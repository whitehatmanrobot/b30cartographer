in the call stack as a critical error.
						throw e;
					}
				}
			}

			return -1;
		} 

		public long Scalar2 ( string SqlStatement ) 
		{ 
			// Simple utility to run a DML statement 
			if ( ( ! Connected ) || ( connection == null ) ) return -1 ; 

			bool fContinue = true;
			SqlCommand cmd = new SqlCommand( ) ;
			cmd.CommandText = SqlStatement ;
			cmd.Connection = connection ;
			cmd.CommandTimeout = m_nTimeoutValue;

			for (int i = 1; true == fContinue && i <= 3; ++i)
			{
				try
				{
					cmd.CommandTimeout *= i;
					object o = cmd.ExecuteScalar( ) ; 

					if ( null == o ) // no data 
					{
						return -1 ; 
					}

					return ( long ) ( o );
				}
		
				catch (SqlException e) 
				{
					SqlErrorCollection myErrors = e.Errors;
					StringBuilder sbErrMsg = new StringBuilder(255);

					sbErrMsg.AppendFormat("Sql statement execution attempt #{0}", i);
					sbErrMsg.AppendFormat("Class: {0}", e.Class);
					sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}." , e.Number, e.Message, e.LineNumber);
					sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", e.Source, e.Server);
					sbErrMsg.AppendFormat("Neither record was written to database.");
					sbErrMsg.AppendFormat("Errors collection contains:");

					if (e.Number > 19 || i > 2)
					{
						for (int nIndex = 0; nIndex < myErrors.Count; nIndex++) 
						{
							sbErrMsg.AppendFormat("Class: {0}", myErrors[nIndex].Class);
							sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}.", myErrors[nIndex].Number, myErrors[nIndex].Message, myErrors[nIndex].LineNumber);
							sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", myErrors[nIndex].Source, myErrors[nIndex].Server);
						}

						fContinue = false;
					}
					else
					{
						fContinue = true;
						Thread.Sleep(m_nBackoffValue * 1000 * i);
					}

					Helper.LogMessage(Helper.MsgType.Err, sbErrMsg.ToString());

					if (false == fContinue)
					{
						// We could not complete the action. We will rethrow the exception so
						// that it is handle up futher in the call stack as a critical error.
						throw e;
					}
				}
			}

			return -1;
		} 

		public SqlDataReader Reader( string Sql )
		{
			bool fContinue = true;
			SqlCommand cmd = new SqlCommand( ) ;
			cmd.CommandText = Sql;
			cmd.Connection = connection ;
			cmd.CommandTimeout = m_nTimeoutValue;

			for (int i = 1; true == fContinue && i <= 3; ++i)
			{
				try
				{
					cmd.CommandTimeout *= i;
					return cmd.ExecuteReader();
				}

				catch (SqlException e) 
				{
					SqlErrorCollection myErrors = e.Errors;
					StringBuilder sbErrMsg = new StringBuilder(255);

					sbErrMsg.AppendFormat("Sql statement execution attempt #{0}", i);
					sbErrMsg.AppendFormat("Class: {0}", e.Class);
					sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}." , e.Number, e.Message, e.LineNumber);
					sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", e.Source, e.Server);
					sbErrMsg.AppendFormat("Neither record was written to database.");
					sbErrMsg.AppendFormat("Errors collection contains:");

					if (e.Number > 19 || i > 2)
					{
						for (int nIndex = 0; nIndex < myErrors.Count; nIndex++) 
						{
							sbErrMsg.AppendFormat("Class: {0}", myErrors[nIndex].Class);
							sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}.", myErrors[nIndex].Number, myErrors[nIndex].Message, myErrors[nIndex].LineNumber);
							sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", myErrors[nIndex].Source, myErrors[nIndex].Server);
						}

						fContinue = false;
					}
					else
					{
						fContinue = true;
						Thread.Sleep(m_nBackoffValue * 1000 * i);
					}

					Helper.LogMessage(Helper.MsgType.Err, sbErrMsg.ToString());

					if (false == fContinue)
					{
						// We could not complete the action. We will rethrow the exception so
						// that it is handle up futher in the call stack as a critical error.
						throw e;
					}
				}
			}

			return null;
		}

		public bool Connect 
			( string Server , string Database , string User , string Password ) 
		{ 
			Helper.LogMessage ( Helper.MsgType.Info, "Connecting " + User + " - " + Password + 
				" to " + Database + " on " + Server + "..." ) ; 

			Connected = false ; 
			try 
			{ 
				// Creates a new SQL connection and then opens the connection
				connection = new System.Data.SqlClient.SqlConnection();
				
                
				connection.ConnectionString = "server=" + Server + ";database=" + Database + 
					";Trusted_Connection=true; Integrated Security=SSPI; Packet Size=1024;"; // smaller than usual for faster value inserts  

				if (User != "")
				{
					connection.ConnectionString += "User ID=" + User + ";Password=" + Password + ";";
				}

				connection.Open();

				Connected = true ; 
			} 
			catch (Exception ex) 
			{
				Helper.LogMessage ( Helper.MsgType.Err, "** ERROR ** Database Exception thrown in Connect(): " + ex.ToString());
			}
			return Connected ; 
		} 

		public bool Disconnect ( ) 
		{ 
			Helper.LogMessage ( Helper.MsgType.Info, "Disconnecting from database..." ) ; 

			if ( connection != null ) 
				if ( connection.State != System.Data.ConnectionState.Closed ) 
					connection.Close();
			return true ; 
		} 

		public bool DetectV4Schema ( )
		{
			string Sql = 
				"SELECT     COUNT ( sysobjects.name ) " + 
				" FROM      sysobjects " +
				" WHERE     ( xtype = 'U' ) AND ( " + 
				"  ( name = 'twAggBatches' ) OR " +
				"  ( name = 'twFiles' ) OR " +
				"  ( name = 'twParserErrors' ) OR " +
				"  ( name = 'tfFriends' ) ) "; 

			return ( Scalar ( Sql ) == 4 );
		}

		public int TimeoutValue
		{
			get
			{
				return m_nTimeoutValue;
			}

			set
			{
				m_nTimeoutValue = value;
			}
		}

		public int BackoffValue
		{
			get
			{
				return m_nBackoffValue;
			}

			set
			{
				m_nBackoffValue = value;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\LogUserMonEx\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <string>
#include <vector>
#include <fstream>
#include <iostream>

using namespace std;

// TODO: reference additional headers your program requires here
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\LogUserMonEx\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// LogUserMonEx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\ErrorRec.cs ===
using System;
using xonline.ops.tools.livereports.logparser.logparserlib;

namespace xonline.ops.tools.livereports.logparser.parser 
{

	public class ErrorRec
	{
		int Batch ; 
		int File ; 
		int LineNumber ; 
		DateTime Timestamp ; 
		public string Message ;
		string LogLine ; 

		public ErrorRec ( int _Batch , int _File , int _LineNumber , 
			string _Message , string _LogLine )
		{
			Batch  = _Batch ; 
			File   = _File ; 
			LineNumber  = _LineNumber ; 
			Timestamp = DateTime.Now ; 
			Message = _Message ; 
			LogLine = _LogLine  ; 

			// Trim message and LogLine to 255 chars 
			if ( Message.Length > 255 ) 
				Message = Message.Substring ( 0 , 255 ) ; 
			if ( LogLine.Length > 1000 ) 
				LogLine = LogLine.Substring ( 0 , 1000 ) ; 
		}

        public ErrorRec ( int _Batch, string _Message )
        {
            Batch  = _Batch ; 
            File   = 0 ; 
            LineNumber  = 0 ; 
            Timestamp = DateTime.Now ; 
            Message = _Message ; 
            LogLine = ""  ; 

            // Trim message to 255 chars 
            if ( Message.Length > 255 ) 
                Message = Message.Substring ( 0 , 255 ) ; 
        }

        /*
		public ErrorRec ( string _Message )
		{
			Batch  = 0 ; 
			File   = 0 ; 
			LineNumber  = 0 ; 
			Timestamp = DateTime.Now ; 
			Message = _Message ; 
			LogLine = ""  ; 

			// Trim message to 255 chars 
			if ( Message.Length > 255 ) 
				Message = Message.Substring ( 0 , 255 ) ; 
		}
        */

		public string ToSql ( ) 
		{ 
			return 
				"INSERT INTO twParserErrors " + 
				" ( dtTimestamp , iBatchID, iFileID , iLineNumber, vcMessage, vcLogLine, iCommentID ) " +
				" VALUES ( " + 
				Helper.ToSQL ( Timestamp ) + " , " + 
				Batch.ToString ( ) + " , " + 
				File.ToString ( ) + " , " + 
				LineNumber.ToString ( ) + " , " + 
				Helper.ToSQL ( Message ) + " , " + 
				Helper.ToSQL ( LogLine ) + ", " +
                "0 ) " ;  
		} 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\bulk.cs ===
using System;
using System.IO;
using System.Text ;
using xonline.ops.tools.livereports.logparser.logparserlib;

namespace xonline.ops.tools.livereports.logparser.parser 
{
	public class BulkIns
	{
        private const int ciBufferSize =  65536 * 2;

        private byte [ ] m_abDiskBuffer = new byte [ ciBufferSize ] ; 
        private ASCIIEncoding m_encoder = new ASCIIEncoding ( ) ; 
        private FileStream m_fs;
        private string m_strFile;
        private string m_strTable;
        int m_iIndex;
        uint m_uiCount;


		public BulkIns( string strTable )
		{
            m_iIndex = 0;
            m_uiCount = 0;

            m_strFile = Directory.GetCurrentDirectory() + "\\bi_" + strTable + ".tmp";
            m_strTable = strTable;

			m_fs = File.Open(m_strFile, FileMode.Create ) ;
            m_fs.Close();
		}

        public void AddRecord( object o )
        {
            m_uiCount++;

            string strLine = ((IXLBulkIns)o).ToBulk() + "\r\n";
            int iLength = strLine.Length;

            if ( m_iIndex + iLength >= ciBufferSize )
            {
                FlushToFile();
            }

            m_encoder.GetBytes ( strLine , 0 , iLength , m_abDiskBuffer , m_iIndex ) ; 
            m_iIndex += iLength ; 

        }

        public void Insert ( DatabaseLoader loader )
        {
            if (m_uiCount > 0 )
            {
                FlushToFile();

                string Sql = 
                    "BULK INSERT " + m_strTable + " FROM " + 
                    "'" + m_strFile +  "'" +
                    " WITH ( " + 
                    " FIELDTERMINATOR = ',' , " +
                    " MAXERRORS = 1 , " +
                    " TABLOCK ) " ; 
            
                loader.Execute ( Sql );
            }
        }

        private void FlushToFile( )
        {
            if (m_iIndex > 0)
            {
                m_fs = File.Open(m_strFile, FileMode.Append ) ;

                m_fs.Write( m_abDiskBuffer, 0, m_iIndex ); 
                m_iIndex=0;

                m_fs.Close();
            }
        }

        //TODO: delete the temp file?

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\Friends.cs ===
using System;
using xonline.ops.tools.livereports.logparser.logparserlib;

namespace xonline.ops.tools.livereports.logparser.parser 
{

	public class FriendAction : IComparable  
	{
		DateTime Timestamp ; 
		public long UserId ; 
		public long BuddyId ; 
        int iBatchID;
        
        public enum ActionTypes { Request=1, Accept=2, Remove=3, Reject=4, Block=5, Mute=6, Unmute=7 };
        public ActionTypes Action;

		public int CompareTo ( object o )
		{ 
			return Timestamp.CompareTo ( ( ( FriendAction ) o ).Timestamp ) ; 
		} 

        public FriendAction( Presence_Request_106 request )
        {            
            iBatchID = request.iBatch;
            Timestamp = request.Timestamp ; 
            UserId = request.UserPUID ; 
            BuddyId = request.BuddyID ;
            Action = ActionTypes.Request; //TODO(v4.5): however, requests can unblock!
        }

		public FriendAction( Presence_Delete_107 delete )
		{
            iBatchID = delete.iBatch;
            Timestamp = delete.Timestamp ; 
			UserId = delete.UserPUID ; 
			BuddyId = delete.BuddyID ;
            Action = ActionTypes.Remove;
		}

        public FriendAction( Presence_Accept_108 accept ) 
        {
            iBatchID = accept.iBatch;
            Timestamp = accept.Timestamp ; 
            UserId = accept.UserPUID ; 
            BuddyId = accept.BuddyID ;
            Action = ActionTypes.Accept;
        }

		public FriendAction( Presence_Reject_109 reject )
		{
            iBatchID = reject.iBatch;
            Timestamp = reject.Timestamp ; 
			UserId = reject.UserPUID ; 
			BuddyId = reject.RejectedID ; 
            
            if (reject.iNever > 0)
            {
                Action = ActionTypes.Block; 
            }
            else
            {
                Action = ActionTypes.Reject;
            }
		}

        public FriendAction( Presence_Mute_113 mute ) 
        {
            iBatchID = mute.iBatch;
            Timestamp = mute.Timestamp ; 
            UserId = mute.UserPUID ; 
            BuddyId = mute.BlockPUID ;
            Action = ActionTypes.Mute;
        }

        public FriendAction( Presence_Unmute_114 unmute ) 
        {
            iBatchID = unmute.iBatch;
            Timestamp = unmute.Timestamp ; 
            UserId = unmute.UserPUID ; 
            BuddyId = unmute.BlockPUID ;
            Action = ActionTypes.Unmute;
        }


		public string ToSql ( ) 
		{ 
            string Sql = null;
                 
			Sql = 
				"INSERT INTO tfFriends " +
				" ( iBatchID, biUserID , biFriendUserID , iHourIDCreated , dtCreated, iType ) " +
				" VALUES ( " + 
                iBatchID.ToString ( ) + " , " + 
                UserId.ToString ( ) + " , " + 
				BuddyId.ToString ( ) +  " , " + 
				Helper.ToHourID ( Timestamp ) + " , " + 
				Helper.ToSQL ( Timestamp )  + " , " + 
                (int)Action + " ) " ;
			 
			return Sql ; 
		} 
	}

    public class InviteAction : IComparable
    {
        public enum ActionTypes { Invite=1, InviteAnswerNo=2, InviteAnswerYes=3, InviteAnswerRemove=4, InviteCancel=5 };
        
        public ActionTypes Action;
        DateTime Timestamp;
        int iBatchID;
        public long UserId;
        long BuddyId;
        long lMatchSession;
        
        public InviteAction( Presence_Invite_110 invite)
        {
            Timestamp = invite.Timestamp;
            iBatchID = invite.iBatch;
            UserId = invite.UserPUID;
            BuddyId = 0;
            lMatchSession = invite.MatchSessionID;
            
            Action = ActionTypes.Invite;
        }

        public InviteAction( Presence_Answer_111 answer)
        {
            Timestamp = answer.Timestamp;
            iBatchID = answer.iBatch;
            UserId = answer.UserPUID;
            BuddyId = answer.HostID;
            lMatchSession = answer.MatchSessionID;
            
            switch (answer.Answer)
            {
            case 0:
                Action = ActionTypes.InviteAnswerNo;
                break;
            case 1:
                Action = ActionTypes.InviteAnswerYes;
                break;
            case 2:
                Action = ActionTypes.InviteAnswerRemove; 
                break;
            }
        }

        public InviteAction( Presence_Cancel_112 cancel)
        {
            Timestamp = cancel.Timestamp;
            iBatchID = cancel.iBatch;
            UserId = cancel.UserPUID;
            BuddyId = 0;
            lMatchSession = cancel.MatchSessionID;
            
            Action = ActionTypes.InviteCancel;
        }

        public int CompareTo ( object o )
        { 
            return Timestamp.CompareTo ( ( ( InviteAction ) o ).Timestamp ) ; 
        } 

        public string ToSql ( ) 
        { 
            string Sql = null;
                 
            Sql = 
                "INSERT INTO tfInvites " +
                " ( iBatchID, iHourID, dtCreated, biUserID , biBuddyID , biMatchSession , iInviteType ) " +
                " VALUES ( " + 
                iBatchID.ToString ( ) + " , " + 
                Helper.ToHourID ( Timestamp ) + " , " + 
                Helper.ToSQL ( Timestamp )  + " , " + 
                UserId.ToString ( ) + " , " + 
                BuddyId.ToString ( ) +  " , " + 
                lMatchSession + ", " +
                (int)Action + " ) " ;
			 
            return Sql ; 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\FileRec.cs ===
using System;
using System.Globalization;
using xonline.ops.tools.livereports.logparser.logparserlib; 

namespace xonline.ops.tools.livereports.logparser.parser 
{
	/// <summary>
	/// Summary description for FileRec.
	/// </summary>
	public class FileRec
	{
		public int FileId = 0 ; 
		int Batch ; 
		string Path ; 
		int Length ; 
		DateTime LastWritten ; 
		DateTime Parsed ; 
		int Events ; 
		int Errors ; 

		public FileRec ( int _Batch , string _Path , int _Length , DateTime _LastWritten )
		{
			Batch = _Batch ; 
			Path = _Path ; 
			Length = _Length ; 
			LastWritten = _LastWritten ; 
			Parsed = DateTime.Now ; 
			Events = 0 ; 
			Errors = 0 ; 
		}

		public void Update ( int _Events , int _Errors ) 
		{ 
			Events = _Events ; 
			Errors = _Errors ; 
		} 

		public string ToSql ( ) 
		{ 
			return 
				"INSERT INTO twFiles " + 
				" ( iBatchID, vcFullPath, iLength, dtCreated, dtParsed, iLines, iErrors ) " +
				"VALUES ( " + 
				Batch.ToString ( ) + " , " + Helper.ToSQL ( Path ) + " , " + 
				Length.ToString ( ) + " , " + 
				Helper.ToSQL ( LastWritten ) + " , " + 
				Helper.ToSQL ( Parsed ) + " , " + 
				Events.ToString ( ) + " , " + Errors.ToString ( ) + " ) " ;  
		} 

		public string ToSqlUpdate ( ) 
		{ 
			return 
				"UPDATE twFiles " + 
				" SET iLines = " + Events.ToString ( ) +
				" , iErrors = " + Errors.ToString ( ) +
				" WHERE ( iFileID = " + FileId.ToString ( ) + " ) " ;  
		} 

		public string ToSqlVerify ( ) 
		{ 
            //don't return a record for files that belong to a rolled-back batch
			return 
				" SELECT COUNT ( * ) FROM twFiles, twParserBatches " + 

				" WHERE twFiles.iBatchID = twParserBatches.iBatchID " +
                "   AND ( twFiles.vcFullPath = " + Helper.ToSQL ( Path ) + " ) " + 
				"   AND ( twFiles.iLength = " + Length.ToString ( ) + " ) " + 
				"   AND ( twFiles.dtCreated = " + Helper.ToSQL ( LastWritten ) + " ) " +
                "   AND ( twParserBatches.iPhase <> " + (int)BatchRec.Phases.RolledBack + " ) " ; 
		} 

		public string ToSqlGetId ( ) 
		{ 
			return 
				" SELECT MAX ( iFileID ) FROM twFiles " + 
				" WHERE ( vcFullPath = " + Helper.ToSQL ( Path ) + " ) " + 
				"   AND ( iLength = " + Length.ToString ( ) + " ) " + 
				"   AND ( dtCreated = " + Helper.ToSQL ( LastWritten ) + " ) " ; 
		} 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\GamePresence.cs ===
using System;
using System.Collections;
using System.Text;
using System.Globalization;
using xonline.ops.tools.livereports.logparser.logparserlib;

namespace xonline.ops.tools.livereports.logparser.parser 
{
	/// <summary>
	/// Summary description for GamePresence.
	/// </summary>
    public class GameRecord : IXLBulkIns
    {
        //New=new game record generated in the current parser session
        //Remnant=old game record loaded from the remnant table
        //DirtyNeedsUpdate=game record loaded from remnant, end of game has been updated in this session, but not associated with a session yet (needs update in the remnant table)
        //DirtyNeedsInsert=new or remnant game record that has been associated with a session (insert needed into the tfGames table)
        //Inserted=this game record has been inserted into the tfGames table. If this was originally a remnant record, it still needs to update the remnant table with processed=1
        public enum RecordTypeEnum { New=1, Remnant=2, DirtyNeedsUpdate=3, DirtyNeedsInsert=4, Inserted=5 };

        public RecordTypeEnum m_RecordType;

        public DateTime m_dtStart;
        public DateTime m_dtEnd;
        public long m_lMatchSessionID;
        public long m_lRemnantID;
        public int m_iBatchID;
        public long m_lSessionID;
        public long m_lUserPUID;

        public int m_iCountry;
        public int m_iTitle;


        public GameRecord( long lUserPUID, 
                           long lMatchSessionID, 
                           DateTime dtStart, 
                           DateTime dtEnd, 
                           long lRemnantID, 
                           int iBatchID )
        {
            m_lMatchSessionID = lMatchSessionID;
            m_dtStart = dtStart;
            m_dtEnd = dtEnd;
            m_lRemnantID = lRemnantID;
            m_iBatchID = iBatchID;
            m_lUserPUID = lUserPUID;
            m_RecordType = RecordTypeEnum.Remnant;

        }


        public GameRecord( long lMatchSessionID, DateTime dtStart, int iBatchID, long lUserPUID )
        {
            m_lMatchSessionID = lMatchSessionID;
            m_dtStart = dtStart;
            m_dtEnd = DateTime.Now.AddYears(200); //set end in distant future
            m_lRemnantID = 0;
            m_iBatchID = iBatchID;
            m_lUserPUID = lUserPUID;
            m_RecordType = RecordTypeEnum.New;
        }

        public void CloseGameRecord( DateTime dtEnd )
        {
            m_dtEnd = dtEnd;

            if ( RecordTypeEnum.Remnant == m_RecordType )
            {
                m_RecordType = RecordTypeEnum.DirtyNeedsUpdate;
            }
        }


        
        public string ToSql()
        {
            string Sql = "INSERT into tfUserGames " +
                         " ( biSessionID , iBatchID , biGameID , dtStarted, dtEnded, iDNCountryID, iDNTitleID, biDNUserID ) " +
                         " VALUES ( " + 
                         m_lSessionID.ToString ( ) + " , " + 
                         m_iBatchID.ToString ( ) +  " , " + 
                         m_lMatchSessionID.ToString ( ) +  " , " + 
                         Helper.ToSQL ( m_dtStart ) + " , " + 
                         Helper.ToSQL ( m_dtEnd ) + " , " +
                         m_iCountry + " , " +
                         m_iTitle + " , " +
                         m_lUserPUID + " ) " ; 

        
            return Sql;
        }

        public string ToBulk()
        {
            string str = "";

            if ( RecordTypeEnum.New == m_RecordType )
            {

                str = 
                    "," +
                    m_lUserPUID + "," + 
                    m_iBatchID + "," + 
                    m_lMatchSessionID + "," + 
                    Helper.ToBulk(m_dtStart) + "," + 
                    Helper.ToBulk(m_dtEnd) + "," + 
                    "0,0"; 
            }
            else
            {
                str = 
                    m_lSessionID + "," + 
                    m_iBatchID + "," + 
                    m_lMatchSessionID + "," + 
                    Helper.ToBulk(m_dtStart) + "," + 
                    Helper.ToBulk(m_dtEnd) + "," +
                    m_iCountry + "," +
                    m_iTitle + "," +
                    m_lUserPUID; 
            }
        
            return str;
        }

        

        public string ToSqlInsertRemnant()
        {
            string Sql = "INSERT into twGameRemnants " +
                " ( biUserID , iBatchID, biGameID, dtStart, dtEnd, bProcessed, iUpdatedBatchID ) " +
                " VALUES ( " + 
                m_lUserPUID.ToString ( ) + " , " + 
                m_iBatchID.ToString ( ) +  " , " + 
                m_lMatchSessionID.ToString ( ) +  " , " + 
                Helper.ToSQL ( m_dtStart ) + " , " + 
                Helper.ToSQL ( m_dtEnd ) + 
                ", 0, 0 ) " ; 

        
            return Sql;
        }

        public string ToSqlUpdate()
        {
            string sql = "";

            if ( RecordTypeEnum.Inserted == m_RecordType )
            {
                sql = "UPDATE twGameRemnants SET bProcessed=1, iUpdatedBatchID=" +
                       m_iBatchID.ToString() +
                       " WHERE biRemnantID = " + m_lRemnantID;
            }
            else if ( RecordTypeEnum.DirtyNeedsUpdate == m_RecordType )
            {
                sql = "UPDATE twGameRemnants SET dtEnd = " + Helper.ToSQL( m_dtEnd ) +
                    " WHERE biRemnantID = " + m_lRemnantID;
            }

            return sql;
        }
    }
    
    


    public class GamePresence
	{
        public long m_lUserPUID;
        public ArrayList m_alGameRecords;
        
        public enum AggStates { GameNotOpen, GameOpen };
		public AggStates m_AggState;

        public GamePresence( long lUserPUID )
		{
            m_lUserPUID = lUserPUID;
            m_alGameRecords = new ArrayList();
            m_AggState = AggStates.GameNotOpen;

		}


        private bool IsPlaying( int iState )
        {
            return ( (iState & 0x2) == 0x2 );
        }

        public void AddRecord( DateTime dtStart, DateTime dtEnd, long lUserPUID, long lMatchSessionID, long lRemnantID, int iBatchID)
        {
            //create record from remnants data
            GameRecord gamerec = new GameRecord( lUserPUID, lMatchSessionID, dtStart, dtEnd, lRemnantID, iBatchID );
            m_alGameRecords.Add(gamerec);

            //set game at state 'GameOpen' needed
            if (dtEnd.AddYears(-50) > dtStart) 
            {
                m_AggState = AggStates.GameOpen; 
            }
            else
            {
                m_AggState = AggStates.GameNotOpen; 
            }
            
            //there is an assumption here batches are not parsed out of order, as everywhere else in the logparser


        }

        public void Process( DateTime dt, int iState, long lMatchSessionID, int iBatchID )
        {
            //synthesizes game record from presence logs
            GameRecord gr = null;

            switch (m_AggState)
            {

            case AggStates.GameNotOpen:
                
                if (lMatchSessionID !=0 && IsPlaying(iState) )
                {
                    //first game session for this object
                    gr = new GameRecord( lMatchSessionID, dt, iBatchID, m_lUserPUID );
                    m_alGameRecords.Add(gr);
                    
                    m_AggState = AggStates.GameOpen;
                }
                break;

            case AggStates.GameOpen:

                gr = (GameRecord)m_alGameRecords[m_alGameRecords.Count - 1];

                if ( gr.m_lMatchSessionID == lMatchSessionID )
                {
                    if (!IsPlaying(iState))
                    {
                        //same match session, but is no longer playing. close the game record
                        gr.CloseGameRecord(dt);
                        m_AggState = AggStates.GameNotOpen;
                    }
                }
                else if ( lMatchSessionID !=0 )
                {
                    //new match session-close old game record and open new one
                    gr.CloseGameRecord(dt); 
  
                    gr = new GameRecord( lMatchSessionID, dt, iBatchID, m_lUserPUID );
                    m_alGameRecords.Add(gr);
                }
                else
                {
                    //no longer on a matchsession, close the game record
                    gr.CloseGameRecord(dt);
                    m_AggState = AggStates.GameNotOpen;
                }
                break;

            }
        }

	}

    public class SessionRemnantUpdate
    {
        private static int MAXUPDATESIZE = 500; //maximum number that will be updated in one SQL statement 
        
        private int m_iCount;
        private int m_iBatch;
        private DatabaseLoader m_loader;
        StringBuilder m_sb;


        public SessionRemnantUpdate( DatabaseLoader loader, int iBatch )
        {
            m_iCount = 0;
            m_loader = loader;
            m_iBatch = iBatch;
            m_sb = new StringBuilder( MAXUPDATESIZE * 26 + 100, MAXUPDATESIZE * 26 + 100 );
        }
    
        public void MarkAsProcessed ( long lRemnant )
        {
            if ( 0 == m_iCount++)
            {
                m_sb.Append("UPDATE twSessRemnants SET bProcessed = 1, iUpdatedBatchID = " +
                    m_iBatch.ToString() + " WHERE biRemnantID=" + lRemnant );
            }
            else
            {
                m_sb.Append(" OR biRemnantID=" + lRemnant);
            }

            if (MAXUPDATESIZE == m_iCount )
            {
                UpdateDB();
            }
            
        }

        public void UpdateDB()
        {
            if (m_iCount > 0 )
            {
                m_loader.Execute( m_sb.ToString() );
                m_iCount = 0;
                m_sb.Length = 0;
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\Feedback.cs ===
using System;
using xonline.ops.tools.livereports.logparser.logparserlib;

namespace xonline.ops.tools.livereports.logparser.parser 
{
	/// <summary>
	/// Summary description for Feedback.
	/// </summary>

	public class Feedback_801 : IXLAppLog
	{
		public DateTime	Timestamp ; 
		public long	SendPUID ; 
		public long	TargetPUID ; 
		public int	TitleID ; 
		int			FeedbackType ; 
		public string		NickName ; 

		public int	Batch ; 
        public int iFileID;

		public	Feedback_801 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case 0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case 1 : /* skip line type */ ; break ;
					case 2 : /* skip line description */ ; break ;
					case 3 : SendPUID   = Helper.ToLong ( strItem ) ; break ;
					case 4 : TargetPUID = Helper.ToLong ( strItem ) ; break ;
					case 5 : TitleID  = Helper.ToInt ( strItem ) ; break ;
					case 6 : FeedbackType = Helper.ToInt ( strItem ) ; break ;
					case 7 : NickName = strItem ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 


			if (null == NickName)
			{
				NickName = "";
			}

			Batch	   = -1 ; 
		} 

		public bool IsValid ( ) 
		{ 
			if ( ( Timestamp.Year > 2048 )   || ( Timestamp.Year < 2002 ) ) return false ; 
            if ( 0 == SendPUID ) return false;
            if ( 0 == TitleID ) return false; 
            if ( NickName.Length > 16 ) return false;

			return true ; 
		} 

		public string ToSql ( ) 
		{ 

			string Sql = 
				"INSERT INTO tfFeedback " +  
				"( iBatchID, iHourIDCreated, dtCreated, " + 
				" biAboutUserID, biFromUserID, iFeedbackType , iTitleID, vcNickName ) " +
				" VALUES ( " + ToString ( ) + " ) " ; 
			
            return Sql ; 

		} 

		public override string ToString ( ) 
		{ 
			return
				Batch.ToString ( ) + " , " + 
				Helper.ToHourID ( Timestamp ).ToString ( ) + " , " + 
				Helper.ToSQL ( Timestamp ) + " , " + 
				TargetPUID.ToString ( ) + " , " + 
				SendPUID.ToString ( ) + " , " + 
				FeedbackType.ToString ( ) + " , " + 
				TitleID.ToString ( ) + " , " + 
				Helper.ToSQL ( NickName ) ; 
		}

        public string ToSqlRaw ()
        {
            string str = "INSERT INTO tr801FdbkFeedback" +
                         "( iFileID, dtCurrent, biSendPUID, biTargetPUID, iTitleID, tiFdbkTypeID, vcNickName)" +
                         "VALUES ( " +
                         iFileID + ", " +
                         Helper.ToSQL(Timestamp) + ", " +
                         SendPUID + ", " +
                         TargetPUID + ", " +
                         TitleID + ", " +
                         FeedbackType + ", " +
                         Helper.ToSQL(NickName) + ")";



            return str;
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\MatchMaking.cs ===
using System;
using xonline.ops.tools.livereports.logparser.logparserlib;

namespace xonline.ops.tools.livereports.logparser.parser 
{
	/// <summary>
	/// Summary description for MatchMaking.
	/// </summary>
	public class MatchMaking_SessionInsert_601 : IXLAppLog
	{
		DateTime Timestamp ; 
		long SessionID ; 
		int TitleID   ; 
		string HostXNAAddr ; 
		string SessionKey ; 
		int PublicOpen ; 
		int PrivateOpen ; 
		int PublicFilled ; 
		int PrivateFilled ;
 
        public int iBatch;
        public int iFileID;

		public MatchMaking_SessionInsert_601 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SessionID = Helper.ToLong  ( strItem ) ; break ;
					case  4 : TitleID  = Helper.ToInt ( strItem ) ; break ;
					case  5 : HostXNAAddr = strItem ; break ;
					case  6 : SessionKey = strItem ; break ;
					case  7 : PublicOpen = Helper.ToInt ( strItem ) ; break ;
					case  8 : PrivateOpen = Helper.ToInt ( strItem ) ; break ;
					case  9 : PublicFilled = Helper.ToInt ( strItem ) ; break ;
					case 10 : PrivateFilled = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each
 
            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr601MtchSessioninsert" +
                "( iFileID, dtCurrent, biSessionID, iTitleID, vchostXNAAddr, vcSessionKey, iPublicOpen, iPrivateOpen, iPublicFilled, iPrivateFilled )" +
                "VALUES (" +
                iFileID + ", " +
                Helper.ToSQL( Timestamp ) + ", " +
                SessionID + ", " +
                TitleID + ", " +
                Helper.ToSQL(HostXNAAddr) + ", " +
                Helper.ToSQL(SessionKey) + ", " +
                PublicOpen + ", " +
                PrivateOpen + ", " +
                PublicFilled + ", " +
                PrivateFilled + ")";



            return str;
        }

	}

	public class MatchMaking_SessionUpdate_602 : IXLAppLog
	{
//		Create table Mtch602
//		(
//		CurrentDT datetime null,
//		SessionID bigint null,
//		TitleID   int null,
//		hostXNAddr varchar(100) null,
//		PublicOpen bit not null,
//		PrivateOpen bit not null,
//		PublicFilled bit not null,
//		PrivateFilled bit not null
//		)
		DateTime Timestamp ; 
		long SessionID ; 
		int TitleID   ; 
		string HostXNAAddr ; 
		int PublicOpen ; 
		int PrivateOpen ; 
		int PublicFilled ; 
		int PrivateFilled ; 

        public int iBatch;
        public int iFileID;

		public MatchMaking_SessionUpdate_602 ( string LogLine ) 
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SessionID = Helper.ToLong ( strItem ) ; break ;
					case  4 : TitleID  = Helper.ToInt ( strItem ) ; break ;
					case  5 : HostXNAAddr = strItem ; break ;
					case  6 : PublicOpen = Helper.ToInt ( strItem ) ; break ;
					case  7 : PrivateOpen = Helper.ToInt ( strItem ) ; break ;
					case  8 : PublicFilled = Helper.ToInt ( strItem ) ; break ;
					case  9 : PrivateFilled = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr602MtchSessionupdate" + 
                "( iFileID, dtCurrent, biSessionID, iTitleID, vchostXNAAddr, iPublicOpen, iPrivateOpen, iPublicFilled, iPrivateFilled )" +
                "VALUES (" +
                iFileID + ", " +
                Helper.ToSQL( Timestamp ) + ", " +
                SessionID + ", " +
                TitleID + ", " +
                Helper.ToSQL(HostXNAAddr) + ", " +
                PublicOpen + ", " +
                PrivateOpen + ", " +
                PublicFilled + ", " +
                PrivateFilled + ")";

            return str;
        }
	}

	public class MatchMaking_SessionDelete_603 : IXLAppLog
	{
//		Create table Mtch603
//		(
//		CurrentDT datetime null,
//		SessionID bigint null,
//		TitleID   int null
//		)
		DateTime Timestamp ; 
		long SessionID ; 
		int TitleID   ; 

        public int iBatch;
        public int iFileID;
		
		public MatchMaking_SessionDelete_603 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SessionID = Helper.ToLong ( strItem ) ; break ;
					case  4 : TitleID  = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr603MtchSessiondelete" +
                "( iFileID, dtCurrent, biSessionID, iTitleID )" +
                "VALUES (" +
                iFileID + ", " +
                Helper.ToSQL( Timestamp ) + ", " +
                SessionID + ", " +
                TitleID + ")";

            return str;
        }

	}


	public class MatchMaking_DeadXbox_604 : IXLAppLog
	{
//		Create table Mtch604
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi int null,
//		xboxID   bigint null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int    SGInt  ; 
		int    spi ; 
		long   XboxID ; 

        public int iBatch;
        public int iFileID;

		public MatchMaking_DeadXbox_604 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt = Helper.ToInt ( strItem ) ; break ;
					case  5 : spi = Helper.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Helper.ToLong ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr604MtchDeadxbox" +
                "( iFileID, dtCurrent, vcSG, SGInt, ispi, biMachinePUID )" +
                "VALUES (" +
                iFileID + ", " +
                Helper.ToSQL( Timestamp ) + ", " +
                Helper.ToSQL(SG) + ", " +
                SGInt + ", " +
                spi + ", " +
                XboxID + ", " +
                ")";

            return str;
        }
	}
	public class MatchMaking_DeadSG_605 : IXLAppLog
	{
//		Create table Mtch605
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int    SGInt  ;
 
        public int iBatch;
        public int iFileID;

		public MatchMaking_DeadSG_605 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr605MtchDeadsg" +
                "( iFileID, dtCurrent, vcSG, iSG )" +
                "VALUES (" +
                iFileID + ", " +
                Helper.ToSQL( Timestamp ) + ", " +
                Helper.ToSQL(SG) + ", " +
                SGInt + ")";

            return str;
        }
	}


	public class MatchMaking_Search_606 : IXLAppLog
	{
//		Create table Mtch606
//		(
//		CurrentDT datetime null,
//		TitleID   int null,
//		ProcIndex   int null,
//		NumParams   int null,
//		hr int null,
//		NumResults int null
//		)
		DateTime Timestamp ; 
		int TitleID   ; 
		int ProcIndex   ; 
		int NumParams   ; 
		int hr ; 
		int NumResults ; 

        public int iBatch;
        public int iFileID;

		public MatchMaking_Search_606 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : TitleID    = Helper.ToInt ( strItem ) ; break ;
					case  4 : ProcIndex  = Helper.ToInt ( strItem ) ; break ;
					case  5 : NumParams  = Helper.ToInt ( strItem ) ; break ;
					case  6 : hr = Helper.ToInt ( strItem ) ; break ;
					case  7 : NumResults = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} 
 
            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr606MtchSearch" +
                "( iFileID, dtCurrent, iTitleID, iProcIndex, iNumParams, ihr, iNumResults )" +
                "VALUES (" +
                iFileID + ", " +
                Helper.ToSQL( Timestamp ) + ", " +
                TitleID + ", " +
                ProcIndex + ", " +
                NumParams + ", " +
                hr + ", " +
                NumResults + ")";
        
            return str;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\Notification.cs ===
using System;
using System.Net ;
using System.Collections;
using System.Text;
using xonline.ops.tools.livereports.logparser.logparserlib; 

namespace xonline.ops.tools.livereports.logparser.parser 
{
	/// <summary>
	/// Summary description for Notification.
	/// </summary>
	public class Notification : IComparable, IXLAppLog, IXLBulkIns
	{
		public DateTime	Timestamp ; 
		public int		ClientIP  ; 
		//public string	ClientIPAsString  ; 
		//int				ClientPort   ;   //these three commented out to save memory
		//public int iFileID;
        public long		UserPUID  ; 
		public int		TitleID   ; 
        public long     lRemnantID;

		public int		iBatch ; 
        public bool bDeleteMe;

        public Notification ( DateTime _dtCreated, 
                              long _UserPUID, 
                              int _iIp, 
                              int _iTitleID, 
                              long _lRemnantID )
        {
            Timestamp = _dtCreated;
            UserPUID = _UserPUID;
            ClientIP = _iIp;
            TitleID = _iTitleID;
            lRemnantID = _lRemnantID;
            bDeleteMe = false;
        }

		public Notification ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : /*ClientIPAsString  = strItem ;*/ break ;
					case  4 : ClientIP   = Helper.ToInt ( strItem ) ; break ;
					case  5 : /*ClientPort = Helper.ToInt ( strItem ) ;*/ break ;
					case  6 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  7 : TitleID  = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 


			iBatch	   = -1 ;
            lRemnantID = 0;
            bDeleteMe  = false;
		}

        public bool IsXonWatchIp ( ArrayList alXonWatchIps ) 
        {
            foreach ( XonWatchIp IpRange in alXonWatchIps ) 
            { 
                if ( IpRange.InRange ( ClientIP ) ) 
                    return true ; 
            } ; 
            return false ; 
        } 

		public bool IsValid ( )
		{ 
			if ( ( Timestamp.Year > 2048 )   || ( Timestamp.Year < 2002 ) ) return false ; 

			// IP as string and as integer should be the same 
			// These double casts looks silly but are necessary...
			long IpAsLong = 
				( long ) ( ( ( ulong ) ClientIP & 0x000000ff ) << 24 ) |
				( long ) ( ( ( ulong ) ClientIP & 0x0000FF00 ) <<  8 ) |
				( long ) ( ( ( ulong ) ClientIP & 0x00ff0000 ) >>  8 ) |
				( long ) ( ( ( ulong ) ClientIP & 0xFF000000 ) >> 24 ) ; 
			IPAddress Ip = new IPAddress ( IpAsLong ) ; 
			string IpAsString = Ip.ToString ( ) ; 
			//if ( Ip.ToString ( ) != ClientIPAsString ) return false ; 

            if ( 0 == UserPUID) return false;

			return true ; 
		} 

		public ulong Hash ( )
		{
			return 
				( ( ulong ) ClientIP << 32 ) + 
				( ( ulong ) ( Timestamp.Year - 2000 ) << 24 ) + 
				( ( ulong ) Timestamp.Month << 16 ) + 
				( ( ulong ) Timestamp.Day << 8 ) + 
				  ( ulong ) Timestamp.Hour ; 
		}

		public string ToSqlXonWatchAlert ( )
		{ 

			return 
				"INSERT INTO tfXonWatchAlerts " +  
				"( iBatchID, iHourIDDetected, dtDetected , iIP, " + 
				"  iPort,  biUserID , iTitleID ) " + 
				"VALUES ( " + ToString ( ) + " ) " ; 

		} 

		public override string ToString ( ) 
		{ 
			return
				iBatch.ToString ( ) + " , " + 
				Helper.ToHourID ( Timestamp ).ToString ( ) + " , " + 
				Helper.ToSQL ( Timestamp ) + " , " + 
				ClientIP.ToString ( ) + " , " + 
				"0 , " + 
				UserPUID.ToString ( ) + " , " + 
				TitleID.ToString ( ) ;  
		} 

        public int CompareTo ( object o )
        { 
            return Timestamp.CompareTo ( ( ( Notification ) o ).Timestamp ) ; 
        } 


        public string ToSqlInsert ( )
        {
            string str = " INSERT into twXpnfRemnants " +
                "( dtCreated, biUserID, iIP, iBatchID, ITitleID, bProcessed, iUpdatedBatchID ) VALUES ( " +
                Helper.ToSQL ( Timestamp ) + " , " + 
                UserPUID.ToString() + " , " + 
                ClientIP.ToString() + " , " + 
                iBatch.ToString() + " , " +
                TitleID.ToString() + 
                ", 0, 0)";
        
            return str;
        }

        public string ToSqlUpdate ( )
        {
            string str = " UPDATE twXpnfRemnants SET bProcessed = 1, iUpdatedBatchID = " +
                iBatch.ToString() +
                " WHERE biRemnantID = " + lRemnantID.ToString();
            
            return str;
        }

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr101XpnfAlive ( iFileID, dtCurrent, ClientIPInt, ClientPort, biUserPUID, iTitleID )" +
                         "VALUES (" +
                         "1, " + //bogus FileID
                         Helper.ToSQL ( Timestamp )  + ", " +
                         ClientIP + ", " +
                         "0, " +
                         UserPUID + ", " +
                         TitleID + ")";


            return str;
        }

        public string ToBulk ( )
        {
            string str = 
                "," +
                Helper.ToBulk(Timestamp) + "," + 
                UserPUID + "," + 
                ClientIP + "," + 
                iBatch + "," +
                TitleID + "," + 
                "0,0";

            return str;
        }

	}


    public class NotificationUpdate
    {
        private static int MAXUPDATESIZE = 500; //maximum number that will be updated in one SQL statement 
        
        private int m_iCount;
        private int m_iBatch;
        private DatabaseLoader m_loader;
        StringBuilder m_sb;


        public NotificationUpdate( DatabaseLoader loader, int iBatch )
        {
            m_iCount = 0;
            m_loader = loader;
            m_iBatch = iBatch;
            m_sb = new StringBuilder( MAXUPDATESIZE * 26 + 100, MAXUPDATESIZE * 26 + 100 );
        }
    
        public void MarkAsProcessed ( long lRemnant )
        {
            if ( 0 == m_iCount++)
            {
                m_sb.Append("UPDATE twXpnfRemnants SET bProcessed = 1, iUpdatedBatchID = " +
                    m_iBatch.ToString() + " WHERE biRemnantID=" + lRemnant );
            }
            else
            {
                m_sb.Append(" OR biRemnantID=" + lRemnant);
            }

            if (MAXUPDATESIZE == m_iCount )
            {
                UpdateDB();
            }
            
        }

        public void UpdateDB()
        {
            if (m_iCount > 0 )
            {
                m_loader.Execute( m_sb.ToString() );
                m_iCount = 0;
                m_sb.Length = 0;
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\Presence.cs ===
using System;
using System.Globalization;
using xonline.ops.tools.livereports.logparser.logparserlib;

namespace xonline.ops.tools.livereports.logparser.parser 
{
	/// <summary>
	/// Summary description for Presence.
	/// </summary>
	
    public class Presence_Alive_102 : IXLAppLog, IComparable, IXLBulkIns
	{
		public DateTime Timestamp ; 
		//string SG ;    //comment these six out to save memory
		//int SGInt  ; 
		//int spi ; 
        //int State ; 
        //long MatchSessionID ; 
        //public int iFileID;
        public long XboxID ; 
		public long UserPUID ; 
		public int TitleID ; 
        public int CountryID ;

		public int hr ; 
        public long lRemnantID;
        public int iBatchID;
        public bool bDeleteMe;


        public Presence_Alive_102 ( DateTime _dtCreated, 
                                    long _UserPUID, 
                                    long _XboxID, 
                                    int _iTitleID, 
                                    int _iCountryID,
                                    long _lRemnantID )
        {
            Timestamp = _dtCreated;
            UserPUID = _UserPUID;
            XboxID = _XboxID;
            TitleID = _iTitleID;
            CountryID = _iCountryID;
            lRemnantID = _lRemnantID;
            bDeleteMe = false;
            //iFileID = 0;
        }

		public Presence_Alive_102 ( string LogLine )
		{
            CountryID = -1;
            lRemnantID = 0;
            bDeleteMe = false;

			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : /*SG = strItem ;*/ break ;
					case  4 : /*SGInt  = Helper.ToInt ( strItem ) ;*/ break ;
					case  5 : /*spi  = Helper.ToInt ( strItem ) ;*/ break ;
					case  6 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  8 : TitleID  = Helper.ToInt ( strItem ) ; break ;
					case  9 : /*State = Helper.ToInt ( strItem ) ;*/ break ;
					case 10 : /*MatchSessionID = Helper.ToLong ( strItem ) ;*/ break ;
					case 11 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} 

            iBatchID = -1;
            //iFileID = 0;
		}

        public bool IsValid( )
        {

            if ( 0 == UserPUID ) return false;
            if ( 0 == XboxID ) return false;

            return true ; 
        }

        public int CompareTo ( object o )
        { 
            return Timestamp.CompareTo ( ( ( Presence_Alive_102 ) o ).Timestamp ) ; 
        }
 
        public string ToSqlInsert ( )
        {
            string str = " INSERT into twSessRemnants " +
                         "( dtCreated, biUserID, biMachineID, iBatchID, iTitleID, iCountryID, bProcessed, iUpdatedBatchID ) VALUES ( " +
                         Helper.ToSQL ( Timestamp ) + " , " + 
                         UserPUID.ToString() + " , " + 
                         XboxID.ToString() + " , " + 
                         iBatchID.ToString() + " , " +
                         TitleID.ToString() + " , " +
                         CountryID.ToString() + 
                         ", 0, 0)";
        
            return str;
        }

        public string ToSqlUpdate ( )
        {
            string str = "UPDATE twSessRemnants SET bProcessed = 1, iUpdatedBatchID = " +
                         iBatchID.ToString() +
                         " WHERE biRemnantID = " + lRemnantID.ToString();

            return str;
        }


        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr102PresAlive" +
                         "( iFileID, dtCurrent, iSG, ispi, biMachinePUID, biUserPUID, iTitleID, istate, biSessionID, ihr )" +
                         " VALUES ( " +
                         "1, " + //bogus fileID
                         Helper.ToSQL ( Timestamp ) + ", " +
                         "0, " +
                         "0, " +
                         XboxID + ", " +
                         UserPUID+ ", " +
                         TitleID + ", " +
                         "0, " +
                         "0, " +
                         hr + ")";

            return str;
        }

        public string ToBulk ( )
        {

            string str = 
                "," +
                Helper.ToBulk(Timestamp) + "," + 
                UserPUID + "," + 
                XboxID + "," + 
                iBatchID + "," +
                TitleID + "," +
                CountryID + "," +
                "0,0";

            return str;
        }

	}

	public class Presence_Killed_103 : IXLAppLog, IComparable, IXLBulkIns
	{
		public DateTime Timestamp ; 
		public long UserPUID ;
        public long XboxID;
		public int  TitleID ; 
		//int  State ;    //these two are commented out to save memory 
        //public int iFileID;
        public long MatchSessionID ; 
		public long Duration ; 

		public long Playing = 0 ; 
		public int  Games = 0 ; 
		public int  IP = 0 ; 
        public int iCountry = -1; //default to unknown country (for phantom users)

		public int	  iBatch ; 


		public Presence_Killed_103 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken ) 
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  4 : TitleID  = Helper.ToInt ( strItem ) ; break ;
					case  5 : /*State = Helper.ToInt ( strItem ) ;*/ break ;
					case  6 : MatchSessionID = Helper.ToLong ( strItem ) ; break ;
					case  7 : Duration = Helper.ToLong ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

			iBatch	   = -1 ;
            XboxID     = 0;
            //iFileID = 0;
		}

		public bool IsValid ( ) 
		{ 
			if ( ( Timestamp.Year > 2048 )   || ( Timestamp.Year < 2002 ) ) return false ; 
			if ( ( Duration > 2000000000 ) || ( Duration < 0 ) ) return false ; //2000000000ms = 23+ days 

            if ( 0 == UserPUID ) return false;

			return true ; 
		} 

		public bool IsZero ( ) 
		{ 
			return ( 0 == Duration ) ; 
		} 
		
		public string ToSql ( ) 
		{ 
			string Sql = 
				"INSERT INTO tfUserSessions " +  
				"( iBatchID, iHourIDEnded, dtStarted, dtEnded, " + 
				" biUserID, biMachineID, iIP, iTitleID, iOnlineTime, iDNGames, iDNPlayingTime, iDNCountryID ) " +
				"VALUES ( " + ToString ( ) + " ) " ; 
			
            return Sql ; 
		} 

        public string ToSqlSelect ( )
        {
            return "Select MAX(biSessionID) from tfUserSessions"; //TODO: should be "select @@Identity from tfUserSessions", but I couldn't get the returned value to cast to an int, long, or ulong
        }

		public override string ToString ( ) 
		{ 
			int SecondsOnline  = ( int ) ( ( ( double ) Duration + 500.0 ) / 1000.0 ) ; //round up
			int SecondsPlaying = ( int ) ( ( ( double ) Playing  + 500.0 ) / 1000.0 ) ; //round up 
			return
				iBatch.ToString ( ) + " , " + 
				Helper.ToHourID ( Timestamp ).ToString ( )  + " , " + 
				Helper.ToSQL ( Timestamp.AddSeconds( - SecondsOnline ) ) + " , " + 
                Helper.ToSQL ( Timestamp ) + " , " + 
				UserPUID.ToString ( ) + " , " + 
				XboxID.ToString ( ) + " , " + 
                IP.ToString ( ) + " , " + 
				TitleID.ToString ( ) + " , " + 
				SecondsOnline.ToString ( ) + " , " + 
				Games.ToString ( ) + " , " + 
				SecondsPlaying.ToString ( ) + " , " +
                iCountry;
		}
 
        public int CompareTo ( object o )
        { 
            //sort primarily by usrPUID, secondarily by time
            int iRet = UserPUID.CompareTo( ( ( Presence_Killed_103 ) o ).UserPUID );

            if ( 0 == iRet )
            {
                iRet = Timestamp.CompareTo ( ( ( Presence_Killed_103 ) o ).Timestamp ) ; 
            }
            
            return iRet;
        } 

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr103PresKilled" +
                         "( iFileID, dtCurrent, biUserPUID, iTitleID, iState, biMatchSessionID,  biDuration ) VALUES (" +
                         "1, " + //bogus fileID
                         Helper.ToSQL( Timestamp ) + ", " +
				         UserPUID.ToString ( ) + ", " + 
				         TitleID.ToString ( ) + ", " + 
		                 "0, " +
                         MatchSessionID + ", " +
                         Duration + ")";

            return str;
        }

        public string ToBulk ( )
        {
            int SecondsOnline  = ( int ) ( ( ( double ) Duration + 500.0 ) / 1000.0 ) ; //round up
            int SecondsPlaying = ( int ) ( ( ( double ) Playing  + 500.0 ) / 1000.0 ) ; //round up 

            string str = iBatch + ", " +
                         Helper.ToHourID ( Timestamp ) + "," + 
				         Helper.ToBulk(Timestamp.AddSeconds( - SecondsOnline )) + "," + 
                         Helper.ToBulk(Timestamp) + "," +
                         UserPUID + "," +
                         XboxID + "," + 
                         IP + "," + 
                         TitleID + "," + 
                         SecondsOnline + "," + 
                         Games + "," + 
                         SecondsPlaying + "," +
                         iCountry;

            return str;
        }

	}



	public class Presence_DeadUser_104 : IXLAppLog
	{

		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		long UserPUID ; 
		int hr ; 
        public int iFileID;

		public Presence_DeadUser_104 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Helper.ToInt ( strItem ) ; break ;
					case  5 : spi  = Helper.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  8 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each
 

            iFileID=0;
		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr104PresDeaduser" +
                "( iFileID, dtCurrent, iSG, ispi, biMachinePUID, biUserPUID,  ihr ) VALUES (" +
                iFileID + ", " +
                Helper.ToSQL( Timestamp ) + ", " +
                SGInt + ", " + 
                spi + ", " + 
                XboxID + ", " +
                UserPUID + ", " +
                hr + ")";



            return str;
        }

	}

	public class Presence_Nickname_105 : IXLAppLog
	{
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		long UserPUID ; 
		string NickName ; 
		int hr ; 
        public int iFileID;


		public Presence_Nickname_105 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Helper.ToInt ( strItem ) ; break ;
					case  5 : spi  = Helper.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  8 : NickName = strItem ; break ;
					case  9 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 


            iFileID = 0;
		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr105PresNickname" +
                "( iFileID, dtCurrent, iSG, ispi, biMachinePUID, biUserPUID,  vcNickName, ihr ) VALUES (" +
                iFileID + ", " +
                Helper.ToSQL( Timestamp ) + ", " +
                SGInt + ", " + 
                spi + ", " + 
                XboxID + ", " +
                UserPUID + ", " +
                Helper.ToSQL(NickName) + ", " +
                hr + ")";

            return str;
        }
	}

	public class Presence_Request_106 : IXLAppLog
	{
		public DateTime Timestamp ; 
		//string SG ;  //these five are commented out to save memory
		//int SGInt ; 
		//int spi   ; 
		//long XboxID ; 
        //public int iFileID;
        public long UserPUID ; 
		public long BuddyID ; 
		string BuddyAcctName ; 
		public int hr ;

        public int iBatch;


		public Presence_Request_106 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : /*SG = strItem ;*/ break ;
					case  4 : /*SGInt  = Helper.ToInt ( strItem ) ;*/ break ;
					case  5 : /*spi    = Helper.ToInt ( strItem ) ;*/ break ;
					case  6 : /*XboxID = Helper.ToLong ( strItem ) ;*/ break ;
					case  7 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  8 : BuddyID = Helper.ToLong ( strItem ) ; break ;
					case  9 : BuddyAcctName = strItem ; break ;
					case 10 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each
 
            //iFileID=0;
            iBatch = -1;

		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr106PresAdd" +
                         "( iFileID, dtCurrent, iSG, ispi, biMachinePUID, biSendPUID, biBuddyPUID, vcBuddyAcctName, ihr) " +
                         "VALUES ( " +
                         "1, " + //bogus fileID
                         Helper.ToSQL( Timestamp ) + ", " +
                         "0, " +
                         "0, " +
                         "0, " +
                         UserPUID + ", " +
                         BuddyID + ", " +
                         Helper.ToSQL(BuddyAcctName) + ", " +
                         hr + " )";

            return str;
        }
	}


	public class Presence_Delete_107 : IXLAppLog
	{
		public DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		public long UserPUID ; 
		public long BuddyID ; 
		public int hr ; 
        public int iFileID;
        public int iBatch;
		
		public Presence_Delete_107 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Helper.ToInt ( strItem ) ; break ;
					case  5 : spi  = Helper.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  8 : BuddyID = Helper.ToLong ( strItem ) ; break ;
					case  9 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

            iFileID = 0;
            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str =  "INSERT INTO tr107PresDelete  " + 
                "( iFileID, dtCurrent, iSG, ispi, biMachinePUID, biUserPUID, biBuddyPUID, ihr ) " +
                "VALUES ( " +
                iFileID + ", " +
                Helper.ToSQL(Timestamp) + ", " +
                SGInt + ", " +
                spi + ", " +
                XboxID + ", " +
                UserPUID + ", " +
                BuddyID + ", " +
                hr + ")";

            return str;
        }

	}

	public class Presence_Accept_108 : IXLAppLog
	{
		public DateTime Timestamp ; 
		//string SG ;   //these four are commented out to save memory
		//int SGInt ; 
		//int spi   ; 
		//long XboxID ; 
		public long UserPUID ; 
		public long BuddyID ; 
		public int hr ; 
        //public int iFileID;
        public int iBatch;

		public Presence_Accept_108 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : /*SG = strItem ;*/ break ;
					case  4 : /*SGInt  = Helper.ToInt ( strItem ) ;*/ break ;
					case  5 : /*spi    = Helper.ToInt ( strItem ) ;*/ break ;
					case  6 : /*XboxID = Helper.ToLong ( strItem ) ;*/ break ;
					case  7 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  8 : BuddyID = Helper.ToLong ( strItem ) ; break ;
					case  9 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

            //iFileID = 0;
            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str =  "INSERT INTO tr108PresAccept  " + 
                "( iFileID, dtCurrent, iSG, ispi, biMachinePUID, biUserPUID, biBuddyPUID, ihr ) " +
                "VALUES ( " +
                "1, " + //bogus FileID
                Helper.ToSQL(Timestamp) + ", " +
                "0, " +
                "0, " +
                "0, " +
                UserPUID + ", " +
                BuddyID + ", " +
                hr + ")";

            return str;
        }
	}

	public class Presence_Reject_109 : IXLAppLog
	{

		public DateTime Timestamp ; 
		//string SG ; //these four are commented out to save memory
		//int SGInt ; 
		//int spi   ; 
		//long XboxID ; 
		public long UserPUID ; 
		public long RejectedID ; 
		public int iNever ; 
		public int hr ; 
        public int iFileID;
        public int iBatch;

		public Presence_Reject_109 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : /*SG = strItem ;*/ break ;
					case  4 : /*SGInt  = Helper.ToInt ( strItem ) ;*/ break ;
					case  5 : /*spi  = Helper.ToInt ( strItem ) ;*/ break ;
					case  6 : /*XboxID = Helper.ToLong ( strItem ) ;*/ break ;
					case  7 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  8 : RejectedID = Helper.ToLong ( strItem ) ; break ;
					case  9 : iNever = Helper.ToInt ( strItem ) ; break ;
					case 10 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each
 
            iFileID = 0;
            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str =  "INSERT INTO tr109PresReject  " + 
                "( iFileID, dtCurrent, iSG, ispi, biMachinePUID, biUserPUID, biBuddyPUID, iNever, ihr ) " +
                "VALUES ( " +
                iFileID + ", " +
                Helper.ToSQL(Timestamp) + ", " +
                "0, " +
                "0, " +
                "0, " +
                UserPUID + ", " +
                RejectedID + ", " +
                iNever + ", " +
                hr + ")";

            return str;
        }
	}

	public class Presence_Invite_110 : IXLAppLog
	{
//		Create table Pres110
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		UserPUID bigint null,
//		TitleID int null,
//		MatchSessionID bigint null,
//		NumInvitee int null,
//		hr int null
//		)
		public DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		public long UserPUID ; 
		public int  TitleID ; 
		public long MatchSessionID ; 
		int  NumInvitee ; 
		public int hr ;
        public int iFileID;
        public int iBatch;

		public Presence_Invite_110 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Helper.ToInt ( strItem ) ; break ;
					case  5 : spi  = Helper.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  8 : TitleID  = Helper.ToInt ( strItem ) ; break ;
					case  9 : MatchSessionID = Helper.ToLong ( strItem ) ; break ;
					case 10 : NumInvitee = Helper.ToInt ( strItem ) ; break ;
					case 11 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each
 
            iFileID = 0;
            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str =  "INSERT INTO tr110PresInvite  " + 
                "( iFileID, dtCurrent, iSG, ispi, biMachinePUID, biUserPUID, iTitleID, biSessionID, iNumInvitee , ihr ) " +
                "VALUES (" +
                iFileID + ", " +
                Helper.ToSQL(Timestamp) + ", " +
                SGInt + ", " +
                spi + ", " +
                XboxID + ", " +
                UserPUID + ", " +
                TitleID + ", " +
                MatchSessionID + ", " +
                NumInvitee + ", " +
                hr + ")";

            return str;
        }
	}

	public class Presence_Answer_111 : IXLAppLog
	{
//		create table Pres111
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		UserPUID bigint null,
//		HostID bigint null,
//		MatchSessionID bigint null,
//		Answer int null,
//		hr int null
//		)
		public DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		public long UserPUID ; 
		public long HostID ; 
		public long MatchSessionID ; 
		public int Answer ; 
		public int hr ; 
        public int iFileID;
		public int iBatch;

		public Presence_Answer_111 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Helper.ToInt ( strItem ) ; break ;
					case  5 : spi  = Helper.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  8 : HostID = Helper.ToLong ( strItem ) ; break ;
					case  9 : MatchSessionID = Helper.ToLong ( strItem ) ; break ;
					case 10 : Answer = Helper.ToInt ( strItem ) ; break ;
					case 11 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each
 
            iFileID = 0;
            iBatch = -1;
		}

        public bool IsValid()
        {
            if ( 0 == XboxID ) return false;
            if ( 0 == UserPUID ) return false;

            return true;
        }

        public string ToSqlRaw ( )
        {
            string str =  "INSERT INTO tr111PresAnswer  " + 
                "( iFileID, dtCurrent, iSG, ispi, biMachinePUID, biUserPUID, biHostPUID, biSessionID, iAnswer, ihr ) " +
                "VALUES (" +
                iFileID + ", " +
                Helper.ToSQL(Timestamp) + ", " +
                SGInt + ", " +
                spi + ", " +
                XboxID + ", " +
                UserPUID + ", " +
                HostID + ", " +
                MatchSessionID + ", " +
                Answer + ", " +
                hr + ")";

            return str;
        }
	}

	public class Presence_Cancel_112 : IXLAppLog
	{
//		create table Pres112
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		UserPUID bigint null,
//		MatchSessionID bigint null,
//		NumInvitee int null,
//		hr int null
//		)
		public DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		public long UserPUID ; 
		public long MatchSessionID ; 
		int NumInvitee ; 
		public int hr ;
        public int iFileID;
        public int iBatch;
		
		public Presence_Cancel_112 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Helper.ToInt ( strItem ) ; break ;
					case  5 : spi  = Helper.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Helper.ToLong ( strItem ) ; break ;
                    case  8 : MatchSessionID = Helper.ToLong ( strItem ) << 32; break;
                    case  9 : MatchSessionID = MatchSessionID | Helper.ToLong ( strItem ); break;
					case 10 : NumInvitee = Helper.ToInt ( strItem ) ; break ;
					case 11 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each
 
            iFileID = 0;
            iBatch = -1;
            //MatchSessionID = 0; //TODO(v5): presence bug is truncating the matchmaking session, so set it to 0
		}

        public string ToSqlRaw ( ) 
        {
            string str =  "INSERT INTO tr112PresCancel  " + 
                          "( iFileID, dtCurrent, iSG, ispi, biMachinePUID, biUserPUID, biSessionID, iNumInvitee, ihr ) " +
                          "VALUES (" +
                          iFileID + ", " +
                          Helper.ToSQL(Timestamp) + ", " +
                          SGInt  + ", " +
                          spi + ", " +
                          XboxID + ", " +
                          UserPUID + ", " +
                          MatchSessionID + ", " +
                          NumInvitee + ", " +
                          hr + ")";

            return str;
        }
	}


	public class Presence_Mute_113 : IXLAppLog
	{
//		create table Pres113
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		UserPUID bigint null,
//		BlockPUID bigint null,
//		hr int null
//		)
		public DateTime Timestamp ; 
		//string SG ;   //these five are commented out to save memory
		//int SGInt ; 
		//int spi   ; 
		//long XboxID ; 
        //public int iFileID;
        public long UserPUID ; 
		public long BlockPUID ; 
		public int hr ; 

        public int iBatch;

		public Presence_Mute_113 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : /*SG = strItem ;*/ break ;
					case  4 : /*SGInt  = Helper.ToInt ( strItem )*/ ; break ;
					case  5 : /*spi  = Helper.ToInt ( strItem )*/ ; break ;
					case  6 : /*XboxID = Helper.ToLong ( strItem )*/ ; break ;
					case  7 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  8 : BlockPUID = Helper.ToLong ( strItem ) ; break ;
					case  9 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each
 
            //iFileID=0;
            iBatch=-1;
		}

        public string ToSqlRaw ( )
        {
            string str =  "INSERT INTO tr113PresBlock  " + 
                          "( iFileID, dtCurrent, iSG, ispi, biMachinePUID, biUserPUID, biBlockPUID, ihr ) " +
                          "VALUES (" +
                          "1, " + //bogus fileID
                          Helper.ToSQL(Timestamp) + ", " +
                          "0, " +
                          "0, " +
                          "0, " +
                          UserPUID + ", " +
                          BlockPUID + ", " +
                          hr + ")";

            return str;
        }

	}

	public class Presence_Unmute_114 : IXLAppLog
	{
//		create table Pres114
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		UserPUID bigint null,
//		BlockPUID bigint null,
//		hr int null
//		)
		public DateTime Timestamp ; 
		//string SG ;   //these five are commented out to save memory
		//int SGInt ; 
		//int spi   ; 
		//long XboxID ; 
        //public int iFileID;
        public long UserPUID ; 
		public long BlockPUID ; 
		public int hr ; 

        public int iBatch;

		public Presence_Unmute_114 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : /*SG = strItem ;*/ break ;
					case  4 : /*SGInt  = Helper.ToInt ( strItem ) ;*/ break ;
					case  5 : /*spi  = Helper.ToInt ( strItem ) ;*/ break ;
					case  6 : /*XboxID = Helper.ToLong ( strItem ) ;*/ break ;
					case  7 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  8 : BlockPUID = Helper.ToLong ( strItem ) ; break ;
					case  9 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each
 
            //iFileID = 0;
            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str =  "INSERT INTO tr114PresUnblock " + 
                          "( iFileID, dtCurrent, iSG, ispi, biMachinePUID, biUserPUID, biBlockPUID, ihr ) " +
                          "VALUES (" +
                          "1, " +
                          Helper.ToSQL(Timestamp) + ", " +
                          "0, " +
                          "0, " +
                          "0, " +
                          UserPUID + ", " +
                          BlockPUID + ", " +
                          hr + ")";


            return str;
        }
	}

	public class Presence_DeadXbox_115 : IXLAppLog
	{
//		create table Pres115
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		int hr ; 
        public int iFileID;

		public Presence_DeadXbox_115 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Helper.ToInt ( strItem ) ; break ;
					case  5 : spi  = Helper.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case  7 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each
 
            iFileID=0;
		}

        public string ToSqlRaw ( )
        {
            string str =  "INSERT INTO tr115PresDeadxbox " + 
                "( iFileID, dtCurrent, iSG, ispi, biMachinePUID, ihr ) " +
                "VALUES (" +
                iFileID + ", " +
                Helper.ToSQL(Timestamp) + ", " +
                SGInt + ", " +
                spi + ", " +
                XboxID + ", " +
                hr + ")";

            return str;
        }
	}

	public class Presence_DeadSg_116 : IXLAppLog
	{
//		create table Pres116
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		int hr ; 
        public int iFileID;

		public Presence_DeadSg_116 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Helper.ToInt ( strItem ) ; break ;
					case  5 : spi  = Helper.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case  7 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each
 
            iFileID=0;
		}

        public string ToSqlRaw ( )
        {
            string str =  "INSERT INTO tr116PresDeadsg " + 
                "( iFileID, dtCurrent, iSG, ispi, biMachinePUID, ihr ) " +
                "VALUES (" +
                iFileID + ", " +
                Helper.ToSQL(Timestamp) + ", " +
                SGInt + ", " +
                spi + ", " +
                XboxID + ", " +
                hr + ")";

            return str;
        }
	}

	public class Presence_State_117 : IXLAppLog, IComparable
	{
        static int iOrderer = 0;

		public DateTime Timestamp ; 
		//string SG ;     //These five were commented out in order to save memory
		//int SGInt ; 
		//int spi   ;
        //int  Length ; 
		//long XboxID ;
        //public int iFileID;
        public int hr ; 
		public long UserPUID ;
		public int  State ; 
		public long MatchSessionID ; 

        public int Batch;
        public int iOrder;
		
        public Presence_State_117 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : /*SG = strItem ;*/ break ;
					case  4 : /*SGInt  = Helper.ToInt ( strItem ) ;*/ break ;
					case  5 : /*spi  = Helper.ToInt ( strItem ) ;*/ break ;
					case  6 : /*XboxID = Helper.ToLong ( strItem ) ;*/ break ;
					case  7 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  8 : State = Helper.ToInt ( strItem ) ; break ;
					case  9 : MatchSessionID = Helper.ToLong ( strItem ) ; break ;
					case 10 : /*Length  = Helper.ToInt ( strItem ) ;*/ break ;
					case 11 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

           Batch = -1;
           //iFileID = 0;

           iOrder = iOrderer ++; //this overcomes an anomaly in Sort() that can rearrange identical objects from original add sequence
        }

        public Presence_State_117( DateTime _Timestamp, long _UserPUID, int _State, long _MatchSessionID )
        {
            Timestamp = _Timestamp;
            UserPUID = _UserPUID;
            State = _State;
            MatchSessionID = _MatchSessionID;
        }


        public bool IsValid ( )
        {
            if ( 0 == UserPUID) return false;

            return true;
        }


        public int CompareTo ( object o )
        { 
            //sort primarily by sessionID, secondarily by time, thirdly by creation order
            int iRet = UserPUID.CompareTo( ( ( Presence_State_117 ) o ).UserPUID );

            if ( 0 == iRet )
            {
                iRet = Timestamp.CompareTo ( ( ( Presence_State_117 ) o ).Timestamp ) ; 
                
                if ( 0 == iRet )
                {
                    iRet = iOrder.CompareTo( ( ( Presence_State_117 ) o ).iOrder ); 
                }
            }
            
            return iRet;
        } 

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr117PresState  " +
                         "( iFileID, dtCurrent, iSG, ispi, biMachinePUID, biUserPUID, istate, biSessionID, iDataLen, ihr) " +
                         "VALUES ( " +
                         "1, " +     //inserting bogus fileID    
                         Helper.ToSQL ( Timestamp ) + ", " +     
                         "0, " +    
                         "0, " +    
                         "0, " +    
                         UserPUID + ", " +    
                         State + ", " +    
                         MatchSessionID + ", " +    
                         "0, " +    
                         hr + ")";   

            return str;
        }

	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\sps.cs ===
using System;
using xonline.ops.tools.livereports.logparser.logparserlib;
using System.Xml; 
using System.IO;

namespace xonline.ops.tools.livereports.logparser.parser 
{

	// TODO: Each of these objects needs a member integer variale, m_iBatchID,
	// to track the batch that this item belongs to.
    public class Sps_AddRoleAssignment_550
    {
        private DateTime m_Timestamp;

        public Sps_AddRoleAssignment_550( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }


	public class Sps_CreateAccount_551 : IXLAppLog
	{
		private	DateTime m_Timestamp; 
		private long m_lUserPUID; 
		private string m_strGamerTag;
        private string m_strEmail;
		private string m_strFirst;
		private string m_strLast;
		private string m_strAddress;
		private string m_strState;
		private string m_strPostal;
        private string m_strCountry;
		private string m_strPhone;
        private string m_strCity;
        private bool m_bHasChild;
        private string m_strRawGamerTag;

        private string m_strTrackingGuid;

        private string m_strAccountInfoXML="";
        private string m_strPaymentXML="";
        private string m_strErrorXML="";
		private string m_strErrorMsg;

		public string ErrorMsg
		{
			get
			{
				return m_strErrorMsg;
			}
		}

		public string GamerTag
		{
			get
			{
				return m_strGamerTag;
			}
		}

        public int m_iBatchID;
		public int m_iHR;

		public Sps_CreateAccount_551( string LogLine, bool bOld )
		{
			int iHigh=0, iLow=0;


			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{

				//compensate for old logs missing line type
				switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
				{
					case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : /* unimportant field, skip it */ ; break ;
					case  4 : /* unimporant field, skip it */ ; break ;
					case  5 : iHigh = Helper.ToInt (strItem) ; break ;
					case  6 : iLow = Helper.ToInt (strItem) ; break ;
					case  7 : m_strGamerTag = strItem ; break ; 
					case  8 : m_strTrackingGuid = strItem ; break ;
					case  9 : m_strAccountInfoXML = strItem ; break ;
					case 10 : m_strPaymentXML = strItem ; break ;
                    case 11 : m_strErrorXML = strItem; break;
				} ; 
				nToken ++ ; 
			} ; // end for each 

            m_bHasChild = false;
			m_iBatchID	   = -1 ;
			m_lUserPUID = FromIntToPuid( iHigh, iLow );


            ParseAccountInfoXML ( m_strAccountInfoXML );
            ParsePaymentXML ( m_strPaymentXML );
            m_iHR = GetErrorCodeFromXML ( m_strErrorXML );
            
            m_strRawGamerTag = m_strGamerTag;
            if ( m_strGamerTag.ToUpper().EndsWith(".OWNER") )
            {
                //mark as owner account and chop off ".owner" from the end of the gamertag
				// NOTE: It isn't the actual user account. It is the owner account that is associated with
				// the users account as in the case that the user account belongs to a minor.

                m_bHasChild = true;
                m_strGamerTag = m_strGamerTag.Substring(0, m_strGamerTag.Length-6);
            }

		}

		private long FromIntToPuid(int highPart, int lowPart)
		{
			return (long)(((ulong)highPart << 32) | ((ulong)lowPart & 0x00000000FFFFFFFF));
		}

		private void ParseAccountInfoXML ( string XML )
		{
            if ( null == XML || "" == XML )
            {
                return;
            }

            //namespace in xpath implementation is f*cking retarded
            XmlDocument xmldoc = new XmlDocument();
            xmldoc.LoadXml(XML);
            XmlNamespaceManager nsmgr = new XmlNamespaceManager(xmldoc.NameTable);
            nsmgr.AddNamespace("URN", "urn:schemas-microsoft-com:billing-data"); 

            //get first name
            XmlNodeReader xmlnr = new XmlNodeReader (xmldoc.SelectSingleNode("//URN:FirstName",nsmgr));
            if (null != xmlnr)
            {
                xmlnr.Read();
                m_strFirst = xmlnr.ReadString();
            }

            //get last name
            xmlnr = new XmlNodeReader (xmldoc.SelectSingleNode("//URN:LastName",nsmgr));
            if (null != xmlnr)
            {
                xmlnr.Read();
                m_strLast = xmlnr.ReadString();
            }

            //get email
            xmlnr = new XmlNodeReader (xmldoc.SelectSingleNode("//URN:Email",nsmgr));
            if (null != xmlnr)
            {
                xmlnr.Read();
                m_strEmail = xmlnr.ReadString();
            }

            //get phone
            xmlnr = new XmlNodeReader (xmldoc.SelectSingleNode("//URN:Phone",nsmgr));
            if (xmlnr != null)
            {
                string strPrefix = "";
                string strNumber = "";
                string strExt = "";
   
                while (xmlnr.Read())
                {
                    if (xmlnr.NodeType == XmlNodeType.Element )
                    {
                        if (xmlnr.Name == "PhonePrefix" )
                        {
                            strPrefix = "(" + xmlnr.ReadString() + ")";
                        }
                        else if (xmlnr.Name == "PhoneNumber" )
                        {
                            strNumber = xmlnr.ReadString();
                        }
                        else if (xmlnr.Name == "PhoneExtension" )
                        {
                            strExt = " x" + xmlnr.ReadString();
                        }
                    }
                }

                m_strPhone = strPrefix + strNumber + strExt;
            }

            //get address
            xmlnr = new XmlNodeReader (xmldoc.SelectSingleNode("//URN:AddressInfo",nsmgr));
            if (xmlnr != null)
            {
                string []strAddTemp= new string[3];

                while (xmlnr.Read())
                {
                    if (xmlnr.NodeType == XmlNodeType.Element )
                    {
                        if (xmlnr.Name == "City" )
                        {
                            m_strCity = xmlnr.ReadString();
                        }
                        else if (xmlnr.Name == "State" )
                        {
                            m_strState = xmlnr.ReadString();
                        }
                        else if (xmlnr.Name == "PostalCode" )
                        {
                            m_strPostal =  xmlnr.ReadString();
                        }
                        else if (xmlnr.Name == "CountryCode" )
                        {
                            m_strCountry =  xmlnr.ReadString();
                        }
                        else if (xmlnr.Name == "Street1" )
                        {
                            strAddTemp[0] =  xmlnr.ReadString();
                        }
                        else if (xmlnr.Name == "Street2" )
                        {
                            strAddTemp[1] =  xmlnr.ReadString();
                        }
                        else if (xmlnr.Name == "Street3" )
                        {
                            strAddTemp[2] =  xmlnr.ReadString();
                        }
                    }
                }
                
                m_strAddress = strAddTemp[0];

                if (strAddTemp[1] != null)
                {
                    m_strAddress += " " + strAddTemp[1];
                }

                if (strAddTemp[2] != null)
                {
                    m_strAddress += " " + strAddTemp[2];
                }

            }
    
		}

		private void ParsePaymentXML ( string XML )
		{
            if ( null == XML || "" == XML )
            {
                return;
            }

            //Not currently used
		}

        private int GetErrorCodeFromXML ( string XML )
        {
			// If the string is not null, not empty and contains the string
			// "ErrorPackage" then we will assume that it is an XML node.
			if ( XML != null && XML != "" && XML.IndexOf("</ErrorPackage>") > 0)
			{

				XmlDocument xmldoc = new XmlDocument();

				try
				{
					xmldoc.LoadXml(XML);
				}
				catch(Exception e)
				{
					e.GetType();
					return -1;
				}
            
				// Get the error message from the ErrorPackage/ErrorMessage node.
				XmlNodeReader xnrErrorMsg = new XmlNodeReader (xmldoc.SelectSingleNode("//ErrorPackage//ErrorMessage"));

				if (null != xnrErrorMsg)
				{
					xnrErrorMsg.Read();
					m_strErrorMsg = xnrErrorMsg.ReadString();

				}

				// Get the hresult from the ErrorPackage/ErrorHResult node
				XmlNodeReader xmlnr = new XmlNodeReader (xmldoc.SelectSingleNode("//ErrorPackage//ErrorHResult"));

				if (null != xmlnr)
				{
					xmlnr.Read();
					string str = xmlnr.ReadString();

					if ( str.StartsWith("0x") )
					{
						return Convert.ToInt32( str, 16); 
					}
				}
			}
			else if ( XML != null && XML != "")
			{
				// Set the error message member
				m_strErrorMsg = XML;
			}


			// If we made it here the string was one of null, empty or it did not
			// contain the string "ErrorPackage" and was rejected as an XML node.
			// This condition indicates that there was an error or some sort.
            return -1;
        }

		public bool IsValid()
		{ 
			if ( ( m_Timestamp.Year > 2048 )   || ( m_Timestamp.Year < 2002 ) ) return false ; 
			if ( null == m_strGamerTag || m_strGamerTag.Length == 0 || m_strGamerTag.Length > 16 ) return false ; 
			
            if ( null == m_strCity || null == m_strState || null == m_strAddress || null == m_strCountry || null == m_strEmail ||
                 null == m_strPostal || null == m_strPhone || null == m_strFirst || null == m_strLast ) return false;

            if ( m_strState.Length > 63 || m_strCountry.Length > 2 || m_strPostal.Length > 40 ) return false;
            if ( m_strAddress.Length > 127 || m_strFirst.Length > 63 || m_strLast.Length > 63 ) return false;
            if ( m_strGamerTag.Length > 16 || m_strEmail.Length > 128 || m_strCity.Length > 63 ) return false;

			if ( 0 == m_lUserPUID ) return false;

            if ( 36 != m_strTrackingGuid.Length ) return false;

			return true ; 
		} 

		public string ToSql()
		{
			string Sql = "INSERT INTO tdUserInfo ( biPUID, vcGamerTag, vcEmail, vcFirstName, vcLastName, vcAddress, " +
						 "vcCity, cState, vcPostalCode, cCountry, vcPhoneNumber, bHasChild, iBatchID, dtCreated ) " +
						 "VALUES ( " +
						 m_lUserPUID + ", " +
						 Helper.ToSQL(m_strGamerTag) + ", " +
						 Helper.ToSQL(m_strEmail) + ", " +
                         Helper.ToSQL(m_strFirst) + ", " +
						 Helper.ToSQL(m_strLast) + ", " +
						 Helper.ToSQL(m_strAddress) + ", " +
						 Helper.ToSQL(m_strCity) + ", " +
                         Helper.ToSQL(m_strState) + ", " +
						 Helper.ToSQL(m_strPostal) + ", " +
						 Helper.ToSQL(m_strCountry) + ", " +
                         Helper.ToSQL(m_strPhone) + ", " +
                         ((m_bHasChild) ? "1, " : "0, ") +
                         m_iBatchID + ", " +
						 Helper.ToSQL(m_Timestamp) + " )";

			return Sql;
		}

		public string ToSqlRaw()
		{
            string Sql = "INSERT INTO tr551SpsCreateAccount ( dtCreated, biPUID, vcGamerTag, " +
                         "cTrackingGuid, vcPaymentXML, vcAccountInfoXML, vcErrorXML) VALUES ( " +
                         Helper.ToSQL(m_Timestamp) + ", " +
                         m_lUserPUID + ", " +
                         Helper.ToSQL(m_strRawGamerTag) + ", " +
                         Helper.ToSQL(m_strTrackingGuid) + ", " +
           			     Helper.ToSQL(m_strAccountInfoXML) + ", " +
			             Helper.ToSQL(m_strPaymentXML) + ", " +
                         Helper.ToSQL(m_strErrorXML) + " )";          

			return Sql;
		}

	}

    public class Sps_GetAccountInfo_552
    {
        private DateTime m_Timestamp;

        public Sps_GetAccountInfo_552( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }

    public class Sps_UpdateAccountInfo_553
    {
        private DateTime m_Timestamp;

        public Sps_UpdateAccountInfo_553( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }

    public class Sps_AddPaymentInstrument_554
    {
        private DateTime m_Timestamp;

        public Sps_AddPaymentInstrument_554( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 


        }
    }

    public class Sps_GetPaymentInstruments_555
    {
        private DateTime m_Timestamp;

        public Sps_GetPaymentInstruments_555( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }

    public class Sps_UpdatePaymentInstrumentInfo_556
    {
        private DateTime m_Timestamp;

        public Sps_UpdatePaymentInstrumentInfo_556( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }

    public class Sps_RemovePaymentInstrument_557
    {
        private DateTime m_Timestamp;

        public Sps_RemovePaymentInstrument_557( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }

    public class Sps_SwitchPaymentInstruments_558
    {
        private DateTime m_Timestamp;

        public Sps_SwitchPaymentInstruments_558( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }


    public class Sps_PurchaseOffering_559
    {
        private DateTime m_Timestamp;

        public Sps_PurchaseOffering_559( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0;
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }

    public class Sps_CancelSubscription_560
    {
        private DateTime m_Timestamp;

        public Sps_CancelSubscription_560( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }

    public class Sps_GetSubscriptions_561
    {
        private DateTime m_Timestamp;

        public Sps_GetSubscriptions_561( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }

    public class Sps_GetAccountInfo_562
    {
        private DateTime m_Timestamp;

        public Sps_GetAccountInfo_562( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }

    public class Sps_ValidateProvisioningData_563
    {
        private DateTime m_Timestamp;

        public Sps_ValidateProvisioningData_563( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }

    public class Sps_CheckProvisioningStatus_564
    {
        private DateTime m_Timestamp;

        public Sps_CheckProvisioningStatus_564( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }

    public class Sps_ProvisionServices_565
    {
        private DateTime m_Timestamp;

        public Sps_ProvisionServices_565( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }

    public class Sps_DeprovisionServices_566
    {
        private DateTime m_Timestamp;

        public Sps_DeprovisionServices_566( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }

    public class Sps_TestConnection_567
    {
        private DateTime m_Timestamp;

        public Sps_TestConnection_567( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }

    public class Sps_GetKey_568
    {
        private DateTime m_Timestamp;

        public Sps_GetKey_568( string LogLine, bool bOld )
        {

            Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
            int nToken = 0 ;  
            foreach ( string strItem in tokens ) 
            {

                //compensate for old logs missing line type
                switch ( (nToken > 0 && true == bOld) ? nToken+1 : nToken ) 
                {
                case  0 : m_Timestamp = Convert.ToDateTime ( strItem ) ; break ;
                case  1 : /* skip line type */ ; break ;
                case  2 : /* skip line description */ ; break ;

                } ; 
                nToken ++ ; 
            } ; // end for each 

        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\ParserDoc.cs ===
using System;
using System.IO ;
using System.Collections ;
using System.Net ;
using xonline.ops.tools.livereports.logparser.logparserlib;

namespace xonline.ops.tools.livereports.logparser.parser 
{
    //wraps a string containing a file path, but provides sorting on the file name
    public class FilePathSortable : IComparable
    {
        public string m_strPath;

        public FilePathSortable( string strPath )
        {
            m_strPath = strPath;
        }

        public int CompareTo ( object o )
        { 
            string strCmp = ((FilePathSortable)o).m_strPath;

            return m_strPath.Substring(m_strPath.LastIndexOf("\\")+1).CompareTo(
                                            strCmp.Substring(strCmp.LastIndexOf('\\')+1));
        } 
    }


    public class ParserDoc
    {
        ArrayList m_alPresence = new ArrayList ( ) ; 
        Hashtable m_htPresenceFromHash = new Hashtable ( ) ; 

        ArrayList m_alEvents			= new ArrayList ( ) ; 
        Hashtable m_htEventsFromHash    = new Hashtable ( ) ; 

        ArrayList m_alChangedTags       = new ArrayList ( ) ;

        Hashtable m_htUsersFromId       = new Hashtable ( ) ;  //normal,test,internal accounts loaded from logs
        Hashtable m_htXonWatchFromId    = new Hashtable ( ) ;  //xonwatch accounts loaded from logs


        ArrayList      m_alSessions   = new ArrayList ( ) ; 

		ArrayList m_alSpsAccounts = new ArrayList();
		Hashtable m_htSpsAcctsFromHash = new Hashtable();

        ArrayList m_alPurchases  = new ArrayList ( ) ; 
        ArrayList m_alFeedbacks  = new ArrayList ( ) ; 

        ArrayList m_alFriends  = new ArrayList ( ) ;
        ArrayList m_alInvites = new ArrayList ( ) ;

        ArrayList m_alAutoupdateRefs = new ArrayList ();
        ArrayList m_alContentRefs = new ArrayList ();

        DatabaseLoader m_loader = new DatabaseLoader ( ) ; 


        Hashtable m_htUserIds			= null ;  //normal,test,internal,phantom accounts loaded from db
        Hashtable m_htXonwatchUserIds   = null ;  //xonwatch accounts loaded from db
        Hashtable m_htPhantomUserIds    = null ;  //phantom accounts loaded from db. redundantly loaded for improved perf
        Hashtable m_htDiscardTitleIds	= null ;
        Hashtable m_htPhantomTitleIds   = new Hashtable ( ) ;
        Hashtable m_htTitleIds          = null ;
        Hashtable m_htReservedTitleIds  = null ;
        ArrayList m_alXonWatchIps		= null ; 
        Hashtable m_htGamePresence      = null ; 
        Hashtable m_htPresenceAlive     = null ;
        Hashtable m_htNotifications     = null;

        ArrayList m_alNewNotifications = new ArrayList ( ) ; 
		 
        ArrayList m_alFiles = new ArrayList ( ) ;

        ParserBatchRec  m_Batch = null ; 

        FileRec m_CurrentFileRec = null;

        int m_iLastBatch = 0 ;

        int m_iEventCounter = 0 ; 
        int m_iFileCounter = 0 ; 
        int m_iErrorCounter = 0 ; 
        int m_iLineCounter = 0 ; 
        int m_iBlankLineCounter = 0 ;
        
        int m_iGameCounter = 0 ;
        int m_iSessionCounter = 0;

        int m_iZeroSessions = 0;

        int m_iNewPhantomUsers = 0;
		
        ErrorRec m_Error ; 

        //rawlogs objects
        ArrayList m_alRawLogs = new ArrayList();


        public ParserDoc()
        {
        }

        public bool ParseLogs ( string Server , string Database , string User , string Password , string Path, int nTimeout, int nBackoff) 
        { 
            // Clear global counters 
            m_iEventCounter = 0 ;
            m_iFileCounter = 0 ; 

            // Create a new batch 
            m_Batch = new ParserBatchRec ( ) ; 
            // connect 
            Helper.LogMessage ( Helper.MsgType.Info, "Connecting to Database..." ) ; 
            if ( ! m_loader.Connect ( Server , Database , User , Password ) ) 
            { 
                Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** Failed to connect to database." ) ; 
                //can't log to database here (obviously)

                return false ; 
            } 
            else 
            { 
                try 
                { 
					// Check set the timeout and backoff timer values
					Helper.LogMessage ( Helper.MsgType.Info, "Connected. Setting timeout and backoff timer values..." ) ; 

					if (60 <= nTimeout)
					{
						m_loader.TimeoutValue = nTimeout;
					}
					else
					{
						Helper.LogMessage ( Helper.MsgType.Info, "/TIMEOUT parameter less than sixty seconds. Defaulting timeout value to 300 seconds" ) ; 
					}

					if (60 <= nBackoff)
					{
						m_loader.BackoffValue = nBackoff;
					}
					else
					{
						Helper.LogMessage ( Helper.MsgType.Info, "/BACKOFF parameter less than sixty seconds. Defaulting back off value to 120 seconds" ) ; 
					}

					// Check that we are running on an V4 database 
					Helper.LogMessage ( Helper.MsgType.Info, "Connected. Checking database schema..." ) ; 
                    
                    if ( false == m_loader.DetectV4Schema() ) 
                    { 
                        // Cant log anything in this old database
                        Helper.LogMessage ( Helper.MsgType.Abort,  "** ERROR ** Obsolete database schema detected. Aborted." ) ; 
                        return false ; 
                    } ; 

                    // Generate the new batch record and get the Id number
                    Helper.LogMessage ( Helper.MsgType.Info, "Creating a new batch record..." ) ; 
                    m_loader.Execute ( m_Batch.ToSqlInsert ( ) ) ; 

                    m_Batch.BatchId = m_loader.Scalar ( m_Batch.ToSqlSelect ( ) ) ;
                    Helper.LogMessage ( Helper.MsgType.Info, "New Batch started with ID #" + m_Batch.Id.ToString ( ) ) ;

                    // Get the previous batch (for seeing if phantom users from previous batch don't get converted)
                    m_iLastBatch =  m_loader.Scalar(
                        "SELECT TOP 1 iBatchID from twParserBatches where iBatchID <  " + m_Batch.BatchId  + " AND iPhase <> " + (int)BatchRec.Phases.RolledBack + " ORDER BY iBatchID DESC" );
                        
                }

                catch ( Exception e ) 
                {
                    Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** Aborted! Exception thrown while checking schema/creating batch record: " + e.Message ) ; 
                    return false;
                }

                //now that we have the batch record inserted, start a new try/catch block that inserts errors into the db on failure
                
                try
                {
                   
                    // load user accounts into memory for fast lookups
                    Helper.LogMessage ( Helper.MsgType.Info, "Loading Existing Accounts IDs in memory..." ) ; 
                    m_htUserIds = Reader.GetUserIds ( m_loader ) ; 

                    //load xonwatch users accounts into memory
                    Helper.LogMessage ( Helper.MsgType.Info, "Loading Xonwatch Users Accounts IDs in memory..." ) ; 
                    m_htXonwatchUserIds = Reader.GetXonwatchUserIds ( m_loader ) ; 

                    //load phantom users accounts into memory
                    Helper.LogMessage ( Helper.MsgType.Info, "Loading Phantom Users Accounts IDs in memory..." ) ; 
                    m_htPhantomUserIds = Reader.GetPhantomUserIds ( m_loader ) ; 


                    // load the list of discard title IDs 
                    Helper.LogMessage ( Helper.MsgType.Info, "Loading Discard Title Ids in memory..." ) ; 
                    m_htDiscardTitleIds = Reader.GetDiscardTitleIds ( m_loader ) ;  

                    // load the list of reserved title IDs 
                    Helper.LogMessage ( Helper.MsgType.Info, "Loading Reserved Title Ids in memory..." ) ; 
                    m_htReservedTitleIds = Reader.GetReservedTitleIds ( m_loader ) ;  
                    
                    // load the list of all title IDs except discard and reserved
                    Helper.LogMessage ( Helper.MsgType.Info, "Loading Title Ids in memory..." ) ;  
                    m_htTitleIds = Reader.GetTitleIds ( m_loader ) ; 

                    // load the list of XonWatch IP address ranges
                    Helper.LogMessage ( Helper.MsgType.Info, "Loading XonWatch IP address ranges in memory..." ) ; 
                    m_alXonWatchIps = Reader.GetXonWatchIps ( m_loader ) ;
 
                    // load session remnants table
                    Helper.LogMessage ( Helper.MsgType.Info, "Loading Session Remnants table in memory..." );
                    m_htPresenceAlive = Reader.GetSessionRemnants ( m_loader, m_Batch.BatchId ) ; 

                    //load xpnf remnants table
                    Helper.LogMessage ( Helper.MsgType.Info, "Loading XPNF Remnants table in memory..." );
                    m_htNotifications = Reader.GetXpnfRemnants ( m_loader, m_Batch.BatchId ) ;                    

                    // load game remnants table
                    Helper.LogMessage ( Helper.MsgType.Info, "Loading Game Remnants table in memory..." ) ;
                    m_htGamePresence = Reader.GetGameRemnants ( m_loader, m_Batch.BatchId ) ;
 

                } 
                catch ( Exception e ) 
                { 
                    m_Error = new ErrorRec ( m_Batch.BatchId, "** ERROR ** Aborted! Exception thrown while loading database records into memory: " + e.Message ) ; 
                    Helper.LogMessage ( Helper.MsgType.Abort, m_Error.Message ) ; 
                    m_loader.Execute ( m_Error.ToSql ( ) ) ;

                    m_Batch.Update ( BatchRec.Phases.Aborted ) ; 
                    m_loader.Execute ( m_Batch.ToSqlUpdate ( ) ) ; 
                    return false;
                } 
                finally 
                { 
                    // nothing for now 
                    // We stay connected to the database, we need that to log progress 
                    // into the twFiles table or errors 
                } ; 
            } 

            // Determines what kind of name Path is and processes it appropriately
            if( File.Exists ( Path ) ) 
            {
                // This path is a file
                m_alFiles.Add( new FilePathSortable(Path) );
            }               
            else if ( Directory.Exists ( Path ) ) 
            {
                // This path is a directory
                EnumerateDirectory ( Path ) ;
            }
            else 
            {
                m_Error = new ErrorRec ( m_Batch.BatchId, "** ERROR ** " + Path + " is not a valid file or directory. Aborted." ) ; 
                Helper.LogMessage ( Helper.MsgType.Abort, m_Error.Message ) ; 
                m_loader.Execute ( m_Error.ToSql ( ) ) ; 

                m_Batch.Update ( BatchRec.Phases.Aborted ) ; 
                m_loader.Execute ( m_Batch.ToSqlUpdate ( ) ) ; 

                return false ; 
            } ; 

            //sort by filename, then process the files one-by-one. Must be sorted for 117's to be processed correctly
            m_alFiles.Sort();

            foreach ( FilePathSortable fps in m_alFiles )
            {
                ProcessFile(fps.m_strPath);
            }

            Helper.LogMessage ( Helper.MsgType.Info, m_iFileCounter + " files processed." ) ;
            Helper.LogMessage ( Helper.MsgType.Info, m_iEventCounter + " events processed." ) ;
            return true ; 
        } 


        public void EnumerateDirectory ( string targetDirectory ) 
        {
            // Process all files in the directory passed in, and recurse on any directories 
            // that are found to process the files they contain. 

            // Process the list of files found in the directory
            string [] fileEntries = Directory.GetFiles ( targetDirectory , "*.log" );
            foreach ( string fileName in fileEntries )
                m_alFiles.Add ( new FilePathSortable(fileName) );

            // Recurse into subdirectories of this directory
            string [] subdirectoryEntries = Directory.GetDirectories ( targetDirectory ) ;
            foreach ( string subdirectory in subdirectoryEntries )
                EnumerateDirectory ( subdirectory );
        }
	        
        public void ProcessFile ( string Path ) 
        {
            
            ++ m_iFileCounter ; 
            if ( m_iFileCounter == 1 ) 
            { 
                //update status to parsing before processing the first file
                m_Batch.Update ( BatchRec.Phases.Parsing ) ; 
                m_loader.Execute ( m_Batch.ToSqlUpdate ( ) ) ; 
            } ; 

            Helper.LogMessage ( Helper.MsgType.Info, "Processing " + Path ) ;

            // Reset the file counters 
            m_iLineCounter = 0 ; 
            m_iBlankLineCounter = 0 ; 
            m_iErrorCounter = 0 ; 

            // Create a stream and gather some information about this file 
            StreamReader reader = null ; 
            FileInfo info = new FileInfo ( Path ) ; 
            DateTime WrittenTo = info.LastWriteTime ; 
            int FileLength = ( int ) info.Length ; 

            // Create a new file record
            m_CurrentFileRec = new FileRec ( m_Batch.Id , Path , FileLength , WrittenTo ) ; 
			
            // Check if we already have an entry in the database 
            int FileCount = m_loader.Scalar ( m_CurrentFileRec.ToSqlVerify ( ) ) ; 
            if ( FileCount != 0 ) 
            { 
                m_Error = new ErrorRec ( m_Batch.BatchId, "** ERROR ** " + Path + " has already been loaded in the database. This file will be ignored." ) ; 
                Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
                m_loader.Execute ( m_Error.ToSql ( ) ) ; 
                return ; 
            } ;
 
            // Add a row in the database
            m_loader.Execute ( m_CurrentFileRec.ToSql ( ) ) ; 
            // retreive this ID 
            m_CurrentFileRec.FileId = m_loader.Scalar ( m_CurrentFileRec.ToSqlGetId ( ) ) ; 
			
            try 
            { 
                reader = new StreamReader ( Path ) ; 
                for ( 
                    string Line = reader.ReadLine ( ) ; 
                    Line != null ; 
                    Line = reader.ReadLine ( ) ) 
                { 
                    m_iLineCounter ++ ; 
                    // All lines MUST start with date and time followed by pipe, and then a 
                    // 3 digit line code followed by another pipe char 
                    // and some data, 4 bytes at least 
					
                    // Date should start with "20", if not, we need to add it 
                    // ( for UACS and maybe more ) 
                    if ( ( Line.Length > 5 ) && 
                        ( Helper.IsNumeric ( Line [ 0 ] ) ) && 
                        ( Helper.IsNumeric ( Line [ 1 ] ) ) )
                    { 
                        if ( ( Line [ 0 ] != '2' ) && 
                            ( Line [ 1 ] != '0' ) &&
                            !Helper.IsNumeric( Line [ 2 ] ) )  
                        { 
                            Line = "20" + Line ; 
                        } ; 
                    } ; 
					
                    // First find the first pipe char, if we can
                    int PipePosition = Line.IndexOf('|');
					
                    if ( 0 > PipePosition )
                    {
                        PipePosition = Line.Length;
                    }
					
                    if ( ( Line.Length > 4 + 14 ) && ( PipePosition + 4 < Line.Length - 1 ) ) 
                    { 
                        int CodePosition = PipePosition + 1 ; 

						if ( ( Helper.IsNumeric ( Line [ CodePosition + 0 ] ) ) && 
							( Helper.IsNumeric ( Line [ CodePosition + 1 ] ) ) && 
							( Helper.IsNumeric ( Line [ CodePosition + 2 ] ) ) && 
							( Line [ CodePosition + 3 ] == '|' ) )
						{ 
							++ m_iEventCounter ; 
							
							//is this faster??
							//int LogCode = Convert.ToInt32( Line.Substring(CodePosition, 3) );
                            
							int LogCode = 
								( Line [ CodePosition + 0 ] & 0x0F ) * 100 + 
								( Line [ CodePosition + 1 ] & 0x0F ) * 10 + 
								( Line [ CodePosition + 2 ] & 0x0F ) ; 
							
                            //try block here to prevent a single corrupted log line from causing file processing to
                            //abort for the whole file
                            try
                            {
                                switch ( LogCode ) 
                                { 
                                case 501  : // Create Account ( UACS 501 ) 
                                    Process_501 ( Line ) ; 
                                    break ; 
                                case 502  : 
                                    Process_502 ( Line ) ;
                                    break;
                                case 503  : 
                                    Process_503 ( Line ) ;
                                    break;
                                case 504  : 
                                    Process_504 ( Line ) ;
                                    break;
                                case 505  : 
                                    Process_505 ( Line ) ;
                                    break;
                                case 506  : //GamerTag Change ( UACS 506 )
                                    Process_506 ( Line ) ;
                                    break ; 
                                    
                                case 507 : //AcceptTOU (UACS 507) (added in sp1)
                                    break;

                                case 508 : //GetPostalCode (UACS 508) (added in sp1)
                                    break;

                                case 550 : //AddRoleAssignment (SPS 550)
                                    break;

                                case 551 :  //CreateAccount ( SPS 551 )
                                    Process_551 ( Line, false );
                                    break;

                                case 552 : //GetAccountInfo (SPS 552)
                                    break;
                                case 553 : //UpdateAccountInfo (SPS 553)
                                    break;
                                case 554 : //AddPaymentInstrument (SPS 554)
                                    break;
                                case 555 : //GetPaymentInstruments (SPS 555)
                                    break;
                                case 556 : //UpdatePaymentInstrumentInfo (SPS 556)
                                    break;
                                case 557 : //RemovePaymentInstrument (SPS 557)
                                    break;
                                case 558 : //SwitchPaymentInstruments (SPS 558)
                                    break;
                                case 559 : //PurchaseOffering (SPS 559)
                                    break;
                                case 560 : //CancelSubscription (SPS 560)
                                    break;
                                case 561 : //GetSubscriptions (SPS 561)
                                    break;
                                case 562 : //GetAccountInfo (SPS 562)
                                    break;
                                case 563 : //ValidateProvisioningData (SPS 563)
                                    break;
                                case 564 : //CheckProvisioningStatus (SPS 564)
                                    break;
                                case 565 : //ProvisionServices (SPS 565)
                                    break;
                                case 566 : //DeprovisionServices (SPS 566)
                                    break;
                                case 567 : //TestConnection (SPS 567)
                                    break;
                                case 568 : //GetKey (SPS 568)
                                    break;


                                case 601  : // ( Mtch 601 ) 
                                    Process_601 ( Line ) ;
                                    break ;
                                case 602  : // ( Mtch 602 )  
                                    Process_602 ( Line ) ;
                                    break ;
                                case 603  : // ( Mtch 603 )  
                                    Process_603 ( Line ) ;
                                    break ;
                                case 604  : // ( Mtch 604 )  
                                    Process_604 ( Line ) ;
                                    break ;
                                case 605  : // ( Mtch 605 )  
                                    Process_605 ( Line ) ;
                                    break ;
                                case 606  : // ( Mtch 606 )  
                                    Process_606 ( Line ) ;
                                    break ;

                                case 801  : // Feedback ( FBCK 801 ) 
                                    Process_801 ( Line ) ; 
                                    break ; 

                                case 901  : // Enumerate (XBOS 901 )
                                    Process_901 ( Line ) ;
                                    break ; 
                                case 902  : // Purchase ( XBOS 902 ) 
                                    Process_902 ( Line ) ; 
                                    break ; 
                                case 903  : // Details (XBOS 903 )
                                    Process_903 ( Line ) ;
                                    break ; 
                                case 904  : // ContentRef (XBOS 904 )
                                    Process_904 ( Line ) ;
                                    break ; 
                                case 905  : // Cancel (XBOS 905 )
                                    Process_905 ( Line ) ;
                                    break ; 
                                case 906  : // VerifyName (XBOS 906 )
                                    Process_906 ( Line ) ;
                                    break ; 
                                case 907  : // AutoUpdateRef (XBOS 907 )
                                    Process_907 ( Line ) ;
                                    break ; 
								case 908  : // ProvisionService (XBOS 908)
									break;
								case 913  : // CheckProvisioningStatus (XBOS 913)
									break;


                                case 101  : // Notification ( Front Door Alive - XPFN 101 ) 
                                    Process_101 ( Line ) ; 
                                    break ; 
                                case 102  :
                                    Process_102 ( Line ); //Presence - Alive 102
                                    break ; 
                                case 103  : // End of Session ( Killed - Presence 103 )  
                                    Process_103 ( Line ) ; 
                                    break ; 
                                case 104  :  
                                    Process_104 ( Line );
                                    break ;
                                case 105  : 
                                    Process_105 ( Line );
                                    break ; 
                                case 106  : // Presence : Friend request
                                    Process_106 ( Line ) ;
                                    break;
                                case 107  : // Presence : Friend delete 
                                    Process_107 ( Line ) ; 
                                    break ; 
                                case 108  : // Presence : Friend Accept 
                                    Process_108 ( Line ) ; 
                                    break ; 
                                case 109  : // Presence : Friend reject
                                    Process_109 ( Line ) ; 
                                    break ; 
                                case 110  : 
                                    Process_110( Line );
                                    break ; 
                                case 111  : 
                                    Process_111( Line );
                                    break ; 
                                case 112  : 
                                    Process_112( Line );
                                    break ; 
                                case 113  : // Presence : Block 
                                    Process_113 ( Line ) ; 
                                    break ; 
                                case 114  : // Presence : Unblock 
                                    Process_114 ( Line ) ; 
                                    break ; 
                                case 115  : 
                                    Process_115 ( Line ) ; 
                                    break ; 
                                case 116  : 
                                    Process_116 ( Line ) ; 
                                    break ; 
                                case 117  : // Presence : State
                                    Process_117 ( Line ) ;
                                    break ;

                                    //
                                default : 
                                    ++ m_iErrorCounter ; 
                                    m_Error = new ErrorRec ( m_Batch.Id , m_CurrentFileRec.FileId , m_iLineCounter , 
                                        "** FORMAT WARNING ** Log three digit code is unknown. Ignored." , Line ) ; 
                                    m_loader.Execute ( m_Error.ToSql ( ) ) ; 

                                    Helper.LogMessage ( Helper.MsgType.Err, "** FORMAT WARNING ** Error reading log line (Log three digit code is unknown. Ignored.)  " + Path + " at line #" + m_iLineCounter.ToString ( ) ) ; 

                                    break ;  
                                } ; // end switch 

                            }

                            catch ( OverflowException )
                            {
                                ++m_iErrorCounter;
                                m_Error = new ErrorRec ( m_Batch.Id , m_CurrentFileRec.FileId , m_iLineCounter , 
                                    "** FORMAT ERROR ** Overflow exception encountered. Log line ignored." , Line ) ; 
                                m_loader.Execute ( m_Error.ToSql ( ) ) ; 

                                Helper.LogMessage ( Helper.MsgType.Err, "** FORMAT ERROR ** Error reading log line (Overflow exception encountered. Ignored.)  " + Path + " at line #" + m_iLineCounter.ToString ( ) ) ; 


                            }

                            catch ( FormatException )
                            {
                                ++m_iErrorCounter;
                                m_Error = new ErrorRec ( m_Batch.Id , m_CurrentFileRec.FileId , m_iLineCounter , 
                                    "** FORMAT ERROR ** Format exception encountered. Log line ignored." , Line ) ; 
                                m_loader.Execute ( m_Error.ToSql ( ) ) ; 

                                Helper.LogMessage ( Helper.MsgType.Err, "** FORMAT ERROR ** Error reading log line (Format exception encountered. Ignored.)  " + Path + " at line #" + m_iLineCounter.ToString ( ) ) ; 

                            }

						} 
						else if( Line.EndsWith("|Complete") ) 
						{
							//TODO: hack because SPS logs are missing code#
							if ( Line.Substring(CodePosition).StartsWith("CreateAccount") )
							{
								Process_551(Line, true);
							}
						}
                        //TODO: hack because SPS logs are missing code#... ignore queued accounts creations. A real SPS creation will be done when they are requeued
						else if ( !Line.EndsWith("|Timeout") && !Line.EndsWith("|Blocked") ) 
						{ 
                            ++ m_iErrorCounter ; 
                            m_Error = new ErrorRec ( m_Batch.Id , m_CurrentFileRec.FileId , m_iLineCounter , 
                                "** FORMAT ERROR ** Line should start with date/time, a pipe char, a three digit code." , Line ) ; 
                            m_loader.Execute ( m_Error.ToSql ( ) ) ; 

                            Helper.LogMessage ( Helper.MsgType.Err, "** FORMAT ERROR ** Error reading file (Line should start with date/time, a pipe char, a three digit code, another pipe character. Ignored.) " + Path + " at line #" + m_iLineCounter.ToString ( ) ) ; 

                        } ; 
                    }
                    else 
                    { 
                        string BlankLine = Line.Trim ( ) ; 
                        if ( BlankLine.Length > 1 ) 
                        { 
                            ++ m_iErrorCounter ; 
                            m_Error = new ErrorRec ( m_Batch.Id , m_CurrentFileRec.FileId , m_iLineCounter , 
                                "** FORMAT ERROR ** Line is truncated. Ignored." , Line ) ; 
                            m_loader.Execute ( m_Error.ToSql ( ) ) ; 

                            Helper.LogMessage ( Helper.MsgType.Err, "** FORMAT ERROR ** Error reading file (Line is truncated. Ignored.) " + Path + " at line #" + m_iLineCounter.ToString ( ) ) ; 
                        }
                        else
                        {                            
                            ++ m_iBlankLineCounter ;
                        } ; 
                    } ; 

                    if ( ( m_iErrorCounter == 200 ) || 
                        ( ( m_iErrorCounter == 100 ) && ( m_iLineCounter == 100 ) ) ) 
                    { 
                        // dont piss me off with zillions of errors messages 
                        m_Error = new ErrorRec ( m_Batch.Id , m_CurrentFileRec.FileId , m_iLineCounter , 
                            "** ERROR ** Too many format errors. File Processing Aborted for this file. " , Line ) ; 
                        m_loader.Execute ( m_Error.ToSql ( ) ) ; 
                        
                        Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
                        break;
                    } 
                
                } 
            } 
            catch ( Exception ) 
            { 
                Helper.LogMessage ( Helper.MsgType.Err, "** IO ERROR ** Error reading file " + Path + " at line #" + m_iLineCounter.ToString ( ) + ". Processing of this file prematurely aborted." ) ; 

                m_Error = new ErrorRec ( m_Batch.Id , m_CurrentFileRec.FileId , m_iLineCounter , 
                    "** ERROR ** IO ERROR ** Error reading file-- processing this file prematurely aborted.  " , "" ) ; 
                m_loader.Execute ( m_Error.ToSql ( ) ) ; 
            } 
            finally 
            { 
                if ( reader != null ) 
                    reader.Close ( ) ; 
            } ; 

            Helper.LogMessage ( Helper.MsgType.Info,
                "Complete : " + 
                m_iLineCounter.ToString ( ) + " logged events. " + 
                m_iErrorCounter.ToString ( ) + " Errors. " + 
                m_iBlankLineCounter.ToString ( ) + " Blank lines." ) ; 

            // update our file record in memory
            m_CurrentFileRec.Update ( m_iLineCounter, m_iErrorCounter ) ;
            // update the file record in the database
            m_loader.Execute ( m_CurrentFileRec.ToSqlUpdate ( ) ) ; 
        }

        public void Process_101 ( string Line ) 
        { 
            // Notification ( Front Door Alive - XPFN 101 ) 
                                                                    
            Notification notification = new Notification ( Line ) ; 
            notification.iBatch = m_Batch.Id ;
            //notification.iFileID = m_CurrentFileRec.FileId;

            //make sure log is valid
            if ( !notification.IsValid ( ) ) 
            {
                ++ m_iErrorCounter ; 
                
                m_Error = new ErrorRec( m_Batch.BatchId,
                    "** FORMAT ERROR ** Error reading file. Invalid Xpnf Alive Event at line #" + m_iLineCounter.ToString ( ) );
                
                m_loader.Execute ( m_Error.ToSql ( ) ) ;
                Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
            
                return;
            }

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( notification );
            }


            ArrayList alnoti = (ArrayList)m_htNotifications[ notification.UserPUID];

            if (null == alnoti)
            {
                alnoti = new ArrayList();
                alnoti.Add(notification);

                m_htNotifications.Add(notification.UserPUID, alnoti);
            }
            else
            {
                alnoti.Add(notification);
                alnoti.Sort();
            }

            m_alNewNotifications.Add(notification);
						
        } 

        public void Process_102 ( string Line ) 
        { 
            Presence_Alive_102 pres102 = new Presence_Alive_102 ( Line ); 
            pres102.iBatchID = m_Batch.BatchId; 
            //pres102.iFileID = m_CurrentFileRec.FileId;

            //check if valid first
            if ( !pres102.IsValid ( ) ) 
            {
                ++ m_iErrorCounter ; 
                
                m_Error = new ErrorRec ( m_Batch.BatchId,
                    "** FORMAT ERROR ** Error reading file. Invalid Presence Alive Event at line #" + m_iLineCounter.ToString ( ) ) ;
                
                m_loader.Execute ( m_Error.ToSql ( ) ) ;
                Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
                
                return;
            }

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( pres102 );
            }

            //don't process failures
            if (pres102.hr < 0)
            {
                return;
            }


            ArrayList temparrlist = (ArrayList) m_htPresenceAlive[ pres102.UserPUID ];

            if ( null == temparrlist )
            {     
                temparrlist = new ArrayList();
                temparrlist.Add(pres102); 

                m_htPresenceAlive.Add ( pres102.UserPUID, temparrlist );
            }
            else
            {
                temparrlist.Add(pres102);   
                temparrlist.Sort();
            }
        } 


        public void Process_103 ( string Line ) 
        { 
            // End of Session ( Killed - Presence 103 )  
            // Parse the line 
            Presence_Killed_103 killed = new Presence_Killed_103 ( Line ) ; 
            killed.iBatch = m_Batch.Id ; 
            //killed.iFileID = m_CurrentFileRec.FileId;

            // A new session  
            if ( !killed.IsValid ( ) ) 
            {
                ++ m_iErrorCounter ; 
                
                m_Error = new ErrorRec ( m_Batch.BatchId,
                    "** FORMAT ERROR ** Error reading file. Invalid Killed Alive Event at line #" + m_iLineCounter.ToString ( ) ) ;
                
                m_loader.Execute ( m_Error.ToSql ( ) ) ;
                Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ;                 
                
                return;
            }

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( killed );
            }

            if ( killed.IsZero ( ) ) 
            { 
                m_iZeroSessions ++;
            }
				
            m_alSessions.Add ( killed ) ; //we decided not to filter out short sessions
				
        } 

        public void Process_104 ( string Line ) 
        {
            // Presence DeadUser ( DeadUser - Presence 106 ) 
           
            //add to raw log collection
            if (Parser.bRawLogs)
            {
                Presence_DeadUser_104 deaduser = new Presence_DeadUser_104( Line );
                deaduser.iFileID = m_CurrentFileRec.FileId;

                m_alRawLogs.Add( deaduser );
            }

        }

        public void Process_105 ( string Line ) 
        {
            // Friend Nickname ( Nickname - Presence 106 ) 
           
            //add to raw log collection
            if (Parser.bRawLogs)
            {
                Presence_Nickname_105 nickname = new Presence_Nickname_105( Line );
                nickname.iFileID = m_CurrentFileRec.FileId;
                
                m_alRawLogs.Add( nickname );
            }
        }

        public void Process_106 ( string Line ) 
        { 
            // Friend Request ( Request - Presence 106 )  
            Presence_Request_106 friend = new Presence_Request_106 ( Line ) ; 
            //friend.iFileID = m_CurrentFileRec.FileId;
            friend.iBatch = m_Batch.BatchId;

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( friend );
            }

            //don't process failures
            if (friend.hr < 0)
            {
                return;
            }
            
            FriendAction fa = new FriendAction ( friend ) ;
            m_alFriends.Add ( fa ) ; 
        } 

        public void Process_107 ( string Line ) 
        { 
            // Friend Delete ( Delete - Presence 107 )  
            Presence_Delete_107 friend = new Presence_Delete_107 ( Line ) ; 
            friend.iFileID = m_CurrentFileRec.FileId;
            friend.iBatch = m_Batch.BatchId;

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( friend );
            }

            //don't process failures
            if (friend.hr < 0)
            {
                return;
            }
            
            FriendAction fa = new FriendAction ( friend ) ;
            m_alFriends.Add ( fa ) ; 
        } 

        public void Process_108 ( string Line ) 
        { 
            // Friend Accept ( Accept - Presence 108 )  
            Presence_Accept_108 friend = new Presence_Accept_108 ( Line ) ; 
            //friend.iFileID = m_CurrentFileRec.FileId;
            friend.iBatch = m_Batch.BatchId;

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( friend );
            }

            //don't process failures
            if (friend.hr < 0)
            {
                return;
            }
            
            FriendAction fa = new FriendAction ( friend ) ;
            m_alFriends.Add ( fa ) ; 
        } 

        public void Process_109 ( string Line )
        {
            // Friend Reject ( Reject - Presence 109 )
            Presence_Reject_109 friend = new Presence_Reject_109 ( Line ) ;
            friend.iFileID = m_CurrentFileRec.FileId;
            friend.iBatch = m_Batch.BatchId;

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( friend );
            }

            //don't process failures
            if (friend.hr < 0)
            {
                return;
            }
            
            FriendAction fa = new FriendAction ( friend );


            m_alFriends.Add ( fa );
        }


        
        public void Process_110 ( string Line )
        {
            //Game Invite ( Invite - Presence 110 )
            Presence_Invite_110 friend = new Presence_Invite_110( Line );
            friend.iFileID = m_CurrentFileRec.FileId;
            friend.iBatch = m_Batch.BatchId;
            
            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( friend );
            }

            //don't process failures
            if (friend.hr < 0)
            {
                return;
            }
            
            InviteAction ia = new InviteAction ( friend );
            m_alInvites.Add ( ia );
        }

        public void Process_111 ( string Line ) 
        {
            //Game Invite Answer ( Answer - Presence 111 )
            Presence_Answer_111 friend = new Presence_Answer_111( Line );
            friend.iFileID = m_CurrentFileRec.FileId;
            friend.iBatch = m_Batch.BatchId;           
            

            if (!friend.IsValid() )
            {
                ++ m_iErrorCounter ; 
                
                m_Error = new ErrorRec ( m_Batch.BatchId,
                    "** FORMAT ERROR ** Error reading file. Invalid Invite Answer Event at line #" + m_iLineCounter.ToString ( ) ) ;
                
                m_loader.Execute ( m_Error.ToSql ( ) ) ;
                Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 

                return;
            }
           

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( friend );
            }

            //don't process failures
            if (friend.hr < 0)
            {
                return;
            }
            
            InviteAction ia = new InviteAction ( friend );            
            m_alInvites.Add ( ia );
            
        }

        public void Process_112 ( string Line )
        {
            //Cancel Game Invite ( Cancel - Presence 112 )

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                Presence_Cancel_112 friend = new Presence_Cancel_112( Line );
                friend.iFileID = m_CurrentFileRec.FileId;
                friend.iBatch = m_Batch.BatchId;
                
                m_alRawLogs.Add( friend );
            }

            //don't process failures
            //if (friend.hr < 0)
            //{
            //    return;
            //}

            //TODO(v5) xboxliveV1 112 logs are not conforming to the spec and are also spamming the service (bug#23299)
            //So... don't record these for right now         
            
            //InviteAction ia = new InviteAction ( friend );            
            //m_alInvites.Add ( ia );
            
        }
        

        public void Process_113 ( string Line ) 
        { 
            // Mute ( Mute - Presence 113 )  
            Presence_Mute_113 mute = new Presence_Mute_113 ( Line ) ; 
            //mute.iFileID = m_CurrentFileRec.FileId;
            mute.iBatch = m_Batch.BatchId;

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( mute );
            }

            //don't process failures
            if (mute.hr < 0)
            {
                return;
            }
            
            
            FriendAction fa = new FriendAction ( mute ) ;             
            m_alFriends.Add ( fa ) ; 
            
        } 

        public void Process_114 ( string Line ) 
        { 
            // Unmute ( Unmute - Presence 114 )  
            Presence_Unmute_114 mute = new Presence_Unmute_114 ( Line ) ; 
            //mute.iFileID = m_CurrentFileRec.FileId;
            mute.iBatch = m_Batch.BatchId;

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( mute );
            }

            //don't process failures
            if (mute.hr < 0)
            {
                return;
            }
            
            FriendAction fa = new FriendAction ( mute ) ;
            m_alFriends.Add ( fa ) ; 
        } 

        public void Process_115 ( string Line ) 
        {
            //add to raw log collection
            if (Parser.bRawLogs)
            {
                Presence_DeadXbox_115 deadxbox = new Presence_DeadXbox_115(Line);
                deadxbox.iFileID = m_CurrentFileRec.FileId;
                
                m_alRawLogs.Add( deadxbox );
            }
        }

        public void Process_116 ( string Line ) 
        {
            Presence_DeadSg_116 deadsg = new Presence_DeadSg_116( Line );
            deadsg.iFileID = m_CurrentFileRec.FileId;

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( deadsg );
            }
        }

        public void Process_117 ( string Line )
        {
            // State ( State - Presence 117 )
            Presence_State_117 state = new Presence_State_117 ( Line ) ;
            state.Batch = m_Batch.Id ; 
            //state.iFileID = m_CurrentFileRec.FileId;

            if (!state.IsValid() )
            {
                ++ m_iErrorCounter ; 
                
                m_Error = new ErrorRec ( m_Batch.BatchId,
                    "** FORMAT ERROR ** Error reading file. Invalid State Event at line #" + m_iLineCounter.ToString ( ) ) ;
                
                m_loader.Execute ( m_Error.ToSql ( ) ) ;
                Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
                
                return;
            }

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( state );
            }

            //don't process failures
            if ( state.hr < 0 )
            {
                return;
            }
            
            //TODO: what if there are no games? investigate whether reduced performance is the only consequence    
            
            GamePresence gamepres = (GamePresence)m_htGamePresence[ state.UserPUID ]; 

            if ( null == gamepres )
            {
                gamepres = new GamePresence( state.UserPUID );
                
                gamepres.Process( state.Timestamp, state.State, state.MatchSessionID, m_Batch.BatchId ); 
                m_htGamePresence.Add( state.UserPUID, gamepres );
            }
            else
            {
                gamepres.Process( state.Timestamp, state.State, state.MatchSessionID, m_Batch.BatchId );
            }

        }

        public void Process_501 ( string Line ) 
        { 
            // Create Account ( UACS 501 )
            Uacs_CreateAccount_501 account = new Uacs_CreateAccount_501 ( Line ) ;  
            account.Batch = m_Batch.Id ;
            //account.iFileID = m_CurrentFileRec.FileId;

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( account );
            }

            //don't process account creation failures
            if ( account.hr < 0)
            {
                return;
            }

            //not checking titleID for this because all user creation is done in the dash title. Title is kept in UserAccounts table because v2 of the dash may use a different titleID?

            //check for invalid date
            if ( !account.IsValid ( ) ) 
            {
                ++ m_iErrorCounter ; 
                
                m_Error = new ErrorRec ( m_Batch.BatchId,
                    "** FORMAT ERROR ** Error reading file. Invalid Account Creation Event at line #" + m_iLineCounter.ToString ( ) ) ;
                
                m_loader.Execute ( m_Error.ToSql ( ) ) ;
                Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
		        
                return;
            }
				
            if ( account.IsXonWatchAccount ( ) ) 
            { 
                if ( m_htPhantomUserIds.ContainsKey ( account.UserPUID ) )
                {
                    //phantom user found, make sure he gets updated into tdUserAccounts as xonwatch user
                    account.AccountType = Uacs_CreateAccount_501.AccountTypeEnum.PhantomToXonwatch;
                            
                    m_htXonWatchFromId.Add ( account.UserPUID, account );
                        
                    m_htUserIds.Remove( account.UserPUID );
                    m_htPhantomUserIds.Remove( account.UserPUID ); //removed so we can later find phantom users not converted
                }
                else if ( m_htXonWatchFromId.ContainsKey ( account.UserPUID )  ) 
                {
                    // check for local duplicate xonwatch account IDs 
                    //error, user already exists in batch
                    m_Error = new ErrorRec ( m_Batch.BatchId, "** ERROR ** Xonwatch account ID (" + account.UserPUID +
                        ")  already exists in batch at line # " + m_iLineCounter.ToString ( ) + 
                        ". Do 2 identical log files have different names?" ) ;
 
                    Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
                    m_loader.Execute ( m_Error.ToSql ( ) ) ; 
                }
                else if ( m_htXonwatchUserIds.ContainsKey ( account.UserPUID ) )
                {
                    // check for duplicate xonwatch account IDs in DB 
                    //error, user already exists in database
                    m_Error = new ErrorRec ( m_Batch.BatchId,  "** ERROR ** Xonwatch account ID (" + account.UserPUID +
                        ")  already exists in database at line # " 
                        + m_iLineCounter.ToString ( ) + ". Has this file been parsed already?" ) ;
 
                    Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
                    m_loader.Execute ( m_Error.ToSql ( ) ) ; 
                }
                else if ( m_htUserIds.ContainsKey ( account.UserPUID ) )
                {
                    //error, user already exists in database as a non-xonwatch user. this should *never* happen
                    m_Error = new ErrorRec ( m_Batch.BatchId,  "** ERROR ** Xonwatch account ID (" + account.UserPUID +
                        ") already exists in database at line # " 
                        + m_iLineCounter.ToString ( ) + " as a non-xonwatch user. Weird!" ) ;
 
                    Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
                    m_loader.Execute ( m_Error.ToSql ( ) ) ; 
                }                    
                else
                {
                    m_htXonWatchFromId.Add ( account.UserPUID , account ) ;
                }
                  
            } 
            else 
            { 

                // check for duplicates or phantom accounts
                if ( m_htPhantomUserIds.ContainsKey ( account.UserPUID ) )
                {
                    //phantom user found, make sure he gets updated into tdUserAccounts
                    account.AccountType = Uacs_CreateAccount_501.AccountTypeEnum.PhantomToNormal; 
                    m_htUsersFromId.Add ( account.UserPUID , account );

                    m_htUserIds.Remove( account.UserPUID );
                    m_htPhantomUserIds.Remove( account.UserPUID ); //removed so we can later find phantom users not converted
                }
                else if ( m_htUsersFromId.ContainsKey ( account.UserPUID ) ) 
                { 
                    //error, user already exists in batch
                    m_Error = new ErrorRec ( m_Batch.BatchId,  "** ERROR ** Account ID (" + account.UserPUID +
                        ")  already exists in batch at line # " 
                        + m_iLineCounter.ToString ( ) + ". Do 2 identical log files have different names?" ) ;
 
                    Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
                    m_loader.Execute ( m_Error.ToSql ( ) ) ; 
                } 
                else if ( m_htUserIds.ContainsKey( account.UserPUID ) )
                { 
                    //error, user already exists in database
                    m_Error = new ErrorRec ( m_Batch.BatchId,  "** ERROR ** Account ID (" + account.UserPUID +
                        ")  already exists in database at line # " 
                        + m_iLineCounter.ToString ( ) + ". Has this file been parsed already?" ) ;
 
                    Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
                    m_loader.Execute ( m_Error.ToSql ( ) ) ; 

                }
                else
                {
                    m_htUsersFromId.Add ( account.UserPUID , account ) ;
                }

               
            } 
				 
        } 

        public void Process_502 ( string Line ) 
        { 
            // ReserveName ( UACS 502 )

            if (Parser.bRawLogs)
            {
                Uacs_ReserveName_502 reserve = new Uacs_ReserveName_502 ( Line ) ;  
                reserve.iBatch = m_Batch.Id ;
                reserve.iFileID = m_CurrentFileRec.FileId;

                m_alRawLogs.Add( reserve );
            }
        }

        public void Process_503 ( string Line ) 
        { 
            // VerifyVoucher ( UACS 503 )

            if (Parser.bRawLogs)
            {
                Uacs_VerifyVoucher_503 verify = new Uacs_VerifyVoucher_503 ( Line ) ;  
                verify.iBatch = m_Batch.Id ;
                verify.iFileID = m_CurrentFileRec.FileId;
                
                m_alRawLogs.Add( verify );
            }
        }

        public void Process_504 ( string Line ) 
        { 
            // SetPaymentInfo ( UACS 504 )

            if (Parser.bRawLogs)
            {
                Uacs_SetPaymentInfo_504 setpayment = new Uacs_SetPaymentInfo_504 ( Line ) ;  
                setpayment.iBatch = m_Batch.Id ;
                setpayment.iFileID = m_CurrentFileRec.FileId;
                
                m_alRawLogs.Add( setpayment );
            }
        }

        public void Process_505 ( string Line ) 
        { 
            // RestoreAccount ( UACS 505 )

            if (Parser.bRawLogs)
            {
                Uacs_RestoreAccount_505 restore = new Uacs_RestoreAccount_505 ( Line ) ;  
                restore.iBatch = m_Batch.Id ;
                restore.iFileID = m_CurrentFileRec.FileId;
                
                m_alRawLogs.Add( restore );
            }
        }

        public void Process_506 ( string Line ) 
        { 
            // Change GamerTag ( UACS 506 )
            Uacs_ChangeGamerTag_506 changetag = new Uacs_ChangeGamerTag_506 ( Line ) ;  
            changetag.iBatch = m_Batch.Id ;
            changetag.iFileID = m_CurrentFileRec.FileId;

            if ( !changetag.IsValid ( ) ) 
            {
                ++ m_iErrorCounter ; 
                
                m_Error = new ErrorRec ( m_Batch.BatchId,
                    "** FORMAT ERROR ** Error reading file. Invalid Gamertag Change Event at line #" + m_iLineCounter.ToString ( ) ) ;
                
                m_loader.Execute ( m_Error.ToSql ( ) ) ;
                Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
		        
                return;
            }


            if (changetag.hr >= 0)
            {
                m_alChangedTags.Add (changetag);
            }

            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( changetag );
            }

        }

		public void Process_551( string Line, bool bOld )
		{
			Sps_CreateAccount_551 spsacct = new Sps_CreateAccount_551 ( Line, bOld );
			spsacct.m_iBatchID = m_Batch.BatchId;

			//check for invalid data
			if ( !spsacct.IsValid ( ) ) 
			{
				++ m_iErrorCounter ; 
                
				m_Error = new ErrorRec ( m_Batch.BatchId,
					"** FORMAT ERROR ** Error reading file. Invalid Sps Account Creation Event at line #" + m_iLineCounter.ToString ( ) ) ;
                
				m_loader.Execute ( m_Error.ToSql ( ) ) ;
				Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
		        
				return;
			}

			if (Parser.bRawLogs)
			{
				m_alRawLogs.Add( spsacct );
			}

            // We will only log successes that we don't know about. We are assuming that multiple
			// occurances of account creation events happen within a short time period.
			if (spsacct.m_iHR >= 0 && false == m_htSpsAcctsFromHash.ContainsKey(spsacct.GamerTag))
			{
				m_alSpsAccounts.Add( spsacct );
				m_htSpsAcctsFromHash.Add(spsacct.GamerTag, spsacct);
			}
			else
			{
				m_Error = new ErrorRec ( m_Batch.BatchId,
					"** WARNING ** Invalid Sps Account Creation Event at line #" + m_iLineCounter.ToString ( ) + "Message: " + spsacct.ErrorMsg);
                
				m_loader.Execute ( m_Error.ToSql ( ) ) ;
				Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
			}

		}
			

        public void Process_601( string Line ) 
        { 
            // Session Insert ( UACS 601 )

            if (Parser.bRawLogs)
            {
                MatchMaking_SessionInsert_601 sessins = new MatchMaking_SessionInsert_601 ( Line ) ;  
                sessins.iBatch = m_Batch.Id ;
                sessins.iFileID = m_CurrentFileRec.FileId;
                
                m_alRawLogs.Add( sessins );
            }
        }

        public void Process_602( string Line ) 
        { 
            // Session Update ( UACS 602 )

            if (Parser.bRawLogs)
            {
                MatchMaking_SessionUpdate_602 sessupd = new MatchMaking_SessionUpdate_602 ( Line ) ;  
                sessupd.iBatch = m_Batch.Id ;
                sessupd.iFileID = m_CurrentFileRec.FileId;
                
                m_alRawLogs.Add( sessupd );
            }
        }

        public void Process_603( string Line ) 
        { 
            // Session Delete ( UACS 603 )

            if (Parser.bRawLogs)
            {
                MatchMaking_SessionDelete_603 sessdel = new MatchMaking_SessionDelete_603 ( Line ) ;  
                sessdel.iBatch = m_Batch.Id ;
                sessdel.iFileID = m_CurrentFileRec.FileId;
                
                m_alRawLogs.Add( sessdel );
            }
        }

        public void Process_604( string Line ) 
        { 
            // DeadXbox ( UACS 604 )

            if (Parser.bRawLogs)
            {
                MatchMaking_DeadXbox_604 deadxbox = new MatchMaking_DeadXbox_604 ( Line ) ;  
                deadxbox.iBatch = m_Batch.Id ;
                deadxbox.iFileID = m_CurrentFileRec.FileId;
                
                m_alRawLogs.Add( deadxbox );
            }
        }

        public void Process_605( string Line ) 
        { 
            // DeadSG ( UACS 605 )

            if (Parser.bRawLogs)
            {
                MatchMaking_DeadSG_605 deadsg = new MatchMaking_DeadSG_605 ( Line ) ;  
                deadsg.iBatch = m_Batch.Id ;
                deadsg.iFileID = m_CurrentFileRec.FileId;

                m_alRawLogs.Add( deadsg );
            }
        }

        public void Process_606( string Line ) 
        { 
            // Search ( UACS 606 )

            if (Parser.bRawLogs)
            {
                MatchMaking_Search_606 search = new MatchMaking_Search_606 ( Line ) ;  
                search.iBatch = m_Batch.Id ;
                search.iFileID = m_CurrentFileRec.FileId;
                
                m_alRawLogs.Add( search );
            }
        }


        public void Process_801 ( string Line ) 
        { 
            // Feedback ( FBCK 801 ) 
            Feedback_801 feedback = new Feedback_801 ( Line ) ;  
            feedback.Batch = m_Batch.Id ;
            feedback.iFileID = m_CurrentFileRec.FileId;

            //special exception to shoving everything into rawlogs tables
            //livetest(thrasher) feedbacks to collect peer-to-peer connectivity data is not stored
            if ( feedback.NickName.IndexOf(',') > 0 && feedback.NickName.Length >150 )
            {
                return;
            }

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( feedback );
            }


            if ( feedback.IsValid() )
            {
                //it is safe to discard on discard titleID here
                if ( !m_htDiscardTitleIds.ContainsKey ( feedback.TitleID ) )
                {
                    m_alFeedbacks.Add ( feedback ) ; 
                }
            }
            else
            {
                ++ m_iErrorCounter ; 
                
                m_Error = new ErrorRec ( m_Batch.BatchId, m_CurrentFileRec.FileId, m_iLineCounter,
                    "** FORMAT ERROR ** Error reading file. Invalid Feedback Event at line #" + m_iLineCounter.ToString ( ), Line ) ;
                
                m_loader.Execute ( m_Error.ToSql ( ) ) ;
                Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
            }
			 
        } 

        public void Process_901 ( string Line ) 
        { 
            // Enumerate( XBOS 901 ) 
        
            //add to raw log collection
            if (Parser.bRawLogs)
            {
                Xbos_Enumerate_901 enumerate = new Xbos_Enumerate_901 ( Line ) ; 
                enumerate.iBatch = m_Batch.Id ; 
                enumerate.iFileID = m_CurrentFileRec.FileId;
                
                m_alRawLogs.Add( enumerate );
            }
            
        }

        public void Process_902 ( string Line ) 
        { 
            // Purchase ( XBOS 902 ) 
            Xbos_Purchase_902 purchase = new Xbos_Purchase_902 ( Line ) ; 
            purchase.Batch = m_Batch.Id ; 
            purchase.iFileID = m_CurrentFileRec.FileId;

            //add to raw log collection
            if (Parser.bRawLogs)
            {
                m_alRawLogs.Add( purchase );
            }

            if ( purchase.IsValid() )
            {
                if ( purchase.hr >= 0 )
                {
                    //it is safe to discard on discard titleID here
                    if ( !m_htDiscardTitleIds.ContainsKey ( purchase.TitleID ) )
                    {
                        m_alPurchases.Add ( purchase ) ; 
                    }
                }
            }
            else
            {
                ++ m_iErrorCounter ; 
                
                m_Error = new ErrorRec ( m_Batch.BatchId,
                    "** FORMAT ERROR ** Error reading file. Invalid Purchase Event at line #" + m_iLineCounter.ToString ( ) ) ;
                
                m_loader.Execute ( m_Error.ToSql ( ) ) ;
                Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 
            }
			 
        } 
        
        public void Process_903 ( string Line ) 
        { 
            // Details( XBOS 903 ) 
        
            //add to raw log collection
            if (Parser.bRawLogs)
            {
                Xbos_Details_903 details = new Xbos_Details_903 ( Line ) ; 
                details.iBatch = m_Batch.Id ; 
                details.iFileID = m_CurrentFileRec.FileId;

                m_alRawLogs.Add( details );
            }         
        }

        public void Process_904 ( string Line ) 
        { 
            // ContentRef ( XBOS 904 ) 
            Xbos_ContentRef_904 contentref = new Xbos_ContentRef_904 ( Line ) ; 
            contentref.iBatch = m_Batch.Id ; 
            //contentref.iFileID = m_CurrentFileRec.FileId;
        
            if ( !contentref.IsValid() )
            {
                ++ m_iErrorCounter ; 
                
                m_Error = new ErrorRec ( m_Batch.BatchId,
                    "** FORMAT ERROR ** Error reading file. Invalid ContentRef Event at line #" + m_iLineCounter.ToString ( ) ) ;
                
                m_loader.Execute ( m_Error.ToSql ( ) ) ;
                Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 

                return;
            }

            //add to raw log collection
            if (Parser.bRawLogs)
            {    
                m_alRawLogs.Add( contentref ); 
            }
            
            //it is safe to discard on discard titleID here
            if ( !m_htDiscardTitleIds.ContainsKey ( contentref.TitleID ) )
            {           
                m_alContentRefs.Add ( contentref );
            }
        }

        public void Process_905 ( string Line ) 
        { 
            // Cancel ( XBOS 905 ) 
        
            //add to raw log collection
            if (Parser.bRawLogs)
            {
                Xbos_Cancel_905 cancel = new Xbos_Cancel_905 ( Line ) ; 
                cancel.iBatch = m_Batch.Id ; 
                cancel.iFileID = m_CurrentFileRec.FileId;
                
                m_alRawLogs.Add( cancel );
            }        
        }

        public void Process_906 ( string Line ) 
        { 
            // VerifyName ( XBOS 906 ) 
        
            //add to raw log collection
            if (Parser.bRawLogs)
            {
                Xbos_VerifyName_906 verify = new Xbos_VerifyName_906 ( Line ) ; 
                verify.iBatch = m_Batch.Id ; 
                verify.iFileID = m_CurrentFileRec.FileId;
                
                m_alRawLogs.Add( verify );
            }         
        }

        public void Process_907 ( string Line ) 
        { 
            // AutoUpdateRef ( XBOS 907 ) 
            Xbos_AutoUpdateRef_907 autoupdate = new Xbos_AutoUpdateRef_907 ( Line ) ; 
            autoupdate.iBatch = m_Batch.Id ; 
            //autoupdate.iFileID = m_CurrentFileRec.FileId;        

            if ( !autoupdate.IsValid() )
            {
                ++ m_iErrorCounter ; 
                
                m_Error = new ErrorRec ( m_Batch.BatchId,
                    "** FORMAT ERROR ** Error reading file. Invalid AutoupdateRef Event at line #" + m_iLineCounter.ToString ( ) ) ;
                
                m_loader.Execute ( m_Error.ToSql ( ) ) ;
                Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message ) ; 

                return;
            }

            //add to raw log collection
            if (Parser.bRawLogs)
            {    

                m_alRawLogs.Add( autoupdate );   
            }

            //it is safe to discard on discard titleID here
            if ( !m_htDiscardTitleIds.ContainsKey ( autoupdate.TitleID ) )
            {        
                m_alAutoupdateRefs.Add ( autoupdate );
            }
        }



        //discover any phantom users or titles in the feedback logs 
        public void ProcessFeedback ( )
        {
            for ( int i=0; i < m_alFeedbacks.Count; i++ ) 
            {                   
                Feedback_801 feedback = (Feedback_801)m_alFeedbacks[i];

                //look for unknown titles
                if( !m_htTitleIds.ContainsKey ( feedback.TitleID ) && !m_htReservedTitleIds.ContainsKey ( feedback.TitleID ) )                   
                {
                    //found unknown title, throw an error
                    m_Error = new ErrorRec ( m_Batch.Id,  
                        "**WARNING** Unknown title ID encountered. (" + 
                        feedback.TitleID + ") This title will be inserted as a phantom title." ) ; 
                
                    m_loader.Execute ( m_Error.ToSql ( ) ) ; 
                    Helper.LogMessage ( Helper.MsgType.Warn, m_Error.Message) ; 

                    //put this title on the phantom title list so it will be inserted later
                    m_htPhantomTitleIds.Add ( feedback.TitleID, feedback.TitleID );
    
                    //put this is the main list so it only throws one error per title
                    m_htTitleIds.Add( feedback.TitleID, feedback.TitleID);
                }
       

                //look for phantom users
                if ( !m_htUsersFromId.ContainsKey ( feedback.SendPUID ) && !m_htUserIds.ContainsKey ( feedback.SendPUID ) )   
                {
                    //create a phantom user and log an error when an unknown user is encountered 
                    //this is done during save phase out of necessity

                    if ( !m_htXonwatchUserIds.ContainsKey(feedback.SendPUID )  &&
                        !m_htXonWatchFromId.ContainsKey(feedback.SendPUID )  )
                    {
                    
                        //add phantom user to list so it will get loaded into db
                        Uacs_CreateAccount_501 account = new 
                            Uacs_CreateAccount_501( m_Batch.BatchId, feedback.SendPUID, feedback.Timestamp );
                    
                        m_htUsersFromId.Add ( feedback.SendPUID, account ) ;

                        //error will get logged once for all phantom PUIDs
                        m_iNewPhantomUsers++;

                    }
                    else
                    {
                        //this is a known discard user, remove from sessions list
                        m_alFeedbacks.RemoveAt(i--);
                    }
                                    
                }

            }
        }

		public void DetectXonWatchHacking ( ) 
		{ 
			Helper.LogMessage ( Helper.MsgType.Info, "Checking XonWatch account hacking attempts..." ) ; 
			int AlertCounter = 0 ; 
			
            foreach( Notification notification in m_alNewNotifications )
            {
                
                //check if this is a known xonwatch user
                if ( !m_htXonWatchFromId.ContainsKey( notification.UserPUID )  &&
                     !m_htXonwatchUserIds.ContainsKey( notification.UserPUID ) )
                {
                    //not an xonwatch account, see if this is a know user                     
                    if (  !m_htUsersFromId.ContainsKey ( notification.UserPUID ) && 
                        !m_htUserIds.ContainsKey ( notification.UserPUID ) )
                    {
                        //create a phantom user and log an error when an unknown user is encountered
                        //this is done so that if notification logs outrace uacs logs, we won't lose any

                        //add phantom user to list so it will get loaded into db
                        Uacs_CreateAccount_501 account = new 
                            Uacs_CreateAccount_501( m_Batch.BatchId, notification.UserPUID, notification.Timestamp );
                    
                        m_htUsersFromId.Add ( notification.UserPUID, account ) ;

                        //error will get logged once for all phantom PUIDs
                        m_iNewPhantomUsers++;

                    }

                    continue;
                }

                // check the IP address now 
                if ( ! notification.IsXonWatchIp ( m_alXonWatchIps ) ) 
                { 
					IPAddress ipAddress = new IPAddress(notification.ClientIP);
					Helper.LogMessage ( Helper.MsgType.Warn, ipAddress.ToString() + " is not an Xonwatch IP address. Possible hacking attempt." ) ; 
					m_loader.Execute ( notification.ToSqlXonWatchAlert ( ) ) ; 
                    ++ AlertCounter ; 
                }  
                                               
				
			} 
 
			Helper.LogMessage ( Helper.MsgType.Info, m_alNewNotifications.Count.ToString() + " IP addresses verified." ) ; 
			Helper.LogMessage ( Helper.MsgType.Info, AlertCounter.ToString ( ) + " XonWatch Alert records loaded into database." ) ; 
		} 


        //examine presence alives, look for reserved titles, unknown titles, phantom users
        public void ProcessAlives()
        {
            //TODO: should I filter in this function here on discard titles, xonwatch users?

            ArrayList alPresAlive = new ArrayList(m_htPresenceAlive); 
                
            foreach ( DictionaryEntry de in alPresAlive )
            {
                foreach ( Presence_Alive_102 pres102 in (ArrayList)de.Value )
                {
                    //look for unknown titles
                    if( !m_htTitleIds.ContainsKey ( pres102.TitleID ) && !m_htDiscardTitleIds.ContainsKey ( pres102.TitleID ) )
                    {
                        if ( m_htReservedTitleIds.ContainsKey ( pres102.TitleID ) )
                        {
                            //found reserved title, throw an error
                            m_Error = new ErrorRec ( m_Batch.Id,  
                                "**WARNING** PresAlive encountered on a reserved title ID. (" + 
                                pres102.TitleID + ") Investigate why users are logging on to this title." ) ; 
                    
                            m_loader.Execute ( m_Error.ToSql ( ) ) ; 
                            Helper.LogMessage ( Helper.MsgType.Warn, m_Error.Message) ; 

                        }
                        else
                        {
                            //found unknown title, throw an error
                            m_Error = new ErrorRec ( m_Batch.Id,  
                                "**WARNING** Unknown title ID encountered. (" + 
                                pres102.TitleID + ") This title will be inserted as a phantom title." ) ; 
                    
                            m_loader.Execute ( m_Error.ToSql ( ) ) ; 
                            Helper.LogMessage ( Helper.MsgType.Warn, m_Error.Message) ; 

                            //put this title on the phantom title list so it will be inserted later
                            m_htPhantomTitleIds.Add ( pres102.TitleID, pres102.TitleID );
                        }

                        //put this is the main list so it only throws one error per title
                        m_htTitleIds.Add( pres102.TitleID, pres102.TitleID);
                    }

                    //look for phantom users
                    if ( !m_htUsersFromId.ContainsKey ( pres102.UserPUID ) && 
                                    !m_htUserIds.ContainsKey ( pres102.UserPUID ) )   
                    {
                        //create a phantom user and log an error when an unknown user is encountered 
                        //this is done during save phase out of necessity

                        if ( !m_htXonwatchUserIds.ContainsKey(pres102.UserPUID )  &&
                            !m_htXonWatchFromId.ContainsKey(pres102.UserPUID )  )
                        {
                        
                            //add phantom user to list so it will get loaded into db
                            Uacs_CreateAccount_501 account = new 
                                Uacs_CreateAccount_501( m_Batch.BatchId, pres102.UserPUID, pres102.Timestamp );
                        
                            m_htUsersFromId.Add ( pres102.UserPUID, account ) ;

                            //error will get logged once for all phantom PUIDs
                            m_iNewPhantomUsers++;

                        }

                    }

                }
            }
        }

        //associate country id's with sessions, discard sessions from xonwatch users
        public void ProcessSessions()
        {
   
            for ( int i=0; i < m_alSessions.Count; i++ ) 
            {                   
                Presence_Killed_103 session = (Presence_Killed_103)m_alSessions[i];


                //associate country with user session ( session and games tables are denormalized )
                if ( m_htUsersFromId.ContainsKey ( session.UserPUID ) )
                {
                    session.iCountry = ((Uacs_CreateAccount_501)m_htUsersFromId[ session.UserPUID ]).CountryID;
                }
                else if ( m_htUserIds.ContainsKey ( session.UserPUID ) )   
                {
                    session.iCountry = ((UserInfo)m_htUserIds[ session.UserPUID ]).iCountry;
                }
                else
                {
                    //get rid of discard users here
                    if ( m_htXonwatchUserIds.ContainsKey(session.UserPUID )  ||
                         m_htXonWatchFromId.ContainsKey(session.UserPUID )  )
                    {
                        //this is a known discard user, remove from sessions list
                        m_alSessions.RemoveAt(i--);
                    }
                                        
                }
               
            }

        }

        public void WriteSessions()
        {           
            int iMissingXpnf = 0;

            //BulkIns BISessions = new BulkIns("tfUserSessions");
            BulkIns BIGames = new BulkIns("tfUserGames");

            foreach ( Presence_Killed_103 session in m_alSessions ) 
            { 
                                
                //look for alive messages to add machine acct info
                ArrayList alpresalive = (ArrayList) m_htPresenceAlive[ session.UserPUID ];

                bool bFoundPresAlive = false;

                if ( alpresalive != null )
                {
                    foreach( Presence_Alive_102 pres102 in alpresalive)
                    {
                        //insure presalive between starting and ending of session (with 500 ms cushion added to starting)
                        //this is tricky because alive and killed can occur at the same precise millisecond for two reasons: 
                        //0 length session, or first user logon got kicked when logging on from a second xbox
                        if ( false == pres102.bDeleteMe && pres102.Timestamp <= session.Timestamp && 
                             pres102.Timestamp >= session.Timestamp.AddMilliseconds(-session.Duration-500) &&
                             pres102.TitleID == session.TitleID )
                        {
                            session.XboxID = pres102.XboxID;
                            pres102.bDeleteMe = true;
                            bFoundPresAlive = true;
                            break;
                        }
                    }
                }

                //error here if alive message not found for this session (and this is not a discard titleID)
                if ( !bFoundPresAlive )
                {                    
                    if ( !m_htDiscardTitleIds.ContainsKey ( session.TitleID ) ) 
                    {
                        //TODO(v4.5) document this and other error messages and how to diagnose the problem
                        string str = "** ERROR ** Corresponding Presence Alive not found for a presence killed! Is there a presence log file missing from a batch or an entire batch missing?";
                        
                        Helper.LogMessage ( Helper.MsgType.Err, str ) ; 

                        m_loader.Execute ( new ErrorRec ( m_Batch.Id , str ).ToSql() ) ; 
                    }

                }
                    
                //look for xpnfd alive messages to add IP info
                ArrayList alnoti = (ArrayList) m_htNotifications[ session.UserPUID ];

                bool bFoundXpnfAlive = false;

                if ( alnoti!= null )
                {
                    foreach( Notification noti in alnoti)
                    {
                        //insure xpnf alive between starting and ending of session. in my testing, xpnf alive timestamp
                        //complication #1: xpnf live timestamp is typically up to 150 ms before pres alive, so I cushion at 3.15s to account for latency under stress (and what i've seen in the tukprod logs)
                        //complication #2: when same user logs on twice, the xpnf alive for new session comes before killed for the kicked off session!! xpnf logs are sorted, so this doesn't pose a problem?

                        if ( false == noti.bDeleteMe && noti.Timestamp < session.Timestamp.AddMilliseconds(1150) &&  
                             noti.Timestamp >= session.Timestamp.AddMilliseconds(-session.Duration-3150) &&
                             noti.TitleID == session.TitleID ) 
                        {
                            session.IP = noti.ClientIP;
                            noti.bDeleteMe = true;
                            bFoundXpnfAlive = true;
                            break;
                        }
                    }
                }

                //warning here if xpnf alive message not found for this session (and this is not a discard titleID)
                if ( !bFoundXpnfAlive )
                {                    
                    if ( !m_htDiscardTitleIds.ContainsKey ( session.TitleID ) ) 
                    {
                        iMissingXpnf++;
                    }
                }


                 //add up the games and time playing
                GamePresence gamepres = (GamePresence)m_htGamePresence[ session.UserPUID ];
                
                if ( gamepres != null )
                {
                    foreach( GameRecord gamerec in gamepres.m_alGameRecords)
                    {
                        if ( gamerec.m_RecordType != GameRecord.RecordTypeEnum.New &&
                                gamerec.m_RecordType != GameRecord.RecordTypeEnum.Remnant &&
                                    gamerec.m_RecordType != GameRecord.RecordTypeEnum.DirtyNeedsUpdate )
                        {
                            //game already associated with another session
                            continue;
                        }
                        
                        if ( gamerec.m_dtStart > session.Timestamp ) 
                        {
                            //a session without any games, perfectly ok
                            continue;
                        }

                        if (gamerec.m_dtStart < session.Timestamp.AddMilliseconds(-session.Duration-50))
                        {
                            //game started before session, so doesn't belong to this session
                            continue;
                        }

                        if ( gamerec.m_dtEnd > session.Timestamp ) 
                        { 
                            //account for killed message marking the end of the game
                            gamerec.m_dtEnd = session.Timestamp;
                        }
                        
                        gamerec.m_iCountry = session.iCountry;
                        gamerec.m_iTitle = session.TitleID;
                        gamerec.m_RecordType = GameRecord.RecordTypeEnum.DirtyNeedsInsert;

                        session.Playing +=  (long)(gamerec.m_dtEnd - gamerec.m_dtStart).TotalMilliseconds; 
                        session.Games++;


                    }
                }

                long lSess=0;

                //filter out sessions on discard titleid's now, it is necessary to do it this late
                if ( !m_htDiscardTitleIds.ContainsKey ( session.TitleID ) )
                {
                    //insert into tfUserSessions table
                    m_loader.Execute ( session.ToSql ( ) ) ;

                    //get the identity field for the inserted row
                    lSess =  m_loader.Scalar2( session.ToSqlSelect ( ) );

                    m_iSessionCounter++;                    
                }
  

                //now insert record into tfUserGames
                if(gamepres != null)
                {
                    foreach( GameRecord gamerec in gamepres.m_alGameRecords ) 
                    {                                                
                        if ( GameRecord.RecordTypeEnum.DirtyNeedsInsert == gamerec.m_RecordType ) 
                        {
                            //filter out games from discard titleid's, it is necessary to do it this late
                            if ( !m_htDiscardTitleIds.ContainsKey ( session.TitleID ) )
                            {
                                gamerec.m_lSessionID = lSess;
                                BIGames.AddRecord( gamerec );
                                
                                m_iGameCounter++;
                            }
                            
                            gamerec.m_RecordType = GameRecord.RecordTypeEnum.Inserted;
                        }
                    }
                }
    
            }

            //bulk insert the games
            BIGames.Insert( m_loader );

            //print out total of missing xpnf errors here so we don't get spammed with these warning
            if ( iMissingXpnf > 0 )
            {
                string strErr = "** WARNING ** " + iMissingXpnf + " Corresponding Xpnf Alive msgs not found for presence killed msgs! Is there a xpnf log file missing, or xpnf batch missing, or have presence logs been parsed out further than xpnf logs?";
                        
                Helper.LogMessage ( Helper.MsgType.Warn, strErr ) ; 
                m_loader.Execute ( new ErrorRec ( m_Batch.Id, strErr ).ToSql() ) ; 
            }
               
        }

		public void LocateSessionPhantomUsers()
		{           

			foreach ( Presence_Killed_103 session in m_alSessions ) 
			{ 
                                
				//look for alive messages to add machine acct info
				ArrayList alpresalive = (ArrayList) m_htPresenceAlive[ session.UserPUID ];

				bool bFoundPresAlive = false;

				if ( alpresalive != null )
				{
					foreach( Presence_Alive_102 pres102 in alpresalive)
					{
						//insure presalive between starting and ending of session (with 500 ms cushion added to starting)
						//this is tricky because alive and killed can occur at the same precise millisecond for two reasons: 
						//0 length session, or first user logon got kicked when logging on from a second xbox
						if ( false == pres102.bDeleteMe && pres102.Timestamp <= session.Timestamp && 
							pres102.Timestamp >= session.Timestamp.AddMilliseconds(-session.Duration-500) &&
							pres102.TitleID == session.TitleID )
						{
							bFoundPresAlive = true;
							break;
						}
					}
				}

				//error here if alive message not found for this session (and this is not a discard titleID)
				if ( !bFoundPresAlive )
				{                    
					if ( !m_htDiscardTitleIds.ContainsKey ( session.TitleID ) ) 
					{
						//look for phantom users
						if ( !m_htUsersFromId.ContainsKey ( session.UserPUID ) && !m_htUserIds.ContainsKey ( session.UserPUID ) )   
						{
							//create a phantom user and log an error when an unknown user is encountered 
							//this is done during save phase out of necessity

							if ( !m_htXonwatchUserIds.ContainsKey(session.UserPUID )  &&
								!m_htXonWatchFromId.ContainsKey(session.UserPUID )  )
							{
                    
								//add phantom user to list so it will get loaded into db
								Uacs_CreateAccount_501 account = new 
									Uacs_CreateAccount_501( m_Batch.BatchId, session.UserPUID, session.Timestamp);
                    
								m_htUsersFromId.Add ( session.UserPUID, account ) ;

								//error will get logged once for all phantom PUIDs
								m_iNewPhantomUsers++;

								//TODO(v4.5) document this and other error messages and how to diagnose the problem
								string str = "** Warning ** Phantom user detected! Corresponding Presence alive not found for a presence killed! Is there a presence log file missing from a batch or an entire batch missing?";
                        
								Helper.LogMessage ( Helper.MsgType.Warn, str ) ; 

								m_loader.Execute ( new ErrorRec ( m_Batch.Id , str ).ToSql() ) ; 

							}
							else
							{

								//TODO(v4.5) document this and other error messages and how to diagnose the problem
								string strError = "** Error ** Corresponding Presence Alive not found for a presence killed but a Xonwatch user already exists! Is there a presence log file missing from a batch or an entire batch missing?";
                        
								Helper.LogMessage ( Helper.MsgType.Err, strError ) ; 
								m_loader.Execute ( new ErrorRec ( m_Batch.Id , strError ).ToSql() ) ; 
							}
                                    
						}
						else
						{

							//TODO(v4.5) document this and other error messages and how to diagnose the problem
							string strError = "** Error ** Corresponding Presence Alive not found for a presence killed but an user already exists! Is there a presence log file missing from a batch or an entire batch missing?";
                        
							Helper.LogMessage ( Helper.MsgType.Err, strError ) ; 
							m_loader.Execute ( new ErrorRec ( m_Batch.Id , strError ).ToSql() ) ; 
						}
					}

				}
			}
		}

        //TODO: phantom xpnf remnants will not get processed into a session after user becomes normal? 
        //TODO(v5): friends and invites are not filtered on titleID!! but they are filtered on discard user
        //TODO(v5): look into optimizing by not pulling down all temporary xonwatch users
        //TODO: for GameID -1750893399577516405, investigate why dtStarted time is mysteriously off by 1ms when put into database


		public bool SaveLogs ( string Server , string Database , string User , string Password ) 
		{ 
			Helper.LogMessage ( Helper.MsgType.Info, m_htXonWatchFromId.Count.ToString ( ) + " New XonWatch accounts. " ) ; 
			Helper.LogMessage ( Helper.MsgType.Info, m_htUsersFromId.Count.ToString ( ) + " New user accounts. " ) ;  
			
			Helper.LogMessage ( Helper.MsgType.Info, "Statistics before filtering: " ) ; 
			Helper.LogMessage ( Helper.MsgType.Info, "   " + m_alSessions.Count.ToString ( ) + " total user sessions." ) ; 
			Helper.LogMessage ( Helper.MsgType.Info, "   " + m_iZeroSessions + " zero length sessions. " ) ; 
            Helper.LogMessage ( Helper.MsgType.Info, "   " + m_alPurchases.Count.ToString ( ) + " purchases. " ) ; 
			Helper.LogMessage ( Helper.MsgType.Info, "   " + m_alFeedbacks.Count.ToString ( ) + " feedback reports. " ) ; 
			Helper.LogMessage ( Helper.MsgType.Info, "   " + m_alNewNotifications.Count.ToString ( ) + " distinct IP notifications. " ) ; 

			if ( ! m_Batch.Aborted ) 
			{ 
				m_Batch.Update ( BatchRec.Phases.Inserting ) ; 
			} 
			m_loader.Execute ( m_Batch.ToSqlUpdate ( ) ) ; 
			 
			int AccountCounter		= 0 ; 
            int XonwatchAccountCounter = 0 ;
			int PurchaseCounter		= 0 ; 
			int FeedbackCounter		= 0 ; 


			int	FriendsRequestCounter  = 0 ; 
			int	FriendsAcceptCounter   = 0 ; 
            int	FriendsRemoveCounter   = 0 ; 
			int	FriendsRejectCounter    = 0 ; 
            int FriendsBlockCounter    = 0 ;
            int FriendsMuteCounter     = 0 ;
            int FriendsUnmuteCounter   = 0 ;

            int InviteCounter = 0;
            int InviteAnswerNoCounter = 0;
            int InviteAnswerYesCounter = 0;
            int InviteAnswerRemoveCounter = 0;
            int InviteCancelCounter = 0;
            int ChangedGamerTags = 0 ;

            int iAutoupdateRefs=0;
            int iContentRefs=0;

			Helper.LogMessage ( Helper.MsgType.Info, "Saving logs to Database..." ) ; 
			
            //TODO: don't need to connect again, right?
            
            /*
            // connect ( We should be already connected ) 
            if ( ! m_loader.Connect ( Server , Database , User , Password ) ) 
            { 
                Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** Failed to connect to database. Aborted." ) ;
                return false;
            }
            */

			Helper.LogMessage ( Helper.MsgType.Info,"Connected. " ) ; 

			try 
			{
                //insert into the rawlogs tables if enabled
                if (Parser.bRawLogs)
                {
                    Helper.LogMessage( Helper.MsgType.Info, "Loading Raw Log records..." );
                    foreach( object rawlog in m_alRawLogs)
                    {
                        m_loader.Execute( ((IXLAppLog)rawlog).ToSqlRaw() ); 
                    }
                    m_alRawLogs.Clear();
                    Helper.LogMessage ( Helper.MsgType.Info, m_alRawLogs.Count + " raw logs loaded into database." ) ; 
                }                    
                
                //report on phantom users not converted
                ArrayList arrlist = new ArrayList (m_htPhantomUserIds);
                
                foreach ( DictionaryEntry de in arrlist )
                {
                    UserInfo userinfo = (UserInfo)de.Value; 
					
                    if ( userinfo.iBatch == m_iLastBatch )
                    {
                        m_Error = new ErrorRec ( m_Batch.Id, 
                                        "**ERROR** Phantom user from the previous batch (" + m_iLastBatch + 
                                        ") not converted in this batch. " + 
                                        "( UserPUID: " + (long)de.Key + " ) Are there UACS logs missing?" );

                        m_loader.Execute ( m_Error.ToSql ( ) ) ; 
                        Helper.LogMessage ( Helper.MsgType.Err, m_Error.Message );
                    }
                }

                //sort the sessions list
                m_alSessions.Sort();

                //process the killed messages
                Helper.LogMessage( Helper.MsgType.Info, "Processing Session Data..." );    
                ProcessAlives();
                ProcessSessions();

				// Process alives and kills again for phantom users.
				Helper.LogMessage( Helper.MsgType.Info, "Processing Session Data for phantom users..." );    
				LocateSessionPhantomUsers();

				//process the feedback data
                Helper.LogMessage( Helper.MsgType.Info, "Processing Feedback Data..." );    
                ProcessFeedback();

                //report on phantom users
                if ( m_iNewPhantomUsers > 0 )
                {
                    m_Error = new ErrorRec ( m_Batch.Id, "**WARNING** " + m_iNewPhantomUsers + " user(s) with an unknown PUID encountered. " + 
                        "Are there XUACS logs missing or was UACS not parsed as far as another service?" ) ; 

                    m_loader.Execute ( m_Error.ToSql ( ) ) ; 
                    Helper.LogMessage ( Helper.MsgType.Warn, m_Error.Message );
                }

                //insert unknown titleid's
                if (m_htPhantomTitleIds.Count > 0 )
                {
                    Helper.LogMessage( Helper.MsgType.Info, "Inserting " + m_htPhantomTitleIds.Count + " Phantom Titles..." );  

                    ArrayList phantomtitles = new ArrayList (m_htPhantomTitleIds);

                    foreach ( DictionaryEntry de in phantomtitles )
                    {
                        int iTitleID = (int) de.Key;

                        string sql = "INSERT INTO tdTitles " +
                                        "( iTitleID, iGenreID, iPublisherID, iTitleTypeID, vcHexValue, vcTitleCodeName, vcTitleName )" + 
                                        " VALUES ( " +
                                        iTitleID + ", " +
                                        "1, " +
                                        "1, " +
                                        "4, " +
                                        Helper.ToSQL(iTitleID.ToString( "x") ) + ", " + 
                                        Helper.ToSQL("Phantom TitleID - Needs Update!") + ", " +
                                        Helper.ToSQL("Phantom TitleID - Needs Update!") + ")";

                        m_loader.Execute ( sql );
                    }
                        
                }

				//find xonwatch hackers 
				DetectXonWatchHacking ( ) ; 

				// load new accounts 
				Helper.LogMessage ( Helper.MsgType.Info, "Loading Account Creation records..." ) ; 
				
                arrlist = new ArrayList (m_htUsersFromId);
                
                foreach ( DictionaryEntry de in arrlist )
                {
                    Uacs_CreateAccount_501 account = (Uacs_CreateAccount_501)de.Value; 
					Uacs_CreateAccount_501.AccountTypeEnum accType = account.AccountType;
					
                    m_loader.Execute ( account.ToSqlInsert ( ) ) ;
                    ++ AccountCounter ; 
					
				} ;

				Helper.LogMessage ( Helper.MsgType.Info, AccountCounter.ToString ( ) + " New account records loaded into database." ) ; 

				
                //load xonwatch Accounts  
                Helper.LogMessage ( Helper.MsgType.Info, "Loading Xonwatch Account Creation records..." ) ; 
				
                arrlist = new ArrayList (m_htXonWatchFromId);
                
                foreach ( DictionaryEntry de in arrlist )
                {
                    Uacs_CreateAccount_501 account = (Uacs_CreateAccount_501)de.Value; 

                    ++ XonwatchAccountCounter ; 
                    m_loader.Execute ( account.ToSqlInsert ( ) ) ;
                }  

                Helper.LogMessage ( Helper.MsgType.Info, XonwatchAccountCounter.ToString ( ) + " New xonwatch account records loaded into database." ) ; 

                //load sessions
                Helper.LogMessage ( Helper.MsgType.Info, "Loading Sessions records..." ) ; 
                WriteSessions();
                Helper.LogMessage ( Helper.MsgType.Info, m_iSessionCounter + " Session records loaded into database." ) ; 
                Helper.LogMessage ( Helper.MsgType.Info, m_iGameCounter + " Game records loaded into database." ) ;


				// Load friends 
				Helper.LogMessage ( Helper.MsgType.Info, "Sorting Friends records..." ) ; 
				m_alFriends.Sort ( ) ; 

				Helper.LogMessage ( Helper.MsgType.Info, "Loading Friends records..." ) ; 
				foreach ( FriendAction friend in m_alFriends ) 
				{ 
					// both guys need to be in the database, not filtered on discard titleID because title is not in these logs 
                    if ( ( ( m_htUserIds.ContainsKey     ( friend.UserId ) ) ||
                        ( m_htUsersFromId.ContainsKey ( friend.UserId ) ) 
                        ) && 
                        ( 							
                        ( m_htUserIds.ContainsKey     ( friend.BuddyId  ) ) || 
                        ( m_htUsersFromId.ContainsKey ( friend.BuddyId  ) ) 
                        ) 
                        )
                    { 
                        m_loader.Execute ( friend.ToSql ( ) ) ;
                        
                        switch( friend.Action )
                        {
                        case FriendAction.ActionTypes.Request:
                            FriendsRequestCounter++;
                            break;
                        case FriendAction.ActionTypes.Accept:
                            FriendsAcceptCounter++;
                            break;
                        case FriendAction.ActionTypes.Remove:
                            FriendsRemoveCounter++;
                            break;
                        case FriendAction.ActionTypes.Reject:
                            FriendsRejectCounter++;
                            break;
                        case FriendAction.ActionTypes.Block:
                            FriendsBlockCounter++;
                            break;
                        case FriendAction.ActionTypes.Mute:
                            FriendsMuteCounter++;
                            break;
                        case FriendAction.ActionTypes.Unmute:
                            FriendsUnmuteCounter++;
                            break;
                        }

                    }
				} ; 
				
                m_alFriends.Clear();
				Helper.LogMessage ( Helper.MsgType.Info, FriendsRequestCounter.ToString ( ) + " new friends request records loaded into database." ) ; 
				Helper.LogMessage ( Helper.MsgType.Info, FriendsAcceptCounter.ToString ( ) + " new friends accept records loaded into database." ) ; 
				Helper.LogMessage ( Helper.MsgType.Info, FriendsRemoveCounter.ToString ( ) + " new friends remove records loaded into database." ) ; 
				Helper.LogMessage ( Helper.MsgType.Info, FriendsRejectCounter.ToString ( ) + " new friends reject records loaded into database." ) ; 
				Helper.LogMessage ( Helper.MsgType.Info, FriendsBlockCounter.ToString ( ) + " new friends block records loaded into database." ) ; 
				Helper.LogMessage ( Helper.MsgType.Info, FriendsMuteCounter.ToString ( ) + " new friends mute records loaded into database." ) ; 
				Helper.LogMessage ( Helper.MsgType.Info, FriendsUnmuteCounter.ToString ( ) + " new friends unmute records loaded into database." ) ; 


                // Load invites
                Helper.LogMessage ( Helper.MsgType.Info, "Sorting Invite records..." ) ; 
                m_alInvites.Sort ( ) ; 

                Helper.LogMessage ( Helper.MsgType.Info, "Loading Invite records..." ) ; 
                foreach ( InviteAction invite in m_alInvites ) 
                { 
                    //needs to be a known user, not filtered on discard titleID because title is not in these logs
                    if ( m_htUserIds.ContainsKey ( invite.UserId ) || m_htUsersFromId.ContainsKey ( invite.UserId ) ) 
                    { 
                        m_loader.Execute ( invite.ToSql ( ) ) ;
                        
                        switch( invite.Action )
                        {
                            
                        case InviteAction.ActionTypes.Invite:
                            InviteCounter++;
                            break;
                        case InviteAction.ActionTypes.InviteAnswerNo:
                            InviteAnswerNoCounter++;
                            break;
                        case InviteAction.ActionTypes.InviteAnswerYes:
                            InviteAnswerYesCounter++;
                            break;
                        case InviteAction.ActionTypes.InviteAnswerRemove:
                            InviteAnswerRemoveCounter++;
                            break;
                        case InviteAction.ActionTypes.InviteCancel:
                            InviteCancelCounter++;
                            break;
                        }

                    }
                } ; 
				
                m_alInvites.Clear();
                Helper.LogMessage ( Helper.MsgType.Info, InviteCounter.ToString ( ) + " new invitation request records loaded into database." ) ; 
                Helper.LogMessage ( Helper.MsgType.Info, InviteAnswerNoCounter.ToString ( ) + " new invitation answer(no) records loaded into database." ) ; 
                Helper.LogMessage ( Helper.MsgType.Info, InviteAnswerYesCounter.ToString ( ) + " new invitation answer(yes) records loaded into database" ) ; 
                Helper.LogMessage ( Helper.MsgType.Info, InviteAnswerRemoveCounter.ToString ( ) + " new invitation answer(remove) records loaded into database" ) ; 
                Helper.LogMessage ( Helper.MsgType.Info, InviteCancelCounter.ToString( ) + " new invitation cancel records loaded into database." ) ; 
            

                // load gamertag changes
                Helper.LogMessage ( Helper.MsgType.Info, "Loading gamertag change records..." ) ; 
                foreach ( Uacs_ChangeGamerTag_506 changedtag in m_alChangedTags ) 
                { 
                    if ( m_htUsersFromId.ContainsKey ( changedtag.UserPUID ) || m_htUserIds.ContainsKey ( changedtag.UserPUID ) ) 
                    { 
                        ++ChangedGamerTags; 
                        m_loader.Execute ( changedtag.ToSql ( ) ) ;
                    } 

					
                } ;
                m_alChangedTags.Clear();
                Helper.LogMessage ( Helper.MsgType.Info, ChangedGamerTags.ToString ( ) + " gamertag change records loaded." ) ; 


				// load feedbacks 
				Helper.LogMessage ( Helper.MsgType.Info, "Loading feedback records..." ) ; 
				foreach ( Feedback_801 feedback in m_alFeedbacks ) 
				{ 
                        // already filtered out the discard users(save step) and discard titles(parsing step)
                        ++ FeedbackCounter ; 
                        m_loader.Execute ( feedback.ToSql ( ) ) ;
				} 
                m_alFeedbacks.Clear();
				Helper.LogMessage ( Helper.MsgType.Info, FeedbackCounter.ToString ( ) + " feedback records loaded into database." ) ; 

				// load purchases 
				Helper.LogMessage ( Helper.MsgType.Info, "Loading Purchases records..." ) ; 
				foreach ( Xbos_Purchase_902 purchase in m_alPurchases ) 
				{ 

					// must be a normal user 
                    if ( ( m_htUsersFromId.ContainsKey ( purchase.UserPUID ) ) || 
                        (m_htUserIds.ContainsKey ( purchase.UserPUID ) ) ) 
                    {                           
                        // already checked that it is not a discard title

                        ++ PurchaseCounter ; 
                        m_loader.Execute ( purchase.ToSql ( ) ) ;			
                    }
                    
                    
				}  
                m_alPurchases.Clear();
				Helper.LogMessage ( Helper.MsgType.Info, PurchaseCounter.ToString ( ) + " Purchase records loaded into database." ) ; 


                //load content referral
                Helper.LogMessage ( Helper.MsgType.Info, "Loading Content Referral records..." ) ; 
                foreach ( Xbos_ContentRef_904 contentref in m_alContentRefs )
                {
                    //don't allow contentref records for discard users
                    if ( ( !m_htUsersFromId.ContainsKey ( contentref.UserPUID ) ) && 
                        ( !m_htUserIds.ContainsKey ( contentref.UserPUID ) ) ) 
                    {	
                        continue; 
                    }

                    // already checked that it is not a discard title


                    iContentRefs++;
                    m_loader.Execute( contentref.ToSql() ); 
                }
				m_alContentRefs.Clear();
                Helper.LogMessage ( Helper.MsgType.Info, iContentRefs + " content referral records loaded into database." ) ; 


                //load autoupdate referrals
                Helper.LogMessage ( Helper.MsgType.Info, "Loading Autoupdate Referral records..." ) ;                     
                foreach ( Xbos_AutoUpdateRef_907 autoup in m_alAutoupdateRefs )
                {
                    // already checked that it is not a discard title, can't check user because 907 doesn't log it
                    iAutoupdateRefs++;
                    m_loader.Execute( autoup.ToSql() );
                }
                m_alAutoupdateRefs.Clear();
				Helper.LogMessage ( Helper.MsgType.Info, iAutoupdateRefs + " autoupdate referral records loaded into the database." ) ; 

				//load user info
                Helper.LogMessage ( Helper.MsgType.Info, "Loading SPS Account Info records..." ) ;                     
                foreach ( Sps_CreateAccount_551 spsacct in m_alSpsAccounts )
                {
                    // already checked that it is not a discard title, can't check user because 907 doesn't log it
                    m_loader.Execute( spsacct.ToSql() );
                }
				Helper.LogMessage ( Helper.MsgType.Info, m_alSpsAccounts.Count + " SPS account info records loaded into the database." ) ; 
                m_alSpsAccounts.Clear();

                //load into session remnants table
                Helper.LogMessage ( Helper.MsgType.Info, "Loading into Session Remnants Table..." ) ; 

                int iSessRemnantUpdated = 0 ;
                int iSessRemnantInserted = 0 ;
                ArrayList alPresAlive = new ArrayList(m_htPresenceAlive); 
                
                SessionRemnantUpdate sru = new SessionRemnantUpdate( m_loader, m_Batch.BatchId );
                BulkIns BISessRemnants = new BulkIns( "twSessRemnants" );

                foreach ( DictionaryEntry de in alPresAlive )
                {
                    foreach ( Presence_Alive_102 pres102 in (ArrayList)de.Value )
                    {
                        //don't allow remnant records for discard users
                        if ( ( !m_htUsersFromId.ContainsKey ( pres102.UserPUID ) ) && 
                            ( !m_htUserIds.ContainsKey ( pres102.UserPUID ) ) ) 
                        {	
					        continue; 
                        }
                                                    
                        //don't allow remnant records for discard titleID's 
                        if ( m_htDiscardTitleIds.ContainsKey ( pres102.TitleID ) ) 
                        {
                            continue;
                        }

                        if (pres102.bDeleteMe && pres102.lRemnantID != 0)
                        {
                            //update record as processed
                            sru.MarkAsProcessed( pres102.lRemnantID );
                            iSessRemnantUpdated++;
                        }
                        else if (!pres102.bDeleteMe && 0 == pres102.lRemnantID)
                        {
                            //add country before insertion
                            if ( m_htUsersFromId.ContainsKey ( pres102.UserPUID ) )
                            {
                                pres102.CountryID = ((Uacs_CreateAccount_501)m_htUsersFromId[ pres102.UserPUID ]).CountryID;
                            }
                            else if ( m_htUserIds.ContainsKey ( pres102.UserPUID ) )   
                            {
                                pres102.CountryID = ((UserInfo)m_htUserIds[ pres102.UserPUID ]).iCountry;
                            }

                            //add this remnant record to bulk insert batch
                            BISessRemnants.AddRecord( pres102 );
                            iSessRemnantInserted++;
                        }

                    }
                
                }
                
                //insert remnant records
                BISessRemnants.Insert( m_loader );

                //update all session remnants that have been processed
                sru.UpdateDB();

                alPresAlive.Clear();
                m_htPresenceAlive.Clear();
                Helper.LogMessage ( Helper.MsgType.Info, iSessRemnantUpdated.ToString ( ) + " Session remnant records updated." ) ;
                Helper.LogMessage ( Helper.MsgType.Info, iSessRemnantInserted.ToString ( ) + " Session remnant records inserted." ) ;


                //load into xpnf remnants table
                Helper.LogMessage ( Helper.MsgType.Info, "Loading into XPNF Remnants Table..." ) ; 

                int iXpnfRemnantUpdated = 0 ;
                int iXpnfRemnantInserted = 0 ;
                ArrayList alXpnfAlive = new ArrayList(m_htNotifications);
                
                NotificationUpdate notiupdate = new NotificationUpdate(m_loader, m_Batch.BatchId);
                BulkIns BIXpnfRemnants = new BulkIns( "twXpnfRemnants" );

                foreach ( DictionaryEntry de in alXpnfAlive )
                {
                    foreach ( Notification noti in (ArrayList)de.Value )
                    {
                        //only allow xpnf alive remnants for normal users
                        if ( ( !m_htUsersFromId.ContainsKey ( noti.UserPUID ) ) && 
                            ( !m_htUserIds.ContainsKey ( noti.UserPUID ) ) ) 
                        {	
                            continue; 
                        }

                        //don't allow remnant records for discard titleID's  
                        if ( m_htDiscardTitleIds.ContainsKey ( noti.TitleID ) ) 
                        {
                            continue;
                        }

                        if (noti.bDeleteMe && noti.lRemnantID != 0)
                        {
                            notiupdate.MarkAsProcessed( noti.lRemnantID );
                            iXpnfRemnantUpdated++;
                        }
                        else if (!noti.bDeleteMe && 0 == noti.lRemnantID)
                        {
                            //add remnant record to bulk insert batch
                            BIXpnfRemnants.AddRecord( noti );
                            iXpnfRemnantInserted++;
                        }

                    }
                
                }

                alXpnfAlive.Clear();
                m_htNotifications.Clear();

                //bulk insert xpnf remnants
                BIXpnfRemnants.Insert( m_loader );

                //update database with all processed xpnf remnants
                notiupdate.UpdateDB();


                Helper.LogMessage ( Helper.MsgType.Info, iXpnfRemnantUpdated.ToString ( ) + " XPNF remnant records updated." ) ;
                Helper.LogMessage ( Helper.MsgType.Info, iXpnfRemnantInserted.ToString ( ) + " XPNF remnant records inserted." ) ;


                //load into game remnant table and update processed records 
                Helper.LogMessage ( Helper.MsgType.Info, "Loading into Game Remnant Table..." ) ; 

                int iGameRemnantUpdated = 0 ;
                int iGameRemnantInserted = 0 ;
                ArrayList alGamePres = new ArrayList(m_htGamePresence);

                BulkIns BIGameRemnants = new BulkIns("twGameRemnants");

                foreach (  DictionaryEntry de in alGamePres )
                {
                    ArrayList alGameRecord = ((GamePresence)de.Value).m_alGameRecords;

                    foreach ( GameRecord gamerec in alGameRecord )
                    {
                        //just ignore here if not a real user
                        if ( ( !m_htUsersFromId.ContainsKey ( gamerec.m_lUserPUID ) ) && 
                            ( !m_htUserIds.ContainsKey ( gamerec.m_lUserPUID ) ) ) 
                        {	                                
                            continue; 
                        }
                        
                        if ( GameRecord.RecordTypeEnum.New == gamerec.m_RecordType )
                        {
                            //insert if associated session not found
                            BIGameRemnants.AddRecord(gamerec); 
                            iGameRemnantInserted++;
                        }
                        else if (  GameRecord.RecordTypeEnum.DirtyNeedsUpdate == gamerec.m_RecordType )
                        {
                            //update when the game end was modified but has not yet become associated with a session
                            m_loader.Execute ( gamerec.ToSqlUpdate() );
                            iGameRemnantUpdated++;
                        }
                        else if ( gamerec.m_lRemnantID != 0 && 
                            GameRecord.RecordTypeEnum.Inserted == gamerec.m_RecordType )
                        {
                            //update if a remnant game became associated with a session
                            m_loader.Execute ( gamerec.ToSqlUpdate() ); 
                            iGameRemnantUpdated++;
                        }

                    }
                }

                //bulk insert the new game remnants
                BIGameRemnants.Insert (m_loader);

                Helper.LogMessage ( Helper.MsgType.Info, iGameRemnantUpdated.ToString ( ) + " Game remnant records updated." ) ;
                Helper.LogMessage ( Helper.MsgType.Info, iGameRemnantInserted.ToString ( ) + " Game remnant records inserted." ) ;

				// all done 
				//Helper.LogMessage ( "Loading to Database succeeded." ) ; 
				if ( ! m_Batch.Aborted ) 
				{ 
					m_Batch.Update ( BatchRec.Phases.Completed ) ; 
				} ; 
				m_loader.Execute ( m_Batch.ToSqlUpdate ( ) ) ;
 
                //send summary event if there was any warnings or errors
                Helper.LogMessage ( Helper.MsgType.Summary, "" );
                Helper.LogMessage ( Helper.MsgType.Info, "Process complete. Stopped." ) ; 

			} 
			catch ( Exception e ) 
			{ 
				Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** Database Exception thrown: " + e.Message + " Processing aborted." ) ; 

				m_Batch.Update ( BatchRec.Phases.Aborted ) ; 
				m_loader.Execute ( m_Batch.ToSqlUpdate ( ) ) ;
                return false;

			} 
			finally 
			{ 
				m_loader.Disconnect ( ) ;
			} ; 
			
            return true;
		} 

	} // end class 

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\Reader.cs ===
using System;
using System.Collections;
using System.Data.SqlClient ;
using xonline.ops.tools.livereports.logparser.logparserlib;

namespace xonline.ops.tools.livereports.logparser.parser 
{

    public class UserInfo
    {
        public int iAccountType;
        public int iCountry;
        public int iBatch;

        public UserInfo( int _iAccountType, int _iCountry, int _iBatch )
        {
            iAccountType = _iAccountType;
            iCountry = _iCountry;
            iBatch = _iBatch;
        }
    }
	

    public class Reader
	{
        public Reader()
        {
        }

        static public Hashtable GetUserIds ( DatabaseLoader dbloader )
        {
            return GetIds ( dbloader, "SELECT biUserID, iAccountTypeID, iCountryID, iBatchID from tdUserAccounts WHERE iAccountTypeID <> 0 AND iAccountTypeID <> 5" ) ; 
        }

        static public Hashtable GetXonwatchUserIds ( DatabaseLoader dbloader ) 
        {
            return GetIds ( dbloader, "SELECT biUserID, iAccountTypeID, iCountryID, iBatchID from tdUserAccounts WHERE iAccountTypeID = 0 OR iAccountTypeID = 5" ) ;  
        }

        static public Hashtable GetPhantomUserIds ( DatabaseLoader dbloader ) //TODO: seperate batchID for use only for phantoms
        {
            return GetIds ( dbloader, "SELECT biUserID, iAccountTypeID, iCountryID, iBatchID from tdUserAccounts WHERE iAccountTypeID = 4" ) ;  
        }

        static private Hashtable GetIds ( DatabaseLoader dbloader, string SqlStatement )
        {
            int UserCount = 0 ; 
            Hashtable UserIds = new Hashtable ( );

            SqlDataReader reader = dbloader.Reader ( SqlStatement );

            while( reader.Read( ) )
            { 
                long Id = ( long ) reader["biUserID"] ;
                int iAccountType = ( int ) reader["iAccountTypeID"] ; 
                int iCountry = ( int ) reader["iCountryID"] ; 
                int iBatch = ( int ) reader["iBatchID"] ; 

                UserIds.Add( Id , new UserInfo(iAccountType, iCountry, iBatch) ) ;
                ++ UserCount ; 
            } ; 
			
            if (reader != null)
            {
                reader.Close();
            }

            Helper.LogMessage ( Helper.MsgType.Info, UserCount.ToString ( ) + " User IDs loaded." ) ;
            return UserIds ;
        }

        static public Hashtable GetDiscardTitleIds ( DatabaseLoader dbloader )
        {
            return GetTitleIds ( dbloader, "SELECT iTitleID from tdTitles WHERE iTitleTypeID = 0 " ) ; 
        } 

        static public Hashtable GetTitleIds ( DatabaseLoader dbloader )
        {
            return GetTitleIds ( dbloader, "SELECT iTitleID from tdTitles WHERE iTitleTypeID <> 0 and iTitleTypeID <> 2" ) ; 
        } 

        static public Hashtable GetReservedTitleIds ( DatabaseLoader dbloader  )
        {
            return GetTitleIds ( dbloader, "SELECT iTitleID from tdTitles WHERE iTitleTypeID = 2 " ) ; 
        }         

        static private Hashtable GetTitleIds ( DatabaseLoader dbloader, string SqlStatement )
        {
            int TitleCount = 0 ; 
            Hashtable TitleIds = new Hashtable ( );
            
            SqlDataReader reader = dbloader.Reader ( SqlStatement );

            while( reader.Read( ) )
            { 
                int Id = ( int ) reader [ "iTitleID" ] ; 
                TitleIds.Add ( Id , Id );
                ++ TitleCount ; 
            } ; 

            if (reader != null)
            {
                reader.Close();
            }

            Helper.LogMessage ( Helper.MsgType.Info, TitleCount.ToString ( ) + " Title IDs loaded." ) ;

            return TitleIds ;
        }

        static public ArrayList GetXonWatchIps ( DatabaseLoader dbloader )
        {
            ArrayList XonWatchIps = new ArrayList ( );

            string SqlStatement = "SELECT vcIP, vcSubnetMask from twXonWatchValidIp " ; 

            SqlDataReader reader = dbloader.Reader ( SqlStatement );

            while( reader.Read( ) )
            { 
                string IP = ( string ) reader [ "vcIP" ] ; 
                string SubnetMask = ( string ) reader [ "vcSubnetMask" ] ; 
                XonWatchIp Range = new XonWatchIp ( IP , SubnetMask ) ; 
                XonWatchIps.Add ( Range );
            } ; 

            if (reader != null)
            {
                reader.Close();
            }

            Helper.LogMessage ( Helper.MsgType.Info, XonWatchIps.Count.ToString ( ) + " IPs loaded." ) ;
            return XonWatchIps ;
        }


        static public Hashtable GetSessionRemnants( DatabaseLoader dbloader, int iBatchID )
        {
            int iCountRemnants = 0;

            Hashtable htSessionRemnants = new Hashtable();
            ArrayList temparrlist = null; 

            string SqlStatement = "SELECT * from twSessRemnants where bProcessed=0" ; 

            SqlDataReader reader = dbloader.Reader ( SqlStatement );

            while( reader.Read( ) )
            { 
                DateTime dtCreated = ( DateTime ) reader [ "dtCreated" ] ;     
                long UserPUID = ( long ) reader [ "biUserID" ] ; 
                long lMachineID = ( long ) reader [ "biMachineID" ] ;
                int iTitleID = ( int ) reader [ "iTitleID" ] ;
                int iCountryID = ( int ) reader [ "iCountryID" ] ;
                long lRemnantID = ( long ) reader [ "biRemnantID" ];

                Presence_Alive_102 pres102 = new Presence_Alive_102 ( 
                            dtCreated , 
                            UserPUID, 
                            lMachineID, 
                            iTitleID,
                            iCountryID,
                            lRemnantID );

                pres102.iBatchID = iBatchID;

                temparrlist = (ArrayList) htSessionRemnants[ UserPUID ];

                if ( null == temparrlist )
                {     
                    temparrlist = new ArrayList();
                    temparrlist.Add(pres102); 

                    htSessionRemnants.Add ( UserPUID, temparrlist );
                }
                else
                {
                    temparrlist.Add(pres102);
                    temparrlist.Sort();
                }

                iCountRemnants++;
                    
            }  

            if (reader != null)
            {
                reader.Close();
            }

            Helper.LogMessage ( Helper.MsgType.Info, iCountRemnants + " presence remnant records loaded for " +  htSessionRemnants.Count + " users." ) ;
            return htSessionRemnants;
        }


        static public Hashtable GetXpnfRemnants( DatabaseLoader dbloader, int iBatchID )
        {
            int iCountRemnants = 0;

            Hashtable htXpnfRemnants = new Hashtable();
            ArrayList temparrlist = null; 

            string SqlStatement = "SELECT * from twXpnfRemnants where bProcessed=0" ; 

            SqlDataReader reader = dbloader.Reader ( SqlStatement );

            while( reader.Read( ) )
            { 
                DateTime dtCreated = ( DateTime ) reader [ "dtCreated" ] ;     
                long UserPUID = ( long ) reader [ "biUserID" ] ; 
                int iIP = ( int ) reader [ "iIP" ] ;
                int iTitleID = ( int ) reader [ "iTitleID" ] ;
                long lRemnantID = ( long ) reader [ "biRemnantID" ];

                Notification noti = new Notification ( 
                    dtCreated , 
                    UserPUID, 
                    iIP, 
                    iTitleID, 
                    lRemnantID );

                noti.iBatch = iBatchID;

                temparrlist = (ArrayList) htXpnfRemnants[ UserPUID ];

                if ( null == temparrlist )
                {     
                    temparrlist = new ArrayList();
                    temparrlist.Add(noti); 

                    htXpnfRemnants.Add ( UserPUID, temparrlist );
                }
                else
                {
                    temparrlist.Add(noti);
                    temparrlist.Sort();
                }
                    
                iCountRemnants ++;
            } 
    
            if (reader != null)
            {
                reader.Close();
            }

            Helper.LogMessage ( Helper.MsgType.Info, iCountRemnants + " Xpnf remnant records loaded for " +  htXpnfRemnants.Count + " users." ) ;
            return htXpnfRemnants;
        }


        static public Hashtable GetGameRemnants( DatabaseLoader dbloader, int iBatchID )
        {
            int iCountRemnants = 0;

            Hashtable htGameRemnants = new Hashtable();
            long lLastPUID=0;
            GamePresence gamepres = null;

            string SqlStatement = "SELECT * from twGameRemnants where bProcessed=0 order by biUserID" ; 

            SqlDataReader reader = dbloader.Reader ( SqlStatement );

            while( reader.Read( ) )
            {   
                DateTime dtStart = ( DateTime ) reader [ "dtStart" ] ; 
                DateTime dtEnd = ( DateTime ) reader [ "dtEnd" ] ; 
                long UserPUID = ( long ) reader [ "biUserID" ] ; 
                long lGameID = ( long ) reader [ "biGameID" ];
                long lRemnantID = ( long ) reader [ "biRemnantID" ];

                if (UserPUID != lLastPUID)
                {
                    if ( gamepres!= null )
                    {
                        //add for previous PUID
                        htGameRemnants.Add( lLastPUID, gamepres );
                    }

                    lLastPUID = UserPUID;

                    gamepres = new GamePresence ( UserPUID ) ;
                }

                gamepres.AddRecord( dtStart, dtEnd, UserPUID, lGameID, lRemnantID, iBatchID );

                iCountRemnants ++;
            }

            if ( gamepres != null )
            {
                //add for the final PUID
                htGameRemnants.Add( lLastPUID, gamepres );
            }

            if (reader != null)
            {
                reader.Close();
            }

            Helper.LogMessage ( Helper.MsgType.Info, iCountRemnants + " game remnant records loaded for " + htGameRemnants.Count.ToString() + " users."  ) ;
            return htGameRemnants ;

        }
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\Parser.cs ===
using System;
using System.IO ;
using System.Text ;
using System.Globalization; 
using System.Diagnostics;
using xonline.ops.tools.livereports.logparser.logparserlib;

namespace xonline.ops.tools.livereports.logparser.parser 
{
    //base interface for bulk insert capabale classes
    public interface IXLBulkIns
    {
        string ToBulk();
    }

    //base interface for log encapsulating classes
    public interface IXLAppLog
    {
        string ToSqlRaw();
    }

    //entry point class
	class Parser
	{
		
		ParserDoc doc = new ParserDoc ( ) ;

		static Parser TheApp = null ; 
		[STAThread]
		static int Main ( string [] args )
		{
			TheApp = new Parser () ; 
            Helper.strCaller = "LogParser";

            bool bRet = TheApp.Start ( args );

			if ( bRet ) 
			{ 
                
				bRet = TheApp.doc.ParseLogs ( Server , Database , User , Password , Path, m_nTimeout, m_nBackoff );

                if ( bRet )
                {
                    bRet = TheApp.doc.SaveLogs ( Server , Database , User , Password) ; 
                }
			} 

            return (bRet == true) ? 0 : -1;
		}

		public bool Start ( string[] args ) 
		{ 
            Helper.LogPath = LogPath;

			if ( TheApp.LoadAppSettings ( args ) ) 
			{              
                Helper.LogPath = LogPath;
                Helper.LogMessage ( Helper.MsgType.Info, "Log Parser - Version 4.2 - Started." ) ;

                return true;
			} 

			return false ; 
		} 

		// Location of source log files 
		public static string Path     = null; // the share name where the source logs files are.

		// Location of the log file
		public static string LogPath  = @"..\ParseLogs\" ; // the location where the parser is writing its own log files.

        public static bool bRawLogs = false;

		// Database 
		// 
		public static string Server   = null;    // The machine name hosting the database
		public static string Database = null ;    // The matchmaking database name 
		public static string User     = "" ;     // User SQL account /
		public static string Password = "" ; // Password for the above account 

		// other program arguments
		public static int    BatchId  = -1 ; // if -1 : Create a new row in table t_Batches, since BatchId is now an identity, I removed the ability to specify the BatchID 

		private static int m_nTimeout = -1;
		private static int m_nBackoff = -1;
											 

        public bool LoadAppSettings ( string []args ) 
        { 
            for (int i = 0; i < args.Length; i++)
            {
				if ( args[i].ToUpper().StartsWith( "/SERVER=" ) )
				{
					Server = args[i].Substring( "/SERVER=".Length ).ToLower();
				}
				else if ( args[i].ToUpper().StartsWith("/DATABASE="))
				{
					Database = args[i].Substring( "/DATABASE=".Length).ToLower();
				}
				else if ( args[i].ToUpper().StartsWith( "/USER=" ) )
				{
					User = args[i].Substring( "/USER=".Length );
				}
				else if ( args[i].ToUpper().StartsWith("/PASSWORD="))
				{
					Password = args[i].Substring( "/PASSWORD=".Length );
				}
				else if ( args[i].ToUpper().StartsWith("/PATH="))
				{
					Path = args[i].Substring( "/PATH=".Length ).ToLower();
				}
				else if ( args[i].ToUpper().StartsWith("/LOGPATH="))
				{
					LogPath = args[i].Substring( "/LOGPATH=".Length ).ToLower();
				}
				else if ( args[i].ToUpper().StartsWith("/RAWLOGS"))
				{
					bRawLogs = true;
				}
				else if ( args[i].ToUpper().StartsWith("/TIMEOUT"))
				{
					m_nTimeout = System.Convert.ToInt32(args[i].Substring( "/TIMEOUT=".Length ));
				}
				else if ( args[i].ToUpper().StartsWith("/BACKOFF"))
				{
					m_nBackoff = System.Convert.ToInt32(args[i].Substring( "/BACKOFF=".Length ));
				}
				else
				{
					Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** - Unrecognized command-line parameter (" + args[i] + ") Aborted." ) ;
					PrintUsage();
					return false;
				}
            }

            if ( null == Server )
            {
                Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** - Server must be specified on the command-line. Aborted." ) ;                
                PrintUsage();
                return false;
            }

            if ( null == Database )
            {
                Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** - Database must be specified on the command-line. Aborted." ) ;
                PrintUsage();
                return false;
            }

            if ( null == Path )
            {
                Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** - Path must be specified on the command-line. Aborted." ) ;
                PrintUsage();
                return false;
            }

            return true;
        }

        void PrintUsage()
        {
            Helper.LogMessage ( Helper.MsgType.Info, "" );
            Helper.LogMessage ( Helper.MsgType.Info, "Usage: logparser [ /SERVER=<servername> ] [ /DATABASE=<database> ] [ /PATH=<path> ] " );
			Helper.LogMessage ( Helper.MsgType.Info, "                 [ /USER=<username> ] [ /PASSWORD=<password> ] " );
			Helper.LogMessage ( Helper.MsgType.Info, "                 [ /BACKOFF=<backoffvalue> ] [ /TIMEOUT=<timeoutvalue> ] " );
			Helper.LogMessage ( Helper.MsgType.Info, "" );
            Helper.LogMessage ( Helper.MsgType.Info, "Examples: logparser /SERVER=infrdmg001 /DATABASE=livereports /PATH=e:\\applogs" );
            Helper.LogMessage ( Helper.MsgType.Info, "Examples: logparser /SERVER=infrdmg001 /DATABASE=livereports /PATH=e:\\applogs /USER=logacct /PASSWORD=logacctpw /BACKOFF=300 /TIMEOUT=240" );
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\Uacs.cs ===
using System;
using System.Globalization;
using xonline.ops.tools.livereports.logparser.logparserlib; 

namespace xonline.ops.tools.livereports.logparser.parser 
{
	/// <summary>
	/// Summary description for Uacs.
	/// </summary>
    public class Uacs_CreateAccount_501 : IXLAppLog
    {
        public enum AccountTypeEnum { XonwatchTemp=0, Normal=1, Test=2, Internal=3, Phantom=4, XonwatchPerm=5, PhantomToXonwatch=6, PhantomToNormal=7 };

		public	DateTime Timestamp ; 
		public  long	UserPUID   ; 
		public  int		hr ; 
		public  AccountTypeEnum AccountType = AccountTypeEnum.Normal ; // default to normal 
		public  int		LocationID = 1 ;  // default to unknown
		string	GamerTag ; 
		string	Email ; 
		public int 	CountryID = -1 ; //default to unknown country (for phantom users)
		string	PostalCode ; 
		int		LanguageID ; 
		long	XboxID ; 
		public  int		TitleID   ; 
		//string	VoucherHash ;   //these two commented out to save memory 
        //public int iFileID;

		public  int	Batch ; 


		public Uacs_CreateAccount_501 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  4 : hr = Helper.ToInt ( strItem ) ; break ;
					case  5 : GamerTag = strItem ; break ;
					case  6 : Email = strItem ; break ;
					case  7 : CountryID = Helper.ToInt ( strItem ) ; break ;
					case  8 : PostalCode = strItem ; break ;
					case  9 : LanguageID = Helper.ToInt ( strItem ) ; break ;
					case 10 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case 11 : TitleID = Helper.ToInt ( strItem ) ; break ;
					case 12 : /*VoucherHash = strItem ;*/ break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

			Batch	   = -1 ;

			SetAccountType ( ) ; 
		} 

        public Uacs_CreateAccount_501 ( int _Batch, long _UserPUID, DateTime _Timestamp )
        {
            //create a phantom object
            Batch = _Batch;
            UserPUID = _UserPUID;
            Timestamp = _Timestamp;
            AccountType = AccountTypeEnum.Phantom;
        }

		public bool IsValid ( ) 
		{ 
			if ( ( Timestamp.Year > 2048 )   || ( Timestamp.Year < 2002 ) ) return false ; 

			if ( GamerTag.Length == 0 || GamerTag.Length > 16 ) return false ; 
 			if ( PostalCode.Length == 0 || PostalCode.Length > 12 ) return false ;
  			if ( Email.Length == 0 || Email.Length > 129 ) return false ;

            if ( 0 == UserPUID ) return false;

			return true ; 
		} 

		public bool IsXonWatchAccount ( ) 
		{ 
			if ( GamerTag.Length > 1 ) 
			{
				return ( ( GamerTag [ 0 ] == '0' ) || ( GamerTag [ 0 ] == '1' ) ) ; 
			}
			else 
				return false ; 
		} 

		public bool IsTestAccount ( ) 
		{ 
			string LoweredGamerTag = GamerTag.ToLower ( ) ; 

			if ( LoweredGamerTag.StartsWith ( "xboxtest" ) )	return true ; 
			if ( LoweredGamerTag.StartsWith ( "xboxxoc" ) )		return true ; 
			if ( LoweredGamerTag.StartsWith ( "xboxcert" ) )	return true ; 
			if ( LoweredGamerTag.StartsWith ( "xboxlive" ) )	return true ; 
			if ( LoweredGamerTag.StartsWith ( "dash" ) )		return true ; 
			if ( LoweredGamerTag.StartsWith ( "functional" ) )	return true ; 
			if ( LoweredGamerTag.StartsWith ( "xoc" ) )			return true ; 

			string LoweredEmail = Email.ToLower ( ) ; 
			if ( LoweredEmail.StartsWith ( "cwilson" ) )		return true ; 
			if ( LoweredEmail.StartsWith ( "dalbert" ) )		return true ; 
			if ( LoweredEmail.StartsWith ( "ericaz" ) )			return true ; 
			if ( LoweredEmail.StartsWith ( "jbernard" ) )		return true ; 
			if ( LoweredEmail.StartsWith ( "xoc" ) )			return true ; 

			return false ; 
		} 

		public bool IsInternalAccount ( ) 
		{ 
			string LoweredGamerTag = GamerTag.ToLower ( ) ; 

			string LoweredEmail = Email.ToLower ( ) ; 
			if ( LoweredEmail.EndsWith ( "microsoft.com" ) )	return true ; 
			if ( LoweredEmail.EndsWith ( "xbox.com" ) )			return true ; 

			return false ; 
		} 

		public int SetAccountType ( ) 
		{ 
			if ( IsXonWatchAccount ( ) )
			{
                if ( GamerTag [ 0 ] == '0' ) 
                {
                    AccountType = AccountTypeEnum.XonwatchTemp; 
                }
                else
                {
                    AccountType = AccountTypeEnum.XonwatchPerm;
                }
			} 
			else 
			{ 
				if ( IsTestAccount ( ) ) 
				{ 
					AccountType = AccountTypeEnum.Test ; 
				} 
				else 
				{ 
					AccountType = IsInternalAccount ( ) ? AccountTypeEnum.Internal : AccountTypeEnum.Normal ; 
				} ;
			} ; 

			return (int)AccountType ; 
		} 

		public string ToSqlInsert ( ) 
		{ 
            string str = null;

            switch ( AccountType )
            {
            case AccountTypeEnum.XonwatchTemp:
            case AccountTypeEnum.XonwatchPerm:

                str =  
                    "INSERT INTO tdUserAccounts ( " +
                    " biUserID , iBatchID, biMachineID, iAccountTypeID , " + 
                    " iCountryID , iLanguageID , iTitleID , " + 
                    " iHourIDCreated, dtCreated , iLocationID, " + 
                    " vcPostalCode , vcGamerTag , vcEmail , vcVoucher, iUpdatedBatchID ) " + 
                    " VALUES ( " +
                    UserPUID.ToString ( ) + " , " + 
                    Batch.ToString ( ) + " , " + 
                    XboxID + ", " +
                    (int)AccountType + ", " + 
                    "0, " + 
                    "0 , " + 
                    "0 , " + 
                    Helper.ToHourID ( Timestamp ).ToString ( ) + " , " + 
                    Helper.ToSQL ( Timestamp ) + " , " + 
                    LocationID.ToString ( ) + " , " + 
                    Helper.ToSQL ( "" ) + " , " + 
                    Helper.ToSQL ( GamerTag ) + ", " +
                    Helper.ToSQL ( "" ) + " , " + 
                    Helper.ToSQL ( "" ) + " , " + 
                    "0 ) " ;
                break;

            case AccountTypeEnum.Phantom:
            
                str =  
                    "INSERT INTO tdUserAccounts ( " +
                    " biUserID , iBatchID, biMachineID, iAccountTypeID , " + 
                    " iCountryID , iLanguageID , iTitleID , " + 
                    " iHourIDCreated, dtCreated , iLocationID, " + 
                    " vcPostalCode , vcGamerTag , vcEmail , vcVoucher, iUpdatedBatchID ) " + 
                    " VALUES ( " +
                    UserPUID.ToString ( ) + " , " + 
                    Batch.ToString ( ) + " , " + 
                    "0, " + 
                    (int)AccountTypeEnum.Phantom + ", " + 
                    CountryID + " , " + 
                    "0 , " + 
                    "0 , " + 
                    Helper.ToHourID ( Timestamp ).ToString ( ) + " , " + 
                    Helper.ToSQL ( Timestamp ) + " , " + 
                    LocationID.ToString ( ) + " , " + 
                    Helper.ToSQL ( "" ) + " , " + 
                    Helper.ToSQL ( "" ) + " , " + 
                    Helper.ToSQL ( "" ) + " , " + 
                    Helper.ToSQL ( "" ) + " , " + 
                    "0 ) " ;
                break;   
            
            case AccountTypeEnum.PhantomToXonwatch:

                SetAccountType(); //redetermine the account type (temp or perm xonwatch user)

                str =  
                    "UPDATE tdUserAccounts SET " +
                    "iCountryID=0, " +
                    "biMachineID=" + XboxID + ", " +
                    "iAccountTypeID=" + (int)AccountType + ", " + 
                    "iHourIDCreated=" + Helper.ToHourID ( Timestamp ) + ", " +
                    "dtCreated=" + Helper.ToSQL ( Timestamp ) + ", " +
                    "vcGamerTag=" + Helper.ToSQL ( GamerTag ) + ", " +
                    "iUpdatedBatchID=" +  Batch +
                    " WHERE biUserID = " + UserPUID;

                break;

            case AccountTypeEnum.PhantomToNormal:

                SetAccountType(); //redetermine the account type

                str =  
                    "UPDATE tdUserAccounts SET " +
                    "biMachineID=" + XboxID + ", " +
                    "iAccountTypeID=" + (int)AccountType + ", " + 
                    "iCountryID=" + CountryID + ", " +
                    "iLanguageID=" + LanguageID + ", " +
                    "iTitleID=" + TitleID + ", " + 
                    "iHourIDCreated=" + Helper.ToHourID ( Timestamp ) + ", " +
                    "dtCreated=" + Helper.ToSQL ( Timestamp ) + ", " +
                    "iLocationID=" + LocationID + ", " + 
                    "vcPostalCode=" + Helper.ToSQL ( PostalCode ) + ", " +
                    "vcGamerTag=" + Helper.ToSQL ( GamerTag ) + ", " +
                    "vcEmail=" + Helper.ToSQL ( Email ) + ", " +
                    "vcVoucher=" + Helper.ToSQL ( "" ) + ", " +
                    "iUpdatedBatchID=" +  Batch +
                    " WHERE biUserID = " + UserPUID;

                break;

            default:
                
                str =  
                    "INSERT INTO tdUserAccounts ( " +
                    " biUserID , iBatchID, biMachineID, iAccountTypeID , " + 
                    " iCountryID , iLanguageID , iTitleID , " + 
                    " iHourIDCreated, dtCreated , iLocationID, " + 
                    " vcPostalCode , vcGamerTag , vcEmail , vcVoucher, iUpdatedBatchID ) " + 
                    " VALUES ( " + ToString ( ) + " ) " ; 
                break;
            }

            return str;
		} 

		public string ToSQLUpdateUserSessions()
		{
			string str = null;

			str =  
				"UPDATE tfUserSessions SET " +
				"iDNCountryID=" + CountryID +
				" WHERE biUserID = " + UserPUID;

			return str;
		}

		public override string ToString ( ) 
		{ 
			return
				UserPUID.ToString ( ) + " , " + 
				Batch.ToString ( ) + " , " + 
				XboxID.ToString ( ) + " , " + 
                (int)AccountType + " , " + 
				CountryID.ToString ( ) + " , " + 
				LanguageID.ToString ( ) + " , " + 
				TitleID.ToString ( ) + " , " + 
				Helper.ToHourID ( Timestamp ).ToString ( ) + " , " + 
				Helper.ToSQL ( Timestamp ) + " , " + 
				LocationID.ToString ( ) + " , " + 
				Helper.ToSQL ( PostalCode ) + " , " + 
				Helper.ToSQL ( GamerTag ) + " , " + 
				Helper.ToSQL ( Email ) + " , " + 
				Helper.ToSQL ( "" ) + " , " +
                "0";
		} 

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr501XuacCreateaccount" +
                         " ( iFileID, dtCurrent, biUserPUID, ihr, vcGamerTag, vcEmail, siCountryID, vcPostalCode, tiLanguageID, biMachinePUID, iTitleID, vcVoucherHash ) " +
                         "VALUES ( " +
                         "1, " + //bogus fileID
                         Helper.ToSQL(Timestamp) + ", " +
                         UserPUID + ", " +
                         hr + ", " +
                         Helper.ToSQL(GamerTag) + ", " +
                         Helper.ToSQL(Email) + ", " +
                         CountryID + ", " +
                         Helper.ToSQL(PostalCode) + ", " +
                         LanguageID + ", " +
                         XboxID + ", " +
                         TitleID + ", " +
                         Helper.ToSQL("") + ")";

            return str;
        }
	}

	public class Uacs_ReserveName_502 : IXLAppLog
	{
//		Create table Xuac502
//		(
//		CurrentDT datetime null,
//		XboxID   bigint null,
//		GamerTag varchar(64) null,
//		CountryID smallint null,
//		hr int null,
//		NameVetted bit not null
//		)
		DateTime Timestamp ; 
		long XboxID   ; 
		string GamerTag ; 
		string CountryID ; 
		public int hr ; 
		int NameVetted ;
        public int iFileID ;
		public int iBatch;

		public Uacs_ReserveName_502 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case  4 : GamerTag = strItem ; break ;
					case  5 : CountryID = strItem ; break ;
					case  6 : hr = Helper.ToInt ( strItem ) ; break ;
					case  7 : NameVetted = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr502XuacReservename" +
                "(iFileID, dtCurrent, biMachinePUID, vcGamerTag, siCountryID, ihr, bNameVetted )" +
                "VALUES (" +
                iFileID + ", " +
                Helper.ToSQL(Timestamp) + ", " +
                XboxID + ", " +
                Helper.ToSQL(GamerTag) + ", " +
                Helper.ToSQL(CountryID) + ", " +
                hr + ", " +
                NameVetted + ")";

            return str;
        }
	}

	public class Uacs_VerifyVoucher_503 : IXLAppLog
	{
//		Create table Xuac503
//		(
//		CurrentDT datetime null,
//		XboxID   bigint null,
//		CountryID smallint null,
//		VoucherHash varchar(45) null,
//		hr int null,
//		)
		DateTime Timestamp ; 
		long XboxID    ;
		string CountryID ; 
		string VoucherHash ; 
		int hr ;
        public int iFileID;
        public int iBatch;
		
		public Uacs_VerifyVoucher_503 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case  4 : CountryID = strItem ; break ;
					case  5 : VoucherHash = strItem ; break ;
					case  6 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr503XuacVerifyvoucher" +
                "(iFileID, dtCurrent, biMachinePUID, siCountryID, vcVoucherHash, ihr )" +
                "VALUES ( " +
                iFileID + ", " +
                Helper.ToSQL(Timestamp) + ", " +
                XboxID + ", " +
                Helper.ToSQL(CountryID) + ", " +
                Helper.ToSQL(VoucherHash) + ", " +
                hr + ")";

            return str;
        }
	}

	public class Uacs_SetPaymentInfo_504 : IXLAppLog
	{
//		Create table Xuac504
//		(
//		CurrentDT datetime null,
//		UserPUID   bigint null,
//		hr int null
//		)
		DateTime Timestamp ; 
		long UserPUID ; 
		int hr ; 
        public int iFileID;
        public int iBatch;
		
		public Uacs_SetPaymentInfo_504 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  4 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr504XuacSetpaymentinfo" +
                "(iFileID, dtCurrent, biUserPUID , ihr )" +
                "VALUES (" +
                iFileID + ", " +
                Helper.ToSQL(Timestamp) + ", " +
                UserPUID + ", " +
                hr + ")";

            return str;
        }
	}

	public class Uacs_RestoreAccount_505 : IXLAppLog
	{
//		Create table Xuac505
//		(
//		CurrentDT datetime null,
//		XboxID   bigint null,
//		GamerTag varchar(64) null,
//		UserPUID   bigint null,
//		hr int null
//		)
		DateTime Timestamp ; 
		long XboxID ; 
		string GamerTag ; 
		long UserPUID ; 
		int hr ;
        public int iFileID;
        public int iBatch;
		
		public Uacs_RestoreAccount_505 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case  4 : GamerTag = strItem ; break ;
					case  5 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  6 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr505XuacRestoreaccount" +
                "(iFileID, dtCurrent, biMachinePUID, vcGamerTag, biUserPUID, ihr )" +
                "VALUES (" +
                iFileID + ", " +
                Helper.ToSQL(Timestamp) + ", " +
                XboxID + ", " +
                Helper.ToSQL(GamerTag) + ", " +
                UserPUID + ", " +
                hr + ")";

            return str;
        }
	}

	public class Uacs_ChangeGamerTag_506 : IXLAppLog
	{
		DateTime Timestamp ; 
		public long UserPUID ; 
		long XboxID   ; 
		string OldGamerTag ;
		string NewGamerTag ; 
		
        public int hr ;
        public int iBatch;
        public int iFileID;
		
		public Uacs_ChangeGamerTag_506 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case  4 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case  5 : OldGamerTag = strItem ; break ;
					case  6 : NewGamerTag = strItem ; break ;
					case  7 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

            iBatch = -1;
		}

        public bool IsValid ( )
        {
            if ( 0 == UserPUID ) return false ; 
            if ( 0 == XboxID ) return false;

			if ( OldGamerTag.Length == 0 || OldGamerTag.Length > 16 ) return false ; 
			if ( NewGamerTag.Length == 0 || NewGamerTag.Length > 16 ) return false ; 

            return true ; 
        }

        public string ToSql ( )
        {
            //the decision was that gamertag in tdUserAccounts will be the only thing in the v4 schema that can not be batch-rolled back
            string str = "BEGIN TRANSACTION " + 
                         "INSERT INTO thGamerTags" +
                         "(iBatchID, dtChanged, iHourID, biUserID, vcOldGamerTag, vcNewGamerTag )" +
                         "VALUES ( " +
                         iBatch + ", " +
                         Helper.ToSQL(Timestamp) + ", " +
                         Helper.ToHourID(Timestamp) + ", " +
                         UserPUID + ", " +
                         Helper.ToSQL(OldGamerTag) + ", " +
                         Helper.ToSQL(NewGamerTag) + ") " + 
                         "UPDATE tdUserAccounts set vcGamerTag = " +
                         Helper.ToSQL(NewGamerTag) +
                         " WHERE (biUserID = " +
                         UserPUID + ") " +                         
                         "COMMIT";

            return str;
        }

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr506XuacChangegamertag" +
                         "(iFileID, dtCurrent, biUserPUID, biMachinePUID, vcOldGamerTag, vcNewGamerTag, ihr )" +
                         "VALUES (" +
                         iFileID + ", " +
                         Helper.ToSQL(Timestamp) + ", " +
                         UserPUID + ", " +
                         XboxID + ", " +
                         Helper.ToSQL(OldGamerTag) + ", " +
                         Helper.ToSQL(NewGamerTag) + ", " +
                         hr + ")";

            return str;
        }
	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\Xbos.cs ===
using System;
using xonline.ops.tools.livereports.logparser.logparserlib;

namespace xonline.ops.tools.livereports.logparser.parser 
{
	/// <summary>
	/// Summary description for Xbos.
	/// </summary>
	public class Xbos_Enumerate_901 : IXLAppLog
	{
		//		Create table XBOS901
		//		(
		//			CurrentDT datetime null,
		//			UserPUID bigint null,
		//			TitleID  int null,
		//			OfferingType int null,
		//			StartIndex int null,
		//			MaxResults int null,
		//			NumRecords int null
		//		)
		DateTime Timestamp ; 
		long UserPUID ; 
		int  TitleID  ; 
		int  OfferingType ; 
		int  StartIndex ; 
		int  MaxResults ; 
		int  NumRecords ;
        public int iFileID;
        public int iBatch;

		public Xbos_Enumerate_901 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case 0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case 1 : /* skip line type */ ; break ;
					case 2 : /* skip line description */ ; break ;
					case 3 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case 4 : TitleID  = Helper.ToInt ( strItem ) ; break ;
					case 5 : OfferingType  = Helper.ToInt ( strItem ) ; break ;
					case 6 : StartIndex  = Helper.ToInt ( strItem ) ; break ;
					case 7 : MaxResults  = Helper.ToInt ( strItem ) ; break ;
					case 8 : NumRecords  = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each
 
            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr901XbosEnumerate " +
                "( iFileID, dtCurrent, biUserPUID, iTitleID, iOfferingTypeID, iStartIndex, iMaxResults, iNumRecords )" +
                "VALUES ( " +
                iFileID + ", " +
                Helper.ToSQL( Timestamp) + ", " +
                UserPUID + ", " +
                TitleID + ", " +
                OfferingType + ", " +
                StartIndex + ", " +
                MaxResults + ", " +
                NumRecords + ") ";

            return str;
        }

	} 
	public class Xbos_Purchase_902 : IXLAppLog
	{
//		1	i_Batch	int	4	0
//		0	si_Year	smallint	2	0
//		0	si_Month	smallint	2	0
//		0	si_Day	smallint	2	0
//		0	si_Week	smallint	2	0
//		0	si_DayOfWeek	smallint	2	0
//		0	si_TimeSlot	smallint	2	0
//		0	bi_User	bigint	8	0
//		0	i_Title	int	4	0
//		0	i_Offering	int	4	0		
		
		DateTime		Timestamp ; 
		public	long	UserPUID ; 
		long			XboxID  ; 
		public	int		TitleID ; 
		long			OfferingID ; 
		public int				hr ; 

		public	int		Batch ; 
        public int iFileID;

		public Xbos_Purchase_902 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case 0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case 1 : /* skip line type */ ; break ;
					case 2 : /* skip line description */ ; break ;
					case 3 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case 4 : XboxID   = Helper.ToLong ( strItem ) ; break ;
					case 5 : TitleID  = Helper.ToInt ( strItem ) ; break ;
					case 6 : OfferingID = Helper.ToLong ( strItem ) ; break ;
					case 7 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

			Batch	   = -1 ; 
		}

		public bool IsValid ( ) 
		{ 
			if ( ( Timestamp.Year > 2048 )   || ( Timestamp.Year < 2002 ) ) return false ; 
            if ( 0 == XboxID ) return false;
            if ( 0 == TitleID ) return false;
            if ( 0 == OfferingID ) return false;
            if ( 0 == UserPUID ) return false;

			return true ; 
		} 

		public string ToSql ( ) 
		{ 

			string Sql = 
				// return 
				"INSERT INTO tfPurchases " +  
				"( iBatchID, iHourIDPurchase, dtPurchase, " + 
				" biUserID, iTitleID, biOfferingID, biMachineID ) " +
				"VALUES ( " + ToString ( ) + " ) " ; 

            return Sql ; 


		} 

		public override string ToString ( ) 
		{ 
			return
				Batch.ToString ( ) + " , " + 
				Helper.ToHourID ( Timestamp ).ToString ( ) + " , " + 
				Helper.ToSQL ( Timestamp ) + " , " + 
				UserPUID.ToString ( ) + " , " + 
				TitleID.ToString ( ) + " , " + 
				OfferingID.ToString ( ) + " , " +
                XboxID;
 
		}
 
        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr902XbosPurchase " +
                         "( iFileID, dtCurrent, biUserPUID, biMachinePUID, iTitleID, biOfferingID, ihr )" +
                         "VALUES ( " +
                         iFileID + ", " +
                         Helper.ToSQL( Timestamp) + ", " +
                         UserPUID + ", " +
                         XboxID + ", " +
                         TitleID + ", " +
                         OfferingID + ", " +
                         hr + ") ";
                            
            return str;
        }

	} 

	
	public class Xbos_Details_903 : IXLAppLog
	{
		//		Create table XBOS903
		//		(
		//		CurrentDT  datetime null,
		//		UserPUID   bigint null,
		//		OfferingID bigint null,
		//		TitleID    int null,
		//		DescIndex int null,
		//		LanguageID tinyint null
		//		)
		DateTime Timestamp ; 
		long UserPUID   ; 
		long OfferingID ; 
		int  TitleID    ; 
		int  DescIndex ; 
		int  LanguageID ;
        public int iFileID;
        public int iBatch;

		public Xbos_Details_903 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case 0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case 1 : /* skip line type */ ; break ;
					case 2 : /* skip line description */ ; break ;
					case 3 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case 4 : OfferingID = Helper.ToLong ( strItem ) ; break ;
					case 5 : TitleID  = Helper.ToInt ( strItem ) ; break ;
					case 6 : DescIndex = Helper.ToInt ( strItem ) ; break ;
					case 7 : LanguageID = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each
 
            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr903XbosDetails " +
                "( iFileID, dtCurrent, biUserPUID, biOfferingID, iTitleID, iDescIndex, tiLanguageID)" +
                "VALUES ( " +
                iFileID + ", " +
                Helper.ToSQL( Timestamp ) + ", " +
                UserPUID + ", " +
                OfferingID + ", " +
                TitleID + ", " +
                DescIndex + ", " +
                LanguageID + ") ";

            return str;
        }
	} 

	public class Xbos_ContentRef_904 : IXLAppLog
	{
		//		Create table XBOS904
		//		(
		//		CurrentDT datetime null,
		//		XboxID bigint null,
		//		UserPUID0 bigint null,
		//		UserPUID1 bigint null,
		//		UserPUID2 bigint null,
		//		UserPUID3 bigint null,
		//		TitleID   int null,
		//		OfferingID bigint null
		//		)
		DateTime Timestamp ; 
		long XboxID ; 
		public long UserPUID ; 
		//public long UserPUID0 ;  //commented out to save memory
        //public long UserPUID1 ; 
        //public long UserPUID2 ; 
        //public long UserPUID3 ; 
        //public int iFileID;
        public int  TitleID   ; 
		long OfferingID ; 
        public int iBatch;

		public Xbos_ContentRef_904 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case  4 : UserPUID = Helper.ToLong ( strItem ) ; 
					          /*UserPUID0 = Helper.ToLong ( strItem ) ; */ break ;
                    case  5 : if ( 0 == UserPUID ) UserPUID = Helper.ToLong ( strItem ) ; 
                              /*UserPUID1 = Helper.ToLong ( strItem ) ;*/  break ;
					case  6 : if ( 0 == UserPUID ) UserPUID = Helper.ToLong ( strItem ) ; 
					          /*UserPUID2 = Helper.ToLong ( strItem ) ;*/  break ;
                    case  7 : if ( 0 == UserPUID ) UserPUID = Helper.ToLong ( strItem ) ; 
                              /*UserPUID3 = Helper.ToLong ( strItem ) ;*/  break ;
					case  8 : TitleID   = Helper.ToInt ( strItem ) ; break ;
					case  9 : OfferingID = Helper.ToLong ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

            iBatch = -1;
		}

        public bool IsValid ( )
        {
            if ( ( Timestamp.Year > 2048 )   || ( Timestamp.Year < 2002 ) ) return false ; 
            if ( 0 == UserPUID ) return false;
            if ( 0 == XboxID ) return false;
            if ( 0 == OfferingID ) return false;
            if ( 0 == TitleID ) return false;

            return true;
        }

        public string ToSql ( )
        {
            string str = "INSERT INTO tfContentRefs " +
                "( iBatchID, iHourID, dtCreated, biMachineID, biUserID, iTitleID, biOfferingID )" +
                "VALUES ( " +
                iBatch.ToString ( ) + " , " + 
                Helper.ToHourID ( Timestamp ).ToString ( ) + " , " + 
                Helper.ToSQL ( Timestamp ) + " , " + 
                XboxID + ", " +
                UserPUID.ToString ( ) + " , " +                 
                TitleID.ToString ( ) + " , " + 
                OfferingID.ToString ( ) + ")"; 

            return str;
        }

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr904XbosContentref " +
                "( iFileID, dtCurrent, biMachinePUID, biUserPUID0, biUserPUID1, biUserPUID2, biUserPUID3, iTitleID, biOfferingID )" +
                "VALUES ( " +
                "1, " + //bogus fileID
                Helper.ToSQL( Timestamp ) + ", " +
                XboxID + ", " +
                UserPUID + ", " +
                "0, " +
                "0, " +
                "0, " +
                TitleID + ", " +
                OfferingID + ") ";

            return str;
        }
	}

	public class Xbos_Cancel_905 : IXLAppLog
	{
		//		Create table XBOS905
		//		(
		//		CurrentDT datetime null,
		//		UserPUID bigint null,
		//		OfferingID bigint null,
		//		hr int null
		//		)
		DateTime Timestamp ; 
		long UserPUID ; 
		long OfferingID ; 
		int  hr ;
        public int iFileID;
        public int iBatch;
		
		public Xbos_Cancel_905 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case 0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case 1 : /* skip line type */ ; break ;
					case 2 : /* skip line description */ ; break ;
					case 3 : UserPUID = Helper.ToLong ( strItem ) ; break ;
					case 4 : OfferingID = Helper.ToLong ( strItem ) ; break ;
					case 5 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

            iBatch = -1;
		}

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr905XbosCancel " +
                "( iFileID, dtCurrent, biUserPUID, biOfferingID, ihr )" +
                "VALUES ( " +
                iFileID + ", " +
                Helper.ToSQL( Timestamp ) + ", " +
                UserPUID + ", " +
                OfferingID + ", " +
                hr + ") ";

            return str;
        }
	} 

	public class Xbos_VerifyName_906 : IXLAppLog
	{
		//		Create table XBOS906
		//		(
		//		CurrentDT datetime null,
		//		strName varchar(64) null,
		//		hr int null
		//		)
		DateTime Timestamp ; 
		string Name ; 
		int hr ;
        public int iFileID;
        public int iBatch;

		public Xbos_VerifyName_906 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case 0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case 1 : /* skip line type */ ; break ;
					case 2 : /* skip line description */ ; break ;
					case 3 : Name = strItem ; break ;
					case 4 : hr = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each
 
            iBatch = -1;
		}



        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr906XbosVerifyname " +
                "( iFileID, dtCurrent, vcName, ihr )" +
                "VALUES ( " +
                iFileID + ", " +
                Helper.ToSQL( Timestamp ) + ", " +
                Helper.ToSQL( Name) + ", " +
                hr + ") ";

            return str;
        }
	} 

	public class Xbos_AutoUpdateRef_907 : IXLAppLog
	{
		DateTime Timestamp ; 
		long XboxID ; 
		public int TitleID ; 
		int BaseVersion ;
        //public int iFileID;
        public int iBatch;

		public Xbos_AutoUpdateRef_907 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case 0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case 1 : /* skip line type */ ; break ;
					case 2 : /* skip line description */ ; break ;
					case 3 : XboxID = Helper.ToLong ( strItem ) ; break ;
					case 4 : TitleID  = Helper.ToInt ( strItem ) ; break ;
					case 5 : BaseVersion = Helper.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each
 
            iBatch = -1;
		}

        public bool IsValid()
        {
            if ( ( Timestamp.Year > 2048 )   || ( Timestamp.Year < 2002 ) ) return false ; 
            if ( 0 == XboxID ) return false;
            if ( 0 == TitleID ) return false;

            return true;
        }

        public string ToSql ( )
        {
            string str = "INSERT INTO tfAutoupdateRefs " +
                "( iBatchID, iHourID, dtCreated, biMachineID, iTitleID, iBaseVersion )" +
                "VALUES ( " +
                iBatch.ToString ( ) + " , " + 
                Helper.ToHourID ( Timestamp ).ToString ( ) + " , " + 
                Helper.ToSQL ( Timestamp ) + " , " + 
                XboxID + ", " +               
                TitleID.ToString ( ) + " , " + 
                BaseVersion.ToString ( ) + ") " ; 

            return str;
        }

        public string ToSqlRaw ( )
        {
            string str = "INSERT INTO tr907XbosAutoupdateref " +
                "( iFileID, dtCurrent, biMachinePUID, iTitleID, iBaseVersion )" +
                "VALUES ( " +
                "1, " + //bogus FileID
                Helper.ToSQL( Timestamp) + ", " +
                XboxID + ", " +
                TitleID + ", " +
                BaseVersion + ") ";

            return str;
        }
	} 

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\parser\XonWatchIp.cs ===
using System;
using System.Net ; 

namespace xonline.ops.tools.livereports.logparser.parser 
{
	/// <summary>
	/// Summary description for XonWatchIp.
	/// </summary>
	public class XonWatchIp
	{
		long Ip = 0 ; 
		long Count = 0 ; 
		public XonWatchIp ( string IpAsString , string SubnetAsString ) 
		{
			IPAddress IP = IPAddress.Parse ( IpAsString ) ; 
			IPAddress SubnetMask = IPAddress.Parse ( SubnetAsString ) ; 
			Ip = IP.Address ; 
			ulong uIp = ( ulong ) IPAddress.HostToNetworkOrder ( ( int ) Ip ) ;
			uIp = uIp & 0x0FFffFFff ; 
			Ip = ( long ) uIp ; 
			Count = SubnetMask.Address ; 
			Count = ( long ) IPAddress.HostToNetworkOrder ( ( int ) Count ) ; 
			Count = - Count ; 
		}

		public bool InRange ( int ClientIP ) 
		{ 
			long   lClientIP = (  long )  ClientIP ; 
			ulong ulClientIP = ( ulong ) lClientIP ; 
			ulClientIP = ulClientIP & 0x0FFffFFff ; 
			lClientIP = ( long ) ulClientIP ; 
			
			return ( ( lClientIP >= Ip ) && ( lClientIP < Ip + Count ) ) ; 
		} 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\sql\popdayshours\popdh.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;

namespace xonline.ops.tools.livereports.sql.popdayshours 
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>

    
    class popdh
	{
        public static SqlConnection g_sqlc;
        public static SqlCommand g_insday;
        public static SqlCommand g_inshour;

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
            string strStartDate = null;
            string strEndDate = null;
            string strDBServer = null;
            string strDB = null;

            for(int i=0; i< args.Length; i++)
            {
                if (args[i].StartsWith( "/STARTDATE:" ) )
                {
                    strStartDate = args[i].Substring( "/STARTDATE:".Length ); 
                }
                else if (args[i].StartsWith( "/ENDDATE:" ) )
                {
                    strEndDate = args[i].Substring( "/ENDDATE:".Length );  
                }
                else if ( args[i].StartsWith( "/DBSERVER:" ) )
                {
                    strDBServer = args[i].Substring( "/DBSERVER:".Length );
                }
                else if ( args[i].StartsWith( "/DB:" ) )
                {
                    strDB = args[i].Substring( "/DB:".Length );
                }
            }

            if ( null == strStartDate || null == strEndDate || null == strDB || null == strDBServer )
            {
                Console.WriteLine("Usage: poplivestats /STARTDATE:<MM/dd/yyyy> /ENDDATE:<MM/dd/yyyy> /DBSERVER:<database server> /DB:<database>"); 
                return;
            }

            DateTimeFormatInfo dtfi  = new DateTimeFormatInfo();
            dtfi.FullDateTimePattern = "MM/dd/yyyy HH:mm";

            DateTime dtStart = Convert.ToDateTime( strStartDate + " 00:00", dtfi );	
            DateTime dtEnd = Convert.ToDateTime( strEndDate + " 00:00", dtfi );	
            
            try
            {
                PrepareStatements( strDBServer, strDB );
            }

            catch(Exception ex)
            {
                Console.WriteLine("Caught exception: " + ex.Message);
                return;   
            }

            int iLastDayInsert=0;
            int iInserts=0;
            int iDuplicates=0;
    
            while ( dtStart < dtEnd )
            {
                int iHourID = ToHourID(dtStart);
                int iDayID = ToDayID(dtStart);

                try
                {
                    if (iDayID != iLastDayInsert)
                    {
                        iLastDayInsert = iDayID;
                        InsertDay(iDayID, dtStart);
                        iInserts++;
                    }


                }

                catch( SqlException ex )
                {
                    if ( ex.Number != 0xa43)
                    {
                        Console.WriteLine("Caught exception: " + ex.Message);
                        return;
                    }

                    iDuplicates++;
                }

                try
                {
                    InsertHour(iHourID, iDayID, dtStart.Hour, dtStart);
                    iInserts++;
                }

                catch( SqlException ex)
                {
                    if ( ex.Number != 0xa43)
                    {
                        Console.WriteLine("Caught exception: " + ex.Message);
                        return;
                    }

                    iDuplicates++;
                }

                dtStart = dtStart.AddHours(1);
            }

            Console.WriteLine("Done! Inserts: " + iInserts + " Duplicates: " + iDuplicates);
		}



        public static void InsertDay( int iDayID, DateTime dt)
        {
            g_insday.Parameters[0].Value = iDayID;
            g_insday.Parameters[1].Value = dt;
            g_insday.Parameters[2].Value = dt.Day;
            g_insday.Parameters[3].Value = dt.Month;
            g_insday.Parameters[4].Value = dt.Year - 2000;
            g_insday.Parameters[5].Value = (short)dt.DayOfWeek + 1;
            g_insday.Parameters[6].Value = WeeksSince(dt, "07\\04\\2002");
            g_insday.Parameters[7].Value = WeeksSince(dt, "01\\01\\" + dt.Year);
            g_insday.Parameters[8].Value = DBNull.Value;
            g_insday.Parameters[9].Value = DBNull.Value;
            g_insday.Parameters[10].Value = DBNull.Value;

            g_insday.ExecuteNonQuery();
        }

        public static void InsertHour( int iHourID, int iDayID, int iHour, DateTime dt )
        {
            g_inshour.Parameters[0].Value = iHourID;
            g_inshour.Parameters[1].Value = dt;
            g_inshour.Parameters[2].Value = iDayID;
            g_inshour.Parameters[3].Value = iHour;

            g_inshour.ExecuteNonQuery();
        }

        public static int WeeksSince( DateTime dt, string strStart )
        {
            //TODO:
            return 1;
        }




        public static void PrepareStatements( string strDBServer, string strDB )
        {
            g_sqlc = new SqlConnection();

            g_sqlc.ConnectionString = "server=" + strDBServer + ";database=" + strDB + 
                ";Trusted_Connection=true; Integrated Security=SSPI;";

            g_sqlc.Open();

            g_insday = new SqlCommand(null, g_sqlc);

            g_insday.CommandText = 
                "insert into dbo.tdDays ( "
                + "iDayID, "
                + "dtDay, "
                + "tiDay, "
                + "tiMonth, "
                + "tiYear, "
                + "tiDayOfWeek, "
                + "tiWeekOfYear, "
                + "iWeekSinceBetaLaunch, "
                + "tiFiscalYear, "
                + "tiFiscalMonth, "
                + "tiFiscalWeek "
                + ") values (" 
                + "@iDayID, "
                + "@dtDay, "
                + "@tiDay, "
                + "@tiMonth, "
                + "@tiYear, "
                + "@tiDayOfWeek, "
                + "@tiWeekOfYear, "
                + "@iWeekSinceBetaLaunch, "
                + "@tiFiscalYear, "
                + "@tiFiscalMonth,"
                + "@tiFiscalWeek "
                + ")";

            g_insday.Parameters.Add("@iDayID",           SqlDbType.Int);
            g_insday.Parameters.Add("@dtDay",           SqlDbType.DateTime);
            g_insday.Parameters.Add("@tiDay",      SqlDbType.TinyInt);
            g_insday.Parameters.Add("@tiMonth",        SqlDbType.TinyInt);
            g_insday.Parameters.Add("@tiYear",     SqlDbType.TinyInt);
            g_insday.Parameters.Add("@tiDayOfWeek",    SqlDbType.TinyInt);
            g_insday.Parameters.Add("@tiWeekOfYear",        SqlDbType.TinyInt);
            g_insday.Parameters.Add("@iWeekSinceBetaLaunch",         SqlDbType.Int);
            g_insday.Parameters.Add("@tiFiscalYear",    SqlDbType.TinyInt).IsNullable = true;
            g_insday.Parameters.Add("@tiFiscalMonth",       SqlDbType.TinyInt).IsNullable = true;
            g_insday.Parameters.Add("@tiFiscalWeek",		 SqlDbType.TinyInt).IsNullable = true;

            g_insday.Prepare();

            g_inshour = new SqlCommand(null, g_sqlc);

            g_inshour.CommandText = 
                "insert into dbo.tdHours ( "
                + "iHourID, "
                + "dtHour, "
                + "iDayID, "
                + "tiHour "
                + ") values (" 
                + "@iHourID, "
                + "@dtHour, "
                + "@iDayID,"
                + "@tiHour "
                + ")";

            g_inshour.Parameters.Add("@iHourID",           SqlDbType.Int);
            g_inshour.Parameters.Add("@dtHour",           SqlDbType.DateTime);
            g_inshour.Parameters.Add("@iDayID",      SqlDbType.Int);
            g_inshour.Parameters.Add("@tiHour",        SqlDbType.TinyInt);

            g_inshour.Prepare();

        }

        public static int ToHourID ( DateTime dt ) 
        { 
            return 100 * ( 100 * ( 100 * ( dt.Year - 2000 ) + dt.Month ) + dt.Day ) + dt.Hour ; 
        } 

 
        public static int ToDayID ( DateTime dt ) 
        { 
            return 100 * ( 100 * ( 100 * ( dt.Year - 2000 ) + dt.Month ) + dt.Day ) + 99 ; 
        } 

 



	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\poplr\poplr.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;

namespace xonline.ops.tools.livereports.poplr 
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>

    
    class Class1
	{
        public static SqlConnection g_sqlc;
        public static SqlCommand g_insday;
        public static SqlCommand g_inshour;

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
            string strStartDate = null;
            string strEndDate = null;
            string strDBServer = null;
            string strDB = null;

            for(int i=0; i< args.Length; i++)
            {
                if (args[i].StartsWith( "/STARTDATE:" ) )
                {
                    strStartDate = args[i].Substring( "/STARTDATE:".Length ); 
                }
                else if (args[i].StartsWith( "/ENDDATE:" ) )
                {
                    strEndDate = args[i].Substring( "/ENDDATE:".Length );  
                }
                else if ( args[i].StartsWith( "/DBSERVER:" ) )
                {
                    strDBServer = args[i].Substring( "/DBSERVER:".Length );
                }
                else if ( args[i].StartsWith( "/DB:" ) )
                {
                    strDB = args[i].Substring( "/DB:".Length );
                }
            }

            if ( null == strStartDate || null == strEndDate || null == strDB || null == strDBServer )
            {
                Console.WriteLine("Usage: poplivereports /STARTDATE:<MM/dd/yyyy> /ENDDATE:<MM/dd/yyyy> /DBSERVER:<database server> /DB:<database>"); 
                return;
            }

            DateTimeFormatInfo dtfi  = new DateTimeFormatInfo();
            dtfi.FullDateTimePattern = "MM/dd/yyyy HH:mm";

            DateTime dtStart = Convert.ToDateTime( strStartDate + " 00:00", dtfi );	
            DateTime dtEnd = Convert.ToDateTime( strEndDate + " 00:00", dtfi );	
            
            try
            {
                PrepareStatements( strDBServer, strDB );
            }

            catch(Exception ex)
            {
                Console.WriteLine("Caught exception: " + ex.Message);
                return;   
            }

            int iLastDayInsert=0;
            int iInserts=0;
            int iDuplicates=0;
    
            while ( dtStart < dtEnd )
            {
                int iHourID = ToHourID(dtStart);
                int iDayID = ToDayID(dtStart);

                try
                {
                    if (iDayID != iLastDayInsert)
                    {
                        iLastDayInsert = iDayID;
                        InsertDay(iDayID, dtStart);
                        iInserts++;
                    }


                }

                catch( SqlException ex )
                {
                    if ( ex.Number != 0xa43)
                    {
                        Console.WriteLine("Caught exception: " + ex.Message);
                        return;
                    }

                    iDuplicates++;
                }

                try
                {
                    InsertHour( dtStart, iHourID, iDayID, dtStart.Hour);
                    iInserts++;
                }

                catch( SqlException ex)
                {
                    if ( ex.Number != 0xa43)
                    {
                        Console.WriteLine("Caught exception: " + ex.Message);
                        return;
                    }

                    iDuplicates++;
                }

                dtStart = dtStart.AddHours(1);
            }

            Console.WriteLine("Done! Inserts: " + iInserts + " Duplicates: " + iDuplicates);
		}



        public static void InsertDay( int iDayID, DateTime dt)
        {
            g_insday.Parameters[0].Value = iDayID;
            g_insday.Parameters[1].Value = dt;
            g_insday.Parameters[2].Value = dt.Day;
            g_insday.Parameters[3].Value = dt.Month;
            g_insday.Parameters[4].Value = dt.Year - 2000;
            g_insday.Parameters[5].Value = (short)dt.DayOfWeek + 1;
            g_insday.Parameters[6].Value = WeeksSince(dt, "07\\04\\2002");
            g_insday.Parameters[7].Value = WeeksSince(dt, "01\\01\\" + dt.Year);
            g_insday.Parameters[8].Value = DBNull.Value;
            g_insday.Parameters[9].Value = DBNull.Value;
            g_insday.Parameters[10].Value = DBNull.Value;

            g_insday.ExecuteNonQuery();
        }

        public static void InsertHour( DateTime dt, int iHourID, int iDayID, int iHour )
        {
            g_inshour.Parameters[0].Value = iHourID;
            g_inshour.Parameters[1].Value = dt;
            g_inshour.Parameters[2].Value = iDayID;
            g_inshour.Parameters[3].Value = iHour;

            g_inshour.ExecuteNonQuery();
        }

        public static int WeeksSince( DateTime dt, string strStart )
        {
            //TODO:
            return 1;
        }




        public static void PrepareStatements( string strDBServer, string strDB )
        {
            g_sqlc = new SqlConnection();

            g_sqlc.ConnectionString = "server=" + strDBServer + ";database=" + strDB + 
                ";Trusted_Connection=true; Integrated Security=SSPI;";

            g_sqlc.Open();

            g_insday = new SqlCommand(null, g_sqlc);

            g_insday.CommandText = 
                "insert into dbo.tdDays ( "
                + "iDayID, "
                + "dtDay, "
                + "tiDay, "
                + "tiMonth, "
                + "tiYear, "
                + "tiDayOfWeek, "
                + "tiWeekOfYear, "
                + "iWeekSinceBetaLaunch, "
                + "tiFiscalYear, "
                + "tiFiscalMonth, "
                + "tiFiscalWeek "
                + ") values (" 
                + "@iDayID, "
                + "@dtDay, "
                + "@tiDay, "
                + "@tiMonth, "
                + "@tiYear, "
                + "@tiDayOfWeek, "
                + "@tiWeekOfYear, "
                + "@iWeekSinceBetaLaunch, "
                + "@tiFiscalYear, "
                + "@tiFiscalMonth,"
                + "@tiFiscalWeek "
                + ")";

            g_insday.Parameters.Add("@iDayID",           SqlDbType.Int);
            g_insday.Parameters.Add("@dtDay",      SqlDbType.DateTime);
            g_insday.Parameters.Add("@tiDay",      SqlDbType.TinyInt);
            g_insday.Parameters.Add("@tiMonth",        SqlDbType.TinyInt);
            g_insday.Parameters.Add("@tiYear",     SqlDbType.TinyInt);
            g_insday.Parameters.Add("@tiDayOfWeek",    SqlDbType.TinyInt);
            g_insday.Parameters.Add("@tiWeekOfYear",        SqlDbType.TinyInt);
            g_insday.Parameters.Add("@iWeekSinceBetaLaunch",         SqlDbType.Int);
            g_insday.Parameters.Add("@tiFiscalYear",    SqlDbType.TinyInt).IsNullable = true;
            g_insday.Parameters.Add("@tiFiscalMonth",       SqlDbType.TinyInt).IsNullable = true;
            g_insday.Parameters.Add("@tiFiscalWeek",		 SqlDbType.TinyInt).IsNullable = true;

            g_insday.Prepare();

            g_inshour = new SqlCommand(null, g_sqlc);

            g_inshour.CommandText = 
                "insert into dbo.tdHours ( "
                + "iHourID, "
                + "dtHour, "
                + "iDayID, "
                + "tiHour "
                + ") values (" 
                + "@iHourID, "
                + "@dtHour, "
                + "@iDayID,"
                + "@tiHour "
                + ")";

            g_inshour.Parameters.Add("@iHourID",           SqlDbType.Int);
            g_inshour.Parameters.Add("@dtHour",           SqlDbType.DateTime);
            g_inshour.Parameters.Add("@iDayID",      SqlDbType.Int);
            g_inshour.Parameters.Add("@tiHour",        SqlDbType.TinyInt);

            g_inshour.Prepare();

        }

        public static int ToHourID ( DateTime dt ) 
        { 
            return 100 * ( 100 * ( 100 * ( dt.Year - 2000 ) + dt.Month ) + dt.Day ) + dt.Hour ; 
        } 

 
        public static int ToDayID ( DateTime dt ) 
        { 
            return 100 * ( 100 * ( 100 * ( dt.Year - 2000 ) + dt.Month ) + dt.Day ) + 99 ; 
        } 

 



	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\reportGen\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace xonline.ops.tools.livereports.reportgen  
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\reportGen\daily.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

using System.Data;
using System.Data.SqlClient;
using System.Configuration;


namespace xonline.ops.tools.livereports.reportgen 
{
	/// <summary>
	/// Summary description for Daily.
	/// </summary>
	public class Daily : System.Web.UI.Page
	{
        protected ReportDG WWactivity;
        protected ReportDG WWusersByDay;
        protected ReportDG WWaccountsByCountry;

        protected ReportDG WWusageByTitle;       
        protected ReportDG NAusageByTitle;  
        protected ReportDG EMEAusageByTitle;  
        protected ReportDG JPNusageByTitle;         
        
        private DateTime _fromDate = new DateTime(2002, 12, 15);
        private DateTime _toDate = new DateTime(2002, 12, 15);
        private DateTime _dtNow = new DateTime(2002, 12, 15);

        private string _ww = ConfigurationSettings.AppSettings["ww"];
        private string _emea = ConfigurationSettings.AppSettings["EMEA"];
        protected System.Web.UI.HtmlControls.HtmlGenericControl dateNow;
        private string _na = ConfigurationSettings.AppSettings["NA"];
        private string _jpn = ConfigurationSettings.AppSettings["53"];
	
		private void Page_Load(object sender, System.EventArgs e)
		{

            _fromDate = Convert.ToDateTime(Request["start"]);
            _toDate = Convert.ToDateTime(Request["end"]);                  
		}

        protected override void OnPreRender(EventArgs e)
        {
            DateTime minus5 = _toDate.Subtract(new TimeSpan(5, 0, 0, 0));    

            string[] names = new string[] {
                                            "Activity Overview", 
                                            "Users Account Creation by Day", 
                                            "User Account Creation by Country",
                                            "Usage by Title (Online Titles): World-wide summary",
                                            "Usage by Title (Online Titles): North America",
                                            "Usage by Title (Online Titles): EMEA",
                                            "Usage by Title (Online Titles): Japan"
                                        };

            string[] xmlFiles = new string[] {
                                               "DailyActivityOverview.xml",
                                               "NewAccountsByDay_WW.xml",
                                               "NewAccountsByCountry_WW.xml",                                                                                              
                                               "UsageByTitle_OnlineWW.xml",
                                               "UsageByTitle_OnlineNA.xml",
                                               "UsageByTitle_OnlineEMEA.xml",
                                               "UsageByTitle_OnlineJPN.xml"
                                           };

            ReportDG[] reportDGs = new ReportDG[] 
                                            {
                                                WWactivity, 
                                                WWusersByDay,
                                                WWaccountsByCountry,
                                                WWusageByTitle,
                                                NAusageByTitle,
                                                EMEAusageByTitle,
                                                JPNusageByTitle
                                            };

            for(int i = 0; i < reportDGs.Length; i++)
            {
                if(bindReport((ReportDG)reportDGs[i], names[i], xmlFiles[i]) == false)
                    break;
            }

            this.dateNow.InnerText = _toDate.ToShortDateString();

            base.OnPreRender(e);
        }

        private bool bindReport(ReportDG report, string title, string xmlFile)
        {      
            bool success = true;
            try
            {
                DataSet dt = new DataSet();

                dt.ReadXml(Server.MapPath(xmlFile), XmlReadMode.InferSchema);

                DataView dv = null;
                if(dt.Tables.Count == 1)
                {
                    this.Response.Write("ERROR_ERROR: </br>");
                    dv = new DataView(dt.Tables[0]);
                    report.AutoGen = true;
                    title = "ERROR " + title;
                    success = false;
                }
                else
                {
                    dv = new DataView(dt.Tables[1]);
                }

                report.ReportDataDV = dv;
                report.ReportTitle = title;
                report.ReportBind();                        
            } 
            catch(Exception e)
            {
                this.Response.Write("ERROR_ERROR: " + e.ToString() + "<br/>" + e.StackTrace);
                Response.End();
            }

            return success;
        }



		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\reportGen\ReportDG.ascx.cs ===
namespace xonline.ops.tools.livereports.reportgen 
{
	using System;
	using System.Data;
	using System.Drawing;
	using System.Web;
	using System.Web.UI.WebControls;
	using System.Web.UI.HtmlControls;
    using System.Collections;
    using System.Web.UI;
    using System.Xml;

	/// <summary>
	///		Summary description for ReportDG.
	/// </summary>
	public abstract class ReportDG : System.Web.UI.UserControl, INamingContainer
	{
        protected System.Web.UI.WebControls.DataGrid DG;

        private ArrayList _bSums = new ArrayList();
        private ArrayList _footers = new ArrayList();
        private ArrayList _footerFormat = new ArrayList();
        private ArrayList _counters = new ArrayList();
        private ArrayList _dateFormatStrings = new ArrayList();
        private ArrayList _dataFormatStrings = new ArrayList();

        private string _title = "";

        private DataSet _dt = null;
        private DataView _dv = null;
        protected System.Web.UI.HtmlControls.HtmlGenericControl Title;
        private ITemplate   _itemTemplate   = null;
        private bool _autoGen = false;

		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here

            if(_autoGen == false)
            {
                Control c = new Control();

                _itemTemplate.InstantiateIn(c);

                XmlDocument doc = new XmlDocument();

                LiteralControl lit = (LiteralControl)c.Controls[0];
                string text = lit.Text;
                doc.InnerXml = lit.Text;

                XmlNode top = doc.ChildNodes[0];

                foreach(XmlNode child in top.ChildNodes)
                {
                    if(child.Name == "BoundColumn")
                    {
                        addBoundColumn(val(child.Attributes["DataField"]),
                            val(child.Attributes["HeaderText"]),
                            val(child.Attributes["DataFormatString"]),
                            val(child.Attributes["DateFormatString"]),
                            val(child.Attributes["Sum"]),
                            val(child.Attributes["FooterText"]),
                            val(child.Attributes["FooterFormat"]));                       
                    }
                } 
            }
		}

        protected override void OnPreRender(EventArgs e)
        {
            if(_autoGen) this.DG.AutoGenerateColumns = true;
            this.Title.InnerText = _title;
            base.OnPreRender(e);
        }

        private string val(XmlAttribute attr) { return (attr == null || attr.Value == null) ? "" : attr.Value; }


        public void addBoundColumn(string dataField, string headerText, string dataFormat, string dateFormat, string sum, string footerText, string footerFormat)
        {
            BoundColumn col = new BoundColumn();

            col.DataField = dataField;
            col.HeaderText = headerText;
            col.DataFormatString = dataFormat;

            DG.Columns.Add(col);

            bool bSum = (sum.ToLower() == "true") ? true : false;
            _bSums.Add(bSum);
            _counters.Add(0);
            _footers.Add(footerText);
            _footerFormat.Add(footerFormat);
            _dateFormatStrings.Add(dateFormat);
            _dataFormatStrings.Add(dataFormat);
        }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		///		Required method for Designer support - do not modify
		///		the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion


        /// <summary>
        /// The title for the Datagrid displayed in the report
        /// </summary>
        public DataSet ReportData
        {
            get
            {
                return _dt;
            }
            set
            {
                _dt = value;
            }
        }

        public DataView ReportDataDV
        {
            get
            {
                return _dv;
            }
            set
            {
                _dv = value;
            }
        }

        public ITemplate Columns
        {
            get
            {
                return _itemTemplate;
            }
            set
            {
                _itemTemplate = value;
            }
        }

        public void ReportBind() 
        {
            if(_dt == null)
                DG.DataSource = _dv;
            else
                DG.DataSource = _dt;
            DG.DataBind();
        }


        /// <summary>
        /// The title for the Datagrid displayed in the report
        /// </summary>
        public string ReportTitle
        {
            get
            {
                return _title;
            }
            set
            {
                _title = value;
            }
        }

        public bool AutoGen
        {
            get
            {
                return _autoGen;
            }
            set
            {
                _autoGen = value;
                DG.AutoGenerateColumns = _autoGen;
                DG.Columns.Clear();
            }
        }

        public void DG_ItemDataBound(object sender, DataGridItemEventArgs e)
        {
            if(_autoGen) return;

            if (e.Item.ItemType == ListItemType.Item || e.Item.ItemType == ListItemType.AlternatingItem)
            {
                for(int i = 0; i < _bSums.Count; i++)
                {                    
                    if((bool)_bSums[i] == true)
                    {
                        _counters[i] = (int)_counters[i] + (int)Convert.ToDouble(e.Item.Cells[i].Text);
                    }
                }
   
                for(int i = 0; i < _dateFormatStrings.Count; i++)
                {
                    if(((string)_dateFormatStrings[i]) != "")
                    {
                        e.Item.Cells[i].Text = string.Format((string)_dateFormatStrings[i], (DateTime)Convert.ToDateTime(e.Item.Cells[i].Text));
                    }
                }

                for(int i = 0; i < _dataFormatStrings.Count; i++)
                {
                    if(((string)_dataFormatStrings[i]) != "")
                    {
                        e.Item.Cells[i].Text = string.Format((string)_dataFormatStrings[i], (int)Convert.ToInt32(e.Item.Cells[i].Text));
                    }
                }
            }
            else if(e.Item.ItemType == ListItemType.Footer )
            {
                e.Item.Attributes.Add("align","Right");
                e.Item.CssClass = "CartListFooter";

                for(int i = 0; i < _bSums.Count; i++)
                {
                    if((bool)_bSums[i] == true)
                    {
                        e.Item.Cells[i].Text = string.Format((string)_footerFormat[i], (int)_counters[i]);
                    }
                    else
                    {
                        e.Item.Cells[i].Text = (string)_footers[i];
                    }
                }
            } 
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livestats\LogParser\BatchRec.cs ===
using System;
using System.Globalization; 

namespace xonline.ops.tools.livestats.logparser 
{
	/// <summary>
	/// Summary description for BatchRec.
	/// </summary>
	public class BatchRec
	{
		public enum Phases { Started = 0 , Parsing , Inserting , Completed , Aborted } ; 
		public int	BatchId ; 
		DateTime	TimeStamp ; 
		Phases		Phase ; 

		public BatchRec()
		{
			BatchId   = -1 ; 
			TimeStamp = DateTime.Now ; 
			Phase	  = Phases.Started ; 
		}

		public int Id
		{
			get
			{
				return BatchId ;
			}
		}

		public bool Aborted
		{
			get
			{
				return Phase == Phases.Aborted ;
			}
		}

		public void Update ( Phases _Phase )
		{
			TimeStamp = DateTime.Now ; 
			Phase	  = _Phase ; 
		}

		public string ToSqlInsert ( ) 
		{ 
			return 
				"INSERT INTO t_Batches ( dt_TimeStamp, i_Phase ) " +
				"VALUES ( '" + TimeStamp.ToString ( "G" , DateTimeFormatInfo.InvariantInfo ) + "' , " + ( ( int ) Phase ).ToString ( ) + " ) " ; 
		} 

		public string ToSqlSelect ( ) 
		{ 
			return 
				"SELECT i_BatchId FROM t_Batches " +
				"WHERE ( dt_TimeStamp = '" + TimeStamp.ToString ( "G" , DateTimeFormatInfo.InvariantInfo ) + "' ) " ; 
		} 

		public string ToSqlVerify ( int BatchId ) 
		{ 
			return 
				"SELECT COUNT ( * ) FROM t_Batches " +
				"WHERE ( i_BatchId = " + BatchId.ToString ( ) + " ) " ; 
		} 

		public string ToSqlVerifyFiles ( int BatchId ) 
		{ 
			return 
				" SELECT COUNT ( t_Files.i_FileId ) AS FileCount " +
				" FROM  t_Batches INNER JOIN t_Files " + 
				" ON t_Batches.i_BatchId = t_Files.i_Batch " + 
				" WHERE ( t_Batches.i_BatchId = " + BatchId.ToString ( ) + " ) " ; 
		} 

		public string ToSqlUpdate ( ) 
		{ 
			return 
				"UPDATE t_Batches " +
				" SET dt_TimeStamp = '" + TimeStamp.ToString ( "G" , DateTimeFormatInfo.InvariantInfo ) + "' , " + 
				"     i_Phase  = " + ( ( int ) Phase ).ToString ( ) + " " + 
				" WHERE ( i_BatchId = " + Id.ToString ( ) + " ) " ; 
		} 

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\reportGen\getReport.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

using System.Net;
using System.IO;
using System.Web.Mail;
using System.Configuration;

namespace xonline.ops.tools.livereports.reportgen 
{
	/// <summary>
	/// Summary description for getReport.
	/// </summary>
	public class getReport : System.Web.UI.Page
	{

		private void Page_Load(object sender, System.EventArgs e)
		{
            string result = getPage(Request["start"], Request["end"]);

            Response.Write(result);

            if(result.IndexOf("ERROR_ERROR") == -1)
            {
                sendMail("Report", result, ConfigurationSettings.AppSettings["ErrorEmail"], ConfigurationSettings.AppSettings["ErrorEmail"]);
            }
            else
            {
                sendMail("report failure", result, ConfigurationSettings.AppSettings["SuccessEmail"], ConfigurationSettings.AppSettings["ErrorEmail"]);
            }

		}

        public void sendMail(string title, string body, string to, string from)
        {
            MailMessage mail = new MailMessage();
            mail.From = from;
            mail.To = to;
            mail.Subject = title;
            mail.Body = body;
            mail.BodyFormat = MailFormat.Html;
            SmtpMail.SmtpServer = "smtphost";
            SmtpMail.Send(mail);    
        }

        public string getPage(string start, string end)
        {
            HttpWebRequest HttpReq = (HttpWebRequest)WebRequest.Create( "http://localhost/DailyReport/daily.aspx?start=" + start + "&end=" + end); 
            HttpReq.Credentials = CredentialCache.DefaultCredentials;
            HttpReq.Method = "GET";
            HttpReq.Timeout = 1000 * 60 * 60 * 40; // 40 hrs

            WebResponse result = HttpReq.GetResponse();

            return (new StreamReader(result.GetResponseStream())).ReadToEnd();
        }
		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livestats\LogParser\EventRec.cs ===
using System;

namespace xonline.ops.tools.livestats.logparser 
{
	/// <summary>
	/// Summary description for EventRec.
	/// </summary>
	public class EventRec
	{
		int	  Batch ; 
		short Year ; 
		short Month ; 
		short Day ; 
		short Week ; 
		short DayOfWeek ; 
		short TimeSlot ; 
		int   Counter ; 
		int   Value ; 

		public EventRec ( int _Batch , DateTime dt , int _Counter )
		{
			Batch      = _Batch ; 
			Year       = ( short ) dt.Year ; 
			Month      = ( short ) dt.Month ; 
			Day        = ( short ) dt.Day ; 
			TimeSpan ts = dt - Parser.Week_0 ; 
			Week       = ( short ) ( ts.Days / 7 ) ; 
			// This enumeration ranges from zero, Sunday, to six, indicating Saturday.
			DayOfWeek  = ( short ) dt.DayOfWeek ; 
			TimeSlot   = ( short ) dt.Hour ; 
			Counter    = _Counter ; 
			Value	   = 1 ; 
		}

		public bool IsValid ( ) 
		{ 
			if ( ( Year > 2048 ) || ( Year < 2002 ) ) return false ; 
			if ( ( Month > 12 ) || ( Month < 0 ) ) return false ; 
			if ( ( Day > 31 ) || ( Day < 0 ) ) return false ; 
			if ( ( TimeSlot > 23 ) || ( TimeSlot < 0 ) ) return false ; 
			if ( ( DayOfWeek > 6 ) || ( DayOfWeek < 0 ) ) return false ; 
			if ( ( Week > 1000 ) || ( Week < 0 ) ) return false ; 
			if ( Counter < 1 )  return false ; 
			// no more than ten thousnand time the same event per hour 
			if ( ( Value > 100000 ) || ( Value < 1 ) ) return false ; 

			return true ; 
		} 

		public void Aggregate ( )
		{ 
			Value ++ ; 
		} 

		public ulong Hash ( )
		{
			return 
				( ( ulong ) Counter << 32 ) + 
				( ( ulong ) ( Year - 2000 ) << 24 ) + 
				( ( ulong ) Month << 16 ) + 
				( ( ulong ) Day << 8 ) + 
				( ( ulong ) TimeSlot ) ; 
		}

		public string ToSql ( ) 
		{ 
			if ( IsValid ( ) ) 
			{ 
				string Sql = 
					// return 
					"INSERT INTO t_Events " +  
					"( i_Batch, si_Year , si_Month, si_Day, si_Week, si_DayOfWeek, si_TimeSlot, i_Counter, i_Value ) " +
					"VALUES ( " + ToString ( ) + " ) " ; 
				return Sql ; 
			} 
			else 
				return "" ; 
		} 

		public override string ToString ( ) 
		{ 
			return 
				Batch.ToString ( ) + " , " + 
				Year.ToString ( ) + " , " + Month.ToString ( ) + " , " + Day.ToString ( ) + " , " + 
				Week.ToString ( ) + " , " + DayOfWeek.ToString ( ) + " , " + 
				TimeSlot.ToString ( ) + " , " + 
				Counter.ToString ( ) + " , " + Value.ToString ( ) ; 
		} 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livestats\LogParser\FileRec.cs ===
using System;
using System.Globalization; 

namespace xonline.ops.tools.livestats.logparser 
{
	/// <summary>
	/// Summary description for FileRec.
	/// </summary>
	public class FileRec
	{
		int Batch ; 
		string Path ; 
		int Length ; 
		DateTime LastWritten ; 
		DateTime Parsed ; 
		int Events ; 
		int Errors ; 

		public FileRec ( int _Batch , string _Path , int _Length , DateTime _LastWritten )
		{
			Batch = _Batch ; 
			Path = _Path ; 
			Length = _Length ; 
			LastWritten = _LastWritten ; 
			Parsed = DateTime.Now ; 
			Events = 0 ; 
			Errors = 0 ; 
		}

		public void Update ( int _Events , int _Errors ) 
		{ 
			Events = _Events ; 
			Errors = _Errors ; 
		} 

		public string ToSql ( ) 
		{ 
			return 
				"INSERT INTO t_Files " + 
				" ( i_Batch, vc_FullPath, i_Length, dt_Created, dt_Parsed, i_Events, i_Errors ) " +
				"VALUES ( " + 
				Batch.ToString ( ) + " , " + Parser.SQ + Path + Parser.SQ + " , " + 
				Length.ToString ( ) + " , " + 
				Parser.SQ + LastWritten.ToString (  "G" , DateTimeFormatInfo.InvariantInfo ) + Parser.SQ + " , " + 
				Parser.SQ + Parsed.ToString (  "G" , DateTimeFormatInfo.InvariantInfo ) + Parser.SQ + " , " + 
				Events.ToString ( ) + " , " + Errors.ToString ( ) + "  ) " ;  
		} 

		public string ToSqlVerify ( ) 
		{ 
			return 
				" SELECT COUNT ( * ) FROM t_Files " + 
				" WHERE ( vc_FullPath = " + Parser.SQ + Path + Parser.SQ + " ) " + 
				"   AND ( i_Length = " + Length.ToString ( ) + " ) " + 
				"   AND ( dt_Created = " + 
				Parser.SQ + 
				LastWritten.ToString (  "G" , DateTimeFormatInfo.InvariantInfo ) + 
				Parser.SQ + " ) " ; 
		} 


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livestats\LogParser\DatabaseLoader.cs ===
using System;
using System.Collections;
using System.IO;
using System.Data.SqlClient ; 


namespace xonline.ops.tools.livestats.logparser 
{
	/// <summary>
	/// Summary description for DatabaseLoader.
	/// </summary>
	public class DatabaseLoader
	{
		public bool Connected = false ; 
		System.Data.SqlClient.SqlConnection connection = null ; 

		// True if we are running on the machine that is hosting the SQL Server
		// private bool bLocalHost = true ;
		// if the above is false, SharePath contains a UNC name, for example 
		// something like @"\\LaurentsBox\Proximity\" 
		private string SharePath = "" ; 

		public DatabaseLoader( )
		{
		}

		public void Execute ( string SqlStatement ) 
		{ 
			// Simple utility to run a DML statement 
			if ( ( ! Connected ) || ( connection == null ) ) return ; 

			SqlCommand cmd = new SqlCommand( ) ;
			cmd.CommandText = SqlStatement ;
			cmd.Connection = connection ;
			cmd.ExecuteNonQuery();
		} 

		public int Scalar ( string SqlStatement ) 
		{ 
			// Simple utility to run a DML statement 
			if ( ( ! Connected ) || ( connection == null ) ) return -1 ; 

			SqlCommand cmd = new SqlCommand( ) ;
			cmd.CommandText = SqlStatement ;
			cmd.Connection = connection ;
			object o = cmd.ExecuteScalar( ) ; 
			if ( null == o ) // not data 
				return -1 ; 
			return ( int ) ( o );
		} 

		public bool CheckUserId ( long UserID ) 
		{ 
			// Returns true if this user ID is present in the database
			string SqlStatement = "SELECT bi_UserID from t_Users WHERE ( bi_UserID = " 
				+ UserID.ToString ( ) + " ) " ; 
			SqlCommand cmd = new SqlCommand( ) ;
			cmd.CommandText = SqlStatement ;
			cmd.Connection = connection ;
			object o = cmd.ExecuteScalar( ) ; 
			if ( null == o ) // not found 
				return false ; 
			else 
				return ( ( long ) ( o ) ) == UserID ; 
		} 

		public Hashtable GetUserIds ( )
		{
			return GetIds ( "SELECT bi_UserID from t_Users " ) ; 
		}

		public Hashtable GetTestUserIds ( )
		{
			return GetIds ( "SELECT bi_UserID from t_TestUsers " ) ; 
		}

		public Hashtable GetIds ( string SqlStatement )
		{
			int UserCount = 0 ; 
			Hashtable UserIds = new Hashtable ( );
			SqlDataReader reader = null ; 
			try
			{
				SqlCommand cmd = new SqlCommand( ) ;
				cmd.CommandText = SqlStatement ;
				cmd.Connection = connection ;

				// Instantiates a SqlDataReader object which moves through the Dataset one row at a time
				reader = cmd.ExecuteReader();
				while( reader.Read( ) )
				{ 
					long Id = ( long ) reader [ "bi_UserID" ] ; 
					UserIds.Add ( Id , Id ) ;
					++ UserCount ; 
				} ; 
			}
			catch(Exception e)
			{
				Parser.LogMessage ( "** ERROR ** Database Exception thrown: " + e.ToString());
			}
			finally 
			{ 
				if ( reader != null ) 
					reader.Close();		
			} ; 

			Parser.LogMessage ( UserCount.ToString ( ) + " User IDs loaded." ) ;
			return UserIds ;
		}

		public Hashtable GetTitleIds ( )
		{
			Hashtable TitleIds = new Hashtable ( );
			// Instantiates a SqlDataReader object which moves through the Dataset one row at a time
			SqlDataReader reader = null ; 
			try
			{
				string SqlStatement = "SELECT i_TitleId from t_Titles WHERE ( i_Type = 0 ) " ; 
				SqlCommand cmd = new SqlCommand( ) ;
				cmd.CommandText = SqlStatement ;
				cmd.Connection = connection ;

				reader = cmd.ExecuteReader();
				while( reader.Read( ) )
				{ 
					int Id = ( int ) reader [ "i_TitleId" ] ; 
					TitleIds.Add ( Id , Id );
				} ; 
			}
			catch(Exception e)
			{
				Parser.LogMessage ( "** ERROR ** Database Exception thrown: " + e.ToString());
			}
			finally 
			{ 
				if ( reader != null ) 
					reader.Close();		
			} ; 
			return TitleIds ;
		}

		public ArrayList GetXonWatchIps ( )
		{
			ArrayList XonWatchIps = new ArrayList ( );
			// Instantiates a SqlDataReader object which moves through the Dataset one row at a time
			SqlDataReader reader = null ; 
			try
			{
//	t_ValidXonWatchIp
//	3	siValidXonWatchIPID	smallint	2	0	
//	0	vcDomain	varchar	50	0	
//	0	iIP	char	15	0	
//	0	iSubnetMask	char	15	0	
				string SqlStatement = "SELECT iIP, iSubnetMask from t_ValidXonWatchIp " ; 
				// Per domain : Later 
				// WHERE ( vc_Domain LIKE ... ) " ; 
				SqlCommand cmd = new SqlCommand( ) ;
				cmd.CommandText = SqlStatement ;
				cmd.Connection = connection ;

				reader = cmd.ExecuteReader();
				while( reader.Read( ) )
				{ 
					string IP = ( string ) reader [ "iIP" ] ; 
					string SubnetMask = ( string ) reader [ "iSubnetMask" ] ; 
					XonWatchIp Range = new XonWatchIp ( IP , SubnetMask ) ; 
					XonWatchIps.Add ( Range );
				} ; 
			}
			catch(Exception e)
			{
				Parser.LogMessage ( "** ERROR ** Database Exception thrown: " + e.ToString());
			}
			finally 
			{ 
				if ( reader != null ) 
					reader.Close();		
			} ; 
			return XonWatchIps ;
		}


		public bool Connect 
			( string Server , string Database , string User , string Password , string Share ) 
		{ 
			Parser.LogMessage ( "Connecting " + User + " - " + Password + 
				" to " + Database + " on " + Server + "..." ) ; 

			if ( Share == "" ) 
			{ 
//				bLocalHost = true ; 
			}
			else 
			{ 
//				bLocalHost = false ; 
				SharePath = Share ; 
			} ; 

			Connected = false ; 
			try 
			{ 
				// Creates a new SQL connection and then opens the connection
				connection = new System.Data.SqlClient.SqlConnection();
				connection.ConnectionString = 
					"data source=" + Server + 
					";initial catalog=" + Database + 
					";integrated security=SSPI;"+ 
					"User ID=" + User + ";" + 
					"Password=" + Password + ";" +
					"Packet Size=1024"; // smaller than usual for faster value inserts  
				connection.Open();

				Connected = true ; 
			} 
			catch (Exception ex) 
			{
				Parser.LogMessage ( "** ERROR ** Database Exception thrown: " + ex.ToString());
			}
			return Connected ; 
		} 

		public bool Disconnect ( ) 
		{ 
			Parser.LogMessage ( "Disconnecting from database..." ) ; 

			if ( connection != null ) 
				if ( connection.State != System.Data.ConnectionState.Closed ) 
					connection.Close();
			return true ; 
		} 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livestats\LogParser\MatchMaking.cs ===
using System;

namespace xonline.ops.tools.livestats.logparser 
{
	/// <summary>
	/// Summary description for MatchMaking.
	/// </summary>
	public class MatchMaking_SessionInsert_601
	{
//		Create table Mtch601
//		(
//		CurrentDT datetime null,
//		SessionID bigint null,
//		TitleID   int null,
//		hostXNAAddr varchar(100) null,
//		SessionKey varchar(64) null,
//		PublicOpen bit not null,
//		PrivateOpen bit not null,
//		PublicFilled bit not null,
//		PrivateFilled bit not null
//		)
		DateTime Timestamp ; 
		long SessionID ; 
		int TitleID   ; 
		string HostXNAAddr ; 
		string SessionKey ; 
		int PublicOpen ; 
		int PrivateOpen ; 
		int PublicFilled ; 
		int PrivateFilled ; 

		public MatchMaking_SessionInsert_601 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SessionID = Parser.ToLong  ( strItem ) ; break ;
					case  4 : TitleID  = Parser.ToInt ( strItem ) ; break ;
					case  5 : HostXNAAddr = strItem ; break ;
					case  6 : SessionKey = strItem ; break ;
					case  7 : PublicOpen = Parser.ToInt ( strItem ) ; break ;
					case  8 : PrivateOpen = Parser.ToInt ( strItem ) ; break ;
					case  9 : PublicFilled = Parser.ToInt ( strItem ) ; break ;
					case 10 : PrivateFilled = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class MatchMaking_SessionUpdate_602
	{
//		Create table Mtch602
//		(
//		CurrentDT datetime null,
//		SessionID bigint null,
//		TitleID   int null,
//		hostXNAddr varchar(100) null,
//		PublicOpen bit not null,
//		PrivateOpen bit not null,
//		PublicFilled bit not null,
//		PrivateFilled bit not null
//		)
		DateTime Timestamp ; 
		long SessionID ; 
		int TitleID   ; 
		string HostXNAAddr ; 
		int PublicOpen ; 
		int PrivateOpen ; 
		int PublicFilled ; 
		int PrivateFilled ; 

		public MatchMaking_SessionUpdate_602 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SessionID = Parser.ToLong ( strItem ) ; break ;
					case  4 : TitleID  = Parser.ToInt ( strItem ) ; break ;
					case  5 : HostXNAAddr = strItem ; break ;
					case  6 : PublicOpen = Parser.ToInt ( strItem ) ; break ;
					case  7 : PrivateOpen = Parser.ToInt ( strItem ) ; break ;
					case  8 : PublicFilled = Parser.ToInt ( strItem ) ; break ;
					case  9 : PrivateFilled = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class MatchMaking_SessionDelete_603
	{
//		Create table Mtch603
//		(
//		CurrentDT datetime null,
//		SessionID bigint null,
//		TitleID   int null
//		)
		DateTime Timestamp ; 
		long SessionID ; 
		int TitleID   ; 
		
		public MatchMaking_SessionDelete_603 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SessionID = Parser.ToLong ( strItem ) ; break ;
					case  4 : TitleID  = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}
	public class MatchMaking_DeadXbox_604
	{
//		Create table Mtch604
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi int null,
//		xboxID   bigint null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int    SGInt  ; 
		int    spi ; 
		long   XboxID ; 

		public MatchMaking_DeadXbox_604 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}
	public class MatchMaking_DeadSG_605
	{
//		Create table Mtch605
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int    SGInt  ; 
		public MatchMaking_DeadSG_605 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}
	public class MatchMaking_Search_606
	{
//		Create table Mtch606
//		(
//		CurrentDT datetime null,
//		TitleID   int null,
//		ProcIndex   int null,
//		NumParams   int null,
//		hr int null,
//		NumResults int null
//		)
		DateTime Timestamp ; 
		int TitleID   ; 
		int ProcIndex   ; 
		int NumParams   ; 
		int hr ; 
		int NumResults ; 

		public MatchMaking_Search_606 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : TitleID    = Parser.ToInt ( strItem ) ; break ;
					case  4 : ProcIndex  = Parser.ToInt ( strItem ) ; break ;
					case  5 : NumParams  = Parser.ToInt ( strItem ) ; break ;
					case  6 : hr = Parser.ToInt ( strItem ) ; break ;
					case  7 : NumResults = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livestats\LogParser\Feedback.cs ===
using System;

namespace xonline.ops.tools.livestats.logparser 
{
	/// <summary>
	/// Summary description for Feedback.
	/// </summary>

	public class Feedback_801
	{
		DateTime	Timestamp ; 
		public long	SendPUID ; 
		public long	TargetPUID ; 
		public int	TitleID ; 
		int			FeedbackType ; 
		string		NickName ; 

		public int	Batch ; 
		short	Year ; 
		short	Month ; 
		short	Day ; 
		short	Week ; 
		short	DayOfWeek ; 
		short	TimeSlot ; 

		public	Feedback_801 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case 0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case 1 : /* skip line type */ ; break ;
					case 2 : /* skip line description */ ; break ;
					case 3 : SendPUID   = Parser.ToLong ( strItem ) ; break ;
					case 4 : TargetPUID = Parser.ToLong ( strItem ) ; break ;
					case 5 : TitleID  = Parser.ToInt ( strItem ) ; break ;
					case 6 : FeedbackType = Parser.ToInt ( strItem ) ; break ;
					case 7 : NickName = strItem ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

			if ( NickName.IndexOf ( "'" ) != -1 ) 
			{ 
				NickName = NickName.Replace ( "'" , "''" ) ; 
			} ;
			Year       = ( short ) Timestamp.Year ; 
			Month      = ( short ) Timestamp.Month ; 
			Day        = ( short ) Timestamp.Day ; 
			TimeSpan ts = Timestamp - Parser.Week_0 ; 
			Week       = ( short ) ( ts.Days / 7 ) ; 
			// This enumeration ranges from zero, Sunday, to six, indicating Saturday.
			DayOfWeek  = ( short ) Timestamp.DayOfWeek ; 
			TimeSlot   = ( short ) Timestamp.Hour ; 

			Batch	   = -1 ; 

		} 

		public bool IsValid ( ) 
		{ 
			if ( ( Year > 2048 )   || ( Year < 2002 ) ) return false ; 
			if ( ( Month > 12 )    || ( Month < 0 ) ) return false ; 
			if ( ( Day > 31 )      || ( Day < 0 ) ) return false ; 
			if ( ( TimeSlot > 23 ) || ( TimeSlot < 0 ) ) return false ; 
			if ( ( DayOfWeek > 6 ) || ( DayOfWeek < 0 ) ) return false ; 
			if ( ( Week > 1000 )   || ( Week < 0 ) ) return false ; 
			if ( ( FeedbackType > 6 ) || ( FeedbackType < 0 ) ) return false ; 

			return true ; 
		} 

		public string ToSql ( ) 
		{ 
			if ( IsValid ( ) ) 
			{ 
//		t_Feedbacks
//
//	1	i_Batch	int	4	0	
//	0	si_Year	smallint	2	0	
//	0	si_Month	smallint	2	0	
//	0	si_Day	smallint	2	0	
//	0	si_Week	smallint	2	0	
//	0	si_DayOfWeek	smallint	2	0	
//	0	si_TimeSlot	smallint	2	0	
//	0	bi_AboutUser	bigint	8	0	
//	0	bi_FromUser	bigint	8	0	
//	0	iFeedbackType	int	4	0	
//	0	vcNickName	varchar	100	1	
				string Sql = 
					"INSERT INTO t_Feedbacks " +  
					"( i_Batch, si_Year , si_Month, si_Day, si_Week, si_DayOfWeek, si_TimeSlot, " + 
					" bi_AboutUser, bi_FromUser, iFeedbackType , vcNickName ) " +
					"VALUES ( " + ToString ( ) + " ) " ; 
				return Sql ; 
			} 
			else 
				return "" ; 
		} 

		public override string ToString ( ) 
		{ 
			return
				Batch.ToString ( ) + " , " + 
				Year.ToString ( ) + " , " + Month.ToString ( ) + " , " + Day.ToString ( ) + " , " + 
				Week.ToString ( ) + " , " + DayOfWeek.ToString ( ) + " , " + 
				TimeSlot.ToString ( ) + " , " + 
				TargetPUID.ToString ( ) + " , " + 
				SendPUID.ToString ( ) + " , " + 
				FeedbackType.ToString ( ) + " , " + 
				Parser.SQ + NickName + Parser.SQ ; 
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livestats\LogParser\Notification.cs ===
using System;
using System.Net ; 
using System.Globalization; 


namespace xonline.ops.tools.livestats.logparser 
{
	/// <summary>
	/// Summary description for Notification.
	/// </summary>
	public class Notification
	{
		DateTime		Timestamp ; 
		public int		ClientIP  ; 
		public string	ClientIPAsString  ; 
		int				ClientPort   ; 
		public long		UserPUID  ; 
		public int		TitleID   ; 

		public int		Batch ; 
		short Year ; 
		short Month ; 
		short Day ; 
		short Week ; 
		short DayOfWeek ; 
		short TimeSlot ; 

		public Notification ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : ClientIPAsString  = strItem ; break ;
					case  4 : ClientIP   = Parser.ToInt ( strItem ) ; break ;
					case  5 : ClientPort = Parser.ToInt ( strItem ) ; break ;
					case  6 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  7 : TitleID  = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

			Year       = ( short ) Timestamp.Year ; 
			Month      = ( short ) Timestamp.Month ; 
			Day        = ( short ) Timestamp.Day ; 
			TimeSpan ts = Timestamp - Parser.Week_0 ; 
			Week       = ( short ) ( ts.Days / 7 ) ; 
			// This enumeration ranges from zero, Sunday, to six, indicating Saturday.
			DayOfWeek  = ( short ) Timestamp.DayOfWeek ; 
			TimeSlot   = ( short ) Timestamp.Hour ; 

			Batch	   = -1 ; 
		}

		public bool IsValid ( )
		{ 
			if ( ( Year > 2048 )   || ( Year < 2002 ) ) return false ; 
			if ( ( Month > 12 )    || ( Month < 0 ) ) return false ; 
			if ( ( Day > 31 )      || ( Day < 0 ) ) return false ; 
			if ( ( TimeSlot > 23 ) || ( TimeSlot < 0 ) ) return false ; 
			if ( ( DayOfWeek > 6 ) || ( DayOfWeek < 0 ) ) return false ; 
			if ( ( Week > 1000 )   || ( Week < 0 ) ) return false ; 

			// IP as string and as integer should be the same 
			// These double casts looks silly but are necessary...
			long IpAsLong = 
				( long ) ( ( ( ulong ) ClientIP & 0x000000ff ) << 24 ) |
				( long ) ( ( ( ulong ) ClientIP & 0x0000FF00 ) <<  8 ) |
				( long ) ( ( ( ulong ) ClientIP & 0x00ff0000 ) >>  8 ) |
				( long ) ( ( ( ulong ) ClientIP & 0xFF000000 ) >> 24 ) ; 
			IPAddress Ip = new IPAddress ( IpAsLong ) ; 
			string IpAsString = Ip.ToString ( ) ; 
			if ( Ip.ToString ( ) != ClientIPAsString ) return false ; 

			// dont know how to check the IP port number... yet... 

			return true ; 
		} 

		public ulong Hash ( )
		{
			return 
				( ( ulong ) ClientIP << 32 ) + 
				( ( ulong ) ( Year - 2000 ) << 24 ) + 
				( ( ulong ) Month << 16 ) + 
				( ( ulong ) Day << 8 ) ; 
		}

		public string ToSql ( )
		{ 
//	t_xpnf
//	1	iBatchID	int	4	0	
//	2	dtCurrentTime	datetime	8	0	
//	0	iIP	int	4	0	
//	0	iPort	int	4	0	
//	2	biUserPUID	bigint	8	0	
//	0	iTitleID	int	4	0	
			if ( IsValid ( ) ) 
			{ 
				return 
					"INSERT INTO t_xpnf " +  
					"( iBatchID, dtCurrentTime , iIP, " + 
					"  iPort,  biUserPUID , iTitleID ) " + 
					"VALUES ( " + ToString ( ) + " ) " ; 
			} 
			else 
				return "" ; 
		} 

		public override string ToString ( ) 
		{ 
			return
				Batch.ToString ( ) + " , " + 
				Parser.SQ + 
				Timestamp.ToString (  "G" , DateTimeFormatInfo.InvariantInfo ) + 
				Parser.SQ + " , " + 
				ClientIP.ToString ( ) + " , " + 
				ClientPort.ToString ( ) + " , " + 
				UserPUID.ToString ( ) + " , " + 
				TitleID.ToString ( ) ;  
		} 

		public string ToSqlXonWatchAlert ( )
		{ 
			if ( IsValid ( ) ) 
			{ 
//	1	iBatchID	int	4	0	
//	2	dtCurrentTime	datetime	8	0	
//	0	IP	int	4	0			<<--------- Watch out this one
//	0	iport	int	4	0	
//	2	biUserPUID	bigint	8	0	
//	0	iTitleID	int	4	0	
				return 
					"INSERT INTO t_XonwatchAlerts " +  
					"( iBatchID, dtCurrentTime , IP, " + 
					"  iPort,  biUserPUID , iTitleID ) " + 
					"VALUES ( " + ToString ( ) + " ) " ; 
			} 
			else 
				return "" ; 
		} 

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livestats\LogParser\ParserDoc.cs ===
using System;
using System.IO ;
using System.Collections ;

namespace xonline.ops.tools.livestats.logparser 
{
	/// <summary>
	/// Summary description for ParserDoc.
	/// </summary>

	public class ParserDoc
	{
		ArrayList Presence = new ArrayList ( ) ; 
		Hashtable PresenceFromHash = new Hashtable ( ) ; 

		ArrayList Events			= new ArrayList ( ) ; 
		Hashtable EventsFromHash    = new Hashtable ( ) ; 

		ArrayList Users             = new ArrayList ( ) ; 
		Hashtable UsersFromId       = new Hashtable ( ) ; 
		ArrayList TestUsers         = new ArrayList ( ) ; 
		Hashtable TestUsersFromId   = new Hashtable ( ) ; 
		Hashtable XonWatchFromId    = new Hashtable ( ) ; 
		Hashtable TestAccountFromId = new Hashtable ( ) ; 

		ArrayList      Sessions   = new ArrayList ( ) ; 
		ArrayList ShortSessions   = new ArrayList ( ) ; 

		ArrayList Purchases  = new ArrayList ( ) ; 
		ArrayList Feedbacks  = new ArrayList ( ) ; 

		DatabaseLoader loader = new DatabaseLoader ( ) ; 

		Hashtable UserIds		= null ; 
		Hashtable TestUserIds	= null ; 
		Hashtable TitleIds		= null ; 
		ArrayList XonWatchIps   = null ; 

		ArrayList Notifications         = new ArrayList ( ) ; 
		Hashtable NotificationsFromHash = new Hashtable ( ) ; 

		BatchRec  Batch = null ; 
		ArrayList Files = new ArrayList ( ) ; 

		int EventCounter = 0 ; 
		int FileCounter = 0 ; 
		int ErrorCounter = 0 ; 
		int LineCounter = 0 ; 
		int BlankLineCounter = 0 ; 

		public ParserDoc()
		{
		}

		public bool ParseLogs ( string Server , string Database , string User , string Password , string Path ) 
		{ 
			// Clear global counters 
			EventCounter = 0 ;
			FileCounter = 0 ; 

			// Create a new batch 
			Batch = new BatchRec ( ) ; 
			// connect 
			Parser.LogMessage ( "Connecting to Database..." ) ; 
			if ( ! loader.Connect ( Server , Database , User , Password , "" ) ) 
			{ 
				Parser.LogMessage ( "** ERROR ** Failed to connect to database." ) ; 
				return false ; 
			} 
			else 
			{ 
				try 
				{ 
					// Check that we are running on an V2 database 
					Parser.LogMessage ( "Connected. Checking database schema... ( V2 update )" ) ; 
					string Sql = 
						"SELECT     COUNT ( sysobjects.name ) " + 
						" FROM      sysobjects " +
						" WHERE     ( xtype = 'U' ) AND ( " + 
						"  ( name = 't_Batches' ) OR " +
						"  ( name = 't_Files' ) ) " ; 
					int TableCount = loader.Scalar ( Sql ) ;
					if ( TableCount != 2 ) 
					{ 
						// Cant log anything in this old database
						Parser.LogMessage ( "** ERROR ** Version 1 database schema. Aborted." ) ; 
						return false ; 
					} ; 

					// Check that we are running on a V3 database 
					Parser.LogMessage ( "Connected. Checking database schema... ( V3 update )" ) ; 
					Sql = 
						"SELECT     COUNT ( sysobjects.name ) " + 
						" FROM      sysobjects " +
						" WHERE     ( xtype = 'U' ) AND ( " + 
						"  ( name = 't_xpnf' ) OR " +
						"  ( name = 't_ValidXonWatchIP' ) OR " +
						"  ( name = 't_XonwatchAlerts' ) ) " ; 
					TableCount = loader.Scalar ( Sql ) ;
					if ( TableCount != 3 ) 
					{ 
						// Cant log in this old database
						Parser.LogMessage ( "** ERROR ** Version 2 database schema. Aborted." ) ; 
						return false ; 
					} ; 

					int BatchId = 0 ; 
					if ( Parser.BatchId < -1 ) 
					{ 
						// Cant continue with an invalid Batch ID 
						Parser.LogMessage ( "** ERROR ** " + Parser.BatchId.ToString ( ) + " is not a valid Batch ID. Aborted." ) ; 
						return false ; 
					} 
					else
					{ 
						if ( Parser.BatchId == -1 ) 
						{
							// Kept for development only 
							if ( Parser.Server != "LaurentsBox" ) 
							{ 
								Parser.LogMessage ( "*** Warning ! *** Using undocumented backdoor..." ) ; 
							} ; 
							Parser.LogMessage ( "Creating a new batch record..." ) ; 
							loader.Execute ( Batch.ToSqlInsert ( ) ) ; 
							// Get the batch ID 
							BatchId = loader.Scalar ( Batch.ToSqlSelect ( ) ) ;
							Batch.BatchId = BatchId ; 
						} 
						else 
						{ 
							// BatchId is given on the command line 
							// Check we have a record with this ID 
							if ( 1 == loader.Scalar ( Batch.ToSqlVerify ( Parser.BatchId ) ) ) 
							{ 
								// Check we have no files with this ID 
								int FileCount = loader.Scalar ( Batch.ToSqlVerifyFiles ( Parser.BatchId ) ) ; 
								if ( 0 == FileCount ) 
								{ 
									Parser.LogMessage ( "Batch Id " + Parser.BatchId.ToString ( ) + " verified." ) ; 
									// everything looks good : Use the given ID 
									Batch.BatchId = Parser.BatchId ; 
								} 
								else 
								{
									// Cant continue  
									Parser.LogMessage ( "** ERROR ** " + FileCount.ToString ( ) + " Files already logged for batch ID " + Parser.BatchId.ToString ( ) + ". Aborted." ) ; 
									return false ; 
								} ; 
							} 
							else 
							{
								// Cant continue with an invalid Batch ID 
								Parser.LogMessage ( "** ERROR ** " + Parser.BatchId.ToString ( ) + " is not a valid Batch ID. Aborted." ) ; 
								return false ; 
							} ; 
						} ; 
					} ; 
					// all done with batch IDs
					Parser.LogMessage ( "New Batch started with ID #" + Batch.Id.ToString ( ) ) ;

					// load existing accounts into memory for fast lookups
					Parser.LogMessage ( "Loading Existing Accounts IDs in memory..." ) ; 
					UserIds = loader.GetUserIds ( ) ; 

					// load test users accounts into memory 
					Parser.LogMessage ( "Loading Test Users Accounts IDs in memory..." ) ; 
					TestUserIds = loader.GetTestUserIds ( ) ; 

					// load the list of test title IDs 
					Parser.LogMessage ( "Loading Test Title Ids in memory..." ) ; 
					TitleIds = loader.GetTitleIds ( ) ; 

					// load the list of XonWatch IP address ranges
					Parser.LogMessage ( "Loading XonWatch IP address ranges in memory..." ) ; 
					XonWatchIps = loader.GetXonWatchIps ( ) ; 
				} 
				catch ( Exception e ) 
				{ 
					Parser.LogMessage ( "** ERROR ** Database Exception thrown: " + e.Message ) ; 
				} 
				finally 
				{ 
					// nothing for now 
					// We stay connected to the database, we need that to log progress 
					// into the t_Files table
				} ; 
			} 

			// Determines what kind of name Path is and processes it appropriately
			if( File.Exists ( Path ) ) 
			{
				// This path is a file
				ProcessFile ( Path ); 
			}               
			else if ( Directory.Exists ( Path ) ) 
			{
				// This path is a directory
				ProcessDirectory ( Path ) ;
			}
			else 
			{
				Parser.LogMessage ( "** ERROR ** " + Path + " is not a valid file or directory." );
				Batch.Update ( BatchRec.Phases.Aborted ) ; 
			} ; 

			Parser.LogMessage ( FileCounter + " files processed." ) ;
			Parser.LogMessage ( EventCounter + " events processed." ) ;
			return true ; 
		} 


		public void ProcessDirectory ( string targetDirectory ) 
		{
			// Process all files in the directory passed in, and recurse on any directories 
			// that are found to process the files they contain. 

			// Process the list of files found in the directory
			string [] fileEntries = Directory.GetFiles ( targetDirectory , "*.log" );
			foreach ( string fileName in fileEntries )
				ProcessFile(fileName);

			// Recurse into subdirectories of this directory
			string [] subdirectoryEntries = Directory.GetDirectories ( targetDirectory ) ;
			foreach ( string subdirectory in subdirectoryEntries )
				ProcessDirectory ( subdirectory );
		}
	        
		public void ProcessFile ( string Path ) 
		{
			++ FileCounter ; 
			if ( FileCounter == 1 ) 
			{ 
				Batch.Update ( BatchRec.Phases.Parsing ) ; 
				loader.Execute ( Batch.ToSqlUpdate ( ) ) ; 
			} ; 

			Parser.LogMessage ( "Processing " + Path ) ;

			// Reset the file counters 
			LineCounter = 0 ; 
			BlankLineCounter = 0 ; 
			ErrorCounter = 0 ; 

			// Create a stream and gather some information about this file 
			StreamReader reader = null ; 
			FileInfo info = new FileInfo ( Path ) ; 
			DateTime WrittenTo = info.LastWriteTime ; 
			int FileLength = ( int ) info.Length ; 

			// Create a new file record
			FileRec FileRecord = 
				new FileRec ( Batch.Id , Path , FileLength , WrittenTo ) ; 
			// Check if we already have an entry in the database 
			int FileCount = loader.Scalar ( FileRecord.ToSqlVerify ( ) ) ; 
			if ( FileCount != 0 ) 
			{ 
				Parser.LogMessage ( "** ERROR ** " + Path + " has already been loaded in the database." ) ; 
				Parser.LogMessage ( "** ----- ** File Ignored. " ) ; 
				return ; 
			} ; 

			try 
			{ 
				reader = new StreamReader ( Path ) ; 
				for ( 
					string Line = reader.ReadLine ( ) ; 
					Line != null ; 
					Line = reader.ReadLine ( ) ) 
				{ 
					LineCounter ++ ; 
					// All lines MUST start with date and time followed by pipe, and then a 
					// 3 digit line code followed by another pipe char 
					// and some data, 4 bytes at least 
					
					// Date should start with "20", if not, we need to add it 
					// ( for UACS and maybe more ) 
					if ( ( Line.Length > 4 ) && 
						 ( Parser.IsNumeric ( Line [ 0 ] ) ) && 
						 ( Parser.IsNumeric ( Line [ 1 ] ) ) )
					{ 
						if ( ( Line [ 0 ] != '2' ) && 
							 ( Line [ 1 ] != '0' ) ) 
						{ 
							// This might cause problem in year 2020... 
							Line = "20" + Line ; 
						} ; 
					} ; 
					
					// First find the first pipe char, if we can
					int PipePosition = 0 ; 
					while ( ( PipePosition < Line.Length - 1 ) && 
						( Line [ PipePosition ] != '|' ) ) 
					{ 
						PipePosition ++ ; 
					} ; 
					
					// debug 
					//			char c = Line [ PipePosition ] ; 

					if ( ( Line.Length > 4 + 14 ) && ( PipePosition + 4 < Line.Length - 1 ) ) 
					{ 
						int CodePosition = PipePosition + 1 ; 

						if ( ( Parser.IsNumeric ( Line [ CodePosition + 0 ] ) ) && 
							 ( Parser.IsNumeric ( Line [ CodePosition + 1 ] ) ) && 
							 ( Parser.IsNumeric ( Line [ CodePosition + 2 ] ) ) && 
							 ( Line [ CodePosition + 3 ] == '|' ) )
						{ 
							++ EventCounter ; 
							int LogCode = 
								( Line [ CodePosition + 0 ] & 0x0F ) * 100 + 
								( Line [ CodePosition + 1 ] & 0x0F ) * 10 + 
								( Line [ CodePosition + 2 ] & 0x0F ) ; 
							switch ( LogCode ) 
							{ 
								case 103  : // End of Session ( Killed - Presence 103 )  
									Process_103 ( Line ) ; 
									break ; 

								case 501  : // Create Account ( UACS 501 ) 
									Process_501 ( Line ) ; 
									break ; 

								case 801  : // Feedback ( FBCK 801 ) 
									Process_801 ( Line ) ; 
									break ; 

								case 902  : // Purchase ( XBOS 902 ) 
									Process_902 ( Line ) ; 
									break ; 

								case 101  : // Notification ( Front Door Alive - XPFN 101 ) 
									Process_101 ( Line ) ; 
									break ; 

								// skip the lines we dont want to process 
								// XBOS 
								case 901  : break ; 
								case 903  : break ; 
								case 904  : break ; 
								case 905  : break ; 
								case 906  : break ; 
								case 907  : break ; 
								// Matchmaking  
								case 601  : break ; 
								case 602  : break ; 
								case 603  : break ; 
								case 604  : break ; 
								case 605  : break ; 
								case 606  : break ; 
								// UACS 
								case 502  : break ; 
								case 503  : break ; 
								case 504  : break ; 
								case 505  : break ; 
								case 506  : break ; 
								// Presence
								case 102  : break ; 
								case 104  : break ; 
								case 105  : break ; 
								case 106  : break ; 
								case 107  : break ; 
								case 108  : break ; 
								case 109  : break ; 
								case 110  : break ; 
								case 111  : break ; 
								case 112  : break ; 
								case 113  : break ; 
								case 114  : break ; 
								case 115  : break ; 
								case 116  : break ; 
								case 117  : break ; 
								//
								default : 
									++ ErrorCounter ; 
									Parser.LogMessage ( "** FORMAT ERROR ** Error reading file " + Path + " at line #" + LineCounter.ToString ( ) ) ; 
									Parser.LogMessage ( "** ------------ ** Log three digit code is unknown. Ignored. " + Line ) ; 
									break ; 
							} ; // end switch 
						} 
						else 
						{ 
							++ ErrorCounter ; 
							Parser.LogMessage ( "** FORMAT ERROR ** Error reading file " + Path + " at line #" + LineCounter.ToString ( ) ) ; 
							Parser.LogMessage ( "** ------------ ** Line should start with date/time, a pipe char, a three digit code, another pipe character. Ignored. " + Line ) ; 
						} ; 
					}
					else 
					{ 
						string BlankLine = Line.Trim ( ) ; 
						if ( BlankLine.Length > 1 ) 
						{ 
							++ ErrorCounter ; 
							Parser.LogMessage ( "** FORMAT ERROR ** Error reading file " + Path + " at line #" + LineCounter.ToString ( ) ) ; 
							Parser.LogMessage ( "** ------------ ** Line is truncated. Ignored." + Line ) ; 
						}
						else
						{
							// Parser.LogMessage ( "** Warning ** Blank Line. Ignored." ) ; 
							++ BlankLineCounter ;
						} ; 
					} ; 

					if ( ( ErrorCounter == 100 ) || 
					   ( ( ErrorCounter == 50 ) && ( LineCounter == 50 ) ) ) 
					{ 
						// dont piss me off with zillions of errors messages 
						Parser.LogMessage ( "** ERROR ** Too many format errors. File Processing Aborted. " ) ; 
						break ; 
					} 
				} ; 
			} 
			catch ( Exception e ) 
			{ 
				Parser.LogMessage ( "** IO ERROR ** Error reading file " + Path + " at line #" + LineCounter.ToString ( ) ) ; 
				Parser.LogMessage ( "** -------- ** " + e.Message ) ; 
			} 
			finally 
			{ 
				if ( reader != null ) 
					reader.Close ( ) ; 
			} ; 

			Parser.LogMessage ( 
				"Complete : " + 
				LineCounter.ToString ( ) + " logged events. " + 
				ErrorCounter.ToString ( ) + " Errors. " + 
				BlankLineCounter.ToString ( ) + " Blank lines." ) ; 

			// update our file record
			FileRecord.Update ( LineCounter, ErrorCounter ) ;
			// Add a row in the database
			loader.Execute ( FileRecord.ToSql ( ) ) ; 
		}

		public void Process_101 ( string Line ) 
		{ 
			// Notification ( Front Door Alive - XPFN 101 ) 

			Notification notification = new Notification ( Line ) ; 
			notification.Batch = Batch.Id ; 

			// A new IP ?   
			if ( notification.IsValid ( ) ) 
			{ 
				// we cannot check if it is a xonwatch account 
				// at this time simply because we may have not 
				// parsed them yet 
				if ( false /* IsXonwatchAccount */ ) 
				{ 
					// nothing here 
				} 
				else 
				{ 
					// We keep even if it is a test title and we we do the XonWatch 
					// filtering and hacking detection just before loading into the database. 
					if ( true /* ! TitleIds.ContainsKey ( notification.TitleID ) */ )
					{ 
						ulong hash = notification.Hash ( ) ; 
						if ( ! NotificationsFromHash.ContainsKey ( hash ) )
						{ 
							Notifications.Add ( notification ) ; 
							NotificationsFromHash.Add ( hash , notification ) ; 
						} ; 
					} ; 
				} ; 
			} 
			else 
			{ 
				++ ErrorCounter ; 
				Parser.LogMessage ( "** FORMAT ERROR ** Error reading file at line #" + LineCounter.ToString ( ) ) ; 
				Parser.LogMessage ( "** ------------ ** Invalid Killed Event. Ignored. " + Line ) ; 
			} ;
								
		} 

		public void Process_103 ( string Line ) 
		{ 
			// End of Session ( Killed - Presence 103 )  
			// Parse the line 
			Presence_Killed_103 killed = new Presence_Killed_103 ( Line ) ; 
			killed.Batch = Batch.Id ; 
			// A new session  
			if ( killed.IsValid ( ) ) 
			{ 
				// must not be a test title
				if ( ! TitleIds.ContainsKey ( killed.TitleID ) )
				{ 
					if ( killed.IsShort ( ) ) 
					{ 
						if ( ShortSessions.Count < 200 ) 
						{ 
							Parser.LogMessage ( "** Short Session ** at line #" + LineCounter.ToString ( ) ) ; 
							Parser.LogMessage ( "** ------------- ** Ignored. " + Line ) ; 
						} ; 
						ShortSessions.Add ( killed ) ; 
					}
					else 
						Sessions.Add ( killed ) ; 
				} ; 
			} 
			else 
			{ 
				++ ErrorCounter ; 
				Parser.LogMessage ( "** FORMAT ERROR ** Error reading file at line #" + LineCounter.ToString ( ) ) ; 
				Parser.LogMessage ( "** ------------ ** Invalid Killed Event. Ignored. " + Line ) ; 
			} ;
		} 

		public void Process_501 ( string Line ) 
		{ 
			// Create Account ( UACS 501 )
			Uacs_CreateAccount_501 account = new Uacs_CreateAccount_501 ( Line ) ;  
			account.Batch = Batch.Id ; 
			if ( account.IsValid ( ) ) 
			{ 
				if ( account.hr == 0 ) // account creation is ok 
				{ 
					// A new User ? 
					if ( account.IsTestAccount ( ) ) 
					{ 
						// check for local duplicate account IDs 
						if ( ! TestUsersFromId.ContainsKey ( account.UserPUID ) ) 
						{ 
							// can be a test title ? 
							// if ( ! TitleIds.ContainsKey ( account.TitleID ) )
							// { 
								TestUsers.Add ( account ) ; 
								TestUsersFromId.Add ( account.UserPUID , account ) ; 
							// } ; // end if test title 
						} 
						else 
						{ 
							++ ErrorCounter ; 
							Parser.LogMessage ( "** ERROR ** Test Account ID already exists in batch at line #" + LineCounter.ToString ( ) ) ; 
							Parser.LogMessage ( "** ----- ** Invalid Account Creation Event. Ignored. " + Line ) ; 
						} ; 
					} 
					else if ( account.IsXonWatchAccount ( ) ) 
					{ 
						// check for local duplicate account IDs 
						if ( ! XonWatchFromId.ContainsKey ( account.UserPUID ) ) 
						{ 
							XonWatchFromId.Add ( account.UserPUID , account ) ; 
						} 
						else 
						{ 
							++ ErrorCounter ; 
							Parser.LogMessage ( "** ERROR ** XonWatch Account ID already exists in batch at line #" + LineCounter.ToString ( ) ) ; 
							Parser.LogMessage ( "** ----- ** Invalid Account Creation Event. Ignored. " + Line ) ; 
						} ; 
					} 
					else 
					{ 
						// check for local duplicate account IDs 
						if ( ! UsersFromId.ContainsKey ( account.UserPUID ) ) 
						{ 
							// must not be a test title
							if ( ! TitleIds.ContainsKey ( account.TitleID ) )
							{ 
								Users.Add ( account ) ; 
								UsersFromId.Add ( account.UserPUID , account ) ; 
							} ; // end if test title 
						} 
						else 
						{ 
							++ ErrorCounter ; 
							Parser.LogMessage ( "** ERROR ** Account ID already exists in batch at line #" + LineCounter.ToString ( ) ) ; 
							Parser.LogMessage ( "** ----- ** Invalid Account Creation Event. Ignored. " + Line ) ; 
						} 
					} ; 
				} 
				else 
				{ 
					// Account creation failure 
				} ; 
			} 
			else 
			{ 
				++ ErrorCounter ; 
				Parser.LogMessage ( "** FORMAT ERROR ** Error reading file at line #" + LineCounter.ToString ( ) ) ; 
				Parser.LogMessage ( "** ------------ ** Invalid Account Creation Event. Ignored. " + Line ) ; 
			} ; 
		} 

		public void Process_801 ( string Line ) 
		{ 
			// Feedback ( FBCK 801 ) 
			Feedback_801 feedback = new Feedback_801 ( Line ) ; 
			feedback.Batch = Batch.Id ; 
			// must not be a test title
			if ( ! TitleIds.ContainsKey ( feedback.TitleID ) )
			{ 
				Feedbacks.Add ( feedback ) ; 
			} ; 
		} 

		public void Process_902 ( string Line ) 
		{ 
			// Purchase ( XBOS 902 ) 
			Xbos_Purchase_902 purchase = new Xbos_Purchase_902 ( Line ) ; 
			purchase.Batch = Batch.Id ; 
			// must not be a test title
			if ( ! TitleIds.ContainsKey ( purchase.TitleID ) )
			{ 
				Purchases.Add ( purchase ) ; 
			} ; 
		} 


		public void AggregateEvent ( EventRec Event ) 
		{ 
			if ( Event.IsValid ( ) ) 
			{ 
				// Look up the model to check if we already something for  
				// this event category in this time slot 
				ulong hash = Event.Hash ( ) ; 
				if ( EventsFromHash.ContainsKey ( hash ) ) 
				{ 
					// aready a record, aggregate 
					EventRec StoredEvent = ( EventRec ) EventsFromHash [ hash ] ; 
					StoredEvent.Aggregate ( ) ; 
				} 
				else 
				{ 
					// no record, create one
					Events.Add ( Event ) ; 
					// Add the key in the hash 
					EventsFromHash.Add ( hash , Event ) ; 
				} ; 
			} ;
		} 

		public void AggregateShortSessions ( ) 
		{ 
			int ValidUserTitleCounter = 0 ; 
			int TestTitleCounter = 0 ; 
			int XonwatchCounter = 0 ; 
			int TestUserCounter = 0 ; 
			int OtherCounter = 0 ; 

			foreach ( Presence_Killed_103 session in ShortSessions ) 
			{ 
				if ( session.IsValid ( ) ) 
				{ 
					// must be an existing account 
					if ( ( UsersFromId.ContainsKey ( session.UserPUID ) ) || 
						( UserIds.ContainsKey ( session.UserPUID ) ) ) 
					{ 
						// must not be a test title
						if ( ! TitleIds.ContainsKey ( session.TitleID ) )
						{ 
							++ ValidUserTitleCounter ; 
							// Create a new DB like record : Type 2 is short sessions
							EventRec Event = 
								new EventRec ( session.Batch , session.Timestamp , 2 ) ; 
							AggregateEvent ( Event ) ; 
						} 
						else 
						{ 
							++ TestTitleCounter ; 
						} 
					} 
					else 
					{ 
						if ( XonWatchFromId.ContainsKey ( session.UserPUID ) ) 
						{ 
							++ XonwatchCounter ; 
						} 
						else if ( ( TestUsersFromId.ContainsKey ( session.UserPUID ) ) || 
							( TestUserIds.ContainsKey ( session.UserPUID ) ) ) 
						{ 
							++ TestUserCounter ; 
						} 
						else 
						{ 
							++ OtherCounter ; 
						} ; 
					} ; 
				} ; 

			} ; // end foreach 

			Parser.LogMessage ( ValidUserTitleCounter.ToString ( ) + " Short sessions logged in database. ( Valid User, valid title ) " ) ; 
			Parser.LogMessage ( TestTitleCounter.ToString ( ) + " Test Title Short sessions." ) ; 
			Parser.LogMessage ( XonwatchCounter.ToString ( ) + " XonWatch Short sessions." ) ; 
			Parser.LogMessage ( TestUserCounter.ToString ( ) + " Test User Short sessions." ) ; 
			Parser.LogMessage ( OtherCounter.ToString ( ) + " Other Short sessions." ) ; 
		} 

		public void AggregateUserSessions ( ) 
		{ 
			foreach ( Presence_Killed_103 session in Sessions ) 
			{ 
				if ( session.IsValid ( ) ) 
				{ 
					// must be an existing account 
					if ( ( UsersFromId.ContainsKey ( session.UserPUID ) ) || 
						 ( UserIds.ContainsKey ( session.UserPUID ) ) ) 
					{ 
						// must not be a test title
						if ( ! TitleIds.ContainsKey ( session.TitleID ) )
						{ 
							// Create a new DB like Presence record 
							PresenceRec presence = 
								new PresenceRec ( session.Batch , session.Timestamp , session.TitleID , ( int ) session.Duration ) ; 
							if ( presence.IsValid ( ) ) 
							{ 
								// Look up the model to check if we already something for  
								// this title in this time slot 
								ulong hash = presence.Hash ( ) ; 
								if ( PresenceFromHash.ContainsKey ( hash ) ) 
								{ 
									// aready a record, aggregate 
									PresenceRec StoredPresence = ( PresenceRec ) PresenceFromHash [ hash ] ; 
									StoredPresence.Aggregate ( presence.TimePlayed ) ; 
								} 
								else 
								{ 
									// no record, create one
									Presence.Add ( presence ) ; 
									// Add the new key in the hash table 
									PresenceFromHash.Add ( hash , presence ) ; 
								} ; 
							} ; 
						} ; 
					} ; 
				} ; 

			} ; // end foreach 
		} 

		public void AggregateAccountCreations ( ) 
		{ 
			foreach ( Uacs_CreateAccount_501 account in Users ) 
			{ 
				if ( account.IsValid ( ) ) 
				{ 
					// not an existing account in the Database 
					if ( ! UserIds.ContainsKey ( account.UserPUID ) ) 
					{ 
						// We already check for :
						//		not an XonWatch account 
						//		not an special named account 
						//		no duplicates account IDs in the Users Arraylist
						//		not a test title

						// Create a new DB like record 
						EventRec Event = 
							new EventRec ( account.Batch , account.Timestamp , 1 ) ; 
						AggregateEvent ( Event ) ; 
					} ;
				} ; 
			} ; 
		} 

		public bool IsXonWatchIp ( int ClientIP ) 
		{
			foreach ( XonWatchIp IpRange in XonWatchIps ) 
			{ 
				if ( IpRange.InRange ( ClientIP ) ) 
					return true ; 
			} ; 
			return false ; 
		} 

		public void DetectXonWatchHacking ( ) 
		{ 
			Parser.LogMessage ( "Checking XonWatch accounts hacking attempts..." ) ; 
			int AlertCounter = 0 ; 
			foreach ( Notification notification in Notifications ) 
			{ 
				if ( notification.IsValid ( ) ) 
				{ 
					// must be a known user or a test user 
					if ( ( UsersFromId.ContainsKey ( notification.UserPUID ) ) || 
						( UserIds.ContainsKey ( notification.UserPUID ) )     || 
						( TestUsersFromId.ContainsKey ( notification.UserPUID ) ) || 
						( TestUserIds.ContainsKey ( notification.UserPUID ) ) ) 
					{
						// we're doing fine, do nothing 
					} 
					else 
					{ 
						// This is a XonWatch account 
						// Not a hacker if this is a test title 
						if ( ! TitleIds.ContainsKey ( notification.TitleID ) )
						{ 
							// check the IP address now 
							if ( ! IsXonWatchIp ( notification.ClientIP ) ) 
							{ 
								try 
								{ 
									loader.Execute ( notification.ToSqlXonWatchAlert ( ) ) ;
									++ AlertCounter ; 
								} 
								catch ( System.Data.SqlClient.SqlException e ) 
								{ 
									// PK violation : We already have this IP for this user 
									if ( e.Number != 0x0A43 ) 
									{ 
										throw e ; 
									} ; 
								} ; 
							} ; 
						} ; 
					} ; 
				} ; 
			} ; 
			Parser.LogMessage ( Notifications.Count.ToString ( ) + " IP addresses verified." ) ; 
			Parser.LogMessage ( AlertCounter.ToString ( ) + " XonWatch Alert records loaded into LiveStats database." ) ; 
		} 

		public void SaveLogs ( string Server , string Database , string User , string Password , string Share ) 
		{ 
			Parser.LogMessage ( XonWatchFromId.Count.ToString ( ) + " XonWatch accounts. " ) ; 
			Parser.LogMessage ( TestUsersFromId.Count.ToString ( ) + " Test accounts. (XBox*, Dash*, etc...) " ) ; 
			Parser.LogMessage ( Users.Count.ToString ( ) + " New user accounts. " ) ; 
			
			Parser.LogMessage ( "Statistics before filtering: " ) ; 
			Parser.LogMessage ( "   " + ShortSessions.Count.ToString ( ) + " short user sessions. " ) ; 
			Parser.LogMessage ( "   " + Sessions.Count.ToString ( ) + " user sessions. " ) ; 
			Parser.LogMessage ( "   " + Purchases.Count.ToString ( ) + " purchases. " ) ; 
			Parser.LogMessage ( "   " + Feedbacks.Count.ToString ( ) + " feedback reports. " ) ; 
			Parser.LogMessage ( "   " + Notifications.Count.ToString ( ) + " distinct IP notifications. " ) ; 

			if ( ! Batch.Aborted ) 
			{ 
				Batch.Update ( BatchRec.Phases.Inserting ) ; 
			} ; 
			loader.Execute ( Batch.ToSqlUpdate ( ) ) ; 
			
			int PresenceCounter = 0 ; 
			int EventCounter = 0 ;
 
			int AccountCounter		= 0 ; 
			int TestAccountCounter	= 0 ; 
			int SessionCounter		= 0 ; 
			int PurchaseCounter		= 0 ; 
			int FeedbackCounter		= 0 ; 
			int NotificationCounter = 0 ; 

			Parser.LogMessage ( "Saving logs to Database..." ) ; 
			// connect ( We should be already connected ) 
			if ( ! loader.Connect ( Server , Database , User , Password , Share ) ) 
			{ 
				Parser.LogMessage ( "** ERROR ** Failed to connect to database." ) ; 
			} 
			else 
			{ 
				Parser.LogMessage ( "Connected. " ) ; 

				// Now that we have in memory all recent user account creations
				// we can start aggregating 
				Parser.LogMessage ( "Aggregating User Sessions..." ) ; 
				AggregateUserSessions ( ) ; 

				Parser.LogMessage ( "Aggregating Short Sessions..." ) ; 
				AggregateShortSessions ( ) ; 

				Parser.LogMessage ( "Aggregating Account creations..." ) ; 
				AggregateAccountCreations ( ) ; 

				try 
				{
					// XonWatch Hackers 
					Parser.LogMessage ( "Detecting Hacking Attempts on XonWatch Account..." ) ; 
					DetectXonWatchHacking ( ) ; 

					// Load the presence records 
					Parser.LogMessage ( "Loading Presence records..." ) ; 
					foreach ( PresenceRec presence in Presence ) 
					{ 
						if ( presence.IsValid ( ) ) 
						{ 
							// must not be a test title
							if ( ! TitleIds.ContainsKey ( presence.Title ) )
							{ 
								++ PresenceCounter ; 
								loader.Execute ( presence.ToSql ( ) ) ; 
							}
						} ; 
					} ; 
					Parser.LogMessage ( PresenceCounter.ToString ( ) + " Presence records loaded into LiveStats database." ) ; 

					// Load the events 
					Parser.LogMessage ( "Loading Events records..." ) ; 
					foreach ( EventRec Event in Events ) 
					{ 
						if ( Event.IsValid ( ) ) 
						{ 
							++ EventCounter ; 
							loader.Execute ( Event.ToSql ( ) ) ;
						} ; 
					} ; 
					Parser.LogMessage ( EventCounter.ToString ( ) + " Event records loaded into LiveStats database." ) ; 

					// load new accounts 
					Parser.LogMessage ( "Loading Account Creation records..." ) ; 
					foreach ( Uacs_CreateAccount_501 account in Users ) 
					{ 
						if ( ! UserIds.ContainsKey ( account.UserPUID ) ) 
						{ 
							++ AccountCounter ; 
							loader.Execute ( account.ToSqlInsert ( ) ) ;
						} ; 
					} ; 
					Parser.LogMessage ( AccountCounter.ToString ( ) + " New account records loaded into LiveStats database." ) ; 

					Parser.LogMessage ( "Loading Test Account Creation records..." ) ; 
					foreach ( Uacs_CreateAccount_501 account in TestUsers ) 
					{ 
						if ( ! TestUserIds.ContainsKey ( account.UserPUID ) ) 
						{ 
							++ TestAccountCounter ; 
							loader.Execute ( account.ToSqlInsertTest ( ) ) ;
						} ; 
					} ; 
					Parser.LogMessage ( TestAccountCounter.ToString ( ) + " New test account records loaded into LiveStats database." ) ; 

					// load sessions 
					Parser.LogMessage ( "Loading Sessions records..." ) ; 
					foreach ( Presence_Killed_103 session in Sessions ) 
					{ 
						if ( session.IsValid ( ) ) 
						{ 
							if ( ( UsersFromId.ContainsKey ( session.UserPUID ) ) || 
								 ( UserIds.ContainsKey ( session.UserPUID ) ) ) 
							{ 
								// must not be a test title
								if ( ! TitleIds.ContainsKey ( session.TitleID ) )
								{ 
									++ SessionCounter ; 
									loader.Execute ( session.ToSql ( ) ) ;
								} ; 
							} ; 
						} ; 
					} ; 
					Parser.LogMessage ( SessionCounter.ToString ( ) + " Sessions records loaded into LiveStats database." ) ; 

					// load feedbacks 
					Parser.LogMessage ( "Loading feedback records..." ) ; 
					foreach ( Feedback_801 feedback in Feedbacks ) 
					{ 
						if ( feedback.IsValid ( ) ) 
						{ 
							if ( ( UsersFromId.ContainsKey ( feedback.SendPUID ) ) || 
								( UserIds.ContainsKey ( feedback.SendPUID ) ) ) 
							{ 
								if ( ( UsersFromId.ContainsKey ( feedback.TargetPUID ) ) || 
									( UserIds.ContainsKey ( feedback.TargetPUID ) ) ) 
								{ 
									// must not be a test title
									if ( ! TitleIds.ContainsKey ( feedback.TitleID ) )
									{ 
										++ FeedbackCounter ; 
										loader.Execute ( feedback.ToSql ( ) ) ;
									} ; 
								} ; 
							} ; 
						} ; 
					} ; 
					Parser.LogMessage ( FeedbackCounter.ToString ( ) + " feedback records loaded into LiveStats database." ) ; 

					// load purchases 
					Parser.LogMessage ( "Loading Purchases records..." ) ; 
					foreach ( Xbos_Purchase_902 purchase in Purchases ) 
					{ 
						if ( purchase.IsValid ( ) ) 
						{ 
							// must be a known user 
							if ( ( UsersFromId.ContainsKey ( purchase.UserPUID ) ) || 
								( UserIds.ContainsKey ( purchase.UserPUID ) ) ) 
							{ 
								// must not be a test title
								if ( ! TitleIds.ContainsKey ( purchase.TitleID ) )
								{ 
									++ PurchaseCounter ; 
									loader.Execute ( purchase.ToSql ( ) ) ;
								} ; 
							} ; 
						} ; 
					} ; 
					Parser.LogMessage ( PurchaseCounter.ToString ( ) + " Purchase records loaded into LiveStats database." ) ; 

					// load Ip addresses from FD Alive Notifications 
					Parser.LogMessage ( "Loading FD Alive Notifications..." ) ; 
					foreach ( Notification notification in Notifications ) 
					{ 
						if ( notification.IsValid ( ) ) 
						{ 
							// must be a known user 
							if ( ( UsersFromId.ContainsKey ( notification.UserPUID ) ) || 
								( UserIds.ContainsKey ( notification.UserPUID ) ) ) 
							{ 
								// must not be a test title
								if ( ! TitleIds.ContainsKey ( notification.TitleID ) )
								{ 
									try 
									{ 
										loader.Execute ( notification.ToSql ( ) ) ;
										++ NotificationCounter ; 
									} 
									catch ( System.Data.SqlClient.SqlException e ) 
									{ 
										// PK violation : We already have this IP for this user 
										if ( e.Number != 0x0A43 ) 
										{ 
											throw e ; 
										} ; 
									} ; 
								} ; 
							} ; 
						} ; 
					} ; 
					Parser.LogMessage ( NotificationCounter.ToString ( ) + " Notification records loaded into LiveStats database." ) ; 

					// all done 
					Parser.LogMessage ( "Loading to Database succeeded." ) ; 
					if ( ! Batch.Aborted ) 
					{ 
						Batch.Update ( BatchRec.Phases.Completed ) ; 
					} ; 
					loader.Execute ( Batch.ToSqlUpdate ( ) ) ; 
				} 
				catch ( Exception e ) 
				{ 
					Parser.LogMessage ( "** ERROR ** Database Exception thrown: " + e.Message ) ; 

					Batch.Update ( BatchRec.Phases.Aborted ) ; 
					loader.Execute ( Batch.ToSqlUpdate ( ) ) ; 
				} 
				finally 
				{ 
					loader.Disconnect ( ) ;
				} ; 
	
				Parser.LogMessage ( "Process complete. Stopped." ) ; 
			} 
		} 

	} // end class 

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livestats\LogParser\Parser.cs ===
using System;
using System.IO ;
using System.Text ;

namespace xonline.ops.tools.livestats.logparser 
{
	class Parser
	{
		ParserDoc doc = new ParserDoc ( ) ;

		public static bool IsNumeric ( char c ) 
		{
			return ( ( c >= '0' ) && ( c <= '9' ) ) ; 
		} 

		public static int ToInt ( string strItem ) 
		{
			if ( strItem == "" ) 
				return 0 ; 
			else 
			{ 
				if ( strItem [ 0 ] == '-' ) 
					return Convert.ToInt32 ( strItem ) ; 
				else 
					return ( int ) Convert.ToUInt32 ( strItem ) ; 
			} ; 
		} 

		public static long ToLong ( string strItem ) 
		{
			if ( strItem == "" ) 
				return 0 ; 
			else 
			{ 
				if ( strItem [ 0 ] == '-' ) 
					return Convert.ToInt64 ( strItem ) ; 
				else 
					return ( long ) Convert.ToUInt64 ( strItem ) ; 
			} ; 
		} 

		public static void LogMessage ( string Message ) 
		{ 
			// Prepend date and time to message.
			DateTime now = DateTime.Now ;
			string LoggedMessage = now.ToString ( ) + " - " + Message ; 

			// Log to file 
			string Filename = "Parser_" + now.Year.ToString ( ) + now.Month.ToString ( ) + now.Day.ToString ( ) ; 
			Filename  = Parser.LogPath + Filename + ".log" ; 
			StreamWriter log = null ; 
			try 
			{ 
				log = new StreamWriter ( Filename , true ) ; 
				log.WriteLine ( LoggedMessage ) ; 
			} 
			catch ( Exception e ) 
			{ 
				// If we get an exception here, we wont be able to log it.
				Console.WriteLine ( e.Message ) ;
			}
			finally 
			{ 
				if ( log != null ) 
					log.Close ( ) ; 
			} ; 

			Console.WriteLine ( LoggedMessage ) ; 
		} 
		/// <summary>
		/// The main entry point for the application.
		/// </summary>		
		
		static Parser TheApp = null ; 
		[STAThread]
		static void Main ( string [] args )
		{
			TheApp = new Parser () ; 
			if ( TheApp.Start ( args ) ) 
			{ 
				if ( TheApp.doc.ParseLogs ( Server , Database , User , Password , Path ) ) 
					TheApp.doc.SaveLogs ( Server , Database , User , Password , Share ) ; 
			} ; 
		}

		public bool Start ( string[] args ) 
		{ 
			// 3.1 is always the version that works... 
			Console.WriteLine ( "Log Parser - Version 3.1 - Copyright 2002 Microsoft Corporation " ) ; 

			string CommandLine = "" ; 
			foreach ( string arg in args ) CommandLine += arg ; 
			bool Start = true ; 
			if ( TheApp.LoadAppSettings ( CommandLine ) ) 
			{ 
				LogMessage ( "Log Parser - Version 3.1 - Started." ) ; 
			} 
			else
				Start = false ; 
			return Start ; 
		} 

		// Time Origin for Week number 
		public static DateTime Week_0 = new DateTime ( 2002, 7, 21 ) ; 
		// Handy string for SQL statements 
		public const string SQ = "'" ; 

		// Location of source log files 
		public static string Path     = @"\\LaurentsBox\RawLogs\" ; // the share name where the source logs files are.

		// Location of the log file
		public static string LogPath  = @"..\Log\" ; // the location where the parser is writing its own log files.

		// Database 
		// 
		public static string Server   = "LaurentsBox" ;    // The machine name hosting the matchmaking database
		public static string Database = "LiveStats" ;      // The matchmaking database name 
		public static string User     = "LiveStatsWriter" ;// User SQL account 
		public static string Password = "onemorerainyday" ;// Password for the above account 
		public static string Share    = @"\\LaurentsBox\Proximity\" ; // the share name where SQL server will pick up files to bulk insert.

		public static int    BatchId  = -1 ; // if -1 : Create a new row in table t_Batches 
											 // else  : Use the given ID ( if valid ) 
		public static int    ShortSessionTime = 1000 ; // expressed in milliseconds 

		public bool LoadAppSettings ( string AppSettings ) 
		{ 
			bool   Success = true ; 

			Tokens tokens = new Tokens ( AppSettings, new char [ ] {'/','='} );
			int nToken = 0 ;  
			string Key = "" ; 
			string Value = "" ; 
			foreach ( string strItem in tokens ) 
			{
				if ( nToken > 0 ) 
				{ 
					if ( nToken % 2 == 1 ) 
						Key = strItem ; 
					else 
						Value = strItem ; 

					if ( nToken % 2 == 0 ) 
					{ 
						Key = Key.ToLower ( ) ; 
						switch ( Key )
						{
							// Database 
							case "server"   : Server   = Value ; break ;
							case "database" : Database = Value ; break ;
							case "user"     : User     = Value ; break ;
							case "password" : Password = Value ; break ;
							case "path"     : Path     = Value ; break ; 
							case "share"    : 
								Share    = Value ; 
								string MachineName = System.Environment.MachineName ; 
								if ( ( Server == MachineName ) || ( Share == "localhost" ) ) 
									Share = "" ; 
								break ;
							case "logpath"    : 
								LogPath    = Value ; 
								if ( ! Directory.Exists ( LogPath ) ) 
								{
									LogMessage ( "** ERROR ** - Specified log path does not exist. Aborted." ) ;
									Success = false ; 
								} ; 
								break ;
							case "batch"  : BatchId  = Convert.ToInt32 ( Value ) ; 
								if ( BatchId <= 0 ) 
								{ 
									LogMessage ( "** ERROR ** - Illegal Batch ID. Aborted." ) ;
									Success = false ; 
								} ; 
								break ;
							
							case "shortsession"  : ShortSessionTime  = Convert.ToInt32 ( Value ) ; 
								if ( ( ShortSessionTime <= 0 ) || ( ShortSessionTime > 480000 ) ) 
								{ 
									LogMessage ( "** ERROR ** - Illegal Short Session Time." ) ;
									Success = false ; 
								} ; 
								break ;
							default : 
								break ; 
						} ; // end switch key 
					} ; 
				} ; 
				++ nToken ; 
			} ; // end for each 

			return Success ; 
		} 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livestats\LogParser\PresenceRec.cs ===
using System;

namespace xonline.ops.tools.livestats.logparser 
{
	/// <summary>
	/// Summary description for PresenceRec.
	/// </summary>
	public class PresenceRec
	{
		int	  Batch ; 
		short Year ; 
		short Month ; 
		short Day ; 
		short Week ; 
		short DayOfWeek ; 
		short TimeSlot ; 
		public int   Title ; 
		int   Users ; 
		public long TimePlayed ; 

		public PresenceRec ( int _Batch , DateTime dt , int _Title , int _TimePlayed )
		{
			Batch      = _Batch ; 
			Year       = ( short ) dt.Year ; 
			Month      = ( short ) dt.Month ; 
			Day        = ( short ) dt.Day ; 
			TimeSpan ts = dt - Parser.Week_0 ; 
			Week       = ( short ) ( ts.Days / 7 ) ; 
			// This enumeration ranges from zero, Sunday, to six, indicating Saturday.
			DayOfWeek  = ( short ) dt.DayOfWeek ; 
			TimeSlot   = ( short ) dt.Hour ; 
			Title      = _Title ; 
			Users      = 1 ; 
			TimePlayed = _TimePlayed  ;
		}

		public bool IsValid ( ) 
		{ 
			if ( ( Year > 2048 )   || ( Year < 2002 ) ) return false ; 
			if ( ( Month > 12 )    || ( Month < 0 ) ) return false ; 
			if ( ( Day > 31 )      || ( Day < 0 ) ) return false ; 
			if ( ( TimeSlot > 23 ) || ( TimeSlot < 0 ) ) return false ; 
			if ( ( DayOfWeek > 6 ) || ( DayOfWeek < 0 ) ) return false ; 
			if ( ( Week > 1000 )   || ( Week < 0 ) ) return false ; 

			return true ; 
		} 

		public void Aggregate ( long _TimePlayed )
		{ 
			Users ++ ; 
			TimePlayed += _TimePlayed  ;
		} 

		public ulong Hash ( )
		{
			return 
				( ( ulong ) Title << 32 ) + 
				( ( ulong ) ( Year - 2000 ) << 24 ) + 
				( ( ulong ) Month << 16 ) + 
				( ( ulong ) Day << 8 ) + 
				( ( ulong ) TimeSlot )  ; 
		}

		public string ToSql ( ) 
		{ 
			if ( IsValid ( ) ) 
			{ 
				string Sql = 
				// return 
				"INSERT INTO t_Presence " +  
				"( i_Batch, si_Year , si_Month, si_Day, si_Week, si_DayOfWeek, si_TimeSlot, i_Title, i_Users, i_TimePlayed ) " +
				"VALUES ( " + ToString ( ) + " ) " ; 
				return Sql ; 
			} 
			else 
				return "" ; 
		} 

		public override string ToString ( ) 
		{ 
			int Seconds = ( int ) ( ( ( double ) TimePlayed + 500.0 ) / 1000.0 ) ;  
			return
				Batch.ToString ( ) + " , " + 
				Year.ToString ( ) + " , " + Month.ToString ( ) + " , " + Day.ToString ( ) + " , " + 
				Week.ToString ( ) + " , " + DayOfWeek.ToString ( ) + " , " + 
				TimeSlot.ToString ( ) + " , " + Title.ToString ( ) + " , " + 
				Users.ToString ( ) + " , " + Seconds.ToString ( ) ; 
		} 

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livestats\LogParser\Uacs.cs ===
using System;
using System.Globalization; 

namespace xonline.ops.tools.livestats.logparser 
{
	/// <summary>
	/// Summary description for Uacs.
	/// </summary>
	public class Uacs_CreateAccount_501
	{
//		3	bi_UserID	bigint	8	0
//		0	i_Batch	int	4	0
//		0	i_Country	int	4	0
//		0	i_Language	int	4	0
//		0	i_Title	int	4	0
//		0	dt_Created	datetime	8	0
//		0	vc_PostalCode	varchar	12	0
//		0	vc_GamerTag	varchar	50	0
//		0	vc_Email	varchar	50	0
//		0	vc_Voucher	varchar	50	0

		public	DateTime Timestamp ; 
		public  long	UserPUID   ; 
		public  int		hr ; 
		string	GamerTag ; 
		string	Email ; 
		int 	CountryID  ;
		string	PostalCode ; 
		int		LanguageID ; 
		long	XboxID ; 
		public  int		TitleID   ; 
		string	VoucherHash ; 

		public  int	Batch ; 
		short Year ; 
		short Month ; 
		short Day ; 
		short Week ; 
		short DayOfWeek ; 
		short TimeSlot ; 

		public Uacs_CreateAccount_501 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  4 : hr = Parser.ToInt ( strItem ) ; break ;
					case  5 : GamerTag = strItem ; break ;
					case  6 : Email = strItem ; break ;
					case  7 : CountryID = Parser.ToInt ( strItem ) ; break ;
					case  8 : PostalCode = strItem ; break ;
					case  9 : LanguageID = Parser.ToInt ( strItem ) ; break ;
					case 10 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case 11 : TitleID = Parser.ToInt ( strItem ) ; break ;
					case 12 : VoucherHash = strItem ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

			if ( GamerTag.IndexOf ( "'" ) != -1 ) 
			{ 
				GamerTag = GamerTag.Replace ( "'" , "''" ) ; 
			} ;
			if ( Email.IndexOf ( "'" ) != -1 ) 
			{ 
				Email = Email.Replace ( "'" , "''" ) ; 
			} ;

			Year       = ( short ) Timestamp.Year ; 
			Month      = ( short ) Timestamp.Month ; 
			Day        = ( short ) Timestamp.Day ; 
			TimeSpan ts = Timestamp - Parser.Week_0 ; 
			Week       = ( short ) ( ts.Days / 7 ) ; 
			// This enumeration ranges from zero, Sunday, to six, indicating Saturday.
			DayOfWeek  = ( short ) Timestamp.DayOfWeek ; 
			TimeSlot   = ( short ) Timestamp.Hour ; 

			Batch	   = -1 ; 
		} 

		public bool IsValid ( ) 
		{ 
			if ( ( Year > 2048 )   || ( Year < 2002 ) ) return false ; 
			if ( ( Month > 12 )    || ( Month < 0 ) ) return false ; 
			if ( ( Day > 31 )      || ( Day < 0 ) ) return false ; 
			if ( ( TimeSlot > 23 ) || ( TimeSlot < 0 ) ) return false ; 
			if ( ( DayOfWeek > 6 ) || ( DayOfWeek < 0 ) ) return false ; 
			if ( ( Week > 1000 )   || ( Week < 0 ) ) return false ; 

			if ( GamerTag.Length == 0 ) return false ; 

			return true ; 
		} 

		public bool IsXonWatchAccount ( ) 
		{ 
			if ( GamerTag.Length > 1 ) 
				return ( GamerTag [ 0 ] == '0' ) || ( GamerTag [ 0 ] == '1' ) ; 
			else 
				return false ; 
		} 

		public bool IsTestAccount ( ) 
		{ 
			string LoweredGamerTag = GamerTag.ToLower ( ) ; 
			if ( LoweredGamerTag.StartsWith ( "xbox" ) )		return true ; 
			if ( LoweredGamerTag.StartsWith ( "dash" ) )		return true ; 
			if ( LoweredGamerTag.StartsWith ( "functional" ) )	return true ; 
			if ( LoweredGamerTag.StartsWith ( "xoc" ) )			return true ; 

			string LoweredEmail = Email.ToLower ( ) ; 
			if ( LoweredEmail.StartsWith ( "cwilson" ) )		return true ; 
			if ( LoweredEmail.StartsWith ( "dalbert" ) )		return true ; 
			if ( LoweredEmail.StartsWith ( "ericaz" ) )			return true ; 
			if ( LoweredEmail.StartsWith ( "jbernard" ) )		return true ; 
			if ( LoweredEmail.StartsWith ( "xoc" ) )			return true ; 

			return false ; 
		} 

		public string ToSqlInsert ( ) 
		{ 
			return 
				"INSERT INTO t_Users ( bi_UserID , i_Batch, i_Country , i_Language , i_Title , " + 
				" dt_Created , vc_PostalCode , vc_GamerTag , vc_Email , vc_Voucher ) " + 
				" VALUES ( " + ToString ( ) + " ) " ; 
		} 

		public string ToSqlInsertTest ( ) 
		{ 
			return 
				"INSERT INTO t_TestUsers ( bi_UserID , i_Batch, i_Country , i_Language , i_Title , " + 
				" dt_Created , vc_PostalCode , vc_GamerTag , vc_Email , vc_Voucher ) " + 
				" VALUES ( " + ToString ( ) + " ) " ; 
		} 

		public override string ToString ( ) 
		{ 
			return
				UserPUID.ToString ( ) + " , " + Batch.ToString ( ) + " , " + 
				CountryID.ToString ( ) + " , " + LanguageID.ToString ( ) + " , " + 
				TitleID.ToString ( ) + " , " + 
				Parser.SQ + Timestamp.ToString ( "G" , DateTimeFormatInfo.InvariantInfo ) + Parser.SQ + " , " + 
				Parser.SQ + PostalCode + Parser.SQ + " , " + 
				Parser.SQ + GamerTag + Parser.SQ + " , " + 
				Parser.SQ + Email + Parser.SQ + " , " + 
				Parser.SQ + VoucherHash + Parser.SQ ; 
		} 

		public string ToSqlSelect ( ) 
		{ 
			return 
				"SELECT bi_UserID FROM t_Users " + 
				" WHERE ( vc_GamerTag = " + Parser.SQ + GamerTag + Parser.SQ + " ) " ; 
		} 
	}

	public class Uacs_ReserveName_502
	{
//		Create table Xuac502
//		(
//		CurrentDT datetime null,
//		XboxID   bigint null,
//		GamerTag varchar(64) null,
//		CountryID smallint null,
//		hr int null,
//		NameVetted bit not null
//		)
		DateTime Timestamp ; 
		long XboxID   ; 
		string GamerTag ; 
		string CountryID ; 
		int hr ; 
		int NameVetted ; 
		
		public Uacs_ReserveName_502 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  4 : GamerTag = strItem ; break ;
					case  5 : CountryID = strItem ; break ;
					case  6 : hr = Parser.ToInt ( strItem ) ; break ;
					case  7 : NameVetted = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Uacs_VerifyVoucher_503
	{
//		Create table Xuac503
//		(
//		CurrentDT datetime null,
//		XboxID   bigint null,
//		CountryID smallint null,
//		VoucherHash varchar(45) null,
//		hr int null,
//		)
		DateTime Timestamp ; 
		long XboxID    ;
		string CountryID ; 
		string VoucherHash ; 
		int hr ; 
		
		public Uacs_VerifyVoucher_503 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  4 : CountryID = strItem ; break ;
					case  5 : VoucherHash = strItem ; break ;
					case  6 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Uacs_SetPaymentInfo_504
	{
//		Create table Xuac504
//		(
//		CurrentDT datetime null,
//		UserPUID   bigint null,
//		hr int null
//		)
		DateTime Timestamp ; 
		long UserPUID ; 
		int hr ; 
		
		public Uacs_SetPaymentInfo_504 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  4 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Uacs_RestoreAccount_505
	{
//		Create table Xuac505
//		(
//		CurrentDT datetime null,
//		XboxID   bigint null,
//		GamerTag varchar(64) null,
//		UserPUID   bigint null,
//		hr int null
//		)
		DateTime Timestamp ; 
		long XboxID ; 
		string GamerTag ; 
		long UserPUID ; 
		int hr ; 
		
		public Uacs_RestoreAccount_505 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  4 : GamerTag = strItem ; break ;
					case  5 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  6 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Uacs_ChangeGamerTag_506
	{
//		Create table Xuac506
//		(
//		CurrentDT datetime null,
//		UserPUID   bigint null,
//		XboxID   bigint null,
//		OldGamerTag varchar(64) null,
//		NewGamerTag varchar(64) null,
//		hr int null
//		)
		DateTime Timestamp ; 
		long UserPUID ; 
		long XboxID   ; 
		string OldGamerTag ;
		string NewGamerTag ; 
		int hr ; 
		
		public Uacs_ChangeGamerTag_506 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  4 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  5 : OldGamerTag = strItem ; break ;
					case  6 : NewGamerTag = strItem ; break ;
					case  7 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livestats\LogParser\Presence.cs ===
using System;

namespace xonline.ops.tools.livestats.logparser 
{
	/// <summary>
	/// Summary description for Presence.
	/// </summary>
	public class Presence_Alive_102
	{
		DateTime Timestamp ; 
		string SG ; 
		int SGInt  ; 
		int spi ; 
		long XboxID ; 
		long UserPUID ; 
		int TitleID ; 
		int State ; 
		long MatchSessionID ; 
		int hr ; 

		public Presence_Alive_102 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi  = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  8 : TitleID  = Parser.ToInt ( strItem ) ; break ;
					case  9 : State = Parser.ToInt ( strItem ) ; break ;
					case 10 : MatchSessionID = Parser.ToLong ( strItem ) ; break ;
					case 11 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Presence_Killed_103
	{
		public DateTime Timestamp ; 
		public long UserPUID ; 
		public int  TitleID ; 
		public int  State ; 
		public long MatchSessionID ; 
		public long Duration ; 

		public int	  Batch ; 
		short Year ; 
		short Month ; 
		short Day ; 
		short Week ; 
		short DayOfWeek ; 
		short TimeSlot ; 

		public Presence_Killed_103 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  4 : TitleID  = Parser.ToInt ( strItem ) ; break ;
					case  5 : State = Parser.ToInt ( strItem ) ; break ;
					case  6 : MatchSessionID = Parser.ToLong ( strItem ) ; break ;
					case  7 : Duration = Parser.ToLong ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

			Year       = ( short ) Timestamp.Year ; 
			Month      = ( short ) Timestamp.Month ; 
			Day        = ( short ) Timestamp.Day ; 
			TimeSpan ts = Timestamp - Parser.Week_0 ; 
			Week       = ( short ) ( ts.Days / 7 ) ; 
			// This enumeration ranges from zero, Sunday, to six, indicating Saturday.
			DayOfWeek  = ( short ) Timestamp.DayOfWeek ; 
			TimeSlot   = ( short ) Timestamp.Hour ; 

			Batch	   = -1 ; 
		}

		public bool IsValid ( ) 
		{ 
			if ( ( Year > 2048 )   || ( Year < 2002 ) ) return false ; 
			if ( ( Month > 12 )    || ( Month < 0 ) ) return false ; 
			if ( ( Day > 31 )      || ( Day < 0 ) ) return false ; 
			if ( ( TimeSlot > 23 ) || ( TimeSlot < 0 ) ) return false ; 
			if ( ( DayOfWeek > 6 ) || ( DayOfWeek < 0 ) ) return false ; 
			if ( ( Week > 1000 )   || ( Week < 0 ) ) return false ; 

			if ( Duration > 2000000000 ) return false ; 

			return true ; 
		} 

		public bool IsShort ( ) 
		{ 
			return ( Duration < Parser.ShortSessionTime ) ; 
		} 
		
		public string ToSql ( ) 
		{ 
			if ( IsValid ( ) ) 
			{ 
				string Sql = 
					// return 
					"INSERT INTO t_Sessions " +  
					"( i_Batch, si_Year , si_Month, si_Day, si_Week, si_DayOfWeek, si_TimeSlot, " + 
					" bi_User, i_Title, i_TimePlayed ) " +
					"VALUES ( " + ToString ( ) + " ) " ; 
				return Sql ; 
			} 
			else 
				return "" ; 
		} 

		public override string ToString ( ) 
		{ 
			int Seconds = ( int ) ( ( ( double ) Duration + 500.0 ) / 1000.0 ) ;  
			return
				Batch.ToString ( ) + " , " + 
				Year.ToString ( ) + " , " + Month.ToString ( ) + " , " + Day.ToString ( ) + " , " + 
				Week.ToString ( ) + " , " + DayOfWeek.ToString ( ) + " , " + 
				TimeSlot.ToString ( ) + " , " + 
				UserPUID.ToString ( ) + " , " + 
				TitleID.ToString ( ) + " , " + 
				Seconds.ToString ( ) ; 
		} 

	}

	public class Presence_DeadUser_104
	{
//		Create table Pres104
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		userPUID bigint null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		long UserPUID ; 
		int hr ; 
    
		public Presence_DeadUser_104 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi  = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  8 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Presence_Nickname_105
	{
//		Create table Pres105
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		userPUID bigint null,
//		NickName varchar(64) null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		long UserPUID ; 
		string NickName ; 
		int hr ; 

		public Presence_Nickname_105 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi  = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  8 : NickName = strItem ; break ;
					case  9 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Presence_Add_106
	{
//		Create table Pres106
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		SendID bigint null,
//		BuddyID bigint null,
//		BuddyAcctName varchar(64) null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		long SendID ; 
		long BuddyID ; 
		string BuddyAcctName ; 
		int hr ;

		public Presence_Add_106 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi    = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  7 : SendID = Parser.ToLong ( strItem ) ; break ;
					case  8 : BuddyID = Parser.ToLong ( strItem ) ; break ;
					case  9 : BuddyAcctName = strItem ; break ;
					case 10 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Presence_Delete_107
	{
//		Create table Pres107
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		UserPUID bigint null,
//		BuddyID bigint null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		long UserPUID ; 
		long BuddyID ; 
		int hr ; 
		
		public Presence_Delete_107 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi  = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  8 : BuddyID = Parser.ToLong ( strItem ) ; break ;
					case  9 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Presence_Accept_108
	{
//		Create table Pres108
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		UserPUID bigint null,
//		BuddyID bigint null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		long UserPUID ; 
		long BuddyID ; 
		int hr ; 

		public Presence_Accept_108 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi  = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  8 : BuddyID = Parser.ToLong ( strItem ) ; break ;
					case  9 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Presence_Reject_109
	{
//		Create table Pres109
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		UserPUID bigint null,
//		BuddyID bigint null,
//		Never int null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		long UserPUID ; 
		long BuddyID ; 
		int Never ; 
		int hr ; 

		public Presence_Reject_109 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi  = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  8 : BuddyID = Parser.ToLong ( strItem ) ; break ;
					case  9 : Never = Parser.ToInt ( strItem ) ; break ;
					case 10 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Presence_Invite_110
	{
//		Create table Pres110
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		UserPUID bigint null,
//		TitleID int null,
//		MatchSessionID bigint null,
//		NumInvitee int null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		long UserPUID ; 
		int  TitleID ; 
		long MatchSessionID ; 
		int  NumInvitee ; 
		int hr ; 

		public Presence_Invite_110 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi  = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  8 : TitleID  = Parser.ToInt ( strItem ) ; break ;
					case  9 : MatchSessionID = Parser.ToLong ( strItem ) ; break ;
					case 10 : NumInvitee = Parser.ToInt ( strItem ) ; break ;
					case 11 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Presence_Answer_111
	{
//		create table Pres111
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		UserPUID bigint null,
//		HostID bigint null,
//		MatchSessionID bigint null,
//		Answer int null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		long UserPUID ; 
		long HostID ; 
		long MatchSessionID ; 
		int Answer ; 
		int hr ; 
		
		public Presence_Answer_111 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi  = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  8 : HostID = Parser.ToLong ( strItem ) ; break ;
					case  9 : MatchSessionID = Parser.ToLong ( strItem ) ; break ;
					case 10 : Answer = Parser.ToInt ( strItem ) ; break ;
					case 11 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Presence_Cancel_112
	{
//		create table Pres112
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		UserPUID bigint null,
//		MatchSessionID bigint null,
//		NumInvitee int null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		long UserPUID ; 
		long MatchSessionID ; 
		int NumInvitee ; 
		int hr ; 
		
		public Presence_Cancel_112 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi  = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  8 : MatchSessionID = Parser.ToLong ( strItem ) ; break ;
					case  9 : NumInvitee = Parser.ToInt ( strItem ) ; break ;
					case 10 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}


	public class Presence_Block_113
	{
//		create table Pres113
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		UserPUID bigint null,
//		BlockPUID bigint null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		long UserPUID ; 
		long BlockPUID ; 
		int hr ; 

		public Presence_Block_113 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi  = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  8 : BlockPUID = Parser.ToLong ( strItem ) ; break ;
					case  9 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Presence_Unblock_114
	{
//		create table Pres114
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		UserPUID bigint null,
//		BlockPUID bigint null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		long UserPUID ; 
		long BlockPUID ; 
		int hr ; 

		public Presence_Unblock_114 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi  = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  8 : BlockPUID = Parser.ToLong ( strItem ) ; break ;
					case  9 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Presence_DeadXbox_115
	{
//		create table Pres115
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		int hr ; 

		public Presence_DeadXbox_115 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi  = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  7 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Presence_DeadSg_116
	{
//		create table Pres116
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid bigint null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		int hr ; 

		public Presence_DeadSg_116 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi  = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  7 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Presence_State_117
	{
//		create table Pres117
//		(
//		CurrentDT datetime null,
//		SG     varchar(15) null,
//		SGInt  int null,
//		spi    int null,
//		xboxid   bigint null,
//		userPUID bigint null,
//		state    int null,
//		MatchSessionID bigint null,
//		DadaLen int null,
//		hr int null
//		)
		DateTime Timestamp ; 
		string SG ; 
		int SGInt ; 
		int spi   ; 
		long XboxID ; 
		long UserPUID ;
		int  State ; 
		long MatchSessionID ; 
		int  Length ; 
		int hr ; 

		public Presence_State_117 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : SG = strItem ; break ;
					case  4 : SGInt  = Parser.ToInt ( strItem ) ; break ;
					case  5 : spi  = Parser.ToInt ( strItem ) ; break ;
					case  6 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  7 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case  8 : State = Parser.ToInt ( strItem ) ; break ;
					case  9 : MatchSessionID = Parser.ToLong ( strItem ) ; break ;
					case 10 : Length  = Parser.ToInt ( strItem ) ; break ;
					case 11 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\logcollect\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livestats\LogParser\Tools.cs ===
using System;
using System.Collections;

namespace xonline.ops.tools.livestats.logparser 
{
	public class Tokens : IEnumerable
	{
		private string[] elements;

		public Tokens(string source, char[] delimiters)
		{
			// Parse the string into tokens:
			elements = source.Split(delimiters);
		}

		// IEnumerable Interface Implementation:
		//   Declaration of the GetEnumerator() method required by IEnumerable
		public IEnumerator GetEnumerator()
		{
			return new TokenEnumerator(this);
		}

		// Inner class implements IEnumerator interface:
		private class TokenEnumerator : IEnumerator
		{
			private int position = -1;
			private Tokens t;

			public TokenEnumerator(Tokens t)
			{
				this.t = t;
			}

			// Declare the MoveNext method required by IEnumerator:
			public bool MoveNext()
			{
				if (position < t.elements.Length - 1)
				{
					position++;
					return true;
				}
				else
				{
					return false;
				}
			}

			// Declare the Reset method required by IEnumerator:
			public void Reset()
			{
				position = -1;
			}

			// Declare the Current property required by IEnumerator:
			public object Current
			{
				get
				{
					return t.elements[position];
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livestats\LogParser\Xbos.cs ===
using System;

namespace xonline.ops.tools.livestats.logparser 
{
	/// <summary>
	/// Summary description for Xbos.
	/// </summary>
	public class Xbos_Enumerate_901
	{
		//		Create table XBOS901
		//		(
		//			CurrentDT datetime null,
		//			UserPUID bigint null,
		//			TitleID  int null,
		//			OfferingType int null,
		//			StartIndex int null,
		//			MaxResults int null,
		//			NumRecords int null
		//		)
		DateTime Timestamp ; 
		long UserPUID ; 
		int  TitleID  ; 
		int  OfferingType ; 
		int  StartIndex ; 
		int  MaxResults ; 
		int  NumRecords ; 

		public Xbos_Enumerate_901 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case 0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case 1 : /* skip line type */ ; break ;
					case 2 : /* skip line description */ ; break ;
					case 3 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case 4 : TitleID  = Parser.ToInt ( strItem ) ; break ;
					case 5 : OfferingType  = Parser.ToInt ( strItem ) ; break ;
					case 6 : StartIndex  = Parser.ToInt ( strItem ) ; break ;
					case 7 : MaxResults  = Parser.ToInt ( strItem ) ; break ;
					case 8 : NumRecords  = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	} 
	public class Xbos_Purchase_902
	{
//		1	i_Batch	int	4	0
//		0	si_Year	smallint	2	0
//		0	si_Month	smallint	2	0
//		0	si_Day	smallint	2	0
//		0	si_Week	smallint	2	0
//		0	si_DayOfWeek	smallint	2	0
//		0	si_TimeSlot	smallint	2	0
//		0	bi_User	bigint	8	0
//		0	i_Title	int	4	0
//		0	i_Offering	int	4	0		
		
		DateTime		Timestamp ; 
		public	long	UserPUID ; 
		long			XboxID  ; 
		public	int		TitleID ; 
		long			OfferingID ; 
		int				hr ; 

		public	int		Batch ; 
		short Year ; 
		short Month ; 
		short Day ; 
		short Week ; 
		short DayOfWeek ; 
		short TimeSlot ; 

		public Xbos_Purchase_902 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case 0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case 1 : /* skip line type */ ; break ;
					case 2 : /* skip line description */ ; break ;
					case 3 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case 4 : XboxID   = Parser.ToLong ( strItem ) ; break ;
					case 5 : TitleID  = Parser.ToInt ( strItem ) ; break ;
					case 6 : OfferingID = Parser.ToLong ( strItem ) ; break ;
					case 7 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

			Year       = ( short ) Timestamp.Year ; 
			Month      = ( short ) Timestamp.Month ; 
			Day        = ( short ) Timestamp.Day ; 
			TimeSpan ts = Timestamp - Parser.Week_0 ; 
			Week       = ( short ) ( ts.Days / 7 ) ; 
			// This enumeration ranges from zero, Sunday, to six, indicating Saturday.
			DayOfWeek  = ( short ) Timestamp.DayOfWeek ; 
			TimeSlot   = ( short ) Timestamp.Hour ; 

			Batch	   = -1 ; 
		}
		public bool IsValid ( ) 
		{ 
			if ( ( Year > 2048 )   || ( Year < 2002 ) ) return false ; 
			if ( ( Month > 12 )    || ( Month < 0 ) ) return false ; 
			if ( ( Day > 31 )      || ( Day < 0 ) ) return false ; 
			if ( ( TimeSlot > 23 ) || ( TimeSlot < 0 ) ) return false ; 
			if ( ( DayOfWeek > 6 ) || ( DayOfWeek < 0 ) ) return false ; 
			if ( ( Week > 1000 )   || ( Week < 0 ) ) return false ; 

			return true ; 
		} 

		public string ToSql ( ) 
		{ 
			if ( IsValid ( ) ) 
			{ 
				string Sql = 
					// return 
					"INSERT INTO t_Purchases " +  
					"( i_Batch, si_Year , si_Month, si_Day, si_Week, si_DayOfWeek, si_TimeSlot, " + 
					" bi_User, i_Title, bi_Offering ) " +
					"VALUES ( " + ToString ( ) + " ) " ; 
				return Sql ; 
			} 
			else 
				return "" ; 
		} 

		public override string ToString ( ) 
		{ 
			return
				Batch.ToString ( ) + " , " + 
				Year.ToString ( ) + " , " + Month.ToString ( ) + " , " + Day.ToString ( ) + " , " + 
				Week.ToString ( ) + " , " + DayOfWeek.ToString ( ) + " , " + 
				TimeSlot.ToString ( ) + " , " + 
				UserPUID.ToString ( ) + " , " + 
				TitleID.ToString ( ) + " , " + 
				OfferingID.ToString ( ) ; 
		} 
	} 

	
	public class Xbos_Details_903
	{
		//		Create table XBOS903
		//		(
		//		CurrentDT  datetime null,
		//		UserPUID   bigint null,
		//		OfferingID bigint null,
		//		TitleID    int null,
		//		DescIndex int null,
		//		LanguageID tinyint null
		//		)
		DateTime Timestamp ; 
		long UserPUID   ; 
		long OfferingID ; 
		int  TitleID    ; 
		int  DescIndex ; 
		int  LanguageID ; 
		public Xbos_Details_903 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case 0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case 1 : /* skip line type */ ; break ;
					case 2 : /* skip line description */ ; break ;
					case 3 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case 4 : OfferingID = Parser.ToLong ( strItem ) ; break ;
					case 5 : TitleID  = Parser.ToInt ( strItem ) ; break ;
					case 6 : DescIndex = Parser.ToInt ( strItem ) ; break ;
					case 7 : LanguageID = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	} 

	public class Xbos_ContentRef_904
	{
		//		Create table XBOS904
		//		(
		//		CurrentDT datetime null,
		//		XboxID bigint null,
		//		UserPUID0 bigint null,
		//		UserPUID1 bigint null,
		//		UserPUID2 bigint null,
		//		UserPUID3 bigint null,
		//		TitleID   int null,
		//		OfferingID bigint null
		//		)
		DateTime Timestamp ; 
		long XboxID ; 
		long UserPUID0 ; 
		long UserPUID1 ; 
		long UserPUID2 ; 
		long UserPUID3 ; 
		int  TitleID   ; 
		long OfferingID ; 

		public Xbos_ContentRef_904 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case  0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case  1 : /* skip line type */ ; break ;
					case  2 : /* skip line description */ ; break ;
					case  3 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case  4 : UserPUID0 = Parser.ToLong ( strItem ) ; break ;
					case  5 : UserPUID1 = Parser.ToLong ( strItem ) ; break ;
					case  6 : UserPUID2 = Parser.ToLong ( strItem ) ; break ;
					case  8 : UserPUID3 = Parser.ToLong ( strItem ) ; break ;
					case  9 : TitleID   = Parser.ToInt ( strItem ) ; break ;
					case 10 : OfferingID = Parser.ToLong ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	}

	public class Xbos_Cancel_905
	{
		//		Create table XBOS905
		//		(
		//		CurrentDT datetime null,
		//		UserPUID bigint null,
		//		OfferingID bigint null,
		//		hr int null
		//		)
		DateTime Timestamp ; 
		long UserPUID ; 
		long OfferingID ; 
		int  hr ;
		
		public Xbos_Cancel_905 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case 0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case 1 : /* skip line type */ ; break ;
					case 2 : /* skip line description */ ; break ;
					case 3 : UserPUID = Parser.ToLong ( strItem ) ; break ;
					case 4 : OfferingID = Parser.ToLong ( strItem ) ; break ;
					case 5 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	} 

	public class Xbos_VerifyName_906
	{
		//		Create table XBOS906
		//		(
		//		CurrentDT datetime null,
		//		strName varchar(64) null,
		//		hr int null
		//		)
		DateTime Timestamp ; 
		string Name ; 
		int hr ; 

		public Xbos_VerifyName_906 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case 0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case 1 : /* skip line type */ ; break ;
					case 2 : /* skip line description */ ; break ;
					case 3 : Name = strItem ; break ;
					case 4 : hr = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	} 

	public class Xbos_AutoUpdateRef_907
	{
		//		Create table XBOS907
		//		(
		//		CurrentDT datetime null,
		//		XboxID bigint null,
		//		TitleID   int null,
		//		BaseVersion int null
		//		)
		DateTime Timestamp ; 
		long XboxID ; 
		int TitleID ; 
		int BaseVersion ; 

		public Xbos_AutoUpdateRef_907 ( string LogLine )
		{
			Tokens tokens = new Tokens ( LogLine , new char [ ] {'|'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case 0 : Timestamp = Convert.ToDateTime ( strItem ) ; break ;
					case 1 : /* skip line type */ ; break ;
					case 2 : /* skip line description */ ; break ;
					case 3 : XboxID = Parser.ToLong ( strItem ) ; break ;
					case 4 : TitleID  = Parser.ToInt ( strItem ) ; break ;
					case 5 : BaseVersion = Parser.ToInt ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 
		}
	} 

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\logcollect\Utilities.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Text;
using System.Net;
using System.Threading;
using System.IO;
using System.Data;
using System.Data.SqlClient; 


namespace xonline.ops.tools.logcollect 
{
	//provides logging services for the library
	public class Logging
	{
		public enum MsgType { Info=0, Warn=1, Err=2, Abort=3, Summary=4 };

		public Logging()
		{
		}

		private static int iInfoCount = 0;
		private static int iWarnCount = 0;
		private static int iErrCount = 0;

		private static string m_Filename="";

		public static string m_LogPath = Directory.GetCurrentDirectory();
		public static string m_strCaller = "LogCollect";

		public static void LogMessage ( MsgType msgtype, string Message  ) 
		{ 
			//write to event logs on first warning, first error, abortive error, and error,warning summary
			string str = "";

			switch (msgtype)
			{
				case MsgType.Info:
					iInfoCount++;
					break;
				case MsgType.Warn:
					iWarnCount++;
					break;
				case MsgType.Err:
					iErrCount++;
					break;
				case MsgType.Abort:
				{
					iErrCount++;

					str = m_strCaller + " aborted on the following non-recoverable error:\r\n";
				}
					break;
				case MsgType.Summary:
					if ( iWarnCount > 0 || iErrCount > 0 )
					{
						str = m_strCaller + " completed, but with warnings and/or errors.\r\n" +
							"Info(s): " + iInfoCount + "\r\n\r\n" +
							"Warning(s): " + iWarnCount + "\r\n" +
							"Error(s): " + iErrCount + "\r\n\r\n";
					}
					else if (iInfoCount > 0)
					{
						str = m_strCaller + " completed without warnings or errors.\r\n" +
							"Info(s): " + iInfoCount + "\r\n\r\n" +
							"Warning(s): " + iWarnCount + "\r\n" +
							"Error(s): " + iErrCount + "\r\n\r\n";
					}

					break;
			}
            
			// Prepend date and time to message.
			DateTime now = DateTime.Now;
			string LoggedMessage = now.ToString ( ) + " - " + str + Message; 

			if ( "" == m_Filename )
			{
				Directory.CreateDirectory(Logging.m_LogPath);

				m_Filename = 
					Logging.m_LogPath +
					"\\" + m_strCaller + "_" + 
					now.Year.ToString ( "0000" ) + "_" +
					now.Month.ToString ( "00" ) + "_" + 
					now.Day.ToString ( "00" ) + "_" + 
					now.Hour.ToString ( "00" ) + "_" +
					now.Minute.ToString( "00" ) +
					".log"; 
			}

			StreamWriter log = null; 
			
			try 
			{ 
				log = new StreamWriter ( m_Filename , true ); 
				log.WriteLine ( LoggedMessage ); 
			} 
			
			catch ( Exception e ) 
			{ 
				// If we get an exception here, we wont be able to log it.
				Console.WriteLine ( e.Message );
			}
			
			finally 
			{ 
				if ( log != null ) 
				{
					log.Close ( ); 
				}
			}

			Console.WriteLine ( LoggedMessage ); 
		} 

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\realTimeWeb\ClusterData.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Xml;
using System.Data.SqlClient;
using System.Configuration;

namespace xonline.ops.tools.realtimeweb 
{
	/// <summary>
	/// Summary description for ClusterData.
	/// </summary>
	public class ClusterData : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
            // get the params
            // run the sp_GetClusterInfo

            DataSet ds = getClusterInfo(Request["beg"], Request["end"], Request["cluster"]);

            // load the xml and modify it
            XmlNode node = makeXml(ds, Request["interval"], Request["beg"], Request["end"]);

            // write the xml to the response
            Response.Write("<?xml version=\"1.0\" standalone=\"yes\"?>\n<!DOCTYPE plot SYSTEM \"plotml.dtd\">\n");
            Response.Write(node.OuterXml); 
            Response.End();
		}

        private XmlNode makeXml(DataSet ds, string interval, string beg, string end)
        {
            TimeSpan span = new TimeSpan(0, Convert.ToInt32(interval), 0);
            DateTime beginning = new DateTime();
            DateTime ending = new DateTime();
            beginning = Convert.ToDateTime(beg);                       
            ending = Convert.ToDateTime(end);                       

            // load the default Xml file
            XmlDocument doc = new XmlDocument();

            doc.Load(Server.MapPath("data.xml"));
            string prev = "";
            

            XmlNode plot = doc.SelectSingleNode("plot");
            XmlNode title = plot.SelectSingleNode("title");
            title.InnerText = Request["cluster"] + ": from [" + Request["beg"] + "] to [" + Request["end"] + "]";

            XmlNode xTicks = plot.SelectSingleNode("xTicks");

            string innerXml = "";

            TimeSpan tInterval = new TimeSpan(0, (int)((TimeSpan)ending.Subtract(beginning)).TotalMinutes / 15, 0);
            int tIntervalMins = (int)tInterval.TotalMinutes;
            for(int i = 0; i < 15; i++)
            {
                
                DateTime next = beginning.Add(tInterval);   
                innerXml += "<tick label=\"" + next + "\" position=\"" + Convert.ToString(tInterval.TotalMinutes / span.TotalMinutes) + "\"/>\n";  
                tInterval = tInterval.Add(new TimeSpan(0, tIntervalMins,0));
            }

            xTicks.InnerXml = innerXml;    
            
            XmlElement n = null;

            if(plot == null) return null;

            // for each row
            foreach(DataRow row in ds.Tables[0].Rows)
            {
                if(prev != (string)row["Name"])
                {
                    // new Name
                    prev = (string)row["Name"];
                    n = doc.CreateElement("dataset");
                    
                    
                    XmlAttribute attr = doc.CreateAttribute("name");
                    attr.Value = prev;
                    n.Attributes.Append(attr);

                    XmlNode temp = doc.CreateNode(XmlNodeType.Element, "m", "");

                    attr = doc.CreateAttribute("x"); attr.Value = Convert.ToString(((TimeSpan)((DateTime)row["DateTime"]).Subtract(beginning.ToUniversalTime())).TotalMinutes / span.TotalMinutes);
                    temp.Attributes.Append(attr);

                    attr = doc.CreateAttribute("y"); attr.Value = ((double)row["Calc"]).ToString();
                    temp.Attributes.Append(attr);

                    temp.InnerXml = "\n" + temp.InnerXml + "\n";

                    n.AppendChild(temp);

                    n.InnerXml = "\n" + n.InnerXml + "\n";

                    plot.AppendChild(n);
                }
                else
                {

                    XmlNode temp = doc.CreateNode(XmlNodeType.Element, "p", "");

                    XmlAttribute attr;
                    attr = doc.CreateAttribute("x"); attr.Value = Convert.ToString(((TimeSpan)((DateTime)row["DateTime"]).Subtract(beginning.ToUniversalTime())).TotalMinutes / span.TotalMinutes);
                    temp.Attributes.Append(attr);

                    attr = doc.CreateAttribute("y"); attr.Value = ((double)row["Calc"]).ToString();
                    temp.Attributes.Append(attr);
                    
                    temp.InnerXml = "\n" + temp.InnerXml + "\n";

                    n.AppendChild(temp);
                }
            }

            plot.AppendChild(n);

            return plot;
        }

        private DataSet getClusterInfo(string beg, string end, string cluster)
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DW"]);

            conn.Open();
            string cmdStr = "exec sp_GetClusterInfo '" + Convert.ToDateTime(beg).ToUniversalTime().ToString() 
                    + "', '" + Convert.ToDateTime(end).ToUniversalTime().ToString() + "', '" + cluster + "'";

            SqlDataAdapter  cmd = new SqlDataAdapter(cmdStr, conn);
		    

            DataSet ds = new DataSet();
            cmd.Fill(ds);
            
            conn.Close();

            return ds;
        }


		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\logcollect\intodb.cs ===
using System;
using System.Diagnostics;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Security.Cryptography;
using System.Text;


namespace xonline.ops.tools.logcollect 
{
	/// <summary>
	/// Summary description for intodb.
	/// </summary>
	public class IntoDB
	{
		private SqlConnection m_sqlc;
		private SqlCommand m_insc;
		private SqlCommand m_updc;
		private ArrayList m_lsarr;
		private DateTime m_LastTime;

		internal struct HashAndCount
		{
			public HashAndCount( byte []byHashIn, int iDupCountIn)
			{
				byHash = byHashIn;
				iDupCount = iDupCountIn;
			}

			public byte []byHash;
			public int iDupCount;
		}
		
		public IntoDB( string strServer, string strDatabase, string strUser, string strPassword)
		{

			m_LastTime = DateTime.Now;
			m_LastTime.AddYears(-100); //just to make sure

			m_lsarr = new ArrayList();

			m_sqlc = new SqlConnection();

			m_sqlc.ConnectionString = "server=" + strServer + ";database=" + strDatabase + 
				";Trusted_Connection=true;";

			if (strUser != "" && strPassword != "")
			{
				m_sqlc.ConnectionString += "User ID=" + strUser + ";Password=" + strPassword + ";";
			}
			else
			{
				m_sqlc.ConnectionString += "Integrated Security=SSPI;";
			}
			
			m_sqlc.Open();

			CreatePreparedStmt();
			
		}


		private void CreatePreparedStmt()
		{
			// prepare the insert command and the column parameters
			m_insc = new SqlCommand(null, m_sqlc);

			m_insc.CommandText = 
				"insert into dbo.EventLog ("
				+ "Data, "
				+ "EntryType, "
				+ "EventID, "
				+ "EventIndex, "
				+ "MachineName, "
				+ "Message, "
				+ "Source, "
				+ "TimeWritten, "
				+ "UserName, "
				+ "DupCount, "
				+ "Hash, "
				+ "LogType "
				+ ") values (" 
				+ "@Data, "
				+ "@EntryType, "
				+ "@EventID, "
				+ "@EventIndex, "
				+ "@MachineName, "
				+ "@Message, "
				+ "@Source, "
				+ "@TimeWritten, "
				+ "@UserName,"
				+ "@DupCount, "
				+ "@Hash, "
				+ "@LogType"
				+ ")";

			m_insc.Parameters.Add("@Data",           SqlDbType.Image, 0x10000000).IsNullable = true;
			m_insc.Parameters.Add("@EntryType",      SqlDbType.NChar, 3);
			m_insc.Parameters.Add("@EventID",        SqlDbType.Int);
			m_insc.Parameters.Add("@EventIndex",     SqlDbType.Int);
			m_insc.Parameters.Add("@MachineName",    SqlDbType.NVarChar, 50);
			m_insc.Parameters.Add("@Message",        SqlDbType.NVarChar, 3000).IsNullable = true;
			m_insc.Parameters.Add("@Source",         SqlDbType.NVarChar, 50);
			m_insc.Parameters.Add("@TimeWritten",    SqlDbType.DateTime);
			m_insc.Parameters.Add("@UserName",       SqlDbType.NVarChar, 50).IsNullable = true;
			m_insc.Parameters.Add("@DupCount",		 SqlDbType.Int);
			m_insc.Parameters.Add("@Hash",			 SqlDbType.Binary, 14);
			m_insc.Parameters.Add("@LogType",		 SqlDbType.NChar, 3);
			m_insc.Prepare();
			
			//prepare the update command
			//==========================

			m_updc = new SqlCommand(null, m_sqlc);

			m_updc.CommandText =
				"UPDATE eventlog SET DupCount = DupCount + 1 WHERE " +
				"EventID = @EventID AND " +				
				"Source = @Source AND " +
				"Hash = @Hash AND " +
				"MachineName = @MachineName AND " +
				"TimeWritten = @TimeWritten"; 

			m_updc.Parameters.Add("@EventID",        SqlDbType.Int);
			m_updc.Parameters.Add("@Source",         SqlDbType.NVarChar, 50);
			m_updc.Parameters.Add("@Hash",			 SqlDbType.Binary, 14);
			m_updc.Parameters.Add("@MachineName",    SqlDbType.NVarChar, 50);
			m_updc.Parameters.Add("@TimeWritten",    SqlDbType.DateTime);
			m_updc.Prepare();
		}

		public int WriteEventLog( EventLogEntry ele, string strLogType )
		{
			//get a hash of the message
			//=========================
				
			UnicodeEncoding UE = new UnicodeEncoding();

			byte []MessageBytes = UE.GetBytes("0"); 
				
			try
			{
				if ( UE.GetByteCount(ele.Message) > 0)
				{
					//Convert the string into an array of bytes.
					MessageBytes = UE.GetBytes(ele.Message);
				}
			}

			catch (Exception e)
			{
				MessageBytes = UE.GetBytes("0");

				// Prepend date and time to message.
				DateTime now = DateTime.Now;
				string LoggedMessage = now.ToString ( ) + " - " + e.Message + ":" + e.StackTrace; 

				Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
			}

			SHA1Managed SHhash = new SHA1Managed();

			byte []HashValue = SHhash.ComputeHash( MessageBytes );
			
			//determine if this is a duplicate event
			//======================================

			if ( ele.TimeWritten == m_LastTime)
			{
				
				//see if this same message was sent from the same source this second
				//==================================================================

				bool bFound = false;
				int i=0;
				int j=0;

				for( i=0; i< m_lsarr.Count; i++)
				{
					for( j=0; j < HashValue.Length; j++)
					{
						if( HashValue[j] != ((HashAndCount)m_lsarr[i]).byHash[j] )
						{
							break;
						}
					}
			
					if( HashValue.Length == j )
					{
						bFound = true;
						break;
					}
				}




				if (bFound)
				{
					//update row with new duplicate count
					//===================================
										
					HashAndCount hac = (HashAndCount)m_lsarr[i];
					hac.iDupCount++;
					m_lsarr[i] = hac;

					try 
					{
						m_updc.Parameters[0].Value = ele.EventID;
						m_updc.Parameters[1].Value = ele.Source;
						m_updc.Parameters[2].Value = HashValue;
						m_updc.Parameters[3].Value = ele.MachineName;
						m_updc.Parameters[4].Value = ele.TimeWritten;
						m_updc.ExecuteNonQuery();
					} 
					catch (Exception e)
					{
						MessageBytes = UE.GetBytes("0");

						// Prepend date and time to message.
						DateTime now = DateTime.Now;
						string LoggedMessage = now.ToString ( ) + " - " + e.Message + ":" + e.StackTrace; 

						Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
						
						return -1;
					}

					return 0;

				}
				else
				{
					//unique this second, add to array
					//================================

					m_lsarr.Add( new HashAndCount( HashValue, 0 ) );
				}

			}
			else
			{
				//first event this second
				//=======================

				m_lsarr.Clear( );
			
				m_lsarr.Add( new HashAndCount( HashValue, 0 )  );

				m_LastTime = ele.TimeWritten;
			}

			//set the values for the insert
			//=============================

			if ( null == ele.Data || 0 == ele.Data.Length )
			{
				m_insc.Parameters[0].Value = DBNull.Value;
			}
			else
			{
				m_insc.Parameters[0].Value = ele.Data;
			}

			switch (ele.EntryType)
			{
				case EventLogEntryType.Error:
					m_insc.Parameters[1].Value = "Err"; break;
				case EventLogEntryType.Information:
					m_insc.Parameters[1].Value = "Inf"; break;
				case EventLogEntryType.Warning:
					m_insc.Parameters[1].Value = "Wrn"; break;
				case EventLogEntryType.FailureAudit:
					m_insc.Parameters[1].Value = "Sau"; break;
				case EventLogEntryType.SuccessAudit:
					m_insc.Parameters[1].Value = "Fau"; break;
			}
			

			m_insc.Parameters[2].Value = ele.EventID;
			m_insc.Parameters[3].Value = ele.Index;
			m_insc.Parameters[4].Value = ele.MachineName;

			try 
			{
				if ( null == ele.Message )
				{
					m_insc.Parameters[5].Value = DBNull.Value;
				}
				else
				{
					m_insc.Parameters[5].Value = ele.Message;
				}
			}
			catch (Exception e)
			{
				m_insc.Parameters[5].Value = DBNull.Value;

				// Prepend date and time to message.
				DateTime now = DateTime.Now;
				string LoggedMessage = now.ToString ( ) + " - " + e.Message + ":" + e.StackTrace; 

				Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
			}

			m_insc.Parameters[6].Value = ele.Source;
			m_insc.Parameters[7].Value = ele.TimeWritten;

			if ( null == ele.UserName )
			{
				m_insc.Parameters[8].Value = DBNull.Value;
			}
			else
			{
				m_insc.Parameters[8].Value = ele.UserName;
			}

			m_insc.Parameters[9].Value = 0; //duplicatecount init = 0
			m_insc.Parameters[10].Value = HashValue;

			if ( "SYSTEM" == strLogType )
			{
				m_insc.Parameters[11].Value = "Sys";
			}
			else if ( "SECURITY" == strLogType )
			{
				m_insc.Parameters[11].Value = "Sec";
			}
			else //( "APPLICATION" == strLogType )
			{
				m_insc.Parameters[11].Value = "App";
			}
			

			//do insert
			//=========

			try 
			{
				m_insc.ExecuteNonQuery();
			} 
			catch (Exception e)
			{
				// Prepend date and time to message.
				DateTime now = DateTime.Now;
				string LoggedMessage = now.ToString ( ) + " - " + e.Message + ":" + e.StackTrace; 

				Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
				return -1;
			}

			return 0; 
		}
			
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\realTimeWeb\ClusterGraph.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace xonline.ops.tools.realtimeweb 
{
	/// <summary>
	/// Summary description for ClusterGraph.
	/// </summary>
	public class ClusterGraph : System.Web.UI.Page
	{
        protected System.Web.UI.WebControls.Label caption;
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here            
            caption.Text = "Ending:  " + parsed(Request["dir"]);            
		}

        public static string parsed(string s)
        {
            string ret = "";

            string[] parts = s.Split(new char[] {'_'});
            if(parts.Length > 3)
            {
                ret = parts[1] + "/" + parts[2] + "/" + parts[3] + " for [" + parts[0] + "]";
            }

            return ret;
        }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\logcollect\work.cs ===
using System;
using System.Collections;
using System.IO;
using System.Threading;
using System.Messaging;

namespace xonline.ops.tools.logcollect 
{

	
	public struct startconfig
	{
		public startconfig(int i)
		{
			dt = DateTime.Now;
			dtEnd = DateTime.Now;
			alMachines = new ArrayList();

			bApplogs = false;
			bSyslogs = false;
			bSeclogs = false;
			alIISlogs = new ArrayList();
			alTxtlogs = new ArrayList();
			strDBServer = null;
			strDB = null;
			strPassword = null;
			strUser = null;
			strTextLogsShare = null;
			strIISLogsShare = null;
            bEventLog = false;
            bCSV = false;
		}

		public ArrayList alMachines;
		public bool bApplogs;
		public bool bSyslogs;
		public bool bSeclogs;
		public ArrayList alIISlogs;
		public ArrayList alTxtlogs;
		public DateTime dt;
		public DateTime dtEnd;
		public string strDBServer;
		public string strDB;
		public string strPassword;
		public string strUser;
		public string strTextLogsShare;
		public string strIISLogsShare;
        public bool bEventLog;
        public bool bCSV;
	}
	
	
	public class StartWork
	{
		private startconfig m_stcfg;
		private string m_strReport;
		private MessageCallback callback;

		public StartWork( startconfig stcfg, MessageCallback callbackDelegate)
		{
			m_stcfg = stcfg;
			callback = callbackDelegate;
		}

		public string Report
		{
			set
			{
				m_strReport = value;
			}
			get
			{
				return m_strReport;
			}
		}

		public void Collect()
		{

			if (null != callback)
			{
				callback(0, "Validating parameters", null);
			}



			//make sure something is selected
			//===============================

			try
			{
				if ( 0 == m_stcfg.alMachines.Count ) 
				{
					m_strReport += "At least one machine must be selected.";
					throw new Exception("At least one machine must be selected.");
				}

				if ( false == m_stcfg.bApplogs && 0 == m_stcfg.alIISlogs.Count && false == m_stcfg.bSeclogs && 
					false == m_stcfg.bSyslogs && 0 == m_stcfg.alTxtlogs.Count ) 
				{
					m_strReport += "At least one type of log must be selected.";
					throw new Exception("At least one type of log must be selected.");
				}

				if ( "" == m_stcfg.strDB || "" == m_stcfg.strDBServer )
				{
					m_strReport += "Database server and name must both be specified.";
					throw new Exception("Database server and name must both be specified.");
				}

				if ( "" == m_stcfg.strPassword || "" == m_stcfg.strUser )
				{
					m_strReport += "User and password must both be specified.";
					throw new Exception("User and password must both be specified.");
				}		

				if (m_stcfg.dt > m_stcfg.dtEnd)
				{
					m_strReport += "The start date/time must be before the end date/time.";
					throw new Exception("The start date/time must be before the end date/time.");
				}
			}
			catch (Exception e)
			{
					// Prepend date and time to message.
					DateTime now = DateTime.Now;
					string LoggedMessage = now.ToString ( ) + " - " + e.Message + ":" + e.StackTrace; 

					Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
					callback(-2, "There were errors!" , m_strReport);
					return;
			}

			//create event log writer object
			//==============================

			Evlog evl = null;
			
			if ( m_stcfg.strDB != null )
			{
				try
				{
					evl = new EvlogDB( m_stcfg.strDBServer, 
						m_stcfg.strDB,
						m_stcfg.strUser,
						m_stcfg.strPassword);
				}

				catch(Exception e)
				{
					m_strReport = e.Message;
					// Prepend date and time to message.
					DateTime now = DateTime.Now;
					string LoggedMessage = now.ToString ( ) + " - " + e.Message + ":" + e.StackTrace; 

					Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
					callback(-2, "There were errors!" , m_strReport);
					return;
				}
			}
			else
			{
				evl = new EvlogTxt(m_stcfg.bCSV); 
			}

			//collect all the logs
			//====================

			for ( int i = 0; i < m_stcfg.alMachines.Count; i++ )
			{
				if (null != callback)
				{
					callback(100 / m_stcfg.alMachines.Count * i, "Collecting logs for " + m_stcfg.alMachines[i].ToString(), null);
				}

				//collect event logs
				//==================

				if ( m_stcfg.bApplogs)
				{
					try
					{
						if (null != callback)
						{
							callback(100 / m_stcfg.alMachines.Count * i, "Collecting application logs for " + m_stcfg.alMachines[i].ToString(), null);
						}

						evl.WriteEvents( m_stcfg.alMachines[i].ToString(),
							"Application",
							m_stcfg.dt,
							m_stcfg.dtEnd);

						m_strReport = m_strReport + "Application logs collected from " + 
							m_stcfg.alMachines[i] +".\r\n";
					}

					catch( Exception e)
					{
						m_strReport = m_strReport + "Error pulling application logs from " +
							m_stcfg.alMachines[i] + " => " + e.Message;
						// Prepend date and time to message.
						DateTime now = DateTime.Now;
						string LoggedMessage = now.ToString ( ) + " - " + e.Message + ":" + e.StackTrace; 

						Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
					}
				}	
				
				if ( m_stcfg.bSeclogs)
				{
					try
					{
						if (null != callback)
						{
							callback(100 / m_stcfg.alMachines.Count * i, "Collecting security logs for " + m_stcfg.alMachines[i].ToString(), null);
						}

						evl.WriteEvents( m_stcfg.alMachines[i].ToString(),
							"Security",
							m_stcfg.dt,
							m_stcfg.dtEnd);

						m_strReport = m_strReport + " Security logs collected from " + 
							m_stcfg.alMachines[i] +".\n";
					}

					catch( Exception ex)
					{
						m_strReport = m_strReport + "Error pulling security logs from " +
							m_stcfg.alMachines[i] + " => " + ex.Message;
						// Prepend date and time to message.
						DateTime now = DateTime.Now;
						string LoggedMessage = now.ToString ( ) + " - " + ex.Message + ":" + ex.StackTrace; 

						Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
					}
				}	
				
				if ( m_stcfg.bSyslogs)
				{
					try
					{
						if (null != callback)
						{
							callback(100 / m_stcfg.alMachines.Count * i, "Collecting system logs for " + m_stcfg.alMachines[i].ToString(), null);
						}

						evl.WriteEvents( m_stcfg.alMachines[i].ToString(),
							"System",
							m_stcfg.dt,
							m_stcfg.dtEnd);

						m_strReport = m_strReport + " System logs collected from " + 
							m_stcfg.alMachines[i] +".\n";
					}

					catch( Exception ex)
					{
						m_strReport = m_strReport + "Error pulling system logs from " +
							m_stcfg.alMachines[i] + " => " + ex.Message;
						// Prepend date and time to message.
						DateTime now = DateTime.Now;
						string LoggedMessage = now.ToString ( ) + " - " + ex.Message + ":" + ex.StackTrace; 

						Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
					}
				}	


				//collect text logs
				//=================

                bool bFoundShare = false;

                foreach ( string strShare in m_stcfg.alTxtlogs )
				{
					if (null != callback)
					{
						callback(100 / m_stcfg.alMachines.Count * i, "Collecting text logs for " + m_stcfg.alMachines[i].ToString(), null);
					}

					string strLocalDir = strShare + "\\" + m_stcfg.alMachines[i];
					
					//look for the applog share in d$ first, e$ second
					//================================================

					string strRemoteDir = "\\\\" + m_stcfg.alMachines[i] + "\\d$\\" + strShare;

					if ( !Directory.Exists( strRemoteDir ) )
					{
						strRemoteDir = "\\\\" + m_stcfg.alMachines[i] + "\\e$\\" + strShare;
					}

                    if ( !Directory.Exists( strRemoteDir ) )
                    {
                        continue;
                    }

                    bFoundShare = true;

					//copy the files
					//==============

					try
					{
						Directory.CreateDirectory( strLocalDir );

						//get the files in the root dir
						//=============================

						int iTotalText = 0;

						string []strFiles = Directory.GetFiles( strRemoteDir );

						for( int k=0; k<strFiles.Length; k++ )
						{
							string []strSplit = strFiles[k].Split('\\');

							File.Copy(  strFiles[i], 
								strLocalDir + "\\" + strSplit[strSplit.Length - 1],
								true );
						}
			
						iTotalText += strFiles.Length;

						//get all files in the subdirs too
						//================================

						string []strSubDirs = Directory.GetDirectories( strRemoteDir );
						
						for ( int l=0; l<strSubDirs.Length; l++ )
						{
							string []strDirSplit = strSubDirs[l].Split('\\');

							//don't get subdirs begining with rpt (temporary collection share)
							//================================================================

							if ( !strDirSplit[ strDirSplit.Length - 1].ToUpper().StartsWith("RPT") )
							{
								strFiles = Directory.GetFiles( strSubDirs[l] );

								if (strFiles.Length > 0)
								{
									Directory.CreateDirectory( strLocalDir + "\\" + strDirSplit[ strDirSplit.Length - 1] );
								}

								for( int m=0; m<strFiles.Length; m++ )
								{
									string []strSplit = strFiles[m].Split('\\');

									File.Copy(  strFiles[m], 
										strLocalDir + "\\" + strDirSplit[ strDirSplit.Length - 1] + "\\" + strSplit[strSplit.Length - 1],
										true );
								}

								iTotalText += strFiles.Length;
							}

						}

						m_strReport = m_strReport + iTotalText + " text log files collected from " + 
							m_stcfg.alMachines[i] +".\r\n";

                        break;

					}

					catch ( Exception ex )
					{
						m_strReport = m_strReport + "Error copying text logs from \\\\" + 
						m_stcfg.alMachines[i] + " => " + ex.Message;

						// Prepend date and time to message.
						DateTime now = DateTime.Now;
						string LoggedMessage = now.ToString ( ) + " - " + ex.Message + ":" + ex.StackTrace; 

						Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
                        break;
					}
				}

                if (m_stcfg.alTxtlogs.Count!=0 && !bFoundShare)
                {
                    m_strReport = m_strReport + "Share not found for text logs on \\\\" + 
                        m_stcfg.alMachines[i] + "\r\n"; 
                }

				//collect IIS logs
				//================
				
                bFoundShare = false;

				foreach( string strShare in m_stcfg.alIISlogs )
				{
					if (null != callback)
					{
						callback(100 / m_stcfg.alMachines.Count * i, "Collecting IIS logs for " + m_stcfg.alMachines[i].ToString(), null);
					}

					string strLocalDir = strShare + "\\" + m_stcfg.alMachines[i];

					
					//look for the iislog share in d$ first, e$ second
					//================================================

					string strRemoteDir = "\\\\" + m_stcfg.alMachines[i] + "\\d$\\" + strShare;

					if ( !Directory.Exists( strRemoteDir ) )
					{
						strRemoteDir = "\\\\" + m_stcfg.alMachines[i] + "\\e$\\" + strShare;
					}					

                    if ( !Directory.Exists( strRemoteDir ) )
                    {
                        continue;
                    }

                    bFoundShare = true;

					//copy the files
					//==============

					try
					{
						string []strSubDirs = Directory.GetDirectories( strRemoteDir );

						Directory.CreateDirectory( strLocalDir );

						int iTotalIIS = 0;

						for ( int l=0; l<strSubDirs.Length; l++ )
						{
							string []strDirSplit = strSubDirs[l].Split('\\');

							//only get W3SVC* dirs
							//====================

							if ( strDirSplit[ strDirSplit.Length - 1].ToUpper().StartsWith("W3SVC") )
							{
								string []strFiles = Directory.GetFiles( strSubDirs[l] );

								if (strFiles.Length > 0)
								{
									Directory.CreateDirectory( strLocalDir + "\\" + strDirSplit[ strDirSplit.Length - 1] );
								}

								for( int k=0; k<strFiles.Length; k++ )
								{
									string []strSplit = strFiles[k].Split('\\');

									File.Copy(  strFiles[k], 
										strLocalDir + "\\" + strDirSplit[ strDirSplit.Length - 1] + "\\" + strSplit[strSplit.Length - 1],
										true );
								}

								iTotalIIS += strFiles.Length;
							}
						}

						m_strReport = m_strReport + iTotalIIS + " IIS log files collected from " + 
							m_stcfg.alMachines[i] +".\r\n";

                        break;
					}

					catch (Exception ex)
					{
						m_strReport = m_strReport + "Error copying IIS logs from \\\\" + 
							m_stcfg.alMachines[i] + " => " + ex.Message;

						// Prepend date and time to message.
						DateTime now = DateTime.Now;
						string LoggedMessage = now.ToString ( ) + " - " + ex.Message + ":" + ex.StackTrace; 

						Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
                        break;
					}

				}
                
                if (m_stcfg.alIISlogs.Count!=0 && !bFoundShare)
                {
                    m_strReport = m_strReport + "Share not found for IIS logs on \\\\" + 
                        m_stcfg.alMachines[i] + "\r\n";
                }
			}

			if (null != callback)
			{
				callback(100, "Processing complete!", null);
			}

			Thread.Sleep(2000);

			if (null != callback)
			{
				callback(-2, null, m_strReport);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\logcollect\evlog.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Text;

namespace xonline.ops.tools.logcollect 
{
	//===========
	//class Evlog
	//===========

	public abstract class Evlog
	{
		private EventLog m_evlog;
		private EventLogEntryCollection m_evlogcoll;
		private int m_iCurr;
		private DateTime m_dtStart;
		private DateTime m_dtEnd;

		public Evlog()
		{
			m_evlog = null;
			m_evlogcoll = null;
			m_iCurr = 0;
		}

		protected void Connect( string strSource, string strLogType, DateTime dtStart, DateTime dtEnd)
		{
			//connect to event log
			//====================

			m_evlog = new EventLog( strLogType, strSource );
			
			m_evlogcoll = m_evlog.Entries;
			m_iCurr = m_evlogcoll.Count-1;

			m_dtStart = dtStart;
			m_dtEnd = dtEnd;


			//do an abbreviated binary search if first record is after the search end date(within the last 12 hours don't bother)
			//this is meant as a signifigant optimization, not an optimal solution
			//result is the the first record read in GetOneEvent() is positioned closer to the actual search end date
			//====================================================================================================

			if (0 > m_iCurr)
			{
				return;
			}

			EventLogEntry ele = m_evlogcoll[m_iCurr];

			if (dtEnd.AddHours(12) < ele.TimeWritten) 
			{
				bool bUp = false;

				int iL = 0;
				int iR = m_iCurr;
				
				m_iCurr = iR / 2;
				ele = m_evlogcoll[m_iCurr];
				
				while ( ( dtEnd > ele.TimeWritten || dtEnd == ele.TimeWritten || bUp == false ) && iL != iR )
				{
					if ( dtEnd < ele.TimeWritten )
					{
						iR = m_iCurr;
						m_iCurr = iL + ((m_iCurr - iL) / 2);
					}
					else
					{
						bUp = true;
						iL = m_iCurr;
						m_iCurr = (iR + m_iCurr + 1) / 2; //+1 handles the case where top entry will retain the starting point
					}

					ele = m_evlogcoll[m_iCurr];
				}
			}

		}

		protected EventLogEntry GetOneEvent()
		{
			EventLogEntry ele = null;

			do
			{
				//return failure if we are at the end
				//===================================

				if (m_iCurr < 0)
				{
					return null;
				}

				//get the event log
				//=================

				ele = m_evlogcoll[m_iCurr--];

				//return failure if this record is before the search start date
				//==============================================================

				if ( m_dtStart > ele.TimeWritten )
				{
					return null;
				}

			} while ( m_dtEnd < ele.TimeWritten);


			return ele;
		}



		public abstract int WriteEvents( string strSource, string strLogType, DateTime dtStart, DateTime dtEnd );

	}
	
	
	
	//=============
	//class EvlogDB
	//=============


	public class EvlogDB : Evlog
	{
		IntoDB m_idb;

		public EvlogDB( string strServer, string strDB, string strUser, string strPassword)
		{
			m_idb = new IntoDB(strServer, strDB, strUser, strPassword);
		}

		public override int WriteEvents( string strSource, string strLogType, DateTime dtStart, DateTime dtEnd )
		{
			strLogType = strLogType.ToUpper();

			Connect( strSource, strLogType, dtStart, dtEnd );

			EventLogEntry ele = null;

			ele = GetOneEvent();
			
			while( ele != null)
			{
				m_idb.WriteEventLog(ele, strLogType);

				ele = GetOneEvent();		
			}

			return 0;
		}

	}

	//==============
	//class EvlogTxt
	//==============

	public class EvlogTxt : Evlog
	{

		StreamWriter m_swriter;
        bool m_bCSV;

		public EvlogTxt(bool bCSV)
		{
			Directory.CreateDirectory( "eventlogs" );

            m_bCSV = bCSV;
		}
	

		public override int WriteEvents( string strSource, string strLogType, DateTime dtStart, DateTime dtEnd )
		{
			Connect( strSource, strLogType, dtStart, dtEnd );

			m_swriter = System.IO.File.CreateText( "eventlogs\\" +  strSource
				+ "." + strLogType + ".events.txt");
		
			EventLogEntry ele = null;

			ele = GetOneEvent();
			int iCount = 0;
			
			while( ele != null)
			{
				WriteTextLog(ele, ++iCount);

				ele = GetOneEvent();
		
				if ( iCount % 1000 == 0)
				{
					m_swriter.Flush(); //maybe this will fix the hang
				}
			}

			m_swriter.Flush();
			m_swriter.Close();

			return 0;
		}

		private void WriteTextLog( EventLogEntry ele, int iCount )
		{
			StringBuilder strLog = new StringBuilder("  " + iCount.ToString(), 24576);
			strLog.Append(",");
			strLog.Append(ele.EventID);
			strLog.Append(",");
			strLog.Append(ele.TimeWritten);
			strLog.Append(",");
			strLog.Append(ele.Source);
			strLog.Append(",");
			strLog.Append(ele.MachineName);
			strLog.Append(",");


			switch (ele.EntryType)
			{
				case EventLogEntryType.Error:
					strLog.Append("Err"); break;
				case EventLogEntryType.Information:
					strLog.Append("Info"); break;
				case EventLogEntryType.Warning:
					strLog.Append("Warn"); break;
				case EventLogEntryType.FailureAudit:
					strLog.Append("SAudit"); break;
				case EventLogEntryType.SuccessAudit:
					strLog.Append("FAudit"); break;
			}
			
            if (m_bCSV)
            {
                strLog.Append(",");
            }
            else
            {
                strLog.Append(",\"");
            }

			try
			{
                if (m_bCSV)
                {
                    string str = ele.Message.Replace(',',' ');
                    str = str.Replace('\f',' ');
                    str = str.Replace('\n',' ');
                    str = str.Replace('\r',' ');
                    strLog.Append(str);
                }
                else
                {
                    strLog.Append(ele.Message.Replace("\"","\"\""));
                }
			}

			catch (Exception e)
			{
				// Prepend date and time to message.
				DateTime now = DateTime.Now;
				string LoggedMessage = now.ToString ( ) + " - " + e.Message + ":" + e.StackTrace; 

				Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
			}

            if (!m_bCSV)
            {
                strLog.Append("\"");
            }

			/*				
			if (ele.Data.Length != 0)
			{
                if (m_bCSV)
                {
                    //write out hex and ascii streams
                    //===============================

                    strLog.Append(",");
                    
                    int iIter = -1;

                    while (++iIter < ele.Data.Length)
                    {
                        strLog.Append(ele.Data[iIter].ToString("x2"));
                    }

                    strLog.Append(",");

                    iIter = -1;

                    while (++iIter < ele.Data.Length)
                    {
                        if ( ele.Data[iIter] >= 32 && ele.Data[iIter] <= 126 )
                        {
                            strLog.Append((char)ele.Data[iIter]);
                        }
                        else
                        {
                            strLog.Append(".");
                        }
                    }
                }
                else
                {
                    //write data out in hex-editor format
                    //===================================

                    strLog.Append(",");
					strLog.Append(m_swriter.NewLine);
								
                    int iIter = 0;

                    while( iIter < ele.Data.Length )
                    {								
                        strLog.Append("  ");
                        strLog.Append(iCount);
                        strLog.Append(": ");
                        strLog.Append(iIter.ToString("x6"));
                        strLog.Append(":");
									
                        int iHowMany = Math.Min( 0x10, ele.Data.Length - iIter);

                        for( int iInd=0; iInd < iHowMany; iInd ++)
                        {
                            if (iInd % 4 == 0)
                            {
                                strLog.Append(" ");
                            }
										
                            strLog.Append(ele.Data[iIter + iInd].ToString("x2"));
                        }

                        //line up the the ascii text frame
                        //================================

                        for (int iInd=0; iInd < 32 - iHowMany*2 + (16 - iHowMany) / 4; iInd ++)
                        {
                            strLog.Append(" ");
                        }
			
                        strLog.Append(" | ");
			
                        for( int iInd=0; iInd < iHowMany; iInd ++)
                        {
                            if ( ele.Data[iIter + iInd] >= 32 && ele.Data[iIter + iInd] <= 126 )
                            {
                                strLog.Append((char)ele.Data[iIter + iInd]);
                            }
                            else
                            {
                                strLog.Append(".");
                            }
                        }

                        strLog.Append(m_swriter.NewLine);
                        iIter += 0x10;
                    }

                }
									
			}
			*/

			m_swriter.WriteLine(strLog);
							
		}


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\logcollect\collect.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.IO;
using System.Xml;
using System.Diagnostics;
using System.Text;
using System.DirectoryServices;
using System.Globalization;
using System.Threading;
//using WSREADERLib;
//using XBOX.Utilities;


namespace xonline.ops.tools.logcollect 
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public delegate void MessageCallback(int nPercentComplete, string strMessage, string strReport);

	public class FormCollect : System.Windows.Forms.Form
	{
		private System.Windows.Forms.ListBox m_listBoxServers;
		private System.Windows.Forms.ProgressBar m_progBarStatus;
		private System.Windows.Forms.Label m_labelStatus;
		private System.Windows.Forms.GroupBox m_groupBoxEventLogs;
		private System.Windows.Forms.ListBox m_listBoxLogs;
		private System.Windows.Forms.GroupBox m_groupBoxTextLogs;
		private System.Windows.Forms.CheckBox m_checkBoxTextLogs;
		private System.Windows.Forms.TextBox m_textBoxTextLogs;
		private System.Windows.Forms.Label m_labelShare;
		private System.Windows.Forms.Button m_buttonCollect;
		private System.Windows.Forms.GroupBox m_groupBoxIIS;
		private System.Windows.Forms.CheckBox m_checkBoxIIS;
		private System.Windows.Forms.Label m_labelIISShare;
		private System.Windows.Forms.TextBox m_textBoxIIS;
		private System.Windows.Forms.ComboBox m_comboBoxTime;
		private System.Windows.Forms.Label m_labelDB;
		private System.Windows.Forms.TextBox m_textBoxDB;
		private System.Windows.Forms.Label m_labelDBServer;
		private System.Windows.Forms.TextBox m_textBoxDBServer;
		private System.Windows.Forms.CheckBox m_checkBoxSpecify;
		private System.Windows.Forms.Label labelUser;
		private System.Windows.Forms.Label labelPassword;
		private System.Windows.Forms.TextBox m_textBoxUser;
		private System.Windows.Forms.TextBox m_textBoxPassword;
		private System.Windows.Forms.RadioButton m_radioButtonDB;
		private System.Windows.Forms.RadioButton m_radioButtonText;
		private System.Windows.Forms.Label m_labelDomain;
		private System.Windows.Forms.TextBox m_textBoxDomain;
		private System.Windows.Forms.Label m_labelTime;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.TextBox m_textBoxMax;
		private System.Windows.Forms.Button m_buttonFind;
        private System.Windows.Forms.RadioButton radioButtonTxtFileCSV;
		private ArrayList m_alAllMachines;

		public FormCollect()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();


			m_radioButtonText.Checked = true;
			m_listBoxServers.Sorted = true;
			m_alAllMachines = new ArrayList();

			//add the static data
			//===================

			m_listBoxLogs.Items.Add("Application");
			m_listBoxLogs.Items.Add("Security");
			m_listBoxLogs.Items.Add("System");

			m_comboBoxTime.Items.Add("Last Hour");
			m_comboBoxTime.Items.Add("Last 2 Hours");
			m_comboBoxTime.Items.Add("Last 6 Hours");
			m_comboBoxTime.Items.Add("Last 12 Hours");
			m_comboBoxTime.Items.Add("Last Day");
			m_comboBoxTime.Items.Add("Last 2 Days");
			m_comboBoxTime.Items.Add("Last Week");
			m_comboBoxTime.Items.Add("Last Month");
			m_comboBoxTime.Items.Add("Last 2 Months");
			m_comboBoxTime.Items.Add("Last 4 Months");
			m_comboBoxTime.Items.Add("Last Century");

			m_comboBoxTime.SelectedIndex = 0;

			//disable credential boxes
			//========================
			
			m_checkBoxSpecify.Enabled = false;
			m_textBoxUser.Enabled = false;
			m_textBoxPassword.Enabled = false;	
			

			//find machines through active directory
			//======================================

			m_textBoxDomain.Text = SystemInformation.UserDomainName;
				
			//add current machine as database default
			//=======================================

			m_textBoxDBServer.Text = SystemInformation.ComputerName;
			m_textBoxDB.Text = "eventlogs";

		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.m_labelDomain = new System.Windows.Forms.Label();
            this.m_listBoxServers = new System.Windows.Forms.ListBox();
			this.m_labelStatus = new System.Windows.Forms.Label();
			this.m_progBarStatus = new System.Windows.Forms.ProgressBar();
            this.m_buttonCollect = new System.Windows.Forms.Button();
            this.m_groupBoxEventLogs = new System.Windows.Forms.GroupBox();
            this.radioButtonTxtFileCSV = new System.Windows.Forms.RadioButton();
            this.m_textBoxPassword = new System.Windows.Forms.TextBox();
            this.m_textBoxUser = new System.Windows.Forms.TextBox();
            this.labelPassword = new System.Windows.Forms.Label();
            this.labelUser = new System.Windows.Forms.Label();
            this.m_checkBoxSpecify = new System.Windows.Forms.CheckBox();
            this.m_labelDB = new System.Windows.Forms.Label();
            this.m_textBoxDB = new System.Windows.Forms.TextBox();
            this.m_labelDBServer = new System.Windows.Forms.Label();
            this.m_textBoxDBServer = new System.Windows.Forms.TextBox();
            this.m_radioButtonDB = new System.Windows.Forms.RadioButton();
            this.m_radioButtonText = new System.Windows.Forms.RadioButton();
            this.m_labelTime = new System.Windows.Forms.Label();
            this.m_listBoxLogs = new System.Windows.Forms.ListBox();
            this.m_comboBoxTime = new System.Windows.Forms.ComboBox();
            this.m_groupBoxTextLogs = new System.Windows.Forms.GroupBox();
            this.m_textBoxTextLogs = new System.Windows.Forms.TextBox();
            this.m_checkBoxTextLogs = new System.Windows.Forms.CheckBox();
            this.m_labelShare = new System.Windows.Forms.Label();
            this.m_groupBoxIIS = new System.Windows.Forms.GroupBox();
            this.m_checkBoxIIS = new System.Windows.Forms.CheckBox();
            this.m_labelIISShare = new System.Windows.Forms.Label();
            this.m_textBoxIIS = new System.Windows.Forms.TextBox();
            this.m_textBoxDomain = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.m_textBoxMax = new System.Windows.Forms.TextBox();
            this.m_buttonFind = new System.Windows.Forms.Button();
            this.m_groupBoxEventLogs.SuspendLayout();
            this.m_groupBoxTextLogs.SuspendLayout();
            this.m_groupBoxIIS.SuspendLayout();
            this.SuspendLayout();
            // 
            // m_labelDomain
            // 
            this.m_labelDomain.Location = new System.Drawing.Point(8, 8);
            this.m_labelDomain.Name = "m_labelDomain";
            this.m_labelDomain.Size = new System.Drawing.Size(56, 23);
            this.m_labelDomain.TabIndex = 1;
            this.m_labelDomain.Text = "Domain:";
            // 
            // m_listBoxServers
            // 
            this.m_listBoxServers.Location = new System.Drawing.Point(16, 72);
            this.m_listBoxServers.Name = "m_listBoxServers";
            this.m_listBoxServers.SelectionMode = System.Windows.Forms.SelectionMode.MultiSimple;
            this.m_listBoxServers.Size = new System.Drawing.Size(160, 459);
            this.m_listBoxServers.TabIndex = 2;
            this.m_listBoxServers.DoubleClick += new System.EventHandler(this.m_listBoxServers_DoubleClick);

			//
			// m_progBarStatus
			//
			this.m_progBarStatus.Location = new System.Drawing.Point(16, 555);
			this.m_progBarStatus.Name = "m_progBarStatus";
			this.m_progBarStatus.Size = new System.Drawing.Size(336,20);
			this.m_progBarStatus.TabIndex = 0;

			//
			// m_labelStatus
			//
			this.m_labelStatus.Location = new System.Drawing.Point(16, 533);
			this.m_labelStatus.Name = "m_labelStatus";
			this.m_labelStatus.Size = new System.Drawing.Size(336, 20);
			this.m_labelStatus.TabIndex = 0;

            // 
            // m_buttonCollect
            // 
            this.m_buttonCollect.Location = new System.Drawing.Point(232, 16);
            this.m_buttonCollect.Name = "m_buttonCollect";
            this.m_buttonCollect.TabIndex = 4;
            this.m_buttonCollect.Text = "Collect!";
            this.m_buttonCollect.Click += new System.EventHandler(this.button1_Click);
            // 
            // m_groupBoxEventLogs
            // 
            this.m_groupBoxEventLogs.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                                              this.radioButtonTxtFileCSV,
                                                                                              this.m_textBoxPassword,
                                                                                              this.m_textBoxUser,
                                                                                              this.labelPassword,
                                                                                              this.labelUser,
                                                                                              this.m_checkBoxSpecify,
                                                                                              this.m_labelDB,
                                                                                              this.m_textBoxDB,
                                                                                              this.m_labelDBServer,
                                                                                              this.m_textBoxDBServer,
                                                                                              this.m_radioButtonDB,
                                                                                              this.m_radioButtonText,
                                                                                              this.m_labelTime,
                                                                                              this.m_listBoxLogs,
                                                                                              this.m_comboBoxTime});
            this.m_groupBoxEventLogs.Location = new System.Drawing.Point(192, 66);
            this.m_groupBoxEventLogs.Name = "m_groupBoxEventLogs";
            this.m_groupBoxEventLogs.Size = new System.Drawing.Size(160, 294);
            this.m_groupBoxEventLogs.TabIndex = 8;
            this.m_groupBoxEventLogs.TabStop = false;
            this.m_groupBoxEventLogs.Text = "Event Logs";
            // 
            // radioButtonTxtFileCSV
            // 
            this.radioButtonTxtFileCSV.Location = new System.Drawing.Point(16, 123);
            this.radioButtonTxtFileCSV.Name = "radioButtonTxtFileCSV";
            this.radioButtonTxtFileCSV.Size = new System.Drawing.Size(128, 24);
            this.radioButtonTxtFileCSV.TabIndex = 0;
            this.radioButtonTxtFileCSV.Text = "Into Text File (CSV)";
            this.radioButtonTxtFileCSV.CheckedChanged += new System.EventHandler(this.radioButtonTxtFileCSV_CheckedChanged);
            // 
            // m_textBoxPassword
            // 
            this.m_textBoxPassword.Location = new System.Drawing.Point(48, 264);
            this.m_textBoxPassword.Name = "m_textBoxPassword";
            this.m_textBoxPassword.PasswordChar = '*';
            this.m_textBoxPassword.Size = new System.Drawing.Size(96, 20);
            this.m_textBoxPassword.TabIndex = 25;
            this.m_textBoxPassword.Text = "";
            // 
            // m_textBoxUser
            // 
            this.m_textBoxUser.Location = new System.Drawing.Point(48, 240);
            this.m_textBoxUser.Name = "m_textBoxUser";
            this.m_textBoxUser.Size = new System.Drawing.Size(96, 20);
            this.m_textBoxUser.TabIndex = 24;
            this.m_textBoxUser.Text = "";
            // 
            // labelPassword
            // 
            this.labelPassword.Location = new System.Drawing.Point(8, 264);
            this.labelPassword.Name = "labelPassword";
            this.labelPassword.Size = new System.Drawing.Size(32, 23);
            this.labelPassword.TabIndex = 23;
            this.labelPassword.Text = "PW";
            // 
            // labelUser
            // 
            this.labelUser.Location = new System.Drawing.Point(8, 240);
            this.labelUser.Name = "labelUser";
            this.labelUser.TabIndex = 22;
            this.labelUser.Text = "User";
            // 
            // m_checkBoxSpecify
            // 
            this.m_checkBoxSpecify.Location = new System.Drawing.Point(16, 216);
            this.m_checkBoxSpecify.Name = "m_checkBoxSpecify";
            this.m_checkBoxSpecify.Size = new System.Drawing.Size(128, 24);
            this.m_checkBoxSpecify.TabIndex = 21;
            this.m_checkBoxSpecify.Text = "Specify Credentials";
            this.m_checkBoxSpecify.CheckedChanged += new System.EventHandler(this.m_checkBoxSpecify_CheckedChanged);
            // 
            // m_labelDB
            // 
            this.m_labelDB.Location = new System.Drawing.Point(8, 193);
            this.m_labelDB.Name = "m_labelDB";
            this.m_labelDB.Size = new System.Drawing.Size(24, 23);
            this.m_labelDB.TabIndex = 20;
            this.m_labelDB.Text = "DB";
            // 
            // m_textBoxDB
            // 
            this.m_textBoxDB.Location = new System.Drawing.Point(48, 193);
            this.m_textBoxDB.Name = "m_textBoxDB";
            this.m_textBoxDB.Size = new System.Drawing.Size(96, 20);
            this.m_textBoxDB.TabIndex = 19;
            this.m_textBoxDB.Text = "";
            // 
            // m_labelDBServer
            // 
            this.m_labelDBServer.Location = new System.Drawing.Point(8, 169);
            this.m_labelDBServer.Name = "m_labelDBServer";
            this.m_labelDBServer.Size = new System.Drawing.Size(40, 23);
            this.m_labelDBServer.TabIndex = 18;
            this.m_labelDBServer.Text = "Server";
            // 
            // m_textBoxDBServer
            // 
            this.m_textBoxDBServer.Location = new System.Drawing.Point(48, 169);
            this.m_textBoxDBServer.Name = "m_textBoxDBServer";
            this.m_textBoxDBServer.Size = new System.Drawing.Size(96, 20);
            this.m_textBoxDBServer.TabIndex = 17;
            this.m_textBoxDBServer.Text = "";
            // 
            // m_radioButtonDB
            // 
            this.m_radioButtonDB.Location = new System.Drawing.Point(16, 144);
            this.m_radioButtonDB.Name = "m_radioButtonDB";
            this.m_radioButtonDB.TabIndex = 16;
            this.m_radioButtonDB.Text = "Into Database";
            this.m_radioButtonDB.CheckedChanged += new System.EventHandler(this.radioButtonDB_CheckedChanged);
            // 
            // m_radioButtonText
            // 
            this.m_radioButtonText.Location = new System.Drawing.Point(16, 103);
            this.m_radioButtonText.Name = "m_radioButtonText";
            this.m_radioButtonText.TabIndex = 15;
            this.m_radioButtonText.Text = "Into Text File";
            this.m_radioButtonText.CheckedChanged += new System.EventHandler(this.radioButtonText_CheckedChanged);
            // 
            // m_labelTime
            // 
            this.m_labelTime.Location = new System.Drawing.Point(8, 24);
            this.m_labelTime.Name = "m_labelTime";
            this.m_labelTime.Size = new System.Drawing.Size(40, 23);
            this.m_labelTime.TabIndex = 14;
            this.m_labelTime.Text = "Within";
            // 
            // m_listBoxLogs
            // 
            this.m_listBoxLogs.Location = new System.Drawing.Point(16, 56);
            this.m_listBoxLogs.Name = "m_listBoxLogs";
            this.m_listBoxLogs.SelectionMode = System.Windows.Forms.SelectionMode.MultiSimple;
            this.m_listBoxLogs.Size = new System.Drawing.Size(128, 43);
            this.m_listBoxLogs.TabIndex = 9;
            // 
            // m_comboBoxTime
            // 
            this.m_comboBoxTime.Location = new System.Drawing.Point(48, 24);
            this.m_comboBoxTime.Name = "m_comboBoxTime";
            this.m_comboBoxTime.Size = new System.Drawing.Size(96, 21);
            this.m_comboBoxTime.TabIndex = 13;
            // 
            // m_groupBoxTextLogs
            // 
            this.m_groupBoxTextLogs.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                                             this.m_textBoxTextLogs,
                                                                                             this.m_checkBoxTextLogs});
            this.m_groupBoxTextLogs.Location = new System.Drawing.Point(192, 368);
            this.m_groupBoxTextLogs.Name = "m_groupBoxTextLogs";
            this.m_groupBoxTextLogs.Size = new System.Drawing.Size(160, 80);
            this.m_groupBoxTextLogs.TabIndex = 9;
            this.m_groupBoxTextLogs.TabStop = false;
            this.m_groupBoxTextLogs.Text = "Text Logs";
            // 
            // m_textBoxTextLogs
            // 
            this.m_textBoxTextLogs.Location = new System.Drawing.Point(48, 48);
            this.m_textBoxTextLogs.Name = "m_textBoxTextLogs";
            this.m_textBoxTextLogs.Size = new System.Drawing.Size(96, 20);
            this.m_textBoxTextLogs.TabIndex = 11;
            this.m_textBoxTextLogs.Text = "applogs";
            // 
            // m_checkBoxTextLogs
            // 
            this.m_checkBoxTextLogs.Location = new System.Drawing.Point(16, 16);
            this.m_checkBoxTextLogs.Name = "m_checkBoxTextLogs";
            this.m_checkBoxTextLogs.Size = new System.Drawing.Size(120, 24);
            this.m_checkBoxTextLogs.TabIndex = 10;
            this.m_checkBoxTextLogs.Text = "Collect Text Logs";
            // 
            // m_labelShare
            // 
            this.m_labelShare.Location = new System.Drawing.Point(200, 416);
            this.m_labelShare.Name = "m_labelShare";
            this.m_labelShare.Size = new System.Drawing.Size(40, 16);
            this.m_labelShare.TabIndex = 11;
            this.m_labelShare.Text = "Share";
            // 
            // m_groupBoxIIS
            // 
            this.m_groupBoxIIS.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                                        this.m_checkBoxIIS,
                                                                                        this.m_labelIISShare,
                                                                                        this.m_textBoxIIS});
            this.m_groupBoxIIS.Location = new System.Drawing.Point(192, 456);
            this.m_groupBoxIIS.Name = "m_groupBoxIIS";
            this.m_groupBoxIIS.Size = new System.Drawing.Size(160, 76);
            this.m_groupBoxIIS.TabIndex = 12;
            this.m_groupBoxIIS.TabStop = false;
            this.m_groupBoxIIS.Text = "IIS Logs";
            // 
            // m_checkBoxIIS
            // 
            this.m_checkBoxIIS.Location = new System.Drawing.Point(16, 16);
            this.m_checkBoxIIS.Name = "m_checkBoxIIS";
            this.m_checkBoxIIS.TabIndex = 0;
            this.m_checkBoxIIS.Text = "Collect IIS Logs";
            // 
            // m_labelIISShare
            // 
            this.m_labelIISShare.Location = new System.Drawing.Point(8, 48);
            this.m_labelIISShare.Name = "m_labelIISShare";
            this.m_labelIISShare.Size = new System.Drawing.Size(40, 23);
            this.m_labelIISShare.TabIndex = 13;
            this.m_labelIISShare.Text = "Share:";
            // 
            // m_textBoxIIS
            // 
            this.m_textBoxIIS.Location = new System.Drawing.Point(48, 48);
            this.m_textBoxIIS.Name = "m_textBoxIIS";
            this.m_textBoxIIS.Size = new System.Drawing.Size(96, 20);
            this.m_textBoxIIS.TabIndex = 12;
            this.m_textBoxIIS.Text = "iislogs";
            // 
            // m_textBoxDomain
            // 
            this.m_textBoxDomain.Location = new System.Drawing.Point(56, 8);
            this.m_textBoxDomain.Name = "m_textBoxDomain";
            this.m_textBoxDomain.Size = new System.Drawing.Size(120, 20);
            this.m_textBoxDomain.TabIndex = 13;
            this.m_textBoxDomain.Text = "textBoxDomain";
            this.m_textBoxDomain.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.TextBoxDomain_KeyPress);
            // 
            // label1
            // 
            this.label1.Location = new System.Drawing.Point(8, 40);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(32, 23);
            this.label1.TabIndex = 14;
            this.label1.Text = "Max:";
            // 
            // m_textBoxMax
            // 
            this.m_textBoxMax.Location = new System.Drawing.Point(56, 40);
            this.m_textBoxMax.Name = "m_textBoxMax";
            this.m_textBoxMax.Size = new System.Drawing.Size(48, 20);
            this.m_textBoxMax.TabIndex = 15;
            this.m_textBoxMax.Text = "400";
            // 
            // m_buttonFind
            // 
            this.m_buttonFind.Location = new System.Drawing.Point(120, 40);
            this.m_buttonFind.Name = "m_buttonFind";
            this.m_buttonFind.Size = new System.Drawing.Size(56, 23);
            this.m_buttonFind.TabIndex = 16;
            this.m_buttonFind.Text = "Find";
            this.m_buttonFind.Click += new System.EventHandler(this.m_buttonFind_Click);
            // 
            // FormCollect
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(368, 580);
            this.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                          this.m_buttonFind,
                                                                          this.m_textBoxMax,
                                                                          this.label1,
                                                                          this.m_textBoxDomain,
                                                                          this.m_groupBoxIIS,
                                                                          this.m_labelShare,
                                                                          this.m_groupBoxTextLogs,
                                                                          this.m_groupBoxEventLogs,
                                                                          this.m_buttonCollect,
																		  this.m_listBoxServers,
																		  this.m_progBarStatus,
																		  this.m_labelStatus,
																		  this.m_labelDomain,});
            this.Name = "FormCollect";
            this.Text = "Log Collector ";
            this.m_groupBoxEventLogs.ResumeLayout(false);
            this.m_groupBoxTextLogs.ResumeLayout(false);
            this.m_groupBoxIIS.ResumeLayout(false);
            this.ResumeLayout(false);

        }
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args) 
		{
			
			// Prepend date and time to message.
			string strMessage = DateTime.Now.ToString ( ) + " - application started"; 

			Logging.LogMessage(Logging.MsgType.Info, strMessage);

			if ( 0 == args.Length )
			{
				Application.Run(new FormCollect());
			}
			else
			{
				//get the command line config
				//===========================

				ArrayList alChosen = new ArrayList();
				int iWildCount = 0;
				uint uiMax = 400;
				string strDomain = null;
				string strStartTime = null;
				string strEndTime = null;
				string strStartDate = null;
				string strEndDate = null;

				startconfig stcfg = new startconfig(0);

				stcfg.strIISLogsShare = "iislogs";
				stcfg.strTextLogsShare = "applogs";
	

				for (int i = 0; i < args.Length; i++)
				{
					args[i] = args[i].ToUpper();

                    if ( args[i].StartsWith( "/MACHINE:" ) )
                    {
                        string s = args[i].Substring( "/MACHINE:".Length ).ToUpper();

                        if (s.Length > 0)
                        {
                            alChosen.Add(s); 

                            if ( s.IndexOf('*') >= 0)
                            {
                                iWildCount++;
                            }

                        }
                    }
                    else if ( args[i].StartsWith("/MAX:"))
                    {
                        uiMax = Convert.ToUInt32(args[i].Substring( "/MAX:".Length ));
                    }
                    else if ( args[i].StartsWith( "/DOMAIN:" ) )
                    {
                        strDomain = args[i].Substring( "/DOMAIN:".Length );				
                    }
                    else if ( args[i].StartsWith( "/APPLOGS" ) )
                    {
                        stcfg.bApplogs = true;
                    }
                    else if ( args[i].StartsWith( "/SYSLOGS" ) )
                    {
                        stcfg.bSyslogs = true;
                    }
                    else if ( args[i].StartsWith( "/SECLOGS" ) )
                    {
                        stcfg.bSeclogs = true;
                    }
                    else if ( args[i].StartsWith( "/TXTLOGS:" ) )
                    {
                        stcfg.alTxtlogs.Add ( args[i].Substring( "/TXTLOGS:".Length ) );	
                    }
                    else if ( args[i].StartsWith( "/IISLOGS:" ) )
                    {
                        stcfg.alIISlogs.Add ( args[i].Substring( "/IISLOGS:".Length ) );
                    }
                    else if ( args[i].StartsWith( "/CSV" ) )
                    {
                        stcfg.bCSV = true;
                    }
                    else if (args[i].StartsWith( "/STARTDATE:" ) )
                    {
                        strStartDate = args[i].Substring( "/STARTDATE:".Length ); 
                    }
                    else if (args[i].StartsWith( "/ENDDATE:" ) )
                    {
                        strEndDate = args[i].Substring( "/ENDDATE:".Length );  
                    }
                    else if (args[i].StartsWith( "/STARTTIME:" ) )
                    {
                        strStartTime = args[i].Substring( "/STARTTIME:".Length ); 
                    }
                    else if (args[i].StartsWith( "/ENDTIME:" ) )
                    {
                        strEndTime = args[i].Substring( "/ENDTIME:".Length );
                    }
                    else if ( args[i].StartsWith( "/DBSERVER:" ) )
                    {
                        string s = args[i].Substring( "/DBSERVER:".Length );

                        if (s.Length > 0)
                        {
                            stcfg.strDBServer = s;
                        }
                        else
                        {
                            //default to local database "eventlogs" if blank server is specified

                            stcfg.strDBServer = SystemInformation.ComputerName;

                            if ( null == stcfg.strDB )
                            {
                                stcfg.strDB = "eventlogs";
                            }
                        }
                    }
                    else if ( args[i].StartsWith( "/DB:" ) )
                    {
                        stcfg.strDB = args[i].Substring( "/DB:".Length );
                    }
                    else if ( args[i].StartsWith( "/USER:" ) )
                    {
                        stcfg.strUser = args[i].Substring( "/USER:".Length );
                    }
                    else if ( args[i].StartsWith( "/PASSWORD:" ) )
                    {
                        stcfg.strPassword = args[i].Substring( "/PASSWORD:".Length );
                    }
                    else if ( args[i].StartsWith( "/LOGNTEVENTS" ) )
                    {
                        stcfg.bEventLog = true;
                    }
                    else
                    {	
						// Prepend date and time to message.
						DateTime now = DateTime.Now;
						string LoggedMessage = now.ToString ( ) + " - Unknown parameter encountered. (" + args[i] + ")"; 

						Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);

						WriteUsage();
                        return;
                    }
				}

				//determine start and end time
				//============================

				DateTimeFormatInfo dtfi  = new DateTimeFormatInfo();
				dtfi.FullDateTimePattern = "MM/dd/yyyy HH:mm";

				try
				{
					if ( null == strStartTime && null == strStartDate )
					{
						// Prepend date and time to message.
						DateTime now = DateTime.Now;
						string LoggedMessage = now.ToString ( ) + " - Starting Date or Time must be specified!"; 

						Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
						WriteUsage();
						return;
					}
					else if ( null == strStartTime )
					{
						stcfg.dt = Convert.ToDateTime( strStartDate + " 00:00", dtfi );	
					}
					else if ( null == strStartDate )
					{
						stcfg.dt = Convert.ToDateTime( DateTime.Now.ToShortDateString() + " " + strStartTime, dtfi );
					}
					else
					{
						stcfg.dt =Convert.ToDateTime( strStartDate + " " + strStartTime, dtfi );
					}

					if ( null == strEndTime && null == strEndDate )
					{
						stcfg.dtEnd = DateTime.Now;
					}
					else if ( null == strEndTime )
					{
						stcfg.dtEnd = Convert.ToDateTime ( strEndDate + " 00:00", dtfi );
					}
					else if ( null == strEndDate )
					{
						stcfg.dtEnd = Convert.ToDateTime( DateTime.Now.ToShortDateString() + " " + strEndTime, dtfi );
					}
					else
					{
						stcfg.dtEnd = Convert.ToDateTime( strEndDate + " " + strEndTime, dtfi );
					}

				}

				catch (Exception e)
				{
					// Prepend date and time to message.
					DateTime now = DateTime.Now;
					string LoggedMessage = now.ToString ( ) + " - " + e.Message + ":" + e.StackTrace; 

					Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
				}

				//collect the logs
				//================
			
				try
				{
					if ( iWildCount > 0 && null == strDomain)
					{
						throw new Exception("Domain must be specified for active directory!"); 
					}
					
                    ArrayList alAvail = new ArrayList();

                    //contact active directory if necessary
                    //=====================================

                    if (iWildCount > 0 && FindMachines( strDomain, uiMax, ref alAvail ) < 0 )
                    {
						throw new Exception("Error contacting active directory for domain " + strDomain + "!"); 
                    }

                    //determine the machines requested, throwing out duplicates
                    //=========================================================

                    foreach( string s in alChosen)
                    {
                        int iAst = s.IndexOf('*');
						
                        if (iAst >= 0)
                        {
                            //wildcard found
                            //==============

                            foreach( string s2 in alAvail)
                            {
                                if ( s2.StartsWith( s.Substring(0,iAst) ) )
                                {
                                    //don't allow duplicates
                                    //======================

                                    bool bDup = false;

                                    foreach (string s3 in stcfg.alMachines)
                                    {
                                        if ( s3 == s2)
                                        {
                                            bDup = true;
                                        }
                                    }

                                    if (!bDup)
                                    {
                                        stcfg.alMachines.Add(s2);
                                    }

                                }
                            }
                        }
                        else
                        {
                            //no wildcard, but check for duplicates
                            //=====================================

                            bool bDup = false;

                            foreach (string s3 in stcfg.alMachines)
                            {
                                if ( s3 == s )
                                {
                                    bDup = true;
                                }
                            }

                            if (!bDup)
                            {
                                stcfg.alMachines.Add( s );
                            }

                        }
                    }
			

                    //start the collection
                    //====================

                    string strReport = "";

                    StartWork work = new StartWork(stcfg, null);
                    
                    work.Collect();
					strReport = work.Report;
					// Prepend date and time to message.
					string LoggedReport = DateTime.Now.ToString ( ) + " - " + strReport; 

					Logging.LogMessage(Logging.MsgType.Info, LoggedReport);
				}

				catch (Exception e)
				{
					// Prepend date and time to message.
					DateTime now = DateTime.Now;
					string LoggedMessage = now.ToString ( ) + " - " + e.Message + ":" + e.StackTrace; 

					Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
					WriteUsage();
				}
			}
		}

        private static void WriteUsage()
        {
            string strUsage = "Usage: logcollect [/MACHINE:<machine name>] [/DOMAIN:<domain>] [/MAX:<max machines>] [/CSV] [/APPLOGS] [/SYSLOGS]\r\n" +
                "                  [/SECLOGS] [/TXTLOGS] [/IISLOGS] [/STARTDATE:<MM/dd/yyyy>]\r\n" +
                "                  [/STARTTIME:<HH:mm>] [/ENDDATE:<MM/dd/yyyy>] [/ENDTIME:<HH:mm>]\r\n" +
                "                  [/DBSERVER:<Database machine>] [/DB:<Database name]\r\n" +
                "                  [/USER:<User name for DB login> [/PASSWORD:<Password for DB>]\r\n\r\n" +
                "Examples:   logcollect /MACHINE:secuinh001 /MACHINE:secuiis* /APPLOGS /SECLOGS /STARTDATE:07/01/2002 /DBSERVER:infrdmg001 /DB:eventlogs\r\n" +
                "            logcollect /MACHINE:statsql001 /MACHINE:another /APPLOGS /STARTDATE:05/02/2002 /ENDDATE:05/15/2002\r\n" +
                "            logcollect /MACHINE:xkdcinh* /MACHINE:xkdciis* /SECLOGS /DBSERVER: /STARTDATE:09/28/2002 /STARTTIME:18:30\r\n\r\n" +
                "If DBSERVER is not specified, eventlogs will be collected into text files. (/CSV for CSV txt format) If an empty DBSERVER ( /DBSERVER: )\r\n" +
                "is specified, it will default to the 'eventlogs' database on the local machine.\r\n" +
                "If no USER and PASSWORD is specified, it will use the credentials of the launching\r\n" +
                "user to access the database.\r\n" +
                "Multiple instance of MACHINE can be specified, but DOMAIN must be specified if any MACHINE instances\r\n" +
                "contain wildcards (*) because active directory must be contacted.\r\n" +
                "The MAX parameter specifies the maximum number of machines that will be located through active\r\n" +
                "directory. The default is 400.\r\n" +
                "Either /STARTDATE or /STARTTIME must be specified.\r\n";
		
			DateTime now = DateTime.Now;
			string LoggedMessage = now.ToString ( ) + " - " + strUsage; 

			Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
		}

		private static int FindMachines( string strDomain, uint uiMax, ref ArrayList alFoundMachines)
		{
			try
			{
				DirectoryEntry entry = new DirectoryEntry("LDAP://" + strDomain);

				DirectorySearcher searcher = new DirectorySearcher(entry);
	
				searcher.Filter = "(objectClass=computer)";
				searcher.SizeLimit = (int)uiMax;
				//searcher.ServerTimeLimit = 

				SearchResultCollection src = searcher.FindAll();

				foreach(SearchResult sres in src)
				{	
					string s = sres.GetDirectoryEntry().Name.ToString().Substring(3).ToUpper();
				
					alFoundMachines.Add(s);
				}
			}

			catch (Exception e)
			{
				// Prepend date and time to message.
				DateTime now = DateTime.Now;
				string LoggedMessage = now.ToString ( ) + " - " + e.Message + ":" + e.StackTrace; 

				Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
			}

			

			return 0;
		}

		private void button1_Click(object sender, System.EventArgs e)
		{


			m_buttonCollect.Enabled = false;

			startconfig stcfg = new startconfig(0);
					
			string s = stcfg.dt.ToString();
																																 
			//adjust the filter time for event log events
			//===========================================

			switch (m_comboBoxTime.SelectedIndex)
			{
				case 0:
					stcfg.dt = stcfg.dt.AddHours(-1); break;
				case 1:
					stcfg.dt = stcfg.dt.AddHours(-2); break;
				case 2:
					stcfg.dt = stcfg.dt.AddHours(-6); break;
				case 3:
					stcfg.dt = stcfg.dt.AddHours(-12); break;
				case 4:
					stcfg.dt = stcfg.dt.AddDays(-1); break;
				case 5:
					stcfg.dt = stcfg.dt.AddDays(-2); break;
				case 6:
					stcfg.dt = stcfg.dt.AddDays(-7); break;
				case 7:
					stcfg.dt = stcfg.dt.AddMonths(-1); break;
				case 8:
					stcfg.dt = stcfg.dt.AddMonths(-2); break;
				case 9:
					stcfg.dt = stcfg.dt.AddMonths(-4); break;
				case 10:
					stcfg.dt = stcfg.dt.AddYears(-100); break;
			}

			//add the machines
			//================

			for(int j=0; j<m_listBoxServers.SelectedItems.Count; j++)
			{
				stcfg.alMachines.Add( m_listBoxServers.SelectedItems[j] );
			}

			//set up all the other parameters
			//===============================

			for(int i=0; i<m_listBoxLogs.SelectedIndices.Count; i++)
			{
				switch(m_listBoxLogs.SelectedIndices[i])
				{
					case 0:
						stcfg.bApplogs = true; break;
					case 1:
						stcfg.bSeclogs = true; break;
					case 2:
						stcfg.bSyslogs = true; break;
				}
			}

            if ( m_checkBoxIIS.Checked )
            {
			    stcfg.alTxtlogs.Add ( m_textBoxIIS.Text ); 
            }

            if ( m_checkBoxTextLogs.Checked )
            {
                stcfg.alIISlogs.Add (  m_textBoxTextLogs.Text );
            }

		    stcfg.bCSV = radioButtonTxtFileCSV.Checked;
	
            if (m_radioButtonDB.Checked)
            {
                stcfg.strDB = m_textBoxDB.Text;
                stcfg.strDBServer = m_textBoxDBServer.Text;
			
                if (m_checkBoxSpecify.Checked)
                {
                    stcfg.strPassword = m_textBoxUser.Text;
                    stcfg.strUser = m_textBoxPassword.Text;
                }
            }
           	

			//collect the logs
			//================

			try
			{
				StartWork work = new StartWork(stcfg, new MessageCallback(ResultCallback));

				// Create a thread to execute the task, and then
				// start the thread.
				Thread t = new Thread(new ThreadStart(work.Collect));
				t.Start();
				//t.Join();
			}

			catch (Exception ex)
			{
				m_buttonCollect.Enabled = true;
				// Prepend date and time to message.
				DateTime now = DateTime.Now;
				string LoggedMessage = now.ToString ( ) + " - " + ex.Message + ":" + ex.StackTrace; 

				Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
			}

		}


		private void m_listBoxServers_DoubleClick(object sender, System.EventArgs e)
		{
			bool bAll = true;

			if ( m_listBoxServers.SelectedItems.Count == m_listBoxServers.Items.Count - 1 )
			{
				bAll = false;
			}

			for(int i=0; i< m_listBoxServers.Items.Count; i++)
			{
				m_listBoxServers.SetSelected(i, bAll);
			}
		}

		private void radioButtonText_CheckedChanged(object sender, System.EventArgs e)
		{
			m_textBoxDBServer.Enabled = false;
			m_textBoxDB.Enabled = false;

			m_checkBoxSpecify.Enabled = false;
			m_textBoxUser.Enabled = false;
			m_textBoxPassword.Enabled = false;	
		}

        private void radioButtonTxtFileCSV_CheckedChanged(object sender, System.EventArgs e)
        {
            m_textBoxDBServer.Enabled = false;
            m_textBoxDB.Enabled = false;

            m_checkBoxSpecify.Enabled = false;
            m_textBoxUser.Enabled = false;
            m_textBoxPassword.Enabled = false;	     
        }

		private void radioButtonDB_CheckedChanged(object sender, System.EventArgs e)
		{
			m_textBoxDBServer.Enabled = true;
			m_textBoxDB.Enabled = true;

			m_checkBoxSpecify.Enabled = true;	
			m_textBoxUser.Enabled = m_checkBoxSpecify.Checked;
			m_textBoxPassword.Enabled = m_checkBoxSpecify.Checked;

		}

		private void m_checkBoxSpecify_CheckedChanged(object sender, System.EventArgs e)
		{
			m_textBoxUser.Enabled = m_checkBoxSpecify.Checked;
			m_textBoxPassword.Enabled = m_checkBoxSpecify.Checked;			
		}

		private void TextBoxDomain_KeyPress(object sender, System.Windows.Forms.KeyPressEventArgs e)
		{

		}

		private void m_buttonFind_Click(object sender, System.EventArgs e)
		{
			m_buttonFind.Text = "Finding..";
			m_listBoxServers.Items.Clear();
            m_alAllMachines.Clear();

			m_buttonFind.Refresh();

			if ( FindMachines( m_textBoxDomain.Text, Convert.ToUInt32(m_textBoxMax.Text), ref m_alAllMachines) < 0 )
			{
				MessageBox.Show("Failure encountered while contacting active directory","Failure");
			}

			foreach( string s in m_alAllMachines)
			{
				m_listBoxServers.Items.Add(s);
			}	

			m_buttonFind.Text = "Find";
		}

		public void ResultCallback(int nPercentComplete, string strMessage, string strReport)
		{
			switch (nPercentComplete)
			{
				case -1:
					m_labelStatus.Text = "";
					m_progBarStatus.Value = 0;
					return;
				case -2:
					m_labelStatus.Text = strMessage;
					m_progBarStatus.Value = 0;
					this.m_buttonCollect.Enabled = true;
					if (null != strReport)
					{
						DateTime now = DateTime.Now;
						string LoggedMessage = now.ToString ( ) + " - " + strReport; 

						Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
					}
					return;
				default:
					break;
			}

			m_labelStatus.Text = strMessage;
			m_progBarStatus.Value = nPercentComplete;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\realTimeWeb\now.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.IO;
using System.Configuration;
using System.Diagnostics;
using System.Globalization;

namespace xonline.ops.tools.realtimeweb 
{
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
	public class WebForm1 : System.Web.UI.Page
	{
        protected System.Web.UI.WebControls.DataGrid dgRegions;
        protected System.Web.UI.WebControls.DataGrid dgMOMAlerts;
        protected System.Web.UI.WebControls.Image Image1;
        protected System.Web.UI.WebControls.Image Image2;
        protected System.Web.UI.WebControls.Image Image3;
        protected System.Web.UI.HtmlControls.HtmlTableRow Accounts;
        protected System.Web.UI.HtmlControls.HtmlTableRow MOM;
        protected System.Web.UI.HtmlControls.HtmlTableRow Network;
        protected System.Web.UI.HtmlControls.HtmlTableRow tukPresRealTime;
        protected System.Web.UI.HtmlControls.HtmlTableRow Billing;
        protected System.Web.UI.HtmlControls.HtmlGenericControl Time;
        protected System.Web.UI.HtmlControls.HtmlGenericControl Active;
        protected System.Web.UI.HtmlControls.HtmlGenericControl uptime;
        protected System.Web.UI.HtmlControls.HtmlGenericControl links;
        protected System.Web.UI.HtmlControls.HtmlGenericControl concurrency;
        protected System.Web.UI.HtmlControls.HtmlGenericControl MaxQueued;
        protected System.Web.UI.HtmlControls.HtmlGenericControl MinQueued;
        protected System.Web.UI.HtmlControls.HtmlGenericControl MaxPurchase;
        protected System.Web.UI.HtmlControls.HtmlGenericControl MinPurchase;
        protected System.Web.UI.HtmlControls.HtmlInputHidden hidTime;  
        protected System.Web.UI.HtmlControls.HtmlGenericControl noAlerts;
        

        private int _totalUsers = 0;
        protected System.Web.UI.WebControls.Image Image6;
        protected System.Web.UI.WebControls.Image Image5;
        protected System.Web.UI.WebControls.Image Image4;
        private int _totalAlerts = 0;
    
        /// <summary>
        /// On Pageload we select which view is to be shown and bind all 
        /// the labels.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Page_Load(object sender, System.EventArgs e)
        {
            // Put user code to initialize the page here
            
            Accounts.Visible = false;
            MOM.Visible = false;
            Network.Visible = false;
            tukPresRealTime.Visible = false;
            Billing.Visible = false;

            if(Request["report"] == null || Request["report"] == "1")
            {
                Accounts.Visible = true;
                bindRegionalAccounts();
            }
            else if(Request["report"] == "2")
            {
                MOM.Visible = true;
                bindMOM(); 
            }
            else if(Request["report"] == "3")
                Network.Visible = true;
            else if(Request["report"] == "4")
                Billing.Visible = true;
            else if(Request["report"] == "5")
                tukPresRealTime.Visible = true;
            else if(Request["report"] == "6")
            {
                links.Visible = true;
                getClusterLinks(links);
            }


            // bind the time thing
            DateTime dNow = getTime();
            Time.InnerHtml = dNow.ToString("d", DateTimeFormatInfo.InvariantInfo) + "<br/>" + dNow.ToString("t", DateTimeFormatInfo.InvariantInfo);
            hidTime.Value = "REALWEB123" + Time.InnerText.Trim() + "REALWEB123";
            int iActive = getActiveUsers();
            Active.InnerText = String.Format("{0:n0}",iActive);

            MaxQueued.InnerText = String.Format("{0:n0}", getQueuedMaxMin("data\\XuacsAccounts.csv", true));
            MinQueued.InnerText = String.Format("{0:n0}", getQueuedMaxMin("data\\XuacsAccounts.csv", false));
            
            MaxPurchase.InnerText = String.Format("{0:n0}", getQueuedMaxMin("data\\PremiumPurchaseFailures.csv", true));
            MinPurchase.InnerText = String.Format("{0:n0}", getQueuedMaxMin("data\\PremiumPurchaseFailures.csv", false));

            double d = getPresUptime();            
            uptime.InnerText = Convert.ToString((int)(d / 24)) + " days, " + Convert.ToString((int)(d % 24)) + " hrs";
		}

        class PicDirectory : IComparable
        {
            public DateTime time;
            public string   dirName;
            public string   parsed;

            public PicDirectory(DateTime t, string d, string p)
            {
                time = t;
                dirName = d;
                parsed = p;
            }

            public int CompareTo(object o)
            {
                if(o is PicDirectory)
                {
                    PicDirectory p = (PicDirectory) o;
                    if(time.CompareTo(p.time) != 0)
                        return time.CompareTo(p.time);

                    return dirName.CompareTo(p.dirName);
                }

                throw new ArgumentException();
            }
        }

        private void getClusterLinks(HtmlGenericControl links)
        {
            ArrayList list = null;
			
			
			if(Application["dirs"] == null || ((DateTime)Application["date"]).Day != DateTime.Now.Day)
			{
				list = new ArrayList();
				string [] dirs = Directory.GetDirectories(Server.MapPath("data"));    
            

				foreach(string path in dirs)
				{
					int last = path.LastIndexOf("\\");
					string dir = path.Substring(last + 1, path.Length - last - 1);
					string temp = ClusterGraph.parsed(dir);
					int space = temp.IndexOf(" ");
					DateTime now = Convert.ToDateTime(temp.Substring(0, space));                

					list.Add(new PicDirectory(now, dir, temp));
				}

				list.Sort();

				list.Reverse();

				Application["dirs"] = list;
				Application["date"] = DateTime.Now;				
			}

			list = (ArrayList)Application["dirs"];

            DateTime prev = new DateTime();
            bool bPrev = false;
            foreach(PicDirectory item in list)
            {
                if(bPrev != false)
                {
                    if(((TimeSpan)prev.Subtract(item.time)).TotalDays > 0)
                    {
                        links.InnerHtml += "<br/>----------------------------------<br/>";
                    }
                }                   

                links.InnerHtml += " <a href=\"ClusterGraph.aspx?dir=" + item.dirName + "\" target=_blank  class=\"MenuUnselected\">" + item.parsed + "</a><br/>";

                prev = item.time;
                bPrev = true;
            }

        }

        /// <summary>
        /// Here we calculate the concurrency.  It must be done here because the counter, _totalUsers,
        /// is not calculated until after the dgRegions datagrid is bound.  And OnPreRender is called
        /// after that.
        /// </summary>
        /// <param name="e"></param>
        protected override void OnPreRender(EventArgs e)
        {
            double d = new Double();
            d = 100 * ((double)getActiveUsers() / (double)_totalUsers);
            concurrency.InnerText = String.Format("{0:f2}", d) + "%";

            if(Request["report"] == "2" && _totalAlerts == 0)
            {
                dgMOMAlerts.Visible = false;
                noAlerts.InnerText = "No alerts in the last 5 hrs.";
            }

            base.OnPreRender(e);
        }

        /// <summary>
        /// Given a comma dilemited file it looks through the last 3 columns
        /// out of 4.
        /// 
        /// It adds the last 3 and returns the max if bMax is true and returns
        /// the min if it is false.
        /// 
        /// NOTE: File needs to have 4 columns.
        /// </summary>
        /// <param name="file">The Virtual path to the file.</param>
        /// <param name="bMax">If true the max of the last 3 columns added is returned.</param>
        /// <returns></returns>
        private double getQueuedMaxMin(string file, bool bMax)
        {
            string s = "";
            StreamReader srReadLine = null;
            double max = -1;
            bool bFirst = true;
            try 
            {

                srReadLine = new StreamReader(
                    (System.IO.Stream)File.OpenRead(Server.MapPath(file)),         
                    System.Text.Encoding.ASCII);

                srReadLine.BaseStream.Seek(0, SeekOrigin.Begin);

                // skip the first line
                s = srReadLine.ReadLine(); 
                while (srReadLine.Peek() > -1) 
                {
                    s = srReadLine.ReadLine(); 

                    string[] arr = s.Replace('"', ' ').Split(new Char[] {','});

                    if(arr.Length > 3)
                    {
                        double temp = Convert.ToDouble(arr[1]) + Convert.ToDouble(arr[2]) + Convert.ToDouble(arr[3]);

                        
                        if(bMax && (temp > max))
                            max = temp;
                        
                        if(!bMax && (temp < max))
                            max = temp;


                        if(bFirst)
                        {
                            max = temp;
                            bFirst = false;
                        }
                        
                    }
                                   
                }
            }
            catch(FormatException e)
            {
            }
            catch(Exception e)
            {
                throw e;
            }
            finally
            {
                if(srReadLine != null)
                    srReadLine.Close();                
            }
            return max;
        }

        /// <summary>
        /// not done...
        /// </summary>
        /// <param name="file"></param>
        /// <returns></returns>
        private double getQueuedMaxChange(string file)
        {
            return -1;
        }


        /// <summary>
        /// not used.
        /// </summary>
        /// <param name="file"></param>
        /// <param name="col"></param>
        /// <param name="bMax"></param>
        /// <returns></returns>
        private double getMaxMin(string file, int col, bool bMax)
        {
            string s = "";
            StreamReader srReadLine = null;
            double max = -1;
            bool bFirst = true;
            try 
            {

                srReadLine = new StreamReader(
                    (System.IO.Stream)File.OpenRead(Server.MapPath(file)),         
                    System.Text.Encoding.ASCII);

                srReadLine.BaseStream.Seek(0, SeekOrigin.Begin);

                // skip the first line
                s = srReadLine.ReadLine();
                while (srReadLine.Peek() > -1) 
                {
                    s = srReadLine.ReadLine(); 

                    string[] arr = s.Replace('"', ' ').Split(new Char[] {','});

                    if(arr.Length > col)
                    {
                        double temp = Convert.ToDouble(arr[col]);
                          
                        if(bMax && (temp > max))
                            max = temp;
                        
                        if(!bMax && (temp < max))
                            max = temp;

                        if(bFirst)
                        {
                            max = temp;
                            bFirst = false;
                        }
                        
                    }
                                   
                }
            }
            catch(FormatException e)
            {
            }
            catch(Exception e)
            {
                throw e;
            }
            finally
            {
                if(srReadLine != null)
                    srReadLine.Close();                
            }
            return max;
        }

       

        /// <summary>
        /// Gets the time from the DB
        /// 
        /// </summary>
        /// <returns>The time.</returns>
        private DateTime getTime()
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();
            string cmdStr = "declare @counter1 int\n" + 
                "declare @time DateTime\n" + 
                "select top 1 @time = DateTime from CounterData\n" + 
                "order by DateTime desc\n" + 
                "select @time\n";

            SqlDataAdapter  cmd = new SqlDataAdapter(cmdStr, conn);
		    

            DataSet ds = new DataSet();
            cmd.Fill(ds);
            object[] obj = ds.Tables[0].Rows[0].ItemArray;
            
            conn.Close();

            return (DateTime)obj[0];
        }
        
        /// <summary>
        /// Gets the last reading of the active users in the DB
        /// </summary>
        /// <returns></returns>
        private int getActiveUsers()
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();
            string cmdStr = "declare @counter1 int\n" + 
                            "declare @counter2 int\n" + 
                            "select top 1 @counter1 = CounterValue from CounterData where CounterID = '6'\n" + 
                            "order by DateTime desc\n" + 
                            "select top 1 @counter2 = CounterValue from CounterData where CounterID = '12'\n" + 
                            "order by DateTime desc\n" + 
                            "select @counter2 + @counter1\n";


            SqlDataAdapter  cmd = new SqlDataAdapter(cmdStr, conn);
		    

            DataSet ds = new DataSet();
            cmd.Fill(ds);
            object[] obj = ds.Tables[0].Rows[0].ItemArray;
            
            conn.Close();

            return (int)obj[0];
        }


        /// <summary>
        /// Gets the last reading of presuptime in the DB
        /// It converts the time to hours.
        /// </summary>
        /// <returns></returns>
        private double getPresUptime()
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();
            string cmdStr = "declare @counter1 float\n" + 
                "declare @counter2 float\n" + 
                "select top 1 @counter1 = CounterValue from CounterData where CounterID = '5'\n" + 
                "order by DateTime desc\n" + 
                "select top 1 @counter2 = CounterValue from CounterData where CounterID = '11'\n" + 
                "order by DateTime desc\n" + 
                "if @counter1 > @counter2\n" +
                "begin\n" +
            	"   select @counter1 / 3600\n" +
                "end\n" +
                "else\n" +
                "begin\n" +
                "	select @counter2 / 3600\n" +
                "end\n";


            SqlDataAdapter  cmd = new SqlDataAdapter(cmdStr, conn);
		    

            DataSet ds = new DataSet();
            cmd.Fill(ds);
            object[] obj = ds.Tables[0].Rows[0].ItemArray;
            
            conn.Close();

            return (double) obj[0];
        }


        /// <summary>
        /// Binds the MOM datagrid to the MOM query results xml.
        /// </summary>
       
        private void bindMOM()
        {
            DataSet dt = new DataSet();

            dt.ReadXml(Server.MapPath("data\\momAlerts.xml"), XmlReadMode.InferSchema);

            DataView dv = new DataView(dt.Tables[1]);

            dgMOMAlerts.DataSource = dv;
            dgMOMAlerts.DataBind();
        }

        /// <summary>
        /// Reads in usercounts.csv and binds it the dgRegion datagrid.
        /// </summary>
        private void bindRegionalAccounts()
        {

            ArrayList list = new ArrayList();
            Hashtable   hash = new Hashtable();
            // open the file         

            StreamReader srReadLine = null;
            try 
            {

                srReadLine = new StreamReader(
                        (System.IO.Stream)File.OpenRead(Server.MapPath("data\\usercounts.csv")),         
                        System.Text.Encoding.ASCII);

                srReadLine.BaseStream.Seek(0, SeekOrigin.Begin);
                while (srReadLine.Peek() > -1) 
                {
                    string strline = srReadLine.ReadLine();
                    

                    // break the line by the comma
                    string[] arr = strline.Split(new Char[] {','});                                       

                    if(arr.Length > 0)
                    {
                        hash.Add(String.Format("{0:n0}", arr[0]), String.Format("{0:n0}", arr[1]));
                    }
                }
            }
            catch(Exception e)
            {
                throw e;
            }
            finally
            {
                if(srReadLine != null)
                    srReadLine.Close();
            }

            dgRegions.DataSource = hash;
            dgRegions.DataBind();

            // read the stuff into the arraylist
        }

        /// <summary>
        /// This is called when the MOM datagrid is databound.  In here we do formating.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public void dgMOM_ItemDataBound(object sender, DataGridItemEventArgs e)
        {
            if (e.Item.ItemType == ListItemType.Item || e.Item.ItemType == ListItemType.AlternatingItem)
            {
                e.Item.Cells[1].Text = string.Format("{0:H:mm, M/d}", (DateTime)Convert.ToDateTime(e.Item.Cells[1].Text).ToLocalTime());
                DateTime t = (DateTime)Convert.ToDateTime(e.Item.Cells[1].Text);

                string text = "";
                string alert = e.Item.Cells[0].Text;
                switch(alert)
                {
                    case "Error":
                        text = "<img src='error.gif' /> <font color='red'> Error</font>";
                        break;
                    case "Warning":
                        text = "<img src='warning.gif' /> <font color='black'>Warning</font>";
                        break;
                    case "Critical Error":
                        text = "<img src='critical.gif' /> <font color='red'> Critical Error</font>";
                        break;
                    case "Information":
                        text = "<img src='information.gif' /> <font color='black'>Information</font>";
                        break;
                    default :
                        text = alert;
                        break;
                }

                e.Item.Cells[0].Text = text;

                HtmlAnchor anchor = new HtmlAnchor();
                anchor.Attributes.Add("class", "bug");
                anchor.Target = "_blank";
                string newStr = "http://raidmail2/PSBug.asp?PSName=XboxOnline&bugid=";
                string owner = e.Item.Cells[7].Text;
                int index = owner.IndexOf('-');
                
                try
                {
                    if(index != -1)
                    { 
                        if(owner.IndexOf('o') != -1)
                        {
                            newStr += owner.Substring(index + 1);
                            anchor.HRef = newStr;
                            anchor.InnerText = owner;

                            e.Item.Cells[7].Controls.Clear();
                            e.Item.Cells[7].Controls.Add(anchor);
                        }
                    }                     
                }
                catch(Exception ex)
                {
                    throw ex;
                }

                if(t.AddHours(5) < DateTime.Now)
                {
                    e.Item.Controls.Clear();
                }      
                else
                    _totalAlerts++;
            } 
        }

        /// <summary>
        /// Called when the dgRegions datagrid is bound.  We do formatting and keep 
        /// track of _totalUsers to calculate concurrency.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public void dgRegions_ItemDataBound(object sender, DataGridItemEventArgs e)
        {
            if (e.Item.ItemType == ListItemType.Item || e.Item.ItemType == ListItemType.AlternatingItem)
            {
                _totalUsers += (int)Convert.ToDouble(e.Item.Cells[1].Text);
                e.Item.Cells[1].Text = string.Format("{0:n0}", (int)Convert.ToDouble(e.Item.Cells[1].Text));
            }
            else if(e.Item.ItemType == ListItemType.Footer )
            {
                e.Item.Attributes.Add("align","Right");
                e.Item.CssClass = "CartListFooter";
                e.Item.Cells[0].Text="Total Accounts:";
                e.Item.Cells[1].Text = string.Format("{0:n0}", _totalUsers);
            } 


        }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion

        private void reportDocument1_InitReport(object sender, System.EventArgs e)
        {
        
        }
	}
}

        /*
        private void bindUsersChart()
        {        
    
            string times = "";
            string users1 = "";

            StreamReader srReadLine = null;
            try 
            {

                srReadLine = new StreamReader(
                    (System.IO.Stream)File.OpenRead(Server.MapPath("XOCReport.csv")),
                    System.Text.Encoding.ASCII);

                srReadLine.BaseStream.Seek(0, SeekOrigin.Begin);
             4   if(true)
                    srReadLine.ReadLine();

                while (srReadLine.Peek() > -1) 
                {
                    string line = srReadLine.ReadLine().Replace('"', ' ');    
                    string[] arr = line.Split(new Char[] {','});                                       

                    if(arr.Length > 0)
                    {
                        times += "\t" + arr[0];
                        users1 += "\t" + (Convert.ToInt16(arr[1]) + Convert.ToInt16(arr[2]));
                    }
              
                }
            }
            catch(Exception e)
            {
            }
            finally
            {
                if(srReadLine != null)
                    srReadLine.Close();                
            }

            OWC10.ChartSpace oChartSpace = new OWC10.ChartSpace();

            oChartSpace.Charts.Add(0);
            //oChartSpace.Charts[0].SetData(OWC10.ChartDimensionsEnum.chDimCategories, 
            //oChartSpace.Charts[0].SeriesCollection.

            oChartSpace.Charts[0].SeriesCollection.Add(0);

            oChartSpace.Charts[0].HasTitle = true;
            oChartSpace.Charts[0].Title.Caption = "Total Online Users on Presence Server";     
            oChartSpace.Charts[0].Title.Font.Size = 15;

            oChartSpace.Charts[0].Axes[0].HasTitle = true;
            oChartSpace.Charts[0].Axes[0].Title.Caption = "Time";
            oChartSpace.Charts[0].Axes[0].Title.Font.Bold = true;

            oChartSpace.Charts[0].Axes[1].HasTitle = true;
            oChartSpace.Charts[0].Axes[1].Title.Caption = "Users";            
            oChartSpace.Charts[0].Axes[1].Title.Font.Bold = true;

            oChartSpace.Charts[0].Type = OWC10.ChartChartTypeEnum.chChartTypeSmoothLine;
            oChartSpace.Charts[0].SeriesCollection[0].SetData(OWC10.ChartDimensionsEnum.chDimCategories,
                Convert.ToInt32(OWC10.ChartSpecialDataSourcesEnum.chDataLiteral), times );
            oChartSpace.Charts[0].SeriesCollection[0].SetData(OWC10.ChartDimensionsEnum.chDimValues,
                Convert.ToInt32(OWC10.ChartSpecialDataSourcesEnum.chDataLiteral), users1 );

            oChartSpace.ExportPicture( Server.MapPath("usersonline.gif"), "gif", 500, 400);
        } 
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\taskschd\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// taskschd.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\taskschd\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#include <stdio.h>
#include <tchar.h>
#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit

#include <atlbase.h>

// TODO: reference additional headers your program requires here
#include <string>
#include <vector>
#include <fstream>
#include <iostream>
#include <mstask.h>
#include <msterr.h>

using namespace std;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\realTimeWeb\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;
using System.Diagnostics;
using System.Web.Mail;
using System.Configuration;

namespace xonline.ops.tools.realtimeweb  
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{
            return ;
            // get reference to the source of the exception chain
            Exception ex = Server.GetLastError().GetBaseException();

            string str = "\nRealTimeWeb\n" + 
                "MESSAGE: " + ex.Message + "\n" +  
                "\nSOURCE: " + ex.Source +"\n" + 
                "\nFORM: " + Request.Form.ToString() + "\n" + 
                "\nQUERYSTRING: " + Request.QueryString.ToString() +"\n" + 
                "\nTARGETSITE: "+ ex.TargetSite +"\n" + 
                "\nSTACKTRACE: \n" + ex.StackTrace;

            sendMail("ERROR in RealTimeWeb", str, ConfigurationSettings.AppSettings["ErrorEmail"], ConfigurationSettings.AppSettings["ErrorEmail"]);

            
            EventLog.WriteEntry("RealTimeWeb", str, EventLogEntryType.Error, 1);      
		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}


        public void sendMail(string title, string body, string to, string from)
        {
            MailMessage mail = new MailMessage();
            mail.From = from;
            mail.To = to;
            mail.Subject = title;
            mail.Body = body;
            mail.BodyFormat = MailFormat.Text;
            SmtpMail.SmtpServer = "smtphost";
            SmtpMail.Send(mail);    
        }
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\realTimeWeb\MyBaby.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace xonline.ops.tools.realtimeweb 
{
	/// <summary>
	/// Summary description for MyBaby.
	/// </summary>
	public class MyBaby : System.Web.UI.Page
	{
        protected System.Web.UI.HtmlControls.HtmlInputText cluster;
        protected System.Web.UI.HtmlControls.HtmlInputText end;
        protected System.Web.UI.HtmlControls.HtmlInputText begin;
    
		private void Page_Load(object sender, System.EventArgs e)
		{


            if(this.IsPostBack)
            {
                string ap = "<applet name=\"Marks2\" code=\"ptolemy.plot.plotml.PlotMLApplet\" width=\"700\" height=\"400\" codebase=\".\" archive=\"plotmlapplet.jar\" alt=\"If you had a java-enabled browser, you would see an applet here.\" VIEWASTEXT>" + 
                    "<PARAM NAME=\"dataurl\" VALUE=\"http://xonsvc001/realtime/clusterdata.aspx?beg=" 
                    + Request["begin"].Replace(" ", "%20") 
                    + "&end=" + Request["end"].Replace(" ", "%20") 
                    + "&cluster=" + Request["cluster"]
                    + "&interval=5\"/>" + 
                    "<PARAM NAME=\"background\" VALUE=\"c9c7c7\">" + 
                    "<hr>" + 
                    "If your browser recognized the applet tag, you would see an applet here.<hr>" + 
                    "</applet>";

                Response.Write(ap);
            }

            
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\taskschd\TaskScheduler.h ===
#pragma once

// ----------------------------------------------------------------------------
//
// File Name:           taskscheduler.h
// Author:              Daniel Leeks (a-dleeks)
// Interdependencies:   None.
// Description: Task scheduling class definition.
//
// History:
//     4/10/2003 Initial checkin - a-dleeks
//
// ----------------------------------------------------------------------------

class CTaskScheduler
{
public:
	typedef enum
	{
		TASK_SCHEDULER_ONCE = 0,
		TASK_SCHEDULER_DAILY,
		TASK_SCHEDULER_WEEKLY,
		TASK_SCHEDULER_MONTHLY,
		TASK_SCHEDULER_MAX = 100,
	} TASK_SCHEDULER_FREQUENCY;

public:
	CTaskScheduler(void);
	virtual ~CTaskScheduler(void);

	HRESULT CreateTask(LPCWSTR pwszTaskName);
	HRESULT SetApplicationName(LPCWSTR pwszTaskName, LPCWSTR pwszApplicationName);
	HRESULT SetMaxRunTime(LPCWSTR pwszTaskName, DWORD dwMaxRunTime);
	HRESULT ClearTaskParameters(LPCWSTR pcwszTaskName);
	HRESULT SetTaskParameters(LPCWSTR pcwszTaskName, LPCWSTR pcwszParameters);
	HRESULT SetTaskPriority(LPCWSTR pwszTaskName, DWORD dwPriority);
	HRESULT SetTaskWorkingDirectory(LPCWSTR pwszTaskName, LPCWSTR pcwszWorkingDirectory);
	HRESULT SetTaskComment(LPCWSTR pwszTaskName, LPCWSTR pcwszTaskComment);
	HRESULT CreateTaskTrigger(LPCWSTR pcwszTaskName, SYSTEMTIME &stTrigger, TASK_SCHEDULER_FREQUENCY tsfFrequency = TASK_SCHEDULER_ONCE, WORD wInterval = 0);
	HRESULT SetAccountInformation(LPCWSTR pcwszTaskName, LPCWSTR pcwszAccount, LPCWSTR pcwszPassword);
	TASK_SCHEDULER_FREQUENCY DetermineFrequencyConstant(wstring strFrequency);

private:
	void Init();
	void Term();

protected:
	CComPtr<ITaskScheduler> m_spITS;
	bool m_fInitialized;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\SQLAdmin\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\taskschd\taskschd.cpp ===
#include "stdafx.h"
#include "TaskScheduler.h"

// ----------------------------------------------------------------------------
// taskscheduler.cpp
//
// File Name:           taskschd.cpp
// Author:              Daniel Leeks (a-dleeks)
// Interdependencies:   None.
// Description: Task scheduling console application.
//
// History:
//     4/10/2003 Initial checkin - a-dleeks
//
// ----------------------------------------------------------------------------

// global variables.
wstring g_strDate;
wstring g_strExecutable;
wstring g_strParameters;
wstring g_strWorkingDir;
wstring g_strFrequency;
wstring g_strInterval;
wstring g_strTaskName;
wstring g_strTaskComment;
wstring g_strUser;
wstring g_strPassword;

CTaskScheduler::TASK_SCHEDULER_FREQUENCY g_tsfFrequency;

//-----------------------------------------------------------------------------
// Function: ParseCommandLine(int argc, TCHAR* argv[])
//
// Description:  Constructor. Performs class instance initialization
//
// Parameters:
//    int argc - the number of arguments
//    TCHAR* argv[] - the variable argument list.
//
// Returns:
//    None.
//-----------------------------------------------------------------------------
void ParseCommandLine(int argc, TCHAR* argv[])
{
	for (int i = 1; i < argc; i++)
	{
		wchar_t* pszParam = (wchar_t*)argv[i];
		bool bFlag = false;
		bool bLast = ((i + 1) == argc);

		if (pszParam[0] == '-' || pszParam[0] == '/')
		{
			// remove flag specifier
			bFlag = true;
			++pszParam;
		}
		else
		{
			// This parameter is not a flag. It is unsupported.
			// Just skip it.
			continue;
		}

		wchar_t* pszToken = NULL;
		wchar_t szName[50];
		wstring strValue;

		memset(szName, 0, sizeof(wchar_t) * 50);

		pszToken = wcstok(pszParam, L"=");

		if (NULL != pszToken)
		{
			wcsncpy(szName, pszToken, wcslen(pszToken));
			pszToken = wcstok(NULL, L"=");
			// TODO: Either stop using wchar_t or figure out another way to perform this assignment.
			strValue = (wchar_t*)pszToken;
		}


		if (0 == wcsicmp(szName, L"TASKNAME"))
		{
			g_strTaskName = strValue;
		}

		if (0 == wcsicmp(szName, L"COMMENT"))
		{
			g_strTaskComment = strValue;
		}

		if (0 == wcsicmp(szName, L"STARTDATE"))
		{
			g_strDate = strValue;
		}

		if (0 == wcsicmp(szName, L"EXE"))
		{
			g_strExecutable = strValue;
		}

		if (0 == wcsicmp(szName, L"PARM"))
		{
			g_strParameters = strValue;
		}

		if (0 == wcsicmp(szName, L"WORKDIR"))
		{
			g_strWorkingDir = strValue;
		}

		if (0 == wcsicmp(szName, L"FREQUENCY"))
		{
			g_strFrequency = strValue;
		}

		if (0 == wcsicmp(szName, L"INTERVAL"))
		{
			g_strInterval = strValue;
		}

		if (0 == wcsicmp(szName, L"USER"))
		{
			g_strUser = strValue;
		}
		if (0 == wcsicmp(szName, L"PASS"))
		{
			g_strPassword = strValue;
		}
	}
}

//-----------------------------------------------------------------------------
// Function: DisplayUsage()
//
// Description:  Outputs the usage message.
//
// Parameters:
//    None.
//
// Returns:
//    None.
//-----------------------------------------------------------------------------
void DisplayUsage()
{
	cout << "Usage: tasksched -TASKNAME=value -COMMENT=value -EXE=value -PARM=value -WORKDIR=value -STARTDATE=value -USER=value -PASS=value [-FREQUENCY=HOUR|DAY|WEEK|MONTH [-PERIOD=value]]\n" << endl;
	cout << "Sample: tasksched -TASKNAME=Notes -COMMENT=\"Notepad works\" -EXE=notepad.exe -PARM=c:\\sources";
	cout << " -USER=REDMOND\\a-dleeks - PASS=password -STARTDATE=16:00:00 -FREQUENCY=HOUR\n" << endl;
}

//-----------------------------------------------------------------------------
// Function: ParseDate(LPCWSTR szDate, SYSTEMTIME &stDate)
//
// Description: Parses a string containing a date and fills in a SYSTEMTIME
//              structure.
//
// Parameters:
//    LPCWSTR szDate - The date to parse.
//    SYSTEMTIME &stDate - The variable to recieve the results.
//
// Returns:
//    bool - true if the date was parsed successfully; Otherwise, false.
//-----------------------------------------------------------------------------
bool ParseDate(LPCWSTR szDate, SYSTEMTIME &stDate)
{
	if (NULL == szDate)
	{
		return false;
	}

	LPWSTR pwszDate = new wchar_t[wcslen(szDate) + 1];

	if (NULL == pwszDate)
	{
		return false;
	}

	wcsncpy(pwszDate, szDate, wcslen(szDate));

	bool fReturn = true;

	wchar_t szYear[5];
	wchar_t szMonth[3];
	wchar_t szDay[3];
	wchar_t szHours[3];
	wchar_t szMinutes[3];
	wchar_t szSeconds[3];
	wchar_t szMiliSeconds[4];

	memset(szYear, 0, sizeof(wchar_t) * 5);
	memset(szMonth, 0, sizeof(wchar_t) * 3);
	memset(szDay, 0, sizeof(wchar_t) * 3);
	memset(szHours, 0, sizeof(wchar_t) * 3);
	memset(szMinutes, 0, sizeof(wchar_t) * 3);
	memset(szSeconds, 0, sizeof(wchar_t) * 3);
	memset(szMiliSeconds, 0, sizeof(wchar_t) * 4);

	int nToken = 0;
	wchar_t *pszToken = wcstok(pwszDate, L"/:. ");

	while (NULL != pszToken)
	{
		switch(nToken)
		{
		case 0:
			wcsncpy(szYear, pszToken, sizeof(szYear) / sizeof(wchar_t));
			break;
		case 1:
			wcsncpy(szMonth, pszToken, sizeof(szMonth) / sizeof(wchar_t));
			break;
		case 2:
			wcsncpy(szDay, pszToken, sizeof(szDay) / sizeof(wchar_t));
			break;
		case 3:
			wcsncpy(szHours, pszToken, sizeof(szHours) / sizeof(wchar_t));
			break;
		case 4:
			wcsncpy(szMinutes, pszToken, sizeof(szMinutes) / sizeof(wchar_t));
			break;
		case 5:
			wcsncpy(szSeconds, pszToken, sizeof(szSeconds) / sizeof(wchar_t));
			break;
		case 6:
			wcsncpy(szMiliSeconds, pszToken, sizeof(szMiliSeconds) / sizeof(wchar_t));
			break;
		default:
			break;
		}

		pszToken = wcstok(NULL, L"/:. ");
		++nToken;
	}

	delete[] pwszDate;
	pwszDate = NULL;

	stDate.wYear = _wtoi(szYear);
	stDate.wMonth = _wtoi(szMonth);
	stDate.wDay = _wtoi(szDay);
	stDate.wHour = _wtoi(szHours);
	stDate.wMinute = _wtoi(szMinutes);
	stDate.wSecond = _wtoi(szSeconds);
	stDate.wMilliseconds = _wtoi(szMiliSeconds);

	return fReturn;

}

//-----------------------------------------------------------------------------
// Function: _tmain(int argc, TCHAR* argv[])
//
// Description: The main entry point to the application.
//
// Parameters:
//    int argc - the number of arguments.
//    TCHAR* argv[] - the variable argument list.
//
// Returns:
//    int - 0 or greater if successful; Otherwise a negative integer.
//-----------------------------------------------------------------------------
int _tmain(int argc, TCHAR* argv[])
{
	CTaskScheduler *ptsObj = NULL;
	SYSTEMTIME stTrigger;
	bool fReturn = false;
	WORD wInterval = 0;
	CTaskScheduler::TASK_SCHEDULER_FREQUENCY tsfFrequency = CTaskScheduler::TASK_SCHEDULER_ONCE;

	ParseCommandLine(argc, argv);

	if (true == g_strDate.empty() ||
		true == g_strTaskName.empty() ||
		true == g_strExecutable.empty() ||
		true == g_strUser.empty() ||
		true == g_strPassword.empty())
	{
		DisplayUsage();
		return -1;
	}

	HRESULT hr = S_OK;

	hr = CoInitialize(NULL);

	if (FAILED(hr))
	{
		goto Error;
	}

	ptsObj = new CTaskScheduler;

	tsfFrequency = ptsObj->DetermineFrequencyConstant(g_strFrequency);

	fReturn = ParseDate(g_strDate.c_str(), stTrigger);

	if (true != g_strInterval.empty())
	{
		wInterval = _wtoi(g_strInterval.c_str());
	}

	hr = ptsObj->CreateTask(g_strTaskName.c_str());

	if (FAILED(hr))
	{
		goto Error;
	}

	hr = ptsObj->CreateTaskTrigger(g_strTaskName.c_str(), stTrigger, tsfFrequency, wInterval);

	if (FAILED(hr))
	{
		goto Error;
	}

	hr = ptsObj->SetApplicationName(g_strTaskName.c_str(), g_strExecutable.c_str());

	if (FAILED(hr))
	{
		goto Error;
	}

	if (true != g_strParameters.empty())
	{
		hr = ptsObj->SetTaskParameters(g_strTaskName.c_str(), g_strParameters.c_str());
	}

	if (FAILED(hr))
	{
		goto Error;
	}

	if (true != g_strWorkingDir.empty())
	{
		hr = ptsObj->SetTaskWorkingDirectory(g_strTaskName.c_str(), g_strWorkingDir.c_str());
	}

	if (FAILED(hr))
	{
		goto Error;
	}

	hr = ptsObj->SetAccountInformation(g_strTaskName.c_str(), g_strUser.c_str(), g_strPassword.c_str());

	if (FAILED(hr))
	{
		goto Error;
	}

	if (true != g_strTaskComment.empty())
	{
		hr = ptsObj->SetTaskComment(g_strTaskName.c_str(), g_strTaskComment.c_str());
	}

	if (FAILED(hr))
	{
		goto Error;
	}

	if (NULL != ptsObj)
	{
		delete ptsObj;
		ptsObj = NULL;
	}

Error:
	CoUninitialize();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\taskschd\TaskScheduler.cpp ===
#include "StdAfx.h"
#include "taskscheduler.h"

// ----------------------------------------------------------------------------
//
// File Name:           taskscheduler.cpp
// Author:              Daniel Leeks (a-dleeks)
// Interdependencies:   None.
// Description: Task scheduling class implmentaton.
//
// History:
//     4/10/2003 Initial checkin - a-dleeks
//
// ----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Function: CTaskScheduler(void)
//
// Description:  Constructor. Performs class instance initialization
//
// Parameters:
//    None.
//
// Returns:
//    None.
//-----------------------------------------------------------------------------
CTaskScheduler::CTaskScheduler(void)
{
	m_fInitialized = false;
	Init();
}

//-----------------------------------------------------------------------------
// Function: ~CTaskScheduler(void)
//
// Description:  Destructor. Performs class instance clean up.
//
// Parameters:
//    None.
//
// Returns:
//    None.
//-----------------------------------------------------------------------------
CTaskScheduler::~CTaskScheduler(void)
{
	Term();
}

//-----------------------------------------------------------------------------
// Function: Init(void)
//
// Description:  Performs common object initialization tasks.
//
// Parameters:
//    None.
//
// Returns:
//    None.
//-----------------------------------------------------------------------------
void CTaskScheduler::Init(void)
{
	HRESULT hr = S_OK;

	hr = m_spITS.CoCreateInstance(CLSID_CTaskScheduler);

	if (FAILED(hr))
	{
		m_fInitialized = false;
	}
	else
	{
		m_fInitialized = true;
	}
}

//-----------------------------------------------------------------------------
// Function: Term(void)
//
// Description:  Performs general cleanup tasks for the object.
//
// Parameters:
//    None.
//
// Returns:
//    None.
//-----------------------------------------------------------------------------
void CTaskScheduler::Term()
{
}

//-----------------------------------------------------------------------------
// Function: CreateTask(LPCWSTR pwszTaskName)
//
// Description:  Creates a scheduled task using the name provided.
//
// Parameters:
//    LPCWSTR pwszTaskName - The name of the scheduled task.
//
// Returns:
//    HRESULT - S_OK if successful;Otherwise a common failure code.
//-----------------------------------------------------------------------------
HRESULT CTaskScheduler::CreateTask(LPCWSTR pwszTaskName)
{
	HRESULT hr = S_OK;
	CComQIPtr<ITask> spITask;
	CComPtr<IPersistFile> spIPersistFile;

	if (NULL == pwszTaskName)
	{
		hr = E_INVALIDARG;
		wprintf(L"Error: Invalid argument");
		goto Error;
	}

	if (false == m_fInitialized)
	{
		Init();
	}

	if (false == m_fInitialized)
	{
		hr = E_FAIL;
		wprintf(L"Error: Failed to create the ITaskScheduler object.");
		goto Error;
	}

	/////////////////////////////////////////////////////////////////
	// Call ITaskScheduler::NewWorkItem to create new task.
	/////////////////////////////////////////////////////////////////

	hr = m_spITS->NewWorkItem(pwszTaskName,           // Name of task
							CLSID_CTask,            // Class identifier 
							IID_ITask,              // Interface identifier
							(IUnknown**)&spITask); // Address of task interface

	if (FAILED(hr))
	{
		fprintf(stderr, "Failed calling NewWorkItem, error = 0x%x\n",hr);
		goto Error;
	}


	/////////////////////////////////////////////////////////////////
	// Call IUnknown::QueryInterface to get a pointer to 
	// IPersistFile and IPersistFile::Save to save 
	// the new task to disk.
	/////////////////////////////////////////////////////////////////

	hr = spITask->QueryInterface(IID_IPersistFile,
								(void **)&spIPersistFile);

	if (FAILED(hr))
	{
		fprintf(stderr, "Failed calling QueryInterface, error = 0x%x\n",hr);
		goto Error;
	}

	hr = spIPersistFile->Save(NULL,
							TRUE);

	if (FAILED(hr))
	{
		fprintf(stderr, "Failed calling Save, error = 0x%x\n",hr);
		goto Error;
	}

Error:
	return hr;
}

//-----------------------------------------------------------------------------
// Function: SetApplicationName(LPCWSTR pwszTaskName, LPCWSTR pwszApplicationName)
//
// Description:  Finds the named scheduled task and sets the name of the 
//               application to be executed.
//
// Parameters:
//    LPCWSTR pcwszTaskName - The name of the scheduled task.
//    LPCWSTR pwszApplicationName - The name of the application to be executed.
//
// Returns:
//    HRESULT - S_OK if successful;Otherwise a common failure code.
//-----------------------------------------------------------------------------
HRESULT CTaskScheduler::SetApplicationName(LPCWSTR pcwszTaskName, LPCWSTR pwszApplicationName)
{
	HRESULT hr = S_OK;
	CComQIPtr<ITask> spITask;
	CComPtr<IPersistFile> spIPersistFile;

	if (NULL == pcwszTaskName || NULL == pwszApplicationName)
	{
		hr = E_INVALIDARG;
		wprintf(L"Error: Invalid argument");
		goto Error;
	}

	if (false == m_fInitialized)
	{
		Init();
	}

	if (false == m_fInitialized)
	{
		hr = E_FAIL;
		wprintf(L"Error: Failed to create the ITaskScheduler object.");
		goto Error;
	}

	///////////////////////////////////////////////////////////////////
	// Call ITaskScheduler::Activate to get the Task object.
	///////////////////////////////////////////////////////////////////

	hr = m_spITS->Activate(pcwszTaskName,
					IID_ITask,
					(IUnknown**) &spITask);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITaskScheduler::Activate: error = 0x%x\n",hr);
		goto Error;
	}

	///////////////////////////////////////////////////////////////////
	// Call ITask::SetComment to specify the account name
	// and the account password for Test Task.
	///////////////////////////////////////////////////////////////////

	hr = spITask->SetApplicationName(pwszApplicationName);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITask::SetApplicationName: error = 0x%x\n",hr);
		goto Error;
	}


	///////////////////////////////////////////////////////////////////
	// Call IPersistFile::Save to save the modified task to disk.
	///////////////////////////////////////////////////////////////////

	hr = spITask->QueryInterface(IID_IPersistFile,
							(void **)&spIPersistFile);

	hr = spIPersistFile->Save(NULL,
						TRUE);


Error:
	return hr;
}

//-----------------------------------------------------------------------------
// Function: SetMaxRunTime(LPCWSTR pwszTaskName, DWORD dwMaxRunTime)
//
// Description:  Sets the maximum allowable run time for the named task.
//
// Parameters:
//    LPCWSTR pcwszTaskName - The name of the scheduled task.
//    DWORD dwMaxRunTime - The maximum allowable runtime (in seconds).
//
// Returns:
//    HRESULT - S_OK if successful;Otherwise a common failure code.
//-----------------------------------------------------------------------------
HRESULT CTaskScheduler::SetMaxRunTime(LPCWSTR pcwszTaskName, DWORD dwMaxRunTime)
{
	HRESULT hr = S_OK;
	CComQIPtr<ITask> spITask;
	CComPtr<IPersistFile> spIPersistFile;

	if (NULL == pcwszTaskName)
	{
		hr = E_INVALIDARG;
		wprintf(L"Error: Invalid argument");
		goto Error;
	}

	if (false == m_fInitialized)
	{
		Init();
	}

	if (false == m_fInitialized)
	{
		hr = E_FAIL;
		wprintf(L"Error: Failed to create the ITaskScheduler object.");
		goto Error;
	}

	///////////////////////////////////////////////////////////////////
	// Call ITaskScheduler::Activate to get the Task object.
	///////////////////////////////////////////////////////////////////

	hr = m_spITS->Activate(pcwszTaskName,
						IID_ITask,
						(IUnknown**) &spITask);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITaskScheduler::Activate: error = 0x%x\n",hr);
		goto Error;
	}


	///////////////////////////////////////////////////////////////////
	// Call ITask::SetMaxRunTime to specify the maximum amount
	// of time the task will run.
	///////////////////////////////////////////////////////////////////

	hr = spITask->SetMaxRunTime(dwMaxRunTime);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITask::SetMaxRunTime: error = 0x%x\n",hr);
		goto Error;
	}

	///////////////////////////////////////////////////////////////////
	// Call IPersistFile::Save to save the modified task to disk.
	///////////////////////////////////////////////////////////////////

	hr = spITask->QueryInterface(IID_IPersistFile,
								(void **)&spIPersistFile);

	hr = spIPersistFile->Save(NULL,
							TRUE);

Error:
	return hr;
}

//-----------------------------------------------------------------------------
// Function: ClearTaskParameters(LPCWSTR pwszTaskName)
//
// Description: Clears the parameters passed to the application when it is
//              excuted for the named task.
//
// Parameters:
//    LPCWSTR pcwszTaskName - The name of the scheduled task.
//
// Returns:
//    HRESULT - S_OK if successful;Otherwise a common failure code.
//-----------------------------------------------------------------------------
HRESULT CTaskScheduler::ClearTaskParameters(LPCWSTR pcwszTaskName)
{
	HRESULT hr = S_OK;
	CComQIPtr<ITask> spITask;
	CComPtr<IPersistFile> spIPersistFile;

	if (NULL == pcwszTaskName)
	{
		hr = E_INVALIDARG;
		wprintf(L"Error: Invalid argument");
		goto Error;
	}

	if (false == m_fInitialized)
	{
		Init();
	}

	if (false == m_fInitialized)
	{
		hr = E_FAIL;
		wprintf(L"Error: Failed to create the ITaskScheduler object.");
		goto Error;
	}

	///////////////////////////////////////////////////////////////////
	// Call ITaskScheduler::Activate to get the Task object.
	///////////////////////////////////////////////////////////////////

	hr = m_spITS->Activate(pcwszTaskName,
						IID_ITask,
						(IUnknown**) &spITask);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITaskScheduler::Activate: error = 0x%x\n",hr);
		goto Error;
	}


	///////////////////////////////////////////////////////////////////
	// Call ITask::SetParameters to L"" to clear the parameters for
	// Test Task.
	///////////////////////////////////////////////////////////////////
	LPCWSTR pwszParameters = L"";

	hr = spITask->SetParameters(pwszParameters);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITask::SetParameters: error = 0x%x\n",hr);
		goto Error;
	}


	///////////////////////////////////////////////////////////////////
	// Call IPersistFile::Save to save the modified task to disk.
	///////////////////////////////////////////////////////////////////

	hr = spITask->QueryInterface(IID_IPersistFile,
								(void **)&spIPersistFile);

	hr = spIPersistFile->Save(NULL,
							TRUE);

Error:
	return hr;
}

//-----------------------------------------------------------------------------
// Function: SetTaskParameters(LPCWSTR pcwszTaskName, LPCWSTR pcwszParameters)
//
// Description: Sets the parameters passed to the application when it is 
//              executed for the named task.
//
// Parameters:
//    LPCWSTR pcwszTaskName - The name of the scheduled task.
//    LPCWSTR pcwszParameters - The parameters to be passed to the application.
//
// Returns:
//    HRESULT - S_OK if successful;Otherwise a common failure code.
//-----------------------------------------------------------------------------
HRESULT CTaskScheduler::SetTaskParameters(LPCWSTR pcwszTaskName, LPCWSTR pcwszParameters)
{
	HRESULT hr = S_OK;
	CComQIPtr<ITask> spITask;
	CComPtr<IPersistFile> spIPersistFile;

	if (NULL == pcwszTaskName)
	{
		hr = E_INVALIDARG;
		wprintf(L"Error: Invalid argument");
		goto Error;
	}

	if (false == m_fInitialized)
	{
		Init();
	}

	if (false == m_fInitialized)
	{
		hr = E_FAIL;
		wprintf(L"Error: Failed to create the ITaskScheduler object.");
		goto Error;
	}

	///////////////////////////////////////////////////////////////////
	// Call ITaskScheduler::Activate to get the Task object.
	///////////////////////////////////////////////////////////////////

	hr = m_spITS->Activate(pcwszTaskName,
						IID_ITask,
						(IUnknown**) &spITask);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITaskScheduler::Activate: error = 0x%x\n",hr);
		goto Error;
	}


	///////////////////////////////////////////////////////////////////
	// Call ITask::SetParameters to L"" to clear the parameters for
	// Test Task.
	///////////////////////////////////////////////////////////////////
	hr = spITask->SetParameters(pcwszParameters);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITask::SetParameters: error = 0x%x\n",hr);
		goto Error;
	}


	///////////////////////////////////////////////////////////////////
	// Call IPersistFile::Save to save the modified task to disk.
	///////////////////////////////////////////////////////////////////

	hr = spITask->QueryInterface(IID_IPersistFile,
								(void **)&spIPersistFile);

	hr = spIPersistFile->Save(NULL,
							TRUE);

Error:
	return hr;
}

//-----------------------------------------------------------------------------
// Function: SetTaskPriority(LPCWSTR pcwszTaskName, DWORD dwPriority)
//
// Description: Sets the priority of the named scheduled task.
//
// Parameters:
//    LPCWSTR pcwszTaskName - The name of the scheduled task.
//	  DWORD dwPriority - The new priority of the scheduled task.
//
// Returns:
//    HRESULT - S_OK if successful;Otherwise a common failure code.
//-----------------------------------------------------------------------------
HRESULT CTaskScheduler::SetTaskPriority(LPCWSTR pcwszTaskName, DWORD dwPriority)
{
	HRESULT hr = S_OK;
	CComQIPtr<ITask> spITask;
	CComPtr<IPersistFile> spIPersistFile;
  
	if (NULL == pcwszTaskName)
	{
		hr = E_INVALIDARG;
		wprintf(L"Error: Invalid argument");
		goto Error;
	}

	if (false == m_fInitialized)
	{
		Init();
	}

	if (false == m_fInitialized)
	{
		hr = E_FAIL;
		wprintf(L"Error: Failed to create the ITaskScheduler object.");
		goto Error;
	}

  ///////////////////////////////////////////////////////////////////
  // Call ITaskScheduler::Activate to get the Task object.
  ///////////////////////////////////////////////////////////////////

  hr = m_spITS->Activate(pcwszTaskName,
                      IID_ITask,
                     (IUnknown**)&spITask);
  
  if (FAILED(hr))
  {
    wprintf(L"Failed calling ITaskScheduler::Activate: error = 0x%x\n",hr);
	goto Error;
  }
  
  ///////////////////////////////////////////////////////////////////
  // Call ITask::SetPriority to specify the priority level of 
  // Test Task.
  ///////////////////////////////////////////////////////////////////
  hr = spITask->SetPriority(dwPriority);
  
  if (FAILED(hr))
  {
    wprintf(L"Failed calling ITask::SetPriority: error = 0x%x\n",hr);
	goto Error;
  }
  
  
  ///////////////////////////////////////////////////////////////////
  // Call IPersistFile::Save to save the modified task to disk.
  ///////////////////////////////////////////////////////////////////
  
  hr = spITask->QueryInterface(IID_IPersistFile,
                              (void **)&spIPersistFile);
  
  hr = spIPersistFile->Save(NULL,
                           TRUE);
  
Error:
  return hr;
}

//-----------------------------------------------------------------------------
// Function: SetTaskWorkingDirectory(LPCWSTR pcwszTaskName, 
//                                   LPCWSTR pcwszWorkingDirectory)
//
// Description: Sets the working directory for the applicaton to be executed for
//              the named task.
//
// Parameters:
//    LPCWSTR pcwszTaskName - The name of the scheduled task.
//    LPCWSTR pcwszWorkingDirectory - The new working directory of the application.
//
// Returns:
//    HRESULT - S_OK if successful;Otherwise a common failure code.
//-----------------------------------------------------------------------------
HRESULT CTaskScheduler::SetTaskWorkingDirectory(LPCWSTR pcwszTaskName, LPCWSTR pcwszWorkingDirectory)
{
	HRESULT hr = S_OK;
	CComQIPtr<ITask> spITask;
	CComPtr<IPersistFile> spIPersistFile;

	if (NULL == pcwszTaskName || NULL == pcwszWorkingDirectory)
	{
		hr = E_INVALIDARG;
		wprintf(L"Error: Invalid argument");
		goto Error;
	}

	if (false == m_fInitialized)
	{
		Init();
	}

	if (false == m_fInitialized)
	{
		hr = E_FAIL;
		wprintf(L"Error: Failed to create the ITaskScheduler object.");
		goto Error;
	}

	///////////////////////////////////////////////////////////////////
	// Call ITaskScheduler::Activate to get the Task object.
	///////////////////////////////////////////////////////////////////

	hr = m_spITS->Activate(pcwszTaskName,
						IID_ITask,
						(IUnknown**) &spITask);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITaskScheduler::Activate: error = 0x%x\n",hr);
		goto Error;
	}


	///////////////////////////////////////////////////////////////////
	// Call ITask::SetWorkingDirectory to specify the current 
	// working directory for Test Task.
	///////////////////////////////////////////////////////////////////
	hr = spITask->SetWorkingDirectory(pcwszWorkingDirectory);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITask::SetWorkingDirectory: error = 0x%x\n",hr);
		goto Error;
	}

	///////////////////////////////////////////////////////////////////
	// Call IPersistFile::Save to save the modified task to disk.
	///////////////////////////////////////////////////////////////////

	hr = spITask->QueryInterface(IID_IPersistFile,
								(void **)&spIPersistFile);

	hr = spIPersistFile->Save(NULL,
							TRUE);

Error:
	return hr;
}

//-----------------------------------------------------------------------------
// Function: SetTaskComment(LPCWSTR pcwszTaskName, LPCWSTR pcwszTaskComment)
//
// Description: Sets the comments (description) for the named task.
//
// Parameters:
//    LPCWSTR pcwszTaskName - The name of the scheduled task.
//    LPCWSTR pcwszTaskComment - The new comments for the named task.
//
// Returns:
//    HRESULT - S_OK if successful;Otherwise a common failure code.
//-----------------------------------------------------------------------------
HRESULT CTaskScheduler::SetTaskComment(LPCWSTR pcwszTaskName, LPCWSTR pcwszTaskComment)
{
	HRESULT hr = S_OK;
	CComQIPtr<ITask> spITask;
	CComPtr<IPersistFile> spIPersistFile;

	if (NULL == pcwszTaskName || NULL == pcwszTaskComment)
	{
		hr = E_INVALIDARG;
		wprintf(L"Error: Invalid argument");
		goto Error;
	}

	if (false == m_fInitialized)
	{
		Init();
	}

	if (false == m_fInitialized)
	{
		hr = E_FAIL;
		wprintf(L"Error: Failed to create the ITaskScheduler object.");
		goto Error;
	}

	///////////////////////////////////////////////////////////////////
	// Call ITaskScheduler::Activate to get the Task object.
	///////////////////////////////////////////////////////////////////

	hr = m_spITS->Activate(pcwszTaskName,
						IID_ITask,
						(IUnknown**) &spITask);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITaskScheduler::Activate: error = 0x%x\n",hr);
		goto Error;
	}


	///////////////////////////////////////////////////////////////////
	// Call ITask::SetComment to specify the account name
	// and the account password for Test Task.
	///////////////////////////////////////////////////////////////////
	hr = spITask->SetComment(pcwszTaskComment);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITask::SetComment: error = 0x%x\n",hr);
		goto Error;
	}


	///////////////////////////////////////////////////////////////////
	// Call IPersistFile::Save to save the modified task to disk.
	///////////////////////////////////////////////////////////////////

	hr = spITask->QueryInterface(IID_IPersistFile,
								(void **)&spIPersistFile);

	hr = spIPersistFile->Save(NULL,
							TRUE);

Error:
	return hr;
}

//-----------------------------------------------------------------------------
// Function: CreateTaskTrigger(LPCWSTR pcwszTaskName, 
//                             SYSTEMTIME &stTrigger, 
//                             TASK_SCHEDULER_FREQUENCY tsfFrequency, 
//                             WORD wInterval)
//
// Description: Creates the trigger for the named task.
//
// Parameters:
//    LPCWSTR pcwszTaskName - The name of the scheduled task.
//    SYSTEMTIME stTrigger - The time at which the task is to be triggered.
//    TASK_SCHEDULER_FREQUENCY - The frequency at which the task is to be triggered.
//
// Returns:
//    HRESULT - S_OK if successful;Otherwise a common failure code.
//-----------------------------------------------------------------------------
HRESULT CTaskScheduler::CreateTaskTrigger(LPCWSTR pcwszTaskName, SYSTEMTIME &stTrigger, TASK_SCHEDULER_FREQUENCY tsfFrequency, WORD wInterval)
{
	HRESULT hr = S_OK;
	CComQIPtr<ITask> spITask;
	CComPtr<ITaskTrigger> spITaskTrigger; 
	CComPtr<IPersistFile> spIPersistFile;
  
	if (NULL == pcwszTaskName)
	{
		hr = E_INVALIDARG;
		wprintf(L"Error: Invalid argument");
		goto Error;
	}

	if (TASK_SCHEDULER_MAX < tsfFrequency)
	{
		hr = E_INVALIDARG;
		wprintf(L"Error: Invalid argument");
		goto Error;
	}

	if (false == m_fInitialized)
	{
		Init();
	}

	if (false == m_fInitialized)
	{
		hr = E_FAIL;
		wprintf(L"Error: Failed to create the ITaskScheduler object.");
		goto Error;
	}

	///////////////////////////////////////////////////////////////////
	// Call ITaskScheduler::Activate to get the Task object.
	///////////////////////////////////////////////////////////////////

	hr = m_spITS->Activate(pcwszTaskName,
						IID_ITask,
						(IUnknown**) &spITask);
	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITaskScheduler::Activate: error = 0x%x\n",hr);
		goto Error;
	}

	///////////////////////////////////////////////////////////////////
	// Call ITask::CreateTrigger to create new trigger.
	///////////////////////////////////////////////////////////////////
	WORD piNewTrigger;

	hr = spITask->CreateTrigger(&piNewTrigger,
								&spITaskTrigger);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITask::CreatTrigger: error = 0x%x\n",hr);
		goto Error;
	}


	//////////////////////////////////////////////////////
	// Define TASK_TRIGGER structure. Note that wBeginDay,
	// wBeginMonth, and wBeginYear must be set to a valid 
	// day, month, and year respectively.
	//////////////////////////////////////////////////////

	TASK_TRIGGER pTrigger;

	ZeroMemory(&pTrigger, sizeof (TASK_TRIGGER));

	// Add code to set trigger structure?
	pTrigger.wBeginDay = stTrigger.wDay;                // Required
	pTrigger.wBeginMonth = stTrigger.wMonth;            // Required
	pTrigger.wBeginYear = stTrigger.wYear;              // Required
	pTrigger.cbTriggerSize = sizeof (TASK_TRIGGER); 
	pTrigger.wStartHour = stTrigger.wHour;
	pTrigger.wStartMinute = stTrigger.wMinute;

	switch(tsfFrequency)
	{
	case TASK_SCHEDULER_ONCE:
		pTrigger.TriggerType = TASK_TIME_TRIGGER_ONCE;
		break;
	case TASK_SCHEDULER_DAILY:
		pTrigger.TriggerType = TASK_TIME_TRIGGER_DAILY;
		pTrigger.Type.Daily.DaysInterval = wInterval;
		break;
	case TASK_SCHEDULER_WEEKLY:
		pTrigger.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
		pTrigger.Type.Weekly.WeeksInterval = wInterval;
		break;
	default:
		pTrigger.TriggerType = TASK_TIME_TRIGGER_ONCE;
		break;
	}

	///////////////////////////////////////////////////////////////////
	// Call ITaskTrigger::SetTrigger to set trigger criteria.
	///////////////////////////////////////////////////////////////////

	hr = spITaskTrigger->SetTrigger(&pTrigger);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITaskTrigger::SetTrigger: error = 0x%x\n",hr);
		goto Error;
	}


	///////////////////////////////////////////////////////////////////
	// Call IPersistFile::Save to save trigger to disk.
	///////////////////////////////////////////////////////////////////

	hr = spITask->QueryInterface(IID_IPersistFile,
								(void **)&spIPersistFile);
	hr = spIPersistFile->Save(NULL,
							TRUE);

Error:
	return hr;
}

//-----------------------------------------------------------------------------
// Function: SetAccountInformation(LPCWSTR pcwszTaskName, 
//                                 LPCWSTR pcwszAccount, 
//                                 LPCWSTR pcwszPassword)
//
// Description:  Sets the user credentials for the named task.
//
// Parameters:
//    LPCWSTR pcwszTaskName - The name of the scheduled task.
//    LPCWSTR pcwszAccount - The user account name.
//    LPCWSTR pcwszPassword - The user account password.
//
// Returns:
//    HRESULT - S_OK if successful;Otherwise a common failure code.
//-----------------------------------------------------------------------------
HRESULT CTaskScheduler::SetAccountInformation(LPCWSTR pcwszTaskName, LPCWSTR pcwszAccount, LPCWSTR pcwszPassword)
{
	HRESULT hr = S_OK;
	CComQIPtr<ITask> spITask;
	CComPtr<IPersistFile> spIPersistFile;

	if (NULL == pcwszTaskName || NULL == pcwszAccount || NULL == pcwszPassword)
	{
		hr = E_INVALIDARG;
		wprintf(L"Error: Invalid argument");
		goto Error;
	}

	if (false == m_fInitialized)
	{
		Init();
	}

	if (false == m_fInitialized)
	{
		hr = E_FAIL;
		wprintf(L"Error: Failed to create the ITaskScheduler object.");
		goto Error;
	}

	///////////////////////////////////////////////////////////////////
	// Call ITaskScheduler::Activate to get the Task object.
	///////////////////////////////////////////////////////////////////

	hr = m_spITS->Activate(pcwszTaskName,
						IID_ITask,
						(IUnknown**) &spITask);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITaskScheduler::Activate: error = 0x%x\n",hr);
		goto Error;
	}


	///////////////////////////////////////////////////////////////////
	// Call ITask::GetAccountInformation to specify the account name
	// and the account password for Test Task.
	///////////////////////////////////////////////////////////////////
	hr = spITask->SetAccountInformation(pcwszAccount, pcwszPassword);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITask::SetAccountInformation: error = 0x%x\n",hr);
		goto Error;
	}

	hr = spITask->SetFlags(TASK_FLAG_DELETE_WHEN_DONE);

	if (FAILED(hr))
	{
		wprintf(L"Failed calling ITask::SetFlags: error = 0x%x\n",hr);
		goto Error;
	}


	///////////////////////////////////////////////////////////////////
	// Call IPersistFile::Save to save the modified task to disk.
	///////////////////////////////////////////////////////////////////

	hr = spITask->QueryInterface(IID_IPersistFile,
								(void **)&spIPersistFile);

	hr = spIPersistFile->Save(NULL,
							TRUE);

Error:
	return hr;
}

//-----------------------------------------------------------------------------
// Function: DetermineFrequencyConstant(wstring strFrequency)
//
// Description: Determines the task frequency constant from the command line
//              argument.
//
// Parameters:
//    wstring strFrequency - The text representation of the task frequency.
//
// Returns:
//    TASK_SCHEDULER_FREQUENCY - TAK_SCHEDULER_ONCE is returned on error;Otherwise
//                               another member of the enumeration is returned.
//-----------------------------------------------------------------------------
CTaskScheduler::TASK_SCHEDULER_FREQUENCY CTaskScheduler::DetermineFrequencyConstant(wstring strFrequency)
{
	if (true == strFrequency.empty())
	{
		return TASK_SCHEDULER_ONCE;
	}

	if (0 == wcsicmp(strFrequency.c_str(), L"DAY"))
	{
		return TASK_SCHEDULER_DAILY;
	}

	if (0 == wcsicmp(strFrequency.c_str(), L"WEEK"))
	{
		return TASK_SCHEDULER_WEEKLY;
	}

	if (0 == wcsicmp(strFrequency.c_str(), L"MONTH"))
	{
		return TASK_SCHEDULER_MONTHLY;
	}

	return TASK_SCHEDULER_ONCE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\GAST\DBInfoClass.cs ===
using System;
using System.Data;
using System.Data.SqlClient;

namespace GAST
{
	/// <summary>
	/// Summary description for DBInfoClass.
	/// </summary>
	public class DBInfo
	{
		public DBInfo(SqlConnection con, string strDatabase) 
		{	
			Server = con.DataSource;
			Name = strDatabase;
			DataSize = 0;
			// instantiate a command reference pointing at sp_helpdb sproc
			try 
			{
                string cmdString;
				SqlCommand cmd = new SqlCommand ("sp_helpdb", con);
				cmd.CommandType = CommandType.StoredProcedure;
				SqlParameter sprm = cmd.Parameters.Add("@dbname", SqlDbType.NVarChar, 128);
				sprm.Value = strDatabase;
				SqlDataReader drd = cmd.ExecuteReader();
				if (drd.HasRows)
				{
					while (drd.Read())
					{
						// record the first sp_helpdb value as the DB name
						Name = drd.GetString(0).ToString();
						// get the fifth sp_helpdb value to get CreateDate
						CreateDate = drd.GetString(4);
						// get the second sp_helpdb value as the DB size
						string strValue = drd.GetString(1).TrimStart();
						// split by space to remove MB suffix
						char[] Delim = " ".ToCharArray();
						string[] arrValues = strValue.Split(Delim);
						// convert to decimal to get actual size
						Size = System.Convert.ToDecimal(arrValues[0]);
                        Status = drd.GetString(5);
					}
					drd.Close();
				} 
				else 
				{
					drd.Close();
				}
                if (con.ServerVersion.Substring(0, 2) == "09")
                {
                    cmdString = "SELECT state_desc, user_access_desc, is_in_standby FROM sys.databases WHERE name = '" + strDatabase + "'";
                }
                else
                {
                    cmdString = "SELECT CONVERT(sysname,DatabasePropertyEx('" + strDatabase + "','Status'))";
                    cmdString += ", CONVERT(sysname,DatabasePropertyEx('" + strDatabase + "','UserAccess'))";
                    cmdString += ", CONVERT(sysname,DatabasePropertyEx('" + strDatabase + "','Recovery'))";
                }
                cmd.CommandText = cmdString;
				cmd.CommandType = CommandType.Text;
				drd = cmd.ExecuteReader();
				if (drd.HasRows)
				{
					while (drd.Read())
					{
						Status = drd.GetString(0);
                        Access = drd.GetString(1);
                        if (con.ServerVersion.Substring(0, 2) == "09")
                        {
                            if ((Status == "ONLINE") & (drd.GetBoolean(2) == true))
                            {
                                Status = "STANDBY";
                            }
                        }
					}
				}
				drd.Close();
			}
			catch (SqlException e)
			{
				Console.WriteLine("Error: " + e.Number.ToString());
				Console.WriteLine(e.Message);
				if ((e.Number == 515) & (e.Procedure == "sp_helpdb")) 
				{
					con.ChangeDatabase(strDatabase);
					SqlCommand setOwner = new SqlCommand("sp_changedbowner", con);
					setOwner.CommandType = CommandType.StoredProcedure;
					SqlParameter retprm = setOwner.Parameters.Add("@RETURN_VALUE", SqlDbType.Int);
					retprm.Direction = ParameterDirection.ReturnValue;
					SqlParameter prm1 = setOwner.Parameters.Add("@loginame", SqlDbType.Char);
					prm1.Value = "sa";
					SqlParameter prm2 = setOwner.Parameters.Add("@map", SqlDbType.Char);
					prm2.Value = "true";
					Console.WriteLine ("Invalid owner of database " + strDatabase);
					Console.WriteLine ("Setting owner to 'sa'");
					setOwner.ExecuteNonQuery();
					Status = "InvalidOwner";
					Name = strDatabase;
				}
			}
		}
		public void getUsage(SqlConnection con)
		{
			// we populate the usage properties only if this method is called.
			if ((Status == "ONLINE") || (Status == "STANDBY"))
			{
				con.ChangeDatabase(Name);
				// execute DBCC SHOWFILESTATS to get data usage
				SqlCommand cmd = new SqlCommand ("DBCC SHOWFILESTATS", con);
				SqlDataReader drd = cmd.ExecuteReader();
				long intExtents = 0;
				long intExtentsUsed = 0;
				// add the extent results for each file to the total
				while (drd.Read())
				{
					try 
					{
						intExtents += drd.GetInt64(2);
						intExtentsUsed += drd.GetInt64(3);
					}
					catch (InvalidCastException) 
					{
						intExtents += drd.GetInt32(2);
						intExtentsUsed += drd.GetInt32(3);
					}
				}
				drd.Close();
				// convert from extents to MB
				DataSize = Convert.ToDecimal(intExtents) / 16;
				DataUsed = Convert.ToDecimal(intExtentsUsed) / 16;
				// get percentage
				DataPercentUsed = Convert.ToDecimal(intExtentsUsed)/Convert.ToDecimal(intExtents) * 100;
				DataPercentUsed = Convert.ToDecimal(DataPercentUsed.ToString("F1"));
				// now that we have done the % calculation, round off to nearest tenth of a MB
				DataSize = Convert.ToDecimal(DataSize.ToString("F1"));
				DataUsed = Convert.ToDecimal(DataUsed.ToString("F1"));
				// use DBCC SQLPERF to get log usage
				cmd.CommandText = "DBCC SQLPERF(LOGSPACE)";
				drd = cmd.ExecuteReader();
				while (drd.Read())
				{
					if (drd.GetString(0) == Name) 
					{
						LogSize = Convert.ToDecimal(drd.GetValue(1).ToString());
						LogSize = Convert.ToDecimal(LogSize.ToString("F1")); // round off to nearest tenth of a MB
						LogPercentUsed = Convert.ToDecimal(drd.GetValue(2).ToString());
						LogPercentUsed = Convert.ToDecimal(LogPercentUsed.ToString("F1"));
						LogUsed = LogSize * LogPercentUsed / 100;
						LogUsed = Convert.ToDecimal(LogUsed.ToString("F1"));
					}
				}
				drd.Close();
			}
			else 
			{
				Console.WriteLine("Could not get usage info for DB " + Name + " due to status of " + Status + ".");
			}
		}
		public static string addString(string strOriginal, string strToBeAdded)
		{
			string strReturn = "";
			if (strOriginal.Length == 0)
			{
				strReturn = strToBeAdded;
			}
			else
			{
                strReturn += "\\";
				strReturn += strToBeAdded;
			}
			return strReturn;
		}

		public string Server;
		public string Name;
		public string CreateDate;
		public int intStatus;
		public string Status;
        public string Access;
		public decimal Size;
		public decimal DataSize;
		public decimal DataUsed;
		public decimal DataPercentUsed;
		public decimal LogSize;
		public decimal LogUsed;
		public decimal LogPercentUsed;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\SQLAdmin\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_sqladmin_none_12.4.56.0_none_a1396ed99f8c0dd6
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_sqladmin_no-public-key_12.4.56.0_x-ww_436dca44
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=sqladmin
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_sqladmin_no-public-key_12.4.56.0_x-ww_436dca44
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_sqladmin_no-public-key_12.4.56.0_x-ww_436dca44.manifest
XP_MANIFEST_PATH=manifests\msil_sqladmin_no-public-key_12.4.56.0_x-ww_436dca44.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_sqladmin_no-public-key_12.4.56.0_x-ww_436dca44.cat
XP_CATALOG_PATH=manifests\msil_sqladmin_no-public-key_12.4.56.0_x-ww_436dca44.cat
XP_PAYLOAD_PATH=msil_sqladmin_no-public-key_12.4.56.0_x-ww_436dca44
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=sqladmin,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\SQLAdmin\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_sqladmin_none_12.4.56.0_none_a1396ed99f8c0dd6
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_sqladmin_no-public-key_12.4.56.0_x-ww_436dca44
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=sqladmin
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_sqladmin_no-public-key_12.4.56.0_x-ww_436dca44
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_sqladmin_no-public-key_12.4.56.0_x-ww_436dca44.manifest
XP_MANIFEST_PATH=manifests\msil_sqladmin_no-public-key_12.4.56.0_x-ww_436dca44.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_sqladmin_no-public-key_12.4.56.0_x-ww_436dca44.cat
XP_CATALOG_PATH=manifests\msil_sqladmin_no-public-key_12.4.56.0_x-ww_436dca44.cat
XP_PAYLOAD_PATH=msil_sqladmin_no-public-key_12.4.56.0_x-ww_436dca44
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=sqladmin,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\SQLAdmin\SQLLib.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Windows.Forms;
using Microsoft.SqlServer;
using Microsoft.SqlServer.Management;
using Microsoft.SqlServer.Management.Common;
using Microsoft.SqlServer.Management.Smo;
using System.Text;

namespace SQLAdmin
{
    /// <summary>
    /// Library of functions necessary for typical SQL Server administrative tasks
    /// </summary>
    internal class SQLLib
    {
        // NOTE: constructor not written because this is a mere function library, rather than a class proper

        internal static string addLogShippingPrimary(SqlConnection con, string prisrv, string dbname, string monsrv, string filepath)
        {
            string retval = string.Empty;
            SqlCommand pri = new SqlCommand();
            pri.Connection = con;
            // add the log shipping primary
            pri.CommandText = "master.dbo.sp_add_log_shipping_primary_database";
            pri.CommandType = CommandType.StoredProcedure;
            SqlParameter ar = pri.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            ar.Direction = ParameterDirection.ReturnValue;
            SqlParameter a1 = pri.Parameters.Add("@database", SqlDbType.NVarChar, 128);
            a1.Value = dbname;
            SqlParameter a2 = pri.Parameters.Add("@backup_directory", SqlDbType.NVarChar, 500);
            a2.Value = string.Format("{0}{1}_local", filepath, dbname);
            SqlParameter a3 = pri.Parameters.Add("@backup_share", SqlDbType.NVarChar, 500);
            a3.Value = string.Format("\\\\{0}\\{1}", prisrv, dbname);
            SqlParameter a4 = pri.Parameters.Add("@backup_job_name", SqlDbType.NVarChar, 128);
            a4.Value = string.Format("LSBackup_{0}", dbname);
            SqlParameter a5 = pri.Parameters.Add("@backup_retention_period", SqlDbType.Int);
            a5.Value = 2880;
            SqlParameter a6 = pri.Parameters.Add("@monitor_server", SqlDbType.NVarChar, 128);
            a6.Value = monsrv;
            SqlParameter a7 = pri.Parameters.Add("@monitor_server_security_mode", SqlDbType.Bit);
            a7.Value = 1;
            SqlParameter a8 = pri.Parameters.Add("@backup_threshold", SqlDbType.Int);
            a8.Value = 60;
            SqlParameter a9 = pri.Parameters.Add("@threshold_alert_enabled", SqlDbType.Bit);
            a9.Value = 1;
            SqlParameter a10 = pri.Parameters.Add("@history_retention_period", SqlDbType.Int);
            a10.Value = 5760;
            SqlParameter a11 = pri.Parameters.Add("@backup_job_id", SqlDbType.NVarChar, 128);
            a11.Direction = ParameterDirection.Output;
            SqlParameter a12 = pri.Parameters.Add("@overwrite", SqlDbType.Bit);
            a12.Value = 1;
            SqlParameter a13 = pri.Parameters.Add("@ignoreremotemonitor", SqlDbType.Bit);
            a13.Value = 1;
            if (SQLLib.executeStoredProc(pri, true))
            {
                if (ar.Value.ToString() == "0")
                {
                    // cull the job ID from the stored procedure run
                    retval = a11.Value.ToString();
                }
            }
            return retval;
        }

        internal static bool addLogShippingPrimarySecondary(SqlConnection con, string prisrv, string dbname, string secsrv)
        {
            bool success = false;
            SqlCommand pri = new SqlCommand();
            pri.Connection = con;
            // add the log shipping secondary to the primary server
            pri.CommandText = "master.dbo.sp_add_log_shipping_primary_secondary";
            pri.CommandType = CommandType.StoredProcedure;
            SqlParameter ar = pri.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            ar.Direction = ParameterDirection.ReturnValue;
            SqlParameter a1 = pri.Parameters.Add("@primary_database", SqlDbType.NVarChar, 128);
            a1.Value = dbname;
            SqlParameter a2 = pri.Parameters.Add("@secondary_server", SqlDbType.NVarChar, 128);
            a2.Value = secsrv;
            SqlParameter a3 = pri.Parameters.Add("@secondary_database", SqlDbType.NVarChar, 128);
            a3.Value = dbname;
            SqlParameter a4 = pri.Parameters.Add("@overwrite", SqlDbType.Bit);
            a4.Value = 1;
            if (SQLLib.executeStoredProc(pri, true))
            {
                if (ar.Value.ToString() == "0")
                {
                    success = true;
                }
            }
            return success;
        }

        internal static int addLogShippingSchedule(SqlConnection con, string scheduletype, string srvname, string dbname)
        {
            int retval = -1;
            SqlCommand cmd = new SqlCommand();
            cmd.Connection = con;
            cmd.CommandText = "msdb.dbo.sp_add_schedule";
            cmd.CommandType = CommandType.StoredProcedure;
            SqlParameter pr = cmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            pr.Direction = ParameterDirection.ReturnValue;
            SqlParameter p1 = cmd.Parameters.Add("@schedule_name", SqlDbType.NVarChar, 128);
            p1.Value = string.Format("{0}Schedule_{1}_{2}", scheduletype, srvname, dbname);
            SqlParameter p2 = cmd.Parameters.Add("@freq_type", SqlDbType.Int);
            p2.Value = 4;
            SqlParameter p3 = cmd.Parameters.Add("@freq_interval", SqlDbType.Int);
            p3.Value = 1;
            SqlParameter p4 = cmd.Parameters.Add("@freq_subday_type", SqlDbType.Int);
            p4.Value = 4;
            SqlParameter p5 = cmd.Parameters.Add("@freq_subday_interval", SqlDbType.Int);
            p5.Value = 5;
            SqlParameter p6 = cmd.Parameters.Add("@schedule_id", SqlDbType.Int);
            p6.Direction = ParameterDirection.Output;
            if (executeStoredProc(cmd, true))
            {
                retval = Convert.ToInt32(p6.Value);
            }
            return retval;
        }

        internal static bool addLogShippingSecondaryDatabase(SqlConnection con, string prisrv, string dbname)
        {
            bool success = false;
            SqlCommand sec = new SqlCommand();
            sec.Connection = con;
            // add the log shipping secondary to the primary server
            sec.CommandText = "master.dbo.sp_add_log_shipping_secondary_database";
            sec.CommandType = CommandType.StoredProcedure;
            SqlParameter ar = sec.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            ar.Direction = ParameterDirection.ReturnValue;
            SqlParameter a0 = sec.Parameters.Add("@secondary_database", SqlDbType.NVarChar, 128);
            a0.Value = dbname;
            SqlParameter a1 = sec.Parameters.Add("@primary_server", SqlDbType.NVarChar, 128);
            a1.Value = prisrv;
            SqlParameter a2 = sec.Parameters.Add("@primary_database", SqlDbType.NVarChar, 128);
            a2.Value = dbname;
            SqlParameter a3 = sec.Parameters.Add("@restore_mode", SqlDbType.Bit);
            a3.Value = 1;
            SqlParameter a4 = sec.Parameters.Add("@disconnect_users", SqlDbType.Bit);
            a4.Value = 1;
            SqlParameter a5 = sec.Parameters.Add("@restore_threshold", SqlDbType.Int);
            a5.Value = 60;
            SqlParameter a6 = sec.Parameters.Add("@threshold_alert_enabled", SqlDbType.Bit);
            a6.Value = 1;
            SqlParameter a7 = sec.Parameters.Add("@history_retention_period", SqlDbType.Bit);
            a7.Value = 5760;
            SqlParameter a8 = sec.Parameters.Add("@overwrite", SqlDbType.Bit);
            a8.Value = 1;
            if (SQLLib.executeStoredProc(sec, true))
            {
                if (ar.Value.ToString() == "0")
                {
                    success = true;
                }
            }
            return success;
        }

        internal static string[] addLogShippingSecondaryPrimary(SqlConnection con, string prisrv, string dbname, string secsrv)
        {
            string[] retval = new string[2];
            SqlCommand sec = new SqlCommand();
            sec.Connection = con;
            // add the log shipping primary
            sec.CommandText = "master.dbo.sp_add_log_shipping_secondary_primary";
            sec.CommandType = CommandType.StoredProcedure;
            SqlParameter ar = sec.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            ar.Direction = ParameterDirection.ReturnValue;
            SqlParameter a1 = sec.Parameters.Add("@primary_server", SqlDbType.NVarChar, 128);
            a1.Value = prisrv;
            SqlParameter a2 = sec.Parameters.Add("@primary_database", SqlDbType.NVarChar, 128);
            a2.Value = dbname;
            SqlParameter a3 = sec.Parameters.Add("@backup_source_directory", SqlDbType.NVarChar, 500);
            a3.Value = string.Format("\\\\{0}\\{1}", prisrv, dbname);
            SqlParameter a4 = sec.Parameters.Add("@backup_destination_directory", SqlDbType.NVarChar, 500);
            a4.Value = string.Format("E:\\MSSQL\\TRAN\\{0}", dbname);
            SqlParameter a5 = sec.Parameters.Add("@copy_job_name", SqlDbType.NVarChar, 128);
            a5.Value = string.Format("LSCopy_{0}_{1}",prisrv , dbname);
            SqlParameter a6 = sec.Parameters.Add("@restore_job_name", SqlDbType.NVarChar, 128);
            a6.Value = string.Format("LSRestore_{0}_{1}", prisrv, dbname);
            SqlParameter a7 = sec.Parameters.Add("@file_retention_period", SqlDbType.Int);
            a7.Value = 2880;
            SqlParameter a8 = sec.Parameters.Add("@monitor_server", SqlDbType.NVarChar, 128);
            a8.Value = secsrv;
            SqlParameter a9 = sec.Parameters.Add("@monitor_server_security_mode", SqlDbType.Bit);
            a9.Value = 1;
            SqlParameter a10 = sec.Parameters.Add("@overwrite", SqlDbType.Bit);
            a10.Value = 1;
            SqlParameter a11 = sec.Parameters.Add("@copy_job_id", SqlDbType.NVarChar, 128);
            a11.Direction = ParameterDirection.Output;
            SqlParameter a12 = sec.Parameters.Add("@restore_job_id", SqlDbType.NVarChar, 128);
            a12.Direction = ParameterDirection.Output;
            if (SQLLib.executeStoredProc(sec, true))
            {
                if (ar.Value.ToString() == "0")
                {
                    // get the job IDs from the stored procedure run
                    retval[0] = a11.Value.ToString();
                    retval[1] = a12.Value.ToString();
                }
            }
            return retval;
        }

        private static void addPublication(string pubSrv, string pubDB, string pubName)
        {
            SqlConnection pubcon = SQLLib.connectToSQL(pubSrv, pubDB);
            SqlCommand pubcmd = new SqlCommand();
            pubcmd.Connection = pubcon;
            SQLAdmin.sendOut("Adding publication '{0}' to database {1}.", pubName, pubDB);
            pubcmd.CommandText = "sp_addpublication";
            pubcmd.CommandType = CommandType.StoredProcedure;
            SqlParameter pubprm1 = pubcmd.Parameters.Add("@publication", SqlDbType.NVarChar, 128);
            pubprm1.Value = pubName;
            SqlParameter pubprm2 = pubcmd.Parameters.Add("@description", SqlDbType.NVarChar, 255);
            pubprm2.Value = "Transactional publication of database ''" + pubDB + "'' from Publisher ''" + pubSrv + "''.";
            SqlParameter pubprm3 = pubcmd.Parameters.Add("@sync_method", SqlDbType.NVarChar, 13);
            pubprm3.Value = "concurrent";
            SqlParameter pubprm5 = pubcmd.Parameters.Add("@status", SqlDbType.NVarChar, 8);
            pubprm5.Value = "active";
            SqlParameter pubprm6 = pubcmd.Parameters.Add("@independent_agent", SqlDbType.NVarChar, 5);
            pubprm6.Value = "true";
            SqlDataReader pubrdr = SQLLib.getReaderFromSP(pubcmd);
            if (pubrdr == null)
            {
                SQLAdmin.sendOut("Failed to add publication.");
            }
            else
            {
                SQLLib.disposeReader(pubrdr);
            }
            pubcmd.Parameters.Clear();
        }

        internal static bool addStepToJob(SqlConnection con, string jobID, string stepName, string stepCommand)
        {
            bool success = addStepToJob(con, jobID, stepName, stepCommand, "TSQL", "master", false);
            return success;
        }

        internal static bool addStepToJob(SqlConnection con, string jobID, string stepName, string stepCommand, bool isFinal)
        {
            bool success = addStepToJob(con, jobID, stepName, stepCommand, "TSQL", "master", isFinal);
            return success;
        }

        internal static bool addStepToJob(SqlConnection con, string jobID, string stepName, string stepCommand, string subsystem)
        {
            bool success = addStepToJob(con, jobID, stepName, stepCommand, subsystem, "master", false);
            return success;
        }

        internal static bool addStepToJob(SqlConnection con, string jobID, string stepName, string stepCommand, string subsystem, string database, bool isFinal)
        {
            SQLAdmin.sendOut("Adding step '{0}' to job.", stepName);
            bool success = false;
            string servername = string.Empty;
            SqlCommand sqlcmd = new SqlCommand();
            sqlcmd.Connection = con;
            sqlcmd.CommandText = "msdb.dbo.sp_add_jobstep";
            sqlcmd.CommandType = CommandType.StoredProcedure;
            SqlParameter retval = sqlcmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            retval.Direction = ParameterDirection.ReturnValue;
            SqlParameter jobIDPrm = sqlcmd.Parameters.Add("@job_id", SqlDbType.NVarChar, 128);
            jobIDPrm.Value = jobID;
            SqlParameter stepNamePrm = sqlcmd.Parameters.Add("@step_name", SqlDbType.NVarChar, 128);
            stepNamePrm.Value = stepName;
            SqlParameter subSystemPrm= sqlcmd.Parameters.Add("@subsystem", SqlDbType.NVarChar, 128);
            subSystemPrm.Value = subsystem;
            SqlParameter stepCmdPrm = sqlcmd.Parameters.Add("@command", SqlDbType.NVarChar, 20000);
            stepCmdPrm.Value = stepCommand;
            if (database != string.Empty)
            {
                SqlParameter dbName = sqlcmd.Parameters.Add("@database_name", SqlDbType.NVarChar, 128);
                dbName.Value = database;
            }
            if (subsystem == "ANALYSISCOMMAND")
            {
                // if ANALYSISCOMMAND is the subsystem, we need an @server parameter.
                // populate it using @@SERVERNAME to get the value from the connection.
                SqlDataReader rdr = getReaderFromSql(con, "SELECT @@SERVERNAME");
                if (verifyReader(rdr))
                {
                    SqlParameter srvPrm = sqlcmd.Parameters.Add("@server", SqlDbType.NVarChar, 128);
                    srvPrm.Value = getStringFromReader(rdr);
                }
                disposeReader(rdr);
            }
            if (!isFinal)
            {
                SqlParameter stepNext = sqlcmd.Parameters.Add("@on_success_action", SqlDbType.TinyInt);
                stepNext.Value = 3;
            }
            success = executeStoredProc(sqlcmd, false);
            return success;
        }

        internal static string assembleBackupFilename(string inputpath, string servername, string dbname)
        {
            string returnval = string.Empty;
            string sharepath = string.Empty;
            // if the path is local, get a path we can "see" from where we are now via share
            if (inputpath.IndexOf(':') != -1)
            {
                sharepath = getShareFromLocal(servername, inputpath);
            }
            // does the input path have a trailing backslash?
            if (inputpath.Substring(inputpath.Length - 1) == "\\")
            {
                // does the path exist as a folder?  If not, try to create it.
                if (verifyFolder(sharepath))
                {
                    // assemble the full path using the inputpath and database name.
                    returnval = string.Format("{0}{1}.bak", inputpath, dbname);
                }
            }
            else
            {
                // does the path represent an existing folder?
                if (Directory.Exists(sharepath))
                {
                    // assemble the full path using the inputpath and database name
                    // and insert the backslash since it doesn't exist in the input
                    returnval = string.Format("{0}\\{1}.bak", inputpath, dbname);
                }
                else
                {
                    // does the path point to an existing file?
                    if (File.Exists(sharepath))
                    {
                        // The input is all we need.
                        returnval = inputpath;
                    }
                    else
                    {
                        // does the path have a file extension?
                    }
                }
            }
            return returnval;
        }

        internal static bool attachJobSchedule(SqlConnection con, string jobID, int schID)
        {
            bool success = false;
            SqlCommand cmd = new SqlCommand();
            cmd.Connection = con;
            cmd.CommandText = "msdb.dbo.sp_attach_schedule";
            cmd.CommandType = CommandType.StoredProcedure;
            SqlParameter pr = cmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            pr.Direction = ParameterDirection.ReturnValue;
            SqlParameter p1 = cmd.Parameters.Add("@job_id", SqlDbType.NVarChar, 128);
            p1.Value = jobID;
            SqlParameter p2 = cmd.Parameters.Add("@schedule_id", SqlDbType.Int);
            p2.Value = schID;
            success = executeStoredProc(cmd, true);
            return success;
        }

        internal static bool backupCopyRestoreDatabase(SqlConnection srccon, SqlConnection destcon, string sourcedb, string destdb, string[] files, string backmodifiers, string restmodifiers, bool useLitespeed)
        {
            bool success = false;
            DBInfo dbinf = new DBInfo(destdb, destcon);
            string folder = files[0];
            if (dbinf.DBExists)
            {
                if (dbinf.IsSystem)
                {
                    SQLAdmin.sendOut("BCR not supported with system database as the destination.");
                    return false;
                }
            }
            else
            {
                SQLAdmin.sendOut("Database does not yet exist at the destination.");
            }
            if (useLitespeed)
            {
                files[0] = String.Format("{0}\\{1}.ls.bak", files[0], sourcedb);
            }
            else
            {
                files[0] = String.Format("{0}\\{1}.bak", files[0], sourcedb);
            }
            if (SQLLib.backupDatabase(srccon, sourcedb, files, backmodifiers, useLitespeed))
            {
                string share = getShareNameFromFilePath(files[0]);
                if (useLitespeed)
                {
                    files[0] = String.Format("\\\\{0}\\{1}\\{2}.ls.bak", srccon.DataSource, share, sourcedb);
                }
                else
                {
                    files[0] = String.Format("\\\\{0}\\{1}\\{2}.bak", srccon.DataSource, share, sourcedb);
                }
                if (SQLLib.restoreDatabase(destcon, destdb, files, restmodifiers, useLitespeed))
                    success = true;
            }
            files[0] = folder;
            return success;
        }

        internal static bool backupDatabase(SqlConnection con, string dbname, string[] files, string options, bool useLitespeed)
        {
            bool success = false;
            string jobname = "SQLAdmin backup for " + dbname;
            string runtime = string.Empty;
            success = createBackupJob(con, dbname, jobname, files, options, useLitespeed);
            if (success)
            {
                success = SQLLib.runJob(con, jobname, string.Empty, false);
                if (success)
                {
                    Thread.Sleep(1000);
                    waitForSPID(con, "BACKUP DATABASE", 30, true);
                    JBInfo jbi = new JBInfo(con, jobname);
                    while (jbi.CurrentRunStatus != "Idle")
                    {
                        Thread.Sleep(1000);
                        jbi.Refresh();
                    }
                    if (jbi.LastRunOutcome == "Succeeded")
                    {
                        runtime = jbi.LastRunDuration;
                    }
                    else
                    {
                        SQLAdmin.sendOut("Job outcome: {0}", jbi.LastRunOutcome);
                        success = false;
                    }
                }
                if (success)
                {
                    SQLAdmin.sendOut("Backup of {0} succeeded in {1}.", dbname, runtime);
                    string evt = string.Format("SQLAdmin backed up database '{0}'.", dbname);
                    SQLAdmin.logEvent(con.DataSource, evt);
                    deleteJob(jobname, con);
                }
                else
                {
                    SQLAdmin.sendOut("Backup of {0} failed!", dbname);
                    outputJobHist(jobname, con);
                }
            }
            return success;
        }

        internal static bool backupLog(SqlConnection con, string dbname, string folder, string options)
        {
            bool success = false;
            string jobname = "SQLAdmin log backup for " + dbname;
            string runtime = string.Empty;
            success = createLogBackupJob(con, dbname, jobname, folder, options);
            if (success)
            {
                success = SQLLib.runJob(con, jobname, string.Empty, false);
                if (success)
                {
                    success = false;
                    Thread.Sleep(1000);
                    waitForSPID(con, "BACKUP LOG", 30, true);
                    JBInfo jbi = new JBInfo(con, jobname);
                    while (jbi.CurrentRunStatus != "Idle")
                    {
                        Thread.Sleep(1000);
                        jbi.Refresh();
                    }
                    if (jbi.LastRunOutcome == "Succeeded")
                    {
                        runtime = jbi.LastRunDuration;
                        success = true;
                    }
                    else
                    {
                        SQLAdmin.sendOut("Job outcome: {0}", jbi.LastRunOutcome);
                    }
                }
                if (success)
                {
                    SQLAdmin.sendOut("Backup of {0} log succeeded in {1}.", dbname, runtime);
                    string evt = string.Format("SQLAdmin backed up the log for database '{0}'.", dbname);
                    SQLAdmin.logEvent(con.DataSource, evt);
                    deleteJob(jobname, con);
                }
                else
                {
                    SQLAdmin.sendOut("Log backup of {0} failed!", dbname);
                    outputJobHist(jobname, con);
                }
            }
            return success;
        }

        internal static bool changeDatabase(SqlConnection con, string db)
        {
            bool success = false;
            try
            {
                con.ChangeDatabase(db);
                success = true;
            }
            catch (SystemException e)
            {
                SQLAdmin.sendOut("Error attempting to change database context:");
                SQLAdmin.sendOut(e.Message);
            }
            return success;
        }

        internal static bool confirmChoice(string msg)
        {
            bool confirmed = false;
            DialogResult result = MessageBox.Show(msg, "Confirm action", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
            if (result == DialogResult.Yes)
                confirmed = true;
            return confirmed;
        }

        internal static SqlConnection connectToSQL(string strServer)
        {
            SqlConnection con = connectToSQL(strServer, "master");
            return con;
        }

        internal static SqlConnection connectToSQL(string strServer, string strDatabase)
        {
            SqlConnection con = new SqlConnection();
            // declare and open a connection to the server
            try
            {
                con.ConnectionString = ("Data Source=" + strServer + ";Initial Catalog=" + strDatabase + ";Integrated Security=SSPI");
                con.Open();
            }
            catch (System.Exception ex)
            {
                SQLAdmin.sendOut("Error attempting to connect to server " + strServer + ", database " + strDatabase);
                SQLAdmin.sendOut(ex.Message);
            }
            return con;
        }

        internal static bool createBackupJob(SqlConnection con, string dbname, string jobname, string[] files, string options, bool useLitespeed)
        {
            bool success = false;
            string fullpath = string.Empty;
            string backup;
            if (options == string.Empty)
            {
                options = "INIT";
            }
            else
            {
                options += ", INIT";
            }
            string jobID;
            if (jobname == string.Empty)
                jobname = string.Format("SQLAdmin database backup for '{0}'", dbname);
            // create the job
            jobID = createJob(con, jobname);
            // assemble the backup query
            if (useLitespeed)
            {
                backup = String.Format("EXEC xp_backup_database @database='{0}", dbname);
                for (int i = 0; i < files.Length; i++)
                {
                    if (files[0].Substring(files[0].Length - 1) == "\\")
                    {
                        backup = String.Format("{0}', @filename='{1}{2}.ls.bak", backup, files[i], dbname);
                    }
                    else
                    {
                        backup = String.Format("{0}', @filename='{1}", backup, files[i]);
                    }
                }
                backup = String.Format("{0}', @init=1", backup);
            }
            else
            {
                backup = String.Format("BACKUP DATABASE {0}{1}TO DISK = '", dbname, Environment.NewLine);
                if (files[0].Substring(files[0].Length - 1) == "\\")
                {
                    backup = String.Format("{0}{1}{2}.bak", backup, files[0], dbname);
                    for (int i = 1; i < files.Length; i++)
                    {
                        backup = String.Format("{0}', DISK='{1}{2}.bak", backup, files[i], dbname);
                    }
                }
                else
                {
                    backup = String.Format("{0}{1}", backup, files[0]);
                    for (int i = 1; i < files.Length; i++)
                    {
                        backup = String.Format("{0}', DISK='{1}", backup, files[i]);
                    }
                }
                backup = String.Format("{0}'", backup);
            }
            if (options != string.Empty)
            {
                if (useLitespeed)
                {
                    // parse options delimited by comma
                    string[] arrOptions = options.Split(',');
                    foreach (string option in arrOptions)
                    {
                        backup = string.Format("{0}, @with='{1}'", backup, option);
                    }
                }
                else
                {
                    backup = string.Format("{0}{1}WITH {2}", backup, Environment.NewLine, options);
                }
            }
            SQLAdmin.sendOut("Backup statement:{0}{1}", Environment.NewLine, backup);
            // add the backup step to the job
            success = addStepToJob(con, jobID, "Backup database", backup, true);
            return success;
        }

        internal static bool createBCRJob(SqlConnection con, string dbname, string srcsrv, string destsrv, string filepath)
        {
            bool success = false;
            string BCRjobname;
            string backupjobcmd;
            string jobID;
            BCRjobname = "SQLAdmin BCR for " + dbname;
            backupjobcmd = String.Format("sqladmin /s dbbcr /s {0}:{1} /d {2} /f {3}", srcsrv, destsrv, dbname, filepath);
            jobID = createJob(con, BCRjobname);
            success = addStepToJob(con, jobID, "BCR database", backupjobcmd, "CMDEXEC", string.Empty, true);
            return success;
        }

        internal static string createJob(SqlConnection con, string jobName)
        {
            SQLAdmin.sendOut("Creating job '{0}'.", jobName);
            bool success = false;
            if (jobExists(con, jobName))
            {
                SQLAdmin.sendOut("Overwriting existing job.");
                deleteJob(jobName, con, false);
            }
            SqlCommand sqlcmd = new SqlCommand();
            sqlcmd.Connection = con;
            sqlcmd.CommandText = "msdb.dbo.sp_add_job";
            sqlcmd.CommandType = CommandType.StoredProcedure;
            SqlParameter retval = sqlcmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            retval.Direction = ParameterDirection.ReturnValue;
            SqlParameter jobname = sqlcmd.Parameters.Add("@job_name", SqlDbType.NVarChar, 128);
            jobname.Value = jobName;
            SqlParameter owner = sqlcmd.Parameters.Add("@owner_login_name", SqlDbType.NVarChar, 128);
            owner.Value = "sa";
            SqlParameter eventloglvl = sqlcmd.Parameters.Add("@notify_level_eventlog", SqlDbType.Int);
            eventloglvl.Value = 0;
            SqlParameter jobID = sqlcmd.Parameters.Add("@job_id", SqlDbType.UniqueIdentifier);
            jobID.Direction = ParameterDirection.Output;
            success = executeStoredProc(sqlcmd, false);
            if (success)
            {
                sqlcmd.Parameters.Clear();
                // direct the job at the local server
                sqlcmd.CommandText = "msdb.dbo.sp_add_jobserver";
                retval = sqlcmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
                retval.Direction = ParameterDirection.ReturnValue;
                jobname = sqlcmd.Parameters.Add("@job_name", SqlDbType.NVarChar, 128);
                jobname.Value = jobName;
                executeStoredProc(sqlcmd, false);
                string evt = string.Format("SQLAdmin created job '{0}'", jobName);
                SQLAdmin.logEvent(con.DataSource, evt);
            }
            return jobID.Value.ToString();
        }

        internal static bool createLogBackupJob(SqlConnection con, string dbname, string jobname, string folder, string options)
        {
            bool success = false;
            string fullpath;
            string undo;
            string backup;
            string jobID;
            if (folder.LastIndexOf('\\') + 1 < folder.Length)
                folder += "\\";
            // verify the folder exists
            if (Directory.Exists(folder))
            {
                // assemble the full file path
                fullpath = folder + dbname + ".trn";
                // create the job
                jobID = createJob(con, jobname);
                if (options.ToLower().IndexOf("standby") != -1)
                {
                    undo = folder + dbname + ".undo";
                    // assemble the backup query
                    backup = string.Format("BACKUP LOG {0} TO DISK = '{1}' WITH INIT, STANDBY='{2}'", dbname, fullpath, undo);
                }
                else
                {
                    backup = string.Format("BACKUP LOG {0} TO DISK = '{1}' WITH INIT", dbname, fullpath);
                }
                SQLAdmin.sendOut("Backup command: {0}", backup);
                // add the backup step to the job
                success = addStepToJob(con, jobID, "Backup log", backup, true);
            }
            else
            {
                SQLAdmin.sendOut("Folder {0} does not exist.", folder);
            }
            return success;
        }

        internal static bool createLogRestoreJob(SqlConnection con, string dbname, string jobname, string folder, string options)
        {
            bool success = false;
            string jobID;
            string restore = string.Empty;
            string dbbackupfile = string.Format("{0}\\{1}.trn", folder, dbname);
            if (jobname == string.Empty)
                jobname = string.Format("SQLAdmin log restore for {0}", dbname);
            jobID = createJob(con, jobname);
            // assemble the restore query
            restore = string.Format("RESTORE LOG {0} FROM DISK = '{1}'", dbname, dbbackupfile);
            if (options != string.Empty)
                restore += " WITH " + options;
            SQLAdmin.sendOut("Restore command: {0}", restore);
            // add the restore step to the job
            success = addStepToJob(con, jobID, "Restore log", restore, true);
            return success;
        }

        internal static void createMirroringEndpoint(SqlConnection sqlConnection)
        {
            SQLAdmin.sendOut("Creating mirroring endpoint for server {0}.", sqlConnection.DataSource);
            string cmd = "IF NOT EXISTS (SELECT 1 FROM sys.database_mirroring_endpoints WHERE name = 'endpoint_mirroring') ";
            cmd += " BEGIN";
            cmd += " CREATE ENDPOINT endpoint_mirroring";
            cmd += " STATE = STARTED";
            cmd += " AS TCP ( LISTENER_PORT = 7022 )";
            cmd += " FOR DATABASE_MIRRORING (";
            cmd += " AUTHENTICATION = WINDOWS NEGOTIATE";
            cmd += " , ENCRYPTION = SUPPORTED";
            cmd += " , ROLE = ALL);";
            cmd += " END ELSE BEGIN";
            cmd += " ALTER ENDPOINT endpoint_mirroring";
            cmd += " STATE = STARTED";
	        cmd += " AS TCP ( LISTENER_PORT = 7022 )";
            cmd += " FOR DATABASE_MIRRORING (";
            cmd += " AUTHENTICATION = WINDOWS NEGOTIATE";
            cmd += " , ENCRYPTION = SUPPORTED";
            cmd += " , ROLE = ALL);";
            cmd += " END";
            executeNonQueryAtSql(sqlConnection, cmd);
        }

        internal static bool createRestoreJob(SqlConnection con, string dbname, string[] files, string options, bool useLitespeed)
        {
            bool success = false;
            string jobname;
            string jobID;
            string oldDBName;
            string logicalName;
            string physicalName;
            string restore = string.Empty;
            string backup = string.Empty;
            if (useLitespeed)
            {
                if (files[0].Substring(files[0].Length - 1) == "\\")
                {
                    backup = String.Format("@filename='{0}{1}{2}.ls.bak'", backup, files[0], dbname);
                }
                else
                {
                    backup = String.Format("@filename='{0}{1}'", backup, files[0]);
                }
                for (int i = 1; i < files.Length; i++)
                {
                    if (files[0].Substring(files[0].Length - 1) == "\\")
                    {
                        backup = String.Format("{0}, @filename='{1}{2}.ls.bak'", backup, files[i], dbname);
                    }
                    else
                    {
                        backup = String.Format("{0}, @filename='{1}'", backup, files[i]);
                    }
                }
            }
            else
            {
                if (files[0].Substring(files[0].Length - 1) == "\\")
                {
                    backup = String.Format("FROM DISK = '{0}{1}{2}.bak", backup, files[0], dbname);
                    for (int i = 1; i < files.Length; i++)
                    {
                        backup = String.Format("{0}', DISK='{1}{2}.bak", backup, files[i], dbname);
                    }
                }
                else
                {
                    backup = String.Format("{0}FROM DISK = '{1}", backup, files[0]);
                    for (int i = 1; i < files.Length; i++)
                    {
                        backup = String.Format("{0}', DISK='{1}", backup, files[i]);
                    }
                }
                backup = string.Format("{0}'", backup);
            }
            // query the backup file header
            if (useLitespeed)
            {
                restore = String.Format("EXEC master.dbo.xp_restore_headeronly {0}", backup);
            }
            else
            {
                restore = string.Format("RESTORE HEADERONLY {0}", backup);
            }
            SqlDataReader rdr = SQLLib.getReaderFromSql(con, restore);
            if (verifyReader(rdr, false))
            {
                rdr.Read();
                if (useLitespeed)
                {
                    oldDBName = getStringFromReader(rdr, 12);
                }
                else
                {
                    oldDBName = getStringFromReader(rdr, 9);
                }
                SQLLib.disposeReader(rdr);
                // create the job
                jobname = string.Format("SQLAdmin restore for {0}", dbname);
                jobID = createJob(con, jobname);
                // determine the database name
                if (oldDBName.ToLower() != dbname.ToLower())
                {
                    // get information regarding the restore files
                    if (useLitespeed)
                    {
                        restore = String.Format("EXEC xp_restore_filelistonly {0}", backup);
                    }
                    else
                    {
                        restore = string.Format("RESTORE FILELISTONLY {0}", backup);
                    }
                    changeDatabase(con, "master");
                    SqlDataReader frdr = getReaderFromSql(con, restore);
                    if (verifyReader(frdr))
                    {
                        frdr.Read();
                        logicalName = SQLLib.getStringFromReader(frdr);
                        physicalName = SQLLib.getStringFromReader(frdr, 1);
                        physicalName = SQLAdmin.replaceNoCase(physicalName, oldDBName, dbname);
                        // add MOVE clauses to the restore options
                        if (options == string.Empty)
                        {
                            if (useLitespeed)
                            {
                                options = string.Format("MOVE \"{0}\" TO \"{1}\"", logicalName, physicalName);
                            }
                            else
                            {
                                options = string.Format("MOVE '{0}' TO '{1}'", logicalName, physicalName);
                            }
                        }
                        else
                        {
                            if (useLitespeed)
                            {
                                options = string.Format("{0}, MOVE \"{1}\" TO \"{2}\"", options, logicalName, physicalName);
                            }
                            else
                            {
                                options = string.Format("{0}, MOVE '{1}' TO '{2}'", options, logicalName, physicalName);
                            }
                        }
                        while (frdr.Read())
                        {
                            logicalName = SQLLib.getStringFromReader(frdr);
                            physicalName = SQLLib.getStringFromReader(frdr, 1);
                            physicalName = SQLAdmin.replaceNoCase(physicalName, oldDBName, dbname);
                            if (useLitespeed)
                            {
                                options = string.Format("{0}, MOVE \"{1}\" TO \"{2}\"", options, logicalName, physicalName);
                            }
                            else
                            {
                                options = string.Format("{0}, MOVE '{1}' TO '{2}'", options, logicalName, physicalName);
                            }
                        }
                    }
                    SQLLib.disposeReader(frdr);
                }
                // assemble the restore query
                if (useLitespeed)
                {
                    restore = String.Format("EXEC xp_restore_database @database='{0}', {1}", dbname, backup);
                }
                else
                {
                    restore = string.Format("RESTORE DATABASE {0}{1}{2}", dbname, Environment.NewLine, backup);
                }
                if (options != string.Empty)
                {
                    if (useLitespeed)
                    {
                        // parse options delimited by comma
                        string[] arrOptions = options.Split(',');
                        foreach (string option in arrOptions)
                        {
                            restore = string.Format("{0}, @with='{1}'", restore, option);
                        }
                    }
                    else
                    {
                        restore = string.Format("{0}{1}WITH {2}", restore, Environment.NewLine, options);
                    }
                }
                SQLAdmin.sendOut("Restore statement:{0}{1}", Environment.NewLine, restore);
                // add the restore step to the job
                success = addStepToJob(con, jobID, "Restore database", restore, true);
            }
            SQLLib.disposeReader(rdr);
            return success;
        }

        internal static bool deleteJob(string jobName, SqlConnection con, bool output)
        {
            bool success = false;
            if (jobExists(con, jobName))
            {
                if (output)
                    SQLAdmin.sendOut("Dropping job '{0}'.", jobName);
                SqlCommand delcmd = new SqlCommand();
                delcmd.Connection = con;
                delcmd.CommandText = "msdb.dbo.sp_delete_job";
                delcmd.CommandType = CommandType.StoredProcedure;
                SqlParameter retval = delcmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
                retval.Direction = ParameterDirection.ReturnValue;
                SqlParameter prm1 = delcmd.Parameters.Add("@job_name", SqlDbType.NVarChar, 128);
                prm1.Value = jobName;
                success = executeStoredProc(delcmd, false);
                if (success)
                {
                    string evt = string.Format("SQLAdmin deleted job '{0}'.", jobName);
                    SQLAdmin.logEvent(con.DataSource, evt);
                }
                delcmd.Dispose();
            }
            else
            {
                // the job doesn't exist; therefore, no deletion necessary
                success = true;
            }
            return success;
        }

        internal static bool deleteJob(string jobName, SqlConnection con)
        {
            bool success = deleteJob(jobName, con, false);
            return success;
        }

        internal static void disposeReader(SqlDataReader rdr)
        {
            if (rdr != null)
            {
                if (!rdr.IsClosed)
                {
                    rdr.Close();
                }
                rdr.Dispose();
            }
        }

        internal static bool dropDatabase(SqlConnection sqlConnection, string db)
        {
            bool success = false;
            if (changeDatabase(sqlConnection, "master"))
            {
                SQLAdmin.sendOut("Verifying that the database is not published.");
                if (dropDBRepl(sqlConnection.DataSource, db))
                {
                    SqlCommand cmd = new SqlCommand();
                    cmd.Connection = sqlConnection;
                    killUsersInDB(sqlConnection, db);
                    SQLAdmin.sendOut("Dropping database '{0}'.", db);
                    string dropQuery = string.Format("ALTER DATABASE {0} SET SINGLE_USER; DROP DATABASE {0}", db);
                    if (SQLLib.executeNonQueryAtSql(cmd, dropQuery) != -1)
                    {
                        success = true;
                        string evt = string.Format("SQLAdmin dropped database '{0}'.", db);
                        SQLAdmin.logEvent(sqlConnection.DataSource, evt);
                        Console.WriteLine(evt);
                    }
                    else
                    {
                        Console.WriteLine("Attempt to drop database {0} failed.", db);
                        // best effort to get back to multi_user following a failed drop attempt
                        dropQuery = string.Format("ALTER DATABASE {0} SET MULTI_USER", db);
                        killUsersInDB(cmd.Connection, db);  // try to kill users so the way is cleared to set to MULTI_USER
                        if (SQLLib.executeNonQueryAtSql(cmd, dropQuery) == -1)
                            Console.WriteLine("Attempt to set database MULTI_USER failed.");
                    }
                }
            }
            return success;
        }

        internal static bool dropDBRepl(string pubSrv, string pubDB)
        {
            bool success = false;
            // get name of the distribution DB
            Console.WriteLine("Getting distribution server.");
            string distSrv = getDistSvr(pubSrv);
            Console.WriteLine("Getting distribution database.");
            string distDB = getDistDB(pubSrv);
            if (distDB != string.Empty)
            {
                success = dropDBRepl(pubSrv, pubDB, distSrv, distDB);
            }
            else
            {
                success = true; // no distribution database implies no replication, so 'mission accomplished'
            }
            return success;
        }

        internal static bool dropDBRepl(string pubSrv, string pubDB, string distSvr, string distDB)
        {
            bool success = false;
            if (distDB != string.Empty)
            {
                string subSrv;
                string subDB;
                string pubName;
                int pubType;
                SqlConnection drpcon = SQLLib.connectToSQL(pubSrv, "master");
                // drop replication and disable publishing on one published database
                for (int i = 0; i < 3; i++)
                {
                    // get list of subscribers FROM distribution DB
                    SqlDataReader rdr = SQLLib.getReplMonitorSubscriptions(pubSrv, pubDB, distSvr, distDB, i, true);
                    if (rdr == null)
                    {
                        // try adding the distribution database as a possible fix for a null datareader
                        if (runSP(pubSrv, "master", "sp_adddistributiondb", "@database", distDB))
                        {
                            rdr = SQLLib.getReplMonitorSubscriptions(pubSrv, pubDB, distSvr, distDB, i, true);
                        }
                    }
                    if (SQLLib.verifyReader(rdr))
                    {
                        while (rdr.Read())
                        {
                            subSrv = rdr.GetString(2);
                            subDB = rdr.GetString(3);
                            pubName = rdr.GetString(5);
                            pubType = rdr.GetInt32(6);
                            Console.WriteLine("Dropping subscription for '{0}' from {1}.", pubName, subSrv);
                            // SQLLib.killUsersInDB(drpcon, pubDB);    // kill users in publication database
                            // instead of this sledgehammer approach, need to develop a more sophisticated means of unblocking ourselves ...
                            dropSubscription(drpcon, pubSrv, pubDB, pubName, subSrv, subDB);
                            // we have no means of determining if subscriptions exist for this subscriber,
                            // so we just attempt to drop the subscriber in case there are none.
                            Console.WriteLine("Attempting to drop subscriber '{0}'.", subSrv);
                            SqlCommand drpcmd = new SqlCommand();
                            drpcmd.Connection = drpcon;
                            drpcmd.CommandText = "sp_dropsubscriber";
                            drpcmd.CommandType = CommandType.StoredProcedure;
                            SqlParameter drpprm = drpcmd.Parameters.Add("@subscriber", SqlDbType.NVarChar, 128);
                            drpprm.Value = subSrv;
                            SqlDataReader drprdr = SQLLib.getReaderFromSP(drpcmd, true);
                            SQLLib.disposeReader(drprdr);
                            drpcmd.Parameters.Clear();
                        }
                    }
                    SQLLib.disposeReader(rdr);
                }
                setDBReplOption(pubSrv, pubDB, "merge publish", false);
                setDBReplOption(pubSrv, pubDB, "publish", false);
                DBInfo pubdbinfo = new DBInfo(pubDB, drpcon);
                if (!pubdbinfo.IsPublished)
                {
                    success = true;
                }
                drpcon.Close();
                drpcon.Dispose();
            }
            return success;
        }

        internal static bool dropSubscription(SqlConnection distconn, string pubSrv, string pubDB, string pubName, string subSrv, string subDB)
        {
            bool success = false;
            if (SQLLib.changeDatabase(distconn, pubDB))
            {
                success = false;  // reset success for the method as a whole
                SqlCommand dpcmd = new SqlCommand();
                dpcmd.Connection = distconn;
                dpcmd.CommandText = "sp_dropsubscription";
                dpcmd.CommandType = CommandType.StoredProcedure;
                SqlParameter dpprm1 = dpcmd.Parameters.Add("@publication", SqlDbType.NVarChar, 128);
                dpprm1.Value = pubName;
                SqlParameter dpprm2 = dpcmd.Parameters.Add("@article", SqlDbType.NVarChar, 128);
                dpprm2.Value = "all";
                SqlParameter dpprm3 = dpcmd.Parameters.Add("@subscriber", SqlDbType.NVarChar, 128);
                dpprm3.Value = subSrv;
                try
                {
                    dpcmd.ExecuteNonQuery();
                    SQLAdmin.sendOut("Subscription dropped.");
                    success = true;
                }
                catch (SystemException e)
                {
                    switch (e.Message.Substring(e.Message.Length - 17, 17))
                    {
                        case " for publication.":
                            setDBReplOption(pubSrv, pubDB, "publish", true);
                            dropSubscription(distconn, pubSrv, pubDB, pubName, subSrv, subDB);
                            break;
                        case "' does not exist.":
                            addPublication(pubSrv, pubDB, pubName);
                            dropSubscription(distconn, pubSrv, pubDB, pubName, subSrv, subDB);
                            break;
                        default:
                            SQLAdmin.sendOut("Error executing query \"{0}\" against connection string {1}:", dpcmd.CommandText, dpcmd.Connection.ConnectionString);
                            SQLAdmin.sendOut(e.Message);
                            SQLAdmin.sendOut(e.Message.Substring(e.Message.Length - 17, 17));
                            break;
                    }
                }
                dpcmd.Dispose();
            }
            return success;
        }

        internal static int executeNonQueryAtSql(SqlConnection con, string cmdText)
        {

            SqlCommand cmd = new SqlCommand();
            cmd.Connection = con;
            int retval = executeNonQueryAtSql(cmd, cmdText, false);
            return retval;
        }

        internal static int executeNonQueryAtSql(SqlConnection con, string cmdText, bool verbose)
        {
            SqlCommand cmd = new SqlCommand();
            cmd.Connection = con;
            int retval = executeNonQueryAtSql(cmd, cmdText, verbose);
            return retval;
        }

        internal static int executeNonQueryAtSql(SqlCommand sqlc, string cmdText)
        {
            int retval = executeNonQueryAtSql(sqlc, cmdText, false);
            return retval;
        }

        internal static int executeNonQueryAtSql(SqlCommand sqlc, string cmdText, bool verbose)
        {
            int retval = 0;
            sqlc.CommandText = cmdText;
            sqlc.CommandType = CommandType.Text;
            if (verbose)
            {
                SQLAdmin.sendOut("Executing: {0}", cmdText);
            }
            try
            {
                sqlc.ExecuteNonQuery();
                if (verbose)
                    SQLAdmin.sendOut("Execute succeeded.");
            }
            catch (SystemException e)
            {
                SQLAdmin.sendOut("Error executing query \"{0}\" against connection string {1}:", cmdText, sqlc.Connection.ConnectionString);
                SQLAdmin.sendOut(e.Message);
                retval = -1;
            }
            return retval;
        }

        internal static bool executeStoredProc(SqlCommand sqlcmd, bool output)
        {
            bool success = false;
            if (sqlcmd.Parameters.Count < 1)
            {
                SQLAdmin.sendOut("Return value parameter not passed to executeStoredProc; skipping execution of '{0}'.", sqlcmd.CommandText);
            }
            else
            {
                if (sqlcmd.Parameters[0].Direction != ParameterDirection.ReturnValue)
                {
                    SQLAdmin.sendOut("First parameter passed to executeStoredProc is not a return value; skipping execution of '{0}'.", sqlcmd.CommandText);
                }
                else
                {
                    SqlDataReader rdr = SQLLib.getReaderFromSP(sqlcmd);
                    // don't use verifyReader because that requires the DataReader have rows.
                    if (rdr != null)
                    {
                        if (!rdr.IsClosed)
                        {
                            rdr.Close();
                        }
                        if (sqlcmd.Parameters[0].Value.ToString() == "0")
                        {
                            if (output)
                            {
                                SQLAdmin.sendOut("Execution of '{0}' succeeded.", sqlcmd.CommandText);
                            }
                            success = true;
                        }
                        else
                        {
                            if (output)
                            {
                                SQLAdmin.sendOut("SQL call succeeded, but '{0}' reports that execution failed.{1}", sqlcmd.CommandText, Environment.NewLine);
                            }
                        }
                        rdr.Dispose();
                    }
                    else
                    {
                        Console.WriteLine();
                    }
                }
            }
            return success;
        }

        internal static bool getBoolFromInt(int boolval)
        {
            bool retval;
            if (boolval == 1)
            {
                retval = true;
            }
            else
            {
                retval = false;
            }
            return retval;
        }

        internal static bool getBoolFromReader(SqlDataReader srdr, int columnID)
        {
            bool returnval = false;
            if (srdr == null)
            {
                SQLAdmin.sendOut("Reader is null.");
            }
            else
            {
                if (srdr.HasRows)
                {
                    try
                    {
                        // return the requested column
                        if (!srdr.IsDBNull(columnID))
                        {
                            returnval = srdr.GetBoolean(columnID);
                        }
                    }
                    catch (SystemException e)
                    {
                        if (handleReadError(e, srdr))
                            returnval = srdr.GetBoolean(columnID);
                    }
                }
            }
            return returnval;
        }

        internal static byte getByteFromReader(SqlDataReader srdr, int columnID)
        {
            byte returnval = 255;
            if (srdr == null)
            {
                SQLAdmin.sendOut("Reader is null.");
            }
            else
            {
                if (srdr.HasRows)
                {
                    try
                    {
                        // if we're already on a valid record, return the requested column
                        if (!srdr.IsDBNull(columnID))
                        {
                            returnval = srdr.GetByte(columnID);
                        }
                    }
                    catch (SystemException e)
                    {
                        if (handleReadError(e, srdr))
                            returnval = srdr.GetByte(columnID);
                    }
                }
            }
            return returnval;
        }

        internal static string getDistDB(string DistSvr)
        {
            string distDB = string.Empty;
            SqlConnection dist = SQLLib.connectToSQL(DistSvr, "master");
            if (dist != null)
            {
                SqlCommand cmd = new SqlCommand();
                cmd.Connection = dist;
                cmd.CommandText = "sp_helpdistributiondb";
                cmd.CommandType = CommandType.StoredProcedure;
                SqlDataReader rdr = SQLLib.getReaderFromSP(cmd);
                if (SQLLib.verifyReader(rdr, true))
                {
                    distDB = SQLLib.getStringFromReader(rdr);
                }
                else
                {
                    SQLAdmin.sendOut("Distribution database not found on server {0}.{1}", DistSvr, Environment.NewLine);
                }
                SQLLib.disposeReader(rdr);
                cmd.Dispose();
                dist.Close();
                dist.Dispose();
            }
            return distDB;
        }

        internal static string getDistSvr(string PubSvr)
        {
            string distSvr = string.Empty;
            SqlConnection pub = SQLLib.connectToSQL(PubSvr, "master");
            if (pub != null)
            {
                SqlCommand cmd = new SqlCommand();
                cmd.Connection = pub;
                cmd.CommandText = "sp_helpdistributor";
                cmd.CommandType = CommandType.StoredProcedure;
                SqlDataReader rdr = SQLLib.getReaderFromSP(cmd);
                if (SQLLib.verifyReader(rdr, true))
                {
                    distSvr = SQLLib.getStringFromReader(rdr);
                }
                else
                {
                    SQLAdmin.sendOut("Distributor not found for server {0}.{1}", PubSvr, Environment.NewLine);
                }
                SQLLib.disposeReader(rdr);
                cmd.Dispose();
                pub.Close();
                pub.Dispose();
            }
            return distSvr;
        }

        internal static float getFloatFromReader(SqlDataReader rrdr)
        {
            float ret = float.NaN;
            if (verifyReader(rrdr))
            {
                if (!rrdr.IsDBNull(0))
                {
                    try
                    {
                        ret = rrdr.GetFloat(0);
                    }
                    catch (SystemException e)
                    {
                        if (handleReadError(e, rrdr))
                            ret = rrdr.GetFloat(0);
                    }
                }
            }
            return ret;
        }

        internal static Guid getGuidFromReader(SqlDataReader grdr)
        {
            Guid ret = getGuidFromReader(grdr, 0);
            return ret;
        }

        internal static Guid getGuidFromReader(SqlDataReader grdr, int columnID)
        {
            Guid ret = Guid.Empty;
            if (verifyReader(grdr))
            {
                try
                {
                    ret = grdr.GetGuid(columnID);
                }
                catch (SystemException e)
                {
                    if (handleReadError(e, grdr))
                        ret = grdr.GetGuid(columnID);
                }
            }
            return ret;
        }

        internal static Int16 getInt16FromReader(SqlDataReader srdr, int columnID)
        {
            Int16 returnval = -1;
            if (srdr == null)
            {
                SQLAdmin.sendOut("Reader is null.");
            }
            else
            {
                if (srdr.HasRows)
                {
                    try
                    {
                        // if we're already on a valid record, return the requested column
                        if (!srdr.IsDBNull(columnID))
                        {
                            returnval = srdr.GetInt16(columnID);
                        }
                    }
                    catch (SystemException e)
                    {
                        if (handleReadError(e, srdr))
                            returnval = srdr.GetInt16(columnID);
                    }
                }
            }
            return returnval;
        }

        internal static Int32 getInt32FromReader(SqlDataReader srdr, int columnID)
        {
            Int32 returnval = -1;
            if (srdr == null)
            {
                SQLAdmin.sendOut("Reader is null.");
            }
            else
            {
                if (srdr.HasRows)
                {
                    try
                    {
                        // if we're already on a valid record, return the requested column
                        if (!srdr.IsDBNull(columnID))
                        {
                            returnval = srdr.GetInt32(columnID);
                        }
                    }
                    catch (SystemException e)
                    {
                        if (handleReadError(e, srdr))
                            returnval = srdr.GetInt32(columnID);
                    }
                }
            }
            return returnval;
        }

        internal static Int64 getInt64FromReader(SqlDataReader srdr, int columnID)
        {
            Int64 returnval = -1;
            if (srdr == null)
            {
                SQLAdmin.sendOut("Reader is null.");
            }
            else
            {
                if (srdr.HasRows)
                {
                    try
                    {
                        // if we're already on a valid record, return the requested column
                        if (!srdr.IsDBNull(columnID))
                        {
                            returnval = srdr.GetInt64(columnID);
                        }
                    }
                    catch (SystemException e)
                    {
                        if (handleReadError(e, srdr))
                            returnval = srdr.GetInt64(columnID);
                    }
                }
            }
            return returnval;
        }

        internal static string getJobIDFromName(SqlConnection con, string jobName)
        {
            string jobID = string.Empty;
            string cmdstr = "SELECT CAST(job_id AS varchar(255)) FROM msdb.dbo.sysjobs_view WHERE name = N'" + jobName + "'";
            SqlDataReader rdr = getReaderFromSql(con, cmdstr);
            if (rdr.HasRows)
            {
                jobID = getStringFromReader(rdr);
            }
            SQLLib.disposeReader(rdr);
            return jobID;
        }

        internal static string getJobNameFromID(SqlConnection con, string jobID)
        {
            string jobname = string.Empty;
            string cmdstr = "SELECT name FROM msdb.dbo.sysjobs_view WHERE job_id = N'" + jobID + "'";
            SqlDataReader rdr = getReaderFromSql(con, cmdstr);
            if (SQLLib.verifyReader(rdr))
            {
                jobname = getStringFromReader(rdr);
            }
            SQLLib.disposeReader(rdr);
            return jobname;
        }

        internal static SqlDataReader getReaderFromSP(SqlCommand sqlc)
        {
            SqlDataReader getRdr = getReaderFromSP(sqlc, false);
            return getRdr;
        }

        internal static SqlDataReader getReaderFromSP(SqlCommand sqlc, bool suppressErrors)
        {
            SqlDataReader getRdr = null;
            try
            {
                getRdr = sqlc.ExecuteReader();
            }
            catch (SystemException e)
            {
                if (!suppressErrors)
                {
                    SQLAdmin.sendOut("Error executing stored procedure '{0}' against connection string {1}:", sqlc.CommandText, sqlc.Connection.ConnectionString);
                    SQLAdmin.sendOut(e.Message);
                }
            }
            return getRdr;
        }

        internal static SqlDataReader getReaderFromSql(SqlConnection con, string cmdText)
        {
            SqlDataReader getRdr = null;
            SqlCommand sqlc = new SqlCommand();
            sqlc.Connection = con;
            sqlc.CommandText = cmdText;
            sqlc.CommandType = CommandType.Text;
            try
            {
                getRdr = sqlc.ExecuteReader();
            }
            catch (SystemException e)
            {
                SQLAdmin.sendOut("Error executing query \"{0}\" against connection string {1}:", cmdText, sqlc.Connection.ConnectionString);
                SQLAdmin.sendOut(e.Message);
            }
            return getRdr;
        }

        internal static SqlDataReader getReplMonitorPublications(string pubSrv, string distSrv, string distDB, int pubtype, bool verbose)
        {
            SqlDataReader rdr = getReplMonitorPublications(pubSrv, null, distSrv, distDB, pubtype, verbose);
            return rdr;
        }

        internal static SqlDataReader getReplMonitorPublications(string pubSrv, string pubDB, string distSrv, string distDB, int pubtype, bool verbose)
        {
            SqlConnection con = connectToSQL(distSrv, distDB);
            SqlDataReader rdr = null;
            if (con.State != ConnectionState.Open)
            {
                SQLAdmin.sendOut("Unable to get publications from server '{0}'.", distSrv, distDB);
            }
            else
            {
                SqlCommand cmd = new SqlCommand();
                cmd.Connection = con;
                if (verbose)
                {
                    if (pubDB == null)
                    {
                        SQLAdmin.sendOut("Getting publication info for publication type {0}.", pubtype.ToString());
                    }
                    else
                    {
                        SQLAdmin.sendOut("Getting publication info for publication type {0} on database {1}.", pubtype.ToString(), pubDB);
                    }
                }
                cmd.CommandText = String.Format("{0}.dbo.sp_replmonitorhelppublication", distDB);
                cmd.CommandType = CommandType.StoredProcedure;
                if (changeDatabase(cmd.Connection, distDB))
                {
                    SqlParameter prm1 = cmd.Parameters.Add("@publisher", SqlDbType.NVarChar, 128);
                    prm1.Value = pubSrv;
                    SqlParameter prm2 = cmd.Parameters.Add("@publication_type", SqlDbType.Int);
                    prm2.Value = pubtype;
                    SqlParameter prm3 = cmd.Parameters.Add("@publisher_db", SqlDbType.NVarChar, 128);
                    prm3.Value = pubDB;
                    rdr = SQLLib.getReaderFromSP(cmd);
                }
            }
            return rdr;
        }

        internal static SqlDataReader getReplMonitorSubscriptions(string pubSrv, string distSrv, string distDB, int pubtype, bool verbose)
        {
            SqlDataReader rdr = getReplMonitorSubscriptions(pubSrv, null, distSrv, distDB, pubtype, verbose);
            return rdr;
        }

        internal static SqlDataReader getReplMonitorSubscriptions(string pubSrv, string pubDB, string distSrv, string distDB, int pubtype, bool verbose)
        {
            SqlConnection con = connectToSQL(distSrv, distDB);
            SqlDataReader rdr = null;
            if (con.State != ConnectionState.Open)
            {
                SQLAdmin.sendOut("Unable to get subscriptions from server '{0}', database '{1}'.", distSrv, distDB);
            }
            else
            {
                SqlCommand cmd = new SqlCommand();
                cmd.Connection = con;
                if (verbose)
                {
                    if (pubDB == null)
                    {
                        SQLAdmin.sendOut("Getting subscription info for publication type {0}.", pubtype.ToString());
                    }
                    else
                    {
                        SQLAdmin.sendOut("Getting subscription info for publication type {0} on database {1}.", pubtype.ToString(), pubDB);
                    }
                }
                cmd.CommandText = String.Format("{0}.dbo.sp_replmonitorhelpsubscription", distDB);
                cmd.CommandType = CommandType.StoredProcedure;
                if (changeDatabase(cmd.Connection, distDB))
                {
                    SqlParameter prm1 = cmd.Parameters.Add("@publisher", SqlDbType.NVarChar, 128);
                    prm1.Value = pubSrv;
                    SqlParameter prm2 = cmd.Parameters.Add("@publication_type", SqlDbType.Int);
                    prm2.Value = pubtype;
                    SqlParameter prm3 = cmd.Parameters.Add("@publisher_db", SqlDbType.NVarChar, 128);
                    prm3.Value = pubDB;
                    rdr = SQLLib.getReaderFromSP(cmd);
                }
            }
            return rdr;
        }

        internal static string getShareFromLocal(string servername, string localpath)
        {
            string sharePath = localpath.Replace(':', '$');
            string retval = String.Format("\\\\{0}\\{1}", servername, sharePath);
            return retval;
        }

        internal static string getShareNameFromFilePath(string filename)
        {
            string sharename = string.Empty;
            string[] foldernames = filename.Split('\\');
            try
            {
                sharename = foldernames[foldernames.Length - 2];
            }
            catch (SystemException e)
            {
                SQLAdmin.sendOut("Error attempting to parse file path {0} for share name:", filename);
                SQLAdmin.sendOut(e.Message);
            }
            return sharename;
        }

        internal static string getShareNameFromFolderPath(string foldername)
        {
            string sharename = string.Empty;
            string[] foldernames = foldername.Split('\\');
            try
            {
                sharename = foldernames[foldernames.Length - 1];
            }
            catch (SystemException e)
            {
                SQLAdmin.sendOut("Error attempting to parse file path {0} for share name:", foldername);
                SQLAdmin.sendOut(e.Message);
            }
            return sharename;
        }

        internal static Database getSMODatabase(ServerConnection srvcon, string strDatabase)
        {
            Database dbreturn = new Database();
            Server srv = new Server(srvcon);
            DatabaseCollection dbc = srv.Databases;
            foreach (Database db in dbc)
            {
                if (db.Name == strDatabase)
                {
                    dbreturn = db;
                }
            }
            return dbreturn;
        }

        internal static string getStringFromReader(SqlDataReader srdr)
        {
            string returnval = getStringFromReader(srdr, 0);
            return returnval;
        }

        internal static string getStringFromReader(SqlDataReader srdr, int columnID)
        {
            string returnval = string.Empty;
            if (srdr == null)
            {
                SQLAdmin.sendOut("Reader is null.");
            }
            else
            {
                if (srdr.HasRows)
                {
                    try
                    {
                        // if we're already on a valid record, return the requested column
                        if (!srdr.IsDBNull(columnID))
                        {
                            returnval = srdr.GetString(columnID);
                        }
                    }
                    catch (SystemException e)
                    {
                        if (handleReadError(e, srdr))
                            returnval = SQLLib.getStringFromReader(srdr, columnID);
                    }
                }
            }
            return returnval;
        }

        internal static string getTimeStrFromMs(int ms)
        {
            string retval = getTimeStrFromMs(ms, true);
            return retval;
        }

        internal static string getTimeStrFromMs(int ms, bool includehours)
        {
            string retval = string.Empty;
            int hour = 0;
            int min = 0;
            int sec = 0;
            string hourstr = string.Empty;
            string minstr = string.Empty;
            string secstr = string.Empty;
            sec = ms / 1000 % 60;   // get seconds remainder from ms
            min = ms / 1000 / 60;   // get minutes by division from ms
            hour = min / 60;        // get hours by division from min
            min = min % 60;         // get minutes remainder from ms
            minstr = min.ToString();
            minstr = minstr.PadLeft(2, '0');
            secstr = sec.ToString();
            secstr = secstr.PadLeft(2, '0');
            retval = string.Format("{0}:{1}", minstr, secstr);
            if (includehours)
            {
                hourstr = hour.ToString();
                hourstr = hourstr.PadLeft(2, '0');
                retval = string.Format("{0}:{1}", hourstr, retval);
            }
            return retval;
        }

        private static bool handleReadError(SystemException e, SqlDataReader rdr)
        {
            bool success = false;
            if (e.Message == "Invalid attempt to read when no data is present.")
            {
                // if we're not on a valid record, then read a record.
                if (rdr.Read())
                    success = true;
            }
            else
            {
                // otherwise, just print the error.
                SQLAdmin.sendOut("Error attempting to read data from SqlDataReader: {0}", e.Message);
            }
            return success;
        }

        internal static bool jobExists(SqlConnection con, string jobName)
        {
            bool exists = false;
            string cmdstr = "SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'" + jobName + "'";
            SqlDataReader rdr = getReaderFromSql(con, cmdstr);
            exists = SQLLib.verifyReader(rdr, false);
            SQLLib.disposeReader(rdr);
            return exists;
        }

        internal static bool killUsersInDB(SqlConnection con, string dbName)
        {
            bool success = false;
            if (dbName.ToLower() == "master")
            {
                Console.WriteLine("SQLAdmin kill command not supported on 'master' database.");
            }
            else
            {
                string cmd = string.Empty;
                cmd += " DECLARE @suser_id smallint";
                cmd += " DECLARE @stmt char(80)";
                cmd += " DECLARE user_cur cursor for";
                cmd += " SELECT spid";
                cmd += " FROM sys.sysprocesses p";
                cmd += " WHERE dbid = DB_ID( '" + dbName + "' )";
                cmd += " AND spid <> @@SPID";
                cmd += " UNION";
                cmd += " SELECT request_session_id";
                cmd += " FROM sys.dm_tran_locks";
                cmd += " WHERE resource_database_id = DB_ID( '" + dbName + "' )";
                cmd += " AND request_session_id <> @@SPID";
                cmd += " OPEN user_cur";
                cmd += " FETCH next FROM user_cur  into @suser_id";
                cmd += " WHILE (@@FETCH_status <> -1)";
                cmd += " BEGIN";
                cmd += " SELECT * FROM sys.sysprocesses WHERE spid=@suser_id";
                cmd += " SELECT @stmt = 'KILL ' + rtrim(convert(char(4), @suser_id)) + ';'";
                cmd += " EXEC (@stmt)";
                cmd += " FETCH next FROM user_cur into @suser_id";
                cmd += " END";
                cmd += " CLOSE user_cur";
                cmd += " DEALLOCATE user_cur";
                SqlDataReader rdr = getReaderFromSql(con, cmd);
                if (rdr != null)
                {
                    if (rdr.HasRows)
                    {
                        SQLAdmin.sendOut("Killed spids connected to database '{0}'on server {1}.", dbName, con.DataSource);
                    }
                    success = true; // successful run of kill statement above
                    string evt = string.Format("SQLAdmin killed SPIDs connected to database '{0}'.", dbName);
                    SQLAdmin.logEvent(con.DataSource, evt);
                }
                SQLLib.disposeReader(rdr);
            }
            return success;
        }

        internal static bool LitespeedExists(SqlConnection con)
        {
            bool exists = false;
            string cmdstr = "SELECT 1 FROM master.sys.procedures WHERE name = N'xp_backup_database'";
            SqlDataReader rdr = getReaderFromSql(con, cmdstr);
            exists = rdr.HasRows;
            SQLLib.disposeReader(rdr);
            return exists;
        }

        internal static string mapJobOutcome(Int32 outcomeint)
        {
            string retstr = mapJobOutcome(outcomeint, false);
            return retstr;
        }

        internal static string mapJobOutcome(Int32 outcomeint, bool padRight)
        {
            string retstr = String.Empty;
            switch (outcomeint)
            {
                case 0:
                    retstr = "Failed";
                    break;
                case 1:
                    retstr = "Succeeded";
                    break;
                case 2:
                    retstr = "Retry";
                    break;
                case 3:
                    retstr = "Cancelled";
                    break;
                case 4:
                    retstr = "InProgress";
                    break;
                default:
                    retstr = "Unknown";
                    break;
            }
            if (padRight)
                retstr = retstr.PadRight(10, ' ');
            return retstr;
        }

        internal static string mapJobStatus(Int32 statusint)
        {
            string retstr = String.Empty;
            switch (statusint)
            {
                case 1:
                    retstr = "Executing";
                    break;
                case 2:
                    retstr = "Waiting For Thread";
                    break;
                case 3:
                    retstr = "Between Retries";
                    break;
                case 4:
                    retstr = "Idle";
                    break;
                case 5:
                    retstr = "Suspended";
                    break;
                case 7:
                    retstr = "PerformingCompletion";
                    break;
                default:
                    retstr = "Unknown";
                    break;
            }
            return retstr;
        }

        internal static string mapNotifyLevel(Int32 notifyint)
        {
            string retstr = String.Empty;
            switch (notifyint)
            {
                case 0:
                    retstr = "Never";
                    break;
                case 1:
                    retstr = "OnSuccess";
                    break;
                case 2:
                    retstr = "OnFailure";
                    break;
                case 3:
                    retstr = "Always";
                    break;
                default:
                    retstr = "Unknown";
                    break;
            }
            return retstr;
        }

        internal static string mapSubStatus(int statusid)
        {
            string status = string.Empty;
            switch (statusid)
            {
                case 1:
                    status = "Started";
                    break;
                case 2:
                    status = "Succeeded";
                    break;
                case 3:
                    status = "In progress";
                    break;
                case 4:
                    status = "Idle";
                    break;
                case 5:
                    status = "Retrying";
                    break;
                case 6:
                    status = "Failed";
                    break;
                default:
                    break;
            }
            return status;
        }

        internal static bool outputJobHist(string jb, SqlConnection con)
        {
            bool success = false;
            JBInfo jbinf = new JBInfo(con, jb);
            ArrayList al = jbinf.getHistory();
            if (al.Count > 0)
            {
                foreach (string hist in al)
                {
                    SQLAdmin.sendOut(hist);
                }
                success = true;
            }
            else
            {
                SQLAdmin.sendOut("No history found for job '{0}'.", jb);
                success = true;
            }
            return success;
        }

        internal static bool outputJobInfo(string jobname, SqlConnection sqlc)
        {
            bool success = false;
            string output = string.Empty;
            string query = string.Empty;
            // create a JBInfo object from the Job object, which will provide the strings we need to output
            JBInfo jbinf = new JBInfo(sqlc, jobname);
            // output the information from the Job object
            SQLAdmin.sendOut("Server  : {0}", jbinf.OriginatingServer);
            SQLAdmin.sendOut("Job Name: {0}", jbinf.Name);
            output = jbinf.CurrentRunStatus;
            if (output == "Executing")
            {
                output += " Step " + jbinf.CurrentRunStep;
            }
            SQLAdmin.sendOut("Status  : {0}", output);
            outputJobSchedules(sqlc, jbinf);
            SQLAdmin.sendOut("Enabled|Last Run         |LastResult|Duration |AlertLvl |Owner");
            output = jbinf.IsEnabled.ToString().PadRight(7) + "|";
            if (jbinf.LastRunDate.ToString() == "00010101 00:00:00")
            {
                // a "dawn of time" value indicates the job has never run
                output += "Never".PadRight(23) + "|";
            }
            else
            {
                output += jbinf.LastRunDate.PadRight(17) + "|";
            }
            output += jbinf.LastRunOutcome.PadRight(10) + "|";
            output += jbinf.LastRunDuration.PadRight(9) + "|";
            output += jbinf.EventLogLevel.PadRight(9) + "|";
            output += jbinf.Owner + Environment.NewLine;
            SQLAdmin.sendOut(output);
            success = true;
            return success;
        }

        internal static void outputJobSchedules(SqlConnection sqlc, JBInfo infjob)
        {
            string output = string.Empty;
            if (changeDatabase(sqlc, "msdb"))
            {
                // Begin block of code to output schedule descriptions
                SqlCommand cmd = new SqlCommand();
                cmd.Connection = sqlc;
                cmd.CommandText = "sp_help_jobschedule";
                cmd.CommandType = CommandType.StoredProcedure;
                SqlParameter prmr = cmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
                prmr.Direction = ParameterDirection.ReturnValue;
                SqlParameter prm1 = cmd.Parameters.Add("@job_name", SqlDbType.NVarChar, 128);
                prm1.Value = infjob.Name;
                SqlParameter prm2 = cmd.Parameters.Add("@include_description", SqlDbType.Bit, 1);
                prm2.Value = 1;
                SqlDataReader rdr = SQLLib.getReaderFromSP(cmd);
                output = "Sched(s): ";
                if (SQLLib.verifyReader(rdr, false))
                {
                    while (rdr.Read())
                    {
                        output += rdr.GetString(14);    // schedule description
                        output += Environment.NewLine + "          ";
                    }
                    output = output.Substring(0, output.Length - 11); // remove final trailing NewLine
                }
                else
                {
                    output += "None";
                }
                SQLLib.disposeReader(rdr);
                Console.WriteLine(output);
            }
        }

        internal static string padTime(int inptime)
        {
            string rettime = string.Empty;
            rettime = inptime.ToString().PadLeft(6, '0');
            rettime = rettime.Substring(0, rettime.Length - 4) + ":" + rettime.Substring(2, 2) + ":" + rettime.Substring(4, 2);
            return rettime;
        }

        internal static bool processLogShippingMonitorPrimary(SqlConnection con, string prisrv, string secsrv, string db)
        {
            bool success = false;
            
            SqlCommand cmd = new SqlCommand();
            cmd.Connection = con;
            cmd.CommandText = "msdb.sys.sp_processlogshippingmonitorprimary";
            cmd.CommandType = CommandType.StoredProcedure;
            SqlParameter pr = cmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            pr.Direction = ParameterDirection.ReturnValue;
            SqlParameter p1 = cmd.Parameters.Add("@mode", SqlDbType.TinyInt);
            p1.Value = 1;
            SqlParameter p2 = cmd.Parameters.Add("@primary_id", SqlDbType.UniqueIdentifier);
            p2.Value = Guid.NewGuid();
            SqlParameter p3 = cmd.Parameters.Add("@primary_server", SqlDbType.NVarChar, 128);
            p3.Value = prisrv;
            SqlParameter p4 = cmd.Parameters.Add("@monitor_server", SqlDbType.NVarChar, 128);
            p4.Value = secsrv;
            SqlParameter p5 = cmd.Parameters.Add("@monitor_server_security_mode", SqlDbType.Bit);
            p5.Value = 1;
            SqlParameter p6 = cmd.Parameters.Add("@primary_database", SqlDbType.NVarChar, 128);
            p6.Value = db;
            SqlParameter p7 = cmd.Parameters.Add("@backup_threshold", SqlDbType.Int);
            p7.Value = 60;
            SqlParameter p8 = cmd.Parameters.Add("@threshold_alert", SqlDbType.Int);
            p8.Value = 14420;
            SqlParameter p9 = cmd.Parameters.Add("@threshold_alert_enabled", SqlDbType.Bit);
            p9.Value = 1;
            SqlParameter p10 = cmd.Parameters.Add("@history_retention_period", SqlDbType.Int);
            p10.Value = 5760;
            success = executeStoredProc(cmd, true);
            return success;
        }

        internal static bool restoreDatabase(SqlConnection con, string dbname, string[] files, string options, bool useLitespeed)
        {
            if (files[0].Substring(files[0].Length - 1, 1) == "\\")
            {
                // Assemble file list from folder plus DB for each file
                string folder = files[0];
            }
            killUsersInDB(con, dbname);
            bool success = false;
            string runtime = string.Empty;
            string jobname = "SQLAdmin restore for " + dbname;
            success = createRestoreJob(con, dbname, files, options, useLitespeed);
            if (success)
            {
                success = false;
                success = SQLLib.runJob(con, jobname, string.Empty, false);
            }
            else
            {
                return success;
            }
            if (success)
            {
                Thread.Sleep(1000);
                waitForSPID(con, "RESTORE DATABASE", 30, true);
                JBInfo jbi = new JBInfo(con, jobname);
                while (jbi.CurrentRunStatus != "Idle")
                {
                    Thread.Sleep(1000);
                    jbi.Refresh();
                }
                if (jbi.LastRunOutcome == "Succeeded")
                {
                    runtime = jbi.LastRunDuration;
                }
                else
                {
                    success = false;
                }
            }
            if (success)
            {
                SQLAdmin.sendOut("Restore of {0} succeeded in {1}.", dbname, runtime);
                string evt = string.Format("SQLAdmin restored database '{0}'.", dbname);
                SQLAdmin.logEvent(con.DataSource, evt);
                // we remove the job if it succeeded
                deleteJob(jobname, con, true);
            }
            else
            {
                SQLAdmin.sendOut("Restore of {0} failed!", dbname);
                if (SQLLib.jobExists(con, jobname))
                    outputJobHist(jobname, con);
            }
            return success;
        }

        internal static bool restoreLog(SqlConnection con, string dbname, string folder, string options)
        {
            if (folder.Substring(folder.Length - 1, 1) == "\\")
            {
                folder += dbname + ".bak";
            }
            killUsersInDB(con, dbname);
            bool success = false;
            string runtime = string.Empty;
            string jobname = "SQLAdmin log restore for " + dbname;
            success = createLogRestoreJob(con, dbname, jobname, folder, options);
            if (success)
                success = SQLLib.runJob(con, jobname, string.Empty, false);
            if (success)
            {
                Thread.Sleep(1000);
                waitForSPID(con, "RESTORE LOG", 30, true);
                JBInfo jbi = new JBInfo(con, jobname);
                while (jbi.CurrentRunStatus != "Idle")
                {
                    Thread.Sleep(1000);
                    jbi.Refresh();
                }
                if (jbi.LastRunOutcome == "Succeeded")
                {
                    runtime = jbi.LastRunDuration;
                }
                else
                {
                    success = false;
                    outputJobHist(jobname, con);
                }
            }
            if (success)
            {
                SQLAdmin.sendOut("Restore of log on {0} succeeded in {1}.", dbname, runtime);
                string evt = string.Format("SQLAdmin restored log for database {0}.", dbname);
                SQLAdmin.logEvent(con.DataSource, evt);
                // we remove the job if it succeeded
                deleteJob(jobname, con);
            }
            else
            {
                SQLAdmin.sendOut("Restore of {0} failed!", dbname);
            }
            return success;
        }

        internal static bool runJob(SqlConnection SQLConn, string jobName, string jobStep, bool output)
        {
            bool success = false;
            JBInfo jb = new JBInfo(SQLConn, jobName);
            if (jb.CurrentRunStatus != string.Empty) // fail if we didn't get a value for the job status
            {
                if (jb.CurrentRunStatus != "Idle")
                {
                    SQLAdmin.sendOut("Not running job '{0}' due to current status of '{1}'.{2}", jobName, jb.CurrentRunStatus, Environment.NewLine);
                    success = true;
                }
                else
                {
                    if (changeDatabase(SQLConn, "msdb"))
                    {
                        SQLAdmin.sendOut("Running job '{0}'.", jobName);
                        SqlCommand cmd = new SqlCommand();
                        cmd.Connection = SQLConn;
                        cmd.CommandText = "sp_start_job";
                        cmd.CommandType = CommandType.StoredProcedure;
                        SqlParameter prmr = cmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
                        prmr.Direction = ParameterDirection.ReturnValue;
                        SqlParameter prm1 = cmd.Parameters.Add("@job_name", SqlDbType.NVarChar, 128);
                        prm1.Value = jobName;
                        if (jobStep != string.Empty)
                        {
                            try
                            {
                                SqlParameter prm2 = cmd.Parameters.Add("@step_name", SqlDbType.NVarChar, 128);
                                prm2.Value = jobStep;
                            }
                            catch (SystemException e)
                            {
                                SQLAdmin.sendOut("Error adding parameter for job step:");
                                SQLAdmin.sendOut(e.Message);
                            }
                        }
                        if (SQLLib.executeStoredProc(cmd, true))
                        {
                            success = true;
                            string evt = string.Format("SQLAdmin started job '{0}'.", jobName);
                            SQLAdmin.logEvent(SQLConn.DataSource, evt);
                        }
                        Thread.Sleep(1000);
                    }
                }
                if (output)
                    outputJobInfo(jobName, SQLConn);
            }
            return success;
        }

        internal static bool runJob(SqlConnection SQLConn, string jobName, string jobStep)
        {
            bool success = runJob(SQLConn, jobName, jobStep, true);
            return success;
        }

        internal static bool runJob(SqlConnection SQLConn, string jobName)
        {
            bool success = runJob(SQLConn, jobName, string.Empty, true);
            return success;
        }

        internal static bool runSP(string srv, string db, string sp)
        {
            bool success = false;
            SqlConnection subcon = SQLLib.connectToSQL(srv, db);
            SqlCommand subcmd = new SqlCommand();
            subcmd.Connection = subcon;
            subcmd.CommandText = sp;
            subcmd.CommandType = CommandType.StoredProcedure;
            SqlParameter retprm = subcmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            retprm.Direction = ParameterDirection.ReturnValue;
            if (SQLLib.executeStoredProc(subcmd, true))
                success = true;
            subcmd.Dispose();
            subcon.Close();
            subcon.Dispose();
            return success;
        }

        internal static bool runSP(string srv, string db, string sp, string parmname, string parmval)
        {
            bool success = false;
            SqlConnection subcon = SQLLib.connectToSQL(srv, db);
            SqlCommand subcmd = new SqlCommand();
            subcmd.Connection = subcon;
            subcmd.CommandText = sp;
            subcmd.CommandType = CommandType.StoredProcedure;
            SqlParameter retprm = subcmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            retprm.Direction = ParameterDirection.ReturnValue;
            SqlParameter prm1 = subcmd.Parameters.Add(parmname, SqlDbType.VarChar, 2000);
            prm1.Value = parmval;
            if (SQLLib.executeStoredProc(subcmd, true))
                success = true;
            subcmd.Dispose();
            subcon.Close();
            subcon.Dispose();
            return success;
        }

        internal static bool setDBOption(SqlConnection con, string db, string option, string value)
        {
            bool success = false;
            string cmdtxt = string.Empty;
            cmdtxt = String.Format("ALTER DATABASE {0} SET {1} {2}", db, option, value);
            SqlCommand cmd = new SqlCommand();
            cmd.Connection = con;
            if (executeNonQueryAtSql(cmd, cmdtxt, true) != -1)
                success = true;
            cmd.Dispose();
            return success;
        }
        internal static bool setDBReplOption(string srvname, string dbname, string pubtype, bool truefalse)
        {
            bool success = false;
            SqlConnection pubcon = SQLLib.connectToSQL(srvname, "master");
            SqlCommand pubcmd = new SqlCommand();
            pubcmd.Connection = pubcon;
            pubcmd.CommandTimeout = 600;
            SQLAdmin.sendOut("Marking {0} replication '{1}' as {2}.", dbname, pubtype, truefalse.ToString());
            pubcmd.CommandText = "sp_replicationdboption";
            pubcmd.CommandType = CommandType.StoredProcedure;
            SqlParameter pubprm1 = pubcmd.Parameters.Add("@dbname", SqlDbType.NVarChar, 128);
            pubprm1.Value = dbname;
            SqlParameter pubprm2 = pubcmd.Parameters.Add("@optname", SqlDbType.NVarChar, 128);
            pubprm2.Value = pubtype;
            SqlParameter pubprm3 = pubcmd.Parameters.Add("@value", SqlDbType.NVarChar, 128);
            pubprm3.Value = truefalse.ToString();
            SqlDataReader pubrdr = SQLLib.getReaderFromSP(pubcmd);
            if (pubrdr == null)
            {
                SQLAdmin.sendOut("Failed to mark database replication option.");
            }
            else
            {
                success = true;
                string evt = string.Format("Set replication {0} option '{1}' as {2}.", dbname, pubtype, truefalse.ToString());
                SQLAdmin.logEvent(srvname, evt);
            }
            SQLLib.disposeReader(pubrdr);
            pubcmd.Parameters.Clear();
            return success;
        }

        internal static bool stopJob(SqlConnection SQLConn, string jobName, bool output)
        {
            bool success = false;
            if (changeDatabase(SQLConn, "msdb"))
            {
                JBInfo jbinf = new JBInfo(SQLConn, jobName);
                if (jbinf.CurrentRunStatus != "Idle")
                {
                    SQLAdmin.sendOut("Stopping job '{0}'.", jobName);
                    SqlCommand cmd = new SqlCommand();
                    cmd.Connection = SQLConn;
                    cmd.CommandText = "sp_stop_job";
                    cmd.CommandType = CommandType.StoredProcedure;
                    SqlParameter prmr = cmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
                    prmr.Direction = ParameterDirection.ReturnValue;
                    SqlParameter prm1 = cmd.Parameters.Add("@job_name", SqlDbType.NVarChar, 128);
                    prm1.Value = jobName;
                    if (SQLLib.executeStoredProc(cmd, true))
                    {
                        success = true;
                        string evt = string.Format("SQLAdmin stopped job '{0}'.", jobName);
                        SQLAdmin.logEvent(SQLConn.DataSource, evt);
                    }
                    Thread.Sleep(1000);
                }
                else
                {
                    SQLAdmin.sendOut("Not stopping job '{0}' due to current status of 'Idle'.{1}", jobName, Environment.NewLine);
                    success = true;
                }
                if (output)
                    outputJobInfo(jobName, SQLConn);
            }
            return success;
        }

        internal static bool updateJob(SqlConnection con, string jbname, string parmname, string parmtype, string parmval)
        {
            bool success = false;
            SQLAdmin.sendOut("Setting {0} to '{1}' on job '{2}'.", parmname, parmval, jbname);
            SQLLib.changeDatabase(con, "msdb");
            SqlCommand cmd = new SqlCommand();
            cmd.Connection = con;
            cmd.CommandText = "sp_update_job";
            cmd.CommandType = CommandType.StoredProcedure;
            SqlParameter prmr = cmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            prmr.Direction = ParameterDirection.ReturnValue;
            SqlParameter prm1 = cmd.Parameters.Add("@job_name", SqlDbType.NVarChar, 128);
            prm1.Value = jbname;
            SqlParameter prm2;
            switch (parmtype)
            {
                case "tinyint" :
                    prm2 = cmd.Parameters.Add(parmname, SqlDbType.TinyInt);
                    prm2.Value = Convert.ToInt16(parmval);
                    break;
                case "smallint" :
                    prm2 = cmd.Parameters.Add(parmname, SqlDbType.SmallInt);
                    prm2.Value = Convert.ToInt16(parmval);
                    break;
                case "bigint" :
                    prm2 = cmd.Parameters.Add(parmname, SqlDbType.BigInt);
                    prm2.Value = Convert.ToInt64(parmval);
                    break;
                case "int" :
                    prm2 = cmd.Parameters.Add(parmname, SqlDbType.Int);
                    prm2.Value = Convert.ToInt32(parmval);
                    break;
                default:
                    prm2 = cmd.Parameters.Add(parmname, SqlDbType.NVarChar, 128);
                    prm2.Value = parmval;
                    break;
            }
            prm2.Value = parmval;
            if (SQLLib.executeStoredProc(cmd, true))
            {
                success = true;
                string evt = string.Format("SQLAdmin updated job '{0}', setting value {1} to '{2}'.", jbname, parmname, parmval);
                SQLAdmin.logEvent(con.DataSource, evt);
            }
            return success;
        }

        internal static bool updateJobStep(SqlConnection con, string jobName, int stepID, string parmname, string parmtype, string parmval)
        {
            bool success = false;
            SQLAdmin.sendOut("Setting {0} to '{1}' on job '{2}', step {3}.", parmname, parmval.ToString(), jobName, stepID.ToString());
            SqlCommand cmd = new SqlCommand();
            cmd.Connection = con;
            cmd.CommandText = "msdb.dbo.sp_update_jobstep";
            cmd.CommandType = CommandType.StoredProcedure;
            SqlParameter prmr = cmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            prmr.Direction = ParameterDirection.ReturnValue;
            SqlParameter prm1 = cmd.Parameters.Add("@job_name", SqlDbType.NVarChar, 128);
            prm1.Value = jobName;
            SqlParameter prm2 = cmd.Parameters.Add("@step_id", SqlDbType.Int);
            prm2.Value = stepID;
            SqlParameter prm3;
            switch (parmtype)
            {
                case "tinyint":
                    prm3 = cmd.Parameters.Add(parmname, SqlDbType.TinyInt);
                    prm3.Value = Convert.ToInt16(parmval);
                    break;
                case "smallint":
                    prm3 = cmd.Parameters.Add(parmname, SqlDbType.SmallInt);
                    prm3.Value = Convert.ToInt16(parmval);
                    break;
                case "bigint":
                    prm3 = cmd.Parameters.Add(parmname, SqlDbType.BigInt);
                    prm3.Value = Convert.ToInt64(parmval);
                    break;
                case "int":
                    prm3 = cmd.Parameters.Add(parmname, SqlDbType.Int);
                    prm3.Value = Convert.ToInt32(parmval);
                    break;
                default:
                    prm3 = cmd.Parameters.Add(parmname, SqlDbType.NVarChar, 128);
                    prm3.Value = parmval;
                    break;
            }
            if (SQLLib.executeStoredProc(cmd, true))
            {
                success = true;
                string evt = string.Format("SQLAdmin updated job '{0}', step {1}, setting value {2} to '{3}'.", jobName, stepID.ToString(), parmname, parmval);
                SQLAdmin.logEvent(con.DataSource, evt);
            }
            return success;
        }

        internal static bool verifyFolder(string folderstr)
        {
            bool success = false;
            if (Directory.Exists(folderstr))
            {
                success = true;
            }
            else
            {
                try
                {
                    Console.WriteLine("Could not find folder '{0}'.  Creating folder.", folderstr);
                    Directory.CreateDirectory(folderstr);
                    success = true;
                }
                catch (SystemException e)
                {
                    Console.WriteLine("Error creating folder {0}:", folderstr);
                    Console.WriteLine(e.Message);
                }
            }
            return success;
        }

        internal static bool verifyReader(SqlDataReader rdr)
        {
            bool isready = verifyReader(rdr, true);
            return isready;
        }

        internal static bool verifyReader(SqlDataReader rdr, bool outputstatus)
        {
            bool isready = false;
            if (rdr == null)
            {
                if (outputstatus)
                    Console.WriteLine("SqlDataReader is null.");
            }
            else
            {
                if (rdr.IsClosed)
                {
                    if (outputstatus)
                        Console.WriteLine("SqlDataReader is closed.");
                }
                else
                {
                    if (rdr.HasRows)
                    {
                        isready = true;
                    }
                    else
                    {
                        if (outputstatus)
                            Console.WriteLine("Query returned no rows.");
                    }
                }
            }
            return isready;
        }

        internal static bool waitForJob(SqlConnection sqlcon, string jb, string waitstatus, int secinterval, int maxretries, bool output)
        {
            return waitForJob(sqlcon, jb, waitstatus, secinterval, maxretries, string.Empty, output);
        }

        internal static bool waitForJob(SqlConnection sqlcon, string jb, string waitstatus, int secinterval, int maxretries, string intendedoutcome, bool output)
        {
            bool success = false;
            int msinterval = secinterval * 1000;
            int counter = 0;
            string msg;
            // instantiate a JbInfo object
            JBInfo jobinf = new JBInfo(sqlcon, jb);
            if (jobinf.Name == null)
            {
                Console.WriteLine("No job for which to wait.");
            }
            else
            {
                if (output)
                {
                    Console.WriteLine("Waiting for status of {0} on job '{1}'", waitstatus, jobinf.Name);
                    if (intendedoutcome != string.Empty)
                        Console.WriteLine("with outcome of '{0}'.", intendedoutcome);
                }
                do
                {
                    jobinf.Refresh();
                    Console.WriteLine("{1}Updated: {0}", DateTime.Now.ToString(), Environment.NewLine);
                    msg = jobinf.CurrentRunStatus;
                    if (msg == "Executing")
                    {
                        msg += " Step " + jobinf.CurrentRunStep;
                    }
                    Console.WriteLine("Status : {0}", msg);
                    if ((jobinf.CurrentRunStatus != waitstatus) & (counter < maxretries))
                    {
                        Thread.Sleep(msinterval);
                        counter++;
                    }
                    // prevent hang when waiting for state of "Running" where run has already taken place
                    if (waitstatus == "Running")
                    {
                        Console.WriteLine("check!");
                    }
                } while ((jobinf.CurrentRunStatus != waitstatus) & (counter < maxretries));
            }
            if (jobinf.CurrentRunStatus == waitstatus)
            {
                if (intendedoutcome == string.Empty)
                {
                    // no intended outcome means that just the wait state being reached is success
                    success = true;
                }
                else
                {
                    // if there's an intended outcome, it must match the job outcome for success
                    if (intendedoutcome.ToUpper() == jobinf.LastRunOutcome.ToUpper())
                        success = true;
                }
                Console.WriteLine();
                SQLLib.outputJobInfo(jobinf.Name, sqlcon);
            }
            else
            {
                if (output)
                {
                    Console.WriteLine("Job failed to enter a state of {0}{1}", waitstatus, Environment.NewLine);
                }
            }
            return success;
        }

        internal static void waitForSPID(SqlConnection con, string cmdtype, int secinterval, bool outputprogress)
        {
            SQLAdmin.sendOut("Waiting for SPID executing '{0}' to stop.", cmdtype);
            int session = 0;        // initial values for session and last session are different so that 
            int lastsession = -1;   // if we don't get results, the loop will not commence its work.
            int perint = 0;
            string perstr = string.Empty;
            string qrytext = string.Format("SELECT percent_complete, session_id, total_elapsed_time, estimated_completion_time FROM sys.dm_exec_requests WHERE command = '{0}'", cmdtype);
            float percent = 0;
            float lastpercent = 0;
            int elapsedtime_ms = 0;
            string elapsedtime = string.Empty;
            decimal msfromnow = 0;
            string timefromnow = string.Empty;
            int secssincelastout = 0;
            string msg = string.Empty;
            SqlDataReader rdr = getReaderFromSql(con, qrytext);
            // initialize the session value
            if (verifyReader(rdr, false))
            {
                // set the two values equal
                session = getInt16FromReader(rdr, 1);
                lastsession = session;
                if (outputprogress)
                {
                    percent = getFloatFromReader(rdr); // this is the percent against which to compare.
                    try
                    {
                        perint = Convert.ToInt32(percent);
                    }
                    catch (SystemException)
                    {
                        perint = 0;
                    }
                    perstr = perint.ToString().PadLeft(3, ' ');
                    Console.WriteLine("'{0}' command is {1} percent complete.", cmdtype, perstr);
                    lastpercent = percent;
                }
            }
            while (session == lastsession)
            {
                // send the output, if called for
                if (outputprogress)
                {
                    percent = getFloatFromReader(rdr); // this is the percent against which to compare.
                    secssincelastout++;
                    if (percent - lastpercent > 5)
                    {
                        try
                        {
                            perint = Convert.ToInt32(percent);
                        }
                        catch (SystemException)
                        {
                            perint = 0;
                        }
                        perstr = perint.ToString().PadLeft(3, ' ');
                        Console.WriteLine("'{0}' command is {1} percent complete.", cmdtype, perstr);
                        lastpercent = percent;
                        secssincelastout = 0;
                    }
                    else if(secssincelastout >= secinterval)
                    {
                        elapsedtime_ms = getInt32FromReader(rdr, 2);                // get current elapsed time
                        elapsedtime = getTimeStrFromMs(elapsedtime_ms);
                        if (percent > 0)
                        {
                            // calculate estimated time to completion
                            msfromnow = getInt64FromReader(rdr, 3);  // estimated ms from now at completion, according to sys.dm_exec_requests
                            timefromnow = getTimeStrFromMs(Convert.ToInt32(msfromnow));
                            perint = Convert.ToInt32(percent);
                            perstr = percent.ToString().PadLeft(9, ' ');
                        }
                        Console.WriteLine("'{0}' command is {1} percent complete.", cmdtype, perstr);
                        msg = string.Format("Current elapsed time is {0}.", elapsedtime);
                        if (percent > 0)
                            msg = string.Format("{0}  Est. completion in {1}.", msg, timefromnow, Environment.NewLine);
                        Console.WriteLine(msg);
                        Console.WriteLine();
                        lastpercent = percent;
                        secssincelastout = 0;
                    }
                }
                // wait a second
                Thread.Sleep(1000);
                // close and re-query the reader
                rdr.Close();
                rdr = getReaderFromSql(con, qrytext);
                if (verifyReader(rdr, false)) // SQLDataReader must be open and have rows
                {
                    // the loop will repeat if this value is unchanged from the start
                    lastsession = getInt16FromReader(rdr, 1);
                }
                else
                {
                    lastsession = -1; // the loop will not repeat if the reader isn't verified
                }
            }
            SQLAdmin.sendOut("SPID is not running.");
            disposeReader(rdr);
        }

        internal static bool mirroringExists(SqlConnection con, string dbname)
        {
            bool exists = false;
            string cmd = "select 1";
            cmd += " from sys.database_mirroring m";
            cmd += " inner join sys.databases d";
            cmd += " on m.database_id = d.database_id";
            cmd = string.Format("{0} where d.name = '{1}'", cmd, dbname);
            cmd += " and mirroring_guid is not null;";
            SqlDataReader rdr = getReaderFromSql(con, cmd);
            if (verifyReader(rdr, false))
                exists = true;
            disposeReader(rdr);
            return exists;
        }
    }

    internal class DBInfo
    {
        SqlConnection conn = new SqlConnection();
        string dbname;
        bool dbexists;
        bool issystemdb = false;
        bool ispublished = false;
        double lsizeinmb = 0;
        decimal logsizeinmb = 0;
        double lpercentused = 0;
        decimal logpercentused = 0;
        double lusedinmb = 0;
        decimal logusedinmb = 0;
        decimal dsizeinmb = 0;
        decimal datasizeinmb = 0;
        decimal dusedinmb = 0;
        decimal datausedinmb = 0;
        decimal dpercentused = 0;
        decimal datapercentused = 0;
        internal bool DBExists
        {
            get
            {
                return dbexists;
            }
        }
        internal string Name
        {
            get
            {
                return dbname;
            }
        }
        internal bool IsSystem
        {
            get
            {
                return issystemdb;
            }
        }
        internal bool IsPublished
        {
            get
            {
                return ispublished;
            }
        }
        internal decimal DataSizeInMB
        {
            get
            {
                return datasizeinmb;
            }
        }

        internal decimal DataUsedInMB
        {
            get
            {
                return datausedinmb;
            }
        }

        internal decimal DataPercentUsed
        {
            get
            {
                return datapercentused;
            }
        }

        internal decimal LogSizeInMB
        {
            get
            {
                return logsizeinmb;
            }
        }

        internal decimal LogUsedInMB
        {
            get
            {
                return logusedinmb;
            }
        }

        internal decimal LogPercentUsed
        {
            get
            {
                return logpercentused;
            }
        }

        internal DBInfo(string db, SqlConnection passedcon)
        {
            conn = passedcon;
            dbname = db;
            string cmdtext = String.Format("SELECT * FROM sys.databases WHERE name = '{0}'", db);
            SqlDataReader rdr = SQLLib.getReaderFromSql(conn, cmdtext);
            if (SQLLib.verifyReader(rdr, false))
            {
                dbexists = true;
                dbname = SQLLib.getStringFromReader(rdr, 0);
                // There should be some way of distinguishing system DBs in the catalog views.
                // Until I find it, there are always the database names...
                if (dbname == "master" || dbname == "model" || dbname == "msdb" || dbname == "tempdb")
                {
                    issystemdb = true;
                }
                // the DB is published if its "is_published" or "is_merge_published" values in sys.databases are true
                ispublished = SQLLib.getBoolFromReader(rdr, 43) || SQLLib.getBoolFromReader(rdr, 45);
            }
            SQLLib.disposeReader(rdr);
        }

        internal void getUsage()
        {
            if (SQLLib.changeDatabase(conn, dbname))
            {
                string cmd = "DBCC SHOWFILESTATS";
                SqlDataReader drd = SQLLib.getReaderFromSql(conn, cmd);
                long intExtents = 0;
                long intExtentsUsed = 0;
                if (SQLLib.verifyReader(drd))
                {
                    // add the extent results for each file to the total
                    while (drd.Read())
                    {
                        try
                        {
                            intExtents += drd.GetInt64(2);
                            intExtentsUsed += drd.GetInt64(3);
                        }
                        catch (InvalidCastException)
                        {
                            intExtents += drd.GetInt32(2);
                            intExtentsUsed += drd.GetInt32(3);
                        }
                    }
                    drd.Close();
                    // convert from extents to MB
                    dsizeinmb = Convert.ToDecimal(intExtents) / 16;
                    dusedinmb = Convert.ToDecimal(intExtentsUsed) / 16;
                    dpercentused = Convert.ToDecimal(intExtentsUsed) / Convert.ToDecimal(intExtents) * 100;
                    // convert to decimal
                    datasizeinmb = Convert.ToDecimal(dsizeinmb.ToString("F1"));
                    datausedinmb = Convert.ToDecimal(dusedinmb.ToString("F1"));
                    datapercentused = Convert.ToDecimal(dpercentused.ToString("F1"));
                }
                // get log space usage data
                cmd = "DBCC SQLPERF(LOGSPACE)";
                SqlDataReader rdr = SQLLib.getReaderFromSql(conn, cmd);
                if (SQLLib.verifyReader(rdr))
                {
                    while (rdr.Read())
                    {
                        if (rdr.GetString(0) == dbname)
                        {
                            lsizeinmb = Convert.ToDouble(rdr.GetValue(1));
                            lpercentused = Convert.ToDouble(rdr.GetValue(2));
                            // derive all log usage data FROM DBCC SQLPERF results
                            lusedinmb = lsizeinmb * lpercentused / 100;
                            logsizeinmb = Convert.ToDecimal(lsizeinmb.ToString("F1"));
                            logpercentused = Convert.ToDecimal(lpercentused.ToString("F1"));
                            logusedinmb = Convert.ToDecimal(lusedinmb.ToString("F1"));
                        }
                    }
                }
                SQLLib.disposeReader(rdr);
            }
        }
    }

    public class JBInfo
    {
        string currentrunstatus = string.Empty;
        string currentrunstep = string.Empty;
        bool exists = false;
        bool isenabled = false;
        int stepcount = 0;
        string jobid = string.Empty;
        string jobname = string.Empty;
        string lastresult = string.Empty;
        string lastrundate = string.Empty;
        string lastrunoutcome = string.Empty;
        string lastrunduration = string.Empty;
        string nextrundate = string.Empty;
        string originatingserver = string.Empty;
        string server = string.Empty;
        string eventloglevel = string.Empty;
        string owner = string.Empty;
        internal string CurrentRunStatus
        {
            get
            {
                return currentrunstatus;
            }
        }
        internal string CurrentRunStep
        {
            get
            {
                return currentrunstep;
            }
        }
        internal string EventLogLevel
        {
            get
            {
                return eventloglevel;
            }
        }
        internal bool Exists
        {
            get
            {
                return exists;
            }
        }
        internal bool IsEnabled
        {
            get
            {
                return isenabled;
            }
        }
        internal string JobId
        {
            get
            {
                return jobid;
            }
        }
        internal string LastRunDate
        {
            get
            {
                return lastrundate;
            }
        }
        internal string LastRunOutcome
        {
            get
            {
                return lastrunoutcome;
            }
        }
        internal string LastRunDuration
        {
            get
            {
                return lastrunduration;
            }
        }
        internal string Name
        {
            get
            {
                return jobname;
            }
        }
        internal string NextRunDate
        {
            get
            {
                return nextrundate;
            }
        }
        internal int NumberOfSteps
        {
            get
            {
                return stepcount;
            }
        }
        internal string OriginatingServer
        {
            get
            {
                return originatingserver;
            }
        }
        internal string Owner
        {
            get
            {
                return owner;
            }
        }

        internal JBInfo(SqlConnection con, string jb)
        {
            originatingserver = con.DataSource;
            jobname = jb;
            Refresh();
        }

        internal ArrayList getHistory()
        {
            ArrayList events = new ArrayList();
            string histevent = string.Empty;
            int histnumber = -1;
            int joboutcome = -1;
            SqlConnection con = SQLLib.connectToSQL(originatingserver, "msdb");
            SqlCommand cmd = new SqlCommand();
            cmd.Connection = con;
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.CommandText = "sp_help_jobhistory";
            cmd.CommandTimeout = 120;
            SqlParameter retval = cmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            retval.Direction = ParameterDirection.ReturnValue;
            SqlParameter prm1 = cmd.Parameters.Add("@job_name", SqlDbType.NVarChar, 128);
            prm1.Value = jobname;
            SqlParameter prm2 = cmd.Parameters.Add("@mode", SqlDbType.NVarChar, 128);
            prm2.Value = "FULL";
            SqlParameter prm3 = cmd.Parameters.Add("@oldest_first", SqlDbType.Int);
            prm3.Value = 1;
            SqlDataReader rdr = SQLLib.getReaderFromSP(cmd);
            if (SQLLib.verifyReader(rdr))
            {
                while (rdr.Read())
                {
                    histnumber = SQLLib.getInt32FromReader(rdr, 9);
                    histevent = Convert.ToString(histnumber);
                    histnumber = SQLLib.getInt32FromReader(rdr, 10);
                    histevent = string.Format("{0} {1}", histevent, SQLLib.padTime(histnumber));
                    joboutcome = SQLLib.getInt32FromReader(rdr, 8);
                    histevent = string.Format("{0} {1}", histevent, SQLLib.mapJobOutcome(joboutcome));
                    histnumber = SQLLib.getInt32FromReader(rdr, 11);
                    histevent = string.Format("{0} {1}", histevent, SQLLib.padTime(histnumber));
                    histevent = string.Format("{0} {1}", histevent, SQLLib.getStringFromReader(rdr, 4));
                    if (joboutcome==0)
                        histevent = string.Format("{0}{1}{2}", histevent, Environment.NewLine, SQLLib.getStringFromReader(rdr, 7));
                    events.Add(histevent);
                }
            }
            return events;
        }

        internal void Refresh()
        {
            int enabledint;
            string runtime;
            isenabled = false;
            stepcount = 0;
            SqlConnection con = SQLLib.connectToSQL(originatingserver, "msdb");
            SqlCommand cmd = new SqlCommand();
            cmd.Connection = con;
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.CommandText = "sp_help_job";
            cmd.CommandTimeout = 120;
            SqlParameter retval = cmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            retval.Direction = ParameterDirection.ReturnValue;
            SqlParameter prm1 = cmd.Parameters.Add("@job_name", SqlDbType.NVarChar, 2000);
            prm1.Value = jobname;
            SqlDataReader rdr = SQLLib.getReaderFromSP(cmd);
            if (SQLLib.verifyReader(rdr))
            {
                exists = true;
                jobname = SQLLib.getStringFromReader(rdr, 2);
                SqlConnection con2 = SQLLib.connectToSQL(originatingserver, "msdb");
                jobid = SQLLib.getJobIDFromName(con2, jobname);
                try
                {
                    con2.Close();
                    con2.Dispose();
                }
                catch (SystemException e)
                {
                    SQLAdmin.sendOut(e.Message);
                }
                originatingserver = SQLLib.getStringFromReader(rdr, 1);
                currentrunstatus = SQLLib.mapJobStatus(SQLLib.getInt32FromReader(rdr, 25));
                currentrunstep = SQLLib.getStringFromReader(rdr, 26);
                enabledint = SQLLib.getByteFromReader(rdr, 3);
                if (enabledint == 1)
                    isenabled = true;
                runtime = SQLLib.padTime(SQLLib.getInt32FromReader(rdr, 20));
                lastrundate = SQLLib.getInt32FromReader(rdr, 19).ToString() + " " + runtime;
                lastrunoutcome = SQLLib.mapJobOutcome(SQLLib.getInt32FromReader(rdr, 21));
                runtime = SQLLib.padTime(SQLLib.getInt32FromReader(rdr, 23));
                nextrundate = SQLLib.getInt32FromReader(rdr, 22).ToString() + " " + runtime;
                eventloglevel = SQLLib.mapNotifyLevel(SQLLib.getInt32FromReader(rdr, 8));
                owner = SQLLib.getStringFromReader(rdr, 7);
                // forward to the results set we want for last run duration
                try
                {
                    rdr.NextResult();
                    while (rdr.Read())
                        stepcount++;
                    rdr.NextResult();
                    rdr.NextResult();
                    lastrunduration = SQLLib.padTime(SQLLib.getInt32FromReader(rdr, 6));
                }
                catch (SqlException e)
                {
                    SQLAdmin.sendOut("Error attempting to retrieve info for job '{0}':", jobname);
                    SQLAdmin.sendOut(e.Message);
                    jobname = string.Empty;
                }
            }
            else
            {
                jobname = string.Empty;
            }
            SQLLib.disposeReader(rdr);
        }
    }

    internal class LSInfo
    {
        string primaryserver;
        string primarydatabase;
        string secondaryserver;
        string secondarydatabase;
        string backupjobname;
        string copyjobname;
        string restorejobname;
        Int32 backuplatency;
        Int32 backupthreshold;
        Int32 copylatency;
        Int32 restorelatency;
        Int32 restorethreshold;
        Int32 filelatency;
        bool backupalertenabled;
        bool restorealertenabled;
        bool lsstreamexists;
        bool backupcurrent;
        bool copyandrestorecurrent;
        bool status;
        SqlCommand localcmd = new SqlCommand();
        SqlDataReader localrdr = null;
        SqlCommand remotecmd = new SqlCommand();
        SqlDataReader remoterdr = null;
        internal bool Status
        {
            get
            {
                return status;
            }
        }
        internal bool BackupAlertEnabled
        {
            get
            {
                return backupalertenabled;
            }
        }
        internal string BackupJobName
        {
            get
            {
                // get the data if they aren't current
                if (!backupcurrent)
                    getBackupJobName();
                return backupjobname;
            }
        }
        internal Int32 BackupLatency
        {
            get
            {
                return backuplatency;
            }
        }
        internal Int32 BackupThreshold
        {
            get
            {
                return backupthreshold;
            }
        }
        internal string CopyJobName
        {
            get
            {
                // get the data if they aren't current
                if (!copyandrestorecurrent)
                    getCopyAndRestoreJobNames();
                return copyjobname;
            }
        }
        internal Int32 CopyLatency
        {
            get
            {
                return copylatency;
            }
        }
        internal Int32 FileLatency
        {
            get
            {
                return filelatency;
            }
        }
        internal bool LSStreamExists
        {
            get
            {
                return lsstreamexists;
            }
        }
        internal string PrimaryServer
        {
            get
            {
                return primaryserver;
            }
        }
        internal string PrimaryDatabase
        {
            get
            {
                return primarydatabase;
            }
        }
        internal bool RestoreAlertEnabled
        {
            get
            {
                return restorealertenabled;
            }
        }
        internal string RestoreJobName
        {
            get
            {
                // get the data if they aren't current
                if (!copyandrestorecurrent)
                    getCopyAndRestoreJobNames();
                return restorejobname;
            }
        }
        internal Int32 RestoreLatency
        {
            get
            {
                return restorelatency;
            }
        }
        internal Int32 RestoreThreshold
        {
            get
            {
                return restorethreshold;
            }
        }
        internal string SecondaryDatabase
        {
            get
            {
                return secondarydatabase;
            }
        }
        internal string SecondaryServer
        {
            get
            {
                return secondaryserver;
            }
        }
        internal LSInfo(string LSServer)
        {
            // connect to LSServer for the local connection
            SqlConnection localcon = SQLLib.connectToSQL(LSServer, "master");
            localcmd.Connection = localcon;
            localcmd.CommandText = "sp_help_log_shipping_monitor";
            localcmd.CommandType = CommandType.StoredProcedure;
            // run sp_help_log_shipping_monitor to get the local info
            localrdr = SQLLib.getReaderFromSP(localcmd);
        }
        private void getBackupJobName()
        {
            backupjobname = string.Empty;
            SqlConnection bjicon = SQLLib.connectToSQL(primaryserver, "master");
            SqlCommand bjicmd = new SqlCommand();
            bjicmd.Connection = bjicon;
            bjicmd.CommandText = "sp_help_log_shipping_primary_database";
            bjicmd.CommandType = CommandType.StoredProcedure;
            SqlParameter prmr = bjicmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            prmr.Direction = ParameterDirection.ReturnValue;
            SqlParameter prm1 = bjicmd.Parameters.Add("@database", SqlDbType.VarChar, 128);
            prm1.Value = primarydatabase;
            SqlDataReader rdr = SQLLib.getReaderFromSP(bjicmd);
            if (SQLLib.verifyReader(rdr))
            {
                if (rdr.Read())
                {
                    string backupjobid = SQLLib.getGuidFromReader(rdr, 5).ToString();
                    rdr.Close();
                    backupjobname = SQLLib.getJobNameFromID(bjicon, backupjobid);
                    backupcurrent = true;
                }
            }
            SQLLib.disposeReader(rdr);
        }
        private void getCopyAndRestoreJobNames()
        {
            copyjobname = string.Empty;
            restorejobname = string.Empty;
            SqlConnection cjicon = SQLLib.connectToSQL(secondaryserver, "master");
            SqlCommand cjicmd = new SqlCommand();
            cjicmd.Connection = cjicon;
            cjicmd.CommandText = "sp_help_log_shipping_secondary_database";
            cjicmd.CommandType = CommandType.StoredProcedure;
            SqlParameter prmr = cjicmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            prmr.Direction = ParameterDirection.ReturnValue;
            SqlParameter prm1 = cjicmd.Parameters.Add("@secondary_database", SqlDbType.VarChar, 128);
            prm1.Value = secondarydatabase;
            SqlDataReader rdr = SQLLib.getReaderFromSP(cjicmd);
            if (SQLLib.verifyReader(rdr))
            {
                if (rdr.Read())
                {
                    string copyjobid = SQLLib.getGuidFromReader(rdr, 6).ToString();
                    string restorejobid = SQLLib.getGuidFromReader(rdr, 7).ToString();
                    rdr.Close();
                    copyjobname = SQLLib.getJobNameFromID(cjicon, copyjobid);
                    restorejobname = SQLLib.getJobNameFromID(cjicon, restorejobid);
                    copyandrestorecurrent = true;
                }
            }
            SQLLib.disposeReader(rdr);
        }
        internal void resetData()
        {
            status = false;
            lsstreamexists = false;
            backupcurrent = false;
            copyandrestorecurrent = false;
            primaryserver = "UNKNOWN";
            secondaryserver = "UNKNOWN";
            primarydatabase = "UNKNOWN";
            secondarydatabase = "UNKNOWN";
        }
        internal void getPriDataFromReader(SqlDataReader rdr)
        {
            if (!status)
                status = SQLLib.getBoolFromReader(rdr, 0);
            primaryserver = SQLLib.getStringFromReader(rdr, 2);
            primarydatabase = SQLLib.getStringFromReader(rdr, 3);
            secondarydatabase = primarydatabase;
            backuplatency = SQLLib.getInt32FromReader(rdr, 4);
            backupthreshold = SQLLib.getInt32FromReader(rdr, 6);
            backupalertenabled = SQLLib.getBoolFromReader(rdr, 7);
            if (rdr.Read())
                secondaryserver = SQLLib.getStringFromReader(rdr, 2);
        }
        internal void getSecDataFromReader(SqlDataReader rdr)
        {
            if (!status)
                status = SQLLib.getBoolFromReader(rdr, 0);
            secondaryserver = SQLLib.getStringFromReader(rdr, 2);
            secondarydatabase = SQLLib.getStringFromReader(rdr, 3);
            primarydatabase = secondarydatabase;
            copylatency = SQLLib.getInt32FromReader(rdr, 8);
            restorelatency = SQLLib.getInt32FromReader(rdr, 10);
            restorethreshold = SQLLib.getInt32FromReader(rdr, 13);
            restorealertenabled = SQLLib.getBoolFromReader(rdr, 14);
            filelatency = SQLLib.getInt32FromReader(rdr, 12);
        }
        private void goToPrimaryRowForDB(SqlDataReader rdr, string database)
        {
            try
            {
                while (rdr.Read())
                {
                    // verify this is a valid primary row
                    if ((SQLLib.getInt32FromReader(rdr, 4) != -1) & (SQLLib.getInt32FromReader(rdr, 13) == -1))
                    {
                        string dbfromrow = SQLLib.getStringFromReader(rdr, 3);
                        // verify that the database is the one we want
                        if (dbfromrow.ToUpper() == database.ToUpper())
                        {
                            // this is the row we want; break out of the read() loop
                            break;
                        }
                    }
                }
            }
            catch (SystemException e)
            {
                SQLAdmin.sendOut("Error getting primary LS row for DB.");
                SQLAdmin.sendOut(e.Message);
            }
        }
        private void goToSecondaryRowForDB(SqlDataReader rdr, string database)
        {
            try
            {
                while (rdr.Read())
                {
                    // verify this is a valid secondary row
                    if ((SQLLib.getInt32FromReader(rdr, 4) == -1) & (SQLLib.getInt32FromReader(rdr, 13) != -1))
                    {
                        string dbfromrow = SQLLib.getStringFromReader(rdr, 3);
                        // verify that the database is the one we want
                        if (dbfromrow.ToUpper() == database.ToUpper())
                        {
                            // this is the row we want; break out of the read() loop
                            break;
                        }
                    }
                }
            }
            catch (SystemException e)
            {
                SQLAdmin.sendOut("Error getting secondary LS row for DB.");
                SQLAdmin.sendOut(e.Message);
            }
        }
        internal bool Next()
        {
            resetData();
            // verify the primary reader has rows
            if (SQLLib.verifyReader(localrdr))
            {
                // get data from first row
                while (localrdr.Read())
                {
                    // test to see if this row has info we want
                    if (!(SQLLib.getInt32FromReader(localrdr, 4) == -1 & SQLLib.getInt32FromReader(localrdr, 13) == -1))
                    {
                        if (SQLLib.getBoolFromReader(localrdr, 1) == true) // IsPrimary
                        {
                            getPriDataFromReader(localrdr);
                            // connect to the secondary
                            SqlConnection remotecon = SQLLib.connectToSQL(secondaryserver);
                            remotecmd.Connection = remotecon;
                            // get log shipping monitor info
                            remotecmd.CommandText = "sp_help_log_shipping_monitor";
                            remotecmd.CommandType = CommandType.StoredProcedure;
                            remoterdr = SQLLib.getReaderFromSP(remotecmd);
                            // find the secondary row that corresponds with the row we have here
                            goToSecondaryRowForDB(remoterdr, primarydatabase);
                            // get the secondary row info
                            getSecDataFromReader(remoterdr);
                            SQLLib.disposeReader(remoterdr);
                        }
                        else
                        {
                            getSecDataFromReader(localrdr);
                            SqlConnection remotecon = SQLLib.connectToSQL(secondaryserver);
                            SqlCommand remotecmd = new SqlCommand();
                            remotecmd.Connection = remotecon;
                            remotecmd.CommandText = "sp_help_log_shipping_secondary_database";
                            remotecmd.CommandType = CommandType.StoredProcedure;
                            SqlParameter retval = remotecmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
                            retval.Direction = ParameterDirection.ReturnValue;
                            SqlParameter prm1 = remotecmd.Parameters.Add("@secondary_database", SqlDbType.NVarChar, 128);
                            prm1.Value = secondarydatabase;
                            SqlDataReader rdr = SQLLib.getReaderFromSP(remotecmd);
                            if (SQLLib.verifyReader(rdr))
                            {
                                primaryserver = SQLLib.getStringFromReader(rdr, 1);
                                SQLLib.disposeReader(rdr);
                                SqlConnection pricon = SQLLib.connectToSQL(primaryserver);
                                SqlCommand pricmd = new SqlCommand();
                                pricmd.Connection = pricon;
                                pricmd.CommandText = "sp_help_log_shipping_monitor";
                                pricmd.CommandType = CommandType.StoredProcedure;
                                remoterdr = SQLLib.getReaderFromSP(pricmd);
                                goToPrimaryRowForDB(remoterdr, primarydatabase);
                                // get the primary row info
                                getPriDataFromReader(remoterdr);
                                SQLLib.disposeReader(remoterdr);
                            }
                        }
                        lsstreamexists = true;
                        // we have all the information we are going to get on this stream
                        break;  // exit the read loop
                    }
                }
            }
            // we allow the SqlCommand objects to persist so that we can refresh on a moment's notice
            return lsstreamexists;
        }
        internal void Refresh()
        {
            // reset the SqlDataReader object
            // in effect, this resets the log shipping info
            if (SQLLib.verifyReader(localrdr))
            {
                SQLLib.disposeReader(localrdr);
                localrdr = SQLLib.getReaderFromSP(localcmd);
            }
        }
    }

    internal class RPInfo
    {
        string publisherserver;
        string publisherdatabase;
        string distributionserver;
        string distributiondatabase;
        string subscriberserver;
        string subscriberdatabase;
        string publicationname;
        string publicationtype = string.Empty;
        Int32 latency;
        Int32 latencythreshold;
        Int32 subscriptiontype;
        int pendingcmds = -1;
        string status;
        bool rpsubexists;
        SqlCommand cmd = new SqlCommand();
        SqlDataReader rdr = null;
        internal void GetPendingCmds()
        {
            pendingcmds = -1;
            // get pending command count
            SqlConnection pndcon = SQLLib.connectToSQL(distributionserver, distributiondatabase);
            SqlCommand pndcmd = new SqlCommand();
            pndcmd.Connection = pndcon;
            pndcmd.CommandText = "sp_replmonitorsubscriptionpendingcmds";
            pndcmd.CommandType = CommandType.StoredProcedure;
            SqlParameter prmr = pndcmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
            prmr.Direction = ParameterDirection.ReturnValue;
            SqlParameter prm1 = pndcmd.Parameters.Add("@publisher", SqlDbType.VarChar, 128);
            prm1.Value = publisherserver;
            SqlParameter prm2 = pndcmd.Parameters.Add("@publisher_db", SqlDbType.VarChar, 128);
            prm2.Value = publisherdatabase;
            SqlParameter prm3 = pndcmd.Parameters.Add("@publication", SqlDbType.VarChar, 128);
            prm3.Value = publicationname;
            SqlParameter prm4 = pndcmd.Parameters.Add("@subscriber", SqlDbType.VarChar, 128);
            prm4.Value = subscriberserver;
            SqlParameter prm5 = pndcmd.Parameters.Add("@subscriber_db", SqlDbType.VarChar, 128);
            prm5.Value = subscriberdatabase;
            SqlParameter prm6 = pndcmd.Parameters.Add("@subscription_type", SqlDbType.Int);
            prm6.Value = subscriptiontype;
            SqlDataReader pndrdr = SQLLib.getReaderFromSP(pndcmd);
            if (SQLLib.verifyReader(pndrdr))
            {
                pendingcmds = SQLLib.getInt32FromReader(pndrdr, 0);
            }
        }
        internal int PendingCmds
        {
            get
            {
                return pendingcmds;
            }
        }
        internal string PublisherServer
        {
            get
            {
                return publisherserver;
            }
        }
        internal string PublisherDatabase
        {
            get
            {
                return publisherdatabase;
            }
        }
        internal string PublicationName
        {
            get
            {
                return publicationname;
            }
        }
        internal string SubscriberServer
        {
            get
            {
                return subscriberserver;
            }
        }
        internal string SubscriberDatabase
        {
            get
            {
                return subscriberdatabase;
            }
        }
        internal Int32 SubscriptionType
        {
            get
            {
                return subscriptiontype;
            }
        }
        internal Int32 Latency
        {
            get
            {
                return latency;
            }
        }
        internal Int32 LatencyThreshold
        {
            get
            {
                return latencythreshold;
            }
        }
        internal string Status
        {
            get
            {
                return status;
            }
        }
        internal string PublicationType
        {
            get
            {
                return publicationtype;
            }
        }
        internal bool RPSubExists
        {
            get
            {
                return RPSubExists;
            }
        }
        internal RPInfo(string RPServer, string pubtype)
        {
            // this gets the datareader object with the results of sp_help_log_shipping_monitor
            // you'll need to invoke the Next() method to get the first row
            publicationtype = pubtype;
            publisherserver = RPServer;
            distributionserver = SQLLib.getDistSvr(RPServer);
            if (distributionserver != string.Empty)
            {
                distributiondatabase = SQLLib.getDistDB(distributionserver);
                if (distributiondatabase != string.Empty)
                {
                    SqlConnection sqlcon = SQLLib.connectToSQL(distributionserver, "master");
                    cmd.Connection = sqlcon;
                    Refresh();
                }
            }
        }
        internal void Dispose()
        {
            // reset the SqlDataReader object
            SQLLib.disposeReader(rdr);
        }
        internal void Refresh()
        {
            // reset the SqlDataReader object
            // in effect, this resets the replication info
            if (rdr != null)
            {
                if (!rdr.IsClosed)
                    rdr.Close();
            }
            switch (publicationtype)
            {
                case "Transactional":
                    rdr = SQLLib.getReplMonitorSubscriptions(publisherserver, distributionserver, distributiondatabase, 0, false);
                    break;
                case "Snapshot":
                    rdr = SQLLib.getReplMonitorSubscriptions(publisherserver, distributionserver, distributiondatabase, 1, false);
                    break;
                case "Merge":
                    rdr = SQLLib.getReplMonitorSubscriptions(publisherserver, distributionserver, distributiondatabase, 2, false);
                    break;
                default:
                    SQLAdmin.sendOut("Invalid publication type passed to RPInfo: '{0}'", publicationtype);
                    break;
            }
        }
        internal bool Next()
        {
            rpsubexists = false;
            if (SQLLib.verifyReader(rdr, false))
            {
                // get data from next row
                if (rdr.Read())
                {
                    // get the property values from the stored procedure results
                    status = SQLLib.mapSubStatus((SQLLib.getInt32FromReader(rdr, 0)));
                    subscriberserver = SQLLib.getStringFromReader(rdr, 2);
                    subscriberdatabase = SQLLib.getStringFromReader(rdr, 3);
                    publisherdatabase = SQLLib.getStringFromReader(rdr, 4);
                    publicationname = SQLLib.getStringFromReader(rdr, 5);
                    subscriptiontype = SQLLib.getInt32FromReader(rdr, 7);
                    latency = SQLLib.getInt32FromReader(rdr, 8);
                    latencythreshold = SQLLib.getInt32FromReader(rdr, 9);
                    rpsubexists = true;
                }
            }
            return rpsubexists;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\GAST\gast.cs ===
using System;
using System.Diagnostics;
using System.ComponentModel;
using System.Management;
using System.Data;
using System.Data.SqlClient;

namespace GAST
{
	/// <summary>
    /// Quick, easy diagnostic of SQL Server
	/// </summary>
	class GAST
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static int Main(string[] args)
		{
			String strMsg = "";
			Boolean blnSuccess = false;
			String strStartDate = "";
			DateTime startTime = DateTime.Now;
			int i = 0;
			String[] arrDBs = new String[32767];
			if (args.Length < 1)
			{
				Usage();
				return 1;
			}
			sendOut ("");
			sendOut ("GAST runtime: " + startTime);
			sendOut ("");
			if (args[0] == "/?")
			{
				Usage();
				return 0;
			}
			String server = args[0];
			// Report the server name
			sendOut ("SERVER  : " + server.ToUpper());
			sendOut ("");
			sendOut ("NETWORK CONNECTIVITY:");
            if (verifyConn(server))
            {
                reportOSVersion(server);
                string[] svcarray = new string[] { "MSSQLSERVER", "SQLSERVERAGENT", "msftesql", "MSSEARCH", "WstAgent", "MSSQLServerOLAPService", "MSDTC", "MsDtsServer" };
                if (verifyServices(server, svcarray, "MSSQLSERVER", "SQLSERVERAGENT"))
                {
                    // conduct the rest of the tests
                    sendOut("CONNECTING TO SQL SERVER:");
                    SqlConnection sqlConn = connectToADO(server, "master");
                    if (sqlConn.State.ToString() == "Open")
                    {

                        SqlCommand sqlCmd = sqlConn.CreateCommand();
                        // get the version from SQL Server
                        sqlCmd.CommandText = "SELECT @@version";
                        SqlDataReader sqlDR = sqlCmd.ExecuteReader();
                        sqlDR.Read();
                        strMsg = sqlDR.GetString(0);
                        // separate the version info from everything that follows
                        string[] arrMsg = strMsg.Split(new Char[] { '(' });
                        // output the version
                        sendOut(arrMsg[0]);
                        sqlDR.Close();
                        sqlCmd.CommandText = "SELECT COUNT(*) FROM sysprocesses";
                        sqlDR = sqlCmd.ExecuteReader();
                        sqlDR.Read();
                        strMsg = "\r\nTOTAL PROCESSES  : " + sqlDR.GetSqlInt32(0).ToString();
                        sendOut(strMsg);
                        sqlDR.Close();
                        sqlCmd.CommandText = "SELECT COUNT(*) FROM sysprocesses WHERE BLOCKED <> 0";
                        sqlDR = sqlCmd.ExecuteReader();
                        sqlDR.Read();
                        strMsg = "BLOCKED PROCESSES: " + sqlDR.GetSqlInt32(0).ToString();
                        sendOut(strMsg);
                        sqlDR.Close();
                        sendOut("\r\nDATABASES on " + sqlConn.DataSource);     // Prepare to list the database output
                        sendOut("\r\nDatabase                           Status    Access     %Data Used %Log Used");
                        sendOut("---------------------------------- --------- ---------- ---------- ---------");
                        sqlCmd.CommandText = "SELECT name, crdate FROM sysdatabases ORDER BY name";
                        sqlDR = sqlCmd.ExecuteReader();
                        if (sqlDR.HasRows)
                        {
                            i = 0;
                            while (sqlDR.Read())
                            {
                                arrDBs[i] = sqlDR.GetString(0);
                                if (arrDBs[i] == "tempdb")
                                {
                                    strStartDate = sqlDR.GetDateTime(1).ToString();
                                }
                                i++;
                            }
                        }
                        sqlDR.Close();
                        for (int j = 0; j < i; j++)
                        {
                            DBInfo dbi = new DBInfo(sqlConn, arrDBs[j]);
                            dbi.getUsage(sqlConn);
                            dbOutput(dbi.Name, dbi.Status, dbi.Access, dbi.DataPercentUsed, dbi.LogPercentUsed);
                        }
                        sqlConn.Close();
                        blnSuccess = true;
                    }
                    else
                    {
                        logFailure(server, "SQL Server connectivity");
                    }
                }
            }
            else
            {
                logFailure(server, "network connectivity");
            }
			if (blnSuccess) 
			{
				DateTime endTime = DateTime.Now;
				TimeSpan elapsed = endTime.Subtract(startTime);
				sendOut ("\r\nSQL Server start time: " + strStartDate);
				string output = "\r\nGAST elapsed time: " + elapsed.Seconds + " second";
				if (elapsed.Seconds != 1)
				{
					output += "s";
				}
				output += "\r\n";
				sendOut (output);
				sendOut ("All tests passed.");
				return 0;
			}
			else 
			{
				return 1;
			}
		}

		/********************************************************************
		Purpose:Send the output for this database back to the user.
		Inputs :strDBName     : Name of the database
				strDBStatus   : Current status of the database
				strLastBackup : Last date/time the DB was backed up
				dblDataPercent: Percent usage on the database's data files
				dblLogPercent : Percent usage on the database's log files
		********************************************************************/
		public static void dbOutput(string strDBName, string strDBStatus, string strDBAccess, decimal dblDataPercent, decimal dblLogPercent) 
		{
			String strPercent = "";
			// format the database output information
            strDBName = strDBName.PadRight(35, ' ');
            strDBStatus = strDBStatus.PadRight(10, ' ');
            strDBAccess = strDBAccess.PadRight(10, ' ');
			if (strDBStatus == "Unknown")
			{
				strPercent = "      Unknown";
			}
			else 
			{
                String strDataPercent = dblDataPercent.ToString().PadLeft(11, ' ');
                String strLogPercent = dblLogPercent.ToString().PadLeft(10, ' ');
				strPercent = strDataPercent + strLogPercent;
			}
			// send the formatted information to the console
			sendOut (strDBName + strDBStatus + strDBAccess + strPercent);
		}

		/****************************************************************
		Purpose: Log GAST failure to command prompt and Windows Event Log
		Inputs : target     : server against which GAST failed
				 strErrType : Last date/time the DB was backed up
		****************************************************************/
		public static void logFailure(string target, string strErrType) 
		{
			// send output to console
			sendOut ("\r\nTest fails.\r\n");
			// log an Information event in the application event log
			string sSource;
			string sLog;
			string sEvent;
			sSource = "GAST";
			sLog = "Application";
			sEvent = "GAST failed against SQL Server " + target;
			sEvent += "\r\nbecause it detected a problem with " + strErrType + ".\r\n";
			sEvent += "GAST user: " + Environment.UserDomainName;
			sEvent += "\\" + Environment.UserName;
			if (!EventLog.SourceExists(sSource))
				EventLog.CreateEventSource(sSource,sLog);
			EventLog.WriteEntry(sSource, sEvent);
		}

		public static bool reportOSVersion(string servername)
		{
            bool success = false;
			ManagementScope ms = new ManagementScope(
				"\\\\" + servername + "\\root\\cimv2");
            try
            {
                ms.Connect();
                WqlObjectQuery wqlQuery =
                    new WqlObjectQuery("Select Version From Win32_OperatingSystem");
                ManagementObjectSearcher searcher =
                    new ManagementObjectSearcher(wqlQuery);
                searcher.Scope = ms;
                foreach (ManagementObject svc in searcher.Get())
                {
                    sendOut("WINDOWS VERSION: " + svc.GetPropertyValue("Version").ToString() + "\r\n");
                    success = true;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Error accessing O/S on server {0}:\r\n{1}", servername, e.Message);
                return success;
            }
            return success;
		}

		public static bool verifyServices(string servername, string[] svcs, string sqlServerSvc, string sqlAgentSvc) 
		{
			Boolean success = false;
			Boolean sqlInstalled = false;
			Boolean sqlRunning = false;
			Boolean agentRunning = false;
			Boolean wstRunning = true;
            Boolean noconnect = false;
			String WmiQuery = "SELECT * FROM Win32_Service";
			WmiQuery += " WHERE Name = '" + svcs[0] + "'";
			for (int i=1; i < svcs.Length; i++) {
				WmiQuery += " OR Name = '" + svcs[i] + "'";
			}
			ManagementScope ms = new ManagementScope(
				"\\\\" + servername + "\\root\\cimv2");
            try
            {
                ms.Connect();
            }
            catch (SystemException ex)
            {
                noconnect = true;
                Console.WriteLine("Error attempting to get service information:");
                Console.WriteLine(ex.Message);
            }
            if (!noconnect)
            {
                WqlObjectQuery wqlQuery =
                    new WqlObjectQuery(WmiQuery);
                ManagementObjectSearcher searcher =
                    new ManagementObjectSearcher(wqlQuery);
                searcher.Scope = ms;
                sendOut("Service                    State         StartMode Login Account");
                sendOut("-------------------------- ------------- --------- ---------------------------");
                // scroll through the service instances, looking for the names of services that interest us.
                foreach (ManagementObject svc in searcher.Get())
                {
                    string strOutput = svc.GetPropertyValue("Name").ToString().PadRight(27, ' ');
                    strOutput += svc.GetPropertyValue("State").ToString().PadRight(14);
                    strOutput += svc.GetPropertyValue("StartMode").ToString().PadRight(10);
                    strOutput += svc.GetPropertyValue("StartName").ToString();
                    sendOut(strOutput);
                    if (svc.GetPropertyValue("Name").ToString() == sqlServerSvc)
                    {
                        sqlInstalled = true;
                        if (svc.GetPropertyValue("State").ToString() == "Running")
                        {
                            sqlRunning = true;
                        }
                    }
                    if (svc.GetPropertyValue("Name").ToString() == sqlAgentSvc)
                    {
                        if (svc.GetPropertyValue("State").ToString() == "Running")
                        {
                            agentRunning = true;
                        }
                    }
                    // WST service is handled differently because it won't necessarily exist.
                    if (svc.GetPropertyValue("Name").ToString() == "WstAgent")
                    {
                        if (svc.GetPropertyValue("State").ToString() != "Running")
                        {
                            wstRunning = false;
                        }
                    }
                }
                sendOut("");
                if (!sqlInstalled)
                {
                    sendOut("Service " + sqlServerSvc + " is not installed.");
                    if (sqlServerSvc != "MSSQLSERVER")
                    { // if it's a named instance we're looking for . . .
                        sendOut("Check the spelling of the instance.");
                    }
                    logFailure(servername, "SQL Server installation");
                }
                else
                {
                    if (!sqlRunning)
                    {
                        sendOut("Service " + sqlServerSvc + " is not running!");
                        logFailure(servername, "SQL Server service status");
                    }
                    else
                    {
                        if (!agentRunning)
                        {
                            sendOut("Service " + sqlAgentSvc + " is not running.");
                            logFailure(servername, "SQL Server Agent service status");
                        }
                        else
                        {
                            if (!wstRunning)
                            {
                                sendOut("WST Agent is not running.");
                                logFailure(servername, "WST Agent service status");
                            }
                        }
                    }
                }
                success = (sqlInstalled && sqlRunning && agentRunning && wstRunning);
            }
            else
            {
                success = true;
            }
			return success;
		}
	
		public static bool verifyConn(string servername)
		{
			Process pingProc = new Process();
			Boolean success = new bool();
			success = false;
			sendOut ("Pinging server.");
			pingProc.StartInfo.UseShellExecute = false;
			pingProc.StartInfo.RedirectStandardOutput = true;
			pingProc.StartInfo.FileName = "Ping.exe";
			pingProc.StartInfo.Arguments = "/n 2 " + servername;
			pingProc.Start();
			string output = pingProc.StandardOutput.ReadToEnd();
			pingProc.WaitForExit();
			if(output.IndexOf("Reply from") == -1)
			{
				sendOut(output);
				sendOut ("CANNOT PING SERVER!  (This is not a SQL Server issue.)");
			} 
			else 
			{
				sendOut("Passed");
			}
			sendOut ("Net viewing server.");
			pingProc.StartInfo.FileName = "Net.exe";
			pingProc.StartInfo.Arguments = "view " + servername;
			pingProc.StartInfo.RedirectStandardError = true;
			pingProc.Start();
			output = pingProc.StandardOutput.ReadToEnd();
			string errors = pingProc.StandardError.ReadToEnd();
			pingProc.WaitForExit();
			if (errors.Length > 0) 
			{
				sendOut (errors);
				sendOut ("CANNOT NET VIEW SERVER!  (This is not a SQL Server issue.)");
			} 
			else 
			{
				sendOut("Passed");
				sendOut("");
				success = true;
			}
			return success;
		}

		public static void Usage()
		{
			sendOut ("Usage: GAST servername");
			sendOut ("");
			sendOut ("For a named instance: GAST servername\\instancename");
			sendOut ("");
			sendOut ("Make sure you have trusted connection privileges on the SQL Server.");
			sendOut ("GAST is case insensitive.");
			sendOut ("");
			sendOut ("Example: gast TestServer");
			sendOut ("Named Instance Example: gast TestServer\\SQLInstance");
			sendOut ("");
		}

		static SqlConnection connectToADO(string strServer, string strDatabase) 
		{
			// declare and open a connection to the server
			// use master DB because DB we are measuring might not be available
			SqlConnection con = new SqlConnection ("Data Source=" + strServer + ";Initial Catalog=" + strDatabase + ";Integrated Security=SSPI");
			try
			{
				con.Open();
			}
			catch (SqlException SqlEx) 
			{
				SqlErrorCollection myErrors = SqlEx.Errors;
				foreach (SqlError f in myErrors) 
				{
					Console.WriteLine(f.Message);
				}
			}
			return con;
		}

		public static void sendOut(string ToBeSent)
		{
			Console.WriteLine(ToBeSent);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\WSTAdmin\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\SQLAdmin\ParsedArgsClass.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Reflection;
using Microsoft.SqlServer.Management.Common;

namespace SQLAdmin
{
    /// <summary>
    /// Summary description for ParsedArgs.
    /// </summary>
    public class ParsedArgs
    {
        string action;
        string additional = string.Empty;
        string server = string.Empty;
        string server2 = string.Empty;
        string database = string.Empty;
        string database2 = string.Empty;
        string filename = string.Empty;
        string[] filenames = null;
        string logname = string.Empty;
        string reportpath = string.Empty;
        string modifier = string.Empty;
        string property = string.Empty;
        string copydest = string.Empty;
        string substring = string.Empty;
        string[] substitutions = null;
        string thislocation = string.Empty;
        string updateparm = string.Empty;
        string updatetype = string.Empty;
        string updatevalue = string.Empty;
        string witness = string.Empty;
        int inpindex = 0;
        int numberoffiles;
        int timeout;
        bool debug = false;
        bool quiet = false;
        ArrayList servers = new ArrayList();
        Assembly asm = Assembly.GetExecutingAssembly();
        ServerConnection srvconn;
        SqlConnection sqlconn;
        SqlConnection sqlconn2;
        DateTime starttime;
        StreamReader sr = null;
        StreamWriter sw = null;
        public DateTime StartTime
        {
            get
            {
                return starttime;
            }
        }
        public SqlConnection SQLConn
        {
            get
            {
                return sqlconn;
            }
        }
        public SqlConnection SQLConn2
        {
            get
            {
                return sqlconn2;
            }
        }
        public bool Debug
        {
            get
            {
                return debug;
            }

        }
        public int NumberOfFiles
        {
            get
            {
                return numberoffiles;
            }
        }
        public int Timeout
        {
            set
            {
                try
                {
                    timeout = value;
                }
                catch (InvalidCastException e)
                {
                    Console.WriteLine("Invalid data type for timeout: {0}.  Using default of 30.  (Error {1})", value, e);
                    timeout = 30;
                }

            }
            get
            {
                return timeout;
            }
        }
        public string Action
        {
            get
            {
                return action;
            }
        }
        public string Additional
        {
            get
            {
                return additional;
            }
        }

        public string Database
        {
            get
            {
                return database;
            }
            set
            {
                database = value;
            }
        }

        public string Database2
        {
            get
            {
                return database2;
            }
            set
            {
                database2 = value;
            }
        }
        public string ExecutableLocation
        {
            get
            {
                return asm.Location;
            }
        }
        public bool Quiet
        {
            get
            {
                return quiet;
            }
        }
        public string[] Files
        {
            get
            {
                return filenames;
            }
        }
        public string CopyDestination
        {
            get
            {
                return copydest;
            }
        }
        public StreamWriter LogStream
        {
            get
            {
                return sw;
            }
        }
        public string Modifier
        {
            get
            {
                return modifier;
            }
        }
        public string Property
        {
            get
            {
                return property;
            }
            set
            {
                property = value;
            }
        }
        public string Server
        {
            get
            {
                return server;
            }
        }
        public string Server2
        {
            get
            {
                return server2;
            }
        }
        public ServerConnection ServerConn
        {
            get
            {
                return srvconn;
            }
        }
        public string[] Substitutions
        {
            get
            {
                return substitutions;
            }
        }
        public string UpdateParameter
        {
            get
            {
                return updateparm;
            }
        }
        public string UpdateType
        {
            get
            {
                return updatetype;
            }
        }
        public string UpdateValue
        {
            get
            {
                return updatevalue;
            }
        }
        public string Witness
        {
            get
            {
                return witness;
            }
        }
        public ParsedArgs(string[] args)
        {
            action = "None";
            timeout = 30;
            debug = false; // true for debug build
            int i = 0;
            starttime = DateTime.Now;
            string o;
            string input;
            string output;
            string thislocation = asm.Location;
            for (i = 0; i < args.Length; i++)
            {
                o = args[i].ToUpper();
                switch (o)
                {
                    case ("/A"):
                        if (!PromptForValue(args, i))
                        {
                            arg = args[i + 1];
                            int colon = arg.IndexOf(':');
                            if (colon > -1)
                            {
                                modifier = arg.Substring(colon + 1);
                            }
                            arg = arg.ToUpper();
                            if (arg.Length > 3)
                            {
                                action = arg.Substring(0, 4);
                            }
                            else
                            {
                                Console.WriteLine("Action must exceed three characters in length.");
                            }
                        }
                        i++;
                        break;
                    case ("/C"):
                        if (!PromptForValue(args, i))
                        {
                            copydest = args[i + 1];
                            if (copydest.Substring(copydest.Length - 1, 1) != "\\")
                                copydest = string.Format("{0}{1}", copydest, "\\");
                        }
                        i++;
                        break;
                    case ("/D"):
                        if (!PromptForValue(args, i))
                        {
                            input = args[i + 1];
                            if (input.IndexOf(':') != -1)
                            {
                                database = input.Substring(0, input.IndexOf(':'));
                                database2 = input.Substring(input.IndexOf(':') + 1, input.Length - input.IndexOf(':') - 1);
                            }
                            else
                            {
                                database = args[i + 1];
                                // don't populate database2 here, as in some cases, we'll want to prompt for it rather than making it automatic
                            }
                        }
                        i++;
                        break;
                    case ("/F"):
                        if (!PromptForValue(args, i))
                        {
                            filename = args[i + 1];
                        }
                        i++;
                        break;
                    case ("/L"):
                        if (!PromptForValue(args, i))
                        {
                            logname = args[i + 1];
                            string backupname = logname + ".bak";
                            if (System.IO.File.Exists(logname))
                            {
                                if (System.IO.File.Exists(backupname))
                                {
                                    System.IO.File.Delete(backupname);
                                }
                                System.IO.File.Move(logname, backupname);
                            }
                            try
                            {
                                sw = System.IO.File.CreateText(logname);
                            }
                            catch (SystemException e)
                            {
                                Console.WriteLine("Error attempting to create log file {0}", logname);
                                Console.WriteLine(e.Message);
                            }
                        }
                        i++;
                        break;
                    case ("/N"):
                        if (!PromptForValue(args, i))
                        {
                            try
                            {
                                numberoffiles = Convert.ToInt32(args[i + 1]);
                            }
                            catch (SystemException e)
                            {
                                Console.WriteLine("Error parsing numberoffiles value:");
                                Console.WriteLine(e.Message);
                            }
                        }
                        i++;
                        break;
                    case ("/P"):
                        if (!PromptForValue(args, i))
                        {
                            property = args[i + 1].ToUpper();
                        }
                        i++;
                        break;
                    case ("/Q"):
                        quiet = true;
                        break;
                    case ("/R"):
                        if (!PromptForValue(args, i))
                        {
                            reportpath = args[i + 1].ToUpper();
                        }
                        i++;
                        break;
                    case ("/S"):
                        if (!PromptForValue(args, i))
                        {
                            input = args[i + 1].ToString();
                            if (input.Length > 3 && input.Substring(input.Length - 4, 4).ToLower() == ".txt")
                            {
                                try
                                {
                                    sr = System.IO.File.OpenText(input);
                                }
                                catch (SystemException e)
                                {
                                    Console.WriteLine("Error attempting to open file {0} for read:", input);
                                    Console.WriteLine(e.Message);
                                }
                                if (sr != null)
                                {
                                    string line = string.Empty;
                                    while ((line = sr.ReadLine()) != null)
                                    {
                                        servers.Add(line);
                                    }
                                    sr.Close();
                                }
                            }
                            else
                            {
                                if (input.IndexOf(':') != -1)
                                {
                                    server = input.Substring(0, input.IndexOf(':')).ToUpper();
                                    server2 = input.Substring(input.IndexOf(':') + 1, input.Length - input.IndexOf(':') - 1).ToUpper();
                                }
                                else
                                {
                                    server = args[i + 1].ToUpper();
                                }
                            }
                        }
                        if (servers.Count > 0)
                            server = servers[inpindex].ToString();
                        i++;
                        break;
                    case ("/T"):
                        if (!PromptForValue(args, i))
                        {
                            try
                            {
                                timeout = Convert.ToInt32(args[i + 1]);
                            }
                            catch (SystemException e)
                            {
                                Console.WriteLine("Error parsing timout value:");
                                Console.WriteLine(e.Message);
                            }
                        }
                        i++;
                        break;
                    case ("/U"):
                        if (!PromptForValue(args, i))
                        {
                            arg = args[i + 1];
                            int equalsign = arg.IndexOf('=');
                            if (equalsign > -1)
                            {
                                updatevalue = arg.Substring(equalsign + 1);
                                if (arg.Substring(0, 1) == "@")
                                {
                                    updateparm = arg.Substring(0, equalsign);
                                }
                                else
                                {
                                    Console.WriteLine("Update parameter must be prefixed with '@'.");
                                    action = "None";
                                }
                            }
                            else
                            {
                                Console.WriteLine("Must include '@parmname=value' for 'JBUpdate' action.");
                                action = "None";
                            }
                        }
                        i++;
                        break;
                    case ("/V"):
                        output = asm.FullName;
                        string[] outputs = output.Split(',');
                        Console.WriteLine("{0} {1}{2}", outputs[0], outputs[1], Environment.NewLine);
                        break;
                    case ("/W"):
                        if (!PromptForValue(args, i))
                        {
                            witness = args[i + 1].ToUpper();
                        }
                        break;
                    case ("/?"):
                        action = "USAG";
                        break;
                    default:
                        if (args[i].IndexOf('=') != -1)
                        {
                            // if it has an equals sign, it's a substitution
                            if (substring == string.Empty)
                            {
                                substring = args[i];
                            }
                            else
                            {
                                substring = string.Format("(0),(1)", substring, args[i]);
                            }
                        }
                        else
                        {
                            // if it doesn't have an equals sign, it's additional information 
                            // if it's not FROM a switch, add it to Additional
                            if (additional == string.Empty)
                            {
                                additional = args[i];
                            }
                            else
                            {
                                additional += " " + args[i];
                            }
                        }
                        break;
                }
            }
            filenames = filename.Split(',');
            if (substring != string.Empty)
                substitutions = substring.Split(',');
            if (server == string.Empty)
            {
                server = Environment.MachineName;
            }
            if (action.Substring(0, 2) == "JB") // a job action necessitates MSDB as the database
            {
                sqlconn = SQLLib.connectToSQL(server, "msdb");
            }
            else
            {
                if ((server != string.Empty) & (action != string.Empty) & (database.IndexOf("%") == -1))
                {
                    if (database != string.Empty)
                    {
                        sqlconn = SQLLib.connectToSQL(server, database);
                    }
                }
            }
            switch (action)
            {
                case ("DBBA"):
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("{0}Must include valid, available server (/S) for database backup action.", Environment.NewLine);
                        action = "None";
                    }
                    if (database == string.Empty)
                    {
                        Console.WriteLine("Must include database to use database backup action.");
                        action = "None";
                    }
                    else
                    {
                        if (filenames[0] == string.Empty)
                        {
                            Console.WriteLine("No file path entered.  Using default 'e:\\mssql\\bak\\'");
                            filenames[0] = String.Format("e:\\mssql\\bak\\");
                        }
                    }
                    break;
                case ("DBBC"):
                    if (database == string.Empty)
                    {
                        Console.WriteLine("Must include database (/D) for database BCR action.");
                        action = "None";
                    }
                    else
                    {
                        if (filenames[0] == string.Empty)
                        {
                            SQLAdmin.sendOut("No file path entered.  Using default 'e:\\mssql\\bak'");
                            filenames[0] = "e:\\mssql\\bak";
                        }
                        else
                        {
                            SQLAdmin.sendOut("Using entered backup filepath '{0}'", filenames[0]);
                        }
                        if (server2 == string.Empty && database2 == string.Empty)
                        {
                            Console.WriteLine("Must include second database name or second server name for BCR action.");
                            action = "None";
                        }
                        if (server2 == string.Empty && database2 != database)
                        {
                            server2 = server;
                        }
                        if (database2 == string.Empty && server2 != server)
                        {
                            database2 = database;
                        }
                    }
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("{0}Must include valid, available server (/S) for backup/copy/restore action.", Environment.NewLine);
                        action = "None";
                    }
                    if (server != server2)
                    {
                        sqlconn2 = SQLLib.connectToSQL(server2, "master");
                    }
                    else
                    {
                        sqlconn2 = sqlconn;
                    }
                    break;
                case ("DBDR"):
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("{0}Must include valid, available server (/S) for database drop action.", Environment.NewLine);
                        action = "None";
                    }
                    if (database == string.Empty)
                    {
                        Console.WriteLine("Must include database (/D) for database drop action.");
                        action = "None";
                    }
                    break;
                case ("DBMA"):
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    modifier = modifier.ToUpper();
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("{0}Must include valid, available server (/S) for database maintenance action.", Environment.NewLine);
                        action = "None";
                    }
                    if (database == string.Empty)
                    {
                        Console.WriteLine("Must include database to use database maintenance action.");
                        action = "None";
                    }
                    else
                    {
                        if (filenames[0] == string.Empty)
                        {
                            Console.WriteLine("No file path entered.  Using default 'e:\\mssql\\bak\\'");
                            filenames[0] = "e:\\mssql\\bak\\";
                        }
                    }
                    if (modifier == string.Empty)
                        modifier = "DB";
                    if (additional == string.Empty)
                        additional = "SQLAdmin database maintenance job";
                    if (copydest != string.Empty && modifier.IndexOf('B') == -1)
                    {
                        Console.WriteLine("If copy destination (/C) is specified, you must backup the databases.");
                        action = "None";
                    }

                    break;
                case ("DBRE"):
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (modifier == string.Empty)
                        modifier = "REPLACE";
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("{0}Must include valid, available server (/S) for database restore action.", Environment.NewLine);
                        action = "None";
                    }
                    if (database == string.Empty)
                    {
                        Console.WriteLine("Must include database (/D) for database restore action.");
                        action = "None";
                    }
                    else
                    {
                        if (filenames[0] == string.Empty)
                        {
                            Console.WriteLine("No file path entered.  Using default 'e:\\mssql\\bak\\'");
                            filenames[0] = "e:\\mssql\\bak\\";
                        }
                        else
                        {
                            if (filenames[0].IndexOf("\\") == -1)
                            {
                                Console.WriteLine("No folder entered.  Using default 'e:\\mssql\\bak\\'");
                                for (i = 0; i < filenames.Length; i++)
                                {
                                    filenames[i] = string.Format("e:\\mssql\\bak\\{0}", filenames[i]);
                                }
                            }
                        }
                    }
                    break;
                case ("DBSP"):
                    srvconn = new ServerConnection(server);
                    srvconn.ConnectTimeout = 30;
                    try
                    {
                        srvconn.Connect();
                    }
                    catch (SystemException e)
                    {
                        Console.WriteLine("Error attempting to connect to SQL Server on {0}:", server);
                        Console.WriteLine(e.Message);
                    }
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("{0}Must include valid, available server (/S) for database space action.", Environment.NewLine);
                        action = "None";
                    }
                    if (database == string.Empty)
                        database = "%";
                    break;
                case ("DTIN"):
                    sqlconn = SQLLib.connectToSQL(Environment.MachineName, "master");
                    if (database == string.Empty)
                    {
                        Console.WriteLine("Must include database (/D) for 'DTInsert' action.");
                        action = "None";
                    }
                    if (additional == string.Empty)
                    {
                        Console.WriteLine("Must include table name as Additional Information for 'DTInsert' action.");
                        action = "None";
                    }
                    break;
                case ("ELOP"):
                    break;
                case ("INST"):
                    break;
                case ("JBAD"):
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (filename == string.Empty)
                    {
                        Console.WriteLine("Must include valid file (/F) to use 'JBAddstep' action.");
                        action = "None";
                    }
                    if (additional == string.Empty)
                    {
                        Console.WriteLine("Must include job name as 'additional information' for 'JBAddstep' action.");
                        action = "None";
                    }
                    break;
                case ("JBCO"):
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (additional == string.Empty)
                    {
                        Console.WriteLine("Must include job name as 'additional information' for 'JBCopy' action.");
                        action = "None";
                    }
                    break;
                case ("JBCR"):
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (filename == string.Empty)
                    {
                        Console.WriteLine("Must include valid file (/f) to use 'JBCreate' action.");
                        action = "None";
                    }
                    else
                    {
                        if (additional == string.Empty)
                            additional = string.Format("SQLAdmin job from file {0}", filename);
                    }
                    if (additional == string.Empty)
                        additional = String.Format("SQLAdmin job from file '{0}'", filename);
                    break;
                case ("JBDE"):
                    if (additional == string.Empty)
                    {
                        Console.WriteLine("Must include job name as 'additional information' for 'JBDelete' action.");
                        action = "None";
                    }
                    break;
                case ("JBEN"):
                    if (modifier == string.Empty)
                    {
                        Console.WriteLine("Must include modifier to use 'JBEnabled' action.");
                        Console.WriteLine("Example: sqladmin /a jbenabled:1 job name");
                        action = "None";
                    }
                    try
                    {
                        Convert.ToInt16(modifier);
                    }
                    catch (System.Exception e)
                    {
                        Console.WriteLine("Problem with action modifier for JBEnabled action:");
                        Console.WriteLine(e.Message);
                        action = "None";
                    }
                    if (additional == string.Empty)
                    {
                        Console.WriteLine("Must include job name as 'additional information' for 'JBEnabled' action.");
                        action = "None";
                    }
                    break;
                case ("JBHI"):
                    if (additional == string.Empty)
                    {
                        Console.WriteLine("Must include job name as 'additional information' for 'JBHistory' action.");
                        action = "None";
                    }
                    break;
                case ("JBLI"):
                    if (additional == string.Empty)
                    {
                        additional = "%";
                    }
                    break;
                case ("JBOW"):
                    if (modifier == string.Empty)
                    {
                        Console.WriteLine("Must include owner as modifier to use 'JBOwner' action.");
                        Console.WriteLine("Example: sqladmin /a owner:sa job name");
                        action = "None";
                    }
                    if (additional == string.Empty)
                    {
                        Console.WriteLine("Must include job name as 'additional information' for 'JBOwner' action.");
                        action = "None";
                    }
                    break;
                case ("JBQU"):
                    if (additional == string.Empty)
                    {
                        Console.WriteLine("Must include job name as 'additional information' for 'JBQuery' action.");
                        action = "None";
                    }
                    break;
                case ("JBRU"):
                    if (additional == string.Empty)
                    {
                        Console.WriteLine("Must include job name as 'additional information' for 'JBRun' action.");
                        action = "None";
                    }
                    break;
                case ("JBSC"):
                    if (additional == string.Empty)
                    {
                        Console.WriteLine("Must include job name as 'additional information' for 'JBScript' action.");
                        action = "None";
                    }
                    // need SMO to use the job script method
                    srvconn = new ServerConnection(server);
                    srvconn.ConnectTimeout = 30;
                    try
                    {
                        srvconn.Connect();
                    }
                    catch (SystemException e)
                    {
                        Console.WriteLine("Error attempting to connect to SQL Server on {0}:", server);
                        Console.WriteLine(e.Message);
                        action = "None";
                    }
                    break;
                case ("JBST"):
                    if (additional == string.Empty)
                    {
                        Console.WriteLine("Must include job name as 'additional information' for 'JBStop' action.");
                        action = "None";
                    }
                    break;
                case ("JBUP"):
                    if (additional == string.Empty)
                    {
                        Console.WriteLine("Must include job name as 'additional information' for 'JBUpdate' action.");
                        action = "None";
                    }
                    break;
                case ("JBWA"):
                    if (additional == string.Empty)
                    {
                        Console.WriteLine("Must include job name as 'additional information' for 'JBWait' action.");
                        action = "None";
                    }
                    break;
                case ("LSFA"):
                    sqlconn = SQLLib.connectToSQL(server, "msdb");
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("Must include valid, available server (/S) for log shipping failover action.");
                        action = "None";
                    }
                    if (filenames[0] == string.Empty)
                    {
                        Console.WriteLine("No file path entered.  Using default 'e:\\mssql\\bak\\'");
                        filenames[0] = "e:\\mssql\\bak\\";
                    }
                    if (database == string.Empty)
                    {
                        Console.WriteLine("Must include database (/D) for 'LSFailover' action.");
                        action = "None";
                    }
                    break;
                case ("LSQU"):
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("Must include valid, available server (/S) for log shipping monitor action.");
                        action = "None";
                    }
                    break;
                case ("LSSE"):
                    sqlconn = SQLLib.connectToSQL(server, "msdb");
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("Must include valid, available server (/S) for log shipping setup action.");
                        action = "None";
                    }
                    if (server2 == string.Empty)
                    {
                        Console.WriteLine("Must include secondary server for log shipping setup action.");
                        action = "None";
                    }
                    else
                    {
                        sqlconn2 = SQLLib.connectToSQL(server2, "msdb");
                        if (sqlconn2.State != ConnectionState.Open)
                        {
                            Console.WriteLine("Must include valid, available secondary server (/S) for log shipping setup action.");
                            action = "None";
                        }
                        else
                        {
                            if (filenames[0] == string.Empty)
                            {
                                Console.WriteLine("No file path entered.  Using default 'e:\\mssql\\tran\\'");
                                filenames[0] = "e:\\mssql\\tran\\";
                            }
                        }
                    }
                    break;
                case ("MRSE"):
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("Must include valid, available server (/S) for mirroring setup action.");
                        action = "None";
                    }
                    if (server2 == string.Empty)
                    {
                        Console.WriteLine("Must include secondary server for mirroring setup action.");
                        action = "None";
                    }
                    else
                    {
                        sqlconn2 = SQLLib.connectToSQL(server2, "msdb");
                        if (sqlconn2.State != ConnectionState.Open)
                        {
                            Console.WriteLine("Must include valid, available secondary server (/S) for mirroring setup action.");
                            action = "None";
                        }
                        else
                        {
                            if (filenames[0] == string.Empty)
                            {
                                Console.WriteLine("No file path entered.  Using default 'e:\\mssql\\bak'");
                                filenames[0] = "e:\\mssql\\bak";
                            }
                        }
                    }
                    break;
                case ("RPDR"):
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("Must include valid, available server (/S) for replication drop action.");
                        action = "None";
                    }
                    break;
                case ("RPFI"):
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("Must include valid, available server (/S) for replication drop action.");
                        action = "None";
                    }
                    break;
                case ("RPQU"):
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("Must include valid, available server (/S) for replication monitor action.");
                        action = "None";
                    }
                    break;
                case ("RPWA"):
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("Must include valid, available server (/S) for replication wait action.");
                        action = "None";
                    }
                    else
                    {
                        if (modifier == string.Empty)
                            modifier = "";
                        switch (modifier.ToUpper())
                        {
                            case "SNAPSHOT":
                                modifier = "Snapshot";
                                break;
                            case "TRANSACTIONAL":
                                modifier = "Transactional";
                                break;
                            case "":
                                modifier = "Transactional";
                                break;
                            default:
                                Console.WriteLine("Invalid modifier to RPWait action: {0}", modifier);
                                action = "None";
                                break;
                        }
                    }
                    break;
                case ("SPKI"):
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("{0}Must include valid, available server (/S) for database kill action.", Environment.NewLine);
                        action = "None";
                    }
                    break;
                case ("SPWA"):
                    sqlconn = SQLLib.connectToSQL(server, "master");
                    if (sqlconn.State != ConnectionState.Open)
                    {
                        Console.WriteLine("Must include valid, available server (/S) for SPID wait action.");
                        action = "None";
                    }
                    break;
                case ("STAD"):
                    if (modifier == string.Empty)
                    {
                        Console.WriteLine("Must include the new parameter as an action modifier for 'STAdd' action.");
                        action = "None";
                    }
                    else
                    {
                        srvconn = new ServerConnection(server);
                        srvconn.ConnectTimeout = 30;
                        try
                        {
                            srvconn.Connect();
                        }
                        catch (SystemException e)
                        {
                            Console.WriteLine("Error attempting to connect to SQL Server on {0}:", server);
                            Console.WriteLine(e.Message);
                        }
                    }
                    break;
                case ("STQU"):
                    srvconn = new ServerConnection(server);
                    srvconn.ConnectTimeout = 30;
                    try
                    {
                        srvconn.Connect();
                    }
                    catch (SystemException e)
                    {
                        Console.WriteLine("Error attempting to connect to SQL Server on {0}:", server);
                        Console.WriteLine(e.Message);
                    }
                    break;
                case ("USAG"):
                    break;
                default:
                    Console.WriteLine("Invalid action: {0}", action);
                    action = "None";
                    break;
            }
        }
        /*
                // assemble the full file path
                    if (useLitespeed)
                    {
                        fullpath = String.Format("{0}{1}.ls.bak", folder, dbname);
                    }
                    else
                    {
                        fullpath = String.Format("{0}{1}.bak", folder, dbname);
                    }
                }
                else
                {
                    // assemble a path for each of the stripes
                    if (useLitespeed)
                    {
                        fullpath = String.Format("{0}{1}.ls1.bak", folder, dbname);
                        fullpath = String.Format("{0}{1}.ls2.bak", fullpath, dbname);
                    }
                    else
                    {
                        fullpath = String.Format("{0}{1}.1.bak", folder, dbname);
                        fullpath = String.Format("', DISK='{0}{1}.2.bak", folder, dbname);
                    }
                }
        */
        protected bool PromptForValue(string[] PValues, int intIndex)
        {
            if ((intIndex + 2) > PValues.Length)
            {
                Console.WriteLine(String.Concat("No value for switch ", PValues[intIndex].ToUpper()));
                return true;
            }
            else
            {
                return false;
            }
        }
        protected string arg;

        // method for ParsedArgs class - this belongs here, not in the SQLLib class
        public string[] getDBList()
        {
            string[] dbnames = getDBList("name");
            return dbnames;
        }

        // method for ParsedArgs class - this belongs here, not in the SQLLib class
        public string[] getDBList(string orderField)
        {
            string output;
            string strCmd = string.Empty;
            string strMsg = string.Empty;
            string[] dbnames = new string[0];
            int i = 0;
            SqlConnection dblistcon = SQLLib.connectToSQL(server, "master");
            if (dblistcon.ServerVersion.Substring(0, 2) == "08")
            {
                strCmd = "SELECT name FROM sysdatabases";
            }
            else
            {
                strCmd = "SELECT name FROM sys.databases";
            }
            strCmd += " WHERE name LIKE '" + database + "'";
            if (property != string.Empty)
            {
                strCmd += " AND " + property;
            }
            if (orderField != string.Empty)
            {
                strCmd += " ORDER BY " + orderField;
            }
            else
            {
                strCmd += " ORDER BY name";
            }
            SqlDataReader rd = SQLLib.getReaderFromSql(dblistcon, strCmd);

            if (rd != null)
            {
                if (rd.HasRows)
                {
                    while (rd.Read())
                    {
                        Array.Resize(ref dbnames, i + 1);
                        dbnames[i] = rd.GetString(0);
                        i++;
                    }
                }
                else
                {
                    output = string.Format("No database found having name pattern '{0}'", database);
                    if (property != string.Empty)
                    {
                        output += string.Format("{0}with property '{1}'.", Environment.NewLine, property);
                    }
                    else
                    {
                        output += ".";
                    }
                    Console.WriteLine(output);
                }
                SQLLib.disposeReader(rd);
            }
            return dbnames;
        }

        // method for ParsedArgs class - this belongs here, not in the SQLLib class
        public string[] getDestDBList()
        {
            string[] dbnames = getDestDBList("name");
            return dbnames;
        }

        // method for ParsedArgs class - this belongs here, not in the SQLLib class
        public string[] getDestDBList(string orderField)
        {
            string strCmd = string.Empty;
            string strMsg = string.Empty;
            string[] dbnames = new string[0];
            int i = 0;
            SqlConnection con = SQLLib.connectToSQL(server2, "master");
            if (con.ServerVersion.Substring(0, 2) == "08")
            {
                strCmd = "SELECT name FROM sysdatabases";
            }
            else
            {
                strCmd = "SELECT name FROM sys.databases";
            }
            strCmd += " WHERE name LIKE '" + database + "'";
            if (property != string.Empty)
            {
                strCmd += " AND " + property;
            }
            if (orderField != string.Empty)
            {
                strCmd += " ORDER BY " + orderField;
            }
            else
            {
                strCmd += " ORDER BY name";
            }
            SqlDataReader rd = SQLLib.getReaderFromSql(con, strCmd);
            if (rd != null)
            {
                if (rd.HasRows)
                {
                    while (rd.Read())
                    {
                        Array.Resize(ref dbnames, i + 1);
                        dbnames[i] = rd.GetString(0);
                        i++;
                    }
                }
                SQLLib.disposeReader(rd);
            }
            return dbnames;
        }

        // method for ParsedArgs class - this belongs here, not in the SQLLib class
        public string[] getJBList()
        {
            if (additional == string.Empty)
            {
                additional = "NONE";
            }
            string strCmd = string.Empty;
            string[] jbnames = new string[0];
            int i = 0;
            SqlConnection con = SQLLib.connectToSQL(server, "msdb");
            strCmd = "SELECT j.name FROM sysjobs j";
            if (property != string.Empty)
            {
                if (property.Substring(0, 8) == "CATEGORY")
                {
                    strCmd += " INNER JOIN syscategories c";
                    strCmd += " ON j.category_id = c.category_id";
                }
                else if (property.Substring(0, 5) == "OWNER")
                {
                    strCmd += " INNER JOIN sys.server_principals p";
                    strCmd += " ON j.owner_sid = p.sid";
                }

            }
            strCmd += " WHERE j.name LIKE '" + additional + "'";
            if (property != string.Empty)
            {
                if (property.Substring(0, 8) == "CATEGORY")
                {
                    strCmd += " AND c.category_class = 1";
                    strCmd += " AND c.name" + property.Substring(8, property.Length - 8);
                }
                else if (property.Substring(0, 5) == "OWNER")
                {
                    strCmd += " AND p.type IN ('S', 'U')";
                    strCmd += " AND p.name" + property.Substring(5, property.Length - 5);
                }
                else
                {
                    strCmd += " AND " + property;
                }
            }
            strCmd += " ORDER BY j.name";
            SqlDataReader rd = SQLLib.getReaderFromSql(con, strCmd);
            if (rd != null)
            {
                if (rd.HasRows)
                {
                    while (rd.Read())
                    {
                        Array.Resize(ref jbnames, i + 1);
                        jbnames[i] = rd.GetString(0);
                        i++;
                    }
                }
                else
                {
                    Console.WriteLine("No job found having name pattern '{0}'.{1}", additional, Environment.NewLine);
                }
                SQLLib.disposeReader(rd);
            }
            return jbnames;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\GAST\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\SQLAdmin\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\SQLAdmin\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\WSTAdmin\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\SQLAdmin\sqladmin.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Management;
using System.Reflection;
using System.Threading;
using System.Windows.Forms;
using Microsoft.SqlServer;
using Microsoft.SqlServer.Management;
using Microsoft.SqlServer.Management.Common;
using Microsoft.SqlServer.Management.Smo;
using Microsoft.SqlServer.Management.Smo.Agent;
using Microsoft.SqlServer.Management.Smo.Wmi;
using Microsoft.SqlServer.Replication;

namespace SQLAdmin
{
	/// <summary>
	/// Program to administer SQL Server from the command prompt, especially elements that require a lot of work in SQLWB.
	/// </summary>
	class SQLAdmin
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
        static StreamWriter wr = null;
        
        [STAThread]
		static int Main(string[] args)
		{
			bool blnSuccess = false;
			Console.WriteLine();
			if (args.Length == 0)
			{
                Usage(string.Empty);
				return 1;
			}
			ParsedArgs ar = new ParsedArgs(args);
            if (ar.Action != "None")
            {
                LogObj = ar.LogStream;
                blnSuccess = runAction(ar);
                if (blnSuccess == false)
                {
                    sendOut("{0}Operation Failed", Environment.NewLine);
                    if (LogObj != null)
                        LogObj.Flush();
                    return 1;
                }
                else
                {
                    sendOut("{0}Operation Successful", Environment.NewLine);
                }
            }
            else
            {
                sendOut("{0}Operation Failed", Environment.NewLine);
                if (LogObj != null)
                    LogObj.Flush();
                return 1;
            }
            if (LogObj != null)
                LogObj.Flush();
            return 0;
		}

        public static StreamWriter LogObj
        {
            get
            {
                if (wr != null)
                {
                    return wr;
                }
                else
                {
                    return null;
                }
            }
            set
            {
                wr = value;
            }
        }

        private static string addInt32ToString(string baseString, Int32 intToAdd, int padToLength)
        {
            string strReturn = baseString;
            string strToAdd = string.Empty;
            if (intToAdd == -1) // -1 means we don't have a valid value available
            {
                strToAdd = "UNKNOWN";
            }
            else
            {
                strToAdd = intToAdd.ToString();
            }
            strToAdd = strToAdd.PadLeft(padToLength);
            strReturn = string.Format("{0}{1}", baseString, strToAdd);
            return strReturn;
        }

        private static bool addJobStepsFromFiles(ParsedArgs arg)
        {
            bool success = false;
            string[] jbs = arg.getJBList();
            if (jbs.Length > 0)
            {
                foreach (string jb in jbs)
                {
                    JBInfo jbi = new JBInfo(arg.SQLConn, jb);
                    int jobstep = jbi.NumberOfSteps;
                    success = SQLLib.updateJobStep(arg.SQLConn, jb, jobstep, "@on_success_action", "tinyint", "3"); // goto next step
                    foreach (string filestr in arg.Files)
                    {
                        if (success)
                        {
                            success = addStepFromFile(arg.SQLConn, filestr, jbi.JobId, arg.Database);
                        }
                        else
                        {
                            break;
                        }
                    }
                    jbi.Refresh();
                    SQLLib.updateJobStep(arg.SQLConn, jb, jbi.NumberOfSteps, "@on_success_action", "tinyint", "1"); // end with success
                }
            }
            Console.WriteLine();
            return success;
        }

        private static bool addStartupParam(ParsedArgs a)
        {
            bool success = false;
            ManagedComputer mc = new ManagedComputer(a.Server);
            ServiceCollection svcs = getServices(mc);
            if (svcs != null)
            {
                foreach (Service svc in svcs)
                {
                    if (svc.Name == "MSSQLSERVER")
                    {
                        if (svc.StartupParameters.ToUpper().IndexOf(a.Modifier.ToUpper()) == -1)
                        {
                            Console.WriteLine("Adding parameter {0} to SQL Server {1}.", a.Modifier, a.Server);
                            svc.StartupParameters = svc.StartupParameters + ";" + a.Modifier;
                            svc.Alter();
                            svc.Refresh();
                        }
                        else
                        {
                            Console.WriteLine("SQL Server {0} already has parameter {1}.", a.Server, a.Modifier);
                        }
                        Console.WriteLine("Startup parameters for SQL Server '{0}':", mc.Name);
                        string output = svc.StartupParameters;
                        string[] outs = output.Split(';');
                        foreach (string o in outs)
                        {
                            Console.WriteLine(o);
                        }
                        if (svc.StartupParameters.IndexOf(a.Modifier) != -1)
                        {
                            success = true;
                            string evt = string.Format("Added SQL Server startup parameter {0}.", a.Modifier);
                            logEvent(a.Server, evt);
                        }
                    }
                }
            }
            Console.WriteLine();
            return success;
        }

        private static bool addStepFromFile(SqlConnection con, string filestr, string jobID, string db)
        {
            StreamReader sr = null;
            bool success = false;
            string subsystem = string.Empty;
            string totalstring = string.Empty;
            string inp = string.Empty;
            if (System.IO.File.Exists(filestr))
            {
                try
                {
                    sr = System.IO.File.OpenText(filestr);
                }
                catch (SystemException e)
                {
                    Console.WriteLine("Error attempting to open input file {0}", filestr);
                    Console.WriteLine(e.Message);
                }
                string[] filename = filestr.Split('.');
                switch (filename[filename.Length - 1].ToLower())
                {
                    case "sql":
                        subsystem = ("TSQL");
                        break;
                    case "xmla":
                        subsystem = ("ANALYSISCOMMAND");
                        break;
                    case "cmd":
                        subsystem = ("CMDEXEC");
                        break;
                    default:
                        Console.WriteLine("File extension .{0} is unsupported for job step add.", filename[filename.Length - 1]);
                        break;
                }
                while (!sr.EndOfStream)
                {
                    inp = sr.ReadLine();
                    totalstring = string.Format("{0}{1}{2}", totalstring, inp, Environment.NewLine);
                }
                string stepName = String.Format("Step from file {0}", filestr);
                success = SQLLib.addStepToJob(con, jobID, stepName, totalstring, subsystem, db, false);
            }
            else
            {
                Console.WriteLine("Non-existent file {0}.  Aborting.", filestr);

            }
            totalstring = string.Empty;
            return success;
        }

        private static bool backupCopyRestoreDatabases(ParsedArgs a)
        {
            bool success = false;
            bool destexists = false;
            string msgadd = string.Empty;
            bool useLitespeed = false;
            string modify = "REPLACE";
            if (a.Modifier != string.Empty)
            {
                modify += "," + a.Modifier;
            }
            if (a.Database2 == a.Database)
            {
                // for same source and destination DB name, we can BCR any number of databases
                string[] dbs = a.getDBList();
                //            string restoreshare = string.Empty;
                if (!a.Quiet)
                {
                    string[] dests = a.getDestDBList();
                    string msg = string.Format("WARNING:{0}{0}", Environment.NewLine);
                    msg = string.Format("{0}This will backup copy and restore the following databases", msg);
                    msg = string.Format("{0} from server {1} to server {2}", msg, a.Server, a.Server2);
                    msg = string.Format("{0} with {1}:", msg, modify);
                    foreach (string sourcedb in dbs)
                    {
                        msg = string.Format("{0}{1}{2}", msg, Environment.NewLine, sourcedb);
                    }
                    if (dests.Length > 0)
                    {
                        foreach (string sourcedb in dbs)
                        {
                            DBInfo destdb = new DBInfo(sourcedb, a.SQLConn2);
                            if (destdb.DBExists)
                            {
                                destexists = true;
                                msgadd = string.Format("{0}{1}{2}", msgadd, Environment.NewLine, destdb.Name);
                            }
                        }
                        if (destexists)
                        {
                            msg = string.Format("{0}{1}{1}It will REPLACE the following databases on {2}:", msg, Environment.NewLine, a.Server2);
                            msg = string.Format("{0}{1}", msg, msgadd);
                        }
                    }
                    msg = string.Format("{0}{1}{1}Is this really what you want?", msg, Environment.NewLine);
                    if (!SQLLib.confirmChoice(msg))
                    {
                        Console.WriteLine("Action terminated due to user input.{0}", Environment.NewLine);
                        return success;
                    }
                    if (SQLLib.LitespeedExists(a.SQLConn) && SQLLib.LitespeedExists(a.SQLConn2))
                    {
                        if (SQLLib.confirmChoice("Use Litespeed for your database backups?"))
                            useLitespeed = true;
                    }
                }
                else
                {
                    if (SQLLib.LitespeedExists(a.SQLConn) && SQLLib.LitespeedExists(a.SQLConn2))
                    {
                        useLitespeed = true;
                    }
                }
                if (dbs.Length > 0)
                {
                    foreach (string db in dbs)
                    {
                        success = SQLLib.backupCopyRestoreDatabase(a.SQLConn, a.SQLConn2, db, db, a.Files, string.Empty, modify, useLitespeed);
                    }
                }
            }
            else
            {
                // for different destination database than the source, we assume only one BCR
                string[] dbs = a.getDBList();
                if (dbs.Length > 1)
                {
                    // here, we don't support multiple databases via a pattern
                    sendOut("Multiple databases not supported when doing BCR to different database name.");
                    sendOut("Aborting.");
                }
                else
                {
                    if (SQLLib.LitespeedExists(a.SQLConn) && SQLLib.LitespeedExists(a.SQLConn2))
                    {
                        if (a.Quiet)
                        {
                            useLitespeed = true;
                        }
                        else
                        {
                            if (SQLLib.confirmChoice("Use Litespeed for your database backups?"))
                                useLitespeed = true;
                        }
                    }
                    // see if database exists at the destination
                    DBInfo dbinf = new DBInfo(a.Database2, a.SQLConn2);
                    if (!a.Quiet)
                    {
                        string msg = string.Format("WARNING:{0}{0}", Environment.NewLine);
                        msg = string.Format("{0}This will backup copy and restore database", msg);
                        msg = string.Format("{0}{1}'{2}' on server {3} to new database name", msg, Environment.NewLine, dbs[0], a.Server.ToUpper());
                        msg = string.Format("{0}{1}'{2}' on server {3},", msg, Environment.NewLine, dbinf.Name, a.Server2.ToUpper());
                        if (dbinf.DBExists)
                        {
                            msg = string.Format("{0}{1}REPLACING the existing database!", msg, Environment.NewLine);
                        }
                        msg = string.Format("{0}{1}{1}Is this really what you want?", msg, Environment.NewLine);
                        if (!SQLLib.confirmChoice(msg))
                        {
                            Console.WriteLine("Action terminated due to user input.{0}", Environment.NewLine);
                            return success;
                        }
                    }
                    success = SQLLib.backupCopyRestoreDatabase(a.SQLConn, a.SQLConn2, dbs[0], a.Database2, a.Files, string.Empty, modify, useLitespeed);
                }
            }
            return success;
        }

        private static bool backupDatabases(ParsedArgs a)
        {
            bool success = false;
            string[] dbs = a.getDBList();
            bool useLitespeed = false;
            if (SQLLib.LitespeedExists(a.SQLConn))
            {
                if (a.Quiet)
                {
                    useLitespeed = true;
                }
                else
                {
                    if (SQLLib.confirmChoice("Use Litespeed for your database backups?"))
                        useLitespeed = true;
                }
            }
            if (dbs.Length > 0)
            {
                foreach (string db in dbs)
                {
                    if (db != "tempdb") // backup operations are not allowed on tempdb
                    {
                        Console.WriteLine(a.Files[0]);
                        if (SQLLib.backupDatabase(a.SQLConn, db, a.Files, a.Modifier, useLitespeed))
                            success = true;
                    }
                    else
                    {
                        Console.WriteLine("NOTE: Backup operations are not allowed on TempDB!{0}", Environment.NewLine);
                    }
                }
            }
            return success;
        }

        private static bool confirmAction(string action, string servername, string objname, string[] objects)
        {
            bool confirmed = false;
            string msg = "WARNING:" + Environment.NewLine + Environment.NewLine;
            msg += "This will " + action.ToUpper();
            msg += " the following " + objname + "s on server " + servername + ":";
            foreach (string obj in objects)
            {
                msg += Environment.NewLine + obj;
            }
            msg += Environment.NewLine + Environment.NewLine + "Is this really what you want?";
            DialogResult result = MessageBox.Show(msg, "Confirm action", MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button2);
            if (result == DialogResult.Yes)
            {
                confirmed = true;
            }
            else
            {
                Console.WriteLine("Action terminated due to user input.{0}", Environment.NewLine);
            }
            return confirmed;
        }

        private static bool confirmAction(string action, string servername)
        {
            bool confirmed = false;
            string msg = "WARNING:" + Environment.NewLine + Environment.NewLine;
            msg += "This will " + action.ToUpper();
            msg += " on server " + servername;
            msg += Environment.NewLine + Environment.NewLine + "Is this really what you want?";
            DialogResult result = MessageBox.Show(msg, "Confirm action", MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button2);
            if (result == DialogResult.Yes)
            {
                confirmed = true;
            }
            else
            {
                Console.WriteLine("Action terminated due to user input.{0}", Environment.NewLine);
            }
            return confirmed;
        }

        private static bool copyJob(ParsedArgs arg)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        private static bool createJobFromFiles(ParsedArgs arg)
        {
            bool success = false;
            int filecount = 0;
            string inp = string.Empty;
            string subsystem = string.Empty;
            string totalstring = string.Empty;
            string jobID = SQLLib.createJob(arg.SQLConn, arg.Additional);
            string[] dbs = arg.getDBList();
            foreach (string filestr in arg.Files)
            {
                if (dbs.Length > 0)
                {
                    // use the first database we find in the list as the context
                    if (addStepFromFile(arg.SQLConn, filestr, jobID, dbs[0]))
                        filecount++;
                }
                else
                {
                    // if we don't have a database, pass an empty string
                    if (addStepFromFile(arg.SQLConn, filestr, jobID, string.Empty))
                        filecount++;
                }

            }
            if (filecount > 0)
            {
                SQLLib.updateJobStep(arg.SQLConn, arg.Additional, filecount, "@on_success_action", "tinyint", "1");
                success = true;
            }
            Console.WriteLine();
            return success;
        }

        private static bool deleteJobs(ParsedArgs arg)
        {
            bool success = false;
            Console.WriteLine("Action: Delete jobs matching name pattern '{0}'.{1}", arg.Additional, Environment.NewLine);
            if (arg.Property != string.Empty)
                Console.WriteLine("with property {0}", arg.Property);
            string[] jbs = arg.getJBList();
            if (jbs.Length > 0)
            {
                if (!arg.Quiet)
                {
                    if (confirmAction("delete", arg.Server, "job", jbs))
                    {
                        success = true;
                        foreach (string jb in jbs)
                        {
                            if (!SQLLib.deleteJob(jb, arg.SQLConn))
                                success = false;
                        }
                    }
                }
                else
                {
                    foreach (string jb in jbs)
                    {
                        success = true;
                        if (!SQLLib.deleteJob(jb, arg.SQLConn))
                            success = false;
                    }
                }
                Console.WriteLine();
            }
            return success;
        }

        private static bool dropDatabases(ParsedArgs a)
        {
            bool success = false;
            string[] dbs = a.getDBList();
            if (dbs.Length > 0)
            {
                if (!a.Quiet)
                {
                    if (!confirmAction("drop", a.Server, "database", dbs))
                    {
                        return success;
                    }
                }
                foreach (string db in dbs)
                {
                    if (SQLLib.dropDatabase(a.SQLConn, db))
                        success = true;
                    if (!success)
                        break;
                }
            }
            return success;
        }

        // Purpose: remove replication distribution FROM a server
        // Inputs : ServerName: string representing the SQL Server FROM which to remove replication
        // Returns: boolean indicating removal success
        private static bool dropReplication(ParsedArgs a)
        {
            bool success = false;
            bool subscriptionsexist = true;
            bool publicationsexist = true;
            string distDB = string.Empty;
            string distSvr = string.Empty;
            string pubSrv = a.Server;
            string[] pubDBs;
            string cmdtxt;
            if (a.Modifier == "OVERRIDE")
            {
                Console.WriteLine("{0}'OVERRIDE' modifier entered. Trying distributor drop with @no_checks and @ignore_distributor.", Environment.NewLine);
                SqlConnection dropcon = SQLLib.connectToSQL(pubSrv, "master");
                SqlCommand dropcmd = new SqlCommand();
                dropcmd.Connection = dropcon;
                dropcmd.CommandText = "sp_dropdistributor";
                dropcmd.CommandType = CommandType.StoredProcedure;
                SqlParameter dropprm1 = dropcmd.Parameters.Add("@no_checks", SqlDbType.Bit, 1);
                dropprm1.Value = 1;
                SqlParameter dropprm2 = dropcmd.Parameters.Add("@ignore_distributor", SqlDbType.Bit, 1);
                dropprm2.Value = 1;
                SqlDataReader droprdr = SQLLib.getReaderFromSP(dropcmd);
                if (droprdr != null)
                {
                    SQLLib.disposeReader(droprdr);
                    success = true;
                }
                dropcmd.Dispose();
                dropcon.Close();
                dropcon.Dispose();
                success = true;
            }
            else
            {
                if (a.Database == string.Empty)
                    a.Database = "%";
                // ensure that databases affected are those marked published
                a.Property = "is_published=1";
                // get the list of DBs on which to drop replication
                pubDBs = a.getDBList();
                if (pubDBs.Length > 0 || a.Database == "%")
                {
                    if (!a.Quiet)
                    {
                        if (pubDBs.Length > 0)
                        {
                            if (!confirmAction("drop all replication on", pubSrv, "database", pubDBs))
                                return false;
                        }
                        else
                        {
                            if (!confirmAction("drop all replication", pubSrv))
                                return false;
                        }
                    }
                    SqlCommand cmd = new SqlCommand();
                    SqlConnection dpdist = SQLLib.connectToSQL(pubSrv, "master");
                    SqlDataReader rdr;
                    // get name of the distribution DB
                    Console.WriteLine("Getting distribution server.");
                    distSvr = SQLLib.getDistSvr(pubSrv);
                    Console.WriteLine("Getting distribution database.");
                    distDB = SQLLib.getDistDB(pubSrv);
                    cmd.Connection = dpdist;
                    if (distDB == string.Empty)
                    {
                        Console.WriteLine("No distribution database found.");
                    }
                    else
                    {
                        SQLLib.killUsersInDB(dpdist, distDB);   // kill users in distribution database
                        if (SQLLib.changeDatabase(dpdist, distDB))
                        {
                            if (a.Database == "%")
                            {
                                // truncate MSrepl_commands and MSrepl_transactions
                                cmdtxt = String.Format("TRUNCATE TABLE {0}.dbo.MSrepl_commands", distDB);
                                SQLLib.executeNonQueryAtSql(cmd, cmdtxt, true);
                                cmdtxt = String.Format("TRUNCATE TABLE {0}.dbo.MSrepl_transactions", distDB);
                                SQLLib.executeNonQueryAtSql(cmd, cmdtxt, true);
                            }
                            foreach (string pubDB in pubDBs)
                            {
                                // NOTE: subscriptions can only be dropped from the publisher database
                                SQLLib.dropDBRepl(pubSrv, pubDB, distSvr, distDB);
                            }
                            Console.WriteLine("Determining whether subscriptions exist for publishing server {0}.", pubSrv);
                            // subscription types to be tested are 0, 1, and 2
                            for (int i = 0; i < 3; i++)
                            {
                                rdr = SQLLib.getReplMonitorSubscriptions(pubSrv, distSvr, distDB, i, true);
                                if (SQLLib.verifyReader(rdr))
                                {
                                    // if we found rows, exit
                                    SQLLib.disposeReader(rdr);
                                    break;
                                }
                                // if we've gone through all the subscription types
                                // and the reader didn't error out, and we didn't exit above,
                                // we know that no subscriptions exist
                                if (!((i == 2) & (rdr != null)))
                                    subscriptionsexist = false;
                                SQLLib.disposeReader(rdr);
                            }
                            if (subscriptionsexist)
                            {
                                Console.WriteLine("Subscriptions still exist.");
                            }
                            else
                            {
                                cmd.Parameters.Clear();
                                Console.WriteLine("Getting list of subscribers.");
                                cmd.CommandText = "SELECT subscriber FROM MSsubscriber_info";
                                cmd.CommandType = CommandType.Text;
                                rdr = SQLLib.getReaderFromSP(cmd);
                                if (SQLLib.verifyReader(rdr))
                                {
                                    while (rdr.Read())
                                    {
                                        string subSrv = rdr.GetString(0);
                                        SqlConnection drpcon = SQLLib.connectToSQL(pubSrv, "master");
                                        SqlCommand drpcmd = new SqlCommand();
                                        drpcmd.Connection = drpcon;
                                        Console.WriteLine("Dropping subscriber '{0}'.", subSrv);
                                        drpcmd.CommandText = "sp_dropsubscriber";
                                        drpcmd.CommandType = CommandType.StoredProcedure;
                                        SqlParameter drpprm = drpcmd.Parameters.Add("@subscriber", SqlDbType.NVarChar, 128);
                                        drpprm.Value = subSrv;
                                        SqlDataReader drprdr = SQLLib.getReaderFromSP(drpcmd);
                                        drpcmd.Parameters.Clear();
                                        SQLLib.disposeReader(drprdr);
                                    }
                                }
                                SQLLib.disposeReader(rdr);
                                // since we have no subscriptions, look for existing publications 
                                // before assuming we should wipe out the rest of replication
                                Console.WriteLine("Determining whether publications exist.");
                                for (int j = 0; j < 3; j++)
                                {
                                    rdr = SQLLib.getReplMonitorPublications(pubSrv, distSvr, distDB, j, true);
                                    if (SQLLib.verifyReader(rdr))
                                    {
                                        SQLLib.disposeReader(rdr);
                                        // if we found any rows, we break out of the loop
                                        break;
                                    }
                                    if (!((j == 2) & (rdr != null)))
                                        // if we're still in the loop with j==2 and we got a response, we know publications don't exist
                                        publicationsexist = false;
                                    SQLLib.disposeReader(rdr);
                                }
                                if (publicationsexist)
                                {
                                    Console.WriteLine("Publications still exist.");
                                }
                                else
                                {
                                    // get all published databases
                                    cmd.Parameters.Clear();
                                    if (SQLLib.changeDatabase(cmd.Connection, "master"))
                                    {
                                        Console.WriteLine("Getting list of published databases.");
                                        cmd.CommandText = "sp_helpreplicationdboption";
                                        cmd.CommandType = CommandType.StoredProcedure;
                                        SqlParameter prm1 = cmd.Parameters.Add("@type", SqlDbType.NVarChar, 128);
                                        prm1.Value = "publish";
                                        rdr = SQLLib.getReaderFromSP(cmd);
                                        if (SQLLib.verifyReader(rdr))
                                        {
                                            while (rdr.Read())
                                            {
                                                // set the published status of each database to false
                                                string pubDB = rdr.GetString(0);
                                                bool isPublish = rdr.GetBoolean(2);
                                                bool isMergePublish = rdr.GetBoolean(3);
                                                if (isPublish == true)
                                                {
                                                    SQLLib.setDBReplOption(pubSrv, pubDB, "publish", false);
                                                }
                                                if (isMergePublish == true)
                                                {
                                                    SQLLib.setDBReplOption(pubSrv, pubDB, "merge publish", false);
                                                }
                                            }
                                        }
                                        SQLLib.disposeReader(rdr);
                                        cmd.Parameters.Clear();
                                        Console.WriteLine("Verifying distribution publisher exists.");
                                        cmd.CommandText = "sp_helpdistpublisher";
                                        rdr = SQLLib.getReaderFromSP(cmd);
                                        if (SQLLib.verifyReader(rdr))
                                        {
                                            SqlConnection drpcon = SQLLib.connectToSQL(pubSrv, "master");
                                            SqlCommand drpcmd = new SqlCommand();
                                            drpcmd.Connection = drpcon;
                                            Console.WriteLine("Dropping distribution publisher.");
                                            drpcmd.CommandText = "sp_dropdistpublisher";
                                            drpcmd.CommandType = CommandType.StoredProcedure;
                                            SqlParameter pubprm = drpcmd.Parameters.Add("@publisher", SqlDbType.NVarChar, 128);
                                            pubprm.Value = pubSrv;
                                            SqlDataReader drprdr = SQLLib.getReaderFromSP(drpcmd);
                                            SQLLib.disposeReader(drprdr);
                                            drpcmd.Parameters.Clear();
                                        }
                                        SQLLib.disposeReader(rdr);
                                        cmd.Parameters.Clear();
                                        SQLLib.killUsersInDB(dpdist, distDB);
                                        if (SQLLib.changeDatabase(dpdist, "master"))
                                        {
                                            Console.WriteLine("Dropping distribution database '{0}'.", distDB);
                                            cmd.CommandText = "sp_dropdistributiondb";
                                            cmd.CommandType = CommandType.StoredProcedure;
                                            prm1 = cmd.Parameters.Add("@database", SqlDbType.NVarChar, 128);
                                            prm1.Value = distDB;
                                            rdr = SQLLib.getReaderFromSP(cmd);
                                            SQLLib.disposeReader(rdr);
                                            cmd.Parameters.Clear();
                                            Console.WriteLine("Verifying distributor exists.");
                                            cmd.CommandText = "sp_helpdistributor";
                                            cmd.CommandType = CommandType.StoredProcedure;
                                            SqlDataReader drdr = SQLLib.getReaderFromSP(cmd);
                                            if (drdr != null)
                                            {
                                                if (!drdr.HasRows)
                                                {
                                                    // a distributor exists if no rows are present
                                                    // this may be a bug in SQL Server
                                                    Console.WriteLine("Dropping distributor (sp_helpdistributor returns no rows).");
                                                    if (SQLLib.runSP(pubSrv, "master", "sp_dropdistributor"))
                                                    {
                                                        success = true;
                                                    }
                                                }
                                                else
                                                {
                                                    distDB = SQLLib.getStringFromReader(drdr);
                                                    if (distDB == string.Empty)
                                                    {
                                                        // the only way we don't need to drop is if a row exists but is empty
                                                        Console.WriteLine("Distributor does not exist.{0}", Environment.NewLine);
                                                        success = true;
                                                    }
                                                    else
                                                    {
                                                        Console.WriteLine("Dropping distributor.{0}", Environment.NewLine);
                                                        if (SQLLib.runSP(pubSrv, "master", "sp_dropdistributor"))
                                                        {
                                                            success = true;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (!success & a.Database != "%")
            {
                pubDBs = a.getDBList();
                if (pubDBs.Length == 0)
                    success = true;
            }
            return success;
        }

        private static bool failoverLogShipping(ParsedArgs arg)
        {
            bool success = false;
            string[] pubDBs = arg.getDBList();
            if (pubDBs.Length > 0 || arg.Database == "%")
            {
                if (!arg.Quiet)
                {
                    if (pubDBs.Length > 0)
                    {
                        if (!confirmAction("failover log shipping for", arg.Server, "database", pubDBs))
                            return false;
                    }
                    else
                    {
                        if (!confirmAction("failover log shipping", arg.Server))
                            return false;
                    }
                }
            }
            // disable log shipping jobs
            LSInfo lsi = new LSInfo(arg.Server);
            lsi.Next();
            SqlConnection con = SQLLib.connectToSQL(lsi.PrimaryServer);
            SqlConnection con2 = SQLLib.connectToSQL(lsi.SecondaryServer);
            SQLLib.updateJob(con, lsi.BackupJobName, "@enabled", "tinyint", "0");
            con2 = SQLLib.connectToSQL(lsi.SecondaryServer);
            SQLLib.updateJob(con2, lsi.CopyJobName, "@enabled", "tinyint", "0");
            SQLLib.updateJob(con2, lsi.RestoreJobName, "@enabled", "tinyint", "0");
            // run backup job
            SQLLib.runJob(con, lsi.BackupJobName);
            // wait for backup job
            SQLLib.waitForJob(con, lsi.BackupJobName, "Idle", 5, 120, true);
            // run and wait for copy and restore jobs to clear any outstanding logs
            // (we need to run these, as they are disabled and may not have run since the last time the backup job completed)
            SQLLib.runJob(con2, lsi.CopyJobName);
            if (!SQLLib.waitForJob(con2, lsi.CopyJobName, "Idle", 5, 120, "Succeeded", true))
            {
                SQLLib.outputJobInfo(lsi.CopyJobName, con2);
                return false;
            }
            SQLLib.runJob(con2, lsi.RestoreJobName);
            if (!SQLLib.waitForJob(con2, lsi.RestoreJobName, "Idle", 5, 120, "Succeeded", true))
            {
                SQLLib.outputJobInfo(lsi.RestoreJobName, con2);
                return false;
            }
            // kill outstanding connections to the database
            SQLLib.killUsersInDB(con, lsi.PrimaryDatabase);
            // backup tail of the log on the primary with standby
            string options = string.Format("INIT, STANDBY='{0}\\{1}.undo'", arg.Files[0], lsi.PrimaryDatabase);
            SQLLib.backupLog(con, lsi.PrimaryDatabase, arg.Files[0], options);
            // restore the tail of the log with recovery across the network
            string restoreshare = String.Format("\\\\{0}\\bak", lsi.PrimaryServer);
            Console.WriteLine("Restore log from: {0}", restoreshare);
            if (SQLLib.restoreLog(con2, lsi.SecondaryDatabase, restoreshare, "RECOVERY"))
                success = true;
            // prompt for setup of log shipping in opposite direction
            return success;
        }

        private static bool fixReplication(ParsedArgs ar)
        {
            bool wasfixed = false;
            Int32 ErrNum = 0;
            string binval = string.Empty;
            string deltxt = string.Empty;
            string replcmd = string.Empty;
            Int32 commandid = -1;
            SqlCommand cmd = new SqlCommand();
            cmd.Connection = ar.SQLConn;
            cmd.CommandText = "sp_helpdistributor";
            cmd.CommandType = CommandType.StoredProcedure;
            SqlDataReader rdr = SQLLib.getReaderFromSP(cmd);
            string distSvr = SQLLib.getStringFromReader(rdr);
            string distDB = SQLLib.getStringFromReader(rdr, 1);
            SQLLib.disposeReader(rdr);
            if (distDB == string.Empty)
            {
                Console.WriteLine("Distribution database not found on server {0}.", ar.SQLConn.DataSource);
            }
            else
            {
                if (SQLLib.changeDatabase(ar.SQLConn, distDB))
                {
                    cmd.CommandText = "prc_lasterror";
                    rdr = SQLLib.getReaderFromSP(cmd);
                    if (SQLLib.verifyReader(rdr))
                    {
                        rdr.Read();
                        ErrNum = rdr.GetInt32(1);
                        binval = SQLLib.getStringFromReader(rdr);
                        commandid = rdr.GetInt32(2);
                        Console.WriteLine("Checking error type:");
                        switch (ErrNum)
                        {
                            case 2627:
                                Console.WriteLine("PK violation");
                                break;
                            case 2714:
                                Console.WriteLine("There is already an object named '' in the database");
                                break;
                            case 257 :
                                Console.WriteLine("Implicit conversion is not allowed");
                                break;
                            default:
                                Console.WriteLine("Error {0} not found.", ErrNum.ToString());
                                break;
                        }
                        SQLLib.disposeReader(rdr);
                    }
                    if (binval == string.Empty)
                    {
                        Console.WriteLine("No xact_seqno found in MSrepl_errors.");
                    }
                    else
                    {
                        Console.WriteLine("xact_seqno is {0}", binval);
                        Console.WriteLine("Command ID is {0}", commandid);
                        Console.WriteLine("Getting command ID from sp_browsereplcmds.");
                        cmd.CommandText = "sp_browsereplcmds";
                        cmd.CommandTimeout = 3000;
                        SqlParameter prm1 = cmd.Parameters.Add("@xact_seqno_start", SqlDbType.NVarChar, binval.Length);
                        prm1.Value = binval;
                        SqlParameter prm2 = cmd.Parameters.Add("@xact_seqno_end", SqlDbType.NVarChar, binval.Length);
                        prm2.Value = binval;
                        rdr = SQLLib.getReaderFromSP(cmd);
                        if (SQLLib.verifyReader(rdr, true))
                        {
                            while (rdr.Read())
                            {
                                if (rdr.GetInt32(11) == commandid)
                                {
                                    replcmd = SQLLib.getStringFromReader(rdr, 10);
                                    Console.WriteLine("{0}", replcmd);
                                }
                            }
                        }
                        else
                        {
                            Console.WriteLine("sp_browsereplcmds returned no rows");
                        }
                        SQLLib.disposeReader(rdr);
                        string delimStr = "(,[]";
                        char[] delimiter = delimStr.ToCharArray();
                        string[] replparams = replcmd.Split(delimiter);
                        switch (ErrNum)
                        {
                            case 2714:
                                if (replparams.Length > 9)
                                {
                                    deltxt = "ALTER TABLE ";
                                    deltxt += replparams[9] + " DROP CONSTRAINT ";
                                    deltxt += replparams[11];
                                }
                                rdr = SQLLib.getReplMonitorSubscriptions(ar.Server, distSvr, distDB, 0, true);
                                wasfixed = runAgainstSubs(rdr, deltxt, false);
                                break;
                            default:
                                break;
                        }
                    }
                }
            }
            Console.WriteLine();
            return wasfixed;
        }

        private static string getFQDN(string serverName)
        {
            Process pingProc = new Process();
            string FQDN = string.Empty;
            pingProc.StartInfo.UseShellExecute = false;
            pingProc.StartInfo.RedirectStandardOutput = true;
            pingProc.StartInfo.FileName = "Ping.exe";
            pingProc.StartInfo.Arguments = "/n 2 " + serverName;
            pingProc.Start();
            string output = pingProc.StandardOutput.ReadToEnd();
            pingProc.WaitForExit();
            if (output.IndexOf("Pinging") != -1)
            {
                string[] pingout = output.Split(' ');
                FQDN = pingout[1];
            }
            return FQDN;
        }

        private static ArrayList getKeyColumns(SqlConnection con, string db, string tbl)
        {
            ArrayList keyColumns = new ArrayList();
            if (SQLLib.changeDatabase(con, db))
            {
                string query = string.Format("SELECT c.name FROM sys.key_constraints k INNER JOIN sys.index_columns ic ON k.parent_object_id = ic.object_id AND k.unique_index_id = ic.index_id INNER JOIN sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id WHERE k.parent_object_id = object_id('{0}')", tbl);
                SqlDataReader rdr = SQLLib.getReaderFromSql(con, query);
                if (SQLLib.verifyReader(rdr))
                {
                    while (rdr.Read())
                    {
                        keyColumns.Add(SQLLib.getStringFromReader(rdr));
                    }
                }
                else
                {
                    Console.WriteLine("No PK data found for table '{0}'.", tbl);
                }
                SQLLib.disposeReader(rdr);
            }
            return keyColumns;
        }

        private static SqlDataReader getReplMonitorPendingCmds(SqlCommand cmd, string pubSrv, string pubDB, string pubName, string subSrv, string subDB)
        {
            cmd.Parameters.Clear();
            cmd.CommandText = "sp_replmonitorsubscriptionpendingcmds";
            cmd.CommandType = CommandType.StoredProcedure;
            SqlParameter prm1 = cmd.Parameters.Add("@publisher", SqlDbType.NVarChar, 128);
            prm1.Value = pubSrv;
            SqlParameter prm2 = cmd.Parameters.Add("@publisher_db", SqlDbType.NVarChar, 128);
            prm2.Value = pubDB;
            SqlParameter prm3 = cmd.Parameters.Add("@publication", SqlDbType.NVarChar, 128);
            prm3.Value = pubName;
            SqlParameter prm4 = cmd.Parameters.Add("@subscriber", SqlDbType.NVarChar, 128);
            prm4.Value = subSrv;
            SqlParameter prm5 = cmd.Parameters.Add("@subscriber_db", SqlDbType.NVarChar, 128);
            prm5.Value = subDB;
            SqlParameter prm6 = cmd.Parameters.Add("@subscription_type", SqlDbType.Int);
            prm6.Value = 0;
            SqlDataReader rdr = SQLLib.getReaderFromSP(cmd);
            return rdr;
        }

        private static ServiceCollection getServices(ManagedComputer comp)
        {
            ServiceCollection services = null;
            services = comp.Services;
            try
            {
                int tmp = services.Count;
            }
            catch (SmoException e)
            {
                Console.WriteLine("Error attempting to get services from server {0}:", comp.Name);
                Console.WriteLine(e.Message);
                services = null;
            }
            return services;
        }

        private static bool insertData(ParsedArgs arg)
        {
            bool success = false;
            bool joinStarted = false;
            ArrayList keyColumns = getKeyColumns(arg.SQLConn, arg.Database, arg.Additional);
            if (keyColumns.Count > 0)
            {
                string query = string.Format("INSERT INTO {0}{3}SELECT d.*{3}FROM {1}.{2}.dbo.{0} d{3}LEFT OUTER JOIN {0} t", arg.Additional, arg.Server, arg.Database, Environment.NewLine);
                foreach (string col in keyColumns)
                {
                    if (joinStarted)
                    {
                        query = string.Format("{0}{2}   AND d.{1} = t.{1}", query, col, Environment.NewLine);
                    }
                    else
                    {
                        query = string.Format("{0}{2}ON d.{1} = t.{1}", query, col, Environment.NewLine);
                        joinStarted = true;
                    }
                }
                query = string.Format("{0}{2}WHERE t.{1} IS NULL;", query, keyColumns[0], Environment.NewLine);
                SqlCommand insertCmd = new SqlCommand();
                if (SQLLib.changeDatabase(arg.SQLConn, arg.Database))
                {
                    insertCmd.Connection = arg.SQLConn;
                    if (arg.Modifier == "RUN")
                    {
                        if (SQLLib.executeNonQueryAtSql(insertCmd, query, true) == 0)
                            success = true;
                    }
                    else
                    {
                        sendOut(query);
                        Environment.Exit(0);
                    }
                }
            }
            return success;
        }

        private static bool installSQLAdmin(ParsedArgs arg)
        {
            bool success = false;
            if (!EventLog.SourceExists("SQLAdmin"))
            {
                try
                {
                    Console.WriteLine("Adding SQLAdmin to Application Eventlog");
                    EventLog.CreateEventSource("SQLAdmin", "Application");
                    success = true;
                }
                catch (SystemException e)
                {
                    Console.WriteLine("Error attempting to add event source 'SQLAdmin' to application event log:");
                    Console.WriteLine(e.Message);
                }
            }
            else
            {
                Console.WriteLine("'SQLAdmin' already exists as an event log source.");
                success = true;
            }
            Console.WriteLine();
            return success;
        }

        private static bool killDBUsers(ParsedArgs arg)
        {
            bool success = false;
            Console.WriteLine("Action: Kill SPIDs connected to databases matching name pattern '{0}'.", arg.Database);
            string[] dbs = arg.getDBList();
            if (dbs.Length > 0)
            {
                if (arg.Quiet)
                {
                    success = true;
                    foreach (string db in dbs)
                    {
                        // one failure should show overall failure for the action.
                        if (!SQLLib.killUsersInDB(arg.SQLConn, db))
                            success = false;
                    }
                }
                else
                {
                    if (confirmAction("kill users in", arg.Server, "database", dbs))
                    {
                        success = true;
                        foreach (string db in dbs)
                        {
                            // one failure should show overall failure for the action.
                            if (!SQLLib.killUsersInDB(arg.SQLConn, db))
                                success = false;
                        }
                    }
                }
            }
            Console.WriteLine();
            return success;
        }

        private static bool listJobs(ParsedArgs ar)
        {
            bool success = false;
            string[] jbs = ar.getJBList();
            if (jbs.Length > 0)
            {
                foreach (string jb in jbs)
                {
                    Console.WriteLine(jb);
                    success = true;
                }
            }
            return success;
        }

        /*******************************************************************
        Purpose: Log SQLAdmin action to command prompt and Windows Event Log
        Inputs : target     : server against which SQLAdmin was run
        *******************************************************************/
        public static void logEvent(string target, string sEvent)
        {
            // log an Information event in the application event log
            string sSource;
            sSource = "SQLAdmin";
            sEvent += "\r\nSQLAdmin user: " + Environment.UserDomainName;
            sEvent += "\\" + Environment.UserName;
            sEvent += "\r\nSQLAdmin client: " + Environment.MachineName;
            try
            {
                EventLog writeLog = new EventLog();
                writeLog.Log = "Application";
                writeLog.MachineName = target;
                writeLog.Source = sSource;
                writeLog.WriteEntry(sEvent);
            }
            catch (SystemException e)
            {
                // no work here - the event logging will fail silently and I'll document this in the GAST docs
                Console.WriteLine(e.Message);
            }
        }

        private static bool maintainDBs(ParsedArgs ar)
        {
            bool success = false;
            string[] dbs = ar.getDBList("database_id");
            string jobID;
            string jobName = ar.Additional;
            int jobStepID = 0;
            string stepName;
            string stepCmd;
            bool useLitespeed = false;
            if (dbs.Length > 0)
            {
                jobID = SQLLib.createJob(ar.SQLConn, jobName);
                if (ar.Modifier.IndexOf('D') != -1) // DBCC
                {
                    foreach (string db in dbs)
                    {
                        if (db != "tempdb") // DBCC operations are not allowed on tempdb
                        {
                            stepName = String.Format("DBCC CHECKDB on database {0}", db);
                            stepCmd = String.Format("DBCC CHECKDB({0}) WITH NO_INFOMSGS", db);
                            if (SQLLib.addStepToJob(ar.SQLConn, jobID, stepName, stepCmd))
                                jobStepID++;
                        }
                    }
                }
                if (ar.Modifier.IndexOf('B') != -1) // Backup
                {
                    if (SQLLib.LitespeedExists(ar.SQLConn))
                    {
                        if (ar.Quiet)
                        {
                            useLitespeed = true;
                        }
                        else
                        {
                            if (SQLLib.confirmChoice("use Litespeed for your database backups?"))
                                useLitespeed = true;
                        }
                    }
                    foreach (string db in dbs)
                    {
                        if (db != "tempdb") // backup operations are not allowed on tempdb
                        {
                            stepName = String.Format("Backup database {0}", db);
                            if (useLitespeed)
                            {
                                stepCmd = String.Format("EXEC xp_backup_database @database='{0}', @filename='{1}{0}.ls.bak', @init=1", db, ar.Files[0]);
                            }
                            else
                            {
                                stepCmd = String.Format("BACKUP DATABASE {0} TO DISK = '{1}{0}.bak' WITH INIT", db, ar.Files[0]);
                            }
                            if (SQLLib.addStepToJob(ar.SQLConn, jobID, stepName, stepCmd))
                                jobStepID++;
                        }
                    }
                }
                if (ar.CopyDestination != String.Empty)
                {
                    foreach (string db in dbs)
                    {
                        if (db != "tempdb") // there's no file to copy for tempdb
                        {
                            stepName = String.Format("Copy database {0} to backup destination", db);
                            if (useLitespeed)
                            {
                                stepCmd = String.Format("copy {1}{0}.ls.bak {2}{3}.{0}.ls.bak", db, ar.Files[0], ar.CopyDestination, ar.Server);
                            }
                            else
                            {
                                stepCmd = String.Format("copy {1}{0}.bak {2}{3}.{0}.ls.bak", db, ar.Files[0], ar.CopyDestination, ar.Server);
                            }
                            if (SQLLib.addStepToJob(ar.SQLConn, jobID, stepName, stepCmd, "cmdexec"))
                            {
                                jobStepID++;
                                SQLLib.updateJobStep(ar.SQLConn, jobName, jobStepID, "@retry_attempts", "int", "3");
                                SQLLib.updateJobStep(ar.SQLConn, jobName, jobStepID, "@retry_interval", "int", "15");
                            }
                        }
                    }
                }
            }
            if (jobStepID == 0)
            {
                Console.WriteLine("No steps added to job.  Check action modifier for valid codes.");
            }
            else
            {
                SQLLib.updateJobStep(ar.SQLConn, jobName, jobStepID, "@on_success_action", "tinyint", "1");
            }
            success = true;
            return success;
        }

        private static void makeLSShare(string comp, string dbname)
        {
            bool connect = false;
            bool shareexists = false;
            string wQL = "SELECT * FROM Win32_Share";
            ManagementScope ms = new ManagementScope(
                "\\\\" + comp + "\\root\\cimv2");
            try
            {
                ms.Connect();
                connect = true;
            }
            catch (SystemException ex)
            {
                Console.WriteLine("Error attempting to get share information:");
                Console.WriteLine(ex.Message);
            }
            if (connect)
            {
                WqlObjectQuery wqlQuery =
                    new WqlObjectQuery(wQL);
                ManagementObjectSearcher searcher =
                    new ManagementObjectSearcher(wqlQuery);
                searcher.Scope = ms;
                foreach (ManagementObject svc in searcher.Get())
                {
                    if (svc["Name"].ToString().ToUpper() == dbname.ToUpper())
                    {
                        Console.WriteLine("Share {0} already exists.  Skipping share create.", dbname);
                        shareexists = true;
                        break;
                    }
                }
                if (!shareexists)
                {
                    // create the share
                    string strPath = string.Format("E:\\MSSQL\\TRAN\\{0}_local", dbname);
                    makeShare(comp, strPath, dbname);
                }
            }
            return;
        }

        private static void makeShare(string servername, string filepath, string sharename)
        {
            try
            {
                // assemble the string so the scope represents the remote server
                string scope = string.Format("\\\\{0}\\root\\cimv2", servername);
                // connect to the WMI on the remote server
                ManagementScope ms = new ManagementScope(scope);
                // create a new instance of the Win32_Share WMI object
                ManagementClass cls = new ManagementClass("Win32_Share");
                // set the scope of the new instance to that created above
                cls.Scope = ms;
                // assemble the arguments to be passed to the Create method
                object[] methodargs = { filepath, sharename, "0" };
                // invoke the Create method to create the share
                object result = cls.InvokeMethod("Create", methodargs);
            }
            catch (SystemException e)
            {
                Console.WriteLine("Error attempting to create share:");
                Console.WriteLine(e.Message);
            }
        }

        private static string mapUpdateType(string parameter)
        {
            string type = string.Empty;
            switch (parameter)
            {
                case "@cmdexec_success_code":
                    type = "int";
                    break;
                case "@command":
                    type = "nvarchar(max)";
                    break;
                case "@deletelevel":
                    type = "int";
                    break;
                case "@description":
                    type = "nvarchar(512)";
                    break;
                case "@enabled":
                    type = "tinyint";
                    break;
                case "@flags":
                    type = "int";
                    break;
                case "@notify_level_eventlog":
                    type = "int";
                    break;
                case "@notify_level_email":
                    type = "int";
                    break;
                case "@notify_level_netsend":
                    type = "int";
                    break;
                case "@notify_level_page":
                    type = "int";
                    break;
                case "@on_fail_action":
                    type = "tinyint";
                    break;
                case "@on_fail_step_id":
                    type = "int";
                    break;
                case "@on_success_action":
                    type = "tinyint";
                    break;
                case "@on_success_step_id":
                    type = "int";
                    break;
                case "@output_file_name":
                    type = "nvarchar(200)";
                    break;
                case "@proxy_id":
                    type = "int";
                    break;
                case "@retry_attempts":
                    type = "int";
                    break;
                case "@retry_interval":
                    type = "int";
                    break;
                case "@start_step_id":
                    type = "int";
                    break;
                default:
                    type = "nvarchar(128)";
                    break;
            }
            return type;
        }

        private static bool openErrorlog(ParsedArgs arg)
        {
            bool success = false;
            // use parameters to get errorlog location (-e) and open using admin share
            ManagedComputer m = new ManagedComputer(arg.Server);
            ServiceCollection svcs = getServices(m);
            if (svcs != null)
            {
                foreach (Service svc in svcs)
                {
                    if (svc.Name == "MSSQLSERVER")
                    {
                        string output = svc.StartupParameters;
                        string[] outs = output.Split(';');
                        foreach (string o in outs)
                        {
                            if (o.Substring(0, 2) == "-e")
                            {
                                string filePath = SQLLib.getShareFromLocal(arg.Server, o.Substring(2, o.Length - 2));
                                if (arg.Modifier != string.Empty)
                                {
                                    filePath += "." + arg.Modifier;
                                }
                                if (File.Exists(filePath))
                                {
                                    Process noteProc = new Process();
                                    sendOut("Opening errorlog '{0}'.", filePath);
                                    noteProc.StartInfo.UseShellExecute = false;
                                    noteProc.StartInfo.RedirectStandardOutput = true;
                                    noteProc.StartInfo.FileName = "Notepad.exe";
                                    noteProc.StartInfo.Arguments = filePath;
                                    noteProc.Start();
                                    success = true;
                                }
                                else
                                {
                                    Console.WriteLine("File not found: '{0}'", filePath);
                                    if (arg.Modifier != string.Empty)
                                    {
                                        Console.WriteLine("Verify that action modifier '{0}' is a valid errorlog extension.", arg.Modifier);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            Console.WriteLine();
            return success;
        }

        private static bool outputDBUsage(ParsedArgs ar)
        {
            bool success = false;
            int stringlen = 6;
            string output = String.Empty;
            string[] dbs = ar.getDBList();
            decimal totaldatasize = 0;
            decimal totaldataused = 0;
            decimal totaldatapercent = 0;
            decimal totallogsize = 0;
            decimal totallogused = 0;
            decimal totallogpercent = 0;
            if (dbs.Length > 0)
            {
                foreach (string db in dbs)
                {
                    if (db.Length > stringlen)
                        stringlen = db.Length;
                }
                if (stringlen > 27)
                    stringlen = 27;
                output = "DBName".PadRight(stringlen, ' ');
                output += "|Recovery  |Data Size|Data Used|%Used|Log Size|%Used";
                Console.WriteLine(output);
                output = "".PadRight(stringlen, '-');
                output += "|----------|---------|---------|-----|--------|-----";
                Console.WriteLine(output);
                foreach (string db in dbs)
                {
                    Database smodb = SQLLib.getSMODatabase(ar.ServerConn, db);
                    output = smodb.Name.PadRight(stringlen, ' ');
                    if (output.Length > 27)
                        output = output.Substring(0, 27);
                    output += "|";
                    output += smodb.DatabaseOptions.RecoveryModel.ToString().PadRight(10, ' ') + "|";
                    if (smodb.Status.ToString().IndexOf("Normal") != -1)
                    {
                        DBInfo dbu = new DBInfo(smodb.Name, ar.SQLConn);
                        dbu.getUsage();
                        totaldatasize += dbu.DataSizeInMB;
                        totallogsize += dbu.LogSizeInMB;
                        totaldataused += dbu.DataUsedInMB;
                        totallogused += dbu.LogUsedInMB;
                        output += dbu.DataSizeInMB.ToString().PadLeft(9, ' ') + "|";
                        output += dbu.DataUsedInMB.ToString().PadLeft(9, ' ') + "|";
                        output += dbu.DataPercentUsed.ToString().PadLeft(5, ' ') + "|";
                        output += dbu.LogSizeInMB.ToString().PadLeft(8, ' ') + "|";
                        output += dbu.LogPercentUsed.ToString().PadLeft(5, ' ');
                        // we succeeded if we got good space data for at least one asked-for DB
                        success = true;
                    }
                    else
                    {
                        output += "Unavailable due to status of " + smodb.Status.ToString();
                    }
                    Console.WriteLine(output);
                }
                if (dbs.Length != 1)
                {
                    if (totaldatasize > 0)
                    {
                        totaldatapercent = totaldataused / totaldatasize * 100;
                    }
                    else
                    {
                        totaldatapercent = 0;
                    }
                    if (totallogsize > 0)
                    {
                        totallogpercent = totallogused / totallogsize * 100;
                    }
                    else
                    {
                        totallogpercent = 0;
                    }
                    output = "".PadRight(stringlen, '-');
                    output += "|----------|---------|---------|-----|--------|-----";
                    Console.WriteLine(output);
                    output = "Total".PadRight(stringlen, ' ') + "|";
                    output += "          |";
                    output += totaldatasize.ToString().PadLeft(9, ' ') + "|";
                    output += totaldataused.ToString().PadLeft(9, ' ') + "|";
                    output += totaldatapercent.ToString("F1").PadLeft(5, ' ') + "|";
                    output += totallogsize.ToString().PadLeft(8, ' ') + "|";
                    output += totallogpercent.ToString("F1").PadLeft(5, ' ');
                    Console.WriteLine(output);
                }
            }
            return success;
        }

        private static bool outputJobHistory(ParsedArgs arg)
        {
            bool success = false;
            string[] jbs = arg.getJBList();
            if (jbs.Length > 0)
            {
                foreach (string jb in jbs)
                {
                    success = SQLLib.outputJobHist(jb, arg.SQLConn);
                }
            }
            return success;
        }

        private static bool outputLogShippingStatus(ParsedArgs arg)
        {
            bool success = false;
            string outstr = string.Empty;
            string streamdesc = string.Empty;
            ConsoleColor clr = Console.ForegroundColor;
            LSInfo lsi = new LSInfo(arg.Server);
            while (lsi.Next())
            {
                outstr = string.Empty;
                streamdesc = string.Format("{0}.{1} -> {2}.{3}", lsi.PrimaryServer, lsi.PrimaryDatabase, lsi.SecondaryServer, lsi.SecondaryDatabase);
                if (lsi.Status)
                {
                    // alert status
                    Console.ForegroundColor = ConsoleColor.Red;
                    outstr = string.Format("Log shipping stream '{0}' is not in synch.{1}", streamdesc, Environment.NewLine);
                }
                else
                {
                    // all is well
                    Console.ForegroundColor = ConsoleColor.Green;
                }
                Console.WriteLine();
                Console.WriteLine(streamdesc);
                Console.WriteLine();
                Console.WriteLine(" Backup| Backup|   Copy|Restore|Restore|   File");
                Console.WriteLine("Latency|Thrshld|Latency|Latency|Thrshld|Latency");
                Console.WriteLine("-------|-------|-------|-------|-------|-------");
                outstr = addInt32ToString(outstr, lsi.BackupLatency, 7) + "|";
                outstr = addInt32ToString(outstr, lsi.BackupThreshold, 7) + "|";
                outstr = addInt32ToString(outstr, lsi.CopyLatency, 7) + "|";
                outstr = addInt32ToString(outstr, lsi.RestoreLatency, 7) + "|";
                outstr = addInt32ToString(outstr, lsi.RestoreThreshold, 7) + "|";
                outstr = addInt32ToString(outstr, lsi.FileLatency, 7);
                Console.WriteLine(outstr);
                Console.WriteLine();
                Console.ForegroundColor = clr;
                success = true;
            }
            if (!success)
            {
                Console.WriteLine("No log shipping streams found.");
                Console.WriteLine();
            }
            return success;
        }

        private static bool outputStartupParams(ParsedArgs a)
        {
            bool success = false;
            ManagedComputer mc = new ManagedComputer(a.Server);
            ServiceCollection svcs = getServices(mc);
            if (svcs != null)
            {
                Console.WriteLine("Startup parameters for SQL Server '{0}':", mc.Name);
                foreach (Service svc in svcs)
                {
                    if (svc.Name == "MSSQLSERVER")
                    {
                        string output = svc.StartupParameters;
                        string[] outs = output.Split(';');
                        foreach (string o in outs)
                        {
                            Console.WriteLine(o);
                        }
                        success = true;
                    }
                }
            }
            Console.WriteLine();
            return success;
        }

        private static bool queryJobs(ParsedArgs ar)
        {
            bool success = false;
            string[] jbs = ar.getJBList();
            if (jbs.Length > 0)
            {
                foreach (string jb in jbs)
                {
                    success = SQLLib.outputJobInfo(jb, ar.SQLConn);
                }
            }
            return success;
        }

        private static bool queryReplication(ParsedArgs a)
        {
            bool success = false;
            bool streamexists = false;
            string output = string.Empty;
            int dblen = 28;
            int seclen = 8;
            RPInfo subinfo = new RPInfo(a.Server, "Transactional");
            while (subinfo.Next())
            {
                // get the width of the items for which we're interested in sending output.
                output = subinfo.PublisherDatabase + subinfo.SubscriberServer + subinfo.SubscriberDatabase;
                if (output.Length + 5 > dblen)
                    dblen = output.Length + 5;
                output = timeFromSeconds(subinfo.Latency);
                if (output.Length > seclen)
                    seclen = output.Length;
                streamexists = true;
            }
            if (streamexists)
            {
                // start again from the beginning of the replication subscription list
                subinfo.Refresh();
                output = "Database -> DestSrvr.DestDB".PadRight(dblen, ' ') + "|";
                output += "Latency".PadRight(seclen, ' ');
                output += "|Status";
                Console.WriteLine(output);
                Console.WriteLine("".PadRight(output.Length, '-'));
                while (subinfo.Next())
                {
                    output = string.Empty;
                    success = true;
                    output += subinfo.PublisherDatabase;
                    output += " -> " + subinfo.SubscriberServer;
                    output += "." + subinfo.SubscriberDatabase;
                    output = output.PadRight(dblen, ' ');
                    output += "|" + timeFromSeconds(subinfo.Latency).PadLeft(seclen, ' ');
                    output += "|" + subinfo.Status;
                    Console.WriteLine(output);
                    output = string.Empty;
                    if (a.Modifier == "COUNT")
                    {
                        // count the undelivered transactions
                        SqlCommand latcmd = new SqlCommand();
                        latcmd.Connection = a.SQLConn;

                    }
                }
            }
            subinfo.Dispose();
            Console.WriteLine();
            return success;
        }

        internal static string replaceNoCase(string input, string tolookfor, string replacement)
        {
            string returnstring = input;    // if we make no alteration, return the original value
            // convert both the input and the string to look for to all caps
            string input_allcaps = input.ToUpper();
            string tolookfor_allcaps = tolookfor.ToUpper();
            string found = string.Empty;
            // if it's there, find the string in the case-insensitive search
            int startindex = input_allcaps.IndexOf(tolookfor_allcaps);
            if (startindex > -1)
            {
                // if we found it, use its location to get the actual case-sensitive string
                found = input.Substring(startindex, tolookfor.Length);
                // now replace the case-sensitive string via the System string.replace method.
                returnstring = input.Replace(found, replacement);
            }
            return returnstring;
        }

        private static bool restoreDatabases(ParsedArgs a)
        {
            bool success = false;
            string db = a.Database;
            bool useLitespeed = false;
            if (SQLLib.LitespeedExists(a.SQLConn))
            {
                sendOut("Litespeed detected.  Using it for restore.");
                sendOut("NOTE: Litespeed can restore regular SQL Server format backups.");
                sendOut("Unless specified, the filename used for each db will be [dbname].ls.bak.");
                useLitespeed = true;
            }
            if (db != string.Empty)
            {
                switch (db)
                {
                    case "tempdb" :
                        Console.WriteLine("NOTE: Restore operations are not allowed on tempdb!{0}", Environment.NewLine);
                        break;
                    case "master":
                        Console.WriteLine("NOTE: Restore operations are not allowed on master!{0}", Environment.NewLine);
                        break;
                    case "model":
                        Console.WriteLine("NOTE: Restore operations are not allowed on model!{0}", Environment.NewLine);
                        break;
                    case "msdb":
                        Console.WriteLine("NOTE: Restore operations are not allowed on msdb!{0}", Environment.NewLine);
                        break;
                    default :
                        if (SQLLib.restoreDatabase(a.SQLConn, db, a.Files, a.Modifier, useLitespeed))
                            success = true;
                        Console.WriteLine();
                        break;
                }
            }
            return success;
        }

        private static bool runAction(ParsedArgs arg)
        {
            if (arg.Debug)
            {
                Console.WriteLine("runAction begins");
                Console.WriteLine("Action is " + arg.Action);
            }
            bool blnSuccess = false;
            switch (arg.Action)
            {
                case "DBBA" :
                    blnSuccess = backupDatabases(arg);
                    break;
                case "DBBC" :
                    blnSuccess = backupCopyRestoreDatabases(arg);
                    break;
                case "DBDR" :
                    blnSuccess = dropDatabases(arg);
                    break;
                case "DBMA" :
                    blnSuccess = maintainDBs(arg);
                    break;
                case "DBRE" :
                    blnSuccess = restoreDatabases(arg);
                    break;
                case "DBSP" :
                    blnSuccess = outputDBUsage(arg);
                    break;
                case "DTIN" :
                    blnSuccess = insertData(arg);
                    break;
                case "ELOP" :
                    blnSuccess = openErrorlog(arg);
                    break;
                case "INST" :
                    blnSuccess = installSQLAdmin(arg);
                    break;
                case "JBAD":
                    blnSuccess = addJobStepsFromFiles(arg);
                    break;
                case "JBCO":
                    blnSuccess = copyJob(arg);
                    break;
                case "JBCR":
                    blnSuccess = createJobFromFiles(arg);
                    break;
                case "JBDE" :
                    blnSuccess = deleteJobs(arg);
                    break;
                case "JBEN" :
                    blnSuccess = setJobsEnabled(arg);
                    break;
                case "JBHI" :
                    blnSuccess = outputJobHistory(arg);
                    break;
                case "JBLI" :
                    blnSuccess = listJobs(arg);
                    break;
                case "JBOW" :
                    blnSuccess = setJobOwners(arg);
                    break;
                case "JBQU" :
                    blnSuccess = queryJobs(arg);
                    break;
                case "JBRU" :
                    blnSuccess = runJobs(arg);
                    break;
                case "JBSC" :
                    blnSuccess = scriptJobs(arg);
                    break;
                case "JBST" :
                    blnSuccess = stopJobs(arg);
                    break;
                case "JBUP" :
                    blnSuccess = updateJobs(arg);
                    break;
                case "JBWA" :
                    blnSuccess = waitForJobs(arg);
                    break;
                case "LSFA":
                    blnSuccess = failoverLogShipping(arg);
                    break;
                case "LSSE":
                    blnSuccess = setupLogShipping(arg);
                    break;
                case "LSQU" :
                    blnSuccess = outputLogShippingStatus(arg);
                    break;
                case "MRSE" :
                    blnSuccess = setupMirroring(arg);
                    break;
                case "RPDR" :
                    blnSuccess = dropReplication(arg);
                    break;
                case "RPFI" :
                    blnSuccess = fixReplication(arg);
                    break;
                case "RPQU" :
                    blnSuccess = queryReplication(arg);
                    break;
                case "RPWA" :
                    blnSuccess = waitForReplication(arg);
                    break;
                case "SPKI":
                    blnSuccess = killDBUsers(arg);
                    break;
                case "SPWA":
                    SQLLib.waitForSPID(arg.SQLConn, arg.Additional, 30, true);
                    Console.WriteLine();
                    blnSuccess = true;
                    break;
                case "STAD" :
                    blnSuccess = addStartupParam(arg);
                    break;
                case "STQU" :
                    blnSuccess = outputStartupParams(arg);
                    break;
                case "USAG" :
                    Usage(arg.ExecutableLocation);
                    blnSuccess = true;
                    break;
                default     :
                    Console.WriteLine("Call to invalid action '{0}' in runAction", arg.Action);
                    break;
            }
            return blnSuccess;
        }

        private static bool runAgainstSubs(SqlDataReader rdr, string deltxt)
        {
            bool wasfixed = runAgainstSubs(rdr, deltxt, true);
            return wasfixed;
        }

        private static bool runAgainstSubs(SqlDataReader rdr, string deltxt, bool failonzero)
        {
            bool wasfixed = false;
            bool wasrun = false;
            int numofrows;
            if (SQLLib.verifyReader(rdr))
            {
                while (rdr.Read())
                {
                    if (rdr.GetInt32(0) > 4)
                    {
                        string subSrv = rdr.GetString(2);
                        string subDB = rdr.GetString(3);
                        SqlConnection subCon = SQLLib.connectToSQL(subSrv, subDB);
                        SqlCommand delCmd = new SqlCommand();
                        delCmd.Connection = subCon;
                        Console.WriteLine("Executing the following command at {0}.{1}", subSrv, subDB);
                        Console.WriteLine(deltxt);
                        wasrun = true;
                        numofrows = SQLLib.executeNonQueryAtSql(delCmd, deltxt);
                        if (failonzero)
                        {
                            if (numofrows > 0)
                            {
                                wasfixed = true;
                                Console.WriteLine("{0} rows affected.", numofrows.ToString());
                            }
                            else
                            {
                                Console.WriteLine("{0} rows affected.", numofrows.ToString());
                            }
                        }
                        else
                        {
                            if (numofrows >= 0)
                            {
                                wasfixed = true;
                            }
                        }
                    }
                }
                if (!wasrun)
                {
                    Console.WriteLine("No subscriptions found having status of Retry or Failed.");
                }
            }
            return wasfixed;
        }

        private static bool runJobs(ParsedArgs ar)
        {
            bool success = false;
            // get the list of jobs
            string[] jbs = ar.getJBList();
            if (jbs.Length > 0)
            {
                // if we found a job, then we're successful so far
                success = true;
                foreach (string jb in jbs)
                {
                    // one failure stops the check for success
                    // this ensures that success of SQLAdmin means we started every job successfully
                    if (success)
                    {
                        // if we have success to this point, we have the opportunity to succeed or fail here
                        success = SQLLib.runJob(ar.SQLConn, jb, ar.Modifier);
                    }
                    else
                    {
                        // previous failure sets success to false; successes and failures after that don't matter
                        SQLLib.runJob(ar.SQLConn, jb, ar.Modifier);
                    }
                }
            }
            return success;
        }

        private static bool scriptJobs(ParsedArgs ar)
        {
            bool success = false;
            string[] jbs = ar.getJBList();
            string[] subvals = null;
            string outval = string.Empty;
            StringCollection sc = new StringCollection();
            if (jbs.Length > 0)
            {
                Server srv = new Server(ar.ServerConn);
                foreach (Job objJ in (srv.JobServer.Jobs))
                {
                    if (Array.IndexOf(jbs, objJ.Name.ToString()) != -1)
                    {
                        sendOut("IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'" + objJ.Name.ToString() + "')");
                        sendOut("EXEC msdb.dbo.sp_delete_job @job_name=N'" + objJ.Name.ToString() +"', @delete_unused_schedule=1");
                        sendOut("GO");
                        try
                        {
                            sc = objJ.Script();
                            success = true;
                        }
                        catch (SystemException e)
                        {
                            sendOut("Error attempting to generate script for job '{0}':", objJ.Name.ToString());
                            sendOut(e.Message);
                        }
                        foreach (string s in sc)
                        {
                            if (ar.Substitutions != null)
                            {
                                // substitute values from substitutions
                                foreach (string sub in ar.Substitutions)
                                {
                                    subvals = sub.Split('=');
                                    if (subvals.Length > 1)
                                    {
                                        subvals[1] = string.Format("$({0})", subvals[1]);
                                        outval = s.Replace(subvals[0], subvals[1]);
                                    }
                                }
                            }
                            else
                            {
                                outval = s;
                            }
                            sendOut(outval);
                        }
                        sendOut("GO");
                    }
                    if (LogObj != null)
                        LogObj.Flush();
                }
            }
            return success;
        }

        internal static void sendOut(string msg)
        {
            Console.WriteLine(msg);
            if (LogObj != null)
                LogObj.WriteLine(msg);
        }

        internal static void sendOut(string msg, string param1)
        {
            Console.WriteLine(msg, param1);
            if (LogObj != null)
                LogObj.WriteLine(msg, param1);
        }

        internal static void sendOut(string msg, string param1, string param2)
        {
            Console.WriteLine(msg, param1, param2);
            if (LogObj != null)
                LogObj.WriteLine(msg, param1, param2);
        }

        internal static void sendOut(string msg, string param1, string param2, string param3)
        {
            Console.WriteLine(msg, param1, param2, param3);
            if (LogObj != null)
                LogObj.WriteLine(msg, param1, param2, param3);
        }

        internal static void sendOut(string msg, string param1, string param2, string param3, string param4)
        {
            Console.WriteLine(msg, param1, param2, param3, param4);
            if (LogObj != null)
                LogObj.WriteLine(msg, param1, param2, param3, param4);
        }

        private static bool setJobOwners(ParsedArgs ar)
        {
            bool success = false;
            string[] jbs = ar.getJBList();
            if (jbs.Length > 0)
            {
                foreach (string jb in jbs)
                {
                    JBInfo jbi = new JBInfo(ar.SQLConn, jb);
                    if (jbi.Owner == ar.Modifier)
                    {
                        Console.WriteLine("Job owner is already '{0}'.", ar.Modifier);
                        success = true;
                    }
                    else
                    {
                        Console.WriteLine("Setting job owner to '{0}' on job '{1}'.", ar.Modifier, jb);
                        SqlCommand cmd = new SqlCommand();
                        cmd.Connection = ar.SQLConn;
                        cmd.CommandText = "sp_update_job";
                        cmd.CommandType = CommandType.StoredProcedure;
                        SqlParameter prmr = cmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
                        prmr.Direction = ParameterDirection.ReturnValue;
                        SqlParameter prm1 = cmd.Parameters.Add("@job_name", SqlDbType.NVarChar, 128);
                        prm1.Value = jb;
                        SqlParameter prm2 = cmd.Parameters.Add("@owner_login_name", SqlDbType.NVarChar, 128);
                        prm2.Value = ar.Modifier;
                        if (SQLLib.executeStoredProc(cmd, true))
                        {
                            success = true;
                            string evt = string.Format("Set job owner to '{0}' on job '{1}'.", ar.Modifier, jb);
                            logEvent(ar.SQLConn.DataSource, evt);
                        }
                    }
                    SQLLib.outputJobInfo(jb, ar.SQLConn);
                }
            }
            return success;
        }

        private static bool setJobsEnabled(ParsedArgs ar)
        {
            bool success = false;
            string[] jbs = ar.getJBList();
            if (jbs.Length > 0)
            {
                foreach (string jb in jbs)
                {
                    success = SQLLib.updateJob(ar.SQLConn, jb, "@enabled", "tinyint", ar.Modifier);
                    SQLLib.outputJobInfo(jb, ar.SQLConn);
                }
            }
            return success;
        }

        private static bool setupLogShipping(ParsedArgs arg)
        {
            bool success = false;
            string[] dbs = arg.getDBList();
            string[] jobIDs = new string[2];
            string[] backupfiles = arg.Files;
            string sourceshare;
            string destshare;
            bool BCRdone = false;
            bool useLitespeed = false;
            makeLSShare(arg.Server, arg.Database);
            if (SQLLib.LitespeedExists(arg.SQLConn) && SQLLib.LitespeedExists(arg.SQLConn2))
            {
                if (arg.Quiet)
                {
                    useLitespeed = true;
                }
                else
                {
                    if (SQLLib.confirmChoice("Use Litespeed for your database backups?"))
                        useLitespeed = true;
                }
            }
            foreach (string db in dbs)
            {
                sourceshare = SQLLib.getShareFromLocal(arg.Server, arg.Files[0]);
                sourceshare = string.Format("{0}{1}_local\\", sourceshare, db);
                // chain of successes ultimately leads to successful completion of log shipping setup
                success = SQLLib.verifyFolder(sourceshare);
                if (success)
                {
                    destshare = SQLLib.getShareFromLocal(arg.Server2, arg.Files[0]);
                    destshare = string.Format("{0}{1}\\", destshare, db);
                    success = SQLLib.verifyFolder(destshare);
                }
                // verify the existence of the share that log shipping will use

                // verify the existence of the \bak share

                if (success)
                    success = SQLLib.setDBOption(arg.SQLConn, db, "RECOVERY", "FULL");
                // verify that the database exists at the destination.  If not, BCR it.
                DBInfo destdb = new DBInfo(db, arg.SQLConn2);
                if (!destdb.DBExists)
                {
                    success = SQLLib.backupCopyRestoreDatabase(arg.SQLConn, arg.SQLConn2, db, db, backupfiles, string.Empty, string.Format("REPLACE, STANDBY=\"{0}{1}.undo\"", arg.Files, db), useLitespeed);
                    if (success)
                        BCRdone = true;
                }
                string jobID = SQLLib.addLogShippingPrimary(arg.SQLConn, arg.Server, db, arg.Server2, arg.Files[0]);
                int schID = SQLLib.addLogShippingSchedule(arg.SQLConn, "Backup", arg.Server, db);
                if (success)
                    success = SQLLib.attachJobSchedule(arg.SQLConn, jobID, schID);
                if (success)
                    success = SQLLib.updateJob(arg.SQLConn, SQLLib.getJobNameFromID(arg.SQLConn, jobID), "@enabled", "tinyint", "1");
                if (success)
                    success = SQLLib.addLogShippingPrimarySecondary(arg.SQLConn, arg.Server, db, arg.Server2);
                if (success)
                    success = SQLLib.processLogShippingMonitorPrimary(arg.SQLConn2, arg.Server, arg.Server2, db);
                if (success)
                    jobIDs = SQLLib.addLogShippingSecondaryPrimary(arg.SQLConn2, arg.Server, db, arg.Server2);
                if (success)
                    schID = SQLLib.addLogShippingSchedule(arg.SQLConn2, "Copy", arg.Server, db);
                if (success)
                    success = SQLLib.attachJobSchedule(arg.SQLConn2, jobIDs[0], schID);
                if (success)
                    schID = SQLLib.addLogShippingSchedule(arg.SQLConn2, "Restore", arg.Server, db);
                if (success)
                    success = SQLLib.attachJobSchedule(arg.SQLConn2, jobIDs[1], schID);
                if (success)
                    success = SQLLib.addLogShippingSecondaryDatabase(arg.SQLConn2, arg.Server, db);
                if (success)
                    success = SQLLib.updateJob(arg.SQLConn2, SQLLib.getJobNameFromID(arg.SQLConn2, jobIDs[0]), "@enabled", "tinyint", "1");
                if (success)
                    success = SQLLib.updateJob(arg.SQLConn2, SQLLib.getJobNameFromID(arg.SQLConn2, jobIDs[1]), "@enabled", "tinyint", "1");
                if (success)
                {
                    if (!BCRdone)
                    {
                        success = SQLLib.backupCopyRestoreDatabase(arg.SQLConn, arg.SQLConn2, db, db, backupfiles, string.Empty, string.Format("REPLACE, STANDBY=\"{0}{1}.undo\"", arg.Files[0], db), useLitespeed);
                    }
                }
            }
            return success;
        }

        private static bool setupMirroring(ParsedArgs arg)
        {
            bool success = false;
            bool useLitespeed = false;
            string[] backupfiles = arg.Files;
            string PriFQDN = getFQDN(arg.Server);
            string SecFQDN = getFQDN(arg.Server2);
            string TSQL = string.Empty;
            if (SQLLib.LitespeedExists(arg.SQLConn) && SQLLib.LitespeedExists(arg.SQLConn2))
            {
                if (arg.Quiet)
                {
                    useLitespeed = true;
                }
                else
                {
                    if (SQLLib.confirmChoice("Use Litespeed for your database backups?"))
                        useLitespeed = true;
                }
            }
            string[] dbs = arg.getDBList();
            // see if the endpoints already exist
            foreach (string db in dbs)
            {
                sendOut("Removing mirroring, if it exists.");
                TSQL = string.Format("ALTER DATABASE {0} SET PARTNER OFF", db);
                SQLLib.executeNonQueryAtSql(arg.SQLConn2, TSQL, false);
                SQLLib.createMirroringEndpoint(arg.SQLConn);
                SQLLib.createMirroringEndpoint(arg.SQLConn2);
                if (arg.Witness != string.Empty)
                {
                    SqlConnection SQLConn3 = SQLLib.connectToSQL(arg.Witness);
                    SQLLib.createMirroringEndpoint(SQLConn3);
                }
                SQLLib.setDBOption(arg.SQLConn, db, "RECOVERY", "FULL");
                success = SQLLib.backupCopyRestoreDatabase(arg.SQLConn, arg.SQLConn2, db, db, backupfiles, string.Empty, string.Format("REPLACE, NORECOVERY", arg.Files, db), useLitespeed);
                if (success)
                {
                    success = SQLLib.backupLog(arg.SQLConn, db, backupfiles[0], string.Empty);
                    if (success)
                    {
                        success = false;
                        // restore the tail of the log with recovery across the network
                        string restoreshare = String.Format("\\\\{0}\\{1}", arg.Server, SQLLib.getShareNameFromFolderPath(backupfiles[0]));
                        sendOut("Restore log from: {0}", restoreshare);
                        if (SQLLib.restoreLog(arg.SQLConn2, db, restoreshare, "NORECOVERY"))
                            success = true;
                        if (success)
                        {
                            success = false;
                            sendOut("Setting partner on secondary server.");
                            TSQL = string.Format("ALTER DATABASE {0} SET PARTNER = 'TCP://{1}:7022'", db, PriFQDN);
                            if (SQLLib.executeNonQueryAtSql(arg.SQLConn2, TSQL) != -1)
                                success = true;
                            if (success)
                            {
                                success = false;
                                sendOut("Setting partner on primary server.");
                                TSQL = string.Format("ALTER DATABASE {0} SET PARTNER = 'TCP://{1}:7022'", db, SecFQDN);
                                if (SQLLib.executeNonQueryAtSql(arg.SQLConn, TSQL) != -1)
                                    success = true;
                                if (success)
                                {
                                    success = false;
                                    if (!(arg.Modifier != string.Empty && arg.Modifier.Substring(0, 3).ToUpper() == "SYN"))
                                    {
                                        sendOut("Setting asynchronous mode.");
                                        TSQL = string.Format("ALTER DATABASE {0} SET PARTNER SAFETY OFF", db);
                                        if (SQLLib.executeNonQueryAtSql(arg.SQLConn, TSQL) != -1)
                                        {
                                            success = true;
                                        }
                                    }
                                    else
                                    {
                                        if (arg.Witness == string.Empty)
                                        {
                                            success = true; // if no witness is called for, we're done
                                        }
                                        else
                                        {
                                            string WitFQDN = getFQDN(arg.Witness);
                                            sendOut("Setting witness server to '{0}'.", arg.Witness);
                                            TSQL = string.Format("ALTER DATABASE {0} SET WITNESS = 'TCP://{1}:7022'", db, WitFQDN);
                                            if (SQLLib.executeNonQueryAtSql(arg.SQLConn, TSQL) != -1)
                                                success = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return success;
        }

        private static bool stopJobs(ParsedArgs arg)
        {
            bool success = false;
            // get the list of jobs
            string[] jbs = arg.getJBList();
            if (jbs.Length > 0)
            {
                // if we found a job, then we're successful so far
                success = true;
                foreach (string jb in jbs)
                {
                    // one failure stops the check for success
                    // this ensures that success of SQLAdmin means we started every job successfully
                    if (success)
                    {
                        // if we have success to this point, we have the opportunity to succeed or fail here
                        success = SQLLib.stopJob(arg.SQLConn, jb, true);
                    }
                    else
                    {
                        // previous failure sets success to false; successes and failures after that don't matter
                        SQLLib.stopJob(arg.SQLConn, jb, true);
                    }
                }
            }
            return success;
        }

        private static string timeFromSeconds(int seconds)
        {
            string retval = string.Empty;
            int hours = seconds / 3600;
            string hrstr = hours.ToString().PadLeft(2, '0');
            seconds = seconds % 3600;
            int minutes = seconds / 60;
            string minstr = minutes.ToString().PadLeft(2, '0');
            seconds = seconds % 60;
            string secstr = seconds.ToString().PadLeft(2, '0');
            retval = string.Format("{0}:{1}:{2}", hrstr, minstr, secstr);
            return retval;
        }

        private static bool updateJobs(ParsedArgs arg)
        {
            bool success = false;
            string[] jbs = arg.getJBList();
            if (jbs.Length > 0)
            {
                foreach (string jb in jbs)
                {
                    if (arg.Modifier == string.Empty)
                    {
                        success = SQLLib.updateJob(arg.SQLConn, jb, arg.UpdateParameter, mapUpdateType(arg.UpdateParameter), arg.UpdateValue);
                    }
                    else
                    {
                        success = SQLLib.updateJobStep(arg.SQLConn, jb, Convert.ToInt32(arg.Modifier), arg.UpdateParameter, mapUpdateType(arg.UpdateParameter), arg.UpdateValue);
                    }
                    SQLLib.outputJobInfo(jb, arg.SQLConn);
                }
            }
            return success;
        }

        private static bool waitForJobs(ParsedArgs ar)
        {
            bool success = false;
            string[] jbs = ar.getJBList();
            if (jbs.Length > 0)
            {
                foreach (string jb in jbs)
                {
                    success = SQLLib.waitForJob(ar.SQLConn, jb, "Idle", 30, 1000000, ar.Modifier, true);
                }
            }
            return success;
        }

        private static bool waitForReplication(ParsedArgs arg)
        {
            sendOut("Action: Wait for replication to synch from publisher '{0}'.{1}", arg.Server, Environment.NewLine);
            bool insync = false;
            int tracer_id = -1;
            long distlatency;
            string distlatencystr;
            long sublatency;
            string sublatencystr;
            long totlatency;
            string totlatencystr;
            string subscriber;
            string subscriberdb;
            Console.WriteLine("Pubtype: {0}", arg.Modifier);
            RPInfo subinfo = new RPInfo(arg.Server, arg.Modifier);
            Console.WriteLine("Pubtype from object: {0}", subinfo.PublicationType);
            if (subinfo.PublicationType == "Transactional")
            {
                // For transactional publications, drop a tracer token into the stream and verify that it goes through.
                while (subinfo.Next())
                {
                    if (SQLLib.changeDatabase(arg.SQLConn, subinfo.PublisherDatabase))
                    {
                        // drop tracer token
                        Console.WriteLine("Posting tracer token.");
                        SqlCommand cmd = new SqlCommand();
                        cmd.Connection = arg.SQLConn;
                        cmd.CommandText = "sys.sp_posttracertoken";
                        cmd.CommandType = CommandType.StoredProcedure;
                        SqlParameter prmr = cmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
                        prmr.Direction = ParameterDirection.ReturnValue;
                        SqlParameter prm1 = cmd.Parameters.Add("@publication", SqlDbType.VarChar, 128);
                        prm1.Value = subinfo.PublicationName;
                        SqlParameter prm2 = cmd.Parameters.Add("@tracer_token_id", SqlDbType.Int);
                        prm2.Direction = ParameterDirection.Output;
                        if (SQLLib.executeStoredProc(cmd, true))
                        {
                            // get tracer token id from stored proc call
                            tracer_id = Convert.ToInt32(prm2.Value);
                            cmd.Parameters.Clear();
                            // track tracer token
                            cmd.CommandText = "sys.sp_helptracertokenhistory";
                            prmr = cmd.Parameters.Add("RETURN_VALUE", SqlDbType.Int);
                            prmr.Direction = ParameterDirection.ReturnValue;
                            prm1 = cmd.Parameters.Add("@publication", SqlDbType.VarChar, 128);
                            prm1.Value = subinfo.PublicationName;
                            prm2 = cmd.Parameters.Add("@tracer_id", SqlDbType.Int);
                            prm2.Value = tracer_id;
                            insync = false;
                            while (insync == false)
                            {
                                SqlDataReader rdr = SQLLib.getReaderFromSP(cmd);
                                if (SQLLib.verifyReader(rdr))
                                {
                                    while (rdr.Read())
                                    {
                                        if (rdr.IsDBNull(0))
                                        {
                                            distlatencystr = "NULL";
                                        }
                                        else
                                        {
                                            distlatency = rdr.GetInt64(0);
                                            distlatencystr = distlatency.ToString().PadLeft(4);
                                        }
                                        subscriber = rdr.GetString(1);
                                        subscriberdb = rdr.GetString(2);
                                        if (rdr.IsDBNull(3))
                                        {
                                            sublatencystr = "NULL";
                                        }
                                        else
                                        {
                                            sublatency = rdr.GetInt64(3);
                                            sublatencystr = sublatency.ToString().PadLeft(4);
                                        }
                                        if (rdr.IsDBNull(4))
                                        {
                                            totlatencystr = "NULL";
                                        }
                                        else
                                        {
                                            totlatency = rdr.GetInt64(4);
                                            totlatencystr = totlatency.ToString().PadLeft(4);
                                            insync = true;
                                        }
                                        Console.WriteLine("Latency - {0} -> {1}.{2}: {3}|{4}|{5}", subinfo.PublisherDatabase, subscriber, subscriberdb, distlatencystr, sublatencystr, totlatencystr);
                                        if (!insync)
                                            Thread.Sleep(10000);
                                    }
                                }
                                SQLLib.disposeReader(rdr);
                            }
                        }
                    }
                }
            }
            else
            {
                if (subinfo.Next())
                {
                    do
                    // For Snapshot, verify that there are no pending commands; this means the most recent snapshot has been delivered.
                    {
                        insync = false;
                        while (insync == false)
                        {
                            Thread.Sleep(60000);
                            subinfo.GetPendingCmds();
                            if (subinfo.PendingCmds == 0)
                            {
                                Console.WriteLine("In synch    : {0} -> {1}.{2}", subinfo.PublisherDatabase, subinfo.SubscriberServer, subinfo.SubscriberDatabase);
                                insync = true;
                            }
                            else
                            {
                                Console.WriteLine("Pending cmds: {0} -> {1}.{2} : {3}", subinfo.PublisherDatabase, subinfo.SubscriberServer, subinfo.SubscriberDatabase, subinfo.PendingCmds.ToString());
                            }
                        }
                    } while (subinfo.Next());
                }
                else
                {
                    Console.WriteLine("No snapshot subscriptions found.");
                }
            }
            Console.WriteLine();
            return insync;
        }

        private static void Usage(string location)
		{
            if (location != string.Empty)
            {
                Process helpProc = new Process();
                helpProc.StartInfo.UseShellExecute = false;
                helpProc.StartInfo.RedirectStandardOutput = true;
                helpProc.StartInfo.FileName = "cmd.exe";
                helpProc.StartInfo.Arguments = string.Format("/c {0}", location.Replace(".exe", ".chm"));
                helpProc.Start();
            }
			Console.WriteLine("Usage:");
			Console.WriteLine("SQLAdmin /A action /S server /D database additional information");
            Console.WriteLine("/F folder /P property /U update /Q /V");
            Console.WriteLine();
			Console.WriteLine("/A: Action to be performed.  The following actions are supported:");
            Console.WriteLine(" DBBackup (backs up a database)");
            Console.WriteLine(" DBBCR (backs up and remotely restores a database or databases");
            Console.WriteLine("     Different destination DB name is supported, delimited by colon ':')");
            Console.WriteLine(" DBDrop (drops databases defined by /D, including replication teardown)");
            Console.WriteLine(" DBKill (kills spids connected to a particular database)");
            Console.WriteLine(" DBMaint (creates maintenance job for databases defined by /D)");
            Console.WriteLine(" DBRestore (restores a database)");
            Console.WriteLine(" DBSpace (reports space usage on DBs defined by /D)");
//            Console.WriteLine(" Install (configures O/S for SQLAdmin logging)");
            //Console.WriteLine(" JBCopy (copies job from one server to another)");
            Console.WriteLine(" JBCreate (creates job from comma-delimited list of files /F)");
            Console.WriteLine(" JBEnabled:1 (sets jobs enabled status, in this case to 'on')");
            Console.WriteLine(" JBHistory (lists history for a job or jobs)");
            Console.WriteLine(" JBList (lists jobs existing in SQL Server Agent)");
            Console.WriteLine(" JBQuery (shows basic job facts for SQL Server Agent jobs)");
            Console.WriteLine(" JBOwner:sa (changes ownership of a job, in this case to 'sa')");
            Console.WriteLine(" JBRun (starts a job from its configured start step)");
            Console.WriteLine(" JBUpdate (updates jobs using sp_update_job)");
            Console.WriteLine(" JBUpdate:1 (updates job step by step ID using sp_update_jobstep)");
            Console.WriteLine(" LSSetup (sets up a log shipping stream)");
            Console.WriteLine(" RPDrop (drops all replication FROM (not TO) server defined by /S");
            Console.WriteLine("     /D limits RPDrop to only the databases defined by it.)");
            Console.WriteLine(" RPDrop:OVERRIDE (all caps 'OVERRIDE' ignores replication warnings");
            Console.WriteLine("     /D is ignored in the case of OVERRIDE.)");
            Console.WriteLine(" RPQuery (returns status of replication subscriptions for which");
            Console.WriteLine("     server defined by /S is the distributor)");
            Console.WriteLine(" RPWait (waits for all subscriptions for this publisher to synch)");
            Console.WriteLine(" SPWait (waits for a spid to complete an operation, such as 'backup database')");
            Console.WriteLine(" STAdd:parameter (adds a startup parameter to SQL Server)");
            Console.WriteLine(" STQuery (lists all startup parameters for a SQL Server)");
            Console.WriteLine("/F: File or folder to use for such things as backups and restores");
            Console.WriteLine("/S: Server against which to act.");
			Console.WriteLine("/D: Database or databases (if any) against which to act.");
            Console.WriteLine("/C: Folder to which to copy file for DBMaint action.");
            Console.WriteLine("/P: Property to be used, in addition to name, to select jobs or databases.");
            Console.WriteLine("/Q: Quiet mode suppresses prompting prior to data-destructive action.");
            Console.WriteLine("/U: Update parameter and value (for JBUpdate action)");
            Console.WriteLine("/V: Output the version of SQLAdmin.");
            Console.WriteLine();
            Console.WriteLine("Non-switch parameters are 'Additional Information'");
            Console.WriteLine("For JB actions, 'Additional Information' denotes a job name");
            Console.WriteLine("JB scripting also supports variable substitution, defined by additional");
            Console.WriteLine("information items with equals signs '=' in them.");
            Console.WriteLine("The SQL Server '%' wildcard is supported for database and job names");
            Console.WriteLine("Two server or database names can be delimited by colon, ':'.");
            Console.WriteLine("The order of the switches does not matter.");
            Console.WriteLine("SQL Server's own case sensitivity for switches is an issue with STAdd.");
            Console.WriteLine("Except as noted above, SQLAdmin is NOT case-sensitive.");
            Console.WriteLine();
            Console.WriteLine("Examples:");
            Console.WriteLine();
            Console.WriteLine("To drop all replication publishing and distribution FROM server1:");
            Console.WriteLine("sqladmin /a rpdrop /s server1");
            Console.WriteLine("To drop database 'test1', including replication teardown:");
            Console.WriteLine("sqladmin /a dbdrop /s server1 /d test1");
            Console.WriteLine("To set the owner of all jobs on the current server to 'TEST\\sqlsrvc':");
            Console.WriteLine("sqladmin /a jbowner:test\\sqlsrvc %");
            Console.WriteLine("To view basic job facts for all jobs beginning with the letter 's':");
            Console.WriteLine("sqladmin /a jbquery s%");
            Console.WriteLine("To run job 'DBCC execution' on server1:");
            Console.WriteLine("sqladmin /a jbrun /s server1 DBCC execution");
            Console.WriteLine("To wait for job 'DBCC execution' on server1 to complete:");
            Console.WriteLine("sqladmin dbcc execution /s server1 /a jbwait");
            Console.WriteLine("To enable alerting on failure on job 'DBCC execution' on the current server:");
            Console.WriteLine("sqladmin /a jbupdate /u @notify_level_eventlog=2 DBCC execution");
            Console.WriteLine("To set retry attempts to 0 on step 2 of all replication distribution jobs:");
            Console.WriteLine("sqladmin /a jbupdate:2 /u @retry_attempts=0 % /p category='REPL-Distribution'");
            Console.WriteLine("To wait for a SPID executing 'restore database' on server1 to complete:");
            Console.WriteLine("sqladmin /a spwait /s server1 restore database");
            Console.WriteLine("NOTE: spwait doesn't tell you if the operation succeeded or failed!");
            Console.WriteLine("To add traceflag 3605 to SQL Server startup parameters on server1:");
            Console.WriteLine("sqladmin /a stadd:-T3605 /s server1");
            Console.WriteLine("To backup pubs database from Server1 and restore it with standby onto Server2:");
            Console.WriteLine("sqladmin /a dbbcr:standby=c:\\temp\\undo /s server1:server2 /d pubs /f c:\\temp\\");
            Console.WriteLine();
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\WSTAdmin\WstAdmin.cs ===
using System;
using System.Data;
using System.Diagnostics;
using System.IO;
using Microsoft.Webstore.WstClient;     
using Microsoft.Webstore.MetaData;

namespace WstAdmin
{
    class WstAdmin
    {
        // PROPERTIES
        internal static StreamWriter LogObj
        {
            get
            {
                if (wr != null)
                {
                    return wr;
                }
                else
                {
                    return null;
                }
            }
            set
            {
                wr = value;
            }
        }

        static StreamWriter wr = null;

        static int Main(string[] args)
        {
            bool blnSuccess = false;
            Console.WriteLine();
            if (args.Length == 0)
            {
                Usage();
                return 1;
            }
            ParsedArgs ar = new ParsedArgs(args);
            LogObj = ar.LogStream;
            if (ar.Action != "None")
            {
                blnSuccess = runAction(ar);
            }
            else
            {
                Console.WriteLine("{0}Operation Failed", Environment.NewLine);
                return 1;
            }
            if (LogObj != null)
            {
                LogObj.Flush();
                LogObj.Close();
                LogObj.Dispose();
            }
            if (blnSuccess == false)
            {
                return 1;
            }
            else
            {
                return 0;
            }
        }

        // METHODS
        private static bool exportManifest(ParsedArgs arg)
        {
            bool success = false;
            Console.WriteLine("Action: Export the current manifest for deployment '{0}'.{1}", arg.DeploymentName, Environment.NewLine);
            success = WstLib.exportManifest(arg.DeploymentName);
            return success;
        }

        private static bool listAnyDatabase(ParsedArgs arg)
        {
            bool success = false;
            Random random = new Random();
            int numOfPartitions;
            WstConnection con = WstLib.connectToWST(arg.DeploymentName);
            if ((con != null) && (con.State == ConnectionState.Open))
            {
                WebstoreSQLFssCollection fssc = con.SqlPartitions;
                numOfPartitions = fssc.Count;
                // get a random number between 0 and the number of logical partitions minus 1
                // logicalPartition = 
                WstCommand cmd = new WstCommand();
                cmd.Connection = con;
                cmd.PartitionType = WstPartitionType.Physical;
                cmd.Partition = random.Next(numOfPartitions);
                if (arg.FailoverMode == "pri")
                {
                    cmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
                }
                else
                {
                    cmd.WstFailoverMode = WstFailoverMode.SecondaryThenPrimary;
                }
                WstDataReader rdr = WstLib.getReaderFromWst(cmd, "SELECT @@SERVERNAME");
                if (WstLib.verifyReader(rdr))
                {
                    try
                    {
                        rdr.Read();
                        sendOut(string.Format("{0} {1}", rdr.GetString(0), cmd.Database.Name));
                        Console.WriteLine();
                        success = true;
                    }
                    catch (SystemException e)
                    {
                        Console.WriteLine("Error attempting to read or output database information:");
                        Console.WriteLine(e.Message);
                    }
                }
            }
            return success;
        }

        private static bool listDatabases(ParsedArgs arg)
        {
            bool success = false;
            string output = string.Empty;
            Console.WriteLine("Action: List databases for deployment '{0}'.{1}", arg.DeploymentName, Environment.NewLine);
            DataTableReader dr = WstLib.deploymentDatabases(arg.DeploymentName, arg.FailoverMode);
            while (dr.Read())
            {
                output = string.Format("{0}\t{1}\t{2}", dr.GetValue(0), dr.GetValue(1), dr.GetValue(2).ToString());
                sendOut(output);
                success = true;
            }
            return success;
        }

        private static bool listFilesInManifest(ParsedArgs arg)
        {
            bool success = false;
            Console.WriteLine("Action: List the source files in the current manifest for deployment '{0}'.{1}", arg.DeploymentName, Environment.NewLine);
            success = WstLib.listObjectsInManifest("file", arg.DeploymentName);
            return success;
        }

        private static bool listTablesInManifest(ParsedArgs arg)
        {
            bool success = false;
            string select_criteria = string.Empty;
            Console.WriteLine("Action: List the tables in the current manifest for deployment '{0}'.{1}", arg.DeploymentName, Environment.NewLine);
            if (arg.Modifier != string.Empty && arg.Modifier.Length > 2)
            {
                switch (arg.Modifier.Substring(0, 3).ToUpper())
                {
                    case "NON":
                        select_criteria = "AND t.isNonPartitioned = 1";
                        break;
                    case "PAR":
                        select_criteria = "AND t.isNonPartitioned = 0";
                        break;
                    default:
                        Console.WriteLine("Unrecognized modifier, ignored.");
                        break;
                }
            }
            success = WstLib.listObjectsInManifest("table", arg.DeploymentName, select_criteria);
            return success;
        }

        private static void outputSuccess(bool success, bool sendtolog)
        {
            if (sendtolog)
            {
                if (success == false)
                {
                    sendOut("Operation Failed", ConsoleColor.Red);
                }
                else
                {
                    sendOut("Operation Successful", ConsoleColor.Green);
                }
            }
            else
            {
                if (success == false)
                {
                    sendOut("Operation Failed", ConsoleColor.Red, false);
                }
                else
                {
                    sendOut("Operation Successful", ConsoleColor.Green, false);
                }
            }
        }

        /*******************************************************************
        Purpose: Log SQLAdmin action to command prompt and Windows Event Log
        Inputs : target     : server on which event is to be logged
        *******************************************************************/
        internal static void logEvent(string target, string sEvent)
        {
            // log an Information event in the application event log
            string sSource;
            sSource = "XappAdmin";
            sEvent += "\r\nXappAdmin user: " + Environment.UserDomainName;
            sEvent += "\\" + Environment.UserName;
            sEvent += "\r\nXappAdmin client: " + Environment.MachineName;
            try
            {
                EventLog writeLog = new EventLog();
                writeLog.Log = "Application";
                writeLog.MachineName = target;
                writeLog.Source = sSource;
                writeLog.WriteEntry(sEvent);
            }
            catch (SystemException e)
            {
                // no work here - the event logging will fail silently and I'll document this in the GAST docs
                Console.WriteLine(e.Message);
            }
        }

        private static bool markFSSNeedsRepair(ParsedArgs arg)
        {
            bool success = false;
            bool secondariesonline = false;
            int FSS = Convert.ToInt32(arg.FSSID);
            sendOut(string.Format("Action: Mark FSS {0} NeedsRepair for deployment {1}.", arg.Additional, arg.DeploymentName));
            DataTableReader dt = WstLib.deploymentDatabases(arg.DeploymentName, "sec"); // get all replica databases for this deployment
            while (dt.Read())
            {
                if (dt.GetInt32(2) == arg.FSSID)    // if the FSS ID matches that entered by the user
                {
                    // mark the secondary database NeedsRepair
                    success = WstLib.markNeedsRepair(dt.GetString(0), dt.GetString(1));
                    if (!success)
                        secondariesonline = true;
                }
            }
            if (secondariesonline)
            {
                // don't try to mark primary NeedsRepair if there are online Secondaries, as this will promote them with data-loss
                success = false; 
            }
            else
            {
                dt = WstLib.deploymentDatabases(arg.DeploymentName, "pri"); // get all replica databases for this deployment
                while (dt.Read())
                {
                    if (dt.GetInt32(2) == arg.FSSID)
                    {
                        // mark the primary database NeedsRepair
                        success = WstLib.markNeedsRepair(dt.GetString(0), dt.GetString(1));
                    }
                }
            }
            return success;
        }

        private static bool repairFSS(ParsedArgs arg)
        {
            bool success = false;
            int FSS = Convert.ToInt32(arg.FSSID);
            sendOut(string.Format("Action: Repair FSS {0}, deployment {1} starting with default primary.", arg.Additional, arg.DeploymentName));
            // since the whole FSS is NeedRepair, there will be no current primary; the default primary is what we want to repair first
            DataTableReader dt = WstLib.deploymentDatabases(arg.DeploymentName, "def"); 
            while (dt.Read())
            {
                if (dt.GetInt32(2) == arg.FSSID)    // if the FSS ID matches that entered by the user
                {
                    // repair the database with Force
                    if (!dt.GetBoolean(3))
                        success = WstLib.repair(dt.GetString(0), dt.GetString(1), true);
                    if (!dt.GetBoolean(3))
                        success = WstLib.markOnline(dt.GetString(0), dt.GetString(1));
                    if (!dt.GetBoolean(4))
                    {
                        success = WstLib.promote(dt.GetString(0), dt.GetString(1));
                        WstLib.waitForPollingPeriod();
                    }
                }
            }
            dt = WstLib.deploymentDatabases(arg.DeploymentName, "pri");
            if (dt.HasRows)    // don't go for secondaries unless primary exists.
            {
                dt = WstLib.deploymentDatabases(arg.DeploymentName, "sec");
                while (dt.Read())
                {
                    if (dt.GetInt32(2) == arg.FSSID)    // if the FSS ID matches that entered by the user
                    {
                        // repair the database without Force
                        if (!dt.GetBoolean(3))
                            success = WstLib.repair(dt.GetString(0), dt.GetString(1), false);
                    }
                }
                dt = WstLib.deploymentDatabases(arg.DeploymentName, "sec");
                while (dt.Read())
                {
                    if (dt.GetInt32(2) == arg.FSSID)    // if the FSS ID matches that entered by the user
                    {
                        // mark the database Online
                        if (!dt.GetBoolean(3))
                        {
                            success = WstLib.markOnline(dt.GetString(0), dt.GetString(1));
                            if (success)
                            {
                                WebstoreEnvironmentSettings env = WebstoreMetaData.Instance.DefaultConfig.EnvironmentSettings;
                                sendOut(string.Format("Mark Online successful. Please wait for polling period ({0} seconds).", env.PollingIntervalService));
                            }
                        }
                    }
                }
            }
            else
            {
                sendOut("No primary exists.  Aborting repair of secondaries.", ConsoleColor.Red);
            }
            return success;
        }

        private static bool runAction(ParsedArgs arg)
        {
            bool blnSuccess = false;
            switch (arg.Action)
            {
                case "DBAN":
                    blnSuccess = listAnyDatabase(arg);
                    outputSuccess(blnSuccess, false);
                    break;
                case "DBLI":
                    blnSuccess = listDatabases(arg);
                    outputSuccess(blnSuccess, false);
                    break;
                case "DEUP":
                    blnSuccess = upgradeDeployment(arg);
                    outputSuccess(blnSuccess, true);
                    break;
                case "FSNE":
                    blnSuccess = markFSSNeedsRepair(arg);
                    outputSuccess(blnSuccess, true);
                    break;
                case "FSRE":
                    blnSuccess = repairFSS(arg);
                    outputSuccess(blnSuccess, true);
                    break;
                case "MAEX":
                    blnSuccess = exportManifest(arg);
                    outputSuccess(blnSuccess, true);
                    break;
                case "MAFI":
                    blnSuccess = listFilesInManifest(arg);
                    outputSuccess(blnSuccess, false);
                    break;
                case "MATA":
                    blnSuccess = listTablesInManifest(arg);
                    outputSuccess(blnSuccess, false);
                    break;
                case "USAG":
                    blnSuccess = Usage();
                    break;
                default:
                    Console.WriteLine("Call to invalid action '{0}' in runAction", arg.Action);
                    break;
            }
            return blnSuccess;
        }

        internal static void sendOut(string msg)
        {
            sendOut(msg, ConsoleColor.Black); // we use "black" as a null value, so this just says "go with what's there"
        }

        internal static void sendOut(string msg, ConsoleColor color)
        {
            sendOut(msg, color, true);
        }

        internal static void sendOut(string msg, ConsoleColor color, bool includelog)
        {
            // this application will never use black as a foreground color, so the value represents a null
            if (color != ConsoleColor.Black)
                Console.ForegroundColor = color;
            Console.WriteLine(msg);
            if (color != ConsoleColor.Black)
                Console.ResetColor();
            if (includelog)
            {
                if (LogObj != null)
                    try
                    {
                        LogObj.WriteLine(msg);
                    }
                    catch (SystemException e)
                    {
                        sendOut("Error writing to the log file:");
                        sendOut(e.Message);
                    }
            }
        }

        private static bool upgradeDeployment(ParsedArgs arg)
        {
            bool success = false;
            Console.WriteLine("Action: Upgrade the current manifest for deployment '{0}' to new version found in manifest.xml of current folder.{1}", arg.DeploymentName, Environment.NewLine);
            if (arg.Modifier != string.Empty && arg.Modifier.Substring(0, 3) == "IGN")
            {
                success = WstLib.upgradeDeployment(arg.DeploymentName, true);
            }
            else
            {
                success = WstLib.upgradeDeployment(arg.DeploymentName);
            }
            return success;
        }

        static bool Usage()
        {
            Console.WriteLine("Usage:");
            Console.WriteLine("wstadmin /A action /D deployment");
            Console.WriteLine();
            Console.WriteLine("/A: Action to be performed.  The following actions are supported:");
            Console.WriteLine(" DBAny (return a database in the deployment at random)");
            Console.WriteLine(" DBList (list the databases in a deployment)");
            Console.WriteLine(" DEUpgrade (upgrade a deployment to the manifest found in the current folder)");
            Console.WriteLine(" FSNeedsRepair (mark all DBs in a fail-safe set NeedsRepair)");
            Console.WriteLine(" FSRepair (repair all DBs in a fail-safe set, starting with the primary");
            Console.WriteLine(" MAExport (export the current manifest for this deployment)");
            Console.WriteLine(" MAFilelist (lists the files in the manifest for this deployment)");
            Console.WriteLine(" MATablelist (lists the tables in the manifest for this deployment)");
            Console.WriteLine("/D: Deployment");
            Console.WriteLine("/F: Failover mode");
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\WSTAdmin\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\WSTAdmin\ParsedArgs.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Reflection;
using Microsoft.Webstore.Management;
using Microsoft.Webstore.Management.Wmo;
using Microsoft.Webstore.Common;        // need this for error handling

namespace WstAdmin
{
    internal class ParsedArgs
    {
        string action = "None";
        string additional = string.Empty;
        string deployment = string.Empty;
        string failovermode = string.Empty;
        string logname = string.Empty;
        string modifier = string.Empty;
        int fss = -1;
        StreamWriter sw = null;

        public int FSSID
        {
            get
            {
                return fss;
            }
        }

        public string Action
        {
            get
            {
                return action;
            }
        }
        public string Additional
        {
            get
            {
                return additional;
            }
        }
        public string DeploymentName
        {
            get
            {
                return deployment;
            }
        }
        public string FailoverMode
        {
            get
            {
                return failovermode;
            }
        }
        public System.IO.StreamWriter LogStream
        {
            get
            {
                return sw;
            }
        }
        public string Modifier
        {
            get
            {
                return modifier;
            }
        }
        protected string arg;
        public ParsedArgs(string[] args)
        {
            int i = 0;
            string o;
            for (i = 0; i < args.Length; i++)
            {
                o = args[i].ToUpper();
                switch (o)
                {
                    case ("/?"):
                        action = "USAG";
                        break;
                    case ("/A"):
                        if (!PromptForValue(args, i))
                        {
                            arg = args[i + 1];
                            int colon = arg.IndexOf(':');
                            if (colon > -1)
                            {
                                modifier = arg.Substring(colon + 1);
                            }
                            arg = arg.ToUpper();
                            if (arg.Length > 3)
                            {
                                action = arg.Substring(0, 4);
                            }
                            else
                            {
                                Console.WriteLine("Action must exceed three characters in length.");
                            }
                        }
                        i++;
                        break;
                    case ("/D"):
                        if (!PromptForValue(args, i))
                            deployment = args[i + 1];
                        i++;
                        break;
                    case ("/F"):
                        if (!PromptForValue(args, i))
                        {
                            failovermode = args[i + 1].Substring(0, 3).ToLower();
                        }
                        i++;
                        break;
                    case ("/L"):
                        if (!PromptForValue(args, i))
                        {
                            logname = args[i + 1];
                            string backupname = logname + ".bak";
                            if (System.IO.File.Exists(logname))
                            {
                                if (System.IO.File.Exists(backupname))
                                {
                                    System.IO.File.Delete(backupname);
                                }
                                System.IO.File.Move(logname, backupname);
                            }
                            try
                            {
                                sw = System.IO.File.CreateText(logname);
                            }
                            catch (SystemException e)
                            {
                                Console.WriteLine("Error attempting to create log file {0}", logname);
                                Console.WriteLine(e.Message);
                            }
                        }
                        i++;
                        break;
                    case ("/V"):
                        Assembly asm = Assembly.GetExecutingAssembly();
                        string output = asm.FullName;
                        string[] outputs = output.Split(',');
                        Console.WriteLine("{0} {1}{2}", outputs[0], outputs[1], Environment.NewLine);
                        break;
                    default:
                        // if it's not FROM a switch, add it to Additional
                        if (additional == string.Empty)
                        {
                            additional = args[i];
                        }
                        else
                        {
                            additional += " " + args[i];
                        }
                        break;
                }
            }
            switch (action)
            {
                case ("DBAN"):
                    if (deployment == string.Empty)
                    {
                        Console.WriteLine("Must include deployment (/D) to use 'select any database' action.");
                        action = "None";
                    }
                    break;
                case ("DBLI"):
                    if (deployment == string.Empty)
                    {
                        Console.WriteLine("Must include deployment (/D) to use database list action.");
                        action = "None";
                    }
                    break;
                case ("DEUP"):
                    if (deployment == string.Empty)
                    {
                        Console.WriteLine("Must include deployment (/D) to use deployment upgrade action.");
                        action = "None";
                    }
                    break;
                case ("FSNE"):
                    if (deployment == string.Empty)
                    {
                        Console.WriteLine("Must include deployment (/D) to use FSS NeedsRepair action.");
                        action = "None";
                    }
                    if (additional == string.Empty)
                    {
                        Console.WriteLine("Must include FSS number (Additional Information) to use FSS NeedsRepair action.");
                        action = "None";
                    }
                    else
                    {
                        try
                        {
                            fss = Convert.ToInt32(additional);
                        }
                        catch (System.FormatException)
                        {
                            Console.WriteLine("FSS ID must be a valid integer value for FSS actions.");
                            action = "None";
                        }
                    }
                    break;
                case ("FSRE"):
                    if (deployment == string.Empty)
                    {
                        Console.WriteLine("Must include deployment (/D) to use FSS Repair action.");
                        action = "None";
                    }
                    if (additional == string.Empty)
                    {
                        Console.WriteLine("Must include FSS number (Additional Information) to use FSS NeedsRepair action.");
                        action = "None";
                    }
                    else
                    {
                        try
                        {
                            fss = Convert.ToInt32(additional);
                        }
                        catch (System.FormatException)
                        {
                            Console.WriteLine("FSS ID must be a valid integer value for FSS actions.");
                            action = "None";
                        }
                    }
                    break;
                case ("MAEX"):
                    if (deployment == string.Empty)
                    {
                        Console.WriteLine("Must include deployment (/D) to use manifest export action.");
                        action = "None";
                    }
                    break;
                case ("MAFI"):
                    if (deployment == string.Empty)
                    {
                        Console.WriteLine("Must include deployment (/D) to use manifest filelist action.");
                        action = "None";
                    }
                    break;
                case ("MATA"):
                    if (deployment == string.Empty)
                    {
                        Console.WriteLine("Must include deployment (/D) to use manifest tablelist action.");
                        action = "None";
                    }
                    break;
                default:
                    break;
            }

        }
        protected bool PromptForValue(string[] PValues, int intIndex)
        {
            if ((intIndex + 2) > PValues.Length)
            {
                Console.WriteLine(String.Concat("No value for switch ", PValues[intIndex].ToUpper()));
                return true;
            }
            else
            {
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\WSTAdmin\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wstadmin_none_12.4.56.0_none_84f63e0e20860180
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wstadmin_no-public-key_12.4.56.0_x-ww_c789dd3a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wstadmin
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wstadmin_no-public-key_12.4.56.0_x-ww_c789dd3a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wstadmin_no-public-key_12.4.56.0_x-ww_c789dd3a.manifest
XP_MANIFEST_PATH=manifests\msil_wstadmin_no-public-key_12.4.56.0_x-ww_c789dd3a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wstadmin_no-public-key_12.4.56.0_x-ww_c789dd3a.cat
XP_CATALOG_PATH=manifests\msil_wstadmin_no-public-key_12.4.56.0_x-ww_c789dd3a.cat
XP_PAYLOAD_PATH=msil_wstadmin_no-public-key_12.4.56.0_x-ww_c789dd3a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wstadmin,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\WSTAdmin\WstLib.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Text;
using System.Xml;
using System.Threading;
using Microsoft.Webstore.WstClient;
using Microsoft.Webstore.MetaData;
using Microsoft.Webstore.Management;
using Microsoft.Webstore.Management.Wmo;
using Microsoft.Webstore.Common;        // need this for error handling

namespace WstAdmin
{
    class WstLib
    {
        internal static WstConnection connectToWST(string strDeployment)
        {
            WstConnection con = null;
            // declare and open a connection to the deployment
            try
            {
                con = new WstConnection(strDeployment);
                con.Open();
            }
            catch (WstException ex)
            {
                Console.WriteLine("Error attempting to connect to Webstore deployment " + strDeployment);
                Console.WriteLine(ex.Message);
            }
            return con;
        }

        internal static DataTableReader deploymentDatabases(string deployment)
        {
            // Create a datatable object to store the database information
            DataTableReader table = deploymentDatabases(deployment, null);
            return table;
        }

        internal static DataTableReader deploymentDatabases(string deployment, string failovermode)
        {
            DataTable table = new DataTable("wstdbs");
            Guid depguid = WstLib.deploymentGuid(deployment);
            if (depguid.ToString() == "00000000-0000-0000-0000-000000000000")
            {
                WstAdmin.sendOut(string.Format("No metadata available for deployment '{0}'.", deployment));
            }
            else
            {
                WebstoreDeployment dep = WebstoreMetaData.Instance.DefaultConfig.Deployments[depguid];
                // Create a datatable object to store the database information
                DataColumn column;
                // Create new DataColumn, set properties for add to DataTable.    
                column = new DataColumn();
                column.DataType = System.Type.GetType("System.String");
                column.ColumnName = "Server";
                column.ReadOnly = true;
                column.Unique = false;
                // Add the Server Column to the DataColumnCollection.
                table.Columns.Add(column);
                column = new DataColumn();
                column.DataType = System.Type.GetType("System.String");
                column.ColumnName = "Database";
                column.ReadOnly = true;
                column.Unique = false;
                // Add the Database Column to the DataColumnCollection.
                table.Columns.Add(column);
                column = new DataColumn();
                column.DataType = System.Type.GetType("System.Int32");
                column.ColumnName = "FSS";
                column.ReadOnly = true;
                column.Unique = false;
                // Add the FSS Column to the DataColumnCollection.
                table.Columns.Add(column);
                column = new DataColumn();
                column.DataType = System.Type.GetType("System.Boolean");
                column.ColumnName = "IsOnline";
                column.ReadOnly = true;
                column.Unique = false;
                // Add the IsOnline Column to the DataColumnCollection.
                table.Columns.Add(column);
                column = new DataColumn();
                column.DataType = System.Type.GetType("System.Boolean");
                column.ColumnName = "IsPrimary";
                column.ReadOnly = true;
                column.Unique = false;
                // Add the IsPrimary Column to the DataColumnCollection.
                table.Columns.Add(column);
                // Populate the DataTable with the data from Webstore
                foreach (WebstoreSQLFss fss in dep.SQLFailSafeSets)
                {
                    foreach (WebstoreDatabase db in fss.Databases)
                    {
                        switch (failovermode)
                        {
                            case "def":
                                if (db.Name == fss.DefaultPrimaryDB.Name)
                                {
                                    table.Rows.Add(databaseRow(table, db));
                                }
                                break;
                            case "pri":
                                if (db.IsPrimary)
                                {
                                    table.Rows.Add(databaseRow(table, db));
                                }
                                break;
                            case "sec":
                                if (!db.IsPrimary)
                                {
                                    table.Rows.Add(databaseRow(table, db));
                                }
                                break;
                            default:
                                table.Rows.Add(databaseRow(table, db));
                                break;
                        }
                    }
                }
            }
            DataTableReader reader = table.CreateDataReader();
            return reader;
        }

        internal static DataRow databaseRow(DataTable tbl, WebstoreDatabase db)
        {
            DataRow row = tbl.NewRow();
            row["Server"] = db.ServerName;
            row["Database"] = db.Name;
            row["FSS"] = db.ResourceFailSafeSet.FssId;
            row["IsOnline"] = db.IsOnline;
            row["IsPrimary"] = db.IsPrimary;
            return row;
        }

        internal static Guid deploymentGuid(string deployment)
        {
            Guid retval = Guid.Empty;
            WebstoreConfig cfg = WebstoreMetaData.Instance.DefaultConfig;
            foreach (WebstoreDeployment dep in cfg.Deployments)
            {
                if (dep.Name.ToUpper() == deployment.ToUpper())
                {
                    retval = dep.Uid;
                }
            }
            return retval;
        }

        internal static void disposeReader(WstDataReader rdr)
        {
            if (rdr != null)
            {
                if (!rdr.IsClosed)
                {
                    rdr.Close();
                }
            }
        }

        internal static bool exportManifest(string deployment)
        {
            bool success = false;
            // try to get the manifest from the metadata collection using the info from the deployment metadata
            Guid depguid = WstLib.deploymentGuid(deployment);
            if (depguid.ToString() == "00000000-0000-0000-0000-000000000000")
            {
                WstAdmin.sendOut(string.Format("Deployment '{0}' not found in Webstore.", deployment));
                WstAdmin.sendOut("Cancelling.");
            }
            else
            {
                WebstoreDeployment metdep = WebstoreMetaData.Instance.DefaultConfig.Deployments[depguid];
                WebstoreManifest metman = WstLib.manifestFromGuid(metdep.ManifestUid); // this is the problem line
                // execute WMO against the deployment to export the manifest
                WmoCommandManifest man = new WmoCommandManifest();
                man.WmoStatusEvent += new Microsoft.Webstore.Common.WmoStatusEventHandler(StatusChanged);
                man.ManifestName = metman.Name;
                man.ExportManifestVersion = metman.Version;
                man.OutXmlPath = "manifest.xml";
                man.DoExportSource = true;
                man.OverWrite = true;
                WstAdmin.sendOut(string.Format("Exporting manifest '{0}' version '{1}'.", metman.Name, metman.Version));
                try
                {
                    man.Export();
                    success = true;
                }
                catch (WmoException e)
                {
                    WstAdmin.sendOut(string.Format("Error attempting to export manifest for deployment '{0}'.", deployment));
                    WstAdmin.sendOut(e.Message);
                }
            }
            return success;
        }

        private static string getQuery(string queryname, string manname, string manversion)
        {
            string query = getQuery(queryname, manname, manversion, string.Empty);
            return query;
        }

        private static string getQuery(string queryname, string manname, string manversion, string extrapredicateterms)
        {
            string query = string.Empty;
            switch (queryname.ToUpper())
            {
                case "FILE":
                    query = string.Format("SELECT sourcefilename{0}", Environment.NewLine);
                    query = string.Format("{0}FROM ({1}", query, Environment.NewLine);
                    query = string.Format("{0}SELECT sourcefilename, setupstep, installorder{1}", query, Environment.NewLine);
                    query = string.Format("{0}FROM objectsource o{1}", query, Environment.NewLine);
                    query = string.Format("{0}INNER JOIN manifest m{1}", query, Environment.NewLine);
                    query = string.Format("{0}ON o.manifestuid = m.manifestuid{1}", query, Environment.NewLine);
                    query = string.Format("{0}INNER JOIN sqlobject s{1}", query, Environment.NewLine);
                    query = string.Format("{0}ON o.objectsourceuid = s.objectsourceuid{1}", query, Environment.NewLine);
                    query = string.Format("{0}WHERE m.manifestname = '{2}'{1}", query, Environment.NewLine, manname);
                    query = string.Format("{0}AND m.manifestversion = '{2}'{1}", query, Environment.NewLine, manversion);
                    query = string.Format("{0}AND s.isgenerated = 0{1}", query, Environment.NewLine);
                    query = string.Format("{0}UNION{1}", query, Environment.NewLine);
                    query = string.Format("{0}SELECT sourcefilename, setupstep, installorder{1}", query, Environment.NewLine);
                    query = string.Format("{0}FROM objectsource o{1}", query, Environment.NewLine);
                    query = string.Format("{0}INNER JOIN manifest m{1}", query, Environment.NewLine);
                    query = string.Format("{0}ON o.manifestuid = m.manifestuid{1}", query, Environment.NewLine);
                    query = string.Format("{0}INNER JOIN sqltable s{1}", query, Environment.NewLine);
                    query = string.Format("{0}ON o.objectsourceuid = s.objectsourceuid{1}", query, Environment.NewLine);
                    query = string.Format("{0}WHERE m.manifestname = '{2}'{1}", query, Environment.NewLine, manname);
                    query = string.Format("{0}AND m.manifestversion = '{2}'{1}", query, Environment.NewLine, manversion);
                    query = string.Format("{0}) AS files{1}", query, Environment.NewLine);
                    query = string.Format("{0}ORDER BY setupstep, installorder{1}", query, Environment.NewLine);
                    break;
                case "TABLE":
                    query = string.Format("SELECT t.name{0}", Environment.NewLine);
                    query = string.Format("{0}FROM objectsource o{1}", query, Environment.NewLine);
                    query = string.Format("{0}INNER JOIN manifest m{1}", query, Environment.NewLine);
                    query = string.Format("{0}ON o.manifestuid = m.manifestuid{1}", query, Environment.NewLine);
                    query = string.Format("{0}INNER JOIN sqltable t{1}", query, Environment.NewLine);
                    query = string.Format("{0}ON o.objectsourceuid = t.objectsourceuid{1}", query, Environment.NewLine);
                    query = string.Format("{0}WHERE m.manifestname = '{2}'{1}", query, Environment.NewLine, manname);
                    query = string.Format("{0}AND m.manifestversion = '{2}'{1}", query, Environment.NewLine, manversion);
                    if (extrapredicateterms != string.Empty)
                        query = query = string.Format("{0}{1}{2}", query, extrapredicateterms, Environment.NewLine);
                    query = string.Format("{0}ORDER BY setupstep, installorder{1}", query, Environment.NewLine);
                    break;
                default:
                    Console.WriteLine("Unsupported query type '{0}' passed to getQuery.", queryname);
                    break;
            }
            return query;
        }

        internal static WstDataReader getReaderFromWst(WstCommand wstc, string cmdText)
        {
            WstDataReader getRdr = null;
            if (cmdText == string.Empty)
            {
                Console.WriteLine("Empty command sent to getReaderFromWst. Cancelling query.");
            }
            else
            {
                wstc.CommandText = cmdText;
                wstc.CommandType = CommandType.Text;
                wstc.WstFailoverMode = WstFailoverMode.SecondaryOnly;
                try
                {
                    getRdr = wstc.ExecuteReader();
                }
                catch (WstException e)
                {
                    Console.WriteLine("Error executing query '{0}' against connection string {1}, partition {2}:", cmdText, wstc.Connection.ConnectionString, wstc.Partition);
                    Console.WriteLine(e.Message);
                }
            }
            return getRdr;
        }

        static char[] hexDigits = {
            '0', '1', '2', '3', '4', '5', '6', '7', 
            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

        internal static WebstoreManifest importManifest(bool ignoreExtraFiles)
        {
            string manifestname = string.Empty;
            string manifestversion = string.Empty;
            WmoCommandManifest impman = new WmoCommandManifest();
            WebstoreManifest webman = null;
            XmlReader read = null;
            string filename = string.Empty;
            bool filemissing = false;
            ArrayList filelist = new ArrayList();
            impman.WmoStatusEvent += new Microsoft.Webstore.Common.WmoStatusEventHandler(StatusChanged);
            impman.InXmlPath = "manifest.xml";
            // determine the manifest version based on the XML
            XmlReaderSettings settings = new XmlReaderSettings();
            settings.ConformanceLevel = ConformanceLevel.Fragment;
            settings.IgnoreWhitespace = true;
            settings.IgnoreComments = true;
            try
            {
                read = XmlReader.Create("manifest.xml", settings);
            }
            catch (SystemException e)
            {
                Console.WriteLine("Error attempting to read file 'manifest.xml':");
                Console.WriteLine(e.Message);
            }
            if (read != null)
            {
                read.Read();
                read.ReadToDescendant("Manifest");
                read.MoveToFirstAttribute();    // its first and only attribute is the name
                manifestname = read.Value;
                read.MoveToElement();
                read.ReadToDescendant("Version");
                manifestversion = read.ReadString().Trim();
                // get the list of source files from the XML
                while (read.Read())
                {
                    if (read.IsStartElement())
                    {
                        if (!read.IsEmptyElement)
                        {
                            if (read.Name == "SourceFile")
                            {
                                filename = read.ReadString().Trim().ToUpper();
                                filelist.Add(filename);
                            }
                        }
                    }
                }
                read.Close();
                // for each file in the manifest folder, ensure the file name exists in the manifest
                DirectoryInfo di = new DirectoryInfo(Environment.CurrentDirectory);
                // Create an array representing the files in the current directory.
                FileInfo[] fi = di.GetFiles();
                foreach (FileInfo fiTemp in fi)
                {
                    if (fiTemp.Name.Substring((fiTemp.Name.Length - 4), 4).ToLower() == ".sql")
                    {
                        if (filelist.IndexOf(fiTemp.Name.ToUpper()) == -1)
                        {
                            if (ignoreExtraFiles)
                            {
                                WstAdmin.sendOut(string.Format("File {0} does not exist in manifest XML.", fiTemp.Name), ConsoleColor.Yellow);
                            }
                            else
                            {
                                WstAdmin.sendOut(string.Format("File {0} does not exist in manifest XML.", fiTemp.Name), ConsoleColor.Red);
                                filemissing = true;
                            }
                        }
                    }
                }
                if (filemissing)
                {
                    WstAdmin.sendOut("One or more files in the folder do not exist in the manifest XML.  Aborting.", ConsoleColor.Red);
                    return webman;  // returns null, since webman hasn't been set to an object instance yet
                }
                webman = manifestFromNameAndVersion(manifestname, manifestversion);
                // check if manifest already exists
                if (webman != null)
                {
                    Console.WriteLine("Manifest '{0}', version '{1}' already exists.  Skipping import.", manifestname, manifestversion);
                }
                else
                {
                    // import the manifest
                    Console.WriteLine("Importing manifest '{0}', version '{1}'.", manifestname, manifestversion);
                    try
                    {
                        impman.Import();
                        WstAdmin.sendOut("Import done.");
                        webman = manifestFromNameAndVersion(manifestname, manifestversion);
                    }
                    catch (WmoException e)
                    {
                        WstAdmin.sendOut("Error attempting to import manifest.");
                        WstAdmin.sendOut(e.Message);
                        WstAdmin.sendOut("Import failed!");
                    }
                }
            }
            return webman;
        }

        internal static bool listObjectsInManifest(string objecttype, string deploymentname)
        {
            bool success = listObjectsInManifest(objecttype, deploymentname, string.Empty);
            return success;
        }

        internal static bool listObjectsInManifest(string objecttype, string deploymentname, string extrapredicate)
        {
            bool success = false;
            string manname = string.Empty;
            string manversion = string.Empty;
            string query = string.Empty;
            // we need the manifest name and version
            Guid depguid = deploymentGuid(deploymentname);
            if (depguid.ToString() == "00000000-0000-0000-0000-000000000000")
            {
                WstAdmin.sendOut(string.Format("Deployment '{0}' not found in Webstore.", deploymentname));
                WstAdmin.sendOut("Cancelling.");
            }
            else
            {
                WebstoreDeployment metdep = WebstoreMetaData.Instance.DefaultConfig.Deployments[depguid];
                WebstoreManifest metman = WstLib.manifestFromGuid(metdep.ManifestUid);
                manname = metman.Name;
                manversion = metman.Version;
            }
            // connect to Webstore on the WstConfig deployment
            WstConnection con = connectToWST("WstConfig");
            WstCommand cmd = new WstCommand();
            cmd.Connection = con;
            query = getQuery(objecttype, manname, manversion, extrapredicate);
            WstDataReader rdr = getReaderFromWst(cmd, query);
            if (verifyReader(rdr))
                success = true;
            outputResults(rdr, false);
            disposeReader(rdr);
            return success;
        }

        internal static WebstoreManifest manifestFromGuid(Guid manifest_guid)
        {
            WebstoreManifest man;
            WebstoreManifestCollection mancol = WebstoreMetaData.Instance.DefaultConfig.GetManifestCollection(true);
            if (!mancol.TryGetValue(manifest_guid, out man))
            {
                WstAdmin.sendOut(string.Format("Failed to get manifest with Guid '{0}'.", manifest_guid.ToString()));
            }
            return man;
        }

        internal static WebstoreManifest manifestFromNameAndVersion(string manifestname, string manifestversion)
        {
            WebstoreManifest man = null;
            WebstoreManifestCollection mancol = WebstoreMetaData.Instance.DefaultConfig.GetManifestCollection(true);
            foreach (WebstoreManifest tmp in mancol)
            {
                if (tmp.Name == manifestname && tmp.Version == manifestversion)
                {
                    man = tmp;
                    break;
                }
            }
            return man;
        }

        internal static bool markNeedsRepair(string servername, string databasename)
        {
            bool success = false;
            WstAdmin.sendOut(string.Format("\r\nMarking db {0} on server {1} NeedsRepair in Webstore.", databasename, servername));
            WmoCommandDatabase db = new WmoCommandDatabase();
            db.WmoStatusEvent += new Microsoft.Webstore.Common.WmoStatusEventHandler(StatusChanged);
            db.ServerName = servername;
            db.DatabaseName = databasename;
            try
            {
                db.NeedsRepair();
                success = true;
            }
            catch (WmoException e)
            {
                WstAdmin.sendOut("Error attempting to mark database NeedsRepair.", ConsoleColor.Red);
                WstAdmin.sendOut(e.Message, ConsoleColor.Red);
            }
            return success;
        }

        internal static bool markOnline(string servername, string databasename)
        {
            bool success = false;
            WstAdmin.sendOut(string.Format("\r\nMarking db {0} on server {1} Online in Webstore.", databasename, servername));
            WmoCommandDatabase db = new WmoCommandDatabase();
            db.WmoStatusEvent += new Microsoft.Webstore.Common.WmoStatusEventHandler(StatusChanged);
            db.ServerName = servername;
            db.DatabaseName = databasename;
            try
            {
                db.Online();
                success = true;
            }
            catch (WmoException e)
            {
                WstAdmin.sendOut("Error attempting to mark database Online.", ConsoleColor.Red);
                WstAdmin.sendOut(e.Message, ConsoleColor.Red);
            }
            return success;

        }

        internal static bool outputResults(WstDataReader rdr)
        {
            return outputResults(rdr, true);
        }

        internal static bool outputResults(WstDataReader rdr, bool includeHeadings)
        {
            bool success = false;
            string outtxt = string.Empty;
            if (verifyReader(rdr))
            {
                try
                {
                    // return data
                    if (includeHeadings)
                    {
                        outtxt = rdr.GetName(0).ToString();
                        for (int i = 1; i < rdr.FieldCount; i++)
                        {
                            outtxt = String.Format("{0}\t{1}", outtxt, rdr.GetName(i).ToString());
                        }
                        WstAdmin.sendOut(outtxt);
                    }
                    while (rdr.Read())
                    {
                        outtxt = string.Empty;
                        for (int j = 0; j < rdr.FieldCount; j++)
                        {
                            if (outtxt == string.Empty)
                            {
                                if (rdr.GetValue(j).ToString() == "System.Byte[]")
                                {
                                    byte[] binaryData = (byte[])rdr.GetValue(j);
                                    outtxt = ToHexString(binaryData);
                                }
                                else
                                {
                                    outtxt = rdr.GetValue(j).ToString();
                                }
                            }
                            else
                            {
                                if (rdr.GetValue(j).ToString() == "System.Byte[]")
                                {
                                    byte[] binaryData = (byte[])rdr.GetValue(j);
                                    outtxt = string.Format("{0}\t{1}", outtxt, ToHexString(binaryData));
                                }
                                else
                                {
                                    outtxt = String.Format("{0}\t{1}", outtxt, rdr.GetValue(j).ToString());
                                }
                            }
                        }
                        WstAdmin.sendOut(outtxt);
                        success = true;
                    }
                }
                catch (SystemException e)
                {
                    Console.WriteLine("Error returning results");
                    Console.WriteLine(e.Message);
                }
            }
            return success;
        }

        internal static bool promote(string servername, string databasename)
        {
            bool success = false;
            WstAdmin.sendOut(string.Format("\r\nPromoting db {0} on server {1}.", databasename, servername));
            WmoCommandDatabase db = new WmoCommandDatabase();
            db.WmoStatusEvent += new Microsoft.Webstore.Common.WmoStatusEventHandler(StatusChanged);
            db.ServerName = servername;
            db.DatabaseName = databasename;
            try
            {
                db.Promote();
                success = true;
            }
            catch (WmoException e)
            {
                WstAdmin.sendOut("Error attempting to Promote database.", ConsoleColor.Red);
                WstAdmin.sendOut(e.Message, ConsoleColor.Red);
            }
            return success;
        }

        internal static bool repair(string servername, string databasename)
        {
            bool success = repair(servername, databasename, false);
            return success;
        }

        internal static bool repair(string servername, string databasename, bool force)
        {
            bool success = false;
            WstAdmin.sendOut(string.Format("\r\nRepairing db {0} on server {1}.", databasename, servername));
            WmoCommandDatabase db = new WmoCommandDatabase();
            db.WmoStatusEvent += new Microsoft.Webstore.Common.WmoStatusEventHandler(StatusChanged);
            db.ServerName = servername;
            db.DatabaseName = databasename;
            if (force)
                db.IsForceRepair = true;
            try
            {
                db.Repair();
                success = true;
            }
            catch (WmoException e)
            {
                WstAdmin.sendOut("Error attempting to Repair database.", ConsoleColor.Red);
                WstAdmin.sendOut(e.Message, ConsoleColor.Red);
            }
            return success;
        }

        internal static string ToHexString(byte[] bytes)
        {
            char[] chars = new char[bytes.Length * 2];
            for (int i = 0; i < bytes.Length; i++)
            {
                int b = bytes[i];
                chars[i * 2] = hexDigits[b >> 4];
                chars[i * 2 + 1] = hexDigits[b & 0xF];
            }
            string charstr = new string(chars);
            charstr = string.Format("0x{0}", charstr);
            return charstr;
        }

        internal static void StatusChanged(object sender, WmoStatusEventArgs eventArgs)
        {
            switch (eventArgs.EventType)
            {
                /*
                case (WmoStatusEventType.Information):
                    WstAdmin.sendOut(eventArgs.ToString(), ConsoleColor.Gray);
                    break;
                */
                case (WmoStatusEventType.InProgress):
                    WstAdmin.sendOut(eventArgs.ToString(), ConsoleColor.Gray);
                    break;
                case (WmoStatusEventType.Success):
                    WstAdmin.sendOut(eventArgs.ToString(), ConsoleColor.Green);
                    break;
                case (WmoStatusEventType.Warning):
                    WstAdmin.sendOut(eventArgs.ToString(), ConsoleColor.Yellow);
                    break;
                default:
                    break;
            }
        }

        internal static bool upgradeDeployment(string deployment)
        {
            bool success = upgradeDeployment(deployment, false);
            return success;
        }

        internal static bool upgradeDeployment(string deployment, bool ignoreExtraFiles)
        {
            bool success = false;
            bool upgradeneeded = false;
            // get the manifest associated with the deployment
            Guid depguid = WstLib.deploymentGuid(deployment);
            WebstoreDeployment metdep = WebstoreMetaData.Instance.DefaultConfig.Deployments[depguid];
            WebstoreManifest currentmanifest = WstLib.manifestFromGuid(metdep.ManifestUid);
            WmoCommandDeployment dep = new WmoCommandDeployment();
            dep.WmoStatusEvent += new Microsoft.Webstore.Common.WmoStatusEventHandler(StatusChanged);
            // import the new manifest, unless it's already present in the config
            WebstoreManifest newmanifest = importManifest(ignoreExtraFiles);
            if (newmanifest != null)
            {
                WebstoreManifest oldmanifest = WstLib.manifestFromGuid(metdep.ManifestUid);
                dep.DeploymentName = deployment;
                if (oldmanifest.Name == newmanifest.Name && oldmanifest.Version == newmanifest.Version)
                {
                    WstAdmin.sendOut(string.Format("Manifest.xml matches manifest version associated with deployment '{0}'.", metdep.Name));
                    WstAdmin.sendOut("Not updating version.");
                }
                else
                {
                    if (newmanifest != null)
                    {
                        // set the manifest UID for this deployment to the one we have just imported.
                        dep.NewManifestVersion = newmanifest.Version;
                        WstAdmin.sendOut(string.Format("Associating new manifest version {0} with deployment '{1}'.", newmanifest.Version, metdep.Name));
                        try
                        {
                            dep.UpdateVersion();
                            upgradeneeded = true;
                            waitForPollingPeriod(); // wait for versions to update
                        }
                        catch (WmoException e)
                        {
                            Console.WriteLine("Error attempting to associate manifest with deployment:");
                            Console.WriteLine(e.Message);
                        }

                    }
                }
                // if we don't already KNOW that an upgrade is needed, find out IF an upgrade is needed
                upgradeneeded = UpgradeNeeded(metdep);
                // if at least one FSS has status "Upgrading or downgrading" 
                if (upgradeneeded)
                {
                    // run the upgrade for the deployment
                    WstAdmin.sendOut(string.Format("Upgrading deployment '{0}':", metdep.Name));
                    try
                    {
                        dep.Upgrade();
                        // the only way to succeed for an upgrade action is for the upgrade to be done without error
                        success = true;
                    }
                    catch (WmoException e)
                    {
                        WstAdmin.sendOut(string.Format("Error attempting to upgrade deployment '{0}'.", metdep.Name), ConsoleColor.Red);
                        WstAdmin.sendOut(e.Message, ConsoleColor.Red);
                        WstAdmin.sendOut("Upgrading with force to unblock rollback.", ConsoleColor.Yellow);
                        dep.IsForce = true;
                        dep.Upgrade();
                        // reset to previous version
                        WstAdmin.sendOut(string.Format("Setting back to version {0} to roll back.", oldmanifest.Version), ConsoleColor.Yellow);
                        dep.NewManifestVersion = oldmanifest.Version;
                        dep.UpdateVersion();
                        WstAdmin.sendOut("Upgrading with force to complete roll back.", ConsoleColor.Yellow);
                        dep.Upgrade();
                    }
                }
                else
                {
                    WstAdmin.sendOut("No fail safe sets are in need of upgrade.");
                }
            }
            return success;
        }

        internal static bool UpgradeNeeded(WebstoreDeployment dep)
        {
            bool upgradeneeded = false;
            foreach (WebstoreSQLFss fss in dep.SQLFailSafeSets)
            {
                if (fss.ManifestUid != dep.ManifestUid)
                    upgradeneeded = true;
                if (fss.Status.ToString() == "UpOrDowngrading")
                    upgradeneeded = true;
            }
            return upgradeneeded;
        }

        internal static bool verifyReader(WstDataReader rdr)
        {
            bool isready = verifyReader(rdr, true);
            return isready;
        }

        internal static bool verifyReader(WstDataReader rdr, bool outputstatus)
        {
            bool isready = false;
            if (rdr == null)
            {
                if (outputstatus)
                    Console.WriteLine("WstDataReader is null.");
            }
            else
            {
                if (rdr.IsClosed)
                {
                    if (outputstatus)
                        Console.WriteLine("WstDataReader is closed.");
                }
                else
                {
                    if (rdr.HasRows)
                    {
                        isready = true;
                    }
                    else
                    {
                        if (outputstatus)
                            Console.WriteLine("Query returned no rows.");
                    }
                }
            }
            return isready;
        }

        internal static void waitForPollingPeriod()
        {
            // wait for polling period
            WebstoreEnvironmentSettings env = WebstoreMetaData.Instance.DefaultConfig.EnvironmentSettings;
            WstAdmin.sendOut(string.Format("Waiting for polling period ({0} seconds).", env.PollingIntervalService));
            int sleepinterval = env.PollingIntervalService * 1000;
            Thread.Sleep(sleepinterval);
        }

        internal delegate void WmoStatusEventHandler(object sender, WmoStatusEventArgs arg);
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xAdmin\WSTAdmin\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wstadmin_none_12.4.56.0_none_84f63e0e20860180
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wstadmin_no-public-key_12.4.56.0_x-ww_c789dd3a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wstadmin
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wstadmin_no-public-key_12.4.56.0_x-ww_c789dd3a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wstadmin_no-public-key_12.4.56.0_x-ww_c789dd3a.manifest
XP_MANIFEST_PATH=manifests\msil_wstadmin_no-public-key_12.4.56.0_x-ww_c789dd3a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wstadmin_no-public-key_12.4.56.0_x-ww_c789dd3a.cat
XP_CATALOG_PATH=manifests\msil_wstadmin_no-public-key_12.4.56.0_x-ww_c789dd3a.cat
XP_PAYLOAD_PATH=msil_wstadmin_no-public-key_12.4.56.0_x-ww_c789dd3a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wstadmin,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xonfud\client\fudloc.cs ===
using System;
using System.Runtime.InteropServices;
using System.IO;
using System.Xml;
using Microsoft.Win32;
using System.Collections;

namespace xonline.ops.tools.xonfud.client 
{
	[ComVisible(false)]
	internal struct ServerCfg
	{
				public string strNetworkName;
				public string strUploadURL;
				public string strDownloadURL;
				public string strUploadRoot;
				public string strDownloadRoot;
	}	


	[Guid("5DF0FDE1-CA5F-47d3-8914-EA451FC0DA89")]
	public interface IFUDLocator
	{
		int ReturnAvailable( ref string pbstrAvailXML );
		
		IXonFUD FUDConnect( string bstrNetwork );
	}


	[Guid("A58E89C8-655F-4730-A85A-FBCF679340E4")]
	public class FUDLocator : IFUDLocator
	{

		private ArrayList m_ServersCfg;

		public FUDLocator()
		{
			m_ServersCfg = new ArrayList();
			ServerCfg scfg = new ServerCfg();

		
			//open the main key
			//=================
	
			RegistryKey mainkey;

			try
			{
				mainkey = Registry.LocalMachine.OpenSubKey("Software\\xonfud");
			}

			catch( Exception )
			{
				return;
			}

			//get config data from all the subkeys
			//====================================

			string []strkeynames = mainkey.GetSubKeyNames();

			for( int i=0; i<strkeynames.Length; i++)
			{
				try
				{
					scfg.strNetworkName = strkeynames[i].ToString().ToUpper();

					RegistryKey subkey = mainkey.OpenSubKey(strkeynames[i]);

					scfg.strUploadURL = subkey.GetValue("UploadURL").ToString();
					scfg.strDownloadURL = subkey.GetValue("DownloadURL").ToString();
					scfg.strUploadRoot = subkey.GetValue("UploadRoot").ToString();
					scfg.strDownloadRoot = subkey.GetValue("DownloadRoot").ToString();	

					subkey.Close();

					if ( scfg.strUploadRoot != null && !scfg.strUploadRoot.EndsWith("\\") )
					{
						scfg.strUploadRoot += "\\";
					}

					if ( scfg.strDownloadRoot != null && !scfg.strDownloadRoot.EndsWith("\\") )
					{
						scfg.strDownloadRoot += "\\";					
					}

					m_ServersCfg.Add( scfg );
				}

				catch( Exception )
				{
				}

			}
			



		}


		public int ReturnAvailable ( ref string pbstrAvailXML )
		{
			pbstrAvailXML = "<NETWORKS>";

			for(int i=0; i< m_ServersCfg.Count; i++)
			{
				pbstrAvailXML += "<NETWORK>";
				pbstrAvailXML += ((ServerCfg)m_ServersCfg[i]).strNetworkName;
				pbstrAvailXML += "</NETWORK>";
			}

			pbstrAvailXML += "</NETWORKS>";

			return (int)RET.XONFUD_OK;
		}


		public IXonFUD FUDConnect( string bstrNetwork )
		{

			for(int i=0; i< m_ServersCfg.Count; i++)
			{		
				if (bstrNetwork.ToUpper() == ((ServerCfg)m_ServersCfg[i]).strNetworkName)
				{	
					IXonFUD pXonFUD = new XonFUD();

					((XonFUD)pXonFUD).SetConfig((ServerCfg)m_ServersCfg[i]); 

					return pXonFUD;
				}
			}

			return null;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xonfud\client\xonfud.cs ===
using System;
using System.Runtime.InteropServices;
using System.Data;
using System.IO;
using System.Text;
using System.Xml;
using System.Collections;
using System.Diagnostics;


namespace xonline.ops.tools.xonfud.client 
{
    

	[ComVisible(true)]
	public enum FLAG 
	{
		XONFUD_FOLDERREQUEST = 0x1,
		XONFUD_DELETEAFTER   = 0x2,
		XONFUD_RECURSIVE     = 0x4,
		XONFUD_TESTONLY	    = 0x8 };

	[ComVisible(true)]
	public enum RET 
	{
		XONFUD_OK			       =  0,
		XONFUD_E_SERVER_ERROR    = -1,
		XONFUD_E_DELETION_ERROR  = -2,
		XONFUD_E_BAD_DIRECTORY   = -3,
		XONFUD_E_BAD_CONFIG	   = -4,
		XONFUD_E_SERVER_NOTFOUND = -5,
        XONFUD_W_EMPTY_FILE = -6 };


	[Guid("8B30F3F9-2986-4351-82A9-9103BF76CFF7")]
	public interface IXonFUD
	{
		int ReturnAvailable( int lFlags, 
						   ref string pbstrAvailXML );
		
		int Download( int lFlags, 
					  string bstrRemoteRelPath, 
					  string bstrDestFolderRelPath,
					  ref int plNumDownloaded);

		int Upload( int lFlags, 
					string bstrLocalRelPath, 
					string bstrDestFolderRelPath, 
					ref int plNumUploaded );  
	}

	[Guid("317DE66C-00EB-4b00-BBAE-385B019F414A")]
	public class XonFUD : IXonFUD
	{
        const string m_strSource = "XonFUD";
        const int    m_iErrNum = 50000; //no need to use real event ID, client doesn't run in the datacenters 

		private FileReq m_FileReq;
		private ServerCfg m_Config;
		
		public XonFUD()
		{
			m_FileReq = new FileReq();
			//m_Config = null;
		}

		internal void SetConfig ( ServerCfg scfg )
		{
			m_Config = scfg;
		}

		public int ReturnAvailable( int lFlags, 
								    ref string pbstrAvailXML )
		{
			if ( null == m_Config.strDownloadURL )
			{
                EventLog.WriteEntry( 
                            m_strSource, 
                            "Failure due to bad configuration: Download URL not found.",
                            EventLogEntryType.Error,
                            m_iErrNum);


				return (int)RET.XONFUD_E_BAD_CONFIG;
			}

            XmlTextReader xmltr = null;

            try
            {
                xmltr = m_FileReq.DiscoverFiles( m_Config.strDownloadURL );

                if ( null == xmltr )
                {
                
                    EventLog.WriteEntry( 
                        m_strSource, 
                        "Server bad response while querying " + m_Config.strNetworkName + " for available files. ",
                        EventLogEntryType.Error,
                        m_iErrNum);

                    
                    return (int)RET.XONFUD_E_SERVER_ERROR;
                }
            }

            catch( Exception ex )
            {
                EventLog.WriteEntry( m_strSource, 
                                     "Server error while querying " + m_Config.strNetworkName + " for available files. " + " ( " + ex.Message + " ) ",
                                     EventLogEntryType.Error,
                                     m_iErrNum);
                    

                return (int)RET.XONFUD_E_SERVER_ERROR;
            }

			xmltr.Read();	
			pbstrAvailXML = xmltr.ReadOuterXml();

			return (int)RET.XONFUD_OK;
		}



		public int Download( int lFlags, 
						     string bstrRemoteRelPath, 
						     string bstrDestFolderRelPath,
						     ref int plNumDownloaded )
		{
			plNumDownloaded = 0;
			bstrRemoteRelPath = bstrRemoteRelPath.ToUpper();

			//make sure config data is populated
			//==================================

			if ( null == m_Config.strDownloadURL || null == m_Config.strDownloadRoot )
			{
                EventLog.WriteEntry( 
                            m_strSource, 
                            "Failure due to bad configuration: Download URL and/or Download Root not found.",
                            EventLogEntryType.Error,
                            m_iErrNum);


				return (int)RET.XONFUD_E_BAD_CONFIG;
			}

			//get the flags
			//=============

			bool bRecursive = ( ( (FLAG)lFlags & FLAG.XONFUD_RECURSIVE) != 0 );
			bool bDelAfter = ( ( (FLAG)lFlags & FLAG.XONFUD_DELETEAFTER ) != 0 );
			bool bFolder = ( ( (FLAG)lFlags & FLAG.XONFUD_FOLDERREQUEST ) != 0 );
			bool bMove = !bDelAfter && ( ( (FLAG)lFlags & FLAG.XONFUD_TESTONLY ) == 0 ); //move is the default	

			//Make sure remote dir is valid path
			//==================================

			if ( null == bstrRemoteRelPath )
			{
				bstrRemoteRelPath = "";
			}

			bstrRemoteRelPath = bstrRemoteRelPath.Replace("/","\\");
			
			if( bFolder && bstrRemoteRelPath != "" && !bstrRemoteRelPath.EndsWith("\\") )
			{
				bstrRemoteRelPath += "\\";
			}

			//default local download dir to root of downloads directory
			//=========================================================

			if ( null == bstrDestFolderRelPath )
			{
				bstrDestFolderRelPath = m_Config.strDownloadRoot;
			}
			else
			{
				bstrDestFolderRelPath.Replace("/","\\");

				bstrDestFolderRelPath = m_Config.strDownloadRoot + bstrDestFolderRelPath;

				if( !bstrDestFolderRelPath.EndsWith("\\") )
				{
					bstrDestFolderRelPath += "\\";
				}
			}

			//insure the local dir has been created
			//=====================================

			try
			{
				Directory.CreateDirectory(bstrDestFolderRelPath);
			}

			catch (Exception ex)
			{
                EventLog.WriteEntry( 
                            m_strSource, 
                            "Failure creating local directory: " + bstrDestFolderRelPath + " ( " + ex.Message + " )",
                            EventLogEntryType.Error,
                            m_iErrNum);


				return (int)RET.XONFUD_E_BAD_DIRECTORY;
			}

			//call server to get the list of files
			//====================================

            XmlTextReader xmltr = null;

            try
            {
                xmltr = m_FileReq.DiscoverFiles(m_Config.strDownloadURL);
		
                if (null == xmltr)
                {
                    EventLog.WriteEntry( 
                                m_strSource, 
                                "Failure due to bad configuration: Download URL not found.",
                                EventLogEntryType.Error,
                                m_iErrNum);


                    return (int)RET.XONFUD_E_SERVER_ERROR;
                }
            }

            catch ( Exception ex )
            {
                EventLog.WriteEntry( 
                    m_strSource, 
                    "Server error while querying " + m_Config.strNetworkName + " for available files. " + " ( " + ex.Message + " ) ",
                    EventLogEntryType.Error,
                    m_iErrNum);
                    

                return (int)RET.XONFUD_E_SERVER_ERROR;
            }

			//download all from the specified directory
			//=========================================

			while( xmltr.Read() )
			{
                if (xmltr.NodeType == XmlNodeType.Element && xmltr.Name.ToUpper() == "NAME")
                {
                    xmltr.Read();
						
					int iLastSlash = xmltr.Value.LastIndexOf("\\");

					if ( ( !bFolder && xmltr.Value.ToUpper() == bstrRemoteRelPath ) || //File requested, file name/path must match
						 ( bFolder && bRecursive && xmltr.Value.ToUpper().StartsWith(bstrRemoteRelPath) ) ||  //Recursive folder requested
						 ( bFolder && !bRecursive && xmltr.Value.ToUpper().StartsWith(bstrRemoteRelPath) && bstrRemoteRelPath.Length >= iLastSlash ) ) //individual folder requested
					{
						try
						{ 
							m_FileReq.DownloadFile( bstrDestFolderRelPath, m_Config.strDownloadURL, xmltr.Value, bMove );
						}

						catch( Exception ex )
						{
                            EventLog.WriteEntry( 
                                m_strSource, 
                                "Server error during download of " + xmltr.Value + " from " + m_Config.strNetworkName + ". " + " ( " + ex.Message + " ) ",
                                EventLogEntryType.Error,
                                m_iErrNum);
                    

							return (int)RET.XONFUD_E_SERVER_ERROR;
						}

						plNumDownloaded++;

						if ( bDelAfter )
						{
							try
							{
								m_FileReq.DeleteFile( m_Config.strDownloadURL, xmltr.Value );
							}

							catch( Exception ex )
							{
                                EventLog.WriteEntry( 
                                    m_strSource, 
                                    "Server error during deletion of " + xmltr.Value + " from " + m_Config.strNetworkName + ". " + " ( " + ex.Message + " ) ",
                                    EventLogEntryType.Error,
                                    m_iErrNum);
                    

								return (int)RET.XONFUD_E_DELETION_ERROR;
							}
						}
					}
				}
			}

			return (int)RET.XONFUD_OK;

		}




		public int Upload( int lFlags, 
						   string bstrLocalRelPath, 
						   string bstrDestFolderRelPath,
						   ref int plNumUploaded )
		{
			plNumUploaded = 0;

			if ( null == m_Config.strUploadURL || null == m_Config.strUploadRoot )
			{
                EventLog.WriteEntry( 
                    m_strSource, 
                    "Failure due to bad configuration: Upload URL and/or Upload Root not found.",
                    EventLogEntryType.Error,
                    m_iErrNum);


				return (int)RET.XONFUD_E_BAD_CONFIG;
			}

			if ( null == bstrDestFolderRelPath )
			{
				bstrDestFolderRelPath = "";
			}
			else if ( "" != bstrDestFolderRelPath && !bstrDestFolderRelPath.EndsWith("\\") )
			{
				bstrDestFolderRelPath += "\\";
			}

			if ( null == bstrLocalRelPath ) 
			{
				bstrLocalRelPath = m_Config.strUploadRoot;
			}
			else
			{
				bstrLocalRelPath = m_Config.strUploadRoot + bstrLocalRelPath;
			}

			bool bRecursive = ( ((FLAG)lFlags & FLAG.XONFUD_RECURSIVE) != 0 );
			bool bDelAfter = ( ( (FLAG)lFlags & FLAG.XONFUD_DELETEAFTER ) != 0 );
			bool bFolder = ( ( (FLAG)lFlags & FLAG.XONFUD_FOLDERREQUEST ) != 0 );

			//retrieve the list of requested files
			//====================================

			ArrayList filelist = new ArrayList();

			if ( bFolder )
			{
                try
                {
                    GetFiles( ref filelist, bstrLocalRelPath, bRecursive );
                }

                catch (Exception ex)
                {
                    EventLog.WriteEntry( 
                        m_strSource, 
                        "Error enumerating local files in: " + bstrLocalRelPath + " ( " + ex.Message  + " ) ",
                        EventLogEntryType.Error,
                        m_iErrNum);


                    return (int)RET.XONFUD_E_BAD_DIRECTORY;
                }
			}
			else
			{
				filelist.Add( bstrLocalRelPath );
			}

			//upload the files one by one
			//===========================

			string bstrMungeRelPath;

			for( int i=0; i < filelist.Count; i++ )
			{
				//create the relative path for the file to reside on the server
				//=============================================================

				bstrMungeRelPath = filelist[i].ToString().Substring(m_Config.strUploadRoot.Length);
			
				int iLast = bstrMungeRelPath.LastIndexOf("\\");

				if (iLast > 0)
				{
					bstrMungeRelPath = bstrMungeRelPath.Substring(0, iLast + 1 );
				}
				else
				{
					bstrMungeRelPath = "";
				}

				bstrMungeRelPath = bstrDestFolderRelPath + bstrMungeRelPath;

				//upload
				//======

                try
                {
                    int iRet = m_FileReq.UploadFile( m_Config.strUploadURL, bstrMungeRelPath, filelist[i].ToString() ) ;

                    if  ( (int)RET.XONFUD_OK == iRet )
                    {
                        plNumUploaded++;
                    }
                    else if ( iRet != (int)RET.XONFUD_W_EMPTY_FILE )
                    {
                        return (int)iRet;
                    }
                }

                catch(Exception ex)
                {
                    EventLog.WriteEntry( 
                        m_strSource, 
                        "Server error during upload of " + filelist[i].ToString() + " to " + m_Config.strNetworkName + ". " + " ( " + ex.Message + " ) ",
                        EventLogEntryType.Error,
                        m_iErrNum);
                    
                    
                    return (int)RET.XONFUD_E_SERVER_ERROR;
                }
				
				

				if ( bDelAfter )
				{
					try
					{
						File.Delete( filelist[i].ToString() );
					}

					catch(Exception ex)
					{
                        EventLog.WriteEntry( 
                            m_strSource, 
                            "Error during attempt to delete the local file: " + filelist[i].ToString() + " ( " + ex.Message + " ) ",
                            EventLogEntryType.Error,
                            m_iErrNum);
                    
                        
						return (int)RET.XONFUD_E_DELETION_ERROR;
					}
				}

			}

			return (int)RET.XONFUD_OK;

		}

		private void GetFiles( ref ArrayList arrlist, string strDir, bool bRecursive )
		{
			string []strFiles = null;
			string []strDirs = null;

			strFiles = Directory.GetFiles(strDir);

			if (strFiles != null)
			{
				for (int i=0; i <strFiles.Length; i++)
				{
					arrlist.Add(strFiles[i]);
				}
			}

			if (bRecursive)
			{
			    strDirs = Directory.GetDirectories( strDir );

				if (strDirs != null)
				{
					for( int j=0; j<strDirs.Length; j++ )
					{
						GetFiles( ref arrlist, strDirs[j], bRecursive);
					}
				}
			}

		}

	}




}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\xonfud\client\filereq.cs ===
using System;
using System.Net;
using System.IO;
using System.Xml;
using System.Text;

namespace xonline.ops.tools.xonfud.client 
{
	internal class FileReq
	{
		internal XmlTextReader DiscoverFiles( string strBaseURL)
		{

			HttpWebRequest HttpReq = (HttpWebRequest)WebRequest.Create( strBaseURL + "?listall" ); 

			WebResponse result = HttpReq.GetResponse();
		
			return new XmlTextReader( result.GetResponseStream() );
		}


		internal void DownloadFile( string strDLDir, string strBaseURL, string strFile, bool bMove )
		{
			byte []bytes = new byte[50000];
			strFile.Replace("/", "\\");

			//form the request
			//================

			string strGetRequest = strBaseURL + "?getone=" + HttpEscape(strFile);

			if (bMove)
			{
				strGetRequest += "&moveit=yeah";
			}

			HttpWebRequest HttpReq = (HttpWebRequest) WebRequest.Create( strGetRequest ); 

			HttpReq.Timeout = System.Threading.Timeout.Infinite;
			WebResponse result = HttpReq.GetResponse();

			//Insure the subdirectories are all created first
			//===============================================

			string []strDirs = strFile.Split( '\\');
			string strNewDir = strDLDir; 

			for(int i=0; i < strDirs.Length - 1; i++)
			{
				strNewDir += strDirs[i] += "\\";
				Directory.CreateDirectory( strNewDir );
			}

			FileStream fs = new FileStream(strDLDir + strFile, FileMode.OpenOrCreate);
			fs.SetLength(0);
					
			Stream s = result.GetResponseStream();
			
			int iCount = s.Read(bytes,0,50000);

			while (iCount >0 )
			{
				fs.Write(bytes,0,iCount);
				iCount = s.Read(bytes,0,50000);
			}

			s.Close();
			fs.Close();
			result.Close();
		}


		internal void DeleteFile( string strBaseURL, string strFile)
		{

			HttpWebRequest HttpReq = (HttpWebRequest)
				WebRequest.Create( strBaseURL + "?remove=" + HttpEscape(strFile));

			WebResponse result = HttpReq.GetResponse();
		
			result.Close();

		}


		internal int UploadFile( string strBaseURL, string strULDir, string strFilePath )
		{
			//open the local file first / don't bother with empty files
			//=========================================================

			FileStream fs = null;

			fs = new FileStream( strFilePath, FileMode.Open );
			
			if ( 0 == fs.Length )
			{
				fs.Close();
				return (int)RET.XONFUD_W_EMPTY_FILE;
			}

			//create the POST form data (RFC 1867)
			//====================================

			const string strBoundary = "---1---2---J---A---Y---4---2---0---9\xd\n";
			
			string strFormData = strBoundary;
			
			string []splitFile = strFilePath.Split('\\');

			strFormData += "Content-Disposition: form-data; name=\"file\"; filename=\"";
			strFormData += HttpEscape(splitFile[splitFile.Length-1]) + "\"\xd\nContent-Type: application/octet-stream\xd\n\xd\n";
	
			byte []byFormData = Encoding.UTF8.GetBytes(strFormData);

			//create the request object (destination folder goes on the querystring)
			//=====================================================================

			HttpWebRequest HttpReq = (HttpWebRequest) WebRequest.Create( strBaseURL + "?DestFolder=" + HttpEscape(strULDir) );
			
            HttpReq.Timeout = System.Threading.Timeout.Infinite;

			HttpReq.Method = "POST";
			HttpReq.ContentType = "multipart/form-data; boundary=" + strBoundary;
			HttpReq.ContentLength = fs.Length + byFormData.Length;
            
			

			//get the request stream and write the form data
			//==============================================

			Stream s = null;
			WebResponse result = null;

			try
			{
				s = HttpReq.GetRequestStream();

				s.Write( byFormData, 0, byFormData.Length );

				byte []bytes = new byte[50000];
				int iCount = fs.Read(bytes,0,50000);

				while ( iCount > 0 )
				{
					s.Write(bytes,0,iCount);
					iCount = fs.Read(bytes,0,50000);
				}
			
				s.Close();
				s = null;

				//get the response and close everything
				//=====================================

				result = HttpReq.GetResponse();

				//TODO: investigate the HTTP return code to return real success or failure


			}

			finally
			{
				if (s != null)
				{
					s.Close();
				}

				if (result != null)
				{
					result.Close();
				}

				fs.Close();
			}

			return (int)RET.XONFUD_OK;
		}

        //return the passed in string after adding the http escape codes
        internal string HttpEscape( string strFile)
        {
            string strRet = strFile.Replace("%","%25");
            strRet = strRet.Replace("&","%26");		
            strRet = strRet.Replace(" ","%20");

            return strRet;
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\AccelerationConfig.cpp ===
#include "stdafx.h"

CAccelerationConfig::CAccelerationConfig() :
    m_pConfig(NULL),
    m_dwMaxKeyLength(0),
    m_qwTotalDataStorageBytes(0),
    m_qwLowWaterDataStorageBytes(0),
    m_dwHeartbeatInterval(0),
    m_dwRecordMaintenangePeriod(0),
    m_dwContextDurationAlertLimit(0)
{
}

CAccelerationConfig::~CAccelerationConfig()
{
    Close();
}

HRESULT CAccelerationConfig::Init()
{
    HRESULT hr = S_OK;

    hr = m_pConfig.CoCreateInstance(__uuidof(ConfigInterop));
    if (FAILED(hr))
    {
        goto lDone;
    }

    //  Setup notification handler
    m_pConfigListener = new CAccelerationConfigListener();
    if (m_pConfigListener != NULL)
    {
        hr = m_pConfig->putref_ConfigListener(m_pConfigListener);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {        
        XomNtEvent( XEVENT_ACCELERATION_CONFIG_LISTENER_FAILED, "CAccelerationConfig::Init() - Failed to register Config Listener object, hr=0x%08X", hr );
        goto lDone;
    }

    hr = Reload(NULL);

lDone:

    return hr;
}

void CAccelerationConfig::Close()
{
    if (m_pConfig && m_pConfigListener)
    {
        m_pConfig->putref_ConfigListener(NULL);
        m_pConfigListener->Release();
        m_pConfigListener = NULL;
    }
    if (m_pConfig)
    {
        m_pConfig.Release();
        m_pConfig = NULL;
    }
}

HRESULT CAccelerationConfig::Reload(struct ISettingChangeEventArgs * eventArgs)
{
    if (eventArgs == NULL)
    {
        // startup
        m_dwMaxKeyLength = GetDWORDSetting(Setting_acceleration_max_key_length);
        m_qwTotalDataStorageBytes = GetQWORDSetting(Setting_acceleration_total_data_storage_bytes);
        m_qwLowWaterDataStorageBytes = GetQWORDSetting(Setting_acceleration_low_water_data_storage_bytes);
        m_dwHeartbeatInterval = GetDWORDSetting(Setting_acceleration_heartbeat_interval);
        m_dwRecordMaintenangePeriod = GetDWORDSetting(Setting_acceleration_record_maintenance_period);
        m_dwContextDurationAlertLimit = GetDWORDSetting(Setting_acceleration_context_duration_alert_limit);    
        m_dwNotificationChangelistSize = GetDWORDSetting(Setting_acceleration_notificationChangelistSize);    
        m_dwNumHashtableBuckets = GetDWORDSetting(Setting_acceleration_numHashtableBuckets);    
        m_dwAllocationPageSize = GetDWORDSetting(Setting_acceleration_allocation_page_size);  
        GetDWORDArraySetting(Setting_acceleration_allocation_sizes, &m_dwNumAllocationSizes, m_rgAllocationSizes);
        return S_OK;
    }
    
    // else dynamic config change.
    
    CComBSTR SettingChange;
    CComBSTR bsValueNew = CComBSTR(NULL);
    HRESULT hr = S_OK;

    hr = eventArgs->get_Setting(&SettingChange);
    if (FAILED(hr))
    {
        goto lDone;
    }
    
    hr = eventArgs->get_ValueNew(&bsValueNew);
    if (FAILED(hr))
    {
        goto lDone;
    }
    
    if (SettingChange == Setting_acceleration_total_data_storage_bytes)
    {
        m_qwTotalDataStorageBytes = GetQWORDSetting(Setting_acceleration_total_data_storage_bytes, bsValueNew);
    }
    else if (SettingChange == Setting_acceleration_low_water_data_storage_bytes)
    {
        m_qwLowWaterDataStorageBytes = GetQWORDSetting(Setting_acceleration_low_water_data_storage_bytes, bsValueNew);
    }
    else if (SettingChange == Setting_acceleration_heartbeat_interval)
    {
        m_dwHeartbeatInterval = GetDWORDSetting(Setting_acceleration_heartbeat_interval, bsValueNew);
    }
    else if (SettingChange == Setting_acceleration_record_maintenance_period)
    {
        m_dwRecordMaintenangePeriod = GetDWORDSetting(Setting_acceleration_record_maintenance_period, bsValueNew);
    }
    else if (SettingChange == Setting_acceleration_context_duration_alert_limit)
    {
        m_dwContextDurationAlertLimit = GetDWORDSetting(Setting_acceleration_context_duration_alert_limit, bsValueNew);
    }

lDone:
    
    return hr;
}

DWORD CAccelerationConfig::GetDWORDSetting(CComBSTR bsSetting, CComBSTR bsValue)
{
    DWORD dwRetVal = 0;
    HRESULT hr = S_OK;

    if (bsValue == NULL)
    {
        hr = m_pConfig->GetSetting( bsSetting, &bsValue );
    }
    
    if( FAILED( hr ) || (bsValue == NULL))
    {
        XomNtEvent( XEVENT_ACCELERATION_CONFIG_SETTING_FAILED, "CAccelerationConfig::GetDWORDSetting() - Config.GetSetting failed DWORD setting '%S', hr=0x%08X", (WCHAR*)(BSTR)bsSetting, hr );
        return 0;
    }

    if( ( L'0' == bsValue[ 0 ] ) && ( L'x' == bsValue[ 1 ] ) )
    {
        if( 0 >= swscanf( bsValue, L"%x", &dwRetVal ) )
        {
            dwRetVal = 0;
        }
    }
    else
    {
        dwRetVal = (DWORD) _wtoi(bsValue);
    }

    return dwRetVal;
}

QWORD CAccelerationConfig::GetQWORDSetting(CComBSTR bsSetting, CComBSTR bsValue)
{
    QWORD qwRetVal = 0;
    HRESULT hr = S_OK;

    if (bsValue == NULL)
    {
        hr = m_pConfig->GetSetting( bsSetting, &bsValue );
    }
    
    if( FAILED( hr ) || (bsValue == NULL))
    {
        XomNtEvent( XEVENT_ACCELERATION_CONFIG_SETTING_FAILED, "CAccelerationConfig::GetQWORDSetting() - Config.GetSetting failed QWORD setting '%S', hr=0x%08X", (WCHAR*)(BSTR)bsSetting, hr );
        return 0;
    }

    if( ( L'0' == bsValue[ 0 ] ) && ( L'x' == bsValue[ 1 ] ) )
    {
        if( 0 >= swscanf( bsValue, L"%I64x", &qwRetVal ) )
        {
            qwRetVal = 0;
        }
    }
    else
    {
        qwRetVal =  _wtoi64(bsValue);
    }

    return qwRetVal;
}

void CAccelerationConfig::GetDWORDArraySetting(
    CComBSTR Setting,
    DWORD *pdwLen,
    DWORD *rgdwVal,
    CComBSTR bsValue)
{
    // BUGBUG put in a new array, then swap

    LPCWSTR wszRead;
    int iRet;
    HRESULT hr = S_OK;

    if (bsValue == NULL)
    {
        // Get the string to parse
        hr = m_pConfig->GetSetting( Setting, &bsValue );
    }

    if( FAILED( hr ) || (bsValue == NULL))
    {
        XomNtEvent( XEVENT_ACCELERATION_CONFIG_SETTING_FAILED, "CAccelerationConfig::GetDWORDArraySetting() - Config.GetSetting failed, hr=0x%08X", hr );

        *pdwLen = 0;
        return;
    }

    wszRead = bsValue;
    *pdwLen = 0;
    for (;;)
    {
        // Check the size limit
        if (*pdwLen >= MAX_DWORD_ARRAY)
        {
            break;
        }

        // Try to get an element
        if( ( '0' == wszRead[ 0 ] ) && ( 'x' == wszRead[ 1 ] ) )
        {
            iRet = swscanf(wszRead, L"%x", rgdwVal + *pdwLen);
        }
        else
        {
            iRet = swscanf(wszRead, L"%d", rgdwVal + *pdwLen);
        }

        // Did we get anything
        if (iRet != 1)
        {
            break;
        }

        // Next element
        *pdwLen = *pdwLen + 1;

        while ((*wszRead != '\0') && (*wszRead != ','))
        {
            wszRead++;
        }

        while ((*wszRead == ',') || (*wszRead == ' ') || (*wszRead == '\t'))
        {
            wszRead++;
        }
    }

}

WORD CAccelerationConfig::GetListenPort()
{
    IInterfaceInfo *piII = NULL;
    long port = 0;
    CHAR szLocalHost [INTERNET_MAX_HOST_NAME_LENGTH];
    int iRet = 0;
 
    // Get the local hostname
    iRet = gethostname(szLocalHost, INTERNET_MAX_HOST_NAME_LENGTH);
    if (iRet != 0) 
    {
        goto lDone; 
    }
        
    HRESULT hr = m_pConfig->GetInterface(CComBSTR(szLocalHost), CComBSTR(GetComponentNameW()), &piII);
    if (FAILED(hr) || (piII == NULL))
    {
        goto lDone;
    }

    hr = piII->get_Port(&port);
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:

    if (piII != NULL)
    {
        piII->Release();
    }

    return (WORD)port;
}

class CAccelerationSettingsChangeContext : public CLocalContext
{
public:
    CAccelerationSettingsChangeContext() :
        m_eventArgs(NULL),
        m_hevtFinished(NULL),
        m_hr(S_OK)
    { }

    virtual ~CAccelerationSettingsChangeContext()
    {
    }

    virtual void CompletionProc()
    {
        m_hr = g_Config.Reload(m_eventArgs);

        if (m_hevtFinished)
        {
            SetEvent(m_hevtFinished);
        }
    }
      
    virtual char* GetDescription() { return "SettingsChange"; }

    struct ISettingChangeEventArgs *m_eventArgs;
    HANDLE m_hevtFinished;
    HRESULT m_hr;

};

HRESULT __stdcall CAccelerationConfigListener::SettingChange (
    struct ISettingChangeEventArgs * e )
{
    HRESULT hr = S_OK;
    HANDLE hevtWait = INVALID_HANDLE_VALUE;
    CAccelerationSettingsChangeContext *pCCtx = NULL;
    
    XomNtEvent(XEVENT_ACCELERATION_CONFIG_SETTING_CHANGED, "CAccelerationConfigListener::SettingChange() called.");
    
    pCCtx = new CAccelerationSettingsChangeContext();
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        XomNtEvent(XEVENT_ACCELERATION_CONFIG_OUT_OF_MEMORY, "CAccelerationConfigListener::SettingChange() could not allocate settings change context.");
        goto lDone;
    }

    hevtWait = CreateEvent(NULL, TRUE, FALSE, NULL);
    if ((hevtWait == NULL) || (hevtWait == INVALID_HANDLE_VALUE))
    {
        hr = E_OUTOFMEMORY;
        XomNtEvent(XEVENT_ACCELERATION_CONFIG_OUT_OF_MEMORY, "CAccelerationConfigListener::SettingChange() could not allocate wait event.");
        goto lDone;
    }

    pCCtx->m_eventArgs = e;
    pCCtx->m_hevtFinished = hevtWait;    

    hr = g_Switchboard.PostCompletion(pCCtx);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_ACCELERATION_CONFIG_POST_COMPLETION_FAILED, "CAccelerationConfigListener::SettingChange() could not post completion, hr=0x%08X", hr);
        goto lDone;
    }

    // this thread blocks until switchboard has processed the setting change.
    if (WAIT_OBJECT_0 != WaitForSingleObject(hevtWait, INFINITE))
    {
        hr = E_UNEXPECTED;
        XomNtEvent(XEVENT_ACCELERATION_CONFIG_WAIT_COMPLETION_FAILED, "CAccelerationConfigListener::SettingChange() failed while waiting for completion.");
        goto lDone;
    }

    hr = pCCtx->m_hr;

lDone:

    SAFE_RELEASE(pCCtx);
    SAFE_CLOSEHANDLE(hevtWait);
    
    return hr;
}

CAccelerationHealth::CAccelerationHealth() :
    m_pHealthInterop(NULL)
{
}

CAccelerationHealth::~CAccelerationHealth()
{
    Close();
}

HRESULT CAccelerationHealth::Init(CComBSTR bsComponent)
{
    HRESULT hr = S_OK;

    // create the health interop instances 
    hr = m_pHealthInterop.CoCreateInstance( __uuidof(HealthInterop) );
    if ( FAILED(hr) )
    {
        XomNtEvent(XEVENT_ACCELERATION_CONFIG_HEALTHINTEROP_CREATE,
            "CAccelerationHealth::Init failed to instantiate HealthInterop "
            "with hr: 0x%08X. Verify xblhealthcheck.dll is in the GAC and it "
            "has been registered with regasm.exe, making sure to use the proper "
            "32 or 64 bit version.  Also verify the various XBL platform DLLs are "
            "in the GAC as well.", 
            hr);
        goto lDone;
    }

    // and fire up the http health listener for this component
    hr = m_pHealthInterop->Initialize(bsComponent, (LONG_PTR)::GetModuleHandle(NULL));
    if ( FAILED(hr) )
    {
        XomNtEvent(XEVENT_ACCELERATION_CONFIG_HEALTHINTEROP_INIT,
            "CAccelerationHealth::Init failed to call Initialize on the "
            "HealthInterop instance for component %S with hr: 0x%08X.",
            (BSTR)bsComponent, hr);
        goto lDone;
    }

lDone:

    return hr;
}

void CAccelerationHealth::Close()
{
    if (m_pHealthInterop)
    {
        m_pHealthInterop.Release();
        m_pHealthInterop = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\AccelerationPerfCtrs.cpp ===
#include "stdafx.h"
#include "AccelerationPerfCtrs.h"
#include "AccelPerf.h"
#include "perfapi.h"


enum XQPC_TYPES
{
    XQPC_DWORD = 1,
    XQPC_QWORD = 2,
    XQPC_OBJECT = 3
};

struct PERFCOUNTER
{
    XQPC_TYPES ctrType;
    DWORD dwPerfType;
    DWORD dwDataSize;
    DWORD dwObjectIndex;
    DWORD dwDataOffset;
};

// Objects (Categories)
struct PERFOBJECT
{
    DWORD dwPerfIndex;
    HANDLE hPerfObject;
    BYTE *pbPerfCtrDataStart;
    DWORD dwInstanceID;
    BOOL fCreate;
};

#define DWORD_AVERAGE( INDEX ) \
    { XQPC_DWORD, PERF_AVERAGE_TIMER, sizeof(DWORD), 0, 0 }

#define DWORD_BASE( INDEX ) \
    { XQPC_DWORD, PERF_AVERAGE_BASE, sizeof(DWORD), 0, 0 }

#define DWORD_COUNTER( INDEX ) \
    { XQPC_DWORD, PERF_COUNTER_RAWCOUNT, sizeof(DWORD), 0, 0 }

#define DWORD_RATE( INDEX ) \
    { XQPC_DWORD, PERF_COUNTER_COUNTER, sizeof(DWORD), 0, 0 }

#define QWORD_AVERAGE( INDEX ) \
    { XQPC_QWORD, PERF_AVERAGE_BULK, sizeof(QWORD), 0, 0 }

#define QWORD_COUNTER( INDEX ) \
    { XQPC_QWORD, PERF_COUNTER_LARGE_RAWCOUNT, sizeof(QWORD), 0, 0 }

#define QWORD_RATE( INDEX ) \
    { XQPC_QWORD, PERF_COUNTER_BULK_COUNT, sizeof(QWORD), 0, 0 }

#define OBJECT( INDEX ) \
    { XQPC_OBJECT, 0, 0, 0, 0 }

PERFOBJECT s_ServerPerfObjects[] =
{
    { ACCELERATIONPERF_SERVER_OBJECT_GENERAL, NULL, NULL, 0, FALSE },
    { ACCELERATIONPERF_SERVER_OBJECT_DATA, NULL, NULL, 0, FALSE }
};

//////////////////////////////////////////////////////////////////////////////
PERFCOUNTER s_ServerPerfCtrs[] =
{
    OBJECT(ACCELERATIONPERF_SERVER_OBJECT_GENERAL),
    QWORD_AVERAGE(ACCELERATION_SWITCHBOARD_WAIT_TIME_AVERAGE),
    DWORD_BASE(ACCELERATION_SWITCHBOARD_WAIT_TIME_BASE),
    DWORD_RATE(ACCELERATION_SWITCHBOARD_COMPLETION_RATE),
    QWORD_AVERAGE(ACCELERATION_SWITCHBOARD_CONTEXT_TIME_AVERAGE),
    DWORD_BASE(ACCELERATION_SWITCHBOARD_CONTEXT_TIME_BASE),
    QWORD_AVERAGE(ACCELERATION_HEARTBEAT_TIME_AVERAGE),
    DWORD_BASE(ACCELERATION_HEARTBEAT_TIME_BASE),
    DWORD_COUNTER(ACCELERATION_NUM_OPEN_CONNECTIONS),
    DWORD_RATE(ACCELERATION_REQUEST_MESSAGE_RATE),
    DWORD_COUNTER(ACCELERATION_BUFFERPOOL_NUM_TOTAL),
    DWORD_COUNTER(ACCELERATION_BUFFERPOOL_NUM_FREE),
    DWORD_RATE(ACCELERATION_BUFFERPOOL_CREATE_RATE),
    DWORD_RATE(ACCELERATION_BUFFERPOOL_BYPASS_RATE),
    DWORD_COUNTER(ACCELERATION_CONTEXTPOOL_NUM_TOTAL),
    DWORD_COUNTER(ACCELERATION_CONTEXTPOOL_NUM_FREE),
    DWORD_RATE(ACCELERATION_CONTEXTPOOL_CREATE_RATE),
    DWORD_COUNTER(ACCELERATION_CONTAINERPOOL_NUM_TOTAL),
    DWORD_COUNTER(ACCELERATION_CONTAINERPOOL_NUM_FREE),
    DWORD_RATE(ACCELERATION_CONTAINERPOOL_CREATE_RATE),
    DWORD_RATE(ACCELERATION_BUCKET_MAINTENANCE_RATE),
    DWORD_RATE(ACCELERATION_LOCK_RATE),
    QWORD_AVERAGE(ACCELERATION_LOCK_SPINCOUNT_AVERAGE),
    DWORD_BASE(ACCELERATION_LOCK_SPINCOUNT_BASE),
    DWORD_RATE(ACCELERATION_ALLOCATOR_ITEM_CREATE_RATE),
    QWORD_COUNTER(ACCELERATION_ALLOCATOR_NUM_ITEMS_TOTAL),
    DWORD_COUNTER(ACCELERATION_ALLOCATOR_NUM_PAGES_TOTAL),
    DWORD_RATE(ACCELERATION_ITEM_DELETE_RATE),
    DWORD_RATE(ACCELERATION_CHANGELIST_CHANGE_RATE),
    DWORD_COUNTER(ACCELERATION_DELETIONLIST_SIZE),
    DWORD_RATE(ACCELERATION_DELETIONLIST_DELETE_RATE),
    QWORD_COUNTER(ACCELERATION_ALLOCATOR_WASTED_BYTES),
    DWORD_RATE(ACCELERATION_ALLOCATOR_BYPASS_RATE),
    DWORD_COUNTER(ACCELERATION_ALLOCATOR_LARGEST_OBJECT),
    OBJECT(ACCELERATIONPERF_SERVER_OBJECT_DATA),
    QWORD_COUNTER(ACCELERATION_NUM_CACHE_ITEMS),
    QWORD_COUNTER(ACCELERATION_NUM_CACHE_BYTES),
    DWORD_RATE(ACCELERATION_EXPIRE_RATE),
    DWORD_RATE(ACCELERATION_PURGE_RATE),
    DWORD_RATE(ACCELERATION_CACHE_HIT_RATE),
    DWORD_RATE(ACCELERATION_CACHE_MISS_RATE),
    QWORD_AVERAGE(ACCELERATION_CACHE_HIT_RATIO),
    DWORD_BASE(ACCELERATION_CACHE_HIT_RATIO_BASE),
    QWORD_COUNTER(ACCELERATION_NUM_CACHE_DATA_BYTES),
    QWORD_COUNTER(ACCELERATION_NUM_CACHE_OVERHEAD_BYTES),
    DWORD_RATE(ACCELERATION_LOOKUPTABLE_FIND_RATE),
    DWORD_RATE(ACCELERATION_LOOKUPTABLE_ADD_RATE),
    DWORD_RATE(ACCELERATION_LOOKUPTABLE_REMOVE_RATE),
    DWORD_RATE(ACCELERATION_LOOKUPTABLE_LOCK_RATE),
    DWORD_RATE(ACCELERATION_QUERY_API_RATE),
    DWORD_RATE(ACCELERATION_INSERT_API_RATE),
    DWORD_RATE(ACCELERATION_REMOVE_API_RATE),
    DWORD_RATE(ACCELERATION_SETDATA_API_RATE),
    DWORD_RATE(ACCELERATION_INCREMENT_API_RATE),
};

#define NUM_SERVER_PERF_COUNTERS ARRAY_ELEMENTS(s_ServerPerfCtrs)

//////////////////////////////////////////////////////////////////////////////
CAccelerationPerfCounters::CAccelerationPerfCounters()
{
}


//////////////////////////////////////////////////////////////////////////////
CAccelerationPerfCounters::~CAccelerationPerfCounters()
{
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CAccelerationPerfCounters::Init()
{
    HRESULT hr;

    //
    // Create the server perf object and associated counters
    //
    
    // Initialize perf objects
    DWORD dwObj = 0;
    for( DWORD dwCtr = 0; dwCtr < NUM_SERVER_PERF_COUNTERS; dwCtr++ )
    {
        if (s_ServerPerfCtrs[dwCtr].ctrType != XQPC_OBJECT)
        {
            // not an object
            continue;
        }

        s_ServerPerfObjects[dwObj].hPerfObject = OpenPerfObject(
            s_ServerPerfObjects[dwObj].dwPerfIndex,
            (void **)&s_ServerPerfObjects[dwObj].pbPerfCtrDataStart);
        if (s_ServerPerfObjects[dwObj].hPerfObject == NULL)
        {
            s_ServerPerfObjects[dwObj].fCreate = TRUE;

            s_ServerPerfObjects[dwObj].hPerfObject = CreatePerfObject(
                s_ServerPerfObjects[dwObj].dwPerfIndex,
                0,
                (void **)&s_ServerPerfObjects[dwObj].pbPerfCtrDataStart);
            if (s_ServerPerfObjects[dwObj].hPerfObject == NULL)
            {
                hr = E_UNEXPECTED;
                goto lDone;
            }
        }

        // Initialize object instance
        WCHAR *wszInstanceName;
        s_ServerPerfObjects[dwObj].dwInstanceID = CreateObjectInstance(
            s_ServerPerfObjects[dwObj].hPerfObject,
            GetComponentNameW(),
            (void **)&wszInstanceName, 
            (void **)&s_ServerPerfObjects[dwObj].pbPerfCtrDataStart);
        if (FAILED(s_ServerPerfObjects[dwObj].dwInstanceID))
        {
            hr = E_UNEXPECTED;
            goto lDone;
        }
        
        dwObj++;
    }

    dwObj = 0;

    // Initialize perf counters
    for( DWORD dwCtr = 0; dwCtr < NUM_SERVER_PERF_COUNTERS; dwCtr++ )
    {
        if (s_ServerPerfCtrs[dwCtr].ctrType == XQPC_OBJECT)
        {
            // not a counter
            dwObj++;
            continue;
        }        

        s_ServerPerfCtrs[dwCtr].dwObjectIndex = dwObj - 1;

        s_ServerPerfCtrs[dwCtr].dwDataOffset = CreatePerfCounter(
                                            s_ServerPerfCtrs[ dwCtr ].dwPerfType,
                                            0,       // dwScale
                                            s_ServerPerfCtrs[ dwCtr ].dwDataSize,
                                            s_ServerPerfObjects[s_ServerPerfCtrs[dwCtr].dwObjectIndex].hPerfObject,
                                            dwCtr * 2,
                                            NULL );

        assert( 0xffffffff != s_ServerPerfCtrs[dwCtr].dwDataOffset);

        //
        // Zero every counter on startup
        //
        ZeroMemory(
            s_ServerPerfObjects[s_ServerPerfCtrs[dwCtr].dwObjectIndex].pbPerfCtrDataStart + s_ServerPerfCtrs[ dwCtr ].dwDataOffset,
            s_ServerPerfCtrs[ dwCtr ].dwDataSize );
    }

    hr = S_OK;

lDone:
    
    return( hr );
}

void CAccelerationPerfCounters::Close()
{
    DWORD dwObj = 0;
    for( DWORD dwCtr = 0; dwCtr < NUM_SERVER_PERF_COUNTERS; dwCtr++ )
    {
        if (s_ServerPerfCtrs[dwCtr].ctrType != XQPC_OBJECT)
        {
            // not an object
            continue;
        }

        DestroyObjectInstance(s_ServerPerfObjects[dwObj].hPerfObject, s_ServerPerfObjects[dwObj].dwInstanceID);
                
        dwObj++;
    }
}

//////////////////////////////////////////////////////////////////////////////
DWORD CAccelerationPerfCounters::GetCurrentValue32(DWORD dwCounterID)
{
    DWORD dwCounterIndex = (dwCounterID / 2);
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    BYTE *pbDataStart = s_ServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;

    return( *(DWORD *) (pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset));
}


//////////////////////////////////////////////////////////////////////////////
void CAccelerationPerfCounters::SetCurrentValue32(DWORD dwCounterID, DWORD dwVal)
{
    DWORD dwCounterIndex = (dwCounterID / 2);
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    BYTE *pbDataStart = s_ServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;

    InterlockedExchange(
        (LONG *) (pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset),
        (LONG) dwVal );
}


//////////////////////////////////////////////////////////////////////////////
void CAccelerationPerfCounters::IncrementValue32(DWORD dwCounterID, DWORD dwAmount)
{
    DWORD dwCounterIndex = (dwCounterID / 2);
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    BYTE *pbDataStart = s_ServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;
    if (pbDataStart != NULL)
    {
        InterlockedExchangeAdd(
            (LONG *) (pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset),
            (LONG) dwAmount );
    }
}

void CAccelerationPerfCounters::IncrementValue64(DWORD dwCounterID, QWORD qwAmount)
{
    DWORD dwCounterIndex = (dwCounterID / 2);
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    BYTE *pbDataStart = s_ServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;
    if (pbDataStart != NULL)
    {
        InterlockedExchangeAdd64(
            (LONGLONG *) (pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset),
            (LONGLONG) qwAmount );
    }
}



//////////////////////////////////////////////////////////////////////////////
void CAccelerationPerfCounters::DecrementValue32(DWORD dwCounterID, DWORD dwAmount)
{
    IncrementValue32(dwCounterID, -(LONG)dwAmount);
}

void CAccelerationPerfCounters::DecrementValue64(DWORD dwCounterID, QWORD dwAmount)
{
    IncrementValue64(dwCounterID, -(LONGLONG)dwAmount);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\AccelerationData.cpp ===
#include "stdafx.h"

QWORD CAccelerationIncrementValue::ComputeNewValue(QWORD qwIncrementAmount, DWORD dwHalfLifeSeconds)
{
    SYSTEMTIME st;
    FILETIME ft;
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    if (dwHalfLifeSeconds != ACCELERATION_INCREMENT_HALFLIFE_INFINITE)
    {
        // decay the old value:  N(t) = N(0) * 2 ^ -(t / halflife)
        double dElapsedSeconds = (double)(*(QWORD *)&ft - m_qwLastUpdate) / (10.0 * 1000.0 * 1000.0);
        double dHalfLifeSeconds = (double)dwHalfLifeSeconds;

        m_dValue *= pow(2.0, -(dElapsedSeconds / dHalfLifeSeconds));
    }

    // increment and set the update time to now.
    m_dValue += qwIncrementAmount;
    m_qwLastUpdate = *(QWORD *)&ft;

    // our double value could in theory go above the max qword value, which gives 
    // weird results when you convert back into a qword. Seems to return 
    // 0x8000000000000000 every time.  so let's catch that? also, be aware that 
    // doubles can't actually represent a max qword -- they round up a bit -- so we 
    // need a safety margin. let's make it signed. blargh.

    return m_dValue > (double)0x7FFFFFFFFFFFFFFF ? 0x7FFFFFFFFFFFFFFF : (QWORD)m_dValue;
}

bool AccelerationCompareBytes(DWORD cb1, BYTE *pb1, DWORD cb2, BYTE *pb2)
{
    if (cb1 != cb2)
    {
        return false;
    }

    return (0 == memcmp(pb1, pb2, cb1));
}

DWORD AccelerationHashBytes(DWORD cb, BYTE *pb)
{
    // this hash function is taken from http://murmurhash.googlepages.com/

    // 'm' and 'r' are mixing constants generated offline.
    // They're not really 'magic', they just happen to work well.
    const DWORD m = 0x5bd1e995;
    const int r = 24;

    // the algorithm allows for a seed here, but we dont need it.
    DWORD h = 1;

    // Mix 4 bytes at a time into the hash
    while(cb >= 4)
    {
        DWORD k = *(DWORD *)pb;

        k *= m; 
        k ^= k >> r; 
        k *= m; 

        h *= m; 
        h ^= k;

        pb += 4;
        cb -= 4;
    }

    // Handle the last few bytes of the input array
    switch(cb)
    {
    case 3: h ^= pb[2] << 16;
    case 2: h ^= pb[1] << 8;
    case 1: h ^= pb[0];
        h *= m;
    };

    // Do a few final mixes of the hash to ensure the last few
    // bytes are well-incorporated.
    h ^= h >> 13;
    h *= m;
    h ^= h >> 15;

    return h;
}

CAccelerationData::CAccelerationData() :
    m_cbKey(0)
{
#ifdef _DEBUG
    m_state = STATE_NEW;
    m_dwSig = ACCELERATION_DATA_SIGNATURE;
#endif

    g_Counters.IncrementValue32(ACCELERATION_CONTAINERPOOL_NUM_TOTAL, 1);
    g_Counters.IncrementValue32(ACCELERATION_CONTAINERPOOL_CREATE_RATE, 1);
   
    g_Counters.IncrementValue64(ACCELERATION_NUM_CACHE_BYTES, sizeof(CAccelerationData));
    g_Counters.IncrementValue64(ACCELERATION_NUM_CACHE_OVERHEAD_BYTES, sizeof(CAccelerationData));

    Close();
}

HRESULT CAccelerationData::Init(
    DWORD cbKey, 
    BYTE *pbKey, 
    DWORD cbData, 
    BYTE *pbData, 
    DWORD dwAbsoluteSeconds, 
    DWORD dwSlidingSeconds,
    FILETIME *pftNow)
{
    // allocate memory for key + data.
    HRESULT hr = S_OK;

#ifdef _DEBUG
    SetState(STATE_IN_USE);
#endif

    if ((cbKey == 0) ||
        (pbKey == NULL))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    hr = g_Allocator.AllocateMemory((CFixedSizeMemoryHandle *)this, cbKey + cbData);
    if (FAILED(hr))
    {
        goto lDone;
    }

    LockMemory();
    
    m_cbKey = cbKey;

    memcpy(GetKeyBytes(), pbKey, cbKey);
    memcpy(GetDataBytes(), pbData, cbData);

    m_dwSlidingSeconds = dwSlidingSeconds;
    m_qwAbsoluteExpiration = 0;
    m_qwSlidingExpiration = 0;
    m_dwVersion = IsReservation() ? 0 : 1;
    m_pNextLookup = NULL;

    g_Counters.IncrementValue64(ACCELERATION_NUM_CACHE_ITEMS, 1);
    g_Counters.IncrementValue64(ACCELERATION_NUM_CACHE_BYTES, cbKey + cbData);
    g_Counters.IncrementValue64(ACCELERATION_NUM_CACHE_DATA_BYTES, cbData);
    g_Counters.IncrementValue64(ACCELERATION_NUM_CACHE_OVERHEAD_BYTES, cbKey);

    FILETIME ft;

    if (pftNow == NULL)
    {
        SYSTEMTIME st;
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);
        pftNow = &ft;
    }

    UpdateSlidingExpiration(pftNow);

    if (dwAbsoluteSeconds > 0)
    {
        // FILETIME is in 100 nanosecond intervals.
        m_qwAbsoluteExpiration = *(QWORD *)pftNow + ((QWORD) dwAbsoluteSeconds * 10 * 1000 * 1000);
        if (m_qwAbsoluteExpiration == 0)
        {
            m_qwAbsoluteExpiration = 1;
        }
    }

    UnlockMemory();

lDone:

    return hr;
}

// virtual destructor!
CAccelerationData::~CAccelerationData()
{
    Close();
}

HRESULT CAccelerationData::Close()
{
    HRESULT hr = S_FALSE;

#ifdef _DEBUG
    if( m_state != STATE_NEW)
    {
        SetState(STATE_CLOSED);
    }
#endif
    
    if (GetKeySize() != 0)
    {
        g_Counters.DecrementValue64(ACCELERATION_NUM_CACHE_ITEMS, 1);
        g_Counters.DecrementValue64(ACCELERATION_NUM_CACHE_BYTES, GetKeySize() + GetDataSize());
        g_Counters.DecrementValue64(ACCELERATION_NUM_CACHE_DATA_BYTES, GetDataSize());
        g_Counters.DecrementValue64(ACCELERATION_NUM_CACHE_OVERHEAD_BYTES, GetKeySize());

        hr = g_Allocator.FreeMemory((CFixedSizeMemoryHandle *)this);
    }

    m_cbKey = 0;
    m_dwSlidingSeconds = 0;
    m_dwVersion = 0;
    m_qwAbsoluteExpiration = 0;
    m_qwSlidingExpiration = 0;
    m_pNextLookup = NULL;
    m_pLessRecent = NULL;
    m_pMoreRecent = NULL;

    return hr;
}

bool CAccelerationData::DoMaintenance(FILETIME *pftNow)
{
    if (pftNow == NULL)
    {
        return false;        
    }

    bool fExpired = (FALSE != IsExpired(pftNow));
    if (fExpired)
    {
        // data will get removed from the table by the parent function.
        
        g_MRUList.RemoveItem(this);

        if (!IsReservation())
        {
            // record the change in the changelist.
            g_Changelist.RecordChange(this);
        }

        MarkForDeletion();
    }

    return fExpired;
}


DWORD CAccelerationData::GetRemainingValidSeconds(FILETIME *pftNow)
{
    if ((m_qwAbsoluteExpiration == 0) && (m_qwSlidingExpiration == 0))
    {
        // no expiration.  it's good for a really long time.
        return 0xFFFFFFFF;
    }

    QWORD qwExpire = min(m_qwAbsoluteExpiration, m_qwSlidingExpiration);
    if (qwExpire == 0)
    {
        // they cant both be zero.  since we know one is zero, adding is the same as max() !!
        qwExpire = m_qwAbsoluteExpiration + m_qwSlidingExpiration;
    }

    QWORD qwValid = (qwExpire - *(QWORD *)pftNow);
    return (DWORD)(qwValid / (QWORD)(10 * 1000 * 1000));
}

void CAccelerationData::UpdateSlidingExpiration(FILETIME *pftNow)
{
    FILETIME ft;

    if (m_dwSlidingSeconds > 0)
    {
        if (pftNow == NULL)
        {
            SYSTEMTIME st;
            GetSystemTime(&st);
            SystemTimeToFileTime(&st, &ft);
            pftNow = &ft;
        }
        
        // FILETIME is in 100 nanosecond intervals.
        m_qwSlidingExpiration = *(QWORD *)pftNow + ((QWORD) m_dwSlidingSeconds * 10 * 1000 * 1000);
        if (m_qwSlidingExpiration == 0)
        {
            m_qwSlidingExpiration = 1;
        }
    }
}

void CAccelerationData::MarkForDeletion()
{
#ifdef _DEBUG
    XOMASSERT(m_dwSig == ACCELERATION_DATA_SIGNATURE);

    SetState(STATE_DELETION_LIST);
#endif

    g_DeletionList.AddToList(this);
}


HRESULT RemoveAndDelete(CAccelerationData *pVictim)
{
    HRESULT hr = S_OK;
    DWORD dwLockToken = CAccelerationLookupTable::InvalidHashValue;
    
    if (pVictim == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // lock the table bucket for this key.
    g_AccelerationLookupTable.LockBucketByKey(pVictim->GetKey(), &dwLockToken);

    // remove from the table.
    hr = g_AccelerationLookupTable.RemoveLookupEntry(dwLockToken, pVictim);

    // unlock the bucket.
    g_AccelerationLookupTable.UnlockBucket(dwLockToken);

    // check if we actually removed it from the table.  if not, someone else already did.
    if (hr != S_OK)
    {
        goto lDone;
    }

    // should already be out of the MRUList.

    if (!pVictim->IsReservation())
    {
        // record the change in the changelist.
        g_Changelist.RecordChange(pVictim);
    }

    // bypass the deletion list here.  we're already on the maintenance routine.
    pVictim->Close();
    g_ContainerPool.Insert(pVictim);

lDone:
    
    return hr;
}

QWORD GetMemoryUsage()
{
    static HANDLE hProc = GetCurrentProcess();
    PROCESS_MEMORY_COUNTERS_EX mcex = {0};
    GetProcessMemoryInfo(hProc, (PROCESS_MEMORY_COUNTERS *)&mcex, sizeof(PROCESS_MEMORY_COUNTERS_EX));
    return (QWORD)mcex.PrivateUsage;
}

BOOL ManageMemoryPressure(DWORD dwStart)
{
    QWORD qwMemoryUsage = 0;

    // purge the deletion list first.
    while (TICK_DIFF(GetTickCount(), dwStart) < g_Config.GetHeartbeatInterval())
    {
        // there shouldnt be anything on the deletion list that is still in the table or the MRU list.
        CAccelerationData *pVictim = g_DeletionList.DeleteNextItem();
        if (pVictim == NULL)
        {
            break;
        }

        // close this item and place it back on the free pool.
        pVictim->Close();
        g_ContainerPool.Insert(pVictim);
    }

    // read the size.
    qwMemoryUsage = GetMemoryUsage();
    
    // check for extreme memory pressure.
    if ((qwMemoryUsage > g_Config.GetTotalDataStorageBytes()) &&
        (g_fServerTooBusy == FALSE))
    {
        // we're over the maximum amount.  delete until we're under the low-water mark.

        // set the too-busy flag while we block switchboard's thread to do this.
        g_fServerTooBusy = TRUE;
        XomNtEvent(
            XEVENT_ACCELERATION_SERVER_TOO_BUSY,
            "Memory usage = %I64d bytes.  Setting server too busy flag while purging items.",
            qwMemoryUsage);
    }

    // check for memory pressure.
    while ((qwMemoryUsage > g_Config.GetLowWaterDataStorageBytes()) &&
        (TICK_DIFF(GetTickCount(), dwStart) < g_Config.GetHeartbeatInterval()))
    {
        CAccelerationData *pVictim = NULL;
        
        // purge the LRU item.
        g_MRUList.RemoveLeastRecent(&pVictim);

        // no changelist update here, as RemoveAndDelete() will call it below.

        g_Counters.IncrementValue32(ACCELERATION_PURGE_RATE, 1);

        RemoveAndDelete(pVictim);

        // re-read the size.
        qwMemoryUsage = GetMemoryUsage();
    }

    if (g_fServerTooBusy && (qwMemoryUsage < g_Config.GetLowWaterDataStorageBytes()))
    {
        // done purging.  we can service requests again.
        g_fServerTooBusy = FALSE;
        XomNtEvent(
            XEVENT_ACCELERATION_INFO_SERVER_RESUME,
            "Done purging items.  Memory usage = %I64d bytes.  Resuming server activity.",
            qwMemoryUsage);
    }

    // return true if we didnt consume all the time thus far.
    BOOL fOkToSleep = (TICK_DIFF(GetTickCount(), dwStart) < g_Config.GetHeartbeatInterval());

// disabling processing of expiries for acceleration.  this kills virtual xblobs, as it consumes a lot of proc when
// the server is idle.  also, we don't intend to use expiries anyway.
#if 0
    // the rest is lower priority maintenance.
    if (fOkToSleep)
    {
        // what time is it?
        SYSTEMTIME st;
        FILETIME ft;
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);

        // process expiries while there's still time left.
        while (TICK_DIFF(GetTickCount(), dwStart) < g_Config.GetHeartbeatInterval())
        {
            g_Counters.IncrementValue32(ACCELERATION_BUCKET_MAINTENANCE_RATE, 1);
            g_AccelerationLookupTable.DoBucketMaintenance(&ft, AccelerationDataMaintenance);
        }
    }
#endif

    return fOkToSleep;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\AccelerationConfig.h ===
#pragma once

#define MAX_DWORD_ARRAY 100

class CAccelerationConfigListener;

class CAccelerationConfig
{
public:

    CAccelerationConfig();
    ~CAccelerationConfig();

    HRESULT Init();
    void Close();

    HRESULT Reload(struct ISettingChangeEventArgs *eventArgs);

    DWORD GetMaxKeyLength() { return m_dwMaxKeyLength; }        
    QWORD GetTotalDataStorageBytes() { return m_qwTotalDataStorageBytes; }        
    QWORD GetLowWaterDataStorageBytes() { return m_qwLowWaterDataStorageBytes; }        
    DWORD GetHeartbeatInterval() { return m_dwHeartbeatInterval; }        
    DWORD GetRecordMaintenangePeriod() { return m_dwRecordMaintenangePeriod; }        
    DWORD GetContextDurationAlertLimit() { return m_dwContextDurationAlertLimit; }        
    DWORD GetNotificationChangelistSize() { return m_dwNotificationChangelistSize; }        
    DWORD GetNumHashtableBuckets() { return m_dwNumHashtableBuckets; }        
    DWORD GetAllocationSizesLength() { return m_dwNumAllocationSizes; }
    DWORD GetAllocationSize(DWORD iIndex) { return m_rgAllocationSizes[iIndex]; }
    DWORD GetAllocationPageSize() { return m_dwAllocationPageSize; }

    WORD GetListenPort();

protected:

    DWORD GetDWORDSetting(CComBSTR bsSetting, CComBSTR bsValue = CComBSTR(NULL));
    QWORD GetQWORDSetting(CComBSTR bsSetting, CComBSTR bsValue = CComBSTR(NULL));
    void GetDWORDArraySetting(CComBSTR Setting, DWORD *pdwLen, DWORD *rgdwVal, CComBSTR bsValue = CComBSTR(NULL));
        
    DWORD m_dwMaxKeyLength;
    QWORD m_qwTotalDataStorageBytes;
    QWORD m_qwLowWaterDataStorageBytes;
    DWORD m_dwHeartbeatInterval;
    DWORD m_dwRecordMaintenangePeriod;
    DWORD m_dwContextDurationAlertLimit;
    DWORD m_dwNotificationChangelistSize;
    DWORD m_dwNumHashtableBuckets;
    DWORD m_dwNumAllocationSizes;
    DWORD m_dwAllocationPageSize;
    DWORD m_rgAllocationSizes[MAX_DWORD_ARRAY];
        
    CComPtr<IConfig> m_pConfig;

    CAccelerationConfigListener *m_pConfigListener;
};

class CAccelerationHealth
{
public:

    CAccelerationHealth();
    ~CAccelerationHealth();

    HRESULT Init(CComBSTR bsComponent);
    void Close();

protected:

    CComPtr<IHealthInterop> m_pHealthInterop;
};


extern CAccelerationHealth g_Health;
extern CAccelerationConfig g_Config;

class CAccelerationConfigListener : public CConfigListenerBase
{

    IMPLEMENT_REFCOUNT_COM
        
public:

    CAccelerationConfigListener()
    { 
    }

    virtual ~CAccelerationConfigListener() 
    {
    }

    STDMETHODIMP QueryInterface( REFIID riid, void** ppObj )
    {
        HRESULT hr;

        if(ppObj == NULL)
            return E_POINTER;

        if(riid == IID_IUnknown)
        {
            *ppObj = (void*)(IUnknown*)this;
            hr = S_OK;
            AddRef();
        }
        else if (riid == _uuidof(IConfigListener))
        {
            *ppObj = (void*)(IConfigListener*)this;
            hr = S_OK;
            AddRef();
        }
        else
            hr = E_NOINTERFACE;

        return hr;
    }    

    virtual HRESULT __stdcall SettingChange (
        /*[in]*/ struct ISettingChangeEventArgs * e );

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\AccelerationData.h ===
#pragma once

extern CAccelerationLookupTable g_AccelerationLookupTable;

class CAccelerationMRUList;

#define ACCELERATION_DATA_SIGNATURE 'AXLD'
#define ACCELERATION_DATA_INCREMENT_SIGNATURE 'XBIV'

class CAccelerationIncrementValue
{
public:

    CAccelerationIncrementValue(QWORD qwValue) :
        m_dwSig(ACCELERATION_DATA_INCREMENT_SIGNATURE),
        m_dValue((double)qwValue)
    {
        SYSTEMTIME st;
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &m_ftLastUpdate);
    }

    BOOL CheckSignature()
    {
        return (m_dwSig == ACCELERATION_DATA_INCREMENT_SIGNATURE);
    }

    QWORD GetValue()
    {
        return (QWORD)m_dValue;
    }

    QWORD ComputeNewValue(QWORD qwIncrementAmount, DWORD dwHalfLifeSeconds);

private:

    DWORD m_dwSig;
    
    double m_dValue;
    
    union
    {
        FILETIME m_ftLastUpdate;
        QWORD m_qwLastUpdate;
    };
};

bool AccelerationCompareBytes(DWORD cb1, BYTE *pb1, DWORD cb2, BYTE *pb2);
DWORD AccelerationHashBytes(DWORD cb, BYTE *pb);

class CAccelerationData :
    public CSingleLink,
    public CFixedSizeMemoryHandle,
    public CAccelerationLookupTableKey,
    public CAccelerationLookupTableValue
{
friend CAccelerationMRUList;
public:

    CAccelerationData();    
    ~CAccelerationData();

    HRESULT Init(
        DWORD cbKey, 
        BYTE *pbKey, 
        DWORD cbData, 
        BYTE *pbData, 
        DWORD dwAbsoluteSeconds, 
        DWORD dwSlidingSeconds,
        FILETIME *pftNow = NULL);

    HRESULT Close();

    // CFixedSizeMemoryHandle
    virtual void OnMemoryMoved(void * pMemory)
    {
        // unused.
        return;
    }

    // CAccelerationLookupTableKey
    virtual DWORD GetHashCode()
    {
        DWORD dwHash = 0;

        LockMemory();

        dwHash = AccelerationHashBytes(GetKeySize(), GetKeyBytes());

        UnlockMemory();
        
        return dwHash;
    }

    // CAccelerationLookupTableKey
    virtual bool Equals(CAccelerationLookupTableKey * pKey)
    {
        bool fRet = false;

        // do this to ensure locks are always taken in the same order.
        CAccelerationData *pCompare1 = MIN(this, (CAccelerationData *)pKey);
        CAccelerationData *pCompare2 = MAX(this, (CAccelerationData *)pKey);

        if ((pCompare1 == NULL) || (pCompare2 == NULL))
        {
            return false;
        }

        pCompare1->LockMemory();
        pCompare2->LockMemory();

        fRet = AccelerationCompareBytes(pCompare1->GetKeySize(), pCompare1->GetKeyBytes(), pCompare2->GetKeySize(), pCompare2->GetKeyBytes());

        pCompare2->UnlockMemory();
        pCompare1->UnlockMemory();
        
        return fRet;
    }

    // CAccelerationLookupTableValue
    virtual CAccelerationLookupTableKey *GetKey()
    {
        return (CAccelerationLookupTableKey *)this;
    }

    // CAccelerationLookupTableValue
    virtual void SetNext(CAccelerationLookupTableValue *pNext)
    {
        m_pNextLookup = (CAccelerationData *)pNext;
    }

    // CAccelerationLookupTableValue
    virtual CAccelerationLookupTableValue *GetNext()
    {
        return (CAccelerationLookupTableValue *)m_pNextLookup;
    }

    // CAccelerationLookupTableValue
    virtual bool DoMaintenance(FILETIME *pftNow);

    DWORD GetKeySize()
    {
        return m_cbKey;
    }

    BYTE *GetKeyBytes()
    {
        XOMASSERT(IsLockedByCurrentThread());
        return (m_cbKey == 0) ? NULL : (BYTE *)GetMemoryPointer();
    }

    DWORD GetDataSize()
    {
        return GetAllocSize() - m_cbKey;
    }

    BYTE *GetDataBytes()
    {
        XOMASSERT(IsLockedByCurrentThread());
        return (GetDataSize() == 0) ? NULL : (BYTE *)GetMemoryPointer() + m_cbKey;
    }

    DWORD GetVersion()
    {
        return m_dwVersion;
    }

    void UpdateVersion(DWORD dwOldVersion)
    {
        m_dwVersion = dwOldVersion + 1;
        // protect against reserved versions.
        if ((m_dwVersion == 0) || (m_dwVersion == ACCELERATION_SET_DATA_VERSION_OVERWRITE))
        {
            m_dwVersion = 1;
        }
    }

    BOOL IsReservation()
    {
        return (GetDataSize() == 0);
    }

    BOOL IsIncrementValue()
    {
        BOOL fRet = FALSE;

        if (GetDataSize() == sizeof(CAccelerationIncrementValue))
        {
            LockMemory();

            fRet = ((CAccelerationIncrementValue *)GetDataBytes())->CheckSignature();

            UnlockMemory();
        }

        return fRet;
    }

    BOOL IsExpired(FILETIME *pftNow)
    {
        if ((m_qwAbsoluteExpiration != 0) && ((*(QWORD *)pftNow >= m_qwAbsoluteExpiration)) ||
            ((m_qwSlidingExpiration != 0) && (*(QWORD *)pftNow >= m_qwSlidingExpiration)))
        {
            g_Counters.IncrementValue32(ACCELERATION_EXPIRE_RATE, 1);
            return TRUE;
        }

        return FALSE;
    }

    DWORD GetRemainingValidSeconds(FILETIME *pftNow);
    void UpdateSlidingExpiration(FILETIME *pftNow);

    void MarkForDeletion();

#ifdef _DEBUG
    enum STATE
    {
        STATE_NEW = 0,
        STATE_CONTAINER_POOL = 1,
        STATE_IN_USE = 2,
        STATE_DELETION_LIST = 3,
        STATE_CLOSED = 4,
    };

    void SetState(STATE state)
    {
        if (m_state != STATE_NEW)
        {
            switch(state)
            {
            case STATE_NEW:
                XOMASSERT( m_state != STATE_NEW );
                break;
    
            case STATE_IN_USE:
                XOMASSERT( (m_state == STATE_NEW) || (m_state == STATE_CONTAINER_POOL) );
                break;
                
            case STATE_CONTAINER_POOL:
                XOMASSERT( m_state == STATE_CLOSED );
                break;
    
            case STATE_DELETION_LIST:
                XOMASSERT( m_state == STATE_IN_USE );
                break;
    
            case STATE_CLOSED:
                XOMASSERT( (m_state == STATE_IN_USE) || (m_state == STATE_DELETION_LIST) );
                break;
            }
        }
        m_stateFrom = m_state;
        m_state = state;
        ZeroMemory(m_stateTrace, sizeof(m_stateTrace));
        CaptureStackBackTrace(1, _countof(m_stateTrace), m_stateTrace, NULL);
    }
#endif
    
protected:

#ifdef _DEBUG
    DWORD m_dwSig;
    STATE m_state;
    STATE m_stateFrom;
    PVOID m_stateTrace[6];
#endif

    DWORD m_cbKey;

    DWORD m_dwSlidingSeconds;
    DWORD m_dwVersion;


    union
    {
        FILETIME m_ftAbsoluteExpiration;
        QWORD m_qwAbsoluteExpiration;
    };
    union
    {
        FILETIME m_ftSlidingExpiration;
        QWORD m_qwSlidingExpiration;
    };

    CAccelerationData *m_pNextLookup;

    CAccelerationData *m_pMoreRecent;
    CAccelerationData *m_pLessRecent;
};

class CAccelerationDataContainerPool
{
public:

    CAccelerationDataContainerPool()
    {
    }

    ~CAccelerationDataContainerPool()
    {
        for (CAccelerationData *pVictim = m_lfsPool.Pop(); pVictim != NULL; pVictim = m_lfsPool.Pop())
        {
            delete pVictim;
        }
    }

    void Insert(CAccelerationData *pData)
    {
        #ifdef _DEBUG
        pData->SetState(CAccelerationData::STATE_CONTAINER_POOL);
        #endif
        
        g_Counters.IncrementValue32(ACCELERATION_CONTAINERPOOL_NUM_FREE, 1);
        m_lfsPool.Push(pData);
    }
    
    CAccelerationData *Obtain()
    {
        CAccelerationData *pData = (CAccelerationData *)m_lfsPool.Pop();
        if (pData == NULL)
        {
            pData = new CAccelerationData();
            if (pData == NULL)
            {
                return NULL;
            }
        }
        else
        {
            g_Counters.DecrementValue32(ACCELERATION_CONTAINERPOOL_NUM_FREE, 1);
        }

        return pData;
    }
    
protected:

    TLFStack<CAccelerationData> m_lfsPool;
};

extern CAccelerationDataContainerPool g_ContainerPool;

class CAccelerationDataDeletionList
{
public:

    CAccelerationDataDeletionList()
    {
    }

    ~CAccelerationDataDeletionList()
    {
        for (CAccelerationData *pVictim = m_lfsPool.Pop(); pVictim != NULL; pVictim = m_lfsPool.Pop())
        {
            delete pVictim;
        }
    }
    
    void AddToList(CAccelerationData *pData)
    {
        g_Counters.IncrementValue32(ACCELERATION_DELETIONLIST_SIZE, 1);
        m_lfsPool.Push(pData);
    }
    
    CAccelerationData * DeleteNextItem()
    {
        CAccelerationData *pVictim = (CAccelerationData *)m_lfsPool.Pop();
        if (pVictim != NULL)
        {
            g_Counters.IncrementValue32(ACCELERATION_DELETIONLIST_DELETE_RATE, 1);
            g_Counters.DecrementValue32(ACCELERATION_DELETIONLIST_SIZE, 1);
        }

        return pVictim;
    }
    
protected:

    TLFStack<CAccelerationData> m_lfsPool;
};

extern CAccelerationDataDeletionList g_DeletionList;

BOOL ManageMemoryPressure(DWORD dwStart);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\dvt\main.cs ===
using System;
using System.Threading;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;


public class AccelerationTestApp
{
    private int _cLargeRequests;
    private int _cSmallRequests;
    private bool _fRunning;
    
    public static bool CompareBytes(byte[] rgb1, byte[] rgb2)
    {
        if (rgb1 == rgb2) return true;

        if ((rgb1 == null) || (rgb2 == null)) return false;

        if (rgb1.Length != rgb2.Length) return false;

        for (int i = 0; i < rgb1.Length; i++)
        {
            if (rgb1[i] != rgb2[i]) return false;
        }

        return true;
    }

    public static void Main()
    {
        RunDVTTest();
        RunOptimisticConcurrencyTest();
//        RunBulkDVTTest();

//        AccelerationTestApp app = new AccelerationTestApp();
//        app.RunStressTest();
    }

    public void RunStressTest()
    {
        Acceleration xb = new Acceleration();
        
        byte[] skey = new byte[] {1,2,3};
        byte[] svalue = new byte[24] ;
        byte[] lkey = new byte[] {1,2,4};
        byte[] lvalue = new byte[1024 * 100] ;
        byte[] output;
        uint hr;

        Console.WriteLine("Setting up value for stress.");
        hr = xb.Remove(skey);
        hr = xb.Query(skey, out output);
        hr = xb.Insert(skey, svalue);
        hr = xb.Remove(lkey);
        hr = xb.Query(lkey, out output);
        hr = xb.Insert(lkey, lvalue);

        _fRunning = true;

        Console.WriteLine("Starting small object threads.");
        for (int iThread = 0; iThread < 100; iThread++)
        {
            Thread thread = new Thread(new ThreadStart(this.StressThreadProc));
            thread.Start();
        }

        Console.WriteLine("Starting large object threads.");
        for (int iThread = 0; iThread < 5; iThread++)
        {
            Thread thread = new Thread(new ThreadStart(this.LargeStressThreadProc));
            thread.Start();
        }

        // wait for worker threads to start.
        Thread.Sleep(5000);

        Console.WriteLine("Counting requests.");
        // reset counter.
        Interlocked.Exchange(ref _cLargeRequests, 0);
        Interlocked.Exchange(ref _cSmallRequests, 0);

        // wait a duration.
        Thread.Sleep(30000);

        // check counter.
        int cSmallRequests = Interlocked.Increment(ref _cSmallRequests);
        int cLargeRequests = Interlocked.Increment(ref _cLargeRequests);

        _fRunning = false;

        Console.WriteLine("Counted " + cLargeRequests +" large requests in 30 seconds.  TPS = " + (cLargeRequests / 30));        
        Console.WriteLine("Counted " + cSmallRequests +" small requests in 30 seconds.  TPS = " + (cSmallRequests / 30));        
    }

    private void StressThreadProc()
    {
        Acceleration xb = new Acceleration();
        byte[] key = new byte[] {1,2,3};
        //byte[] value = new byte[1024 * 100] ;
        byte[] output;

        while (_fRunning)
        {
            uint hr = xb.Query(key, out output);
            //uint hr = xb.SetData(key, value, 0, 0);
            if (hr != HResult.S_OK)
            {
                Console.WriteLine("Query returned hr = 0x" + hr.ToString("X") + ".  Aborting thread.");
                break;
            }
            else
            {
                Interlocked.Increment(ref _cSmallRequests);
            }
        }
    }
    
    private void LargeStressThreadProc()
    {
        Acceleration xb = new Acceleration();
        byte[] key = new byte[] {1,2,4};
        //byte[] value = new byte[1024 * 100] ;
        byte[] output;

        while (_fRunning)
        {
            uint hr = xb.Query(key, out output);
            //uint hr = xb.SetData(key, value, 0, 0);
            if (hr != HResult.S_OK)
            {
                Console.WriteLine("Query returned hr = 0x" + hr.ToString("X") + ".  Aborting thread.");
                break;
            }
            else
            {
                Interlocked.Increment(ref _cLargeRequests);
            }
        }
    }

    public static void OnNotification(byte[][] rgChangedKeys)
    {
        Console.WriteLine("Notification batch (" + rgChangedKeys.Length + " keys) received.");
    }
    
    public static void RunDVTTest()
    {
        Acceleration.RegisterNotificationHandler(OnNotification);
        
        Acceleration xb = new Acceleration();

        byte[] key = new byte[] {1,2,3};
        byte[] value = new byte[] {4,5,6};
        byte[] output;
        ulong result;

        uint hr;
        hr = xb.Remove(key);
        Console.WriteLine("Remove(key) returned 0x" + hr.ToString("X") + (HResult.Succeeded(hr) ? " PASS" : " FAIL"));
        
        hr = xb.Insert(key, value);
        Console.WriteLine("Insert(key, value) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));
        
        hr = xb.Query(key, out output);
        Console.WriteLine("Query(key, out output) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));
        
        hr = xb.Insert(key, value);
        Console.WriteLine("Insert(key, value) returned 0x" + hr.ToString("X") + ((hr == HResult.E_ACCESSDENIED) ? " PASS" : " FAIL"));
        
        hr = xb.Remove(key);
        Console.WriteLine("Remove(key) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));
        
        hr = xb.Query(key, out output);
        Console.WriteLine("Query(key, out output) returned 0x" + hr.ToString("X") + ((hr == HResult.S_FALSE) ? " PASS" : " FAIL"));
        
        hr = xb.Insert(key, value);        
        Console.WriteLine("Insert(key, value) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));

        hr = xb.Remove(key);
        Console.WriteLine("Remove(key) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));
        
        hr = xb.Increment(key, 1, out result);
        Console.WriteLine("Increment(key, 1) returned 0x" + hr.ToString("X") + ((hr == HResult.S_FALSE) ? " PASS" : " FAIL"));

        hr = xb.Increment(key, 1, out result);
        Console.WriteLine("Increment(key, 1) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));

        hr = xb.Increment(key, 1, 1, out result);
        Console.WriteLine("Increment(key, 1, 1) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));

        hr = xb.Remove(key);
        Console.WriteLine("Remove(key) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));

        Thread.Sleep(5000);

        Acceleration.UnregisterHandlers();
    }        

    public static void RunOptimisticConcurrencyTest()
    {
        Acceleration xb = new Acceleration();

        byte[] key = new byte[] {1,2,3};
        byte[] value = new byte[] {4,5,6};
        byte[] output;
        uint version;
        uint validSeconds;

        uint hr;
        hr = xb.Remove(key);
        Console.WriteLine("Remove(key) returned 0x" + hr.ToString("X") + (HResult.Succeeded(hr) ? " PASS" : " FAIL"));

        hr = xb.Query(key, out output, out validSeconds, out version);
        Console.WriteLine("Query(key, out output, out validSeconds, out version) returned 0x" + hr.ToString("X") + ((hr == HResult.S_FALSE) ? " PASS" : " FAIL"));

        hr = xb.SetData(key, value, version);
        Console.WriteLine("SetData(key, value, version) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));
        
        hr = xb.SetData(key, value, version);
        Console.WriteLine("SetData(key, value, version) returned 0x" + hr.ToString("X") + ((hr == HResult.E_ACCESSDENIED) ? " PASS" : " FAIL"));

        hr = xb.SetData(key, value);
        Console.WriteLine("SetData(key, value, version) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));

        hr = xb.Query(key, out output, out validSeconds, out version);
        Console.WriteLine("Query(key, out output, out validSeconds, out version) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));

        hr = xb.SetData(key, value, version);
        Console.WriteLine("SetData(key, value, version) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));
        
        hr = xb.SetData(key, value, version);
        Console.WriteLine("SetData(key, value, version) returned 0x" + hr.ToString("X") + ((hr == HResult.E_ACCESSDENIED) ? " PASS" : " FAIL"));

        hr = xb.SetData(key, value);
        Console.WriteLine("SetData(key, value, version) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));

        hr = xb.Remove(key);
        Console.WriteLine("Remove(key) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));
    }        

    public static bool TestHResults(string testname, uint[] got, uint expected)
    {
        bool retval = true;
        
        if (got == null)
        {
            Console.WriteLine(testname + ": returned null.  FAIL");
            return false;
        }            
        for (uint i = 0; i < got.Length; i++)
        {
            if (got[i] != expected)
            {
                Console.WriteLine(testname + ": index " + i + " mismatch.  got = " + got[i] + ". expected = " + expected + ".  FAIL");
                retval = false;
            }
        }

        if (retval)
        {
            Console.WriteLine(testname + ": PASS");
        }
        return retval;
    }

    public static void RunBulkDVTTest()
    {
        Acceleration xb = new Acceleration();

        byte[][] keys = new byte[][] {new byte[]{1,2,3}, new byte[]{2,3,4}, new byte[]{3,4,5}, new byte[]{4,5,6}, new byte[]{5,6,7}};
        byte[][] values = new byte[][] {new byte[]{4,5,6}, new byte[]{5,6,7}, new byte[]{6,7,8}, new byte[]{7,8,9}, new byte[]{8,9,0}};
        ulong[] amounts = new ulong[] {1,1,1,1,1};
        uint[] zeroes = new uint[]{0,0,0,0,0};
        byte[][] outputs;
        ulong[] results;
        uint[] validSeconds;
        uint[] versions;

        TestHResults("Remove(keys) (OK to fail)", xb.Remove(keys), HResult.S_OK);
        TestHResults("Insert(keys, values)", xb.Insert(keys, values, zeroes, zeroes), HResult.S_FALSE);
        TestHResults("Query(keys, out outputs)", xb.Query(keys, out outputs, out validSeconds, out versions), HResult.S_FALSE);
        TestHResults("Insert(keys, values)", xb.Insert(keys, values, zeroes, zeroes), HResult.S_OK);
        TestHResults("Remove(keys)", xb.Remove(keys), HResult.S_OK);
        TestHResults("Insert(keys, values)", xb.Insert(keys, values, zeroes, zeroes), HResult.S_FALSE);
        TestHResults("Query(keys, out outputs)", xb.Query(keys, out outputs, out validSeconds, out versions), HResult.S_FALSE);
        TestHResults("Insert(keys, values)", xb.Insert(keys, values, zeroes, zeroes), HResult.S_OK);
        TestHResults("Remove(keys)", xb.Remove(keys), HResult.S_OK);

        TestHResults("Increment(keys, amounts, out results)", xb.Increment(keys, amounts, out results), HResult.S_FALSE);
        TestHResults("Increment(keys, amounts, out results)", xb.Increment(keys, amounts, out results), HResult.S_OK);
        TestHResults("Increment(keys, amounts, out results)", xb.Increment(keys, amounts, out results), HResult.S_OK);
    }        

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\AccelerationPerfCtrs.h ===
#pragma once
#include <windows.h>
#include "wmsstd.h"

//////////////////////////////////////////////////////////////////////////////
class CAccelerationPerfCounters
{
public:
    CAccelerationPerfCounters();
    ~CAccelerationPerfCounters();

    HRESULT Init();
    void Close();

    //
    // DWORD counter manipulation routines
    //
    DWORD GetCurrentValue32(DWORD dwCounterID);

    void SetCurrentValue32(DWORD dwCounterID, DWORD dwVal);

    void IncrementValue32(DWORD dwCounterID, DWORD dwAmount);

    void IncrementValue64(DWORD dwCounterID, QWORD qwAmount);

    void DecrementValue32(DWORD dwCounterID, DWORD dwAmount);

    void DecrementValue64(DWORD dwCounterID, QWORD dwAmount);

};

extern CAccelerationPerfCounters g_Counters;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\BufferPool.cpp ===
#include "stdafx.h"

CTCPConnectionVarPoolBuffer * CTCPConnectionVarPoolBuffer::CreateInstance(BufferPool *pPool)
{
    if (pPool == NULL)
    {
        return NULL;
    }
    
    CTCPConnectionVarPoolBuffer *pCRet;

    pCRet = (CTCPConnectionVarPoolBuffer *) XAlloc(POOLBUFFER_DEFAULT_SIZE + sizeof(CTCPConnectionVarPoolBuffer));
    if (pCRet == NULL)
    {
        return NULL;
    }
    else
    {
        pCRet->CTCPConnectionVarPoolBuffer::CTCPConnectionVarPoolBuffer();
        pCRet->m_cbBuffer = POOLBUFFER_DEFAULT_SIZE;
        pCRet->m_pPool = pPool;

        g_Counters.IncrementValue32(ACCELERATION_BUFFERPOOL_NUM_TOTAL, 1);
        g_Counters.IncrementValue32(ACCELERATION_BUFFERPOOL_CREATE_RATE, 1);

        return pCRet;
    }        
}
        
ULONG CTCPConnectionVarPoolBuffer::Release()
{
    // call parent release.
    ULONG refCount = CTCPConnectionVarBuffer::Release();

    // check if anyone other than us still has a handle.
    if (refCount == 1)
    {
        // its just us.  reset the buffer size to what we know it really is, then give it back to the pool.
        m_cbBuffer = POOLBUFFER_DEFAULT_SIZE;
        m_pPool->ReclaimBuffer(this);
    }

    return refCount;
}

BufferPool::BufferPool()
{
    // make some buffers to start.
    for (DWORD iBuffer = 0; iBuffer < BUFFERPOOL_MAX_NUM_BUFFERS; iBuffer++)
    {
        CTCPConnectionVarPoolBuffer *pBuffer = CTCPConnectionVarPoolBuffer::CreateInstance(this);
        if (pBuffer == NULL)
        {
            // stop if there are any NULLs.
            XomNtEvent(XEVENT_ACCELERATION_SERVER_BUFFERPOOL_OUTOFMEMORY, "BufferPool::BufferPool() could not allocate buffer #%d", iBuffer);
            break;
        }

        ReclaimBuffer(pBuffer);
    }
}

BufferPool::~BufferPool()
{
    for (DWORD iBuffer = 0; iBuffer < BUFFERPOOL_MAX_NUM_BUFFERS; iBuffer++)
    {
        CTCPConnectionVarPoolBuffer *pBuffer = m_lfsPool.Pop();
        if (pBuffer != NULL)
        {
            pBuffer->Release();
        }
    }
}

CTCPConnectionVarBuffer *BufferPool::GetBuffer(DWORD dwSize)
{
    CTCPConnectionVarBuffer *pBuffer = NULL;

    if (dwSize > POOLBUFFER_DEFAULT_SIZE)
    {
        // requested size is bigger than the pool buffers.  just bypass the pool.
        g_Counters.IncrementValue32(ACCELERATION_BUFFERPOOL_BYPASS_RATE, 1);

        pBuffer = CTCPConnectionVarBuffer::CreateInstance(dwSize);
        goto lDone;
    }

    pBuffer = m_lfsPool.Pop();
    if (pBuffer == NULL)
    {
        // pool is empty.  make a new buffer!
        pBuffer = CTCPConnectionVarPoolBuffer::CreateInstance(this);
    }
    else
    {
        g_Counters.DecrementValue32(ACCELERATION_BUFFERPOOL_NUM_FREE, 1);
    }

    // add the caller's reference.
    pBuffer->AddRef();

    // size it to the requested nubmer of bytes.
    pBuffer->Resize(dwSize);

lDone:

    return pBuffer;
}

void BufferPool::ReclaimBuffer(CTCPConnectionVarPoolBuffer *pBuffer)
{
    if (pBuffer == NULL)
    {
        goto lDone;
    }

    g_Counters.IncrementValue32(ACCELERATION_BUFFERPOOL_NUM_FREE, 1);
    
    m_lfsPool.Push(pBuffer);

lDone:

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\callback.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once

/*****************************************************************************

CAccelerationControlCallback

Receives requests from the XOM management framework

*****************************************************************************/
extern HANDLE g_hControlCallbackEvent;

class CAccelerationControlCallback : public CXomControlCallback
{
public:

    CAccelerationControlCallback() {}
    ~CAccelerationControlCallback()
    {
        SAFE_CLOSEHANDLE(g_hControlCallbackEvent);
    }

    ULONG __stdcall AddRef () { return 1; }
    ULONG __stdcall Release() { return 1; } 

    void Init()
    {
        g_hControlCallbackEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    }

    virtual HRESULT OnControlRequest(
        LPCSTR pszRequest,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

};

extern CAccelerationControlCallback g_ControlCallback;

#define BYTE_HIGH_BITS(b) (((b) & 0xF0) >> 4)
#define BYTE_LOW_BITS(b) ((b) & 0xF)
#define HEX_DIGIT(n) (((n) <= 9) ? ((n) + '0') : ((n) - 10 + 'A'))
#define DIGIT_BITS(d) ((((d) >= '0') && ((d) <= '9')) ? ((d) - '0') : (((d) >= 'A') && ((d) <= 'F')) ? ((d) - 'A' + 10) : (((d) >= 'a') && ((d) <= 'f')) ? ((d) - 'a' + 10) : 0)

class CAccelerationControlRequestContext : public CLocalContext
{
public:
    CAccelerationControlRequestContext() :
        m_pszRequest(NULL),
        m_dwRequestId(0),
        m_pResponseInterface(NULL),
        m_pKey(NULL),
        m_cbKey(0),
        m_pBuffer(NULL)
    { 
    }

    virtual ~CAccelerationControlRequestContext()
    {
        delete[] m_pKey;
        delete[] m_pBuffer;
    }
     
    void ShowHelp()
    {
        XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, "\r\n\r\nAcceleration Admin Commands:\r\n");
        XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, "  showkeydata <key>: display the value associated with the specified key.\r\n");
        XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, "  removekey <key>: remove the value associated with the specified key.\r\n");
        XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, "\r\nWhen entering keys, readable characters (ASCII 32-126) can be typed,\r\nor any character may be escaped by \"~XX\",\r\nwhere \"XX\" is a two-digit hex ASCII code.\r\n");
    }

    void AdminShowKeyData(LPCSTR pszParams);
    void AdminRemoveKey(LPCSTR pszParams);

    virtual void CompletionProc()
    {        
        if(_strnicmp(m_pszRequest, "help", 4) == 0)
        {
            ShowHelp();
        }
        else if (_strnicmp(m_pszRequest, "removekey", 9) == 0)
        {
            AdminRemoveKey(m_pszRequest + 9);
        }
        else if (_strnicmp(m_pszRequest, "showkeydata", 11) == 0)
        {
            AdminShowKeyData(m_pszRequest + 11);
        }

        SetEvent(g_hControlCallbackEvent);

        Release();
    }

    virtual char* GetDescription() { return "AdminControlRequest"; }

    BYTE *m_pKey;
    WORD m_cbKey;
    LPCSTR m_pszRequest;
    DWORD m_dwRequestId;
    CXomControlResponseInterface* m_pResponseInterface;
    BYTE *m_pBuffer;

    char *EncodeKey(BYTE *pData, DWORD cbData)
    {
        if (cbData > g_Config.GetMaxKeyLength())
        {
            return "";
        }

        if (m_pBuffer == NULL)
        {
            m_pBuffer = new BYTE[g_Config.GetMaxKeyLength() * 3];
            if (m_pBuffer == NULL)
            {
                return "";
            }
        }
        
        BYTE *pWrite = m_pBuffer;
        BYTE *pEnd = pData + cbData;
        while (pData < pEnd)
        {
            if ((*pData >= 32) && (*pData < 126))
            {
                *pWrite = *pData;
                pWrite++;
            }
            else
            {
                *pWrite++ = '~'; // ascii 126
                *pWrite++ = HEX_DIGIT(BYTE_HIGH_BITS(*pData));
                *pWrite++ = HEX_DIGIT(BYTE_LOW_BITS(*pData));
            }
            pData++;
        }

        *pWrite = '\0';

        return (char *)m_pBuffer;
    }

    void DecodeKey(BYTE *pData, WORD cbData)
    {
        XOMASSERT(m_pKey == NULL);

        m_cbKey = 0;

        if (cbData > g_Config.GetMaxKeyLength() * 3)
        {
            return;
        }
        
        m_pKey = new BYTE[g_Config.GetMaxKeyLength()];
        if (m_pKey == NULL)
        {
            return;
        }

        BYTE *pWrite = m_pKey;
        BYTE *pEnd = pData + cbData;
        while (pData < pEnd)
        {
            if ((DWORD)(pWrite - m_pKey) >= g_Config.GetMaxKeyLength())
            {
                break;
            }
            
            if (*pData == '~')
            {
                *pWrite = (DIGIT_BITS(*(pData + 1)) << 4) |DIGIT_BITS(*(pData + 2));
                pData += 3;
            }
            else
            {
                *pWrite = *pData++;
            }
            pWrite++;
        }

        m_cbKey = (WORD)(pWrite - m_pKey);
    }
    
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\BufferPool.h ===
#ifndef BUFFERPOOL_H_INCLUDED
#define BUFFERPOOL_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define POOLBUFFER_DEFAULT_SIZE 2048
#define BUFFERPOOL_INIT_NUM_BUFFERS 1024
#define BUFFERPOOL_MAX_NUM_BUFFERS 16384

class BufferPool;

extern BufferPool *g_pBufferPool;

class CTCPConnectionVarPoolBuffer :
    public CSingleLink,
    public CTCPConnectionVarBuffer
{

friend class BufferPool;
    
public:

    virtual ULONG Release();
    
    virtual BYTE* GetBuffer()
    {
        return (BYTE *)(this + 1);
    }

    void operator delete(void *pv) { XFree(pv); }
    
protected:
    
    static CTCPConnectionVarPoolBuffer * __stdcall CreateInstance(BufferPool *pPool);
    
    void *operator new(size_t len) { return NULL; }

    BufferPool *m_pPool;    
};


// NOTE: BufferPool is NOT threadsafe!  Only use BufferPool from switchboard's thread.
class BufferPool {
    
friend class CTCPConnectionVarPoolBuffer;

public:

    BufferPool();    
    ~BufferPool();

    DWORD GetPoolSize() { return BUFFERPOOL_MAX_NUM_BUFFERS; }
    
    CTCPConnectionVarBuffer *GetBuffer(DWORD dwSize);

protected:
    
    void ReclaimBuffer(CTCPConnectionVarPoolBuffer *pBuffer);

    TLFStack<CTCPConnectionVarPoolBuffer> m_lfsPool;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\Changelist.h ===
#pragma once

struct AccelerationChangelistItem
{
    AccelerationChangelistItem() :
        m_dwChangeID(0),
        m_cbKey(0),
        m_pbKey(NULL)
    {
    }
    
    DWORD m_dwChangeID;
    DWORD m_cbKey;
    BYTE *m_pbKey;
};

class CAccelerationChangelist
{
public:
    
    CAccelerationChangelist();
    ~CAccelerationChangelist();
    
    HRESULT Init(DWORD cdwTotalEntries);
    void Close();

    HRESULT GetSizes(
        DWORD dwInChangeID, 
        DWORD *pdwNewChangeID, 
        DWORD *pdwNumChanges, 
        DWORD *pdwNumKeyBytes);

    HRESULT BuildResponseBuffer(
        DWORD dwInChangeID,
        DWORD cbBuffer,
        BYTE *pBuffer);

    HRESULT RecordChange(CAccelerationData *pData);

    void Lock() { m_lock.WriteLock(); }
    void Unlock() { m_lock.WriteUnlock(); }

protected:

    NYCLock m_lock;

    DWORD m_cTotalEntries;
    DWORD m_dwLastIndex;
    AccelerationChangelistItem *m_rgChanges;
};

extern CAccelerationChangelist g_Changelist;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\LookupTable.cpp ===
#include "stdafx.h"

CAccelerationLookupTable::CAccelerationLookupTable()
{
    m_cdwBuckets = 0;
    m_rgBuckets = NULL;
    m_rgBucketLocks = NULL;
    m_iMaintenanceBucket = 0;
}

CAccelerationLookupTable::~CAccelerationLookupTable()
{
    Close();
}

HRESULT CAccelerationLookupTable::Init(DWORD cdwBuckets)
{
    HRESULT hr = S_OK;

    // parameter checks
    if (cdwBuckets <= 0)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // make the bucket pointers.
    m_rgBuckets = new CAccelerationLookupTableValue*[cdwBuckets];
    if (m_rgBuckets == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // set all the pointers to NULL.
    ZeroMemory(m_rgBuckets, cdwBuckets * sizeof(CAccelerationLookupTableValue *));

    // make all the bucket locks.
    m_rgBucketLocks = new NYCLock[cdwBuckets];
    if (m_rgBucketLocks == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    m_cdwBuckets = cdwBuckets;

lDone:

    if (FAILED(hr))
    {
        // clean up anything we did before failing.
        Close();
    }

    return hr;        
}

HRESULT CAccelerationLookupTable::Close()
{
    // object pointers should be allocated by an instance of CAccelerationMemoryManager, and thus deleted there.

    // delete the buckets.
    delete[] m_rgBuckets;
    delete[] m_rgBucketLocks;
    
    // zero out everything else.
    m_cdwBuckets = 0;
    m_rgBuckets = NULL;
    m_rgBucketLocks = NULL;

    return S_OK;
}

HRESULT CAccelerationLookupTable::LockBucketByKey(CAccelerationLookupTableKey *pKey, DWORD *pdwLockToken)
{
    HRESULT hr = S_OK;
    DWORD dwHash = InvalidHashValue;
    NYCLock *pLock = NULL;

    if ((pdwLockToken == NULL) ||
        (pKey == NULL))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // use the key to get the hash value.
    dwHash = pKey->GetHashCode() % m_cdwBuckets;

    // lock the bucket.
    pLock = &(m_rgBucketLocks[dwHash]);
    pLock->WriteLock();

    g_Counters.IncrementValue32(ACCELERATION_LOOKUPTABLE_LOCK_RATE, 1);

    *pdwLockToken = dwHash;
    
lDone:

    return hr;
}

HRESULT CAccelerationLookupTable::GetHeldLockToken(CAccelerationLookupTableKey *pKey, DWORD *pdwLockToken)
{
    HRESULT hr = S_OK;
    DWORD dwHash = InvalidHashValue;
    NYCLock *pLock = NULL;

    if (pKey == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // use the key to get the hash value.
    dwHash = pKey->GetHashCode() % m_cdwBuckets;

    // get the lock.
    pLock = &(m_rgBucketLocks[dwHash]);

    if (!pLock->IsLockedByCurrentThread())
    {
        // no lock; no token.
        hr = S_FALSE;
    }
    else if (pdwLockToken != NULL)
    {
        // we have the lock, return the token.
        *pdwLockToken = dwHash;
    }
    
lDone:

    return hr;
}

HRESULT CAccelerationLookupTable::UnlockBucket(DWORD dwLockToken)
{
    HRESULT hr = S_OK;
    NYCLock *pLock = NULL;

    if (dwLockToken >= m_cdwBuckets)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // unlock the bucket.
    pLock = &(m_rgBucketLocks[dwLockToken]);

    XOMASSERT(pLock->IsLockedByCurrentThread());
    
    pLock->WriteUnlock();

lDone:

    return hr;
}

HRESULT CAccelerationLookupTable::AddLookupEntry(DWORD dwLockToken, CAccelerationLookupTableValue *pObject)
{
    HRESULT hr = S_OK;
    DWORD dwHash = dwLockToken;

    if (dwLockToken >= m_cdwBuckets)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    if (pObject == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }


#ifdef _DEBUG
{
    CAccelerationLookupTableKey *pKey = pObject->GetKey();
    CAccelerationLookupTableValue *pBucket = m_rgBuckets[dwHash];
    
    while (pBucket != NULL)
    {
        // check for duplicate key.  this shouldnt happen, as find and remove should be called before add.
        if (pKey->Equals(pBucket->GetKey()))
        {
            XOMASSERT(FALSE);
            hr = E_UNEXPECTED;
            goto lDone;
        }

        pBucket = pBucket->GetNext();
    }
}
#endif    

    // link this object into the chain for this bucket.
    pObject->SetNext(m_rgBuckets[dwHash]);
    m_rgBuckets[dwHash] = pObject;    

    g_Counters.IncrementValue32(ACCELERATION_LOOKUPTABLE_ADD_RATE, 1);

lDone:

    return hr;
}

HRESULT CAccelerationLookupTable::FindLookupEntry(DWORD dwLockToken, CAccelerationLookupTableKey *pKey, CAccelerationLookupTableValue **ppObject)
{
    HRESULT hr = S_OK;
    DWORD dwHash = dwLockToken;
    CAccelerationLookupTableValue *pBucket = NULL;

    if (dwLockToken >= m_cdwBuckets)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    if ((ppObject == NULL) ||
        (pKey == NULL))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    g_Counters.IncrementValue32(ACCELERATION_LOOKUPTABLE_FIND_RATE, 1);
    
    // clear the return value.
    *ppObject = NULL;

    pBucket = m_rgBuckets[dwHash];
    while (pBucket != NULL)
    {
        if (pKey->Equals(pBucket->GetKey()))
        {
            // found it!
            *ppObject = pBucket;
            goto lDone;
        }

        pBucket = pBucket->GetNext();
    }

    // didnt find the value.
    hr = S_FALSE;

lDone:

    return hr;
}

HRESULT CAccelerationLookupTable::RemoveLookupEntry(DWORD dwLockToken, CAccelerationLookupTableValue *pObject)
{
    HRESULT hr = S_OK;
    DWORD dwHash = dwLockToken;
    CAccelerationLookupTableValue *pBucket = NULL;

    if (dwLockToken >= m_cdwBuckets)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    if (pObject == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    g_Counters.IncrementValue32(ACCELERATION_LOOKUPTABLE_REMOVE_RATE, 1);

    pBucket = m_rgBuckets[dwHash];
    
    if (pBucket != NULL)
    {
        if (pObject == pBucket)
        {
            // head pointer is the match.  just advance the head pointer.
            m_rgBuckets[dwHash] = pBucket->GetNext();
            goto lDone;
        }
        else
        {
            // start with the next pointer.
            while (pBucket->GetNext() != NULL)
            {
                if (pObject == pBucket->GetNext())
                {
                    // found the target to delete.  un-link it from the list.
                    pBucket->SetNext(pBucket->GetNext()->GetNext());
                    goto lDone;
                }

                pBucket = pBucket->GetNext();
            }
        }
    }

    // didnt find the value.
    hr = S_FALSE;

lDone:

    return hr;
}


// this function is not threadsafe against itself.  only call it on one thread!
void CAccelerationLookupTable::DoBucketMaintenance(FILETIME *pftNow)
{
    m_rgBucketLocks[m_iMaintenanceBucket].WriteLock();

    // check the head pointer first.
    while (m_rgBuckets[m_iMaintenanceBucket] != NULL)
    {
        // the current value of the victim's next pointer
        CAccelerationLookupTableValue *pVictimNext = m_rgBuckets[m_iMaintenanceBucket]->GetNext();

        // pfnMaintenance will modify the victim's next pointer if it returns true.
        if (m_rgBuckets[m_iMaintenanceBucket]->DoMaintenance(pftNow))
        {
            // advance the head pointer to the next object obtained before the call to maintenance.
            m_rgBuckets[m_iMaintenanceBucket] = pVictimNext;
        }
        else
        {
            // the head of the bucket now points to something that isnt expired, or NULL.
            break;
        }
    }
    
    if (m_rgBuckets[m_iMaintenanceBucket] != NULL)
    {
        CAccelerationLookupTableValue *pBucket = m_rgBuckets[m_iMaintenanceBucket];
        // start with the next pointer.
        CAccelerationLookupTableValue *pVictim = pBucket->GetNext();
        while (pVictim != NULL)
        {
            // the current value of the victim's next pointer
            CAccelerationLookupTableValue *pVictimNext = pVictim->GetNext();

            // pfnMaintenance will modify the victim's next pointer if it returns true.
            if (pVictim->DoMaintenance(pftNow))
            {
                // found a target to delete.  un-link it from the list.  
                // we use the value of the victim's next pointer that we obtained before the maintenance call.
                pBucket->SetNext(pVictimNext);
            }
            else
            {
                // move on.  we arent removing this victim, so it becomes the parent of the next potential victim.
                pBucket = pVictim;
                pVictim = pVictimNext;
            }
        }
    }
    
    m_rgBucketLocks[m_iMaintenanceBucket].WriteUnlock();

    m_iMaintenanceBucket = (m_iMaintenanceBucket + 1) % m_cdwBuckets;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\Changelist.cpp ===
#include "stdafx.h"

CAccelerationChangelist::CAccelerationChangelist() :
    m_cTotalEntries(0),
    m_dwLastIndex(0),
    m_rgChanges(NULL)
{
}

CAccelerationChangelist::~CAccelerationChangelist()
{
    Close();
}

HRESULT CAccelerationChangelist::Init(DWORD cdwTotalEntries)
{
    m_lock.WriteLock();
    
    HRESULT hr = S_OK;
    
    Close();

    m_rgChanges = new AccelerationChangelistItem[cdwTotalEntries];
    if (m_rgChanges == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    m_cTotalEntries = cdwTotalEntries;

    for (DWORD iChange = 0; iChange < m_cTotalEntries; iChange++)
    {
        m_rgChanges[iChange].m_dwChangeID = (DWORD)(-1);
        m_rgChanges[iChange].m_pbKey = new BYTE[g_Config.GetMaxKeyLength()];
        if (m_rgChanges[iChange].m_pbKey == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }
    }

lDone:

    if (FAILED(hr))
    {
        Close();
    }

    m_lock.WriteUnlock();
    
    return hr;
}

void CAccelerationChangelist::Close()
{
    m_lock.WriteLock();

    for (DWORD iChange = 0; iChange < m_cTotalEntries; iChange++)
    {
        SAFE_ARRAYDELETE(m_rgChanges[iChange].m_pbKey);
    }
    
    SAFE_ARRAYDELETE(m_rgChanges);
    m_cTotalEntries = 0;
    m_dwLastIndex = 0;

    m_lock.WriteUnlock();
}

HRESULT CAccelerationChangelist::GetSizes(
    DWORD dwInChangeID, 
    DWORD *pdwNewChangeID, 
    DWORD *pdwNumChanges, 
    DWORD *pdwNumKeyBytes)
{
    m_lock.WriteLock();
    
    HRESULT hr = S_OK;

    if ((pdwNewChangeID == NULL) || (pdwNumChanges == NULL) || (pdwNumKeyBytes == NULL))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    *pdwNewChangeID = m_rgChanges[m_dwLastIndex].m_dwChangeID;
    *pdwNumChanges = 0;
    *pdwNumKeyBytes = 0;

    if (dwInChangeID == 0)
    {
        // this is what the proxy will pass on startup.  just send back the current change id, and no list.
        goto lDone;
    }

    DWORD dwIndex = m_dwLastIndex;
    while ((m_rgChanges[dwIndex].m_dwChangeID != dwInChangeID)
        && (m_rgChanges[dwIndex].m_cbKey > 0))
    {
        (*pdwNumChanges)++;
        (*pdwNumKeyBytes) += m_rgChanges[dwIndex].m_cbKey;

        if (dwIndex == 0)
        {
            dwIndex = m_cTotalEntries;
        }
        dwIndex--;
        

        if (dwIndex == m_dwLastIndex)
        {
            // cycled the changelist.  we've dropped notifications since this caller last synced.
            hr = S_FALSE;
            break;
        }
    }
    
lDone:

    m_lock.WriteUnlock();

    return hr;
}

HRESULT CAccelerationChangelist::BuildResponseBuffer(
    DWORD dwInChangeID, 
    DWORD cbBuffer, 
    BYTE *pBuffer)
{
    m_lock.WriteLock();
    
    HRESULT hr = S_OK;

    if (pBuffer == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    BYTE *pbWrite = pBuffer;

    DWORD dwIndex = m_dwLastIndex;
    while ((m_rgChanges[dwIndex].m_dwChangeID != dwInChangeID)
        && (m_rgChanges[dwIndex].m_cbKey > 0))
    {
        if (cbBuffer < (sizeof(ACCELERATION_CHANGELIST_ITEM) + m_rgChanges[dwIndex].m_cbKey))
        {
            // buffer was too small to continue.  we've dropped the notifications beyond this point.
            hr = S_FALSE;
            break;
        }

        ACCELERATION_CHANGELIST_ITEM *pItem = (ACCELERATION_CHANGELIST_ITEM *)pbWrite;
        pItem->cbKey = m_rgChanges[dwIndex].m_cbKey;

        pbWrite += sizeof(ACCELERATION_CHANGELIST_ITEM);
        cbBuffer -= sizeof(ACCELERATION_CHANGELIST_ITEM);
        
        memcpy(pbWrite, m_rgChanges[dwIndex].m_pbKey, pItem->cbKey);

        pbWrite += pItem->cbKey;
        cbBuffer -= pItem->cbKey;

        if (dwIndex == 0)
        {
            dwIndex = m_cTotalEntries;
        }
        dwIndex--;

        if (dwIndex == m_dwLastIndex)
        {
            // cycled the changelist.  we've dropped notifications since this caller last synced.
            hr = S_FALSE;
            break;
        }
    }

lDone:

    m_lock.WriteUnlock();

    return hr;
}

HRESULT CAccelerationChangelist::RecordChange(CAccelerationData *pData)
{
    m_lock.WriteLock();

    HRESULT hr = S_OK;

    if (pData == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // grab the last change id.
    DWORD dwNextChangeID = m_rgChanges[m_dwLastIndex].m_dwChangeID + 1;
    if (dwNextChangeID == 0)
    {
        // dont use zero.
        dwNextChangeID = 1;
    }

    // increment the index.
    m_dwLastIndex++;
    m_dwLastIndex %= m_cTotalEntries;

    // write the new change.
    m_rgChanges[m_dwLastIndex].m_dwChangeID = dwNextChangeID;

    pData->LockMemory();

    m_rgChanges[m_dwLastIndex].m_cbKey = pData->GetKeySize();
    memcpy(m_rgChanges[m_dwLastIndex].m_pbKey, pData->GetKeyBytes(), pData->GetKeySize());    

    pData->UnlockMemory();

    g_Counters.IncrementValue32(ACCELERATION_CHANGELIST_CHANGE_RATE, 1);

lDone:

    m_lock.WriteUnlock();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\callback.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

HANDLE g_hControlCallbackEvent = NULL;

HRESULT CAccelerationControlCallback::OnControlRequest(
    LPCSTR pszRequest,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface )
{
    HRESULT hr = S_OK;
    CAccelerationControlRequestContext *pCCtx = NULL;
    
    if (WAIT_OBJECT_0 != WaitForSingleObject(g_hControlCallbackEvent, 0))
    {
        pResponseInterface->WriteResponse(dwRequestId, (BYTE*)"FAILURE: another request is in progress.\r\n", (DWORD) -1);
        hr = E_FAIL;
        goto lDone;
    }
    
    ResetEvent(g_hControlCallbackEvent);

    pCCtx = new CAccelerationControlRequestContext();
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pCCtx->m_pszRequest = pszRequest;
    pCCtx->m_dwRequestId = dwRequestId;
    pCCtx->m_pResponseInterface = pResponseInterface;

    hr = g_Switchboard.PostCompletion(pCCtx);

    WaitForSingleObject(g_hControlCallbackEvent, INFINITE);

lDone:

    return hr;
}

void CAccelerationControlRequestContext::AdminRemoveKey(LPCSTR pszParams)
{
    if (pszParams == NULL)
    {
        return;
    }

    HRESULT hr = S_OK;

    // find the start of the key.
    BYTE *pbKey = NULL;
    WORD cbKey = 0;
    while (*pszParams == ' ')
    {
        pszParams++;
    }
    pbKey = (BYTE *)pszParams;

    // find the end of the key.
    while (*pszParams != '\0')
    {
        pszParams++;
        cbKey++;
    }

    DecodeKey(pbKey, cbKey);

    // make a key object
    CAccelerationData *pKey = g_ContainerPool.Obtain();
    if (pKey == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    hr = pKey->Init(m_cbKey, m_pKey, 0, NULL, 0, 0);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // lock the table bucket for this key.
    DWORD dwLockToken = CAccelerationLookupTable::InvalidHashValue;
    g_AccelerationLookupTable.LockBucketByKey(pKey->GetKey(), &dwLockToken);

    // let's see what exists at the given key...
    CAccelerationData *pData = NULL;
    CAccelerationLookupTableValue *pLookupValue = NULL;
    hr = g_AccelerationLookupTable.FindLookupEntry(dwLockToken, pKey->GetKey(), &pLookupValue);
    XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, "FindLookupEntry() returned hr = 0x%X\r\n", hr);
    if (FAILED(hr))
    {
        // something wrong with either the key or the table.  this is bad.
        goto lDone;
    }

    pData = (CAccelerationData *)pLookupValue;

    // was it there?
    if (hr == S_OK)
    {
        // remove it.
        g_AccelerationLookupTable.RemoveLookupEntry(dwLockToken, pData);
        g_MRUList.RemoveItem(pData);

        // record the change in the changelist.
        g_Changelist.RecordChange(pData);

        pData->MarkForDeletion();
        
        XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, "Key removed.\r\n");
    }

    g_AccelerationLookupTable.UnlockBucket(dwLockToken);

lDone:

    if (pKey != NULL)
    {
        pKey->MarkForDeletion();
    }
    
}

void CAccelerationControlRequestContext::AdminShowKeyData(LPCSTR pszParams)
{
    if (pszParams == NULL)
    {
        return;
    }

    HRESULT hr = S_OK;

    // find the start of the key.
    BYTE *pbKey = NULL;
    WORD cbKey = 0;
    while (*pszParams == ' ')
    {
        pszParams++;
    }
    pbKey = (BYTE *)pszParams;

    // find the end of the key.
    while (*pszParams != '\0')
    {
        pszParams++;
        cbKey++;
    }

    DecodeKey(pbKey, cbKey);

    // make a key object
    CAccelerationData *pKey = g_ContainerPool.Obtain();
    if (pKey == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    hr = pKey->Init(m_cbKey, m_pKey, 0, NULL, 0, 0);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // lock the table bucket for this key.
    DWORD dwLockToken = CAccelerationLookupTable::InvalidHashValue;
    g_AccelerationLookupTable.LockBucketByKey(pKey->GetKey(), &dwLockToken);

    // let's see what exists at the given key...
    CAccelerationData *pData = NULL;
    CAccelerationLookupTableValue *pLookupValue = NULL;
    hr = g_AccelerationLookupTable.FindLookupEntry(dwLockToken, pKey->GetKey(), &pLookupValue);
    XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, "FindLookupEntry() returned hr = 0x%X\r\n", hr);
    if (FAILED(hr))
    {
        // something wrong with either the key or the table.  this is bad.
        goto lDone;
    }

    pData = (CAccelerationData *)pLookupValue;

    // now pNode points to the specified key.
    if (pData != NULL)
    {
        pData->LockMemory();
        
        if (pData->IsIncrementValue())
        {
            CAccelerationIncrementValue *pIncrement = (CAccelerationIncrementValue *)pData->GetDataBytes();
            XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, "Data is an increment value.  Value = %I64d.\r\n", pIncrement->GetValue());
        }
        else if (pData->IsReservation())
        {
            XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, "Data is a reservation.\r\n");
        }
        else
        {
            DWORD dwSize = pData->GetDataSize();
            BYTE *pBytes = pData->GetDataBytes();
            while (dwSize > 0)
            {
                for (DWORD iByte = 0; iByte < 16; iByte++)
                {
                    if (iByte == 8)
                    {
                        XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, "   ");
                    }
                    XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, " %c%c", 
                        (iByte >= dwSize) ? ' ' : HEX_DIGIT(BYTE_HIGH_BITS(pBytes[iByte])), 
                        (iByte >= dwSize) ? ' ' : HEX_DIGIT(BYTE_LOW_BITS(pBytes[iByte])));
                }

                XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, "  ||  ");

                for (DWORD iByte = 0; iByte < 16; iByte++)
                {
                    if (iByte == 8)
                    {
                        XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, "  ");
                    }
                    if (iByte < dwSize)
                    {
                        XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, "%c", 
                            ((pBytes[iByte] >= 32) && (pBytes[iByte] < 126)) ? pBytes[iByte] : '.');
                    }
                }

                XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, "\r\n");

                if (dwSize < 16)
                {
                    break;
                }

                pBytes += 16;
                dwSize -= 16;
            }
        }
        
        XomWriteFormattedResponse(m_pResponseInterface, m_dwRequestId, "Data version = %d.\r\n", pData->GetVersion());

        pData->UnlockMemory();
    }

    g_AccelerationLookupTable.UnlockBucket(dwLockToken);

lDone:

    if (pKey != NULL)
    {
        pKey->MarkForDeletion();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\LookupTable.h ===
#pragma once

class CAccelerationLookupTableKey
{
public:
    virtual DWORD GetHashCode() = 0;
    virtual bool Equals(CAccelerationLookupTableKey *pKey) = 0;   
};

class CAccelerationLookupTableValue
{
public:
    virtual CAccelerationLookupTableKey *GetKey() = 0;
    virtual void SetNext(CAccelerationLookupTableValue *pNext) = 0;
    virtual CAccelerationLookupTableValue *GetNext() = 0;
    virtual bool DoMaintenance(FILETIME *pftNow) = 0;
};

class CAccelerationLookupTable
{
public:

    static const DWORD InvalidHashValue = 0xFFFFFFFF;

    // constructor
    CAccelerationLookupTable();

    // destructor
    ~CAccelerationLookupTable();
    
    // initializer takes a number of buckets, and the function pointers needed to perform inserts and lookups.
    HRESULT Init(DWORD cdwBuckets);
    
    // close down everything.
    HRESULT Close();

    HRESULT LockBucketByKey(CAccelerationLookupTableKey *pKey, DWORD *pdwLockToken);

    HRESULT GetHeldLockToken(CAccelerationLookupTableKey *pKey, DWORD *pdwLockToken);
    
    HRESULT UnlockBucket(DWORD dwLockToken);

    // insert this object into the lookup table.
    HRESULT AddLookupEntry(DWORD dwLockToken, CAccelerationLookupTableValue *pObject);

    // find an object given its key.
    HRESULT FindLookupEntry(DWORD dwLockToken, CAccelerationLookupTableKey *pKey, CAccelerationLookupTableValue **ppObject);

    // remove this object from the lookup table.
    HRESULT RemoveLookupEntry(DWORD dwLockToken, CAccelerationLookupTableValue *pObject);

    DWORD GetNumBuckets() { return m_cdwBuckets; }

    // this function is not threadsafe against itself.  only call it on one thread!
    void DoBucketMaintenance(FILETIME *pftNow);

protected:

    DWORD m_cdwBuckets;
    CAccelerationLookupTableValue **m_rgBuckets;
    NYCLock *m_rgBucketLocks;
    DWORD m_iMaintenanceBucket;
    
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\memmgr.cpp ===
#include <stdafx.h>

#define ObjectHeader CFixedSizeMemoryAllocator::CFixedSizeObjectHeader

// qsort helper
static int __cdecl CompareInt( const void *pLeft, const void *pRight )
{
    return *(int*)pLeft - *(int*)pRight;
}

#define HEADER_ALIGN_SHIFT (MEMORY_ALLOCATION_ALIGNMENT - (sizeof(CFixedSizeMemoryAllocator::CFixedSizeObjectHeader) % MEMORY_ALLOCATION_ALIGNMENT))

CFixedSizeMemoryAllocator::CFixedSizeMemoryAllocator()
{
    m_dwObjectSize = 0;
    m_dwActualPageSize = 0;
    m_dwTargetObjectSize = 0;

    m_pPageCurrent = NULL;

    m_dwPerfCounterPerObject = 0xFFFFFFFF;
    m_dwPerfCounterPerPage = 0xFFFFFFFF;
}

CFixedSizeMemoryAllocator::~CFixedSizeMemoryAllocator()
{
    Close();
}

HRESULT CFixedSizeMemoryAllocator::Init(
    HANDLE pHeap,
    DWORD dwObjectSize, 
    DWORD dwPerfCounterPerObject, 
    DWORD dwPerfCounterPerPage)
{
    HRESULT hr = S_OK;

    m_lock.WriteLock();

    // make sure we aren't already initialized.
    if (m_dwObjectSize != 0)
    {
        hr = E_UNEXPECTED;
        goto lDone;
    }

    DWORD dwTargetPageSize = g_Config.GetAllocationPageSize();

    // object size has to be within the page size.
    if (dwObjectSize > dwTargetPageSize)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    m_pHeap = pHeap;

    m_dwTargetObjectSize = dwObjectSize;

    // add space for a header on each object.
    dwObjectSize += sizeof(CFixedSizeObjectHeader);

    // align the object size
    dwObjectSize = _ALIGN(dwObjectSize, MEMORY_ALLOCATION_ALIGNMENT);

    m_dwObjectSize = dwObjectSize;
    m_dwPerfCounterPerObject = dwPerfCounterPerObject;
    m_dwPerfCounterPerPage = dwPerfCounterPerPage;

    // trim actual page size to be a multiple of object size.
    m_dwActualPageSize = dwTargetPageSize - (dwTargetPageSize % m_dwObjectSize);

    // add padding to offset the allocations for proper alignment.
    m_dwActualPageSize += HEADER_ALIGN_SHIFT;

    // page 1.  in the beginning...
    hr = AllocNewPage();
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:

    if (FAILED(hr))
    {
        // clean up anything we managed to do before failing.
        Close();
    }

    m_lock.WriteUnlock();
    
    return hr;
}

HRESULT CFixedSizeMemoryAllocator::Close()
{
    // delete all pages.
    // note: this deletes all memory owned by the manager, even if it is allocated to a client!

    m_lock.WriteLock();

    if (m_pPageCurrent != NULL)
    {
        // delete pages prior to the current.
        CFixedSizeMemoryPage *pPage = m_pPageCurrent->m_pPrev;
        while (pPage != NULL)
        {
            CFixedSizeMemoryPage *pVictim = pPage;
            pPage = pPage->m_pPrev;
            delete[] pVictim->m_pMemory;
            delete pVictim;            
        }

        // delete current and after.
        while (m_pPageCurrent != NULL)
        {
            CFixedSizeMemoryPage *pVictim = m_pPageCurrent;
            m_pPageCurrent = m_pPageCurrent->m_pNext;
            delete[] pVictim->m_pMemory;
            delete pVictim;
        }
    }
    
    m_dwObjectSize = 0;
    m_dwActualPageSize = 0;
    m_dwTargetObjectSize = 0;
    m_pPageCurrent = NULL;
    m_pHeap = NULL;

    m_lock.WriteUnlock();

    return S_OK;
}

HRESULT CFixedSizeMemoryAllocator::AllocNewPage()
{
    m_lock.WriteLock();
    
    // we shouldnt be allocating a new page if there exists a page with space on it.
    XOMASSERT((m_pPageCurrent == NULL) || ((m_pPageCurrent->m_pNext == NULL) && (m_pPageCurrent->m_dwObjects == (m_dwActualPageSize / m_dwObjectSize))));
    
    HRESULT hr = S_OK;

    // get a page node.
    CFixedSizeMemoryPage *pNewPage = new CFixedSizeMemoryPage();
    if (pNewPage == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // mark this page as ours.
    pNewPage->m_pAllocator = this;

    // get a memory block to serve as a page.
    pNewPage->m_pMemory = (BYTE *)HeapAlloc(m_pHeap, 0, m_dwActualPageSize);
    if (pNewPage->m_pMemory == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // add this page to the linked list.
    if (m_pPageCurrent != NULL) m_pPageCurrent->m_pNext = pNewPage;
    pNewPage->m_pUnused = pNewPage->m_pMemory;
    pNewPage->m_dwObjects = 0;
    pNewPage->m_pNext = NULL;
    pNewPage->m_pPrev = m_pPageCurrent;
    m_pPageCurrent = pNewPage;

    // shift allocations for proper alignment.
    pNewPage->m_pUnused += HEADER_ALIGN_SHIFT;

    // if we have a counter for pages, increment it.
    if (m_dwPerfCounterPerPage != 0xFFFFFFFF)
    {
        g_Counters.IncrementValue32(m_dwPerfCounterPerPage, 1);
    }

lDone:

    if (FAILED(hr))
    {
        // delete anything we allocated before failing.
        if (pNewPage != NULL)
        {
            delete[] pNewPage->m_pMemory;
            delete pNewPage;
        }
    }

    m_lock.WriteUnlock();

    return hr;
}

HRESULT CFixedSizeMemoryAllocator::DeletePage(CFixedSizeMemoryPage *pVictim)
{
    m_lock.WriteLock();

    HRESULT hr = S_OK;

    XOMASSERT(pVictim != NULL);
    XOMASSERT(pVictim->m_pNext == NULL);
    XOMASSERT(pVictim->m_dwObjects == 0);

    // check to see if this is the first available page.
    if (m_pPageCurrent == pVictim)
    {
        // we dont delete this page, as it's the only place left to allocate new items.
        hr = S_FALSE;
        goto lDone;
    }    

    // unlink this page.
    if (pVictim->m_pPrev)
    {
        pVictim->m_pPrev->m_pNext = NULL;
    }

    // delete the memory.
    HeapFree(m_pHeap, 0, pVictim->m_pMemory);

    // delete the page.
    delete pVictim;
    
    // if we have a counter for pages, decrement it.
    if (m_dwPerfCounterPerPage != 0xFFFFFFFF)
    {
        g_Counters.DecrementValue32(m_dwPerfCounterPerPage, 1);
    }

lDone:

    m_lock.WriteUnlock();

    return hr;
}

HRESULT CFixedSizeMemoryAllocator::GetObjectMemory(CFixedSizeMemoryHandle *pHandle)
{
    m_lock.WriteLock();

    HRESULT hr = S_OK;

    // where were you planning to put that object pointer?
    if (pHandle == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // is this page full?
    if (m_pPageCurrent->m_dwObjects == (m_dwActualPageSize / m_dwObjectSize))
    {
        // no space on this page?  we must be totally full.
        XOMASSERT(m_pPageCurrent->m_pNext == NULL);

        // make a new page.
        hr = AllocNewPage();
        if (FAILED(hr))
        {
            goto lDone;
        }        
    }

    // if there were no holes on this page, then there should be free space available.
    XOMASSERT((DWORD)(m_pPageCurrent->m_pUnused - m_pPageCurrent->m_pMemory) <= (m_dwActualPageSize - m_dwObjectSize));

    // grant this memory to the caller.
    CFixedSizeObjectHeader *pHeader = (CFixedSizeObjectHeader *)m_pPageCurrent->m_pUnused;
    m_pPageCurrent->m_pUnused += m_dwObjectSize;

#ifdef _DEBUG
    pHeader->m_dwSig = m_dwGuardWord;
#endif

    pHandle->LockMemory();

    pHeader->m_pPage = m_pPageCurrent;
    pHeader->m_pHandle = pHandle;
    pHandle->m_pHeader = pHeader;
    pHandle->OnMemoryMoved(pHeader + 1);
    m_pPageCurrent->m_dwObjects++;

    pHandle->UnlockMemory();

    // update the page list.
    if (m_pPageCurrent->m_dwObjects == (m_dwActualPageSize / m_dwObjectSize))
    {
        // no more room on this page.
        if (m_pPageCurrent->m_pNext != NULL)
        {
            // move to the next page.
            m_pPageCurrent = m_pPageCurrent->m_pNext;
        }
        // else we stay full and wait for the next allocation.
    }

    // if we have a perf counter for objects, increment it.
    if (m_dwPerfCounterPerObject != 0xFFFFFFFF)
    {
        g_Counters.IncrementValue64(m_dwPerfCounterPerObject, 1);
    }

lDone:

    m_lock.WriteUnlock();

    return hr;
}

HRESULT CFixedSizeMemoryAllocator::ReleaseObject(CFixedSizeMemoryHandle *pHandle)
{
    m_lock.WriteLock();

    HRESULT hr = S_OK;

    if (pHandle == NULL)
    {
        // non fatal
        hr = S_FALSE;
        goto lDone;
    }

    // lock the handle being deleted.
    pHandle->LockMemory();

    XOMASSERT(pHandle->m_pHeader->m_pPage != NULL);
    XOMASSERT(pHandle->m_pHeader->m_pHandle == pHandle);

    CFixedSizeMemoryPage *pPage = pHandle->m_pHeader->m_pPage;

#ifdef _DEBUG
    // is this spot already released?
    XOMASSERT(pHandle->m_pHeader->m_dwSig == m_dwGuardWord);
#endif

    // find the object that we will move overtop of the freed spot.
    CFixedSizeObjectHeader *pRelocate = (CFixedSizeObjectHeader *)(m_pPageCurrent->m_pUnused - m_dwObjectSize);
    if ((BYTE *)pRelocate < m_pPageCurrent->m_pMemory)
    {
        // current page was empty.
        XOMASSERT(m_pPageCurrent->m_dwObjects == 0);

        // do we already have a spare empty page?
        if (m_pPageCurrent->m_pNext != NULL)
        {
            // delete the spare.  the current page is now empty and is our spare.
            DeletePage(m_pPageCurrent->m_pNext);
        }

        // we're deleting something, so it must be previous to here.
        XOMASSERT(m_pPageCurrent->m_pPrev != NULL);

        m_pPageCurrent = m_pPageCurrent->m_pPrev;
        pRelocate = (CFixedSizeObjectHeader *)(m_pPageCurrent->m_pUnused - m_dwObjectSize);
    }

    if (pRelocate != pHandle->m_pHeader)
    {
        // lock the relocating handle.
        pRelocate->m_pHandle->LockMemory();

        // copy the memory.
        memcpy((void *)pHandle->m_pHeader, pRelocate, m_dwObjectSize);

        // update the header's page -- we moved it.
        pHandle->m_pHeader->m_pPage = pPage;

        // update the handle.
        pRelocate->m_pHandle->m_pHeader = pHandle->m_pHeader;

        // invoke the relocation callback.
        pRelocate->m_pHandle->OnMemoryMoved((void *)(pHandle->m_pHeader + 1));

        pRelocate->m_pHandle->UnlockMemory();
    }

#ifdef _DEBUG
    // clear the signature on the item that's actually being freed.
    pRelocate->m_dwSig = 0;
#endif

    // clean up the deleted handle.
    pHandle->m_pHeader = NULL;
    pHandle->UnlockMemory();

    // reclaim the memory to the current page.
    m_pPageCurrent->m_dwObjects--;
    m_pPageCurrent->m_pUnused -= m_dwObjectSize;

    // if we have a perf counter for objects, decrement it.
    if (m_dwPerfCounterPerObject != 0xFFFFFFFF)
    {
        g_Counters.DecrementValue64(m_dwPerfCounterPerObject, 1);
    }

lDone:

    m_lock.WriteUnlock();

    return hr;
}

CAccelerationMemoryAllocator::CAccelerationMemoryAllocator()
{
    m_dwNumSizes = 0;
    m_rgAllocSizes = NULL;
    m_rgpAllocators = NULL;
}

HRESULT CAccelerationMemoryAllocator::Init()
{
    HRESULT hr = S_OK;

    // get allocation sizes from config.
    m_dwNumSizes = g_Config.GetAllocationSizesLength();
    if (m_dwNumSizes == 0)
    {
        hr = E_UNEXPECTED;
        goto lDone;
    }

    m_pHeap = HeapCreate(HEAP_NO_SERIALIZE, 0, 0);
    if ((m_pHeap == NULL) || (m_pHeap == INVALID_HANDLE_VALUE))
    {
        hr = E_UNEXPECTED;
        goto lDone;
    }

    m_rgAllocSizes = new DWORD[m_dwNumSizes];
    if (m_rgAllocSizes == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
    
    for (DWORD iSize = 0; iSize < m_dwNumSizes; iSize++)
    {
        m_rgAllocSizes[iSize] = g_Config.GetAllocationSize(iSize);
    }

    qsort((void *)m_rgAllocSizes, m_dwNumSizes, sizeof(DWORD), CompareInt);
    
    m_rgpAllocators = new CFixedSizeMemoryAllocator*[m_dwNumSizes];
    if (m_rgpAllocators == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
    
    for (DWORD iSize = 0; iSize < m_dwNumSizes; iSize++)
    {
        m_rgpAllocators[iSize] = new CFixedSizeMemoryAllocator();
        if (m_rgpAllocators[iSize] == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        hr = m_rgpAllocators[iSize]->Init(
            m_pHeap,
            m_rgAllocSizes[iSize], 
            ACCELERATION_ALLOCATOR_NUM_ITEMS_TOTAL, 
            ACCELERATION_ALLOCATOR_NUM_PAGES_TOTAL);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

lDone:

    if (FAILED(hr))
    {
        Close();
    }

    return hr;
}

CAccelerationMemoryAllocator::~CAccelerationMemoryAllocator()
{
    Close();
}

HRESULT CAccelerationMemoryAllocator::Close()
{
    if (m_dwNumSizes == 0)
    {
        return S_FALSE;
    }
    
    for (DWORD iSize = 0; iSize < m_dwNumSizes; iSize++)
    {
        SAFE_DELETE(m_rgpAllocators[iSize]);
    }

    SAFE_ARRAYDELETE(m_rgpAllocators);
    SAFE_ARRAYDELETE(m_rgAllocSizes);
    m_dwNumSizes = 0;

    HeapDestroy(m_pHeap);
    m_pHeap = NULL;

    return S_OK;
}

HRESULT CAccelerationMemoryAllocator::AllocateMemory(CFixedSizeMemoryHandle *pHandle, size_t len)
{
    HRESULT hr= S_OK;

    if (pHandle == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // track the biggest object.
    if (len > (size_t)g_Counters.GetCurrentValue32(ACCELERATION_ALLOCATOR_LARGEST_OBJECT))
    {
        g_Counters.SetCurrentValue32(ACCELERATION_ALLOCATOR_LARGEST_OBJECT, (DWORD)len);
    }

    pHandle->LockMemory();

    pHandle->m_pHeader = NULL;
    
    CFixedSizeMemoryAllocator *pAllocator = GetAllocator(len);
    if (pAllocator == NULL)
    {
        // too big for us.
        BYTE *pBuf = new BYTE[len + sizeof(ObjectHeader) + HEADER_ALIGN_SHIFT];
        pHandle->m_pHeader = (ObjectHeader *)(pBuf + HEADER_ALIGN_SHIFT);
        if (pHandle->m_pHeader == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }
        
        pHandle->m_pHeader->m_pPage = NULL;
        pHandle->m_dwAllocSize = (DWORD)len;
        pHandle->OnMemoryMoved((void *)(pHandle->m_pHeader + 1));

        g_Counters.IncrementValue32(ACCELERATION_ALLOCATOR_BYPASS_RATE, 1);
    
        goto lDone;
    }
    
    hr = pAllocator->GetObjectMemory(pHandle);
    if (FAILED(hr))
    {
        goto lDone;
    }

    pHandle->m_dwAllocSize = (DWORD)len;

    g_Counters.IncrementValue32(ACCELERATION_ALLOCATOR_ITEM_CREATE_RATE, 1);
    g_Counters.IncrementValue64(ACCELERATION_ALLOCATOR_WASTED_BYTES, pAllocator->m_dwObjectSize - (DWORD)len);

lDone:

    if (pHandle != NULL)
    {
        pHandle->UnlockMemory();
    }
    
    return hr;
}

HRESULT CAccelerationMemoryAllocator::FreeMemory(CFixedSizeMemoryHandle *pHandle)
{
    HRESULT hr = S_OK;
    CFixedSizeMemoryAllocator *pAllocator = NULL;
    DWORD dwSize = 0;

    if (pHandle == NULL)
    {
        hr = S_FALSE;
        goto lDone;
    }

    pHandle->LockMemory();

    if (pHandle->m_pHeader->m_pPage == NULL)
    {
        BYTE *pBuf = (BYTE *)pHandle->m_pHeader - HEADER_ALIGN_SHIFT;
        delete[] pBuf;
        pHandle->m_pHeader = NULL;
        goto lDone;
    }

#ifdef _DEBUG
    // is this spot already released?
    XOMASSERT(pHandle->m_pHeader->m_dwSig == CFixedSizeMemoryAllocator::m_dwGuardWord);
#endif

    pAllocator = pHandle->m_pHeader->m_pPage->m_pAllocator;
    dwSize = pHandle->GetAllocSize();

    hr = pAllocator->ReleaseObject(pHandle);
    if (FAILED(hr))
    {
        goto lDone;
    }

    g_Counters.IncrementValue32(ACCELERATION_ITEM_DELETE_RATE, 1);
    g_Counters.DecrementValue64(ACCELERATION_ALLOCATOR_WASTED_BYTES, pAllocator->m_dwObjectSize - dwSize);

lDone:

    if (pHandle != NULL)
    {
        pHandle->UnlockMemory();
    }

    return hr;
}

CFixedSizeMemoryAllocator * CAccelerationMemoryAllocator::GetAllocator(DWORD dwSize)
{
    for (DWORD iSize = 0; iSize < m_dwNumSizes; iSize++)
    {
        if (m_rgAllocSizes[iSize] >= dwSize)
        {
            return m_rgpAllocators[iSize];
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\main.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

CAccelerationMemoryAllocator g_Allocator;
CAccelerationSwitchboard g_Switchboard;
CAccelerationMRUList g_MRUList;
CAccelerationLookupTable g_AccelerationLookupTable;
CAccelerationDataDeletionList g_DeletionList;
CAccelerationPerfCounters g_Counters;
CAccelerationConfig g_Config;
CAccelerationSocketListener g_ClientListener;
CAccelerationControlCallback g_ControlCallback;
CAccelerationClientReceiveContextPool g_ContextPool;
CAccelerationDataContainerPool g_ContainerPool;
CAccelerationChangelist g_Changelist;
BufferPool *g_pBufferPool = NULL;
CAccelerationHealth g_Health;

BOOL g_fServerTooBusy = FALSE;

void * __cdecl operator new(size_t len)
{
    void *pv = XAlloc(len);
    return pv;
}

void __cdecl operator delete(void *pv)
{
    XFree(pv);
}

WCHAR *BuildServiceDisplayName(WCHAR *wszComponent)
{
    static WCHAR wszDisplayName[MAX_PATH];
    wsprintf(wszDisplayName, L"Xbox Live %s Server", wszComponent);
    return wszDisplayName;
}

WCHAR *BuildServiceDescription(WCHAR *wszComponent)
{
    static WCHAR wszDisplayName[MAX_PATH];
    wsprintf(wszDisplayName, L"Acceleration distributed cache server for cluster: %s", wszComponent);
    return wszDisplayName;
}

CHAR *GetComponentNameA()
{
    static CHAR szComponent[MAX_PATH];
    sprintf(szComponent, "%S", g_wszComponent);
    return szComponent;
}

WCHAR *GetComponentNameW()
{
    return g_wszComponent;
}

class CAccelerationService : public CNTService
{
public:
    CAccelerationService(WCHAR *wszComponent) :
        CNTService(
            wszComponent,
            BuildServiceDisplayName(wszComponent),
            BuildServiceDescription(wszComponent),
            L"accelperf",
            CComBSTR(wszComponent))
    {
    }

    virtual WCHAR *GetExePathAndArgs()
    {
        static WCHAR szFileName[MAX_PATH + 1];
        GetModuleFileName(NULL, szFileName, MAX_PATH);
        wcscat(szFileName, L" -component ");
        wcscat(szFileName, GetComponentNameW());
        szFileName[MAX_PATH] = L'\0';
        return szFileName;
    }

    virtual HRESULT InitService( DWORD dwArgc, LPWSTR *pszArgv )
    {
        HRESULT hr = S_OK;

        SYSTEM_INFO si = {0};
        GetSystemInfo(&si);
        
        hr = g_xomcentral.Init(GetComponentNameA());
        if ( FAILED(hr) )
        {
            XomNtEvent(XEVENT_ACCELERATION_STARTUP_MGMT_INIT_FAILED, "Failed to initialize management infrastructure hr =0x%x", hr);
            goto lDone;
        }

        hr = g_xomcentral.RegisterControlCallback(&g_ControlCallback);
        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_ACCELERATION_STARTUP_MGMT_REGISTER_FAILED, "Unrecoverable failure while initializing: Failed to register control callback function: hr=0x%X", hr);
            goto lDone;
        }
        g_ControlCallback.Init();

        hr = g_Config.Init();
        if (FAILED(hr))
        {
            XomNtEvent( XEVENT_ACCELERATION_STARTUP_CONFIG_FAILED, "Failed to initialize config object hr =0x%X", hr);
            goto lDone;
        }

        hr = g_Counters.Init();
        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_ACCELERATION_STARTUP_PERF_COUNTERS_FAILED, "Failed to initialize perf counters hr =0x%x", hr);
            goto lDone;
        }

        g_pBufferPool = new BufferPool();
        if (g_pBufferPool == NULL)
        {
            XomNtEvent(XEVENT_ACCELERATION_STARTUP_BUFFER_POOL_FAILED, "Unrecoverable failure while initializing: Send Buffer Pool == NULL");
            goto lDone;
        }

        hr = g_Allocator.Init();
        if (FAILED(hr))
        {
            XomNtEvent(XEVENT_ACCELERATION_STARTUP_ALLOCATOR_FAILED, "Failed to initialize global custom allocator object hr =0x%x", hr);
            goto lDone;
        }

        hr = g_Switchboard.Init(si.dwNumberOfProcessors);
        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_ACCELERATION_STARTUP_SWITCHBOARD_FAILED, "Failed to initialize global switchboard object hr =0x%x", hr);
            goto lDone;
        }

        hr = g_MRUList.Init();
        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_ACCELERATION_STARTUP_MRU_LIST_FAILED, "Failed to initialize global MRU list hr =0x%x", hr);
            goto lDone;
        }

        hr = g_Changelist.Init(g_Config.GetNotificationChangelistSize());
        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_ACCELERATION_STARTUP_CHANGELIST_FAILED, "Failed to initialize global Changelist hr =0x%x", hr);
            goto lDone;
        }

        hr = g_AccelerationLookupTable.Init(g_Config.GetNumHashtableBuckets());
        if (FAILED(hr))
        {
            XomNtEvent(XEVENT_ACCELERATION_STARTUP_LOOKUP_TABLE_FAILED, "Failed to initialize global lookup table structure hr =0x%x", hr);
            goto lDone;
        }

        hr = g_ClientListener.Init(si.dwNumberOfProcessors);
        if (FAILED(hr))
        {
            XomNtEvent(XEVENT_ACCELERATION_STARTUP_LISTENER_FAILED, "Failed to initialize client listener hr =0x%x", hr);
            goto lDone;
        }

        // Doing this last; otherwise, it would fire up and return "green" when perhaps 
        // the other init routines are still running. Would be better to have a custom 
        // healthcheck (future work). 
        hr = g_Health.Init(CComBSTR(GetComponentNameW()));
        if (FAILED(hr))
        {
            // already logged event
            goto lDone;
        }

    lDone:
        
        if (SUCCEEDED(hr))
        {
            XomNtEvent(XEVENT_ACCELERATION_STARTED, "Server initialization has been completed, hr =0x%x", hr);
        }

        return( hr );
    }

    BOOL AccelerationHeartbeat()
    {
        // record start time.
        DWORD dwStart = GetTickCount();

        BOOL fFinished = ManageMemoryPressure(dwStart);

        // track heartbeat time
        DWORD dwElapsed = TICK_DIFF(GetTickCount(), dwStart);
        g_Counters.IncrementValue64(ACCELERATION_HEARTBEAT_TIME_AVERAGE, dwElapsed);
        g_Counters.IncrementValue32(ACCELERATION_HEARTBEAT_TIME_BASE, 1);

        return fFinished;
    }

    virtual HRESULT RunService( BOOL *pfServiceRan )
    {
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

        BOOL fSleep = TRUE;
        
        while (TRUE)
        {
            // check the shutdown event.
            DWORD dwResult = WaitForSingleObject(ShutdownEvent(), fSleep ? g_Config.GetHeartbeatInterval() : 0);
            if (WAIT_TIMEOUT == dwResult)
            {
                // still running.  do a heartbeat.  if the heartbeat reaches a stopping point, we'll relax with a sleep before the next one.
                fSleep = AccelerationHeartbeat();
            }
            else
            {
                break;
            }
        }

        Checkpoint();
        
        XomNtEvent(XEVENT_ACCELERATION_SHUTDOWN_STARTED, "Server shutdown has begun");

        g_Health.Close();
        g_ClientListener.Shutdown();
        g_Switchboard.Close();

// deleting all the structures takes a lot of time.  if we're in release mode, just let the OS clean it up.
// use debug for tracking leaks.
#ifdef _DEBUG        
        g_AccelerationLookupTable.Close();
        g_MRUList.Close();
        g_Changelist.Close();
#endif

        g_Config.Close();
        g_Counters.Close();
        SAFE_DELETE(g_pBufferPool);

        XomNtEvent(XEVENT_ACCELERATION_SHUTDOWN_COMPLETE, "Server shutdown has been completed");
        g_xomcentral.Term();

        XDumpLeaks();
        
        return S_OK;
    }

protected:

};

CNTService *g_pService = NULL;
WCHAR *g_wszComponent = NULL;

//////////////////////////////////////////////////////////////////////////////
int __cdecl wmain( int argc, WCHAR *argv[] )
{
    for( int i = 1; i < argc; i++ )
    {
        if( ( L'/' == argv[ i ][ 0 ] ) || ( L'-' == argv[ i ][ 0 ] ) )
        {
            if(((i + 1) < argc) && ( 0 == _wcsicmp( argv[ i ] + 1, L"component" ) ))
            {
                g_wszComponent = argv[ i + 1 ];
            }
        }
    }

    if (g_wszComponent == NULL)
    {
        return E_INVALIDARG;
    }

    g_pService = new CAccelerationService(g_wszComponent);

    DWORD dwRes = g_pService->ProcessMain( argc, argv );
    XDumpLeaks();
    return( dwRes );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\MRUList.h ===
#pragma once

class CAccelerationMRUList
{
public:

    CAccelerationMRUList();
    ~CAccelerationMRUList();

    HRESULT Init();
    void Close();

    HRESULT InsertItem(CAccelerationData *pData);
    HRESULT RemoveItem(CAccelerationData *pVictim);

    HRESULT MakeMostRecent(CAccelerationData *pData);
    
    HRESULT RemoveLeastRecent(CAccelerationData **ppRemoved)
    {
        HRESULT hr = S_OK;

        if (ppRemoved == NULL)
        {
            hr = E_INVALIDARG;
            goto lDone;
        }
        
        m_lock.WriteLock();

        *ppRemoved = m_pLeastRecent;
        
        if (m_pLeastRecent == NULL)
        {
            // no least recent item.
            XOMASSERT(m_pMostRecent == NULL);
            hr = S_FALSE;
            goto lDone;
        }

        hr = RemoveItem(m_pLeastRecent); 

    lDone:

        m_lock.WriteUnlock();

        return hr;
    }

    DWORD GetNumItems()
    { 
        return m_cItems; 
    }

protected:

/*
    // Used for debugging consistency issues with the doubly-linked list.
    BOOL InternalValidate();
*/

//    xlocks::CSpinLock m_lock;
    NYCLock m_lock;

    DWORD m_cItems;

    CAccelerationData *m_pMostRecent;
    CAccelerationData *m_pLeastRecent;
};

extern CAccelerationMRUList g_MRUList;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\NYCLock.h ===
#pragma once

#define _NYC_SPIN_COUNT 0x1000

// It's the spinny that never sleeps!
class NYCLock
{
public:

    NYCLock() :
        m_lThreadId(0),
        m_dwLockDepth(0)
        {}
    ~NYCLock() {}

    void Lock()
    {
        LONG lThreadId = GetCurrentThreadId();
        if (lThreadId == m_lThreadId)
        {
            // already locked by us.
            m_dwLockDepth++;
        }
        else
        {
            g_Counters.IncrementValue32(ACCELERATION_LOCK_RATE, 1);
            g_Counters.IncrementValue32(ACCELERATION_LOCK_SPINCOUNT_BASE, 1);
            
            // spin
            while(InterlockedCompareExchange(&m_lThreadId, lThreadId, 0) != 0)
            {
                g_Counters.IncrementValue64(ACCELERATION_LOCK_SPINCOUNT_AVERAGE, 1);
                
                for (DWORD dwSpin = 0; dwSpin < _NYC_SPIN_COUNT; dwSpin++)
                {
                    if (m_lThreadId == 0)
                    {
                        break;
                    }
                }
            }

            // now we have the lock.

            XOMASSERT(m_dwLockDepth == 0);

            m_dwLockDepth = 1;
        }
    }

    void Unlock()
    {
        XOMASSERT(IsLockedByCurrentThread());
        XOMASSERT(m_dwLockDepth > 0);

        // reduce lock depth.
        m_dwLockDepth--;
        if (m_dwLockDepth == 0)
        {
            // all locks released.  yield the lock.
            m_lThreadId = 0;
        }
    }

    bool IsLockedByCurrentThread()
    {
        return (GetCurrentThreadId() == (DWORD)m_lThreadId);
    }

    void WriteLock()
    {
        Lock();
    }

    void ReadLock()
    {
        Lock();
    }

    void WriteUnlock()
    {
        Unlock();
    }

    void ReadUnlock()
    {
        Unlock();
    }
    
protected:

    volatile LONG m_lThreadId;
    DWORD m_dwLockDepth;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\memmgr.h ===
#pragma once

#define _ALIGN(x, a) ((x) & ((a) - 1) ? ((x) + (a)) & ~((a) - 1) : (x))

class CAccelerationMemoryAllocator;
class CFixedSizeMemoryHandle;

class CFixedSizeMemoryAllocator
{
friend CAccelerationMemoryAllocator;
friend CFixedSizeMemoryHandle;
public:

    // constructor
    CFixedSizeMemoryAllocator();

    // destructor
    ~CFixedSizeMemoryAllocator();

    // Init() takes an object size.  all allocations made will be of this size.
    HRESULT Init(
        HANDLE pHeap, 
        DWORD dwObjectSize, 
        DWORD dwPerfCounterPerObject = 0xFFFFFFFF, 
        DWORD dwPerfCounterPerPage = 0xFFFFFFFF);

    // shuts down the allocator and frees all memory allocated or not.
    HRESULT Close();

    // obtain a memory block of size dwObjectSize (passed to Init).
    HRESULT GetObjectMemory(CFixedSizeMemoryHandle *pHandle);

    // release memory for an object.
    HRESULT ReleaseObject(CFixedSizeMemoryHandle *pHandle);

protected:

    HANDLE m_pHeap;

    NYCLock m_lock;

    // internal page node structure.
    struct CFixedSizeMemoryPage
    {
        // parent allocator pointer.
        CFixedSizeMemoryAllocator *m_pAllocator;
        
        // pointer to actual memory block.
        BYTE *m_pMemory;

        // pointer to unallocated space in memory.
        BYTE *m_pUnused;

        // number of allocations active on this page.
        DWORD m_dwObjects;

        // list links.
        CFixedSizeMemoryPage *m_pNext;
        CFixedSizeMemoryPage *m_pPrev;
    };

    struct CFixedSizeObjectHeader
    {
        // parent page link.
        CFixedSizeMemoryPage *m_pPage;

        // pointer to memory handle.
        CFixedSizeMemoryHandle *m_pHandle;
        
#ifdef _DEBUG
        DWORD m_dwSig;
#endif

        // user memory
        // BYTE *m_pMemory;
    };

    // make a new page and add to the list.
    HRESULT AllocNewPage();

    // delete an unused page from the list.
    HRESULT DeletePage(CFixedSizeMemoryPage *pVictim);

    // target size for each object.
    DWORD m_dwTargetObjectSize;

#ifdef _DEBUG
    // for debugging, to make sure we dont double-delete anything.
    static const DWORD m_dwGuardWord = 'FSMA';
#endif

    // actual size of each page is trimmed to be an even multiple of m_dwObjectSize.
    DWORD m_dwActualPageSize;

    // size of each object returned.
    DWORD m_dwObjectSize;

    // first page with free holes available.
    CFixedSizeMemoryPage *m_pPageCurrent;

    // perfcounter stuff
    DWORD m_dwPerfCounterPerObject;
    DWORD m_dwPerfCounterPerPage;
};

class CAccelerationMemoryAllocator
{
public:

    CAccelerationMemoryAllocator();

    ~CAccelerationMemoryAllocator();

    HRESULT Init();
    HRESULT Close();

    HRESULT AllocateMemory(CFixedSizeMemoryHandle *pHandle, size_t len);
    HRESULT FreeMemory(CFixedSizeMemoryHandle *pHandle);

protected:

    CFixedSizeMemoryAllocator * GetAllocator(DWORD dwSize);

    HANDLE m_pHeap;

    DWORD m_dwNumSizes;
    DWORD *m_rgAllocSizes;
    CFixedSizeMemoryAllocator **m_rgpAllocators;
};

class CFixedSizeMemoryHandle
{
friend CAccelerationMemoryAllocator;
friend CFixedSizeMemoryAllocator;
public:

    void LockMemory()
    {
        m_lock.WriteLock();
    }

    void UnlockMemory()
    {
        m_lock.WriteUnlock();
    }

    bool IsLockedByCurrentThread()
    {
        return m_lock.IsLockedByCurrentThread();
    }

    DWORD GetAllocSize()
    {
        return m_dwAllocSize;
    }

    void *GetMemoryPointer()
    {
        XOMASSERT(IsLockedByCurrentThread());
        return (void *)(m_pHeader + 1);
    }

    virtual void OnMemoryMoved(void *pMemory) = 0;
    
private:

    NYCLock m_lock;
    DWORD m_dwAllocSize;
    volatile CFixedSizeMemoryAllocator::CFixedSizeObjectHeader *m_pHeader;
};

extern CAccelerationMemoryAllocator g_Allocator;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\Protocol.cpp ===
#include "stdafx.h"

HRESULT CAccelerationMessageProcessor::ProcessAccelerationMessage(ACCELERATION_MSG_HEADER *pRequest, CAccelerationSocketConnection *pCReplyConn)
{
    HRESULT hr = S_OK;

    struct MessageHandler
    {
        DWORD dwMsgType;
        DWORD dwMinSize;
        MsgHandler pfnMsgHandler;
    };
    
    static MessageHandler s_rgMsgHandlers[1 + XBMSG_MAX_REQ - XBMSG_MIN_REQ] =
    {
        {XBMSG_QUERY_REQ, sizeof(ACCELERATION_QUERY_REQUEST_MSG), (MsgHandler) &CAccelerationMessageProcessor::ProcessMsgQuery},
        {XBMSG_INSERT_REQ, sizeof(ACCELERATION_INSERT_REQUEST_MSG), (MsgHandler) &CAccelerationMessageProcessor::ProcessMsgInsert},
        {XBMSG_REMOVE_REQ, sizeof(ACCELERATION_REMOVE_REQUEST_MSG), (MsgHandler) &CAccelerationMessageProcessor::ProcessMsgRemove},
        {XBMSG_SET_DATA_REQ, sizeof(ACCELERATION_SET_DATA_REQUEST_MSG), (MsgHandler) &CAccelerationMessageProcessor::ProcessMsgSetData},
        {XBMSG_CONTINUATION_REQ, sizeof(ACCELERATION_MSG_HEADER), (MsgHandler) &CAccelerationMessageProcessor::ProcessMsgNotSupported},
        {XBMSG_INCREMENT_REQ, sizeof(ACCELERATION_INCREMENT_REQUEST_MSG), (MsgHandler) &CAccelerationMessageProcessor::ProcessMsgIncrement},
        {XBMSG_CHANGELIST_REQ, sizeof(ACCELERATION_CHANGELIST_REQUEST_MSG), (MsgHandler) &CAccelerationMessageProcessor::ProcessMsgChangelist},
    };

    if ((pRequest->dwProtocolVersion == 0) || (pRequest->dwProtocolVersion > ACCELERATION_PROTOCOL_VERSION))
    {
        hr = XONLINE_E_PROTOCOL_MISMATCH;
        goto lDone;
    }

    if ((pRequest->dwMsgType < XBMSG_MIN_REQ) || (pRequest->dwMsgType > XBMSG_MAX_REQ))
    {
        hr = XONLINE_E_PROTOCOL_MISMATCH;
        goto lDone;
    }

    MessageHandler *pHandler = (MessageHandler *)&(s_rgMsgHandlers[pRequest->dwMsgType - XBMSG_MIN_REQ]);

    // make sure the handler array is ordered with the msg type enum.
    XOMASSERT(pHandler->dwMsgType == pRequest->dwMsgType);

    // minimum size check.
    if (pRequest->dwMsgLen < pHandler->dwMinSize)
    {
        hr = XONLINE_E_PROTOCOL_MISMATCH;
        goto lDone;
    }

    // run the message handler for this type.
    hr = (this->*(pHandler->pfnMsgHandler))(pRequest);
    if (FAILED(hr))
    {
        goto lDone;
    }

    if (m_pResponseBuffer != NULL)
    {
        // send the response.
        hr = pCReplyConn->Send(m_pResponseBuffer);
    }

lDone:

    if (FAILED(hr))
    {
        // if we failed, try to send a failure message back to the caller.
        SAFE_RELEASE(m_pResponseBuffer);
        m_pResponseBuffer = g_pBufferPool->GetBuffer(sizeof(ACCELERATION_EMPTY_RESPONSE_MSG));
        if (m_pResponseBuffer != NULL)
        {
            ACCELERATION_EMPTY_RESPONSE_MSG *pResp = (ACCELERATION_EMPTY_RESPONSE_MSG *)m_pResponseBuffer->GetBuffer();

            pResp->dwProtocolVersion = pRequest->dwProtocolVersion;
            pResp->dwMsgType = XBMSG_EMPTY_RESP;
            pResp->dwMsgLen = sizeof(ACCELERATION_EMPTY_RESPONSE_MSG);
            pResp->dwSeqNum = pRequest->dwSeqNum;
            pResp->hr = hr;            
            
            pCReplyConn->Send(m_pResponseBuffer);
        }
    }

    return hr;
}

HRESULT CAccelerationMessageProcessor::ProcessMsgQuery(ACCELERATION_QUERY_REQUEST_MSG *pRequest)
{
    HRESULT hr = S_OK;
    CAccelerationData *pKey = NULL;
    CAccelerationData *pData = NULL;
    CAccelerationLookupTableValue *pLookupValue = NULL;
    SYSTEMTIME st;
    FILETIME ft;
    DWORD dwLockToken = CAccelerationLookupTable::InvalidHashValue;
    BYTE *pbNew = NULL;

    if ((pRequest->dwKeySize > g_Config.GetMaxKeyLength()) ||
        (pRequest->dwKeySize == 0))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // make a key object
    pKey = g_ContainerPool.Obtain();
    if (pKey == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    hr = pKey->Init(pRequest->dwKeySize, (BYTE *)(pRequest + 1), 0, NULL, 60, 0, &ft);
    if (FAILED(hr))
    {
        goto lDone;
    }

    g_Counters.IncrementValue32(ACCELERATION_QUERY_API_RATE, 1);

    // lock the table bucket for this key.
    g_AccelerationLookupTable.LockBucketByKey(pKey->GetKey(), &dwLockToken);

    // let's see what exists at the given key...
    hr = g_AccelerationLookupTable.FindLookupEntry(dwLockToken, pKey->GetKey(), &pLookupValue);
    if (FAILED(hr))
    {
        // something wrong with either the key or the table.  this is bad.
        goto lDone;
    }

    pData = (CAccelerationData *)pLookupValue;

    switch (hr)
    {
    case S_OK:
        // we found something.  is it expired?
        if (!pData->IsExpired(&ft))
        {
            // there was already a good value there.  pData holds it.

            // successfull access of this data.
            pData->UpdateSlidingExpiration(&ft);
            g_MRUList.MakeMostRecent(pData);

            break;
        }
        else
        {
            // expired data.  we'll remove it.
            g_AccelerationLookupTable.RemoveLookupEntry(dwLockToken, pData);
            g_MRUList.RemoveItem(pData);

            if (!pData->IsReservation())
            {
                // record the change in the changelist.
                g_Changelist.RecordChange(pData);
            }
            
            pData->MarkForDeletion();

            // fall through to...
        }
    case S_FALSE:
        // nothing there.  we'll make a reservation.

        // use the key we already created.
        pData = pKey;
        pKey = NULL;

        // add the reservation to the table.
        g_AccelerationLookupTable.AddLookupEntry(dwLockToken, pData);
        g_MRUList.InsertItem(pData);

        // no changelist update for a reservation.

        break;
    }

    // pData now has the value to return to the caller.
    XOMASSERT(pData != NULL);

    // make a response buffer to send back to the caller.
    DWORD dwStructSize = ACCELERATION_PROTOCOL_SUPPORTS_VERSIONING(pRequest->dwProtocolVersion) ? 
        sizeof(ACCELERATION_QUERY_EX_RESPONSE_MSG) : sizeof(ACCELERATION_QUERY_RESPONSE_MSG);

    m_pResponseBuffer = g_pBufferPool->GetBuffer(dwStructSize + (pData->IsIncrementValue() ? sizeof(QWORD) : pData->GetDataSize()));
    if (m_pResponseBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pData->LockMemory();
    
    ACCELERATION_QUERY_EX_RESPONSE_MSG *pResp = (ACCELERATION_QUERY_EX_RESPONSE_MSG *)m_pResponseBuffer->GetBuffer();
    pResp->dwProtocolVersion = pRequest->dwProtocolVersion;
    pResp->dwMsgLen = m_pResponseBuffer->GetBufferLength();
    pResp->dwMsgType = XBMSG_QUERY_RESP;
    pResp->dwSeqNum = pRequest->dwSeqNum;
    pResp->hr = (pData->IsReservation()) ? S_FALSE : S_OK;

    if (ACCELERATION_PROTOCOL_SUPPORTS_VERSIONING(pRequest->dwProtocolVersion))
    {
        pResp->dwVersion = pData->GetVersion();
    }

    if (pData->IsIncrementValue())
    {
        pResp->dwValueSize = sizeof(QWORD);
        QWORD qwValue = ((CAccelerationIncrementValue *)(pData->GetDataBytes()))->GetValue();
        memcpy((BYTE *)pResp + dwStructSize, &qwValue, sizeof(QWORD));
    }
    else
    {
        pResp->dwValueSize = pData->GetDataSize();
        memcpy((BYTE *)pResp + dwStructSize, pData->GetDataBytes(), pData->GetDataSize());
    }

    pResp->dwValidSeconds = pData->GetRemainingValidSeconds(&ft);

    pData->UnlockMemory();

    // message successfully processed.
    hr = S_OK;

    g_Counters.IncrementValue32(ACCELERATION_CACHE_HIT_RATIO_BASE, 1);
    if (pResp->hr == S_OK)
    {
        g_Counters.IncrementValue64(ACCELERATION_CACHE_HIT_RATIO, 1);
        g_Counters.IncrementValue32(ACCELERATION_CACHE_HIT_RATE, 1);
    }
    else
    {
        g_Counters.IncrementValue32(ACCELERATION_CACHE_MISS_RATE, 1);
    }

lDone:

    // unlock the table bucket.
    g_AccelerationLookupTable.UnlockBucket(dwLockToken);

    if (pKey != NULL)
    {
        pKey->MarkForDeletion();
    }
    
    return hr;

}

HRESULT CAccelerationMessageProcessor::ProcessMsgInsert(ACCELERATION_INSERT_REQUEST_MSG *pRequest)
{
    HRESULT hr = S_OK;
    CAccelerationData *pNewData = NULL;
    CAccelerationData *pData = NULL;
    CAccelerationLookupTableValue *pLookupValue = NULL;
    SYSTEMTIME st;
    FILETIME ft;
    DWORD dwLockToken = CAccelerationLookupTable::InvalidHashValue;

    if (ACCELERATION_PROTOCOL_SUPPORTS_VERSIONING(pRequest->dwProtocolVersion) ||
        (pRequest->dwKeySize > g_Config.GetMaxKeyLength()) ||
        (pRequest->dwKeySize == 0) ||
        (pRequest->dwValueSize == 0))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // make a key object
    pNewData = g_ContainerPool.Obtain();
    if (pNewData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    // get a pointer to the value specified.
    BYTE *pValue = (BYTE *)(pRequest + 1) + pRequest->dwKeySize;

    hr = pNewData->Init(
            pRequest->dwKeySize, 
            (BYTE *)(pRequest + 1), 
            pRequest->dwValueSize, 
            pValue, 
            pRequest->dwAbsoluteSeconds, 
            pRequest->dwSlidingSeconds,
            &ft);
    if (FAILED(hr))
    {
        goto lDone;
    }

    g_Counters.IncrementValue32(ACCELERATION_INSERT_API_RATE, 1);

    // lock the table bucket for this key.
    g_AccelerationLookupTable.LockBucketByKey(pNewData->GetKey(), &dwLockToken);

    // let's see what exists at the given key...
    hr = g_AccelerationLookupTable.FindLookupEntry(dwLockToken, pNewData->GetKey(), &pLookupValue);
    if (FAILED(hr))
    {
        // something wrong with either the key or the table.  this is bad.
        goto lDone;
    }

    pData = (CAccelerationData *)pLookupValue;

    // make a response buffer.  since no data is returned, all responses are the same size.
    m_pResponseBuffer = g_pBufferPool->GetBuffer(sizeof(ACCELERATION_INSERT_RESPONSE_MSG));
    if (m_pResponseBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    ACCELERATION_INSERT_RESPONSE_MSG *pResp = (ACCELERATION_INSERT_RESPONSE_MSG *)m_pResponseBuffer->GetBuffer();
    pResp->dwProtocolVersion = pRequest->dwProtocolVersion;
    pResp->dwMsgLen = m_pResponseBuffer->GetBufferLength();
    pResp->dwMsgType = XBMSG_INSERT_RESP;
    pResp->dwSeqNum = pRequest->dwSeqNum;

    if (hr == S_FALSE)
    {
        // nothing found (no reservation).
        pResp->hr = S_FALSE;
    }
    else if (pData->IsExpired(&ft))
    {
        // expired item is the same as nothing.
        pResp->hr = S_FALSE;

        // expired data.  we'll remove it.
        g_AccelerationLookupTable.RemoveLookupEntry(dwLockToken, pData);
        g_MRUList.RemoveItem(pData);

        if (!pData->IsReservation())
        {
            // record the change in the changelist.
            g_Changelist.RecordChange(pData);
        }
        
        pData->MarkForDeletion();
    }
    else if (pData->IsReservation())
    {
        // reservation found, we can add the data.

        // first remove the reservation.
        g_AccelerationLookupTable.RemoveLookupEntry(dwLockToken, pData);
        g_MRUList.RemoveItem(pData);

        // no changelist update for a reservation.

        pData->MarkForDeletion();

        // replace with the new object.
        pData = pNewData;
        pNewData = NULL;

        // add the new item.
        g_AccelerationLookupTable.AddLookupEntry(dwLockToken, pData);
        g_MRUList.InsertItem(pData);

        // record the change in the changelist.
        g_Changelist.RecordChange(pData);

        pResp->hr = S_OK;
    }
    else
    {
        // real data found.

        pData->LockMemory();

        BOOL fSame = AccelerationCompareBytes(pRequest->dwValueSize, pValue, pData->GetDataSize(), pData->GetDataBytes());

        pData->UnlockMemory();

        // is it the same data?
        if (fSame)
        {
            // successfull access of this data.
            pData->UpdateSlidingExpiration(&ft);
            g_MRUList.MakeMostRecent(pData);

            pResp->hr = S_FALSE;
        }
        else
        {
            // different data.  Insert() not allowed to overwrite!
            pResp->hr = E_ACCESSDENIED;
        }
    }

    // message successfully processed.
    hr = S_OK;

lDone:

    
    // unlock the table bucket.
    g_AccelerationLookupTable.UnlockBucket(dwLockToken);
    
    if (pNewData != NULL)
    {
        pNewData->MarkForDeletion();
    }

    return hr;

}

HRESULT CAccelerationMessageProcessor::ProcessMsgRemove(ACCELERATION_REMOVE_REQUEST_MSG *pRequest)
{
    HRESULT hr = S_OK;
    CAccelerationData *pKey = NULL;
    CAccelerationData *pData = NULL;
    CAccelerationLookupTableValue *pLookupValue = NULL;
    DWORD dwLockToken = CAccelerationLookupTable::InvalidHashValue;

    if ((pRequest->dwKeySize > g_Config.GetMaxKeyLength()) ||
        (pRequest->dwKeySize == 0) ||
        (pRequest->fMatchExact == FALSE)) // bulk removal not supported in acceleration.
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // make a key object
    pKey = g_ContainerPool.Obtain();
    if (pKey == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    hr = pKey->Init(pRequest->dwKeySize, (BYTE *)(pRequest + 1), 0, NULL, 0, 0);
    if (FAILED(hr))
    {
        goto lDone;
    }

    g_Counters.IncrementValue32(ACCELERATION_REMOVE_API_RATE, 1);

    // lock the table bucket for this key.
    g_AccelerationLookupTable.LockBucketByKey(pKey->GetKey(), &dwLockToken);

    // let's see what exists at the given key...
    hr = g_AccelerationLookupTable.FindLookupEntry(dwLockToken, pKey->GetKey(), &pLookupValue);
    if (FAILED(hr))
    {
        // something wrong with either the key or the table.  this is bad.
        goto lDone;
    }

    pData = (CAccelerationData *)pLookupValue;

    // was it there?
    if (hr == S_OK)
    {
        // remove it.
        g_AccelerationLookupTable.RemoveLookupEntry(dwLockToken, pData);
        g_MRUList.RemoveItem(pData);

        if (!pData->IsReservation())
        {
            // record the change in the changelist.
            g_Changelist.RecordChange(pData);
        }

        pData->MarkForDeletion();
    }

    // make a response buffer.  since no data is returned, all responses are the same size.
    m_pResponseBuffer = g_pBufferPool->GetBuffer(sizeof(ACCELERATION_REMOVE_RESPONSE_MSG));
    if (m_pResponseBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    ACCELERATION_REMOVE_RESPONSE_MSG *pResp = (ACCELERATION_REMOVE_RESPONSE_MSG *)m_pResponseBuffer->GetBuffer();
    pResp->dwProtocolVersion = pRequest->dwProtocolVersion;
    pResp->dwMsgLen = m_pResponseBuffer->GetBufferLength();
    pResp->dwMsgType = XBMSG_REMOVE_RESP;
    pResp->dwSeqNum = pRequest->dwSeqNum;
    pResp->hr = hr;

    // message successfully processed.
    hr = S_OK;
    
lDone:
    
    // unlock the table bucket.
    g_AccelerationLookupTable.UnlockBucket(dwLockToken);

    if (pKey != NULL)
    {
        pKey->MarkForDeletion();
    }

    return hr;
}

HRESULT CAccelerationMessageProcessor::ProcessMsgSetData(ACCELERATION_SET_DATA_EX_REQUEST_MSG *pRequest)
{
    HRESULT hr = S_OK;
    CAccelerationData *pNewData = NULL;
    CAccelerationData *pData = NULL;
    CAccelerationLookupTableValue *pLookupValue = NULL;
    DWORD dwLockToken = CAccelerationLookupTable::InvalidHashValue;
    DWORD dwOldVersion = 0;

    DWORD dwStructSize = ACCELERATION_PROTOCOL_SUPPORTS_VERSIONING(pRequest->dwProtocolVersion) ? 
        sizeof(ACCELERATION_SET_DATA_EX_REQUEST_MSG) : sizeof(ACCELERATION_SET_DATA_REQUEST_MSG);

    if ((pRequest->dwKeySize > g_Config.GetMaxKeyLength()) ||
        (pRequest->dwKeySize == 0) ||
        (pRequest->dwValueSize == 0))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // make a key object
    pNewData = g_ContainerPool.Obtain();
    if (pNewData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // get a pointer to the value specified.
    BYTE *pValue = (BYTE *)(pRequest + 1) + pRequest->dwKeySize;

    hr = pNewData->Init(
            pRequest->dwKeySize, 
            (BYTE *)(pRequest + 1), 
            pRequest->dwValueSize, 
            pValue, 
            pRequest->dwAbsoluteSeconds, 
            pRequest->dwSlidingSeconds);
    if (FAILED(hr))
    {
        goto lDone;
    }

    g_Counters.IncrementValue32(ACCELERATION_SETDATA_API_RATE, 1);

    // lock the table bucket for this key.
    g_AccelerationLookupTable.LockBucketByKey(pNewData->GetKey(), &dwLockToken);

    // let's see what exists at the given key...
    hr = g_AccelerationLookupTable.FindLookupEntry(dwLockToken, pNewData->GetKey(), &pLookupValue);
    if (FAILED(hr))
    {
        // something wrong with either the key or the table.  this is bad.
        goto lDone;
    }

    pData = (CAccelerationData *)pLookupValue;

    // make a response buffer.  since no data is returned, all responses are the same size.
    m_pResponseBuffer = g_pBufferPool->GetBuffer(ACCELERATION_PROTOCOL_SUPPORTS_VERSIONING(pRequest->dwProtocolVersion) ? 
        sizeof(ACCELERATION_SET_DATA_EX_RESPONSE_MSG) : sizeof(ACCELERATION_SET_DATA_RESPONSE_MSG));
    if (m_pResponseBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // we always cast the buffer to an _EX_ message here, but the _EX_ fields (version) are only accessed when versioning is supported.
    ACCELERATION_SET_DATA_EX_RESPONSE_MSG *pResp = (ACCELERATION_SET_DATA_EX_RESPONSE_MSG *)m_pResponseBuffer->GetBuffer();
    pResp->dwProtocolVersion = pRequest->dwProtocolVersion;
    pResp->dwMsgLen = m_pResponseBuffer->GetBufferLength();
    pResp->dwMsgType = XBMSG_SET_DATA_RESP;
    pResp->dwSeqNum = pRequest->dwSeqNum;

    dwOldVersion = (hr == S_OK) ? pData->GetVersion() : 0;
    
    // check the versions.
    if (ACCELERATION_PROTOCOL_SUPPORTS_VERSIONING(pRequest->dwProtocolVersion)
        && (pRequest->dwVersion != dwOldVersion)
        && (pRequest->dwVersion != ACCELERATION_SET_DATA_VERSION_OVERWRITE))
    {
        // version mismatch.  fail the update.
        pResp->hr = E_ACCESSDENIED;
        pResp->dwVersion = dwOldVersion;
        goto lDone;
    }

    if (hr == S_OK)
    {
        // found data.  we'll remove it.
        g_AccelerationLookupTable.RemoveLookupEntry(dwLockToken, pData);
        g_MRUList.RemoveItem(pData);

        // no changelist update here, as we'll be overwriting this key below.

        pData->MarkForDeletion();
    }

    pData = pNewData;
    pNewData = NULL;
    
    // add the new item.
    g_AccelerationLookupTable.AddLookupEntry(dwLockToken, pData);
    g_MRUList.InsertItem(pData);
    pData->UpdateVersion(dwOldVersion);

    if (ACCELERATION_PROTOCOL_SUPPORTS_VERSIONING(pRequest->dwProtocolVersion))
    {
        pResp->dwVersion = pData->GetVersion();
    }
    
    // record the change in the changelist.
    g_Changelist.RecordChange(pData);

    pResp->hr = S_OK;

    // message successfully processed.
    hr = S_OK;

lDone:

    // unlock the table bucket.
    g_AccelerationLookupTable.UnlockBucket(dwLockToken);
    
    if (pNewData != NULL)
    {
        pNewData->MarkForDeletion();
    }

    return hr;

}

HRESULT CAccelerationMessageProcessor::ProcessMsgIncrement(ACCELERATION_INCREMENT_REQUEST_MSG *pRequest)
{
    HRESULT hr = S_OK;
    CAccelerationData *pNewData = NULL;
    CAccelerationData *pData = NULL;
    CAccelerationLookupTableValue *pLookupValue = NULL;
    SYSTEMTIME st;
    FILETIME ft;
    DWORD dwLockToken = CAccelerationLookupTable::InvalidHashValue;
    CAccelerationIncrementValue incValue(pRequest->qwIncrementAmount);

    if ((pRequest->dwKeySize > g_Config.GetMaxKeyLength()) ||
        (pRequest->dwKeySize == 0) ||
        (pRequest->dwHalfLifeSeconds == 0))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // make a key object
    pNewData = g_ContainerPool.Obtain();
    if (pNewData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    hr = pNewData->Init(
        pRequest->dwKeySize, 
        (BYTE *)(pRequest + 1), 
        sizeof(CAccelerationIncrementValue), 
        (BYTE *)&incValue, 
        pRequest->dwAbsoluteSeconds, 
        pRequest->dwSlidingSeconds,
        &ft);
    if (FAILED(hr))
    {
        goto lDone;
    }

    g_Counters.IncrementValue32(ACCELERATION_INCREMENT_API_RATE, 1);

    // lock the table bucket for this key.
    g_AccelerationLookupTable.LockBucketByKey(pNewData->GetKey(), &dwLockToken);

    // let's see what exists at the given key...
    hr = g_AccelerationLookupTable.FindLookupEntry(dwLockToken, pNewData->GetKey(), &pLookupValue);
    if (FAILED(hr))
    {
        // something wrong with either the key or the table.  this is bad.
        goto lDone;
    }

    pData = (CAccelerationData *)pLookupValue;

    // make a response buffer.  since no data is returned, all responses are the same size.
    m_pResponseBuffer = g_pBufferPool->GetBuffer(sizeof(ACCELERATION_INCREMENT_RESPONSE_MSG));
    if (m_pResponseBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    ACCELERATION_INCREMENT_RESPONSE_MSG *pResp = (ACCELERATION_INCREMENT_RESPONSE_MSG *)m_pResponseBuffer->GetBuffer();
    pResp->dwProtocolVersion = pRequest->dwProtocolVersion;
    pResp->dwMsgLen = m_pResponseBuffer->GetBufferLength();
    pResp->dwMsgType = XBMSG_INCREMENT_RESP;
    pResp->dwSeqNum = pRequest->dwSeqNum;

    if ((hr == S_FALSE) ||
        (pData->IsReservation()) ||
        (pData->IsExpired(&ft)))
    {
        if (pData != NULL)
        {
            // delete whatever was there.
            g_AccelerationLookupTable.RemoveLookupEntry(dwLockToken, pData);
            g_MRUList.RemoveItem(pData);

            // no changelist update here, as we'll be overwriting this key below.

            pData->MarkForDeletion();
        }
        
        // nothing found, add the value.

        pData = pNewData;
        pNewData = NULL;

        // insert the new item into the table.
        g_AccelerationLookupTable.AddLookupEntry(dwLockToken, pData);
        g_MRUList.InsertItem(pData);

        // record the change in the changelist.
        g_Changelist.RecordChange(pData);

        // no existing item, so we return S_FALSE to indicate creation.
        pResp->hr = S_FALSE;
        pResp->qwResult = pRequest->qwIncrementAmount;
    }
    else if (!pData->IsIncrementValue())
    {
        // something other than an increment value found.  this is bad.
        pResp->hr = E_ACCESSDENIED;
        pResp->qwResult = 0;
    }
    else
    {
        // an increment value found.  we can increment it.
        pData->LockMemory();
        
        CAccelerationIncrementValue *pIncrement = (CAccelerationIncrementValue *)pData->GetDataBytes();

        pResp->qwResult = pIncrement->ComputeNewValue(pRequest->qwIncrementAmount, pRequest->dwHalfLifeSeconds);

        pData->UnlockMemory();

        // successfull access of this data.
        pData->UpdateSlidingExpiration(&ft);
        g_MRUList.MakeMostRecent(pData);
        pData->UpdateVersion(pData->GetVersion());

        // record the change in the changelist.
        g_Changelist.RecordChange(pData);

        pResp->hr = S_OK;
    }

    // message successfully processed.
    hr = S_OK;

lDone:

    // unlock the table bucket.
    g_AccelerationLookupTable.UnlockBucket(dwLockToken);

    if (pNewData != NULL)
    {
        pNewData ->MarkForDeletion();
    }
    
    return hr;

}

HRESULT CAccelerationMessageProcessor::ProcessMsgChangelist(ACCELERATION_CHANGELIST_REQUEST_MSG *pRequest)
{
    HRESULT hr = S_OK;
    DWORD dwNewChangeID = 0;
    DWORD dwNumChanges = 0;
    DWORD cbAllKeys = 0;

    // TODO: perfcounter for changelist query rate.

    // lock the changelist here so we can make mulitple calls without it being modified.
    g_Changelist.Lock();

    // get the sizes we'll need to make a buffer.
    hr = g_Changelist.GetSizes(
        pRequest->dwChangeID, 
        &dwNewChangeID, 
        &dwNumChanges, 
        &cbAllKeys);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // make a response buffer to send back to the caller.
    m_pResponseBuffer = g_pBufferPool->GetBuffer(
        sizeof(ACCELERATION_CHANGELIST_RESPONSE_MSG) 
        + (dwNumChanges * sizeof(ACCELERATION_CHANGELIST_ITEM))
        + cbAllKeys);
    if (m_pResponseBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    ACCELERATION_CHANGELIST_RESPONSE_MSG *pResp = (ACCELERATION_CHANGELIST_RESPONSE_MSG *)m_pResponseBuffer->GetBuffer();
    
    // walk changelist, populate data.
    hr = g_Changelist.BuildResponseBuffer(
        pRequest->dwChangeID, 
        m_pResponseBuffer->GetBufferLength() - sizeof(ACCELERATION_CHANGELIST_RESPONSE_MSG), 
        (BYTE *)(pResp + 1));
    if (FAILED(hr))
    {
        goto lDone;
    }

    pResp->dwProtocolVersion = pRequest->dwProtocolVersion;
    pResp->dwMsgLen = m_pResponseBuffer->GetBufferLength();
    pResp->dwMsgType = XBMSG_CHANGELIST_RESP;
    pResp->dwSeqNum = pRequest->dwSeqNum;
    pResp->hr = hr;
    pResp->dwNewChangeID = dwNewChangeID;
    pResp->dwNumChanges = dwNumChanges;

    // message successfully processed.
    hr = S_OK;

lDone:

    g_Changelist.Unlock();

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\MRUList.cpp ===
#include "stdafx.h"

CAccelerationMRUList::CAccelerationMRUList() :
    m_pLeastRecent(NULL),
    m_pMostRecent(NULL)
{
}
    
CAccelerationMRUList::~CAccelerationMRUList()
{
    Close();
}

HRESULT CAccelerationMRUList::Init()
{
    Close();
    
    return S_OK;
}

void CAccelerationMRUList::Close()
{
    m_lock.WriteLock();
    
    // delete all the items in the list.
    while (m_pLeastRecent != NULL)
    {
        CAccelerationData *pVictim = m_pLeastRecent;
        m_pLeastRecent = pVictim->m_pMoreRecent;

        // ensure that the chain starting from m_pLeastRecent terminated at m_pMostRecent.
        XOMASSERT((m_pLeastRecent == NULL) ? pVictim == m_pMostRecent : TRUE);
        
        delete pVictim;
    }

    m_pLeastRecent = NULL;
    m_pMostRecent = NULL;

    m_lock.WriteUnlock();
}

HRESULT CAccelerationMRUList::InsertItem(CAccelerationData *pData)
{
    m_lock.WriteLock();

    HRESULT hr = S_OK;
    
    if (pData == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // increment the count.
    m_cItems++;

    // insert at the head.
    pData->m_pMoreRecent = NULL;
    pData->m_pLessRecent = m_pMostRecent;

    // link back from the existing most recent.
    if (m_pMostRecent != NULL)
    {
        XOMASSERT(m_pMostRecent->m_pMoreRecent == NULL);
        m_pMostRecent->m_pMoreRecent = pData;
    }

    // this is now the most recent.
    m_pMostRecent = pData;

    // if this is the only one in the list, it is also least recent.
    if (m_pLeastRecent == NULL)
    {
        m_pLeastRecent = pData;
        XOMASSERT(m_pLeastRecent->m_pLessRecent == NULL);
    }

lDone:
    
    m_lock.WriteUnlock();

    return hr;
}

HRESULT CAccelerationMRUList::MakeMostRecent(CAccelerationData *pData)
{
    m_lock.WriteLock();

    HRESULT hr = S_OK;
    
    if (pData == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // remove then re-insert.
    hr = RemoveItem(pData);
    if (hr != S_OK)
    {
        goto lDone;
    }

    hr = InsertItem(pData);
    
lDone:

    m_lock.WriteUnlock();

    return hr;
}

HRESULT CAccelerationMRUList::RemoveItem(CAccelerationData *pVictim)
{
    m_lock.WriteLock();

    HRESULT hr = S_OK;

    // skip over this node from the more recent side.
    if (pVictim->m_pMoreRecent != NULL)
    {
        pVictim->m_pMoreRecent->m_pLessRecent = pVictim->m_pLessRecent;
    }
    else if (m_pMostRecent == pVictim)
    {
        // this node was the most recent.  update the most recent to the less recent side of this node.
        m_pMostRecent = pVictim->m_pLessRecent;
    }
    else
    {
        // item not in the list!
        hr = S_FALSE;
        goto lDone;
    }

    // skip over this node from the less recent side.
    if (pVictim->m_pLessRecent != NULL)
    {
        pVictim->m_pLessRecent->m_pMoreRecent = pVictim->m_pMoreRecent;
    }
    else if (m_pLeastRecent == pVictim)
    {
        // this node was the least recent.  update the least recent to the more recent side of this node.
        m_pLeastRecent = pVictim->m_pMoreRecent;
    }
    else
    {
        // item not in the list!
        hr = S_FALSE;
        goto lDone;
    }

    pVictim->m_pMoreRecent = NULL;
    pVictim->m_pLessRecent = NULL;

lDone:

    if (hr == S_OK)
    {
        m_cItems--;
    }

    m_lock.WriteUnlock();

    return hr;
}

/*
// Used for debugging consistency issues with the doubly-linked list.
BOOL CAccelerationMRUList::InternalValidate()
{
    if ((m_cItems == 0) || (m_pMostRecent == NULL) || (m_pLeastRecent == NULL))
    {
        // list is empty.  everything must show empty.
        if ((m_cItems != 0) || (m_pMostRecent != NULL) || (m_pLeastRecent != NULL))
        {
            XOMASSERT(FALSE);
            return FALSE;
        }
    }
    else
    {
        // list has at least one element.
        if (m_pMostRecent->m_pMoreRecent != NULL)
        {
            // head isnt at the head.
            XOMASSERT(FALSE);
            return FALSE;
        }
        if (m_pLeastRecent->m_pLessRecent != NULL)
        {
            // tail isnt at the tail.
            XOMASSERT(FALSE);
            return FALSE;
        }
    }

    // walk the whole list.
    for (CAccelerationData *pItem = m_pMostRecent; pItem != NULL; pItem = pItem->m_pLessRecent)
    {
        if (pItem->m_pLessRecent != NULL)
        {
            // check less->more links.
            if (pItem->m_pLessRecent->m_pMoreRecent != pItem)
            {
                XOMASSERT(FALSE);
                return FALSE;
            }
        }
        else
        {
            if (pItem != m_pLeastRecent)
            {
                XOMASSERT(FALSE);
                return FALSE;
            }
        }

        if (pItem->m_pMoreRecent != NULL)
        {
            // check more->less links.
            if (pItem->m_pMoreRecent->m_pLessRecent != pItem)
            {
                XOMASSERT(FALSE);
                return FALSE;
            }
        }
        else
        {
            if (pItem != m_pMostRecent)
            {
                XOMASSERT(FALSE);
                return FALSE;
            }
        }
    }

    return TRUE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\Protocol.h ===
#pragma once

enum ACCELERATION_MSG_TYPES
{
    // request types:
    XBMSG_MIN_REQ                    = 1000,
    XBMSG_QUERY_REQ                  = 1000,
    XBMSG_INSERT_REQ                 = 1001,
    XBMSG_REMOVE_REQ                 = 1002,
    XBMSG_SET_DATA_REQ               = 1003,
    XBMSG_CONTINUATION_REQ           = 1004,
    XBMSG_INCREMENT_REQ              = 1005,
    XBMSG_CHANGELIST_REQ             = 1006,
    XBMSG_MAX_REQ                    = 1006,

    // response types:
    XBMSG_MIN_RESP                   = 1100,
    XBMSG_EMPTY_RESP                 = 1100,
    XBMSG_QUERY_RESP                 = 1101,
    XBMSG_INSERT_RESP                = 1102,
    XBMSG_REMOVE_RESP                = 1103,
    XBMSG_SET_DATA_RESP              = 1104,
    XBMSG_INCREMENT_RESP             = 1105,
    XBMSG_CHANGELIST_RESP            = 1106,
    XBMSG_MAX_RESP                   = 1106,
};

///////////////////////////////////////////////////////////////////////////////////////////
// PROTOCOL VERSIONS
//
// 1 -- initial protocol version.
//
// 2 -- added optimistic concurrency via versions.  QUERY_EX_RESP and SET_DATA_EX_REQ/RESP added.
#define ACCELERATION_PROTOCOL_SUPPORTS_VERSIONING(version) ((version) > 1)
//
///////////////////////////////////////////////////////////////////////////////////////////

#define ACCELERATION_PROTOCOL_VERSION 2
#define ACCELERATION_INCREMENT_HALFLIFE_INFINITE 0xFFFFFFFF
#define ACCELERATION_SET_DATA_VERSION_OVERWRITE 0xFFFFFFFF

#pragma pack(push, 1)

struct ACCELERATION_MSG_HEADER
{
    DWORD dwProtocolVersion;
    DWORD dwMsgType;
    DWORD dwMsgLen;
    DWORD dwSeqNum;
};

struct ACCELERATION_QUERY_REQUEST_MSG : public ACCELERATION_MSG_HEADER
{
    DWORD dwKeySize;
    // BYTE rgbKey[dwKeySize];
};

struct ACCELERATION_QUERY_RESPONSE_MSG : public ACCELERATION_MSG_HEADER
{
    HRESULT hr;
    DWORD dwValueSize;
    DWORD dwValidSeconds;
    // BYTE rgbValue[dwValueSize];
};

struct ACCELERATION_QUERY_EX_RESPONSE_MSG : public ACCELERATION_QUERY_RESPONSE_MSG
{
    // ACCELERATION_QUERY_RESPONSE_MSG
    DWORD dwVersion;
    // BYTE rgbValue[dwValueSize];
};

struct ACCELERATION_INSERT_REQUEST_MSG : public ACCELERATION_MSG_HEADER
{
    DWORD dwKeySize;
    DWORD dwValueSize;
    DWORD dwAbsoluteSeconds;
    DWORD dwSlidingSeconds;
    // BYTE rgbKey[dwKeySize];
    // BYTE rgbValue[dwValueSize];
};

struct ACCELERATION_INSERT_RESPONSE_MSG : public ACCELERATION_MSG_HEADER
{
    HRESULT hr;
};

struct ACCELERATION_REMOVE_REQUEST_MSG : public ACCELERATION_MSG_HEADER
{
    DWORD dwKeySize;
    BOOL fMatchExact;
    // BYTE rgbKey[dwKeySize];
};

struct ACCELERATION_REMOVE_RESPONSE_MSG : public ACCELERATION_MSG_HEADER
{
    HRESULT hr;
};

struct ACCELERATION_SET_DATA_REQUEST_MSG : public ACCELERATION_MSG_HEADER
{
    DWORD dwKeySize;
    DWORD dwValueSize;
    DWORD dwAbsoluteSeconds;
    DWORD dwSlidingSeconds;
    // BYTE rgbKey[dwKeySize];
    // BYTE rgbValue[dwValueSize];
};

struct ACCELERATION_SET_DATA_EX_REQUEST_MSG : public ACCELERATION_SET_DATA_REQUEST_MSG
{
    // ACCELERATION_SET_DATA_REQUEST_MSG
    DWORD dwVersion;
    // BYTE rgbKey[dwKeySize];
    // BYTE rgbValue[dwValueSize];
};

struct ACCELERATION_SET_DATA_RESPONSE_MSG : public ACCELERATION_MSG_HEADER
{
    HRESULT hr;
};

struct ACCELERATION_SET_DATA_EX_RESPONSE_MSG : public ACCELERATION_SET_DATA_RESPONSE_MSG
{
    // ACCELERATION_SET_DATA_RESPONSE_MSG
    DWORD dwVersion;
};

struct ACCELERATION_EMPTY_RESPONSE_MSG : public ACCELERATION_MSG_HEADER
{
    HRESULT hr;
};

struct ACCELERATION_INCREMENT_REQUEST_MSG : public ACCELERATION_MSG_HEADER
{
    DWORD dwKeySize;
    QWORD qwIncrementAmount;
    DWORD dwHalfLifeSeconds;
    DWORD dwAbsoluteSeconds;
    DWORD dwSlidingSeconds;
    // BYTE rgbKey[dwKeySize];
};

struct ACCELERATION_INCREMENT_RESPONSE_MSG : public ACCELERATION_MSG_HEADER
{
    HRESULT hr;
    QWORD qwResult;
};

struct ACCELERATION_CHANGELIST_REQUEST_MSG : public ACCELERATION_MSG_HEADER
{
    DWORD dwChangeID;
};

struct ACCELERATION_CHANGELIST_RESPONSE_MSG : public ACCELERATION_MSG_HEADER
{
    HRESULT hr;
    DWORD dwNewChangeID;
    DWORD dwNumChanges;
    // ACCELERATION_CHANGELIST_ITEM rgChanges[dwNumChanges];
};

struct ACCELERATION_CHANGELIST_ITEM
{
    DWORD cbKey;
    // BYTE rgbKey[cbKey];
};

#pragma pack(pop)

class CAccelerationSocketConnection;

class CAccelerationMessageProcessor
{
public:

    // constructor
    CAccelerationMessageProcessor() :
        m_pResponseBuffer(NULL)
    {
    }

    // destructor
    ~CAccelerationMessageProcessor()
    {
        SAFE_RELEASE(m_pResponseBuffer);
    }

    HRESULT ProcessAccelerationMessage(ACCELERATION_MSG_HEADER *pRequest, CAccelerationSocketConnection *pCReplyConn);

protected:

    // Message handler methods
    typedef HRESULT (CAccelerationMessageProcessor::*MsgHandler)(ACCELERATION_MSG_HEADER *pMsgHeader);

    HRESULT ProcessMsgQuery(ACCELERATION_QUERY_REQUEST_MSG *pRequest);
    HRESULT ProcessMsgInsert(ACCELERATION_INSERT_REQUEST_MSG *pRequest);
    HRESULT ProcessMsgRemove(ACCELERATION_REMOVE_REQUEST_MSG *pRequest);
    HRESULT ProcessMsgSetData(ACCELERATION_SET_DATA_EX_REQUEST_MSG *pRequest);
    HRESULT ProcessMsgIncrement(ACCELERATION_INCREMENT_REQUEST_MSG *pRequest);
    HRESULT ProcessMsgChangelist(ACCELERATION_CHANGELIST_REQUEST_MSG *pRequest);

    HRESULT ProcessMsgNotSupported(ACCELERATION_MSG_HEADER *pRequest)
    {
        // this should be unreachable by any valid client.
        XOMASSERT(FALSE);
        XomNtEvent(XEVENT_ACCELERATION_UNSUPPORTED_MESSAGE, "ProcessMsgNotSupported() called for msgtype %d", pRequest->dwMsgType);
        return E_INVALIDARG;
    }

    CTCPConnectionVarBuffer *m_pResponseBuffer;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\SocketConnect.h ===
#pragma once

class CAccelerationClientReceiveContext;

class CAccelerationSocketConnection : public CTCPConnectionMessageBased
{
public:

    // constructor
    CAccelerationSocketConnection();

    // destructor
    virtual ~CAccelerationSocketConnection();

    HRESULT Init(CServerSocket *pSocket);

    // completion routine called on the switchboard thread.
    void ProcessClientMessage(BYTE *pMsg, DWORD cbEntireMsg);

    const sockaddr_in *GetConnectedAddress()
    {
        return (const sockaddr_in *)&m_sa;
    }
    
protected:

    virtual void OnDisconnect(HRESULT hrReason ) 
    {
        // Self Destruct
        Release();
    }

    // message handler function.  called once per message.
    virtual void ProcessMessage(BYTE *pMsg, DWORD cbEntireMsg);
    
    sockaddr_in m_sa;

    CAccelerationClientReceiveContext *m_pCCtx;
};



class CAccelerationSocketListener : 
    public CServerSocketCallback
{
public:
    IMPLEMENT_REFCOUNT;

    // constructor
    CAccelerationSocketListener() :
        m_pCCompPort(NULL),
        m_pCListenSocket(NULL)
    {
    }

    // destructor
    virtual ~CAccelerationSocketListener()
    {
        Shutdown();
    }

    HRESULT Init(DWORD cProcessors);
    void Shutdown();

    // CServerSocketCallback methods
    virtual void OnSocketAccept(
        CServerSocket *pListenSocket,
        CServerSocket *pAcceptedSocket,
        sockaddr_in *pLocalAddr,
        sockaddr_in *pRemoteAddr,
        HRESULT hr,
        QWORD qwCallbackArg );
    
protected:

    CCompletionPort *m_pCCompPort;
    CServerSocket *m_pCListenSocket;
};

extern CAccelerationSocketListener g_ClientListener;

class CAccelerationClientReceiveContext : 
    public CSingleLink,
    public CLocalContext
{
public:

    // constructor
    CAccelerationClientReceiveContext()
    {
        g_Counters.IncrementValue32(ACCELERATION_CONTEXTPOOL_NUM_TOTAL, 1);
        g_Counters.IncrementValue32(ACCELERATION_CONTEXTPOOL_CREATE_RATE, 1);
    }

    void Init(CAccelerationSocketConnection *pCCliConn, DWORD dwBufSize)
    {
        m_pCCliConn = pCCliConn;
        m_pCCliConn->AddRef();

        if (dwBufSize > m_cbAlloc)
        {
            // our buffer is too small.  make a new one.
            m_pMsg = new BYTE[dwBufSize];
        }
        else
        {
            // use the existing buffer.
            m_pMsg = m_pbAlloc;
        }

        m_pWrite = m_pMsg;
        m_cbEntireMsg = dwBufSize;
    }

    void Close()
    {
        // m_pbAlloc is allocated with the object.

        if (m_cbEntireMsg > m_cbAlloc)
        {
            // we must have made a custom sized buffer.  delete it.
            SAFE_ARRAYDELETE(m_pMsg);
        }
        
        SAFE_RELEASE(m_pCCliConn);
        m_pWrite = NULL;
        m_cbEntireMsg = 0;
    }

    // destructor
    virtual ~CAccelerationClientReceiveContext()
    {
        Close();
    }

    virtual void CompletionProc();

    virtual char*GetDescription()
    {
        return "Acceleration Client Receive";
    }
      
protected:
    CAccelerationSocketConnection *m_pCCliConn;

public:
    BYTE *m_pMsg;
    DWORD m_cbEntireMsg;
    BYTE * m_pWrite;

    BYTE *m_pbAlloc;
    DWORD m_cbAlloc;
};

class CAccelerationClientReceiveContextPool
{
public:

    CAccelerationClientReceiveContextPool()
    {
    }

    ~CAccelerationClientReceiveContextPool()
    {
        for (CAccelerationClientReceiveContext *pCCtx = m_lfsPool.Pop(); pCCtx != NULL; pCCtx = m_lfsPool.Pop())
        {
            pCCtx->Release();
        }
    }

    void Insert(CAccelerationClientReceiveContext *pCCtx)
    {
        g_Counters.IncrementValue32(ACCELERATION_CONTEXTPOOL_NUM_FREE, 1);
        pCCtx->Close();
        m_lfsPool.Push(pCCtx);
    }
    
    CAccelerationClientReceiveContext *Obtain(CAccelerationSocketConnection *pCCliConn, DWORD dwBufSize)
    {
        CAccelerationClientReceiveContext *pCCtx = (CAccelerationClientReceiveContext *)m_lfsPool.Pop();
        if (pCCtx == NULL)
        {
            // allocate 1k for buffer.
            BYTE *pbAlloc = new BYTE[1024];
            if (pbAlloc == NULL)
            {
                return NULL;
            }
            
            pCCtx = new CAccelerationClientReceiveContext();
            if (pCCtx == NULL)
            {
                delete[] pbAlloc;
                return NULL;
            }

            pCCtx->m_pbAlloc = pbAlloc;
            pCCtx->m_cbAlloc = 1024;
        }
        else
        {
            g_Counters.DecrementValue32(ACCELERATION_CONTEXTPOOL_NUM_FREE, 1);
        }

        pCCtx->Init(pCCliConn, dwBufSize);

        return pCCtx;
    }
    
protected:

    TLFStack<CAccelerationClientReceiveContext> m_lfsPool;
};

extern CAccelerationClientReceiveContextPool g_ContextPool;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\SocketConnect.cpp ===
#include "stdafx.h"

extern BOOL g_fServerTooBusy;

XomDefineArea(AccelerationClient);

HRESULT CAccelerationSocketListener::Init(DWORD cProcessors)
{
    HRESULT hr = S_OK;
    sockaddr_in sa;

    // Create worker threads to deal with incoming network traffic
    hr = CCompletionPort::CreateInstance(
        cProcessors,  // dwConcurrancy
        cProcessors,  // dwThreadPoolSize
        THREAD_PRIORITY_HIGHEST,
        &m_pCCompPort );

    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_ACCELERATION_SOCKET_INIT_COMPLETION_PORT_FAILED, "Unrecoverable failure while initializing: CCompPort::CreateInstance failed (%X)", hr);
        goto lDone;
    }
    
    // Create our listening socket on the designated completion port
    hr = CServerSocket::CreateInstance(&m_pCListenSocket, m_pCCompPort, m_pCCompPort);
    if(FAILED(hr))
    {
       XomNtEvent(XEVENT_ACCELERATION_SOCKET_INIT_CREATE_INSTANCE_FAILED, "Unrecoverable failure while initializing: CServSocket::CreateInstance failed (%X)", hr);
       goto lDone;
    }
    
    memset(&sa, 0, sizeof(sa));
    
    sa.sin_family = AF_INET;

    sa.sin_port = htons(g_Config.GetListenPort());
    if (sa.sin_port == 0)
    {
        hr = E_UNEXPECTED;
        goto lDone;
    }
    
    hr = m_pCListenSocket->Init(IPPROTO_TCP, &sa, FALSE);
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_ACCELERATION_SOCKET_INIT_FAILED, "Unrecoverable failure while initializing: CServSocket::Init failed (%X)", hr);
        goto lDone;
    }
    
    hr = m_pCListenSocket->Listen(SOMAXCONN);
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_ACCELERATION_SOCKET_INIT_LISTEN_FAILED, "Unrecoverable failure while initializing: CServSocket::Listen failed (%X)", hr);
        goto lDone;
    }
    
    hr = m_pCListenSocket->Accept(this, 0x12345678);
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    hr = S_OK;

lDone:

    return hr;
}

void CAccelerationSocketListener::Shutdown()
{
    SAFE_SHUTRELEASE(m_pCCompPort);
    SAFE_RELEASE(m_pCListenSocket);
}

void CAccelerationSocketListener::OnSocketAccept(
     CServerSocket *pCListenSocket,
     CServerSocket *pCAcceptedSocket,
     sockaddr_in *pLocalAddr,
     sockaddr_in *pRemoteAddr,
     HRESULT hrIn,
     QWORD qwCallbackArg )
{
    XOMASSERT(m_pCCompPort != NULL);
    XOMASSERT(m_pCListenSocket != NULL);

    HRESULT hr = hrIn;
    CAccelerationSocketConnection *pCConnection = NULL;

    // Check the incomming HRESULT
    if(HRESULT_FROM_WIN32( ERROR_OPERATION_ABORTED) == hr)
    {
        // Most likely case is that we're shutting down
        hr = S_OK;

        goto lDone;
    }
    else if (FAILED(hr))
    {
        goto lDone;
    }
    
    XOMASSERT( m_pCListenSocket == pCListenSocket );
    
    // Before anything else happens, accept a new connection
    hr = m_pCListenSocket->Accept( this, 0x12345678 );
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_ACCELERATION_SOCKET_ACCEPT_FAILED, "Error accepting new client hr=%X", hr );
        goto lDone;
    }
    
    XOMASSERT( NULL != pCAcceptedSocket );
    
    XomTrace(
        AccelerationClient,
        L_NORMAL,
        "Client connected addr=%s:%d",
        inet_ntoa( pRemoteAddr->sin_addr ), 
        ntohs( pRemoteAddr->sin_port ));
    
    // Allocate a new connection management class
    pCConnection = new CAccelerationSocketConnection;
    if( NULL == pCConnection )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Hand over control of the socket to the connection class
    hr = pCConnection->Init(pCAcceptedSocket);
    if( FAILED( hr ) )
    {
        goto lDone;
    }
    
    pCConnection = NULL;
        
lDone:
    SAFE_RELEASE(pCConnection);
}


// plugin for CTCPCntMessageBased.  returns the size of a message, given the start of that message.
int CTCPConnectionMessageBasedPlugin_Acceleration(const BYTE* pBuffer, const DWORD cbBuffer)
{
    if (cbBuffer < sizeof(ACCELERATION_MSG_HEADER))
    {
        return 0;        
    }
    
    ACCELERATION_MSG_HEADER *pMsg = (ACCELERATION_MSG_HEADER *)pBuffer;
    
    if (pMsg->dwMsgLen > CTCPConnection_RECEIVE_BUFFER_LENGTH)
    {
        if (cbBuffer < CTCPConnection_RECEIVE_BUFFER_LENGTH)
        {
            return 0;
        }
        
        return CTCPConnection_RECEIVE_BUFFER_LENGTH;
    }

    if (cbBuffer < pMsg->dwMsgLen)
    {
        return 0;
    }

    return pMsg->dwMsgLen;
}

CAccelerationSocketConnection::CAccelerationSocketConnection() :
    CTCPConnectionMessageBased(CTCPConnectionMessageBasedPlugin_Acceleration),
    m_pCCtx(NULL)
{
    memset(&m_sa, 0, sizeof(sockaddr_in));

    g_Counters.IncrementValue32(ACCELERATION_NUM_OPEN_CONNECTIONS, 1);
}

CAccelerationSocketConnection::~CAccelerationSocketConnection()
{
    g_Counters.DecrementValue32(ACCELERATION_NUM_OPEN_CONNECTIONS, 1);

    delete m_pCCtx;
}

HRESULT CAccelerationSocketConnection::Init(CServerSocket *pSocket)
{
    HRESULT hr = S_OK;

    // Validate arguments
    if(NULL == pSocket)
    {
        XOMASSERT(FALSE);
        return E_INVALIDARG;
    }
 
    hr = pSocket->GetPeerAddress( &m_sa );
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = Attach(pSocket);
    if (FAILED(hr))
    {
        goto lDone;
    }
    
lDone:
    return hr;
}


void CAccelerationSocketConnection::ProcessMessage(BYTE *pMsg, DWORD cbEntireMsg)
{
    if (pMsg == NULL)
    {
        XOMASSERT(FALSE);
        return;
    }

    XomTrace(
        AccelerationClient,
        L_NORMAL,
        "Message received from Client addr=%s:%d, size=%d",
        inet_ntoa( m_sa.sin_addr ), 
        ntohs( m_sa.sin_port ),
        cbEntireMsg);

    ACCELERATION_MSG_HEADER *pHeader = (ACCELERATION_MSG_HEADER *)pMsg;

    if (g_fServerTooBusy == TRUE)
    {
        XomTrace(
            AccelerationClient,
            L_NORMAL,
            "Server too busy -- rejecting message received from Client addr=%s:%d, size=%d",
            inet_ntoa( m_sa.sin_addr ), 
            ntohs( m_sa.sin_port ),
            cbEntireMsg);

        CTCPConnectionVarBuffer *pBuffer = g_pBufferPool->GetBuffer(sizeof(ACCELERATION_EMPTY_RESPONSE_MSG));
        if (pBuffer == NULL)
        {
            return;
        }
        ACCELERATION_EMPTY_RESPONSE_MSG *pResp = (ACCELERATION_EMPTY_RESPONSE_MSG *)pBuffer->GetBuffer();
        pResp->dwMsgLen = pBuffer->GetBufferLength();
        pResp->dwMsgType = XBMSG_EMPTY_RESP;
        pResp->dwProtocolVersion = ACCELERATION_PROTOCOL_VERSION;
        pResp->dwSeqNum = pHeader->dwSeqNum;

        pResp->hr = E_OUTOFMEMORY;

        Send(pBuffer);
        SAFE_RELEASE(pBuffer);

        return;
    }

    // support for message fragmenting.  we have to decode the message header here.
    if (pHeader->dwMsgType == XBMSG_CONTINUATION_REQ)
    {
        // this is a continuation of an existing request.  use the held context for it.
        if ((m_pCCtx == NULL) || 
            (((ACCELERATION_MSG_HEADER *)(m_pCCtx->m_pMsg))->dwSeqNum != pHeader->dwSeqNum))
        {
            // mismatched continuation!  how does this happen??
            XOMASSERT(FALSE);
            delete m_pCCtx;
            m_pCCtx = NULL;
            return;
        }

        // skip over the continuation header
        pMsg += sizeof(ACCELERATION_MSG_HEADER);
        cbEntireMsg -= sizeof(ACCELERATION_MSG_HEADER);
    }
    else
    {
        // we dont want to mess with the global data structures on a connection thread.  wrap the request in a context.

        m_pCCtx = g_ContextPool.Obtain(this, pHeader->dwMsgLen);
        if (m_pCCtx == NULL)
        {
            return;
        }
    }

    // copy this portion of the message.
    XOMASSERT(m_pCCtx->m_cbEntireMsg - (m_pCCtx->m_pWrite - m_pCCtx->m_pMsg) >= cbEntireMsg);
    memcpy(m_pCCtx->m_pWrite, pMsg, cbEntireMsg);
    m_pCCtx->m_pWrite += cbEntireMsg;

    if ((DWORD)(m_pCCtx->m_pWrite - m_pCCtx->m_pMsg) == m_pCCtx->m_cbEntireMsg)
    {
        // we have the whole messsage, post it now.
        g_Switchboard.PostCompletion(m_pCCtx);
        m_pCCtx = NULL;
    }
    // else hold on to the context for further fragments.
    
}

void CAccelerationSocketConnection::ProcessClientMessage(BYTE *pMsg, DWORD cbEntireMsg)
{
    if (pMsg == NULL)
    {
        XOMASSERT(FALSE);
        return;
    }

    ACCELERATION_MSG_HEADER *pRequest = (ACCELERATION_MSG_HEADER *)pMsg;
    if (cbEntireMsg != pRequest->dwMsgLen)
    {
        // something is wrong with CTCPConnectionMessageBasedPlugin_Acceleration !!
        XomNtEvent(XEVENT_ACCELERATION_SOCKET_SIZE_MISMATCH, "CSocketConnection::ProcessClientMessage() received message size does not match header (%d != %d)", cbEntireMsg, pRequest->dwMsgLen);
        return;
    }

    CAccelerationMessageProcessor msgProcessor;

    HRESULT hr = msgProcessor.ProcessAccelerationMessage(pRequest, this);
    if (FAILED(hr))
    {
        // arrgh??
        XomNtEvent(
            XEVENT_ACCELERATION_SOCKET_PROCESS_REQUEST_FAILED, 
            "CSocketConnection::ProcessClientMessage() failed to parse message from Client addr=%s:%d.  hr=0x%X, size=%d, type=%d, version=%d, seq=0x%X", 
            inet_ntoa( m_sa.sin_addr ), 
            ntohs( m_sa.sin_port ),
            hr,
            pRequest->dwMsgLen,
            pRequest->dwMsgType,
            pRequest->dwProtocolVersion,
            pRequest->dwSeqNum);
    }

    // update counter
    g_Counters.IncrementValue32(ACCELERATION_REQUEST_MESSAGE_RATE, 1);
}

void CAccelerationClientReceiveContext::CompletionProc()
{
    XOMASSERT( NULL != m_pCCliConn );

    // we're on the switchboard thread now, so we can safely process the message.
    m_pCCliConn->ProcessClientMessage(m_pMsg, m_cbEntireMsg);

    g_ContextPool.Insert(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\StdAfx.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once

// Disable warning: unreferenced formal parameter
#pragma warning( disable : 4100 )
// Disable warning: conditional expression is constant
#pragma warning( disable : 4127 )

#include <winsock2.h>
#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <stdlib.h>
#include <icecap.h>
#include <atlbase.h>
#include <atlcom.h>
#include <math.h>
#include <psapi.h>

#ifndef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(x) (sizeof(x) / sizeof(x[0]))
#endif

// Return the difference between two DWORDs, accounting for wrapping.
// Useful for finding the elapsed time between calls to GetTickCount.
#define TICK_DIFF(dwEnd, dwStart) (((dwEnd) >= (dwStart)) ? ((dwEnd) - (dwStart)) : ((dwStart) - (dwEnd)))


#define XAlloc(nSize) _aligned_malloc(nSize, MEMORY_ALLOCATION_ALIGNMENT)
#define XFree(pv) if (pv != NULL) _aligned_free(pv)
#define XDumpLeaks()
//#include "xalloc.h"

#include "wmsstd.h"
#include "xmgmt.h"
//#include "xlocks.h"
#include "ntservice.h"
#include "servsock.h"
#include "tcpconnection.h"
#include "addref.h"
#include <vptrarr.h>
#include "wsockntp.h"
#include "xonlinep.h"
#include "xeventids.h"
#include "AccelPerf.h"
#include "AccelerationperfCtrs.h"
#include "svrspec.h"

#import "mscorlib.tlb" raw_interfaces_only, no_smart_pointers, rename("ReportEvent", "__ReportEvent")
#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblConfig;

#import "XblHealthcheck.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblHealthcheck;

#include "cutil.h"
#include "NYCLock.h"
#include "bufferpool.h"
#include "memmgr.h"
#include "ConfigListener.h"
#include "AccelerationConfig.h"
#include "LookupTable.h"
#include "Protocol.h"
#include "AccelerationData.h"
#include "MRUList.h"
#include "Changelist.h"
#include "Switchboard.h"
#include "SocketConnect.h"
#include "Callback.h"

extern BOOL g_fServerTooBusy;
extern WCHAR *g_wszComponent;

void * __cdecl operator new(size_t len);
void __cdecl operator delete(void *pv);

CHAR *GetComponentNameA();
WCHAR *GetComponentNameW();


XomImportArea(AccelerationDebug);
XomImportArea(AccelerationClient);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\TCPConnection.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved

Module Name:

  tcpcnt.h

Abstract:

  This file contains classes to help dealing with TCP connections. All classes
  use CServerSocket (servsock.h) and CCompletionPort (compport.h).

  CTCPConnection provides basic connect, send and receive functionality.

  CTCPConnectionMessageBased inherits from CTCPConnection and provides message parsing and
  processing.

  CTCPConnectionBuffer is a pure virtual class (interface) that buffers passed to 
  CTCPConnection and its other derived classes must implement.

  CTCPConnectionTemplateBuffer is a template for fixed size buffers that inherit from
  CTCPConnectionBuffer and it's usually enough for most cases.

--*/

#ifndef _TCPCONNECTION_H_
#define _TCPCONNECTION_H_

#include "servsock.h"
#include "addref.h"
#include <vptrlist.h>
#include <xlocks.h>

class CTCPConnection;
class CTCPConnectionBuffer;

#define CTCPConnection_RECEIVE_BUFFER_LENGTH 0x4000
    // Maximum receive buffer length

/******************************************************************************

  CTCPConnection

  Provides basic TCP connection services.

  You can create and initialize a CServerSocket object and call AttachAndConnect 
  to start the connection process. Or if you have a CServerSocket that is 
  already connected, for example from a successfull Accept, you can simply
  call Attach.

  Use Send to queue buffers to be sent to the destination. The buffers must be
  objects from classes that implement the interface CTCPConnectionBuffer. 

  Override any of the virtual methods if you want to process incoming data, 
  perform some custom task on Connect or Disconnect, etc..

******************************************************************************/

class CTCPConnection :
    public CServerSocketCallback,
    public CAddRefable

{
public:

    IMPLEMENT_REFCOUNT;

    // Constructor
    
    CTCPConnection();
    
    // Public methods. Check out implementation for details.
    
    HRESULT Attach(
        CServerSocket* pSocket );

    HRESULT AttachAndConnect(
        CServerSocket* pSocket,
        sockaddr_in* pAddr );

    virtual HRESULT Send(
        CTCPConnectionBuffer* pBuffer );

    void Disconnect(
        HRESULT hr );

    bool IsConnected()
    {
        return m_eState != S_NOT_CONNECTED;
    }

    bool IsSending()
    {
        return (m_fSending != FALSE);
    }

    void SetDebugName(LPCSTR pszName)
    {
        strncpy(m_szDebugName, pszName, sizeof(m_szDebugName)/sizeof(m_szDebugName[0]));
    }

    const sockaddr_in* GetSockAddr() { return &m_sinOut; }

protected:

    virtual HRESULT InternalInit(
        CServerSocket* pSocket,
        sockaddr_in* psin );

    // Destructor
    
    virtual ~CTCPConnection();
        // Destructor is protected. The only way to release this object is by
        // calling Release.

    // CTCPConnection virtuals. Override these and be cool. For more info, check the 
    // implementation.
    
    virtual void OnConnect();

    virtual void OnDisconnect(
        HRESULT hrReason );

    virtual void OnDone();
    
    virtual void ParseReceiveBuffer(
        BYTE* pBuffer,
        DWORD* pcbBuffer );

    // Protected methods. Check out implementation for details.
    
    HRESULT StartReceiving();

    // CServerSocketCallback virtuals. 

    virtual void OnSocketConnect(
        HRESULT hr,
        QWORD qwCallbackArg );

    virtual void OnSocketAccept(
        CServerSocket *pListenSocket,
        CServerSocket *pAcceptedSocket,
        sockaddr_in *pLocalAddr,
        sockaddr_in *pRemoteAddr,
        HRESULT hr,
        QWORD qwCallbackArg ) {}

    virtual void OnSocketSend(
        BYTE *pbBufferSent,
        DWORD cbToSend,
        DWORD cbSent,
        HRESULT hrSend,
        QWORD qwCallbackArg );

    virtual void OnSocketSendTo(
        BYTE *pbBufferSent,
        DWORD cbToSend,
        DWORD cbSent,
        HRESULT hr,
        QWORD qwCallbackArg ) {}

    virtual void OnSocketReceive(
        BYTE *pbFilledInBuffer,
        DWORD cbRead,
        HRESULT hrReceive,
        QWORD qwCallbackArg );

    virtual void OnSocketReceiveFrom(
        BYTE *pbFilledInBuffer,
        DWORD cbRead,
        sockaddr_in *pFilledInFrom,
        HRESULT hr,
        QWORD qwCallbackArg ) {}

    virtual void OnSocketClose(
        HRESULT hr,
        QWORD qwCallbackArg ) {}

    // Connection enumerated states
    
    enum STATE {
    
        S_NOT_CONNECTED,
            // Not connected. 

        S_CONNECTING,
            // In the process of connecting. 

        S_CONNECTED
            // Connected
    };
    
    CServerSocket* m_pSocket;
        // The socket this object is encapsulating.

    STATE m_eState;
        // Current state of this object.

    BYTE m_rgbBuffer[CTCPConnection_RECEIVE_BUFFER_LENGTH];
        // Used to receive data.

    DWORD m_dwBufferConsumed;
        // Amount of m_rgbBuffer used. In bytes.

    volatile LONG m_fSending;
        // Send pending?

    volatile LONG m_fReceiving;
        // Receiving?

    sockaddr_in m_sinOut;
        // Address of destination

    char m_szDebugName[32];
        // A debug name that will be used in trace statements.
};

/******************************************************************************

  CTCPConnectionMessageBased

  Provides CTCPConnection functionality plus incoming message parsing.

  CTCPConnectionMessageBased was designed to work with almost any kind of message
  oriented protocol. It allows the developer to specify it's own way to 
  define the message size. Just pass one of the CTCPConnectionMessageBasedPlugin_*
  functions in the GetMessageSize template parameter or write your own.
  
  E.g. CTCPConnectionMessageBased<CTCPConnectionMessageBasedPlugin_VerySimple> will handle
  messages where the first DWORD contains the total size of the message.

  Then override ProcessMessage to process your own messages.

  The maximum message size is limited to the receive buffer size of CTCPConnection
  which is defined by the constant CTCPConnection_RECEIVE_BUFFER_LENGTH.

******************************************************************************/

typedef int (*CTCPConnectionMessageBasedPlugin)(const BYTE *pbBuffer, const DWORD cbBuffer);

class CTCPConnectionMessageBased
    : public CTCPConnection
{
public:

    CTCPConnectionMessageBased(CTCPConnectionMessageBasedPlugin pMessagePlugin) :
        m_pfParseMessage(pMessagePlugin)
    {
    }
    
    virtual void ProcessMessage(
        BYTE* pMsg,
        DWORD cbMsg ) = 0;
        // Override me to process the incoming messages. 
        // pMsg points to the message buffer.
        // cbMsg contains the size of the message pointed by pMsg.
        // You're allowed to change the buffer's content up to cbMsg bytes.

    // CTCPConnection virtuals

    virtual void ParseReceiveBuffer(
        BYTE* pBuffer,
        DWORD* pcbBuffer )
        // Parses the incoming data into messages. Each message will
        // generate one call to ProcessMessage.
    {
        HRESULT hr = S_OK;
        
        int cbParsed = 0;
        int cbAvailable = 0;

        for(;;)
        {
            cbAvailable = (int) (*pcbBuffer - cbParsed);
            
            // I'm using ints here instead of DWORDs because cbAvailable
            // could become negative if ProcessMessage ended up calling 
            // Disconnect
            
            int cbMessageSize = m_pfParseMessage(pBuffer + cbParsed, cbAvailable);

            if(0 == cbMessageSize)
            {
                // We haven't read enough to parse a message. Come back later.

                break;
            }

            if( cbMessageSize > CTCPConnection_RECEIVE_BUFFER_LENGTH ||
                cbMessageSize < 0 )
            {
                //
                // Message is bigger than we could ever parse.
                //
                
                hr = E_FAIL;

                //XomTrace(
                //    ServHlpDebug,
                //    L_NORMAL,
                //    "[CTCPConnection::ParseReceiveBuffer] message is bigger than parsing buffer");
                
                goto lDone;
            }

            if(cbMessageSize > cbAvailable)
            {
                //
                // We haven't read the entire message yet.
                //

                break;
            }

            ProcessMessage(pBuffer + cbParsed, (DWORD) cbMessageSize);

            cbParsed += cbMessageSize;
        }
        
        //
        // Move the remainder of the receive buffer to the beginning. This 
        // shouldn't happen very often and shouldn't suck if the messages 
        // sizes are relatively small.
        //
        
        if(cbAvailable > 0)
        {
            XOMASSERT(cbAvailable + cbParsed <= CTCPConnection_RECEIVE_BUFFER_LENGTH);
            memmove(pBuffer, pBuffer + cbParsed, cbAvailable);
        }

        *pcbBuffer = cbAvailable;
        
    lDone:

        if(FAILED(hr))
        {
            Disconnect(hr);
        }
    }

protected:

    CTCPConnectionMessageBasedPlugin m_pfParseMessage;
};

/******************************************************************************

  CTCPConnectionMessageBased plugins

  Use these plugins to adjust CTCPConnectionMessageBased to your protocol... or write
  your own

******************************************************************************/

// CTCPConnectionMessageBasedPlugin_VerySimple
// Use this one if the length of the messages of your protocol are the first
// thing in the message and has the size of a DWORD in host byte order (as
// opposed to network byte order).
  
int CTCPConnectionMessageBasedPlugin_VerySimple(const BYTE* pBuffer, const DWORD cbBuffer)
{
    if(cbBuffer < sizeof(DWORD))
        return 0;

    return (int) *((DWORD*)pBuffer);
}


/******************************************************************************

  CTCPConnectionBuffer

  Buffers passed to CTCPConnection::Send must inherit from this class. This class 
  is pure virtual (interface like) and is not good by itself. Try using its
  derived classes or write your own.

******************************************************************************/

class CTCPConnectionBuffer :
    public CAddRefable
{
public:

    virtual BYTE* GetBuffer() = 0;

    virtual DWORD GetBufferLength() = 0;

    // CONSIDER: Stash off the send list node in here
};

/******************************************************************************

  CTCPConnectionTemplateBuffer

  Use this if you use fixed buffer sizes. Pass the size in SIZE and you're
  all set.

******************************************************************************/

template <int SIZE>
class CTCPConnectionTemplateBuffer :
    public CTCPConnectionBuffer
{
public:

    IMPLEMENT_REFCOUNT;
    
    CTCPConnectionTemplateBuffer()
    {
        m_cbMsgBuffer = 0;
    }
    
    void *operator new(size_t len) { return XAlloc(len); }
    void operator delete(void *pv) { XFree(pv); }

    void SetSize(DWORD cbSize)
    {
        XOMASSERT(cbSize <= SIZE);
        m_cbMsgBuffer = cbSize;
    }

    DWORD GetMaxSize()
    {
        return SIZE;
    }
    
    // CTCPPumpBuffer virtuals
    
    virtual BYTE* GetBuffer()
    {
        return m_rgbMsgBuffer;
    }

    virtual DWORD GetBufferLength()
    {
        return m_cbMsgBuffer;
    }

protected:    

    ~CTCPConnectionTemplateBuffer()
        // Destructor is protected. The only way to release this object is by
        // calling Release.
    {
    }

    BYTE m_rgbMsgBuffer[SIZE];
    DWORD m_cbMsgBuffer;
};


/******************************************************************************

  CTCPConnectionVarBuffer

  Use this if you use variable buffer sizes. Constuct with static member
  CreateInstance.

******************************************************************************/
class CTCPConnectionVarBuffer :
    public CTCPConnectionBuffer
{
public:

    IMPLEMENT_REFCOUNT;

    static CTCPConnectionVarBuffer * __stdcall CreateInstance(DWORD cbBuffer)
    {
        CTCPConnectionVarBuffer *pCRet;

        pCRet = (CTCPConnectionVarBuffer *) XAlloc(cbBuffer + sizeof(CTCPConnectionVarBuffer));
        if (pCRet == NULL)
        {
            return NULL;
        }
        else
        {
            pCRet->CTCPConnectionVarBuffer::CTCPConnectionVarBuffer();
            pCRet->m_cbBuffer = cbBuffer;
            return pCRet;
        }
    }

    CTCPConnectionVarBuffer *Resize(DWORD cbBuffer)
    {
        if (cbBuffer <= m_cbBuffer)
        {
            m_cbBuffer = cbBuffer;
            return this;
        }
        else
        {
            return NULL;
        }
    }    
    
    void operator delete(void *pv) { XFree(pv); }
    
    // CTCPPumpBuffer virtuals

    virtual BYTE* GetBuffer()
    {
        return (BYTE *)(this + 1);
    }

    virtual DWORD GetBufferLength()
    {
        return m_cbBuffer;
    }

protected:
    
    void *operator new(size_t len) { return NULL; }

    DWORD m_cbBuffer;
};


#endif // #ifndef _TCPCNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\Switchboard.h ===
#pragma once

extern CAccelerationConfig g_Config;

// base class for completion port work item contexts.
class CLocalContext : 
    public CCompletionContext, 
    public CCompletionHandler
{
public:
    CLocalContext() : 
        m_dwTime( 0 )
    {
    }
    virtual ~CLocalContext()
    {
    }

    IMPLEMENT_REFCOUNT

    virtual void OnIoCompletion( 
        DWORD dwError, 
        DWORD cbTransferred, 
        ULONG_PTR ulpKey,
        CCompletionContext *pCtx )
    {
        XOMASSERT(pCtx == this);

        // update counters for the wait time.
        RecordWaitTime();

        // start tracking the processing time.
        DWORD dwStartTime = GetTickCount();

        // call the overriden proc.
        CompletionProc();

        // calculate the processing time.
        DWORD dwElapsed = TICK_DIFF(GetTickCount(), dwStartTime);
        g_Counters.IncrementValue64(ACCELERATION_SWITCHBOARD_CONTEXT_TIME_AVERAGE, dwElapsed);
        g_Counters.IncrementValue32(ACCELERATION_SWITCHBOARD_CONTEXT_TIME_BASE, 1);

        // did we take too long?
        if (dwElapsed > g_Config.GetContextDurationAlertLimit())
        {
            XomNtEvent(XEVENT_ACCELERATION_WARN_0, "CLocalContext::OnIoCompletion - switchboard context took too long to process! (%d ms, desc='%s')", dwElapsed, GetDescription());
        }

        // release the switchboard reference.
        Release();
    }

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    // implemented by derived classes.  performs whatever action was intended for the switchboard thread.
    virtual void CompletionProc() = 0;

    // implemented by derived classes.  returns a string describing the context.
    virtual char *GetDescription() = 0;

    // used for tracking the wait time of each context.
    void SetPostTime() 
    {
        XOMASSERT( 0 == m_dwTime ); 
        m_dwTime = GetTickCount(); 
        if (m_dwTime == 0)
        {
            m_dwTime = 1;
        }
    }

protected:
    
    void RecordWaitTime() 
    { 
        XOMASSERT( 0 != m_dwTime ); 

        // calculate the wait time.
        DWORD dwElapsed = TICK_DIFF(GetTickCount(), m_dwTime); 
        
        // update wait time average counter
        g_Counters.IncrementValue64(ACCELERATION_SWITCHBOARD_WAIT_TIME_AVERAGE, dwElapsed);
        g_Counters.IncrementValue32(ACCELERATION_SWITCHBOARD_WAIT_TIME_BASE, 1);

        // update context rate counter
        g_Counters.IncrementValue32(ACCELERATION_SWITCHBOARD_COMPLETION_RATE, 1);

        // reset the post time.
        m_dwTime = 0; 
    }

    DWORD m_dwTime;
};

class CAccelerationSwitchboard
{
public:

    // constructor
    CAccelerationSwitchboard()
    {
        m_pCompPort = NULL;
    }

    // destructor
    ~CAccelerationSwitchboard()
    {
        Close();
    }

    HRESULT Init(DWORD cProcessors)
    {
        HRESULT hr = S_OK;

        // Create our completion port with a single high-priority thread.
        hr = CCompletionPort::CreateInstance(
            cProcessors - 1,  // dwConcurrancy
            cProcessors - 1,  // dwThreadPoolSize
            THREAD_PRIORITY_HIGHEST,
            &m_pCompPort );    
        if(FAILED(hr))
        {
            goto lDone;
        }

    lDone:

        if (FAILED(hr))
        {
            // clean up anything we were able to do before failing.
            Close();
        }
        
        return hr;
    }

    HRESULT Close()
    {
        SAFE_RELEASE(m_pCompPort);

        return S_OK;
    }

    // queues a work item for this switchboard.    
    HRESULT PostCompletion(CLocalContext *pCCtx)
    {
        // add a reference for the switchboard.
        pCCtx->AddRef();

        // track the start time of the wait.
        pCCtx->SetPostTime();

        // queue the context.
        return m_pCompPort->PostCompletion(pCCtx);
    }
   
protected:

    // completion port
    CCompletionPort *m_pCompPort;
};

extern CAccelerationSwitchboard g_Switchboard;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\inh\TCPConnection.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved

Module Name:

    TCPConnection.cpp

Abstract:


--*/

#include "stdafx.h"


XomDefineArea(TCPConnection);
    // Debug area

/////////////////////////////////////////////////////////////////////////////    
CTCPConnection::CTCPConnection()
{
    m_pSocket = NULL;
    m_eState = S_NOT_CONNECTED;
    m_dwBufferConsumed = 0;
    m_fSending = FALSE;
    m_fReceiving = FALSE;
    ZeroMemory(&m_sinOut, sizeof(m_sinOut));
    m_szDebugName[0] = '\0';
}

/////////////////////////////////////////////////////////////////////////////
CTCPConnection::~CTCPConnection()
{
    Disconnect(S_OK);

    SAFE_RELEASE(m_pSocket);
}

/////////////////////////////////////////////////////////////////////////////
void CTCPConnection::OnConnect() {}

/////////////////////////////////////////////////////////////////////////////
void CTCPConnection::OnDisconnect( HRESULT hrReason ) {}

/////////////////////////////////////////////////////////////////////////////
void CTCPConnection::OnDone() {}

/////////////////////////////////////////////////////////////////////////////
void CTCPConnection::ParseReceiveBuffer(
    BYTE* pBuffer,
    DWORD* pcbBuffer
)
{
    //
    // The default implementation doesn't do anything with the buffer
    //

    *pcbBuffer = 0;
    
    return;
}


/////////////////////////////////////////////////////////////////////////////
HRESULT CTCPConnection::Attach(
    CServerSocket* pSocket
)
{
    return AttachAndConnect(pSocket, NULL);
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CTCPConnection::AttachAndConnect(
    CServerSocket* pSocket,
    sockaddr_in* pAddr
)
{
    HRESULT hr = S_OK;
    
    hr = InternalInit(pSocket, pAddr);
    
    if(FAILED(hr))
    {
        XomTrace(
            TCPConnection,
            L_NORMAL,
            "[CTCPConnection::AttachAndConnect] (%s) InternalInit failed, hr = 0x%08x", 
            m_szDebugName, hr);

        //
        // We failed so we're not keeping the socket connection object.
        //    
        
        goto lDone;
    }

lDone:

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CTCPConnection::InternalInit(
    CServerSocket* pSocket,
    sockaddr_in* psin
)
{
    HRESULT hr = S_OK;

    if(m_pSocket != NULL)
    {
        XomTrace(
            TCPConnection,
            L_ERROR,
            "[CTCPConnection::InternalInit] (%s) Object cannot be reused", 
            m_szDebugName);

        XOMASSERT(!"[CTCPConnection::InternalInit] Object cannot be reused");

        hr = E_UNEXPECTED;

        goto lDone;
    }
    
    m_pSocket = pSocket;
    m_pSocket->AddRef();

    if(psin)
    {
        memcpy(&m_sinOut, psin, sizeof(m_sinOut));
        
        //
        // Socket needs to be connected before we can start using it.
        //
        
        AddRef();
        
        m_eState = S_CONNECTING;

        hr = m_pSocket->Connect(psin, this, 0);

        if(FAILED(hr))
        {
            Release();

            XomTrace(
                TCPConnection,
                L_ERROR,
                "[CTCPConnection::Init] (%s) m_pSocket->Connect failed, hr=0x%08x",
                m_szDebugName, hr);
            
            goto lDone;
        }
    }
    else
    {
        //
        // Socket is connected and ready for use.
        //

        hr = m_pSocket->GetPeerAddress(&m_sinOut);

        if(FAILED(hr))
        {
            XomTrace(TCPConnection, L_ERROR,
                "[CTCPConnection::InternalInit] (%s) m_pSocket->GetPeerAddress failed, hr = 0x%08x", 
                m_szDebugName, hr);
            goto lDone;
        }

        m_eState = S_CONNECTED;

        hr = StartReceiving();

        if(FAILED(hr))
        {
            XomTrace(
                TCPConnection,
                L_ERROR,
                "[CTCPConnection::Init] (%s) StartReceiving failed, hr=0x%08x",
                m_szDebugName, hr);
            goto lDone;
        }            
    }

lDone:

    if(FAILED(hr))
    {
        Disconnect(hr);
    }

    if(SUCCEEDED(hr))
    {
        XomTrace(TCPConnection, L_NORMAL,
            "[CTCPConnection::InternalInit] (%s) Attaching socket, addr = "DBGSINFMT", hr = 0x%08x",
            m_szDebugName, DBGSINPRM(&m_sinOut), hr);
    }
    else
    {
        XomTrace(TCPConnection, L_ERROR,
            "[CTCPConnection::InternalInit] (%s) Attaching socket, addr = "DBGSINFMT", hr = 0x%08x",
            m_szDebugName, DBGSINPRM(&m_sinOut), hr);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
void CTCPConnection::Disconnect(
    HRESULT hr
)
{
    //
    // Make sure that only one thread will make through.
    //
    
    if(InterlockedExchange((LONG*) &m_eState, S_NOT_CONNECTED) != S_NOT_CONNECTED)
    {
        XomTrace(TCPConnection, L_NORMAL, 
            "[CTCPConnection::Disconnect] (%s) Disconnecting from "DBGSINFMT" with hr = 0x%08x", 
            m_szDebugName,
            DBGSINPRM(&m_sinOut), hr);

        //
        // Cancel pending operations
        //
        
        if(m_pSocket)
        {
            m_pSocket->Close();
        }

        // Send Notification of disconnect
        OnDisconnect(hr);
    }

    return;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CTCPConnection::Send(
    CTCPConnectionBuffer* pBuffer
)
{
    HRESULT hr = S_OK;
    DWORD dwOldEnd;
    DWORD dwNewEnd;
    
    if(S_NOT_CONNECTED == m_eState)
    {
        //
        // Not connected (nor connecting)
        //

        hr = E_FAIL;

        XomTrace(TCPConnection, L_ERROR, 
            "[CTCPConnection::Send] (%s) Cannot start sending without connecting first",
            m_szDebugName);
        
        goto lDone;
    }

    pBuffer->AddRef();

    AddRef();

    hr = m_pSocket->Send(pBuffer->GetBuffer(), pBuffer->GetBufferLength(), this, (QWORD)pBuffer);
    
    if(FAILED(hr))
    {
        Release();
        
        XomTrace(
            TCPConnection,
            L_ERROR,
            "[CTCPConnection::Send] (%s) m_pSocket->Send failed, hr=0x%08x", 
            m_szDebugName, 
            hr);

        goto lDone;
    }                

lDone:

    if(FAILED(hr))
    {
        Disconnect(hr);
    }

    if(SUCCEEDED(hr))
    {
        XomTrace(TCPConnection, L_LOW,
            "[CTCPConnection::Send] (%s) Sending, addr = "DBGSINFMT", hr = 0x%08x",
            m_szDebugName,
            DBGSINPRM(&m_sinOut), hr);
    }
    else
    {
        XomTrace(TCPConnection, L_ERROR,
            "[CTCPConnection::Send] (%s) Sending, addr = "DBGSINFMT", hr = 0x%08x",
            m_szDebugName,
            DBGSINPRM(&m_sinOut), hr);
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
void CTCPConnection::OnSocketConnect(
    HRESULT hr,
    QWORD qwCallbackArg 
)
{
    if(FAILED(hr))
    {
        goto lDone;
    }

    InterlockedExchange((LONG*) &m_eState, (LONG)S_CONNECTED);

    hr = StartReceiving();

    if(FAILED(hr))
    {
        XomTrace(
            TCPConnection,
            L_ERROR,
            "[CTCPConnection::Init] (%s) StartReceiving failed, hr=0x%08x",
            m_szDebugName,
            hr);

        goto lDone;
    }            

    OnConnect();
    
lDone:
    
    if(FAILED(hr))
    {
        Disconnect(hr);
    }

    if(SUCCEEDED(hr))
    {
        XomTrace(TCPConnection, L_NORMAL,
            "[CTCPConnection::OnSocketConnect] (%s) OnConnect, addr = "DBGSINFMT", hr = 0x%08x",
            m_szDebugName,
            DBGSINPRM(&m_sinOut), hr);
    }
    else
    {
        XomTrace(TCPConnection, L_ERROR,
            "[CTCPConnection::OnSocketConnect] (%s) OnConnect, addr = "DBGSINFMT", hr = 0x%08x",
            m_szDebugName,
            DBGSINPRM(&m_sinOut), hr);
    }

    Release();
}

/////////////////////////////////////////////////////////////////////////////
void CTCPConnection::OnSocketSend(
    BYTE *pbBufferSent,
    DWORD cbToSend,
    DWORD cbSent,
    HRESULT hrSend,
    QWORD qwCallbackArg 
)
{
    CTCPConnectionBuffer* pBuffer = (CTCPConnectionBuffer*)qwCallbackArg;
    pBuffer->Release();

    if(FAILED(hrSend))
    {
        Disconnect(hrSend);
    }

    if(SUCCEEDED(hrSend))
    {
        XomTrace(TCPConnection, L_LOW,
            "[CTCPConnection::OnSocketSend] (%s) OnSend, addr = "DBGSINFMT", %d bytes, hr = 0x%08x",
            m_szDebugName,
            DBGSINPRM(&m_sinOut), cbSent, hrSend);
    }
    else
    {
        XomTrace(TCPConnection, L_ERROR,
            "[CTCPConnection::OnSocketSend] (%s) OnSend, addr = "DBGSINFMT", %d bytes, hr = 0x%08x",
            m_szDebugName,
            DBGSINPRM(&m_sinOut), cbSent, hrSend);
    }

    Release();
}

/////////////////////////////////////////////////////////////////////////////
void CTCPConnection::OnSocketReceive(
    BYTE *pbFilledInBuffer,
    DWORD cbRead,
    HRESULT hrReceive,
    QWORD qwCallbackArg 
) 
{
    HRESULT hr = S_OK;

    InterlockedExchange(&m_fReceiving, FALSE);

    if(SUCCEEDED(hrReceive) && (cbRead != 0))
    {
        //
        // Compute received data in our "to be processed" total.
        //
        
        m_dwBufferConsumed += cbRead;

        if(m_dwBufferConsumed > CTCPConnection_RECEIVE_BUFFER_LENGTH)
        {
            hr = E_UNEXPECTED;

            XomTrace(
                TCPConnection,
                L_ERROR,
                "[CTCPConnection::OnSocketReceive] (%s) m_dwBufferConsumed > CTCPConnection_RECEIVE_BUFFER_LENGTH",
                m_szDebugName);

            XOMASSERT(!"[CTCPConnection::OnSocketReceive] m_dwBufferConsumed > CTCPConnection_RECEIVE_BUFFER_LENGTH");

            goto lDone;
        }

        //
        // Ask daddy to parse it
        //
        
        ParseReceiveBuffer(m_rgbBuffer, &m_dwBufferConsumed);

        if((int) (CTCPConnection_RECEIVE_BUFFER_LENGTH - m_dwBufferConsumed) <= 0)
        {
            hr = E_FAIL;

            XomTrace(
                TCPConnection,
                L_ERROR,
                "[CTCPConnection::OnSocketReceive] (%s) Receive buffer is completely full after ParseReceiveBuffer. Disconnecting.",
                m_szDebugName);
            
            goto lDone;
        }

        //
        // And keep going
        //
        
        hr = StartReceiving();

        if(FAILED(hr))
        {
            XomTrace(
                TCPConnection,
                L_ERROR,
                "[CTCPConnection::OnSocketReceive] (%s) StartReceiving failed, hr=0x%08x",
                m_szDebugName,
                hr);

            goto lDone;
        }            
    }

lDone:
    
    if(FAILED(hr) || (cbRead == 0))
    {
        Disconnect(hr);
    }

    if(SUCCEEDED(hr))
    {
        XomTrace(TCPConnection, L_LOW,
            "[CTCPConnection::OnSocketReceive] (%s) OnReceive, addr = "DBGSINFMT", %d bytes, hr = 0x%08x",
            m_szDebugName,
            DBGSINPRM(&m_sinOut), cbRead, hrReceive);
    }
    else
    {
        XomTrace(TCPConnection, L_ERROR,
            "[CTCPConnection::OnSocketReceive] (%s) OnReceive, addr = "DBGSINFMT", %d bytes, hr = 0x%08x",
            m_szDebugName,
            DBGSINPRM(&m_sinOut), cbRead, hrReceive);
    }

    Release();
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CTCPConnection::StartReceiving()
{
    HRESULT hr = S_OK;
    
    if(    m_eState != S_CONNECTED )
    {
        //
        // Socket disconnected or connecting. Can't start receiving.
        //
        
        goto lDone;
    }

    if(InterlockedCompareExchange(&m_fReceiving, TRUE, FALSE) != FALSE)
    {
        // Already receiving

        goto lDone;
    }

    AddRef();
    
    hr = m_pSocket->Receive(m_rgbBuffer + m_dwBufferConsumed, 
        CTCPConnection_RECEIVE_BUFFER_LENGTH - m_dwBufferConsumed, this, 0);

    if(FAILED(hr))
    {
        InterlockedExchange(&m_fReceiving, FALSE);
        Release();

        XomTrace(
                TCPConnection,
                L_ERROR,
                "[CTCPConnection::StartReceiving] (%s) m_pSocket->Receive failed, hr = 0x%08x",
                m_szDebugName,
                hr);
        
        goto lDone;
    }

lDone:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\AccelFuncConcurrency.cs ===
using System;
using ServerTestFramework;
using xonline.common.service;


namespace AccelTest
{
     public class AccelFuncConcurrency : TestNode
     {
          [TestCase, Description("Mainline concurrency test")]
          class P_Mainline : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key;
                    byte[] value;
                    CreateKeyValuePair(out key, out value);

                    uint hr;
                    uint validSeconds;
                    uint version;
                    byte[] outValue;
                    
                    ValidateHResult(hr = _xb.Query(key, out outValue, out validSeconds, out version), HResult.S_FALSE);
                    ValidateVersion(version, 0);

                    version = 1;
                    ValidateHResult(hr = _xb.SetData(key, value, 0, 0, ref version), HResult.E_ACCESSDENIED);
                    ValidateVersion(version, 0);
                    ValidateHResult(hr = _xb.Query(key, out outValue, out validSeconds, out version), HResult.S_FALSE);
                    ValidateVersion(version, 0);

                    version = 0;
                    ValidateHResult(hr = _xb.SetData(key, value, 0, 0, ref version), HResult.S_OK);
                    ValidateVersion(version, 1);
                    ValidateHResult(hr = _xb.Query(key, out outValue, out validSeconds, out version), HResult.S_OK);
                    ValidateReturnedData(value, outValue);
                    ValidateVersion(version, 1);

                    version = 0;
                    ValidateHResult(hr = _xb.SetData(key, value, 0, 0, ref version), HResult.E_ACCESSDENIED);
                    ValidateVersion(version, 1);
                    ValidateHResult(hr = _xb.Query(key, out outValue, out validSeconds, out version), HResult.S_OK);
                    ValidateReturnedData(value, outValue);
                    ValidateVersion(version, 1);

                    version = 1;
                    ValidateHResult(hr = _xb.SetData(key, value, 0, 0, ref version), HResult.S_OK);
                    ValidateVersion(version, 2);
                    ValidateHResult(hr = _xb.Query(key, out outValue, out validSeconds, out version), HResult.S_OK);
                    ValidateReturnedData(value, outValue);
                    ValidateVersion(version, 2);

                    _xb.Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
          
          [TestCase, Description("Forced overwrite concurrency test")]
          class P_ForcedOverwrite : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key;
                    byte[] value;
                    CreateKeyValuePair(out key, out value);

                    uint hr;
                    uint validSeconds;
                    uint version;
                    byte[] outValue;
                    
                    ValidateHResult(hr = _xb.Query(key, out outValue, out validSeconds, out version), HResult.S_FALSE);
                    ValidateVersion(version, 0);

                    version = 0;
                    ValidateHResult(hr = _xb.SetData(key, value, 0, 0, ref version), HResult.S_OK);
                    ValidateVersion(version, 1);
                    ValidateHResult(hr = _xb.Query(key, out outValue, out validSeconds, out version), HResult.S_OK);
                    ValidateReturnedData(value, outValue);
                    ValidateVersion(version, 1);
                    
                    ValidateHResult(hr = _xb.SetData(key, value), HResult.S_OK);
                    ValidateHResult(hr = _xb.Query(key, out outValue, out validSeconds, out version), HResult.S_OK);
                    ValidateReturnedData(value, outValue);
                    ValidateVersion(version, 2);
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
          
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\AccelFuncInsert.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;


namespace AccelTest
{
     public class AccelFuncInsert : TestNode
     {

          [TestCase, Description("Insert version 1 positive paramater testing")]
          class P_Mainline : AccelFuncTestBase
          {
                 /***** valid key, valid value *****/
               override protected void Execute()
               {
                    byte[] key = null;
                    byte[] value = null;
                    
                    CreateKeyValuePair(out key, out value);

                    InsertSingleItem(key, value);
                     //cleanup
                    Remove(key);

                    //Insert [][] overload
                    byte[][] key2 = null;
                    byte[][] value2 = null;
                    
                    CreateKeyValueArrayPair(out key2, out value2);

                    InsertMultipleItems(key2, value2);
                     //cleanup
                    Remove(key2);
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
                    
                    

          [TestCase, Description("Insert version 1 positive paramater testing")]
          class P_Keys_EdgeCases : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] tempkey = null;
                    byte[] value = null;
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);
                    
                    CreateKeyValuePair(out tempkey, out value);
                    /***** rest of valid key, valid value test cases *****/
                    //according to MSDN there is an implicit cast from integer literal to byte as long as the literal is < 256
                    byte[][] keyTable = { 
                                                            new byte[] {0,0,0,0},    //nonzero length key with no bits set
                                                            new byte[] {5},          // 1 byte length key
                                                            new byte[] {1,2,3,4,5,6,7,8}, //byte aligned key
                                                            new byte[] {1,2,3,4,5,6},     //non-byte aligned key
                                                            CreateKey( _maxKeyLength) // equal to max size key length
                                                       };
                                                       
                    foreach (byte[] key in keyTable)
                    {
                         InsertSingleItem(key, value);
                          //cleanup
                         Remove(key);
                    }

                     ResultCode = TEST_RESULTS.PASSED;
                    
               }
          }

            [TestCase]
           class P_KeyArray_EdgeCases : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint[] hr;
                    byte[][] key = new byte[2][];
                    key[0] = new byte[] {34};
                    key[1] = null;
                    byte[][] value = new byte[2][]; //just some random data
                    value[0] = new byte[] {25};
                    value[1] = new byte[] {45};
                    hr = _xb.Insert(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hr == null || hr.Length != 2)
                    {
                        throw new Exception("Insert did not return expected HR results");
                    }
                    if (hr[0] != HResult.E_ACCESSDENIED)
                    {
                        throw new HResultException(hr[0], "Insert returned "+hr[0]+" instead of E_ACCESSDENIED");
                    }
                    if (hr[1] != HResult.E_INVALIDARG)
                    {
                        throw new HResultException(hr[1], "Insert returned "+hr[1]+" instead of E_INVALIDARG");
                    }

                    key = new byte[100][];
                    value = new byte[100][];
                    for(int i=0; i<key.Length; i++)
                    {
                        key[i] = CreateKey();
                        value[i] = CreateValue();
                    }

                    InsertMultipleItems(key, value, new uint [key.Length], new uint [key.Length]);

                    //remove for cleanup
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;
                    
               }
          }

           [TestCase, Description("Insert version 1 positive paramater testing")]
          class P_Values_EdgeCases : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null;
                    byte[] tempvalue = null;
                    CreateKeyValuePair(out key, out tempvalue);
                    /***** rest of valid key, valid value test cases *****/
                    //according to MSDN there is an implicit cast from integer literal to byte as long as the literal is < 256
                    byte[][] valueTable = { 
                                                            new byte[] {0,0,0,0},    //nonzero length value with no bits set
                                                            new byte[] {5},          // 1 byte length value
                                                            new byte[256000],   //large value size
                                                            new byte[1048576 ] //value sized =  1 mb
                                                       };
                                                       
                    foreach (byte[] value in valueTable)
                    {
                        if (value.Length > 4)
                        {
                            //fill key with some random values.
                            _random.NextBytes(value);
                        }
                         
                        InsertSingleItem(key, value);
                         //cleanup
                        Remove(key);
                    }
                    
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase, Description("Insert version 1 positive paramater testing")]
          class P_Insert_Same_Value : AccelFuncTestBase
          {
               /***** existing key, same value *****/
               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    byte[] value = null;
                    
                    CreateKeyValuePair(out key, out value);
                    //put value at key with SetData
                    SetData(key,value,0,0);

                    hr = _xb.Insert(key, value);
                    if (hr != HResult.E_ACCESSDENIED)
                    {
                        throw new HResultException(hr, "Insert over existing item with same value returned "+hr+" instead of E_ACCESSDENIED");
                    }
                    //call remove to clean up
                    Remove(key);

                    //try to do it in the same call
                    byte[][] dupKeys = new byte[][] {key, key};
                    byte[][] dupValues = new byte[][] {value, value};
                    byte[][] outvalues = null;
                    uint[] dupHr;

                    //make a reservation
                    Query(dupKeys, outvalues, new uint[] {HResult.S_FALSE, HResult.S_FALSE});

                    //call insert
                    dupHr = _xb.Insert(dupKeys, dupValues, new uint[dupKeys.Length], new uint[dupKeys.Length]);
                    if (dupHr == null || dupHr.Length != 2)
                    {
                        throw new Exception("Insert did not return expected HR results");
                    }
                    if (dupHr[0] != HResult.S_OK)
                    {
                        throw new HResultException(dupHr[0], "Insert returned "+dupHr[0]+" instead of S_OK");
                    }
                    if (dupHr[1] != HResult.E_ACCESSDENIED)
                    {
                        throw new HResultException(dupHr[1], "Insert returned "+dupHr[1]+" instead of E_ACCESSDENIED");
                    }
                     //cleanup                    
                    Remove(dupKeys);
                    

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase, Description("Insert version 1 positive paramater testing")]
          class P_Insert_Without_Reservation: AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    byte[] value = null;
                    
                    CreateKeyValuePair(out key, out value);
                    hr = _xb.Insert(key, value);
                    if (hr != HResult.S_OK )
                    {
                          throw new HResultException(hr, "Calling Insert without a reservation returned "+hr+" instead of S_OK");
                    }    

                    // cleanup
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;
                    
                    //done with FuncInsertPositive_Simple
               }
          }

          [TestCase, Description("Insert version 2 no expiration testing")]
          class P_Expiry_None : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] value = null;
                    byte[] noExpirationKey = null;
                    byte[] key = null;

                    //valid key, valid value, no expiration          
                    CreateKeyValuePair(out noExpirationKey, out value);
                    CreateKeyValuePair(out key, out value);
                    QueryCheckTime(noExpirationKey, null, _reservationExpirySeconds, HResult.S_FALSE);
                    InsertSingleItem(noExpirationKey, value, 0, 0);
                    QueryCheckTime(noExpirationKey, value, 0xFFFFFFFF, HResult.S_OK);
                    
                    Remove(noExpirationKey);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert version 2 no expiration testing")]
          class P_Expiry_MaxAbsolute : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] value = null;
                    byte[] key = null;
                    byte[][] keyArray = null;
                    byte[][] valueArray = null;
                    uint[] expiry = null;
                    uint[] expectedExpiry = null;
                    uint[] expectedHR = null;

                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);

                    expiry = new uint[keyArray.Length];
                    expectedHR = new uint[keyArray.Length];
                    expectedExpiry = new uint[keyArray.Length];
                    for(int i=0; i<expiry.Length; i++)
                    {
                        expiry[i] = _maxUInt;
                        expectedHR[i] = HResult.S_OK;
                        expectedExpiry[i] = _maxUInt - 5;
                    }
                    
                    InsertSingleItem(key, value, _maxUInt, 0);
                    InsertMultipleItems(keyArray, valueArray, expiry, new uint[keyArray.Length]);
                    
                    //wait to see if the value will expire, it should not.
                    new SleepInfo("Wait for 5 seconds for value to NOT expire",5*1000);
                    //Query to see if value did not expire
                    QueryCheckTime(key, value, _maxUInt - 5, HResult.S_OK);
                    QueryCheckTime(keyArray, valueArray, expectedExpiry, expectedHR);
                  
                    //remove for cleanup
                    Remove(key);
                    Remove(keyArray);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase, Description("Insert version 2 no expiration testing")]
          class P_Expiry_MaxSliding : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] value = null;
                    byte[] key = null;
                    byte[][] keyArray = null;
                    byte[][] valueArray = null;
                    uint[] expiry = null;
                    uint[] expectedExpiry = null;
                    uint[] expectedHR = null;

                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);

                    expiry = new uint[keyArray.Length];
                    expectedHR = new uint[keyArray.Length];
                    expectedExpiry = new uint[keyArray.Length];
                    for(int i=0; i<expiry.Length; i++)
                    {
                        expiry[i] = _maxUInt;
                        expectedHR[i] = HResult.S_OK;
                        expectedExpiry[i] = _maxUInt;
                    }
                    
                    InsertSingleItem(key, value, 0,  _maxUInt);
                    InsertMultipleItems(keyArray, valueArray, new uint[keyArray.Length], expiry);
                    
                    //wait to see if the value will expire, it should not.
                    new SleepInfo("Wait for 5 seconds for value to NOT expire",5*1000);
                    
                    //Query to see if value did not expire
                    QueryCheckTime(key, value, _maxUInt, HResult.S_OK); //sliding time updated because we just queried for it
                    QueryCheckTime(keyArray, valueArray, expectedExpiry, expectedHR);
                    //remove for cleanup
                    Remove(key);
                    Remove(keyArray);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

             [TestCase, Description("Insert version 2 sliding/absolute seconds individual testing")]
          class P_Expiry_Both60seconds : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] absoluteKey = null;
                    byte[] value = null;
                    byte[][] keyArray = null;
                    byte[][] valueArray = null;
                    uint[] absoluteExpiry = null;
                    uint[] slidingExpiry = null;                    
                    uint[] expectedExpiry = null;
                    uint[] expectedHR = null;

                    //create sliding and absolute keys, one value
                    CreateKeyValuePair(out slidingKey, out value);
                    CreateKeyValuePair(out absoluteKey, out value);

                    keyArray = new byte[3][];
                    valueArray = new byte[3][];

                    absoluteExpiry = new uint[keyArray.Length];
                    slidingExpiry = new uint[keyArray.Length];                    
                    expectedHR = new uint[keyArray.Length];
                    expectedExpiry = new uint[keyArray.Length];
                    for(int i=0; i<keyArray.Length; i++)
                    {
                        keyArray[i] = CreateKey();
                        valueArray[i] = CreateValue();
                        expectedHR[i] = HResult.S_FALSE;
                        expectedExpiry[i] = _reservationExpirySeconds;
                    }
                    absoluteExpiry[0] = 0;
                    absoluteExpiry[1] = 60;
                    absoluteExpiry[2] = 60;
                    slidingExpiry[0] = 60;
                    slidingExpiry[1] = 0;
                    slidingExpiry[2] = 60;

                    //valid key, valid value, 60 seconds sliding expiration          

                    // *******  verify value expires 60 seconds after insertion **********
                    InsertSingleItem(slidingKey, value, 0, 60);
                    InsertSingleItem(absoluteKey, value, 60, 0);
                    InsertMultipleItems(keyArray, valueArray, absoluteExpiry, slidingExpiry);

                     //sleep for 60 seocnds, value should expire
                     new SleepInfo("Wait 60 seconds for both values to expire", 60 * 1000);
                     //both values should be expired
                     QueryCheckTime(slidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);
                     QueryCheckTime(absoluteKey, null, _reservationExpirySeconds, HResult.S_FALSE);
                     QueryCheckTime(keyArray, null, expectedExpiry, expectedHR);

                     Remove(keyArray);

                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class P_Expiry_MultipleInsert : AccelFuncTestBase
          {
                
               override protected void Execute()
               {
                    byte[][] keyArrayInsert = null;
                    byte[][] keyArrayQuery = null;
                    byte[][] valueArray = null;
                    byte[][] expectedQueryValues = null;
                    uint[] absoluteExpiry = null;
                    uint[] slidingExpiry = null;                    
                    uint[] expectedExpiry = null;
                    uint[] expectedHR= null;
                    
                   //65                                  75                          30                      45                  60                  
                    //not sliding expired, not absolute expired, sliding expired, absolute expired, reservation expired, 
                    keyArrayInsert = new byte[4][];
                    valueArray = new byte[4][];
                    absoluteExpiry = new uint[keyArrayInsert.Length];
                    slidingExpiry = new uint[keyArrayInsert.Length];   
                    //for the query checktime call
                    expectedQueryValues = new byte[5][];
                    keyArrayQuery = new byte[5][];
                    expectedHR = new uint[keyArrayQuery.Length];
                    expectedExpiry = new uint[keyArrayQuery.Length];
                    
                    for(int i=0; i<keyArrayInsert.Length; i++)
                    {
                        keyArrayInsert[i] = CreateKey();
                        valueArray[i] = CreateValue();
                        keyArrayQuery[i] = keyArrayInsert[i];
                    }
                    
                    absoluteExpiry[0] = 0;
                    absoluteExpiry[1] = 75;
                    absoluteExpiry[2] = 0;
                    absoluteExpiry[3] = 45;
                    slidingExpiry[0] = 70;
                    slidingExpiry[1] = 0;
                    slidingExpiry[2] = 30;
                    slidingExpiry[3] = 0;

                    //results for the QueryCheckTime
                    keyArrayQuery[4] = CreateKey();
                    
                    expectedHR[0] = HResult.S_OK;
                    expectedHR[1] = HResult.S_OK;
                    expectedHR[2] = HResult.S_FALSE;
                    expectedHR[3] = HResult.S_FALSE;
                    expectedHR[4] = HResult.S_FALSE;
                    expectedExpiry[0] = 70;
                    expectedExpiry[1] = 15;
                    expectedExpiry[2] = _reservationExpirySeconds;
                    expectedExpiry[3] = _reservationExpirySeconds;
                    expectedExpiry[4] = _reservationExpirySeconds;
                    expectedQueryValues[0] = valueArray[0];
                    expectedQueryValues[1] = valueArray[1];
                    expectedQueryValues[2] = null;
                    expectedQueryValues[3] = null;
                    expectedQueryValues[4] = null;
                    //make the reservation for the last case
                    Query(keyArrayQuery[4], null, HResult.S_FALSE);
                    
                    InsertMultipleItems(keyArrayInsert, valueArray, absoluteExpiry, slidingExpiry);

                     //sleep for 60 seocnds, value should expire
                    new SleepInfo("Wait 60 seconds for both values to expire", 60 * 1000);

                    QueryCheckTime(keyArrayQuery, expectedQueryValues, expectedExpiry, expectedHR);

                    //remove everything for cleanup
                    Remove(keyArrayInsert);
                    _xb.Remove(keyArrayQuery[4]);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase]
           class P_Expiry_RandomlyQuerySlidingExpiration : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint slidingExpiryTime = 100;
                    byte[] key = null, value = null;
                    long ticksPerSecond = 10000000;
                    CreateKeyValuePair(out key, out value);

                    DateTime timeNanny = DateTime.Now;
                    SetData(key, value, 0, slidingExpiryTime);
                    long secondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond;
                    for (int i=0; i<10; i++)
                    {
                        _report.Debug(i+"/10 query test begins.");
                        //randomly pick a time to sleep
                        int sleepSeconds = _random.Next(1,(int)(slidingExpiryTime+1));
                        Thread.Sleep(sleepSeconds * 1000);

                        QueryCheckTime(key, value, slidingExpiryTime, HResult.S_OK);
                        secondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond;                        
                        _report.Debug(secondsPassed + " total seconds have passed");
                    }
                   //remove for cleanup
                   Remove(key);
                   ResultCode = TEST_RESULTS.PASSED;
               }
          }


           [TestCase]
           class P_Expiry_220secondsAbsolute_Bug107728 : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] value = null;
                    byte[] key = null;
                    long secondsPassed = 0;
                    uint absoluteExpirySeconds = 220;
                    long ticksPerSecond =10000000;

                    //valid key, valid value       
                    CreateKeyValuePair(out key, out value);
                    DateTime timeNanny = DateTime.Now;
                    DateTime now = DateTime.Now;

                    SetData(key, value, absoluteExpirySeconds, 0);
                    secondsPassed = (DateTime.Now.Ticks - now.Ticks)/ticksPerSecond; 
                  
                    //query for it every 10 seconds to make sure it is still there
                    while (secondsPassed < absoluteExpirySeconds)
                    {
                        secondsPassed = ( DateTime.Now.Ticks - now.Ticks)/ticksPerSecond; 
                        QueryCheckTime(key, value, absoluteExpirySeconds - (uint)secondsPassed, HResult.S_OK);

                        new SleepInfo("Waiting 10 seconds to query", 10*1000);
                
                        //do time keeping because i do not trust the sleepinfo to be accurate
                        secondsPassed = ( DateTime.Now.Ticks - now.Ticks)/ticksPerSecond; 

                    }
                     long newSecondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond;
                     _report.Debug("total time passed: "+newSecondsPassed);
                    // Query to see if value expired
                    QueryCheckTime(key, null, _reservationExpirySeconds, HResult.S_FALSE);

                    //remove to clean it up, just incase.
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;

               }
          }

               [TestCase, Description("Insert version 2 sliding/absolute seconds individual testing")]
          class P_Expiry_MultipleInserts: AccelFuncTestBase
          {
            // *******  verify value expires 30 seconds after insertion despite multiple inserts **********
               override protected void Execute()
               {
                    uint hr;
                    byte[] slidingKey = null;
                    byte[] anotherSlidingKey = null;
                    byte[] value = null;

                    CreateKeyValuePair(out anotherSlidingKey, out value);
                    CreateKeyValuePair(out slidingKey, out value);

                    InsertSingleItem(slidingKey, value, 0, 30);
                    InsertSingleItem(anotherSlidingKey, value, 0, 30);
                    //sleep for 15 seocnds
                    new SleepInfo("Wait 15 seconds.", 15 * 1000);

                    //try to insert same value again
                    hr = _xb.Insert(slidingKey, value);
                    if (hr != HResult.E_ACCESSDENIED)
                    {
                        throw new HResultException(hr, "Calling Insert with existing key and same value "+hr+" instead of E_ACCESSDENIED");  
                    }

                     //try to insert different value 
                     byte[] differentValue = _enc.GetBytes("sliiiiding different value!");
                     hr = _xb.Insert(anotherSlidingKey, differentValue);
                     if (hr != HResult.E_ACCESSDENIED)
                     {
                         throw new HResultException(hr, "Calling Insert with existing key and different value "+hr+" instead of E_ACCESSDENIED"); 
                     }

                     //sleep for 20 seocnds, "insert different value" case should should expire, "insert same value" should not
                     new SleepInfo("Wait 20 seconds.", 20 * 1000); //now 35 seconds after initial insertion, 20 seconds after re-insertion
                     
                    QueryCheckTime(slidingKey, value, 30, HResult.S_OK);                      
                    QueryCheckTime(anotherSlidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);

                    //sleep for 31 seocnds, both values should be expired
                    new SleepInfo("Wait 31 seconds.", 31 * 1000); //now 66 seconds after initial insertion, 51 seconds after re-insertion, 31 seconds after last query

                    QueryCheckTime(slidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);

                    Remove(new byte[][] { slidingKey, anotherSlidingKey });
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

                    [TestCase, Description("Insert version 2 sliding/absolute seconds individual testing")]
          class P_Expiry_MultipleQueries60Sec: AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] absoluteKey = null;
                    byte[] value = null;
                    long ticksPerSecond = 10000000;

                    CreateKeyValuePair(out slidingKey, out value);
                    CreateKeyValuePair(out absoluteKey, out value);

                     // ****** verify value expires 60 seconds after last query ********
                    InsertSingleItem(slidingKey, value, 0, 60);
                    InsertSingleItem(absoluteKey, value, 60, 0);
                    DateTime now = DateTime.Now;
                    //sleep for 25 seocnds
                    new SleepInfo("Wait 25 seconds then query for sliding key", 25 * 1000);
                    uint secPassed = (uint)((DateTime.Now.Ticks - now.Ticks)/ticksPerSecond);
                    //now 25 seconds after insertion
                    QueryCheckTime(slidingKey, value, 60, HResult.S_OK);
                    QueryCheckTime(absoluteKey, value, 60-secPassed, HResult.S_OK);

                      //sleep for 40 seconds
                      _report.Debug("Sleeping for 40 seconds, will be 65 seconds after insertion, 40 seconds after last query.");
                      new SleepInfo("Wait 40 seconds.", 40 * 1000);  //now 65 seconds after insertion, 40 seconds after last query

                     //do not test query for sliding expiry key, it will push its expiration longer
                     //test absolute expiry, should be expired
                     QueryCheckTime(absoluteKey, null, _reservationExpirySeconds, HResult.S_FALSE);    

                    //sleep for 25 seocnds
                    _report.Debug("Sleeping for 25 seconds, will be 80 seconds after insertion, 65 seconds after last query.");
                    new SleepInfo("Wait 25 seconds", 25 * 1000);

                     //now 80 seconds after insertion, 65 seconds after last query, all should be expired
                    QueryCheckTime(slidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);

                    Remove(new byte[][] { slidingKey, absoluteKey });
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert version 2 sliding/absolute seconds individual testing")]
          class P_Expiry_Remove: AccelFuncTestBase
          {
               override protected void Execute()
               {
                    // ****** verify remove called before 60 seconds removes the value ********
                    byte[] slidingKey = null;
                    byte[] absoluteKey = null;
                    byte[] value = null;

                    CreateKeyValuePair(out slidingKey, out value);
                    CreateKeyValuePair(out absoluteKey, out value);
                    InsertSingleItem(slidingKey, value, 0, 60);
                    InsertSingleItem(absoluteKey, value, 60, 0);
                   
                     //sleep for 25 seconds
                     new SleepInfo("Wait 25 seconds", 25 * 1000);
                     //now 25 seconds after insertion

                     Remove(slidingKey);
                     //value should be removed
                     QueryCheckTime(slidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);  
                     //remove and check absolute
                     Remove(absoluteKey);
                     //value should be removed
                     QueryCheckTime(absoluteKey, null, _reservationExpirySeconds, HResult.S_FALSE);  
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert version 2 sliding/absolute seconds individual testing")]
          class P_Expiry_OverwriteWithSetData: AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] absoluteKey = null;
                    byte[] value = null;

                    CreateKeyValuePair(out slidingKey, out value);
                    CreateKeyValuePair(out absoluteKey, out value);
                    InsertSingleItem(slidingKey, value, 0, 60);
                    InsertSingleItem(absoluteKey, value, 60, 0);
                    
                    //sleep for 25 seocnds
                    _report.Debug("Sleeping for 25 seconds.");
                    new SleepInfo("Wait 25 seconds",25 * 1000);

                     SetData(slidingKey, value,0,0);
                     SetData(absoluteKey, value,0,0);
                      
                      //check to see if the setdata worked
                      QueryCheckTime(slidingKey, value, 0xFFFFFFFF, HResult.S_OK);
                      QueryCheckTime(absoluteKey, value, 0xFFFFFFFF,  HResult.S_OK);     
                      
                      //sleep for 65 seocnds, value should NOT expire
                      _report.Debug("Sleeping for 65 seconds, will be 90 seconds after insertion, 65 seconds after last query.");
                      new SleepInfo("Wait 65 seconds", 65 * 1000);

                     QueryCheckTime(slidingKey, value, 0xFFFFFFFF,  HResult.S_OK);
                     QueryCheckTime(absoluteKey, value, 0xFFFFFFFF,  HResult.S_OK); 
                     Remove(slidingKey);
                     Remove(absoluteKey);
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase, Description("Insert version 2 sliding/absolute seconds individual testing")]
          class P_Expiry_InsertOverExpiredData: AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] absoluteKey = null;
                    byte[] value = null;

                    CreateKeyValuePair(out slidingKey, out value);
                    CreateKeyValuePair(out absoluteKey, out value);
                    InsertSingleItem(slidingKey, value, 0, 5);
                    InsertSingleItem(absoluteKey, value, 5, 0);
                    
                    //sleep for 5 seocnds
                    _report.Debug("Sleeping for 5 seconds.");
                     new SleepInfo("Wait 5 seconds",5 * 1000);

                     InsertSingleItem(slidingKey, value, 0, 5);
                     InsertSingleItem(absoluteKey, value, 5, 0);
                      
                      //check to see if the setdata worked
                      QueryCheckTime(slidingKey, value, 5, HResult.S_OK);
                      QueryCheckTime(absoluteKey, value, 5,  HResult.S_OK);     
                      
                      new SleepInfo("Wait 10 seconds", 6 * 1000);

                     QueryCheckTime(slidingKey, null, _reservationExpirySeconds,  HResult.S_FALSE);
                     QueryCheckTime(absoluteKey, null, _reservationExpirySeconds,  HResult.S_FALSE);

                     Remove(new byte[][] { slidingKey, absoluteKey});
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }
    

             [TestCase, Description("Insert version 2 sliding/absolute seconds integrated testing")]
          class P_Expiry_VariedSlidingAndAbsolute_ExpireAfterInsertion : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] absoluteKey = null;
                    byte[] value = null;

                    CreateKeyValuePair(out slidingKey, out value);
                    CreateKeyValuePair(out absoluteKey, out value);

                    InsertSingleItem(slidingKey, value, 60, 30);    
                    InsertSingleItem(absoluteKey, value, 30, 60);   
                   
                     //sleep for 35 seocnds, value should expire
                     new SleepInfo("Wait 35 seconds for value to expire", 35 * 1000);

                     QueryCheckTime(slidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);
                     QueryCheckTime(absoluteKey, null, _reservationExpirySeconds, HResult.S_FALSE);

                    Remove(new byte[][] { slidingKey, absoluteKey });
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

                  [TestCase, Description("Insert version 2 sliding/absolute seconds integrated testing")]
          class P_Expiry_VariedSlidingAndAbsolute_ExpireAfterMultipleQueries : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] value = null;
                    long ticksPerSecond = 10000000;

                    CreateKeyValuePair(out slidingKey, out value);

                    DateTime timeNanny = DateTime.Now;
                    InsertSingleItem(slidingKey, value, 40, 30);
                    uint expectedExpiryTime = 30;
                    
                     //sleep for 10 seocnds
                     _report.Debug("Sleeping for 8 seconds.");
                     new SleepInfo("Wait 8 seconds, then query", 8 * 1000);

                     //now 10 seconds after insertion
                     long secondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond;
                     if ((int)secondsPassed > 10) expectedExpiryTime = 40- (uint)secondsPassed;

                     QueryCheckTime(slidingKey, value, expectedExpiryTime, HResult.S_OK); //sliding = 40, absolute = 30

                     //sleep for 20 seocnds
                     _report.Debug("Sleeping for 22 seconds, will be 30 seconds after insertion, 20 seconds after last query.");
                     new SleepInfo("Wait 22 seconds", 22 * 1000);

                     //now 30 seconds after insertion, 20 seconds after last query
                     secondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond;
                     if ((int)secondsPassed > 10) expectedExpiryTime = 40-(uint)secondsPassed;
                     QueryCheckTime(slidingKey, value, expectedExpiryTime, HResult.S_OK);

                     //sleep for 15 seocnds, value should expire
                     _report.Debug("Sleeping for 15 seconds, will be 45 seconds after insertion, 15 seconds after last query.");
                     new SleepInfo("Wait 15 seconds for value to expire", 15 * 1000);

                     //45 seconds after insertion, 15 seconds after last query
                     QueryCheckTime(slidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);
                     Remove(slidingKey);
                    
                         
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase, Description("Insert version 2 sliding/absolute seconds integrated testing")]
          class P_Expiry_VariedSlidingAndAbsolute_Remove : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] value = null;

                    CreateKeyValuePair(out slidingKey, out value);

                    InsertSingleItem(slidingKey, value, 60, 30);
                    
                     //sleep for 15 seocnds
                     _report.Debug("Sleeping for 15 seconds.");
                     new SleepInfo("Wait 15 seconds", 15 * 1000);

                     Remove(slidingKey);
                     //value should be removed
                      QueryCheckTime(slidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

           
           [TestCase, Description("Insert version 2 sliding/absolute seconds integrated testing")]
          class P_Expiry_VariedSlidingAndAbsolute_OverwriteWithSetData : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] value = null;
                    
                    CreateKeyValuePair(out slidingKey, out value);

                    InsertSingleItem(slidingKey, value, 60, 30);
                    
                    SetData(slidingKey, value,0,0);
                     //check to see if the setdata worked
                    QueryCheckTime(slidingKey, value, 0xFFFFFFFF, HResult.S_OK);

                      //sleep for 65 seocnds, value should NOT expire
                      _report.Debug("Sleeping for 65 seconds, will be 65 seconds after setdata and query call.");
                      new SleepInfo("Wait 65 seconds", 65 * 1000);

                     //check to see if value has not expired
                     QueryCheckTime(slidingKey, value, 0xFFFFFFFF, HResult.S_OK);

                      //remove the value (cleanup)
                      Remove(slidingKey);
                         
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class N_Parameter_Null_Cases : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    uint[] hrArray;
                    byte[] key = null;
                    byte[][] keyArray = null;
                    byte[][] keyNull = null;
                    byte[] value = null;
                    byte[][] valueArray = null;
                    byte[][] valueNull = null;
                    
                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);
                    
                    /**** null key, valid value *****/
               
                     hr = _xb.Insert(null,value);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Insert with null key returned "+hr+" instead of E_INVALIDARG");                     
                     }

                     hr = _xb.Insert(null,value,0,0);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Insert with null key returned "+hr+" instead of E_INVALIDARG");                     
                     }

                     hrArray = _xb.Insert(keyNull, valueArray, new uint[valueArray.Length],new uint[valueArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling insert with null key array returned unexpected HResult array");
                     }

                    /**** valid key, null value *****/
                     hr = _xb.Insert(key, null);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Insert with null value returned "+hr+" instead of E_INVALIDARG");                           
                     }

                     hr = _xb.Insert(key, null,0,0);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Insert with null value returned "+hr+" instead of E_INVALIDARG");                           
                     }

                     hrArray = _xb.Insert(keyArray, valueNull,new uint[keyArray.Length],new uint[keyArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling insert with null value array returned unexpected HResult array");
                     }
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase]
          class N_Parameter_Unequal_Length_Cases : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint[] hr;
                    
                    hr = _xb.Insert(new byte[][] {new byte[]{1}},new byte[][] {new byte[]{2},new byte[]{3},new byte[]{4},new byte[]{5}}, new uint[1], new uint[1]);
                    if (hr != null)
                    {
                        throw new Exception("Calling insert with key array and value array different lengths returned unexpected HResult array");
                    }
                    
                    byte[][] key = new byte[][] {new byte[]{1},new byte[] {2},new byte[]{3}};
                    byte[][] value = new byte[][] {new byte[]{1,2},new byte[] {2,3},new byte[]{3,4,5,6}};

                    hr = _xb.Insert(key, value, new uint[] {0,0,0,0}, new uint[] {0,0,0,0} );
                    if (hr != null)
                    {
                        throw new Exception("Calling insert with key array and expiry arrays different lengths returned unexpected HResult array");
                    }

                    hr = _xb.Insert(key, value, new uint[] {0,0,0,0,0}, new uint[] {0} );
                    if (hr != null)
                    {
                        throw new Exception("Calling insert with key array and expiry arrays different lengths returned unexpected HResult array");
                    }

                     hr = _xb.Insert(key, value, new uint[] {0}, new uint[] {0,0} );
                    if (hr != null)
                    {
                        throw new Exception("Calling insert with key array and expiry arrays different lengths returned unexpected HResult array");
                    }

                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase]
          class N_Parameter_Empty_Cases : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    byte[] value = null;
                    uint[] hrArray;
                    byte[][] keyArray = null;
                    byte[][] keyEmpty = new byte[0][];
                    byte[][] valueArray = null;
                    byte[][] valueEmpty = new byte[0][];
                    
                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);
                   
                    /**** empty key, valid value *****/
                     hr = _xb.Insert(new byte[0], value);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hr, "Calling Insert with empty key returned "+hr+" instead of E_INVALIDARG");                                      
                    }

                     hr = _xb.Insert(new byte[0], value,0,0);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hr, "Calling Insert with empty key returned "+hr+" instead of E_INVALIDARG");                                      
                    }

                     hrArray = _xb.Insert(keyEmpty, valueArray, new uint[keyEmpty.Length], new uint[keyEmpty.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling insert with empty key array returned unexpected HResult array");
                     }

                     /***** valid key, empty value ******/
                     hr = _xb.Insert(key, new byte[0]);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hr, "Calling Insert with empty value returned "+hr+" instead of E_INVALIDARG");                                      
                    }
                    
                     hr = _xb.Insert(key, new byte[0],0,0);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                         throw new HResultException(hr, "Calling Insert with empty value returned "+hr+" instead of E_INVALIDARG");                        
                    }

                     hrArray = _xb.Insert(keyArray, valueEmpty, new uint[keyArray.Length], new uint[keyArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling insert with empty value array returned unexpected HResult array");
                     }

                     /***** vaild key, valid value, empty expiries ******/
                      hrArray = _xb.Insert(keyArray, valueArray, new uint[0], new uint[0]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling insert with empty expiry arrays returned unexpected HResult array");
                     }

                     hrArray = _xb.Insert(keyArray, valueArray, new uint[valueArray.Length], new uint[0]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling insert with empty sliding expiry array returned unexpected HResult array");
                     }

                     hrArray = _xb.Insert(keyArray, valueArray, new uint[0], new uint[valueArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling insert with empty absolute expiry array returned unexpected HResult array");
                     }
                    

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class N_Key_SizeTooLong : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    byte[] value = null;
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);
                    
                    CreateKeyValuePair(out key, out value);

                    /***** key size too long, valid value *****/
                    byte[] keyTooLong =  new byte[_maxKeyLength + 1];
                    //fill key with some random values.
                    _random.NextBytes(keyTooLong);

                     hr = _xb.Insert(keyTooLong, value);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Insert with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }

                     hr = _xb.Insert(keyTooLong, value,0,0);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Insert with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase]
          class N_KeyArray_Invalid_Cases : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint[] hrArray;
                    byte[][] key = null;
                    byte[][] value = null;
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);

                    /********* KEY CASES **************/
                    
                    //key[0] = null;
                    key = new byte[1][];
                    key[0] = null;
                    value = new byte[][] {new byte[]{1}};
                    
                    hrArray = _xb.Insert(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling insert with null key first value returned unexpected HResult array");
                    }
                    if (hrArray[0] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[0], "Calling Insert with null key first value returned "+hrArray[0]+" instead of E_INVALIDARG");                           
                    }
                    //key[0] = invalid key, key[1] = valid key w/o reservation, key[2] = invalid key
                    key = new byte[3][];
                    key[0] = new byte[_maxKeyLength + 1];   //key size too long
                    key[1] = new byte[]{2,3,4,5,6,7,8};                   //insert without reservation
                    key[2] = null;                                          //null key
                    value = new byte[][] {new byte[]{1}, new byte[]{3}, new byte[]{5}};      //just random data

                    hrArray = _xb.Insert(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling insert with null first key array returned unexpected HResult array");
                    }
                    if (hrArray[0] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[0], "Calling Insert with key size too long returned "+hrArray[0]+" instead of E_INVALIDARG");                           
                    }
                    if (hrArray[1] != HResult.S_OK) 
                    {
                        throw new HResultException(hrArray[1], "Calling Insert with key without reservation returned "+hrArray[1]+" instead of S_OK");                           
                    }
                    if (hrArray[2] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[2], "Calling Insert with null key returned "+hrArray[2]+" instead of E_INVALIDARG");                           
                    }

                    Remove(key[1]);

                    /**** VALUE CASES  *****/
                    key = new byte[][] {new byte[]{1}, new byte[]{2}};
                    value = new byte[2][];
                    value[0] = new byte[] {33};
                    value[1] = null;
                    hrArray = _xb.Insert(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling insert with null second value array returned unexpected HResult array");
                    }
                    if (hrArray[1] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[1], "Calling Insert with null second value array returned "+hrArray[1]+" instead of E_INVALIDARG");                           
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

             [TestCase]
          class N_Insert_Different_Value: AccelFuncTestBase
          {
                    /***** existing key, different value *****/
               override protected void Execute()
               {
                    
                    uint hr;
                    byte[] key = null;
                    byte[] value = null;
                    
                    CreateKeyValuePair(out key, out value);
                  
                    //put value at key with SetData
                    SetData(key,value,0,0);
                    
                    //change value
                    value = _enc.GetBytes("A different value!");
                    
                    //call insert to try to put the value in the cache
                    hr = _xb.Insert(key, value);
                    if (hr != HResult.E_ACCESSDENIED)
                    {
                         throw new HResultException(hr, "Calling Insert with existing key and different value "+hr+" instead of E_ACCESSDENIED");  
                    }    

                    hr = _xb.Insert(key, value, 0, 0);
                    if (hr != HResult.E_ACCESSDENIED)
                    {
                         throw new HResultException(hr, "Calling Insert with existing key and different value "+hr+" instead of E_ACCESSDENIED");  
                    }    
                    
                    //cleanup                    
                    Remove(key);


                    //try to do it in the same call
                    byte[][] dupKeys = new byte[][] {key, key};
                    byte[][] diffValues = new byte[][] {value, new byte[]{1,2,3}};
                    byte[][] outvalues = null;
                    uint[] dupHr;

                    //make a reservation
                    Query(dupKeys, outvalues, new uint[] {HResult.S_FALSE, HResult.S_FALSE});

                    //call insert
                    dupHr = _xb.Insert(dupKeys, diffValues, new uint[dupKeys.Length],new uint[dupKeys.Length]);
                    if (dupHr == null || dupHr.Length != 2)
                    {
                        throw new Exception("Insert did not return expected HR results");
                    }
                    if (dupHr[0] != HResult.S_OK)
                    {
                        throw new HResultException(dupHr[0], "Insert returned "+dupHr[0]+" instead of S_OK");
                    }
                    if (dupHr[1] != HResult.E_ACCESSDENIED)
                    {
                        throw new HResultException(dupHr[1], "Insert returned "+dupHr[1]+" instead of E_ACCESSDENIED");
                    }

                     //cleanup                    
                    Remove(dupKeys);
                    
                  
                    ResultCode = TEST_RESULTS.PASSED;

               }
          }
         
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\AccelFuncHighVolume.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.protocol;
using xonline.common.service;


namespace AccelTest
{
     public class AccelFuncHighVolume : TestNode
     {
          [TestCase, Description("Insert 1000 random keys with value as the key")]
          
          class P_lnsert1000Random: AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    //track total items & bytes added to manually verify with counters
                    int byteCount = 0;
                    int insertCount = 0;
                          
                    for(int i=0; i<1000; i++)
                    {
                         byte[] key = CreateKey();
                         byte[] outBytes = null;
                         hr = _xb.Query(key, out outBytes);
                         if (HResult.Failed(hr))
                         {
                            throw new HResultException(hr);
                         }
                         
                         hr = _xb.Insert(key, key);
                         if (HResult.Failed(hr))
                         {
                            throw new HResultException(hr);
                         }
                         if (hr == HResult.S_OK)
                         {
                              //update byte & item counters
                              byteCount += key.Length;
                              insertCount ++;
                         }
                    }
                    //output count info to STFRunner
                    _report.Debug("Total items inserted = "+byteCount);
                    _report.Debug("Total bytes inserted = "+insertCount);
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert 256*256 key,key pairs to create full tries")]
          
          class P_lnsertFullBranches: AccelFuncTestBase
          {
              
              override protected void Execute()
               {
                    uint hr;
                    byte[] key1 = null;
                    //track total items & bytes added to manually verify with counters
                    int byteCount = 0;
                    int insertCount = 0;
                    //insert a key/value pair for each possible key in the root (first) level
                    for(int i=0; i<256; i++)
                    {
                          key1=new byte[1];
                          key1[0] = (byte) i;
                          
                          hr = _xb.SetData(key1, key1,0,0);
                          if (HResult.Failed(hr))
                          { 
                             throw new HResultException(hr);
                          }
                          if (hr != HResult.S_OK)
                          {
                              _report.Warn("SetData at root level (" + PrintByteArray(key1) + ") returned result: "+hr);                              
                          }
                          else
                          {
                              //update byte & item counters from successful insert
                              insertCount ++;
                              byteCount++;
                          }
                         //insert a key/value pair for each possible key in the second level
                         for(int j=0; j<256; j++)
                         {
                              byte[] key2 = new byte[2];
                              key2[0] = (byte) i;
                              key2[1] = (byte) j;
                              hr = _xb.SetData(key2, key2,0,0);
                               if (HResult.Failed(hr))
                              { 
                                 throw new HResultException(hr);
                              }
                              if (hr != HResult.S_OK)
                              {
                                  _report.Warn("SetData a second level (" + PrintByteArray(key2) + ") returned result: " + hr);
                              }
                              else
                              {
                                    //update byte & item counters from successful insert
                                     insertCount ++;
                                     byteCount+=2;
                              }
                                    //insert a key/value pair for 5 random keys in the third level
                                    /*  for(int k=0; k<5; k++)//doing this 255 times would insert a RIDICULOUS amount of items. Believe me, I tried it.
                                   {
                                   byte[] key3 = new byte[3];
                                   key3[0] = (byte) i;
                                   key3[1] = (byte) j;
                                   key3[2] = (byte)_random.Next(0, 255);
                                   hr = _xb.Query(key3, out outBytes);
                                   hr = _xb.Insert(key3, key3);
                                   if (hr != HResult.S_OK)
                                   {
                                        _report.Fatal("Insert a third level ("+ PrintByteArray(key3) +") returned result: "+hr);
                                   }
                                   else
                                   {
                                        //update byte & item counters from successful insert
                                       _report.Debug("Insert a third level (" + PrintByteArray(key3) + ") returned result: " + hr);
                                       insertCount++;
                                       byteCount+=3;
                                   }
                                   }*/
                         }
                    }
                    //output count info to STFRunner
                    _report.Debug("Total items inserted = "+insertCount);
                    _report.Debug("Total bytes inserted = "+byteCount);

                    ResultCode = TEST_RESULTS.PASSED;
                 
               }
          }

          [TestCase, Description("Create skinny trie with 256*256 key,key pairs at the end of the 127 byte long branch")]
          
          class P_lnsertLongSkinnyTrie: AccelFuncTestBase
          {
              override protected void Execute()
               {
                  
                    uint hr;
                    byte[] key1 = new byte[127];
                    byte[] key2 = new byte[128] ;                   
                    byte[] outBytes = null;
                    //track total items & bytes added to manually verify with counters
                    int byteCount = 0;
                    int insertCount = 0;

                    //create keys
                    for (int i=4; i<126; i++)
                    {
                         byte rand = (byte) _random.Next(0,255);
                         key1[i] = rand;
                         key2[i] = rand;
                    }
                     key1[0] = key2[0] = (byte) 'F';
                     key1[1] = key2[1] = (byte) 'u';
                     key1[2] = key2[2] = (byte) 'n';
                     key1[3] = key2[3] = (byte) 'c';

                    //insert a key/value pair for each possible key 
                    for(int i=0; i<256; i++)
                    {
                         
                          key1[126] = (byte) i;
                         
                          hr = _xb.Query(key1, out outBytes);
                          if (HResult.Failed(hr))
                          { 
                            throw new HResultException(hr);
                          }
                          hr = _xb.Insert(key1, key1);
                          if (HResult.Failed(hr))
                          { 
                            throw new HResultException(hr);
                          }
                          if (hr != HResult.S_OK)
                          {
                              _report.Warn("Insert at root level (" + PrintByteArray(key1) + ") returned result: "+hr);                              
                          }
                          else
                          {
                              //update byte & item counters from successful insert
                              insertCount ++;
                              byteCount+=key1.Length;
                          }
                         //insert a key/value pair for each possible key in the second level
                         for(int j=0; j<256; j++)
                         {
                              key2[126] = (byte) i;
                              key2[127] = (byte) j;
                              hr = _xb.Query(key2, out outBytes);
                              if (HResult.Failed(hr))
                              { 
                                  throw new HResultException(hr);
                              }
                              hr = _xb.Insert(key2, key2);
                              if (HResult.Failed(hr))
                              { 
                                  throw new HResultException(hr);
                              }
                              if (hr != HResult.S_OK)
                              {
                                  _report.Fatal("Insert a second level (" + PrintByteArray(key2) + ") returned result: " + hr);
                              }
                              else
                              {
                                    //update byte & item counters from successful insert
                                    insertCount ++;
                                    byteCount+=key2.Length;
                              }
                         }
                    }
                    //output count info to STFRunner
                    _report.Debug("Total items inserted = "+insertCount);
                    _report.Debug("Total bytes inserted = "+byteCount);

                      ResultCode = TEST_RESULTS.PASSED;
                 
               }
          }

           [TestCase, Description("Insert 10000 keys that map to the same bucket")]
          
          class P_InsertToSameBucket: AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    byte[] outBytes = null;
                    //track total items & bytes added to manually verify with counters
                    int byteCount = 0;
                    int insertCount = 0;
                    /***** insert into all into last bucket, bucket 419       *****/
                    int bucket = 419;
                    for(int i=0; i<10000; i++)
                    {
                         bool inserted=false;
                         //let the user know the progress
                         if ((i+1)%500 == 0) _report.Debug("500 keys inserted");
                         //find a key that hashes to 419
                        while(inserted == false)
                        {
                            byte[] key = CreateKey();
                            if (HashKeyToBucket(key) == bucket)
                            {
                                hr = _xb.Query(key, out outBytes);
                                if (HResult.Failed(hr))
                                { 
                                    throw new HResultException(hr);
                                }
                                hr = _xb.Insert(key, key);
                                if (HResult.Failed(hr))
                                { 
                                    throw new HResultException(hr);
                                }
                                else if (hr == HResult.S_OK)
                                {
                                    //update byte & item counters
                                    byteCount += key.Length;
                                    insertCount ++;
                                    inserted = true;
                                }
                            }
                        }
                    }
                    //output count info to STFRunner
                    _report.Debug("Total items inserted = "+insertCount);
                    _report.Debug("Total bytes inserted = "+byteCount);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

//            [TestCase, Description("100 Simultaneous open connections")]
//            
//            class P_100SimultaneousConnections: AccelFuncTestBase
//            {
//                 override protected void Execute()
//                 {
//                      
//                      uint hr;
//                      uint numConnections = 99;
//                      //track total items & bytes added to manually verify with counters
//                      int byteCount = 0;
//                      int insertCount = 0;
//                      ServerTestFramework.LiveService.IXBanc[] xbaList =new ServerTestFramework.LiveService.IXBanc[numConnections];
//                      byte[][] keyList= new byte[numConnections][];
//                      byte[] outBytes = null;
//                      for(int i=0; i<numConnections; i++)
//                      {
//                           //let the user know the progress
//                           if ((i+1)%10 == 0) _report.Debug("10 connections tested.");
//                           xbaList[i] = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//                           //pick a random key, insert it.                       
//                           keyList[i] = CreateKey();
//                           hr = xbaList[i].Query(keyList[i], out outBytes);
//                           if (HResult.Failed(hr))
//                           { 
//                               throw new HResultException(hr);
//                           }
//                           hr = xbaList[i].Insert(keyList[i],keyList[i]);
//                           if (HResult.Failed(hr))
//                           { 
//                               throw new HResultException(hr);
//                           }
//                           if (hr != HResult.S_OK)
//                           {
//                                _report.Warn("Insert returned result: "+hr);       
//                                //zero out the key length to let the next function know this isn't a valid key anymore
//                                keyList[i] = new byte[0];
//                           }
//                           else
//                           {
//                                //update byte & item counters
//                                byteCount += keyList[i].Length;
//                                insertCount ++;
//                           }
//                      }
//                      _report.Debug("Total items inserted = "+insertCount);
//                      _report.Debug("Total bytes inserted = "+byteCount);
//
//                      //query and remove the keys
//                      for(int i=0; i<numConnections; i++)
//                      {
//                           //only operate on exisitng keys
//                           if (keyList[numConnections-1-i].Length == 0) continue;
//
//                           //query for the data, on different "connections"
//                           QueryCheckTime(keyList[numConnections-1-i], keyList[numConnections-1-i], 0xFFFFFFFF, HResult.S_OK);
//                           
//                           //remove that key
//                            hr = xbaList[i].Remove(keyList[numConnections-1-i]);
//                           if (hr != HResult.S_OK)
//                           {
//                                 _report.Fatal("Remove on key "+i+" did not return S_OK but "+hr);
//                                 ResultCode = TEST_RESULTS.FAILED;
//                           }
//                           //return the connection
//                           ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xbaList[i]);
//                      }
//                      ResultCode = TEST_RESULTS.PASSED;
//                 }
//            }
         
      }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\AccelFuncMRU.cs ===
using System;
using System.Diagnostics;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Utilities;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;

//this is not supported in acceleration, so it is commented out of the test list.
namespace AccelTest
{
     public class AccelFuncMRU : TestNode
     {
        private static uint beginningTotalBytes = 0;
        private static uint lowWaterMark = 0;
        private static uint highWaterMark = 0;
        private static uint bucketNum = 20;
        private static uint oldLowWaterMark = 0;
        private static uint oldHighWaterMark = 0;
           
          public override void PreRun()
          {
                //read the total bytes
                //read the low water mark, high water mark
                //adjust the low water mark, high water mark
                //add the tear down delegate
                Report _report = new Report("Log");
                _report.Debug("Removing ALL entries from Accel");
                XBanc xb = new XBanc();
                //remove all!
                for(int i=0; i<256; i++)
                {
                     byte[] key = {(byte)i};
                     xb.Remove(key, false);
                }
                _report.Debug("Waiting for Accel to remove ALL entries");
                //wait 30 seconds.
                new SleepInfo("wait 30 seconds for remove to complete", 30*1000);
                 for(int i=0; i<256; i++)
                {
                     byte[] key = {(byte)i};
                     xb.Remove(key, false);
                }

                //get perfcounters to verify
                
                IBucketServer b = Config.GetBucketServer(Interface.xbanc, (uint)bucketNum);
                PerformanceCounter AccelTotalBytes = new PerformanceCounter("Xbox Live XBanc Data", "Total bytes", "_Total_", b.CurrentServerName);
                beginningTotalBytes = (uint) AccelTotalBytes.NextValue();
                //determine what to set the low and high counters to
                if (beginningTotalBytes < 2000)
                    lowWaterMark = 10000;
                else
                    lowWaterMark = beginningTotalBytes + 8000;
                highWaterMark = lowWaterMark+5000;

                //get the old values of the low and high water marks.
                oldLowWaterMark = Config.GetUIntSetting(Setting.xbanc_low_water_data_storage_bytes);
                oldHighWaterMark = Config.GetUIntSetting(Setting.xbanc_total_data_storage_bytes);

                //set the new values 
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.xbanc_low_water_data_storage_bytes, lowWaterMark.ToString());
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.xbanc_total_data_storage_bytes, highWaterMark.ToString());

                //wait two minutes for the settings to take hold
                _report.Debug("Waiting for Accel to pickup the settings change");
                new SleepInfo("wait for Accel to pickup change", 100*1000);
                

                
          }
          
          public override void PostRun()
          {
             Report _report = new Report("Log");
                _report.Warn("DESTRUCT!!!");
            //set the old values back
            Global.XEnv.OverrideSetting("ALL", "ALL", Setting.xbanc_low_water_data_storage_bytes, oldLowWaterMark.ToString());
            Global.XEnv.OverrideSetting("ALL", "ALL", Setting.xbanc_total_data_storage_bytes, oldHighWaterMark.ToString());

            //wait two minutes for the settings to take hold
            _report.Debug("Waiting for Accel to pickup the settings change");
            new SleepInfo("wait for Accel to pickup change", 100*1000);
          }

         

    
    
         [TestCase, Description("Insert one value < low water mark, one > low water mark, total size > total data storage bytes")]
         
          class P_Mainline_LWM: AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint sizeLeft = lowWaterMark - beginningTotalBytes;
                    
                    uint firstValueSize = sizeLeft - 2000; 
                    uint secondValueSize = 6000;
                    //get the total value to be below the highwatermark
                    if ((beginningTotalBytes + firstValueSize + secondValueSize) > highWaterMark)
                    {
                        secondValueSize -= (beginningTotalBytes + firstValueSize + secondValueSize) - highWaterMark - 100;
                    }
                    byte[] firstKey = null;
                    byte[] firstValue = new byte[firstValueSize];
                    byte[] secondKey = null;
                    byte[] secondValue = new byte[secondValueSize];
                    //fill the values with random bits                                        
                    _random.NextBytes(firstValue);
                    _random.NextBytes(secondValue);
                    //we need two keys that map to the same bucket
                    byte[][] keys = CreateKeyArrayThatMapsToSameBucket(2, bucketNum);
                    if (keys == null) return;
                    
                    firstKey = keys[0];
                    secondKey = keys[1];

                    /***** insert one large value < low water mark, then insert another to set off drainage. *****/
                    
                    //insert value sized firstValueSize bytes
                    InsertSingleItem(firstKey, firstValue);

                    //insert value so that total inserted value >= 16384
                    //insert value sized secondValueSize bytes
                    InsertSingleItem(secondKey, secondValue);
                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.
                    //wait 1 second for heartbeat thread to remove values
                    _report.Debug("Wait for 1 second for heartbeat to remove values");
                    new SleepInfo("Wait for 1 second", 1*1000);

                    //check to see if first value was removed.
                    Query(firstKey, null, HResult.S_FALSE);
                    
                    //check to see if second value was NOT removed.
                    Query(secondKey, secondValue, HResult.S_OK);
                   
                     //remove it for cleanup
                    Remove(secondKey);
                    Remove(firstKey);
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
          [TestCase, Description("Insert one value < low water mark, one > low water mark, total size > total data storage bytes")]
         
          class P_Mainline_HWM: AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint sizeLeft = lowWaterMark - beginningTotalBytes;
                    
                    uint firstValueSize = sizeLeft - 2000; 
                    uint secondValueSize = 10000;
                    //get the total value to be below the highwatermark
                    int sizeDiff = (int)highWaterMark - (int)(beginningTotalBytes + firstValueSize + secondValueSize);
                    if (sizeDiff > 0) //make sure we can hit the lowWaterMark
                    {
                        secondValueSize += (uint)sizeDiff + 100;
                    }
                     sizeDiff = (int)lowWaterMark - ((int)beginningTotalBytes + (int)secondValueSize);
                     if (sizeDiff < 0)
                     {  
                        //sizediff is negative!
                        if ((-sizeDiff + 500) > secondValueSize)
                        {
                            throw new Exception("Can not perform this test because beginningTotalBytes is too large");
                        }
                        if (beginningTotalBytes + firstValueSize + (uint)((int)secondValueSize + sizeDiff) < highWaterMark)
                        {
                            secondValueSize = (uint)((int)secondValueSize - sizeDiff - 500);
                            firstValueSize += (uint)sizeDiff + 500;
                        }
                        else
                        {
                            secondValueSize = (uint)((int)secondValueSize + sizeDiff - 500);
                        }
                     }
                    
                    byte[] firstKey = null;
                    byte[] firstValue = new byte[firstValueSize];
                    byte[] secondKey = null;
                    byte[] secondValue = new byte[secondValueSize];
                    //fill the values with random bits                                        
                    _random.NextBytes(firstValue);
                    _random.NextBytes(secondValue);
                    //we need two keys that map to the same bucket
                    byte[][] keys = CreateKeyArrayThatMapsToSameBucket(2, bucketNum);
                    if (keys == null) return;
                    
                    firstKey = keys[0];
                    secondKey = keys[1];

                    /***** insert one large value < low water mark, then insert another to set off drainage. *****/
                    
                    //insert value sized firstValueSize bytes
                    InsertSingleItem(firstKey, firstValue);

                    //insert value so that total inserted value >= 16384
                    //insert value sized secondValueSize bytes
                    InsertSingleItem(secondKey, secondValue);
                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.
                    //wait 1 second for heartbeat thread to remove values
                    _report.Debug("Wait for 1 second for heartbeat to remove values");
                    new SleepInfo("Wait for 1 second", 1*1000);

                    //check to see if first value was removed.
                    Query(firstKey, null, HResult.S_FALSE);
                    
                    //check to see if second value was NOT removed.
                    Query(secondKey, secondValue, HResult.S_OK);
                   
                     //remove it for cleanup
                    Remove(secondKey);
                    Remove(firstKey);
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert 16 1KB values")]
         
          class P_MultipleSimple: AccelFuncTestBase
          {

               override protected void Execute()
               {
                    
                    uint hr;
                    byte[] outBytes=null;

                    //initial starting bytes
                    uint totalBytes = beginningTotalBytes;
                    uint valueSize = 3000;
                    int numValues = 16;

                    totalBytes += valueSize*(uint) numValues;
                    uint numDrained = 0;
                     //i'm too lazy to figure out the formula for this
                     while(totalBytes > lowWaterMark)
                     {
                          numDrained++;
                          totalBytes -= valueSize;
                     }

          
                    _report.Debug("Number of key/values to be drained: "+numDrained);

                    //create 1KB values, fill with random bytes
                    byte[] value = new byte[valueSize];
                    _random.NextBytes(value);
                    
                    byte[][] keyArray = CreateKeyArrayThatMapsToSameBucket(numValues, bucketNum);
                    if (keyArray == null) return;
                    

                    /***** insert 16 1KB values, should trigger drainage. *****/
                    for(int i=0; i<numValues; i++)
                    {
                        InsertSingleItem(keyArray[i], value);
                    }

                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.

                    //wait 1 second for heartbeat thread to remove values
                     _report.Debug("Wait for 1 second for heartbeat to remove values");
                    new SleepInfo("Wait for 1 second", 1*1000);
              
                    for(int i=0; i<numValues; i++)
                    {
                         hr = _xb.Query(keyArray[i], out outBytes);
                         if (i < numDrained)
                         {
                              //this one should be removed
                                if (hr != HResult.S_FALSE)
                                {
                                   throw new HResultException(hr, "Querying for supposedly MRU'd out key of index "+i+" returned: "+hr);
                                }
                         }
                         else
                         {     
                              //this key should not be removed
                              ValidateReturnedData(value, outBytes);
                         }

                         //remove them all for good measure
                         Remove(keyArray[i]);
                         
                    }
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert two values, query for first, insert another to drain second value")]
          class P_QueryForFirst: AccelFuncTestBase
          {
               override protected void Execute()
               {
                    ResultCode = TEST_RESULTS.PASSED;
                    uint firstValueSize = 500;
                    uint secondValueSize = 9000;
                    uint thirdValueSize = 1000;
                    int sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + firstValueSize + secondValueSize + thirdValueSize);
                    if (sizeDiff > 0) //make sure we can hit the lowWaterMark
                    {
                        thirdValueSize += (uint)sizeDiff + 100;
                    }
                    
                    byte[] firstKey = null, firstValue = new byte[firstValueSize];
                    byte[] secondKey = null, secondValue = new byte[secondValueSize];
                    byte[] thirdKey = null, thirdValue = new byte[thirdValueSize];
                    //fill the values with random bits
                    _random.NextBytes(firstValue);
                    _random.NextBytes(secondValue);
                    _random.NextBytes(thirdValue);

                    //create keys that map to the same server
                    byte[][] keyArray = CreateKeyArrayThatMapsToSameBucket(3, bucketNum);
                    if (keyArray == null) return;                    
                    firstKey = keyArray[0];
                    secondKey = keyArray[1];
                    thirdKey = keyArray[2];
                    
                    /***** insert two < low_water values, query for first, insert another > low watermark to set off drainage. *****/

                    InsertSingleItem(firstKey, firstValue);
                    InsertSingleItem(secondKey, secondValue);

                    //query for the first key so that the second key will be removed instead of the first
                    Query(firstKey, firstValue, HResult.S_OK);

                    //insert third key that will trigger drainage
                    InsertSingleItem(thirdKey, thirdValue);
                  
                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.

                    //wait 2 second for heartbeat thread to remove values// we need the deleted items from the previous test to be removed by the heartbeat proc, this takes 1.6 seconds
                    _report.Debug("Wait for 2 seconds for heartbeat to remove values");
                    new SleepInfo("Wait for 2 seconds", 2*1000);

                    //check to see if first value was NOT removed.
                    Query(firstKey, firstValue, HResult.S_OK);
                 
                    //check to see if third value was NOT removed.
                    Query(thirdKey, thirdValue, HResult.S_OK);

                    //check to see if second value was removed.
                    Query(secondKey, null, HResult.S_FALSE);
                   
                    Remove(firstKey);
                    Remove(secondKey);
                    Remove(thirdKey);
               }
          }

           [TestCase, Description("Insert two values, setdata first, insert another to drain second value")]
          class P_SetDataFirstValue: AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint firstValueSize = 1024;
                    uint secondValueSize = 2048;
                    uint thirdValueSize = 7024;
                    int sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + firstValueSize + secondValueSize + thirdValueSize);
                    if (sizeDiff > 0) //make sure we can hit the lowWaterMark
                    {
                        thirdValueSize += (uint)sizeDiff + 500;
                    }
                    //make sure the right things will be purged
                    sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + firstValueSize + thirdValueSize);
                    if (sizeDiff < 0)
                    {  
                        //sizediff is negative!
                        if ((-sizeDiff + 500) > thirdValueSize)
                        {
                            throw new Exception("Can not perform this test because beginningTotalBytes is too large");
                        }
                        if (beginningTotalBytes + firstValueSize + (uint)((int)thirdValueSize + sizeDiff) < lowWaterMark)
                        {
                            thirdValueSize = (uint)((int)thirdValueSize - sizeDiff - 500);
                            firstValueSize += (uint)sizeDiff + 500;
                        }
                        else
                        {
                            thirdValueSize = (uint)((int)thirdValueSize + sizeDiff - 500);
                        }
                    }
                    
                    byte[] firstKey = {56}; 
                    byte[] firstValue = new byte[firstValueSize];
                    byte[] secondKey = {254}; 
                    byte[] secondValue = new byte[secondValueSize];
                    byte[] thirdKey = {7}; 
                    byte[] thirdValue = new byte[thirdValueSize];
                    //fill the values with random bits
                    _random.NextBytes(firstValue);
                    _random.NextBytes(secondValue);
                    _random.NextBytes(thirdValue);

                    //create keys that map to the same server
                    byte[][] keyArray = CreateKeyArrayThatMapsToSameBucket(3, bucketNum);
                    if (keyArray == null) return;                    
                    firstKey = keyArray[0];
                    secondKey = keyArray[1];
                    thirdKey = keyArray[2];
                    
                    /***** insert two < low_water values, query for first, insert another > low watermark to set off drainage. *****/

                    InsertSingleItem(firstKey, firstValue);
                    InsertSingleItem(secondKey, secondValue);
                    
                    //query for the first key so that the second key will be removed instead of the first
                    SetData(firstKey, firstValue,0,0);
                    
                    //insert third key that will trigger drainage
                    InsertSingleItem(thirdKey, thirdValue);

                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.

                    //wait 1 second for heartbeat thread to remove values
                    _report.Debug("Wait for 1 second for heartbeat to remove values");
                    new SleepInfo("Wait for 1 second", 1*1000);

                    //check to see if first value was NOT removed.
                    Query(firstKey, firstValue, HResult.S_OK);
                    //check to see if second value was removed.
                    Query(secondKey, null, HResult.S_FALSE);
                    //check to see if third value was NOT removed.
                    Query(thirdKey, thirdValue, HResult.S_OK);
                     //remove it for cleanup
                    Remove(firstKey);
                    Remove(secondKey);
                    Remove(thirdKey);
                    ResultCode = TEST_RESULTS.PASSED;
                    
               }
          }

             [TestCase, Description("Insert two values, Insert first again, insert another to drain second value")]
          class P_InsertFirstAgainSameValue: AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    uint firstValueSize = 5000;
                    uint secondValueSize = 2000;
                    uint thirdValueSize = 2000;
                    int sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + firstValueSize + secondValueSize + thirdValueSize);
                    if (sizeDiff > 0) //make sure we can hit the lowWaterMark
                    {
                        thirdValueSize += (uint)sizeDiff + 500;
                    }
                    //make sure the right things will be purged
                    sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + firstValueSize + thirdValueSize);
                    if (sizeDiff < 0)
                    {  
                        //sizediff is negative!
                        if ((-sizeDiff + 500) > thirdValueSize)
                        {
                            throw new Exception("Can not perform this test because beginningTotalBytes is too large");
                        }
                        if (beginningTotalBytes + firstValueSize + (uint)((int)thirdValueSize + sizeDiff) < lowWaterMark)
                        {
                            thirdValueSize = (uint)((int)secondValueSize - sizeDiff - 500);
                            firstValueSize += (uint)sizeDiff + 500;
                        }
                        else
                        {
                            thirdValueSize = (uint)((int)thirdValueSize + sizeDiff - 500);
                        }
                    }
                    byte[] firstKey = null, firstValue = new byte[firstValueSize];
                    byte[] secondKey = null, secondValue = new byte[secondValueSize];
                    byte[] thirdKey = null,  thirdValue = new byte[thirdValueSize];
                    //fill the values with random bits
                    _random.NextBytes(firstValue);
                    _random.NextBytes(secondValue);
                    _random.NextBytes(thirdValue);
                    //create keys that map to the same server
                    byte[][] keyArray = CreateKeyArrayThatMapsToSameBucket(3, bucketNum);
                    if (keyArray == null) return;                    
                    firstKey = keyArray[0];
                    secondKey = keyArray[1];
                    thirdKey = keyArray[2];
                    
                    /***** insert two < low_water values, query for first, insert another > low watermark to set off drainage. *****/

                    InsertSingleItem(firstKey, firstValue);
                   
                    InsertSingleItem(secondKey, secondValue);

                    //insert the first key again so that the second key will be removed instead of the first
                    hr = _xb.Insert(firstKey, firstValue);
                    if (hr != HResult.S_FALSE)
                    {
                         throw new HResultException(hr, "Insert returned "+hr+" instead of S_FALSE");
                    }

                    //insert third key that will trigger drainage
                    InsertSingleItem(thirdKey, thirdValue);

                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.

                    //wait 1 second for heartbeat thread to remove values
                    _report.Debug("Wait for 1 second for heartbeat to remove values");
                    new SleepInfo("Wait for 1 second", 1*1000);

                    //check to see if first value was NOT removed.
                    Query(firstKey, firstValue, HResult.S_OK);
                    //check to see if second value was removed.
                    Query(secondKey, null, HResult.S_FALSE);
                 
                     //check to see if third value was NOT removed.
                    Query(thirdKey, thirdValue, HResult.S_OK);
                
                     //remove it for cleanup
                   Remove(firstKey);
                   Remove(secondKey);
                   Remove(thirdKey);

                   ResultCode = TEST_RESULTS.PASSED;
                   
                    
               }
          }

          [TestCase, Description("Insert two values, Insert first again with different value, insert another to drain second value")]
          class P_InsertFirstAgainDiffValue: AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    uint firstValueSize = 5000;
                    uint secondValueSize = 2000;
                    uint thirdValueSize = 2000;
                    int sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + firstValueSize + secondValueSize + thirdValueSize);
                    if (sizeDiff > 0) //make sure we can hit the lowWaterMark
                    {
                        thirdValueSize += (uint)sizeDiff + 500;
                    }
                  
                    byte[] firstKey = null, firstValue = new byte[firstValueSize];
                    byte[] secondKey = null, secondValue = new byte[secondValueSize];
                    byte[] thirdKey = null,  thirdValue = new byte[thirdValueSize];
                    //fill the values with random bits
                    _random.NextBytes(firstValue);
                    _random.NextBytes(secondValue);
                    _random.NextBytes(thirdValue);

                    //create keys that map to the same server
                    byte[][] keyArray = CreateKeyArrayThatMapsToSameBucket(3, bucketNum);
                    if (keyArray == null) return;
                    firstKey = keyArray[0];
                    secondKey = keyArray[1];
                    thirdKey = keyArray[2];
                    
                    /***** insert two < low_water values, query for first, insert another > low watermark to set off drainage. *****/

                    InsertSingleItem(firstKey, firstValue);
                    InsertSingleItem(secondKey, secondValue);

                    //insert the first key with a different value. This will not count as an access, so that the first key will be removed instead of the second
                    byte[] newFirstValue = _enc.GetBytes("a different value");
                    hr = _xb.Insert(firstKey, newFirstValue);
                    if (hr != HResult.E_ACCESSDENIED)
                    {
                         throw new HResultException(hr, "Insert returned "+hr+" instead of E_ACCESSDENIED");
                    }

                    //insert third key that will trigger drainage
                    InsertSingleItem(thirdKey, thirdValue);

                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.

                    //wait 1 second for heartbeat thread to remove values
                    _report.Debug("Wait for 1 seconds for heartbeat to remove values");
                    new SleepInfo("Wait for 1 second", 1*1000);

                    //check to see if first value was removed.
                    Query(firstKey, null, HResult.S_FALSE);
                    
                    //check to see if second value was NOT removed.
                    Query(secondKey, secondValue, HResult.S_OK);
                
                     //check to see if third value was NOT removed.
                    Query(thirdKey, thirdValue, HResult.S_OK);
                     //remove it for cleanup
                    Remove(firstKey);
                    Remove(secondKey);
                    Remove(thirdKey);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert four values, remove fourth, insert fifth and another to drain five previous values")]
          class P_MRURemoveAnAlreadyRemovedValue: AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint fourthValueSize = 2000;
                    uint fifthValueSize = 1000;
                    uint sixthValueSize = 5000;
                    int sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + fourthValueSize + fifthValueSize + 3 * 1024);
                    if (sizeDiff < 0)  //1+2+3+4+5 < LWM
                    {
                        if ((int)fifthValueSize < -sizeDiff)
                        {
                            sizeDiff += (int)fifthValueSize;
                            fifthValueSize = 1;
                            fourthValueSize += (uint)sizeDiff;
                        }
                        else
                        {
                            fifthValueSize += (uint)sizeDiff - 1;
                        }
                    }
                    sizeDiff = (int)lowWaterMark - ((int)beginningTotalBytes + (int)fifthValueSize + (int)sixthValueSize + 3 * 1024);
                    if (sizeDiff > 0)
                    {
                        sixthValueSize += (uint)sizeDiff + 500;
                    }
                      //make sure the right things will be purged
                    sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + fifthValueSize + sixthValueSize);
                    if (sizeDiff < 0)
                    {  
                        //sizediff is negative!
                        if ((-sizeDiff + 500) > sixthValueSize)
                        {
                            throw new Exception("Can not perform this test because beginningTotalBytes is too large");
                        }
                        if (beginningTotalBytes + fifthValueSize + (uint)((int)sixthValueSize + sizeDiff) < lowWaterMark)
                        {
                            sixthValueSize = (uint)((int)sixthValueSize - sizeDiff - 500);
                            fifthValueSize += (uint)sizeDiff + 500;
                        }
                        else
                        {
                            sixthValueSize = (uint)((int)sixthValueSize + sizeDiff - 500);
                        }
                    }
                    
                    Random random = new Random();
                    byte[][] firstKeys = {new byte[]{1},new byte[]{2}, new byte[]{3}}; 
                    byte[] fourthKey = {100};
                    byte[] fourthValue = new byte[fourthValueSize];
                    byte[] fifthKey = {150}; 
                    byte[] fifthValue = new byte[fifthValueSize];
                    byte[] sixthKey = {200}; 
                    byte[] sixthValue = new byte[sixthValueSize];
                    //fill the values with random bits
                    random.NextBytes(fourthValue);
                    random.NextBytes(fifthValue);
                    random.NextBytes(sixthValue);

                    //create keys that map to the same server
                    byte[][] keyArray = CreateKeyArrayThatMapsToSameBucket(6, bucketNum);
                    if (keyArray == null) return;
                    firstKeys[0] = keyArray[0];
                    firstKeys[1] = keyArray[1];
                    firstKeys[2] = keyArray[2];
                    fourthKey = keyArray[3];
                    fifthKey = keyArray[4];
                    sixthKey = keyArray[5];

                    for (int i=0; i<3; i++)
                    {
                         InsertSingleItem(firstKeys[i],new byte[1024]);
                    } // 3 * 1024 inserted 
                    
                    InsertSingleItem(fourthKey, fourthValue);
                    InsertSingleItem(fifthKey, fifthValue);

                    //throw things awry by removing the fourth key! 
                    Remove(fourthKey);

                    //insert sixth key that will trigger drainage
                    InsertSingleItem(sixthKey, sixthValue);

                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.

                    //wait 1 second for heartbeat thread to remove values
                    _report.Debug("Wait for 1 seconds for heartbeat to remove values");
                    new SleepInfo("Wait for 1 second", 1000);

                    //check to see if sixth value was NOT removed.
                    Query(sixthKey, sixthValue, HResult.S_OK);
                
                    //check to see if fifth value was NOT removed.
                    Query(fifthKey, fifthValue, HResult.S_OK);

                    //check to see if first values were removed.
                     for (int i=0; i<3; i++)
                    {
                         Query(firstKeys[i], null, HResult.S_FALSE);
                    }
                     //check to see if fourth value was removed.
                    Query(fourthKey, null, HResult.S_FALSE);
                   
                                     
                     //remove it for cleanup
                    Remove(sixthKey);
                    Remove(fifthKey);
                    Remove(fourthKey);
                    for (int i=0; i<3; i++)
                    {
                        Remove(firstKeys[i]);
                    }
                 
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
      }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\AccelFuncMulti.cs ===
using System;
using System.Threading;
using ServerTestFramework;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;


namespace AccelTest
{
     public class AccelFuncMulti : TestNode
     {
           [TestCase]
          class P_MultiInsertToDifferentServers : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint[] expectedHRArray = new uint[20];
                    byte[][] keys = new byte[20][];
                    byte[][] tempKeys = null;
                    byte[][] values = new byte[20][];
                    DateTime ooo = DateTime.Now;
                    long ticksPerSecond = ooo.AddSeconds(1).Ticks - ooo.Ticks;

                    for(int i=0; i<keys.Length; i+=2)
                    {
                           tempKeys = CreateKeyArrayThatMapsToDifferentServers(2);
                           keys[i] = tempKeys[0];
                           keys[i+1] = tempKeys[1];
                    }
                    
                    for(int i=0; i<values.Length; i++)
                    {
                        values[i] = CreateValue();
                        expectedHRArray[i] = HResult.S_OK;
                    }

                    InsertMultipleItems(keys, values);

                    DateTime now = DateTime.Now;
                    double timePassed = 0;
                    DateTime then = DateTime.Now;
                    long ticksPassed = 0;

                    for(int j=1; j<5; j++)
                    {
                        now = DateTime.Now;

                        uint[] hr;
                        byte[][] outvalue;
                        uint[] outseconds = null;
                        
                        hr = _xb.Query(keys,  out outvalue, out outseconds);
                        then = DateTime.Now;
                        
                        if(hr == null || hr.Length !=expectedHRArray.Length)
                        {
                            throw new Exception("Query returned results were null when not expected.");                     
                        }
                        for(int i=0; i< hr.Length; i++)
                        {
                            if (hr[i] != expectedHRArray[i])
                            {
                                throw new HResultException(hr[i], "Query returned "+hr[i]+" instead of "+expectedHRArray[i]+" for the "+i+"th key.");
                            }
                        }
                        if (values != null && outvalue != null)
                        {
                             for(int i=0; i< values.Length; i++)
                            {
                                if(expectedHRArray[i] == HResult.S_OK)
                                {
                                    ValidateReturnedData(values[i], outvalue[i]);
                                }
                            }
                        }

                        
                        timePassed = 0;

                        ticksPassed = then.Ticks - now.Ticks;
                        timePassed = ticksPassed / (double) ticksPerSecond;
                        
                        _report.Debug(j+". querying for "+keys.Length+" existing keys took "+timePassed+" seconds.");

                        now = DateTime.Now;
                    }

                    Remove(keys);
                    ResultCode = TEST_RESULTS.PASSED;
               }
           }
           
            [TestCase]
            class P_MultiInsertToSameBucket: AccelFuncTestBase
          {
               override protected void Execute()
               {
                    DateTime ooo = DateTime.Now;
                    long ticksPerSecond = ooo.AddSeconds(1).Ticks - ooo.Ticks;
                     /***** insert into all into last bucket, bucket 419       *****/
                    byte[][] keys1 = CreateKeyArrayThatMapsToSameBucket(5, 419);
                    byte[][] keys = new byte[keys1.Length+5][];

                    int fastfailtimeoutperiod = (int)Config.GetUIntSetting(Setting.xbanc_fastFailBlockIntervalSeconds);

                    
                    for(int i=0; i<keys1.Length; i++)
                    {
                        keys[i*2] = keys1[i];
                        if ((i*2+1) < keys.Length)
                        {
                            keys[i*2+1] = CreateKey(); //if only 419 is mapped to the dead server, then there is a 1/419 chance this key will be mapped to the dead server
                        }
                    }
                    
                    byte[][] values = new byte[keys.Length][];
                    uint[] hr;
                    uint[] seconds;
                    
                    DateTime now = DateTime.Now;
                    double timePassed = 0;
                    DateTime then = DateTime.Now;
                    long ticksPassed = 0;
                    int countFails = 0;
                    int interation =0;
                    DateTime nanny = DateTime.Now;
                    
                    while((DateTime.Now.Ticks - nanny.Ticks)/ticksPerSecond< fastfailtimeoutperiod + 10)
                    {
                        now = DateTime.Now;

                        hr = _xb.Query(keys, out values, out seconds);

                        then = DateTime.Now;

                        ticksPassed = then.Ticks - now.Ticks;
                        timePassed = ticksPassed / (double) ticksPerSecond;
                        
                        _report.Debug(interation+". querying for "+keys.Length+" existing keys took "+timePassed+" seconds.");

                        countFails = 0;
                        foreach(uint h in hr)
                        {
                            if (HResult.Failed(h))
                                countFails++;
                        }
                        _report.Debug(interation+". querying for "+keys.Length+" encountered "+countFails+" failures.");
                        interation++;
                        
                        Thread.Sleep(500);
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\AccelFuncQuery.cs ===
using System;
using System.Threading;
using ServerTestFramework;

using xonline.common.protocol;
using xonline.common.service;


namespace AccelTest
{
     public class AccelFuncQuery : TestNode
     {
          [TestCase]
          class P_ReservationExpiration : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    long ticksPerSecond = 10000000;
                    byte[] key = null, value = null;

                    CreateKeyValuePair(out key, out value);

                    DateTime timeNanny = DateTime.Now;
                    QueryCheckTime(key, null, _reservationExpirySeconds, HResult.S_FALSE);

                    long secondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond;
                    while (secondsPassed < _reservationExpirySeconds)
                    {
                        secondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond; 
                        QueryCheckTime(key, null, _reservationExpirySeconds - (uint)secondsPassed, HResult.S_FALSE);

                        _report.Debug(secondsPassed + " seconds have passed");

                        Thread.Sleep(1000);
                        secondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond;
                    }
                     //sleep for 1000 milliseconds
                     Thread.Sleep(1000);
                     
                    //reservation should have expired

                    //we shouldn't see the inserted data, but we should create a new reservation
                    QueryCheckTime(key, null, _reservationExpirySeconds, HResult.S_FALSE);

                    // try to insert over the expired reservation, it *should* work
                    hr = _xb.Insert(key, value, 0, 0);
                    if (hr != HResult.S_OK)
                    {
                        throw new HResultException(hr, "Insert returned " + hr + " instead of S_OK");
                    }

                    Remove(key);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class N_Parameter_Null_Cases : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] value = null;
                    
                    hr = _xb.Query(null, out value);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hr, "Calling Query with null key returned "+hr+" instead of E_INVALIDARG");                     
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase]
          class N_Parameter_Empty_Cases : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    byte[] key = new byte[0];
                    byte[] value = null;

                    hr = _xb.Query(key, out value);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hr, "Calling Query with empty key returned "+hr+" instead of E_INVALIDARG");                     
                    }
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\AccelFuncNotif.cs ===
using System;
using System.Threading;
using ServerTestFramework;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;


namespace AccelTest
{
     public class AccelFuncNotif : TestNode
     {

         

         [TestCase]
         class P_Unregister_Cases : AccelFuncTestBase
         {

             override protected void Execute()
             {
                 uint hr;
                 byte[] key = CreateKey();
                 Acceleration accel2 = new Acceleration(Interface.acceleration);
                 
                 //one handler!
                 handler2Called = false;
                 _xb.RegisterNotificationHandler(Handler2);
                 _xb.RegisterNotificationFailureHandler(null);

                 hr = accel2.SetData(key, key, 0, 0);
                 if (hr != HResult.S_OK)
                 {
                     throw new HResultException(hr, "SetData returned " + hr + " instead of S_OK.");
                 }

                 if (!WaitForValuesToBecomeTrue(new bool[] { handler2Called}))
                 {
                     throw new Exception("Handler were not called as expected for 1 minute.");
                 }

                 _xb.UnregisterHandlers();
                 handler2Called = false;

                 hr = accel2.SetData(key, key, 0, 0);
                 if (hr != HResult.S_OK)
                 {
                     throw new HResultException(hr, "SetData returned " + hr + " instead of S_OK.");
                 }
                 if (!WaitForValuesToNotBecomeTrue(new bool[] { handler2Called }))
                 {
                     throw new Exception("Unregistered handler was called unexpectedly.");
                 }
                 
                 //two handlers!
                 handler3Called = false;
                 handler2Called = false;
                 _xb.RegisterNotificationHandler(Handler3);
                 _xb.RegisterNotificationHandler(Handler2);

                 hr = accel2.SetData(key, key, 0, 0);
                 if (hr != HResult.S_OK)
                 {
                     throw new HResultException(hr, "SetData returned " + hr + " instead of S_OK.");
                 }

                 if (!WaitForValuesToBecomeTrue(new bool[] { handler2Called, handler3Called }))
                 {
                     throw new Exception("Multiple handlers were not called as expected for 1 minute.");
                 }

                 _xb.UnregisterHandlers();
                 handler2Called = false;
                 handler3Called = false;
                 hr = accel2.SetData(key, key, 0, 0);
                 if (hr != HResult.S_OK)
                 {
                     throw new HResultException(hr, "SetData returned " + hr + " instead of S_OK.");
                 }
                 if (!WaitForValuesToNotBecomeTrue(new bool[] { handler2Called, handler3Called }))
                 {
                     throw new Exception("Unregistered handler was called unexpectedly.");
                 }


                 //both handlers!
                 handler2Called = false;
                 failureCalled = false;
                 _xb.RegisterNotificationHandler(Handler2);
                 _xb.RegisterNotificationFailureHandler(FailureNotif);

                 //TODO: Trigger failure call
                 hr = accel2.SetData(key, key, 0, 0);
                 if (hr != HResult.S_OK)
                 {
                     throw new HResultException(hr, "SetData returned " + hr + " instead of S_OK.");
                 }

                 if (!WaitForValuesToBecomeTrue(new bool[] { handler2Called, failureCalled }))
                 {
                     throw new Exception("Handlers were not called as expected for 1 minute.");
                 }

                 _xb.UnregisterHandlers();
                 handler2Called = false;
                 failureCalled = false;

                 hr = accel2.SetData(key, key, 0, 0);
                 if (hr != HResult.S_OK)
                 {
                     throw new HResultException(hr, "SetData returned " + hr + " instead of S_OK.");
                 }
                 if (!WaitForValuesToNotBecomeTrue(new bool[] { handler2Called, failureCalled }))
                 {
                     throw new Exception("Unregistered handler was called unexpectedly.");
                 }

                 
                 //two both handlers!
                 handler3Called = false;
                 handler2Called = false;
                 failureCalled = false;
                 failure2Called = false;
                 _xb.RegisterNotificationHandler(Handler3);
                 _xb.RegisterNotificationHandler(Handler2);
                 _xb.RegisterNotificationFailureHandler(FailureNotif);
                 _xb.RegisterNotificationFailureHandler(FailureNotif2);
                 
                 //TODO: Trigger failure call
                 hr = accel2.SetData(key, key, 0, 0);
                 if (hr != HResult.S_OK)
                 {
                     throw new HResultException(hr, "SetData returned " + hr + " instead of S_OK.");
                 }
                 if (!WaitForValuesToBecomeTrue(new bool[] { handler2Called, handler3Called, failureCalled, failure2Called}))
                 {
                     throw new Exception("Multiple handlers were not called as expected for 1 minute.");
                 }

                 _xb.UnregisterHandlers();
                 handler2Called = false;
                 handler3Called = false;
                 failureCalled = false;
                 failure2Called = false;

                 //TODO: Trigger failure call
                 hr = accel2.SetData(key, key, 0, 0);
                 if (hr != HResult.S_OK)
                 {
                     throw new HResultException(hr, "SetData returned " + hr + " instead of S_OK.");
                 }
                 if (!WaitForValuesToNotBecomeTrue(new bool[] { handler2Called, handler3Called, failureCalled, failure2Called }))
                 {
                     throw new Exception("Unregistered handler was called unexpectedly.");
                 }

                 _xb.UnregisterHandlers();

                 ResultCode = TEST_RESULTS.PASSED;
             }
         }

         [TestCase]
         class P_Key_Value_Cases : AccelFuncTestBase
         {

             override protected void Execute()
             {
                 Acceleration accel2 = new Acceleration(Interface.acceleration);
                 byte[][] keys = new byte[100][];
                 
                 for (int i = 0; i < keys.Length; i++)
                 {
                     keys[i] = CreateKey(128);
                 }

                 //the set data logic should take care of our needs
                 SetData(keys, keys);

                 for (int i = 0; i < keys.Length; i++)
                 {
                     if (i % 3 != 0)
                     {
                         keys[i] = CreateKey();
                     }
                     if (i % 10 == 0)
                     {
                         keys[i] = new byte[] { (byte)i };
                     }
                 }

                 //the set data logic should take care of our needs
                 SetData(keys, keys);

                 for (int i = 0; i < keys.Length; i++)
                 {
                    keys[i] = new byte[] { (byte)i };
                 }

                 //the set data logic should take care of our needs
                 SetData(keys, keys);

                 keys = new byte[10][];
                 byte[][] keysToVerify = new byte[30][];
                 uint[] expiry = new uint[10];
                 int index = 0;
                 for (int i = 0; i < keys.Length; i++)
                 {
                     keys[i] = CreateKey();
                     keysToVerify[index++] = keys[i];
                     keysToVerify[index++] = keys[i];
                     keysToVerify[index++] = keys[i];
                 }
                 byte[][] values1 = new byte[10][];
                 for (int i = 0; i < values1.Length; i++)
                 {
                     values1[i] = CreateKey();
                 }
                 byte[][] values2 = new byte[10][];
                 for (int i = 0; i < values2.Length; i++)
                 {
                     values2[i] = CreateKey();
                 }

                 RegisterRegularNotificationHandler(keysToVerify);
                 uint[] hra = accel2.SetData(keys, keys, expiry, expiry);
                 foreach (uint h in hra)
                 {
                     if (h != HResult.S_OK)
                     {
                         throw new HResultException(h, "SetData returned " + h + " instead of S_OK.");
                     }
                 }
                 hra = accel2.SetData(keys, values1, expiry, expiry);
                 foreach (uint h in hra)
                 {
                     if (h != HResult.S_OK)
                     {
                         throw new HResultException(h, "SetData returned " + h + " instead of S_OK.");
                     }
                 }
                 hra = accel2.SetData(keys, values2, expiry, expiry);
                 foreach (uint h in hra)
                 {
                     if (h != HResult.S_OK)
                     {
                         throw new HResultException(h, "SetData returned " + h + " instead of S_OK.");
                     }
                 }

                 WaitForNotificationHandlerToFire();
                 UnregisterRegularNotificationHandler();

                 _xb.UnregisterHandlers();

                 ResultCode = TEST_RESULTS.PASSED;
            }
         }


          [TestCase]
          class P_Null_Handeler_Cases : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] key = CreateKey();
                    //both null
                    _xb.RegisterNotificationHandler(null);
                    _xb.RegisterNotificationFailureHandler(null);
                    //no exception should be thrown
                    //Todo: Generate a failure for notifications
                    SetData(key, key);
                    Thread.Sleep(2000);
                    _xb.UnregisterHandlers();
                   
                    //one null
                    _expectedKeys.Clear();
                    _expectedKeys.Add(key);
                    _compareFunction = RegularCompareKeys;
                    _xb.RegisterNotificationHandler(NotificationHandler);
                    _xb.RegisterNotificationFailureHandler(null);

                    //no exception should be thrown
                    //Todo: Generate a failure for notifications
                    SetData(key, key);
                    WaitForNotificationHandlerToFire();
                    _xb.UnregisterHandlers();

                    failureCalled = false;
                    _xb.RegisterNotificationHandler(null);
                    _xb.RegisterNotificationFailureHandler(FailureNotif);
                    //Todo: Generate a failure for notifications
                    //no exception should be thrown
                    SetData(key, key);
                    if (! WaitForValuesToBecomeTrue(new bool[]{failureCalled}))
                    {
                        throw new Exception("Multiple handlers were not called as expected for 1 minute.");
                    }
                    if (failureCalled == false)
                    {
                        throw new Exception("Failure notification handler not called when regular handler was null.");
                    }
                    _xb.UnregisterHandlers();

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

         [TestCase]
         class P_Multiple_Handler_Cases : AccelFuncTestBase
         {

             override protected void Execute()
             {
                 uint hr;
                 byte[] key = CreateKey();
                 Acceleration accel2 = new Acceleration(Interface.acceleration);
                 Acceleration accel3 = new Acceleration(Interface.acceleration);

                 handler3Called = false;
                 handler2Called = false;
                 _xb.RegisterNotificationHandler(Handler3);
                 _xb.RegisterNotificationHandler(Handler2);
                 _xb.RegisterNotificationFailureHandler(null);
                 
                 SetData(key, key);

                 if (!WaitForValuesToBecomeTrue(new bool[] { handler2Called, handler3Called }))
                 {
                     throw new Exception("Multiple handlers were not called as expected for 1 minute.");
                 }
                 if (_retKeys3 == null || _retKeys2 == null)
                 {
                     throw new Exception("Returned keys in multiple notification handlers were null.");
                 } 
                 //strict comparison, yes i know, but we only changed one key
                 if (_retKeys3.Length != 1 || _retKeys2.Length != 1)
                 {
                     throw new Exception("Returned key lengths in multiple notification handlers were not expected lengths.");
                 }
                 if (!Acceleration.CompareByteArrays(key, _retKeys2[0]))
                 {
                     throw new Exception("Returned key from second notification handler was not expected key.");
                 }
                 if (!Acceleration.CompareByteArrays(key, _retKeys3[0]) )
                 {
                     throw new Exception("Returned key from third notification handler was not expected key.");
                 }

                 //use a different acceleration instance
                 handler3Called = false;
                 handler2Called = false;
                 _xb.RegisterNotificationHandler(Handler3);
                 _xb.RegisterNotificationHandler(Handler2);

                 hr = accel2.SetData(key, key, 0, 0);
                 if (hr != HResult.S_OK)
                 {
                     throw new HResultException(hr, "SetData returned " + hr + " instead of S_OK.");
                 }

                 if (!WaitForValuesToBecomeTrue(new bool[] { handler2Called, handler3Called }))
                 {
                     throw new Exception("Multiple handlers were not called as expected for 1 minute.");
                 }
                 if (_retKeys3 == null || _retKeys2 == null)
                 {
                     throw new Exception("Returned keys in multiple notification handlers were null.");
                 }
                 //strict comparison, yes i know, but we only changed one key
                 if (_retKeys3.Length != 1 || _retKeys2.Length != 1)
                 {
                     throw new Exception("Returned key lengths in multiple notification handlers were not expected lengths.");
                 }
                 if (!Acceleration.CompareByteArrays(key, _retKeys2[0]))
                 {
                     throw new Exception("Returned key from second notification handler was not expected key.");
                 }
                 if (!Acceleration.CompareByteArrays(key, _retKeys3[0]))
                 {
                     throw new Exception("Returned key from third notification handler was not expected key.");
                 }

                 //use a different acceleration instance
                 handler3Called = false;
                 handler2Called = false;
                 hr = accel3.SetData(key, key, 0, 0);
                 if (hr != HResult.S_OK)
                 {
                     throw new HResultException(hr, "SetData returned " + hr + " instead of S_OK.");
                 }

                 if (!WaitForValuesToBecomeTrue(new bool[] { handler2Called, handler3Called }))
                 {
                     throw new Exception("Multiple handlers were not called as expected for 1 minute.");
                 }
                 if (_retKeys3 == null || _retKeys2 == null)
                 {
                     throw new Exception("Returned keys in multiple notification handlers were null.");
                 }
                 //strict comparison, yes i know, but we only changed one key
                 if (_retKeys3.Length != 1 || _retKeys2.Length != 1)
                 {
                     throw new Exception("Returned key lengths in multiple notification handlers were not expected lengths.");
                 }
                 if (!Acceleration.CompareByteArrays(key, _retKeys2[0]))
                 {
                     throw new Exception("Returned key from second notification handler was not expected key.");
                 }
                 if (!Acceleration.CompareByteArrays(key, _retKeys3[0]))
                 {
                     throw new Exception("Returned key from third notification handler was not expected key.");
                 }

                 _xb.UnregisterHandlers();

                 ResultCode = TEST_RESULTS.PASSED;
             }
         }

          
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\AccelFuncRemove.cs ===
using System;
using ServerTestFramework;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;


namespace AccelTest
{
     public class AccelFuncRemove : TestNode
     {
           [TestCase, Description("Remove simple test cases: null paramater, nonexistent key without flag")]
          class P_NonExistentKeys : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    uint[] hrArray;

                    /***** pass in nonexistent key without match flag *****/
                    hr = _xb.Remove(_enc.GetBytes("Test nonexistent key!!!!!"));
                    if (hr != HResult.S_FALSE)
                    {
                        throw new HResultException(hr, "Remove returned "+hr+" instead of S_FALSE");
                    }

                    /***** pass in nonexistent keys *****/
                    hrArray = _xb.Remove(new byte[][] {_enc.GetBytes("Testnonexistant!"),_enc.GetBytes("Testnonexistan2222t!"), _enc.GetBytes("Testnonexisalskdjflaks;jdftant!")} );
                    if (hrArray == null || hrArray.Length != 3)
                    {
                        throw new Exception("Calling remove with 3 non-existant keys returned an unexpected HResult array");
                    }
                    for(int i=0; i<3; i++)
                    {
                        if (hrArray[i] != HResult.S_FALSE)
                        {
                            throw new HResultException(hrArray[i], "Remove returned "+hrArray[i]+" instead of S_FALSE");
                        }
                    }

                    /***** pass in nonexistent key with match flag true *****/
                    hr = _xb.Remove(_enc.GetBytes("Test nonexistent key!!!!!"),true);
                    if (hr != HResult.S_FALSE)
                    {
                          throw new HResultException(hr, "Remove returned "+hr+" instead of S_FALSE");
                    }
                    
                    ResultCode = TEST_RESULTS.PASSED;
                    
               }
          }

           [TestCase]
          class P_MultiRemove: AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint[] hrArray;
                    uint[] expectedHRArray = new uint[4];
                    byte[][] keysToRemove = new byte[4][];
                    byte[][] keysToInsert = null;
                    byte[][] values = new byte[2][];
                    
                    keysToInsert = CreateKeyArrayThatMapsToDifferentServers(2);
                    values[0] = CreateValue();
                    values[1] = CreateValue();

                    InsertMultipleItems(keysToInsert, values, new uint [keysToInsert.Length], new uint [keysToInsert.Length]);

                    byte[][] tempKeys = CreateKeyArrayThatMapsToDifferentServers(2);
                    keysToRemove[0] = keysToInsert[0];
                    keysToRemove[1] = tempKeys[0];
                    keysToRemove[2] = keysToInsert[1];
                    keysToRemove[3] = tempKeys[1];
                    expectedHRArray[0] = HResult.S_OK;
                    expectedHRArray[1] = HResult.S_FALSE;
                    expectedHRArray[2] = HResult.S_OK;
                    expectedHRArray[3] = HResult.S_FALSE;                 
                        

                    /***** Remove the keys *****/
                    hrArray = _xb.Remove(keysToRemove);
                    if (hrArray == null || hrArray.Length != 4)
                    {
                        throw new Exception("Calling remove with 4 keys returned an unexpected HResult array");
                    }
                    for(int i=0; i<hrArray.Length; i++)
                    {
                        if (hrArray[i] != expectedHRArray[i])
                        {
                            throw new HResultException(hrArray[i], "Remove returned "+hrArray[i]+" instead of "+expectedHRArray[i]);
                        }
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
          
          [TestCase, Description("Remove exact key with true matchexact")]
          
          class P_ExactKeyTrueMatch : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    string[] keys = {      "Key1",
                                                       "Key11",
                                                       "Key1K",
                                                       "Key11K",
                                                       "Key2"};
                    string keyToRemove = "Key11K";
                    string[] keysToCheck = {"Key1",
                                                            "Key11",
                                                            "Key1K",
                                                            "Key2"};

                    /***** Valid exact key, true match exact, should only erase one key *****/
                    RemoveTestHelper(keys, keyToRemove, keysToCheck,true,HResult.S_OK);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

          //Not supported in Acceleration
          //[TestCase, Description("Remove exact key with false matchexact")]
          //class P_ExactKeyFalseMatch : AccelFuncTestBase
          //{
          //     override protected void Execute()
          //     {
          //          string[] keys = {      "Key1",
          //                                             "Key11",
          //                                             "Key1K",
          //                                             "Key11K",
          //                                             "Key2"};
          //          string keyToRemove = "Key1K";
          //          string[] keysToCheck = {"Key1",
          //                                                  "Key11",
          //                                                  "Key11K",
          //                                                  "Key2"};
          //          /***** Valid exact key, false match exact, should only erase one key *****/
          //          RemoveTestHelper(keys, keyToRemove, keysToCheck,false,HResult.S_OK);                  
          //          ResultCode = TEST_RESULTS.PASSED;
          //     }
          //}
          
          [TestCase, Description("Remove exact and prefixed key with true matchexact")]
          class P_PreFixExactKeyTrueMatch : AccelFuncTestBase
          {
                override protected void Execute()
                {
                    string[] keys = {      "Key1",
                                                       "Key11",
                                                       "Key1K",
                                                       "Key11K",
                                                       "Key2"};
                    string keyToRemove = "Key11";
                    string[] keysToCheck = {"Key1",
                                                            "Key1K",
                                                            "Key11K",
                                                            "Key2"};

                    /***** Valid prefix and exact key, true match exact, should only erase one key *****/
                    RemoveTestHelper(keys, keyToRemove, keysToCheck, true,HResult.S_OK);
                    ResultCode = TEST_RESULTS.PASSED;
                }
          }

          //Not supported in Acceleration
          //  [TestCase, Description("Remove subtree by prefix tree with false matchexact")]
          //class P_PreFixOnlyKeyFalseMatch : AccelFuncTestBase
          //{
          //     override protected void Execute()
          //     {
          //          string[] keys = {      "a",
          //                                             "Z",
          //                                             "K",
          //                                             "Key",
          //                                             "Key11",
          //                                             "Key1K",
          //                                             "Key11K"};
          //          string keyToRemove = "Ke";
          //          string[] keysToCheck = {"a",
          //                                                  "Z",
          //                                                  "K",};
          //          string[] deletedKeysToCheck = {  "Key",
          //                                                                 "Key11",
          //                                                                 "Key1K",
          //                                                                 "Key11K"};
          //          /***** Valid prefix but non-exact key, false match exact, should erase subtree *****/
          //          RemoveTestHelper(keys, keyToRemove, keysToCheck,  false,HResult.S_OK);
          //          ResultCode = TEST_RESULTS.PASSED;
          //          //verify deleted subtree is indeed deleted
          //          foreach(string key in deletedKeysToCheck)
          //          {
          //              Query(_enc.GetBytes(key), null, HResult.S_FALSE);
          //          }
          //     }
          //}

          //Not supported in Acceleration
          //[TestCase, Description("Remove entire subtree by prefix tree with false matchexact")]
          //class P_PreFixKeyEntireFalseMatch : AccelFuncTestBase
          //{
          //      override protected void Execute()
          //      {
          //          string[] keys = {      "A",
          //                                         "Key1",
          //                                         "Key11",
          //                                         "Key1K",
          //                                         "K2345678911234567892123456789312345678941234567895123456789612345678971234567898123456789912345678901234567891123456789212345678",
          //                                         "Key11K"};
          //          string keyToRemove = "K";
          //          string[] keysToCheck = {"A"};
          //          string[] deletedKeysToCheck = {  "Key1",
          //                                                             "Key11",
          //                                                             "Key1K",
          //                                                             "K2345678911234567892123456789312345678941234567895123456789612345678971234567898123456789912345678901234567891123456789212345678",
          //                                                             "Key11K"};
          //          /***** Valid entire tree prefix but non-exact key, false match exact, should erase entire subtree *****/
          //          RemoveTestHelper(keys, keyToRemove, keysToCheck, false,HResult.S_OK);
          //          //verify deleted subtree is indeed deleted
          //          foreach(string key in deletedKeysToCheck)
          //          {
          //              Query(_enc.GetBytes(key), null, HResult.S_FALSE);
          //          }
          //          ResultCode = TEST_RESULTS.PASSED;
          //      }
          //}

          [TestCase, Description("Remove nonexistent prefix key with true matchexact")]
          class P_NonExistentKeyTrueMatch : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    string[] keys = {      "A",
                                                       "Key1",
                                                       "Key11",
                                                       "Key1K",
                                                       "Key1Kkkkkkkkk",
                                                       "Key11K"};
                    string keyToRemove = "Key1Kj";
                    string[] keysToCheck = {"A",
                                                       "Key1",
                                                       "Key11",
                                                       "Key1K",
                                                       "Key1Kkkkkkkkk",
                                                       "Key11K"};
                    //remove the keys just incase a previous test failed.
                    foreach (string s in keys)
                    {
                        _xb.Remove(_enc.GetBytes(s));
                    }
                    _xb.Remove(_enc.GetBytes(keyToRemove));
                    

                    //TODO: does remove no longer return S_FALSE if nothing was removed?
                                                            
                   /***** invalid key and prefix, true match exact, should erase nothing *****/
                  RemoveTestHelper(keys, keyToRemove, keysToCheck, true,HResult.S_FALSE);
                  ResultCode = TEST_RESULTS.PASSED;
               }
          }

          //Not supported in Acceleration
          // [TestCase, Description("Remove nonexistent prefix key with false matchexact")]
          //class P_NonExistentKeyFalseMatch : AccelFuncTestBase
          //{
          //     override protected void Execute()
          //     {
          //          string[] keys = {      "A",
          //                                             "Key1",
          //                                             "Key11",
          //                                             "Key1K",
          //                                             "Key1Kkkkkkkkk",
          //                                             "Key11K"};
          //          string keyToRemove = "Key1Kj";
          //          string[]keysToCheck = {"A",
          //                                             "Key1",
          //                                             "Key11",
          //                                             "Key1K",
          //                                             "Key1Kkkkkkkkk",
          //                                             "Key11K"};
          //         /***** invalid key and prefix, false match exact, should erase nothing *****/
          //         //2 Since Matt was lazy, the Remove call will return S_OK, even though it did not remove anything.
          //        RemoveTestHelper(keys, keyToRemove, keysToCheck, false,HResult.S_OK);
          //        ResultCode = TEST_RESULTS.PASSED;
          //     }
          //}

         [TestCase, Description("Remove prefix but not exact key with true matchexact")]
          class P_PreFixOnlyKeyTrueMatch : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string[] keys = {      "A",
                                                       "Key1",
                                                       "Key111",
                                                       "Key111K",
                                                       "Key1Kkkkkkkkk",
                                                       "Key11K"};
                    string keyToRemove = "Key11";
                    string[] keysToCheck = { "A",
                                                       "Key1",
                                                       "Key111",
                                                       "Key111K",
                                                       "Key1Kkkkkkkkk",
                                                       "Key11K"};
                    //remove the keys just incase a previous test failed.
                    Remove(keys);
                    Remove(keyToRemove);


                   /***** invalid key but valid prefix, true match exact, should erase nothing *****/
                  RemoveTestHelper(keys, keyToRemove, keysToCheck, true,HResult.S_FALSE);
                  ResultCode  = TEST_RESULTS.PASSED;
                
                  
               }
          }
              [TestCase]
          class N_Parameter_Null_Cases : AccelFuncTestBase
          {

               override protected void Execute()
               {
                     uint hr;
                     uint[] hra;
                     byte[] nothing = null;
                     byte[][] nothing2 = null;
                     hr = _xb.Remove(nothing);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Remove with null key returned "+hr+" instead of E_INVALIDARG");                     
                     }

                     hra = _xb.Remove(nothing2);
                     if(hra != null)
                     {
                          throw new Exception("Calling Remove with null key returned an hresult array that was not null.");                     
                     }
                    

                     hr = _xb.Remove(null,true);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Remove with null value returned "+hr+" instead of E_INVALIDARG");                           
                     }
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase]
          class N_Parameter_Empty_Cases : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    uint[] hrArray = null;
                    byte[][] keyEmpty = new byte[0][];

                    hr = _xb.Remove(new byte[0]);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hr, "Calling Remove with empty key returned "+hr+" instead of E_INVALIDARG");                                      
                    }

                    hr = _xb.Remove(new byte[0], false);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                         throw new HResultException(hr, "Calling Remove with empty key returned "+hr+" instead of E_INVALIDARG");                        
                    }
                    
                    hrArray = _xb.Insert(keyEmpty, new byte[][] {new byte[] {1}}, new uint[1], new uint[1]);
                    if (hrArray != null)
                    {
                        throw new Exception("Calling remove with empty key array returned unexpected HResult array");
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class N_Key_SizeTooLong : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);
                    byte[] keyTooLong =  new byte[_maxKeyLength + 1];

                    //fill key with some random values.
                    _random.NextBytes(keyTooLong);

                     hr = _xb.Remove(keyTooLong);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Remove with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }

                     hr = _xb.Remove(keyTooLong, true);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Remove with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\makefile.inc ===
!include $(NTMAKEENV)\msbuild.def
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\AccelStressLITE.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;
using ServerTestFramework.Core.Utilities;

namespace AccelTest
{
    [StressInstantiate]
    class AccelStressTestBase : TestBase
    {
        public static AccelStressManager _xbsm = new AccelStressManager();
        protected static Acceleration _accel = new Acceleration(Interface.acceleration);
        public static void NotifHandler(byte[][] keys)
        {
            //do nothing!
        }
        public static void FailHandler()
        {
            //do nothing
        }
        public static void Init()
        {
            _accel.UnregisterHandlers();
            _accel.RegisterNotificationHandler(NotifHandler);
            _accel.RegisterNotificationFailureHandler(FailHandler);
        }
    }

    [StressTest, EnvRequirement("Stress")]
    //Inserts new user data into Acceleration
    class AccelInsertNewUserData : AccelStressTestBase
    {
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
        uint hr;
        ResultCode = TEST_RESULTS.PASSED;

        byte[] key = _xbsm.GetNewKeyLITE();
        byte[] value = _xbsm.GetRandomBasicPresenceData();
        hr = _accel.SetData(key, value, 0, 0);
        if (HResult.Failed(hr))
        {
            ResultCode = TEST_RESULTS.FAILED;
        }

        key = _xbsm.GetNewKeyLITE();
        value = _xbsm.GetRandomRichPresenceData();
        hr = _accel.SetData(key, value, 0, 0);
        if (HResult.Failed(hr))
        {
            ResultCode = TEST_RESULTS.FAILED;
        }

        key = _xbsm.GetNewKeyLITE();
        value = _xbsm.GetRandomFriendsListData();
        hr = _accel.SetData(key, value, 0, 0);
        if (HResult.Failed(hr))
        {
            ResultCode = TEST_RESULTS.FAILED;
        }

        key = _xbsm.GetNewKeyLITE();
        value = _xbsm.GetRandomConnInfoData();
        hr = _accel.SetData(key, value, 0, 0);
        if (HResult.Failed(hr))
        {
            ResultCode = TEST_RESULTS.FAILED;
        }
      }
   }

    [StressTest, EnvRequirement("Stress")]
    //Inserts new user data into Acceleration
    class AccelOverwriteBasicPresence : AccelStressTestBase
    {
        //public static AccelStressManager _xbsm = new AccelStressManager();
        private static Report _report = new Report("Log");
        override protected void Execute()
        {
            uint hr;
            ResultCode = TEST_RESULTS.PASSED;

            byte[] key = _xbsm.GetBasicPresenceKey();
            byte[] value = _xbsm.GetRandomBasicPresenceData();
            hr = _accel.SetData(key, value, 0, 0);
            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [StressTest, EnvRequirement("Stress")]
    //Inserts new user data into Acceleration
    class AccelOverwriteRichPresence : AccelStressTestBase
    {
        //public static AccelStressManager _xbsm = new AccelStressManager();
        private static Report _report = new Report("Log");
        override protected void Execute()
        {
            uint hr;
            ResultCode = TEST_RESULTS.PASSED;
            byte[] key = _xbsm.GetRichPresenceKey();
            byte[] value = _xbsm.GetRandomRichPresenceData();
            hr = _accel.SetData(key, value, 0, 0);
            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [StressTest, EnvRequirement("Stress")]
    //Inserts new user data into Acceleration
    class AccelOverwriteFriendsList : AccelStressTestBase
    {
        
        private static Report _report = new Report("Log");
        override protected void Execute()
        {
            uint hr;
            ResultCode = TEST_RESULTS.PASSED;

            byte[] key = _xbsm.GetFriendsListKey();
            byte[] value = _xbsm.GetRandomFriendsListData();
            hr = _accel.SetData(key, value, 0, 0);
            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [StressTest, EnvRequirement("Stress")]
    //Inserts new user data into Acceleration
    class AccelOverwriteConnectionInfo : AccelStressTestBase
    {
        //public static AccelStressManager _xbsm = new AccelStressManager();
        private static Report _report = new Report("Log");
        override protected void Execute()
        {
            uint hr;
            ResultCode = TEST_RESULTS.PASSED;

            byte[] key = _xbsm.GetConnInfoKey();
            byte[] value = _xbsm.GetRandomConnInfoData();
            hr = _accel.SetData(key, value, 0, 0);
            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [StressTest, EnvRequirement("Stress")]
    //Inserts new user data into Acceleration
    class AccelLogonLogoffUser : AccelStressTestBase
    {
       // public static AccelStressManager _xbsm = new AccelStressManager();
        private static Report _report = new Report("Log");
        override protected void Execute()
        {
            uint hr;
            ResultCode = TEST_RESULTS.PASSED;

            byte[] key = _xbsm.GetBasicPresenceKey();
            byte[] value = _xbsm.GetRandomBasicPresenceData();
            hr = _accel.SetData(key, value, 0, 0);
            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }

            key = _xbsm.GetRichPresenceKey();
            value = _xbsm.GetRandomRichPresenceData();
            hr = _accel.SetData(key, value, 0, 0);
            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }

            key = _xbsm.GetFriendsListKey();
            value = _xbsm.GetRandomFriendsListData();
            hr = _accel.SetData(key, value, 0, 0);
            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }

            key = _xbsm.GetConnInfoKey();
            value = _xbsm.GetRandomConnInfoData();
            hr = _accel.SetData(key, value, 0, 0);
            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [StressTest, EnvRequirement("Stress")]
    //Inserts new user data into Acceleration
    class AccelBatchQuery : AccelStressTestBase
    {
        //public static AccelStressManager _xbsm = new AccelStressManager();
        private static Report _report = new Report("Log");
        override protected void Execute()
        {
            uint[] hr = null;
            uint[] outseconds = null;
            ResultCode = TEST_RESULTS.PASSED;
            RandomEx _random = new RandomEx();
            byte[][] outbytes = null;
            int batchsize = _random.Next(30, 50);
            byte[][] keys = new byte[batchsize][];
            switch (_random.Next(0, 4))
            {
                case 0:
                    {
                        for (int i = 0; i < batchsize; i++)
                        {
                            keys[i] = _xbsm.GetBasicPresenceKey();
                        }
                        
                        break;
                    }
                case 1:
                    {
                        for (int i = 0; i < batchsize; i++)
                        {
                            keys[i] = _xbsm.GetRichPresenceKey();
                        }
                        break;
                    }
                case 2:
                    {
                        for (int i = 0; i < batchsize; i++)
                        {
                            keys[i] = _xbsm.GetFriendsListKey();
                        }
                        break;
                    }
                case 3:
                    {
                        for (int i = 0; i < batchsize; i++)
                        {
                            keys[i] = _xbsm.GetConnInfoKey();
                        }
                        break;
                    }
            }

            hr = _accel.Query(keys, out outbytes, out outseconds);
            foreach (uint h in hr)
            {
                if (HResult.Failed(h))
                {
                    _report.Error("Failed with " + h);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
    }

    [StressTest, EnvRequirement("Stress")]
    //Inserts new user data into Acceleration
    class AccelEmulateQuery : AccelStressTestBase
    {
        //public static AccelStressManager _xbsm = new AccelStressManager();
        private static Report _report = new Report("Log");
        override protected void Execute()
        {
            uint hr = 0;
            ResultCode = TEST_RESULTS.PASSED;
           // Acceleration xb = new Acceleration();
            RandomEx _random = new RandomEx();
            byte[] outbytes = null;
            int numtimes = _random.Next(1, 6);

            switch (_random.Next(0, 4))
            {
                case 0:
                {
                    for (int i = 0; i < numtimes; i++)
                    {
                        hr |= _accel.Query(_xbsm.GetBasicPresenceKey(), out outbytes);
                    }
                    break;
                }
                case 1:
                {
                    for (int i = 0; i < numtimes; i++)
                    {
                        hr |= _accel.Query(_xbsm.GetRichPresenceKey(), out outbytes);
                    }
                    break;
                }
                case 2:
                {
                    for (int i = 0; i < numtimes; i++)
                    {
                        hr |= _accel.Query(_xbsm.GetFriendsListKey(), out outbytes);
                    }
                    break;
                }
                case 3:
                {
                    for (int i = 0; i < numtimes; i++)
                    {
                        hr |= _accel.Query(_xbsm.GetConnInfoKey(), out outbytes);
                    }
                    break;
                }
            }

            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [StressTest, EnvRequirement("Stress")]
    //Inserts new user data into Acceleration
    class AccelQuery : AccelStressTestBase
    {
        //public static AccelStressManager _xbsm = new AccelStressManager();
        private static Report _report = new Report("Log");
        override protected void Execute()
        {
            uint hr = 0;
            ResultCode = TEST_RESULTS.PASSED;
            // Acceleration xb = new Acceleration();
            RandomEx _random = new RandomEx();
            byte[] outbytes = null;
            switch (_random.Next(0, 4))
            {
                case 0:
                    {
                        hr = _accel.Query(_xbsm.GetBasicPresenceKey(), out outbytes);
                        break;
                    }
                case 1:
                    {
                        
                        hr = _accel.Query(_xbsm.GetRichPresenceKey(), out outbytes);
                        break;
                    }
                case 2:
                    {
                        hr = _accel.Query(_xbsm.GetFriendsListKey(), out outbytes);
                        break;
                    }
                case 3:
                    {
                        hr = _accel.Query(_xbsm.GetConnInfoKey(), out outbytes);
                        break;
                    }
            }

            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [StressTest, EnvRequirement("Stress")]
    class AltInsert : AccelStressTestBase
    {
        private static Report _report = new Report("Log");
        override protected void Execute()
        {
            ResultCode = TEST_RESULTS.PASSED;

            byte[] key = _xbsm.AltGetRandomKey();
            byte[] value = _xbsm.AltGetRandomData();

            uint hr = _accel.SetData(key, value, 0, 0);
            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [StressTest, EnvRequirement("Stress")]
    class AltQuery : AccelStressTestBase
    {
        private static Report _report = new Report("Log");
        override protected void Execute()
        {
            ResultCode = TEST_RESULTS.PASSED;

            byte[] key = _xbsm.AltGetRandomKey();
            byte[] value;

            uint hr = _accel.Query(key, out value);
            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

//   [StressTest, EnvRequirement("Stress")]
//   class AccelStressInsertSmallValueLITE : StressTestBase
//   {
//      public static AccelStressManager _xbsm = new AccelStressManager();
//      private static Random _random = new Random();

//      override protected void Execute()
//      {
//         ResultCode = TEST_RESULTS.PASSED;
//         uint hr;

//         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//         Acceleration xb = new Acceleration();
//         try
//         {
//            byte[] rgbKey = _xbsm.GetNewKeyLITE();
//            byte[] rgbValue = null;
//            int valueIndex = _xbsm.GetValueIndex(1);
//            hr = xb.Query(rgbKey, out rgbValue);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//            hr = xb.Insert(rgbKey, AccelStressManager._valueList[valueIndex]);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
//            //if ( xb != null)
//            //ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }

//      }
//   }



//   [StressTest, EnvRequirement("Stress")]
//   class AccelStressInsertLargeValueLITE : StressTestBase
//   {
//      public static AccelStressManager _xbsm = new AccelStressManager();
//      private static Random _random = new Random();

//      override protected void Execute()
//      {
//         ResultCode = TEST_RESULTS.PASSED;
//         uint hr;
//         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//          Acceleration xb = new Acceleration();
//         try
//         {
//            byte[] rgbKey = _xbsm.GetNewKeyLITE();
//            byte[] rgbValue = null;
//            int valueIndex = _xbsm.GetValueIndex(3);
//            hr = xb.Query(rgbKey, out rgbValue);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//            hr = xb.Insert(rgbKey, AccelStressManager._valueList[valueIndex]);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
//            //if ( xb != null)
//            //ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }
//      }
//   }


//   [StressTest, EnvRequirement("Stress")]
//   class AccelStressQuerySmallValueLITE : StressTestBase
//   {
//      public static AccelStressManager _xbsm = new AccelStressManager();
//      private static Report _report = new Report("Log");
//      override protected void Execute()
//      {
//         uint hr;
//         ResultCode = TEST_RESULTS.PASSED;
//         byte[] rgbOutValue = null;
//         int type = 1;
//         int keyIndex = _xbsm.GetKeyIndexByTypeLITE(type);
//         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//          Acceleration xb = new Acceleration();
//         try
//         {
//            hr = xb.Query(AccelStressManager._keyList[keyIndex], out rgbOutValue);
//            if (hr == HResult.S_FALSE)
//            {
//               //set the key to some value of correct size (of decided type)
//               xb.SetData(AccelStressManager._keyList[keyIndex],AccelStressManager._valueList[ _xbsm.GetValueIndex(type)],0,0);
               
//            }
//            else if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
////            if ( xb != null)
//   //         ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }
//      }
//   }



//   [StressTest, EnvRequirement("Stress")]
//   class AccelStressQueryLargeValueLITE : StressTestBase
//   {
//      public static AccelStressManager _xbsm = new AccelStressManager();
//      private static Report _report = new Report("Log");
//      override protected void Execute()
//      {
//         uint hr;
//         ResultCode = TEST_RESULTS.PASSED;
//         byte[] rgbOutValue = null;
//         Random random = new Random();
//         int type = 3;
//         int keyIndex = _xbsm.GetKeyIndexByTypeLITE(type);
//         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//          Acceleration xb = new Acceleration();
//         try
//         {
//            hr = xb.Query(AccelStressManager._keyList[keyIndex], out rgbOutValue);
//            if (hr == HResult.S_FALSE)
//            {
//               //set the key to some value of correct size (of decided type)
//               xb.SetData(AccelStressManager._keyList[keyIndex],AccelStressManager._valueList[ _xbsm.GetValueIndex(type)],0,0);
//            }
//            else if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
////            if ( xb != null)
//    //        ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }
//      }
//   }

   //[StressTest, EnvRequirement("Stress")]
   // //this API attempts to emulate a catalog API which queries for a value, and if it doesn't find it, it will insert it.
   // //all catalog items will expire after 60 minutes
   //class AccelStressLargeDataToBucket219: StressTestBase
   //{
   //   public static AccelStressManager _xbsm = new AccelStressManager();
   //   private static Report _report = new Report("Log");
   //   override protected void Execute()
   //   {
   //      uint hr;
   //      ResultCode = TEST_RESULTS.PASSED;
   //      byte[] rgbOutValue = null;
   //      Random random = new Random();
   //      int type = 3;
   //     RandomEx _random = new RandomEx();
   //      Acceleration xb = new Acceleration();
   //      //determine whether or not this will be a hit or a miss
   //      if( _random.Next(1,100) > AccelStressManager._CatalogHitRatio)
   //      {
   //         //its a miss, choose a key that will miss.
   //         byte[] rgbKey = _xbsm.GetKeyThatMapsToBucket(219);
   //         int valueIndex = _xbsm.GetValueIndex(3);
   //         //we want to log the cache miss, so query for the key that's going to miss
   //         hr = xb.Query(rgbKey, out rgbOutValue);
   //         if (hr == HResult.S_FALSE)
   //         {
   //            //set the key to some value of correct size (of decided type)
   //             hr = xb.SetData(rgbKey, AccelStressManager._valueList[valueIndex],0,0);
   //             if (HResult.Failed(hr))
   //             {
   //                 ResultCode = TEST_RESULTS.FAILED;
   //             }
   //         }
   //         else if (HResult.Failed(hr))
   //         {
   //             ResultCode = TEST_RESULTS.FAILED;
   //         }

   //      }
   //      else
   //      {
   //         //its a hit
   //         int keyIndex = _random.Next(0, AccelStressManager._keyListBucket219.Length);
   //         hr = xb.Query(AccelStressManager._keyListBucket219[keyIndex], out rgbOutValue);
   //         if (hr == HResult.S_FALSE)
   //         {
   //            //set the key to some value of correct size (of decided type)
   //            xb.SetData(AccelStressManager._keyListBucket219[keyIndex],AccelStressManager._valueList[ _xbsm.GetValueIndex(type)],0,0);
   //         }
   //         else if (HResult.Failed(hr))
   //         {
   //             ResultCode = TEST_RESULTS.FAILED;
   //         }

   //      }
   //   }
   //}

   //[StressTest, EnvRequirement("Stress")]
   // //this API attempts to emulate a catalog API which queries for a value, and if it doesn't find it, it will insert it.
   // //all catalog items will expire after 60 minutes
   //class AccelStressSmallDataToBucket219: StressTestBase
   //{
   //   public static AccelStressManager _xbsm = new AccelStressManager();
   //   private static Report _report = new Report("Log");
   //   override protected void Execute()
   //   {
   //      uint hr;
   //      ResultCode = TEST_RESULTS.PASSED;
   //      byte[] rgbOutValue = null;
   //      Random random = new Random();
   //      int type = 1;
   //     RandomEx _random = new RandomEx();
   //      Acceleration xb = new Acceleration();
   //      //determine whether or not this will be a hit or a miss
   //      if( _random.Next(1,100) > AccelStressManager._ProfileHitRatio)
   //      {
   //         //its a miss, choose a key that will miss.
   //         byte[] rgbKey = _xbsm.GetKeyThatMapsToBucket(219);
   //         int valueIndex = _xbsm.GetValueIndex(3);
   //         //we want to log the cache miss, so query for the key that's going to miss
   //         hr = xb.Query(rgbKey, out rgbOutValue);
   //         if (hr == HResult.S_FALSE)
   //         {
   //            //set the key to some value of correct size (of decided type)
   //             hr = xb.SetData(rgbKey, AccelStressManager._valueList[valueIndex],0,0);
   //             if (HResult.Failed(hr))
   //             {
   //                 ResultCode = TEST_RESULTS.FAILED;
   //             }
   //         }
   //         else if (HResult.Failed(hr))
   //         {
   //             ResultCode = TEST_RESULTS.FAILED;
   //         }

   //      }
   //      else
   //      {
   //         //its a hit
   //         int keyIndex = _random.Next(0, AccelStressManager._keyListBucket219.Length);
   //         hr = xb.Query(AccelStressManager._keyListBucket219[keyIndex], out rgbOutValue);
   //         if (hr == HResult.S_FALSE)
   //         {
   //            //set the key to some value of correct size (of decided type)
   //            xb.SetData(AccelStressManager._keyListBucket219[keyIndex],AccelStressManager._valueList[ _xbsm.GetValueIndex(type)],0,0);
   //         }
   //         else if (HResult.Failed(hr))
   //         {
   //             ResultCode = TEST_RESULTS.FAILED;
   //         }

   //      }
   //   }
   //}

//   [StressTest(Priority = 10)]
//   class XBancStressRemovePrefixLITE : StressTestBase
//   {
//      public static XBancStressManager _xbsm = new XBancStressManager();
//      private static Report _report = new Report("Log");
//      override protected void Execute()
//      {
//         uint hr;
//         ResultCode = TEST_RESULTS.PASSED;
//         Random random = new Random();
//         byte[] rgbKey = _xbsm.GetPrefixKeyLITE();
//        // ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//         XBanc xb = new XBanc();
//         try
//         {
//            hr = xb.Remove(rgbKey, false);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
////            if ( xb != null)
//    //        ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }
//
//      }
//  }
   //   [StressTest(Priority = 10)]
//   class XBancStressInsertMediumValueLITE : StressTestBase
//   {
//      public static XBancStressManager _xbsm = new XBancStressManager();
//      private static Random _random = new Random();
//
//      override protected void Execute()
//      {
//         ResultCode = TEST_RESULTS.PASSED;
//         uint hr;
//         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//        XBanc xb = new XBanc();
//         try
//         {
//            byte[] rgbKey = _xbsm.GetNewKeyLITE();
//            byte[] rgbValue = null;
//            int valueIndex = _xbsm.GetValueIndex(2);
//            hr = xb.Query(rgbKey, out rgbValue);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//            hr = xb.Insert(rgbKey, XBancStressManager._valueList[valueIndex]);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
//            //if ( xb != null)
//            //ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }
//      }
//   }
   
//   [StressTest(Priority = 10)]
//   class XBancStressSetDataSmallValueLITE : StressTestBase
//   {
//      public static XBancStressManager _xbsm = new XBancStressManager();
//      private static Random _random = new Random();
//      private static Report _report = new Report("Log");
//
//      override protected void Execute()
//      {
//         ResultCode = TEST_RESULTS.PASSED;
//         uint hr, abs, slid;
//         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//          XBanc xb = new XBanc();
//         try
//         {
//            byte[] rgbKey = _xbsm.GetNewKeyLITE();
//            int valueIndex = _xbsm.GetValueIndex(1);
//
//            //pick random values
//            abs = (uint) _random.Next(XBancStressManager._AbsoluteExpiryLow,XBancStressManager._AbsoluteExpiryHigh+1);
//            if (abs > XBancStressManager._AbsoluteExpiryCutoff) abs = 0;
//            slid = (uint) _random.Next(XBancStressManager._SlidingExpiryLow,XBancStressManager._SlidingExpiryHigh+1);
//            if (slid > XBancStressManager._SlidingExpiryCutoff) slid = 0;
//
//            hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex],abs,slid);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
//            //if ( xb != null)
//            //ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }
//
//      }
//   }
//
//   [StressTest(Priority = 10)]
//   class XBancStressSetDataMediumValueLITE : StressTestBase
//   {
//      public static XBancStressManager _xbsm = new XBancStressManager();
//      private static Random _random = new Random();
//      private static Report _report = new Report("Log");
//
//      override protected void Execute()
//      {
//         ResultCode = TEST_RESULTS.PASSED;
//         uint hr, abs, slid;
//         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//        XBanc xb = new XBanc();
//         try
//         {
//            byte[] rgbKey = _xbsm.GetNewKeyLITE();
//            int valueIndex = _xbsm.GetValueIndex(2);
//            //pick random values
//            abs = (uint) _random.Next(XBancStressManager._AbsoluteExpiryLow,XBancStressManager._AbsoluteExpiryHigh+1);
//            if (abs > XBancStressManager._AbsoluteExpiryCutoff) abs = 0;
//            slid = (uint) _random.Next(XBancStressManager._SlidingExpiryLow,XBancStressManager._SlidingExpiryHigh+1);
//            if (slid > XBancStressManager._SlidingExpiryCutoff) slid = 0;
//
//            hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex],abs,slid);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
//           // if ( xb != null)
//            //ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }
//      }
//   }
//
//   [StressTest(Priority = 10)]
//   class XBancStressSetDataLargeValueLITE : StressTestBase
//   {
//      public static XBancStressManager _xbsm = new XBancStressManager();
//      private static Random _random = new Random();
//      private static Report _report = new Report("Log");
//
//      override protected void Execute()
//      {
//         ResultCode = TEST_RESULTS.PASSED;
//         uint hr, abs, slid;
//         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//         XBanc xb = new XBanc();
//         try
//         {
//            byte[] rgbKey = _xbsm.GetNewKeyLITE();
//            int valueIndex = _xbsm.GetValueIndex(3);
//            //pick random values
//            abs = (uint) _random.Next(XBancStressManager._AbsoluteExpiryLow,XBancStressManager._AbsoluteExpiryHigh+1);
//            if (abs > XBancStressManager._AbsoluteExpiryCutoff) abs = 0;
//            slid = (uint) _random.Next(XBancStressManager._SlidingExpiryLow,XBancStressManager._SlidingExpiryHigh+1);
//            if (slid > XBancStressManager._SlidingExpiryCutoff) slid = 0;
//
//            hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex],abs,slid);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
//        //    if ( xb != null)
//            //ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }
//      }
//   }
//
//   [StressTest(Priority = 10)]
//   class XBancStressQueryMediumValueLITE : StressTestBase
//   {
//      public static XBancStressManager _xbsm = new XBancStressManager();
//      private static Report _report = new Report("Log");
//      override protected void Execute()
//      {
//         uint hr;
//         ResultCode = TEST_RESULTS.PASSED;
//         byte[] rgbOutValue = null;
//         Random random = new Random();
//         int type = 2;
//         int keyIndex = _xbsm.GetKeyIndexByTypeLITE(type);
//         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//        XBanc xb = new XBanc();
//         try
//         {
//            hr = xb.Query(XBancStressManager._keyList[keyIndex], out rgbOutValue);
//            if (hr == HResult.S_FALSE)
//            {
//               //set the key to some value of correct size (of decided type)
//               xb.SetData(XBancStressManager._keyList[keyIndex],XBancStressManager._valueList[ _xbsm.GetValueIndex(type)],0,0);
//            }
//            else if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
//            //if ( xb != null)
//            //ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }
//
//      }
//   }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\AccelFuncSequence.cs ===
using System;
using ServerTestFramework;
using xonline.common.service;


namespace AccelTest
{
     public class AccelFuncSequence : TestNode
     {
          
          [TestCase, Description("Basic Sequence: Query, Insert and Remove")]
          
          class P_QueryInsertRemove : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Query",
                                                       "Insert",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_OK};
                    /***** call Query, Insert, and remove on the same key (and value) *****/
                    //verify a reservation was made, filled, and the data was successfully removed 
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

          [TestCase, Description("Out of order sequence: Query Remove Insert")]
          
          class P_QueryRemoveInsert : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Query",
                                                       "Remove",
                                                       "Insert"};
                    uint[] expectedValues = {
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_OK};
                    /***** call Query, Remove, and Insert on the same key (and value) *****/
                    //verify a reservation was made, removed, and the insert call failed
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

          [TestCase, Description("Out of order sequence: Query SetData Insert")]
          
          class P_QuerySetDataInsert : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Query",
                                                       "SetData",
                                                       "Insert",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.E_ACCESSDENIED,
                                                       HResult.S_OK};
                    /***** call Query, SetData, and Insert on the same key (and value) *****/
                    //verify a reservation was made, overwritten, and the insert call failed
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Out of order sequence: Query SetData Insert")]
          
          class P_QueryInsertSetData : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Query",
                                                       "Insert",
                                                       "SetData",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_OK, 
                                                       HResult.S_OK}; 
                    /***** call Query, Insert, SetData on the same key (and value) *****/
                    //verify a reservation was made, filled, and setdata returned S_OK
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Out of order sequence: Query Query Insert Insert")]
          
          class P_QueryQueryInsertInsert : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Query",
                                                       "Query",
                                                       "Insert",
                                                       "Insert",
                                                       "Query",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_FALSE,
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.E_ACCESSDENIED,
                                                       HResult.S_OK,
                                                       HResult.S_OK};
                    /***** call Query, Query, Insert, Insert on the same key (and value) *****/
                    //verify a reservation was made, nothing was returned, filled, and second call to insert failed
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

           [TestCase, Description("Out of order sequence: Query Query Remove Insert")]
          
          class P_QueryQueryRemoveInsert : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Query",
                                                       "Query",
                                                       "Remove",
                                                       "Insert"};
                    uint[] expectedValues = {
                                                       HResult.S_FALSE,
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_OK};
                                                      
                    /***** call Query, Query, Remove, Insert on the same key (and value) *****/
                    //verify a reservation was made, nothing was returned, the reservation was removed, and the call to insert failed
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

           [TestCase, Description("Out of order sequence: Insert Query Remove")]
          
          class P_InsertQueryRemove : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Insert",
                                                       "Query",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.S_OK};
                                                      
                    /***** call Insert, Query, Remove on the same key (and value) *****/
                    //verify the insert failed, a reservation was made and removed
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

          [TestCase, Description("Out of order sequence: Remove Query Insert")]
          
          class P_RemoveQueryInsert : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Remove",
                                                       "Query",
                                                       "Insert",
                                                       "Query",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_FALSE,
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.S_OK};
                                                      
                    /***** call Remove, Query, Insert on the same key (and value) *****/
                    //verify the remove returned false, a reservation was made and filled 
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

           [TestCase, Description("Out of order sequence: Setdata Query Insert")]
          
          class P_SetDataQueryInsert : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "SetData",
                                                       "Query",
                                                       "Insert",
                                                       "Query",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.E_ACCESSDENIED,
                                                       HResult.S_OK,
                                                       HResult.S_OK};
                                                      
                    /***** call SetData, Query, Insert on the same key (and value) *****/
                    //verify the value was written, returned by query, and insert failed 
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

           [TestCase, Description("Sequence: Setdata Query Remove Query Insert")]
          
          class P_SetDataQueryRemoveQueryInsert : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "SetData",
                                                       "Query",
                                                       "Remove",
                                                       "Query",
                                                       "Insert",
                                                       "Query",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.S_OK};
                                                      
                    /***** call SetData, Query, Remove, Query, Insert on the same key (and value) *****/
                    //verify the value was written, returned by Query, removed, a reservation was made and filled
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

          [TestCase, Description("Out of order sequence: Setdata Query Insert Remove")]
          
          class P_SetDataQueryInsertRemove : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "SetData",
                                                       "Query",
                                                       "Insert",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.E_ACCESSDENIED,
                                                       HResult.S_OK};
                                                      
                    /***** call SetData, Query, Insert, Remove on the same key (and value) *****/
                    //verify the value was written, correct value was returned by query, the insert returned s_false, and data was successfully removed 
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

           [TestCase, Description("Out of order sequence: Setdata Query Remove Insert ")]
          
          class P_SetDataQueryRemoveInsert : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "SetData",
                                                       "Query",
                                                       "Remove",
                                                       "Insert"};
                    uint[] expectedValues = {
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.S_OK};
                                                      
                    /***** call SetData, Query, Remove, Insert on the same key (and value) *****/
                    //verify the value was written, correct value was returned, removed, and the insert call failed 
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\AccelFuncSetData.cs ===
using System;
using System.Diagnostics;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;



namespace AccelTest
{
     public class AccelFuncSetData : TestNode
     {
      
             [TestCase]
          class P_Mainline : AccelFuncTestBase
          {
                 /***** valid key, valid value *****/
               override protected void Execute()
               {
                    byte[] key = null;
                    byte[] value = null;
                    
                    CreateKeyValuePair(out key, out value);

                    SetData(key, value);
                     //cleanup
                    Remove(key);

                     //SetData [][] overload
                    byte[][] key2 = null;
                    byte[][] value2 = null;
                    
                    CreateKeyValueArrayPair(out key2, out value2);

                    SetData(key2, value2);
                     //cleanup
                    Remove(key2);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class P_Keys_EdgeCases : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] tempkey = null;
                    byte[] value = null;
                    
                    
                    CreateKeyValuePair(out tempkey, out value);
                    /***** rest of valid key, valid value test cases *****/
                    //according to MSDN there is an implicit cast from integer literal to byte as long as the literal is < 256
                    byte[][] keyTable = { 
                                                            new byte[] {0,0,0,0},    //nonzero length key with no bits set
                                                            new byte[] {5},          // 1 byte length key
                                                            new byte[] {1,2,3,4,5,6,7,8}, //byte aligned key
                                                            new byte[] {1,2,3,4,5,6},     //non-byte aligned key
                                                            CreateKey(_maxKeyLength) // equal to max size key length
                                                       };
                                                       
                    foreach (byte[] key in keyTable)
                    {
                         SetData(key, value);
                          //cleanup
                         Remove(key);
                    }

                     ResultCode = TEST_RESULTS.PASSED;
                    
               }
          }

            [TestCase]
           class P_KeyArray_EdgeCases : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint[] hr;
                    byte[][] key = new byte[2][];
                    key[0] = new byte[] {34};
                    key[1] = null;
                    byte[][] value = new byte[2][]; //just some random data
                    value[0] = new byte[] {25};
                    value[1] = new byte[] {45};
                    //key[0] = valid, key[1]=invalid

                    //byte[][] expectedKeys = new byte[][] { key[0], key[0] };
                    RegisterRegularNotificationHandler(key[0]);
                    hr = _xb.SetData(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hr == null || hr.Length != 2)
                    {
                        throw new Exception("SetData did not return expected HR results");
                    }
                    if (hr[0] != HResult.S_OK)
                    {
                        throw new HResultException(hr[0], "SetData returned "+hr[0]+" instead of S_OK");
                    }
                    if (hr[1] != HResult.E_INVALIDARG)
                    {
                        throw new HResultException(hr[1], "SetData returned "+hr[1]+" instead of E_INVALIDARG");
                    }
                    WaitForNotificationHandlerToFire();
                    
                   //remove for cleanup
                    Remove(key[0]);
                   
                    key = new byte[100][];
                    value = new byte[100][];
                    for(int i=0; i<key.Length; i++)
                    {
                        key[i] = CreateKey();
                        value[i] = CreateValue();
                    }
                    SetData(key, value, new uint [key.Length], new uint [key.Length]);

                    //remove for cleanup
                    Remove(key);
                    ResultCode = TEST_RESULTS.PASSED;
                    
               }
          }

           [TestCase, Description("Insert version 1 positive paramater testing")]
          class P_Values_EdgeCases : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null;
                    byte[] tempvalue = null;
                    CreateKeyValuePair(out key, out tempvalue);
                    /***** rest of valid key, valid value test cases *****/
                    //according to MSDN there is an implicit cast from integer literal to byte as long as the literal is < 256
                    byte[][] valueTable = { 
                                                            new byte[] {0,0,0,0},    //nonzero length value with no bits set
                                                            new byte[] {5},          // 1 byte length value
                                                            new byte[256000],   //large value size
                                                            new byte[1048576 ] //value sized =  1 mb
                                                       };
                                                       
                    foreach (byte[] value in valueTable)
                    {
                        if (value.Length > 4)
                        {
                            //fill key with some random values.
                            _random.NextBytes(value);
                        }
                         
                        SetData(key, value);
                         //cleanup
                        Remove(key);
                    }
                    
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert version 2 no expiration testing")]
          class P_Expiry_MaxAbsolute : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] value = null;
                    byte[] key = null;
                    byte[][] keyArray = null;
                    byte[][] valueArray = null;
                    uint[] expiry = null;
                    uint[] expectedExpiry = null;
                    uint[] expectedHR = null;

                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);

                    expiry = new uint[keyArray.Length];
                    expectedHR = new uint[keyArray.Length];
                    expectedExpiry = new uint[keyArray.Length];
                    for(int i=0; i<expiry.Length; i++)
                    {
                        expiry[i] = _maxUInt;
                        expectedHR[i] = HResult.S_OK;
                        expectedExpiry[i] = _maxUInt - 5;
                    }

                    SetData(key, value, _maxUInt, 0);
                    SetData(keyArray, valueArray, expiry, new uint[keyArray.Length]);
                    
                    //wait to see if the value will expire, it should not.
                    new SleepInfo("Wait for 5 seconds for value to NOT expire",5*1000);
                    //Query to see if value did not expire
                    QueryCheckTime(key, value, _maxUInt - 5, HResult.S_OK);
                    QueryCheckTime(keyArray, valueArray, expectedExpiry, expectedHR);
                    //remove for cleanup
                    Remove(key);
                    Remove(keyArray);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase, Description("Insert version 2 no expiration testing")]
          class P_Expiry_MaxSliding : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] value = null;
                    byte[] key = null;
                    byte[][] keyArray = null;
                    byte[][] valueArray = null;
                    uint[] expiry = null;
                    uint[] expectedExpiry = null;
                    uint[] expectedHR = null;

                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);

                    expiry = new uint[keyArray.Length];
                    expectedHR = new uint[keyArray.Length];
                    expectedExpiry = new uint[keyArray.Length];
                    for(int i=0; i<expiry.Length; i++)
                    {
                        expiry[i] = _maxUInt;
                        expectedHR[i] = HResult.S_OK;
                        expectedExpiry[i] = _maxUInt;
                    }
                    
                    SetData(key, value, 0,  _maxUInt);
                    SetData(keyArray, valueArray, new uint[keyArray.Length], expiry);
                    //wait to see if the value will expire, it should not.
                    new SleepInfo("Wait for 5 seconds for value to NOT expire",5*1000);
                    //Query to see if value did not expire
                    QueryCheckTime(key, value, _maxUInt, HResult.S_OK); //sliding time updated because we just queried for it
                    QueryCheckTime(keyArray, valueArray, expectedExpiry, expectedHR);
                    //remove for cleanup
                    Remove(key);
                    Remove(keyArray);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase]
          class P_Expiry_MultipleSetData : AccelFuncTestBase
          {
                
               override protected void Execute()
               {
                    byte[][] keyArrayInsert = null;
                    byte[][] keyArrayQuery = null;
                    byte[][] valueArray = null;
                    byte[][] expectedQueryValues = null;
                    uint[] absoluteExpiry = null;
                    uint[] slidingExpiry = null;                    
                    uint[] expectedExpiry = null;
                    uint[] expectedHR= null;
                    
                   //70                                 75                          30                      45                  60                  
                    //not sliding expired, not absolute expired, sliding expired, absolute expired, reservation expired, 
                    keyArrayInsert = new byte[4][];
                    valueArray = new byte[4][];
                    absoluteExpiry = new uint[keyArrayInsert.Length];
                    slidingExpiry = new uint[keyArrayInsert.Length];   
                    //for the query checktime call
                    expectedQueryValues = new byte[5][];
                    keyArrayQuery = new byte[5][];
                    expectedHR = new uint[keyArrayQuery.Length];
                    expectedExpiry = new uint[keyArrayQuery.Length];
                    
                    for(int i=0; i<keyArrayInsert.Length; i++)
                    {
                        keyArrayInsert[i] = CreateKey();
                        valueArray[i] = CreateValue();
                        keyArrayQuery[i] = keyArrayInsert[i];
                    }
                    
                    absoluteExpiry[0] = 0;
                    absoluteExpiry[1] = 75;
                    absoluteExpiry[2] = 0;
                    absoluteExpiry[3] = 45;
                    slidingExpiry[0] = 70;
                    slidingExpiry[1] = 0;
                    slidingExpiry[2] = 30;
                    slidingExpiry[3] = 0;

                    //results for the QueryCheckTime
                    keyArrayQuery[4] = CreateKey();
                    
                    expectedHR[0] = HResult.S_OK;
                    expectedHR[1] = HResult.S_OK;
                    expectedHR[2] = HResult.S_FALSE;
                    expectedHR[3] = HResult.S_FALSE;
                    expectedHR[4] = HResult.S_FALSE;
                    expectedExpiry[0] = 70;
                    expectedExpiry[1] = 15;
                    expectedExpiry[2] = _reservationExpirySeconds;
                    expectedExpiry[3] = _reservationExpirySeconds;
                    expectedExpiry[4] = _reservationExpirySeconds;
                    expectedQueryValues[0] = valueArray[0];
                    expectedQueryValues[1] = valueArray[1];
                    expectedQueryValues[2] = null;
                    expectedQueryValues[3] = null;
                    expectedQueryValues[4] = null;
                    //make the reservation for the last case
                    Query(keyArrayQuery[4], null, HResult.S_FALSE);
                    
                    SetData(keyArrayInsert, valueArray, absoluteExpiry, slidingExpiry);

                     //sleep for 60 seocnds, value should expire
                    new SleepInfo("Wait 60 seconds for stuff to expire", 60 * 1000);

                    QueryCheckTime(keyArrayQuery, expectedQueryValues, expectedExpiry, expectedHR);

                    //remove everything for cleanup
                    Remove(keyArrayInsert);
                    _xb.Remove(keyArrayQuery[4]);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
         
            [TestCase, Description("SetData valid existent key, valid value smaller than original")]
          
          class P_OverWrite_ValueSizeLessThanOriginal : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string sValue = "Setdata value to cache in XBANC";
                    byte[] key = CreateKey();
                    byte[] value = _enc.GetBytes(sValue);

                    int oldValueLength = value.Length;
                    InsertSingleItem(key, value);
                    
                    sValue = "Smaller value";
                    value = _enc.GetBytes(sValue);
                    int lengthDifference = oldValueLength - value.Length;

                    //get perfcounters to verify
                    //uint bucket = HashKeyToBucket(key);
                    //IBucketServer b = Config.GetBucketServer(Interface.xbanc, (uint)bucket);
                    //PerformanceCounter AccelTotalDataBytes = new PerformanceCounter("Xbox Live Accel Data", "Data bytes", "_Total_", b.CurrentServerName);
                    //PerformanceCounter AccelTotalItems = new PerformanceCounter("Xbox Live Accel Data", "Total cache items", "_Total_", b.CurrentServerName);
                    //int oldTotalDataBytes = (int) AccelTotalDataBytes.NextValue();
                    //int oldTotalItems = (int) AccelTotalItems.NextValue();

                    /***** Call SetData with value sized smaller than the original *****/
                    SetData(key,value,0,0);
                    // Need to verify that the old value was released and deleted
                    new SleepInfo("Waiting 1 sec", 1*1000);
                    ////Confirm PerfCounter TotalBytesCached and TotalItemsCached dropped by 18 bytes and NO items.
                    //int newDataBytes = (int) AccelTotalDataBytes.NextValue();
                    //if (oldTotalDataBytes - newDataBytes != lengthDifference)
                    //{
                    //     ResultCode = TEST_RESULTS.FAILED;
                    //     _report.Fatal("Did not recieve expected Data Bytes perfcounter. newDataBytes = "+newDataBytes+", oldDataBytes = "+oldTotalDataBytes+", expected difference = "+lengthDifference);
                    //}
                    //int newTotalItems = (int) AccelTotalItems.NextValue();
                    //if (oldTotalItems != newTotalItems)
                    //{
                    //     ResultCode = TEST_RESULTS.FAILED;
                    //     _report.Fatal("Did not recieve expected total items perfcounter. oldTotalItems = "+oldTotalItems+", newTotalItems = "+newTotalItems);

                    //}
                    //remove value from cache to clean up
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;

               }
          }

          
          [TestCase, Description("SetData valid existent key, identical value")]
            class P_OverWrite_IdenticalValue : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string sValue = "Setdata value to cache in XBANC";
                    byte[] key = CreateKey();
                    byte[] value = _enc.GetBytes(sValue);

                    InsertSingleItem(key, value);

                     //get perfcounters to verify later
                    //uint bucket = HashKeyToBucket(key);
                    //IBucketServer b = Config.GetBucketServer(Interface.xbanc, (uint)bucket);
                    //PerformanceCounter AccelTotalDataBytes = new PerformanceCounter("Xbox Live Accel Data", "Data bytes", "_Total_", b.CurrentServerName);
                    //PerformanceCounter AccelTotalItems = new PerformanceCounter("Xbox Live Accel Data", "Total cache items", "_Total_", b.CurrentServerName);
                    //int oldTotalDataBytes = (int) AccelTotalDataBytes.NextValue();
                    //int oldTotalItems = (int) AccelTotalItems.NextValue();
               
                    /***** Call SetData with same value *****/
                    SetData(key,value,0,0);
                   
                    // verify that the old value was released and deleted
                    //"Confirm PerfCounter TotalBytesCached and TotalItemsCached dropped by NO bytes and NO items.
                    //int newDataBytes = (int) AccelTotalDataBytes.NextValue();
                    //if (oldTotalDataBytes != newDataBytes)
                    //{
                    //     ResultCode = TEST_RESULTS.FAILED;
                    //     _report.Fatal("Did not recieve expected Data Bytes perfcounter. newDataBytes = "+newDataBytes+", oldDataBytes = "+oldTotalDataBytes+", expected difference = 0");
                    //}
                    //int newTotalItems = (int) AccelTotalItems.NextValue();
                    //if (oldTotalItems != newTotalItems)
                    //{
                    //     ResultCode = TEST_RESULTS.FAILED;
                    //     _report.Fatal("Did not recieve expected total items perfcounter. oldTotalItems = "+oldTotalItems+", newTotalItems = "+newTotalItems+", expected difference = 0");
                    //}
                    //remove value from cache to clean up
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
          
          [TestCase, Description("SetData valid existent key, same sized value but different contents")]
          class P_OverWrite_SameSizeValueDiffContents : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string sValue = "Setdata value to cache in XBANC";
                    byte[] key = CreateKey();
                    byte[] value = _enc.GetBytes(sValue);

                    InsertSingleItem(key, value);

                    //get perfcounters to verify later
//                      uint bucket = HashKeyToBucket(key);
//                      IBucketServer b = Config.GetBucketServer(Interface.xbanc, (uint)bucket);
//                      PerformanceCounter AccelTotalDataBytes = new PerformanceCounter("Xbox Live XBanc Data", "Data bytes", "_Total_", b.CurrentServerName);
//                      PerformanceCounter AccelTotalItems = new PerformanceCounter("Xbox Live XBanc Data", "Total cache items", "_Total_", b.CurrentServerName);
//                      int oldTotalDataBytes = (int) AccelTotalDataBytes.NextValue();
//                      int oldTotalItems = (int) AccelTotalItems.NextValue();
                             
                    sValue = "Setdata value to cache in XBANK";
                    value = _enc.GetBytes(sValue);

                    /***** Call SetData with same sized value but different contents *****/
                    SetData(key,value,0,0);

                     //Need to verify that the old value was released and deleted
                    //Confirm PerfCounter TotalBytesCached and TotalItemsCached dropped by NO bytes and NO items.
//                      int newDataBytes = (int) AccelTotalDataBytes.NextValue();
//                      if (oldTotalDataBytes != newDataBytes)
//                      {
//                           ResultCode = TEST_RESULTS.FAILED;
//                           _report.Fatal("Did not recieve expected Data Bytes perfcounter. newDataBytes = "+newDataBytes+", oldDataBytes = "+oldTotalDataBytes+", expected difference = 0");
//                      }
//                      int newTotalItems = (int) AccelTotalItems.NextValue();
//                      if (oldTotalItems != newTotalItems)
//                      {
//                           ResultCode = TEST_RESULTS.FAILED;
//                           _report.Fatal("Did not recieve expected total items perfcounter. oldTotalItems = "+oldTotalItems+", newTotalItems = "+newTotalItems+", expected difference = 0");
//
//                      }
//                      //remove value from cache to clean up
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;                    

               }
          }

               [TestCase, Description("SetData valid existent key, identical value different expiry data")]
            class P_OverWrite_IdenticalValueDiffExpiry : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string sValue = "Setdata value to cache in XBANC";
                    byte[] key = CreateKey();
                    byte[] value = _enc.GetBytes(sValue);
                    byte[] key2 = CreateKey();
                    byte[][] keyArray = new byte[][]{key2, key2};
                    byte[][] valueArray = new byte[][]{value, value};
                    uint[] absoluteExpiry = new uint[]{0,30};
                    uint[] slidingExpiry = new uint[]{0,0};   
                    uint[] expectedReturnedSeconds = new uint[]{_reservationExpirySeconds,_reservationExpirySeconds};  

                     /***** Call SetData with same value *****/
                    InsertSingleItem(key, value);
                   
                    SetData(key,value,30,0);
                    SetData(keyArray, valueArray, absoluteExpiry, slidingExpiry);
                    
                    //sleep 31 seconds
                    _report.Debug("Sleeping for 31 seconds to wait for value to expire.");
                    new SleepInfo("Wait for 31 seconds",31*1000);

                    //value should be expired            
                    QueryCheckTime(key, null, _reservationExpirySeconds, HResult.S_FALSE);
                    QueryCheckTime(keyArray, null, expectedReturnedSeconds, new uint[]{HResult.S_FALSE, HResult.S_FALSE});
                    //remove value from cache to clean up, all in one
                    byte[][] keys = new byte[1+keyArray.Length][];
                    keys[0] = key;
                    for (int i = 1; i < keyArray.Length + 1; i++)
                    {
                        keys[i] = keyArray[i - 1];
                    }
                    Remove(keys);
                   
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
          
               [TestCase, Description("SetData valid existent key, value size greater than original")]
          class P_OverWrite_ValueSizeGreaterThanOriginal : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    string sValue = "Setdata value to cache in XBANC";
                    byte[] key = CreateKey();
                    byte[] value = _enc.GetBytes(sValue);
                    int oldValueLength = value.Length;

                    //insert original data
                    InsertSingleItem(key, value);

                    //Record Accel PerfCounters TotalBytesCached and TotalItemsCached.
                     //get perfcounters to verify
//                      uint bucket = HashKeyToBucket(key);
//                      IBucketServer b = Config.GetBucketServer(Interface.xbanc, (uint)bucket);
//                      PerformanceCounter AccelTotalDataBytes = new PerformanceCounter("Xbox Live XBanc Data", "Data bytes", "_Total_", b.CurrentServerName);
//                      PerformanceCounter AccelTotalItems = new PerformanceCounter("Xbox Live XBanc Data", "Total cache items", "_Total_", b.CurrentServerName);
//                      int oldTotalDataBytes = (int) AccelTotalDataBytes.NextValue();
//                      int oldTotalItems = (int) AccelTotalItems.NextValue();
                    
                    sValue = "Setdata value to cache in XBANC Greater than original!";
                    value = _enc.GetBytes(sValue);
                    int lengthDifference = value.Length - oldValueLength ;

                    /***** Call SetData with greater sized value *****/
                    SetData(key,value,0,0);
                                         
                    //Need to verify, possibly manually, that the old value was released and deleted
                     //Confirm PerfCounter TotalBytesCached and TotalItemsCached increased by 23 bytes and NO items.
//                      int newDataBytes = (int) AccelTotalDataBytes.NextValue();
//                      if ( newDataBytes - oldTotalDataBytes  != lengthDifference)
//                      {
//                           ResultCode = TEST_RESULTS.FAILED;
//                           _report.Fatal("Did not recieve expected Data Bytes perfcounter. newDataBytes = "+newDataBytes+", oldDataBytes = "+oldTotalDataBytes+", expected difference = "+lengthDifference);
//                      }
//                      int newTotalItems = (int) AccelTotalItems.NextValue();
//                      if (oldTotalItems != newTotalItems)
//                      {
//                           ResultCode = TEST_RESULTS.FAILED;
//                           _report.Fatal("Did not recieve expected total items perfcounter. oldTotalItems = "+oldTotalItems+", newTotalItems = "+newTotalItems);
//
//                      }
                   
                    //remove value from cache to clean up
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
               [TestCase]
          class N_Parameter_Null_Cases : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    uint[] hrArray;
                    byte[] key = null;
                    byte[] value = null;
                    byte[][] keyArray = null;
                    byte[][] keyNull = null;
                    byte[][] valueArray = null;
                    byte[][] valueNull = null;
                    
                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);
                    
                    /**** null key, valid value *****/
               
                     hr = _xb.SetData(null,value,0,0);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling SetData with null key returned "+hr+" instead of E_INVALIDARG");                     
                     }

                     hrArray = _xb.SetData(keyNull, valueArray, new uint[valueArray.Length],new uint[valueArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling SetData with null key array returned unexpected HResult array");
                     }

                     /*** valid key, null value ****/

                     hr = _xb.SetData(key, null,0,0);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling SetData with null value returned "+hr+" instead of E_INVALIDARG");                           
                     }

                      hrArray = _xb.SetData(keyArray, valueNull,new uint[keyArray.Length],new uint[keyArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling SetData  with null value array returned unexpected HResult array");
                     }
                     
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

                 [TestCase]
          class N_Parameter_Unequal_Length_Cases : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint[] hr;
                    
                    hr = _xb.SetData(new byte[][] {new byte[]{1}},new byte[][] {new byte[]{2},new byte[]{3},new byte[]{4},new byte[]{5}}, new uint[1], new uint[1]);
                    if (hr != null)
                    {
                        throw new Exception("Calling SetData with key array and value array different lengths returned unexpected HResult array");
                    }
                    
                    byte[][] key = new byte[][] {new byte[]{1},new byte[] {2},new byte[]{3}};
                    byte[][] value = new byte[][] {new byte[]{1,2},new byte[] {2,3},new byte[]{3,4,5,6}};

                    hr = _xb.SetData(key, value, new uint[] {0,0,0,0}, new uint[] {0,0,0,0} );
                    if (hr != null)
                    {
                        throw new Exception("Calling SetDAta with key array and expiry arrays different lengths returned unexpected HResult array");
                    }

                    hr = _xb.SetData(key, value, new uint[] {0,0,0,0,0}, new uint[] {0} );
                    if (hr != null)
                    {
                        throw new Exception("Calling SetData with key array and expiry arrays different lengths returned unexpected HResult array");
                    }

                     hr = _xb.SetData(key, value, new uint[] {0}, new uint[] {0,0} );
                    if (hr != null)
                    {
                        throw new Exception("Calling SetData with key array and expiry arrays different lengths returned unexpected HResult array");
                    }

                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase]
          class N_Parameter_Empty_Cases : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    byte[] value = null;
                    uint[] hrArray;
                    byte[][] keyArray = null;
                    byte[][] keyEmpty = new byte[0][];
                    byte[][] valueArray = null;
                    byte[][] valueEmpty = new byte[0][];
                    
                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);
                    
                    /**** empty key, valid value *****/

                     hr = _xb.SetData(new byte[0], value,0,0);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hr, "Calling setdata with empty key returned "+hr+" instead of E_INVALIDARG");                                      
                    }

                      hrArray = _xb.SetData(keyEmpty, valueArray, new uint[keyEmpty.Length], new uint[keyEmpty.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling setdata with empty key array returned unexpected HResult array");
                     }


                     /***** valid key, empty value ******/
                     hr = _xb.SetData(key, new byte[0],0,0);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                         throw new HResultException(hr, "Calling setdata with empty value returned "+hr+" instead of E_INVALIDARG");                        
                    }

                     hrArray = _xb.SetData(keyArray, valueEmpty, new uint[keyArray.Length], new uint[keyArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling setdata with empty value array returned unexpected HResult array");
                     }

                       /***** vaild key, valid value, empty expiries ******/
                      hrArray = _xb.SetData(keyArray, valueArray, new uint[0], new uint[0]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling setdata with empty expiry arrays returned unexpected HResult array");
                     }

                     hrArray = _xb.SetData(keyArray, valueArray, new uint[valueArray.Length], new uint[0]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling setdata with empty sliding expiry array returned unexpected HResult array");
                     }

                     hrArray = _xb.SetData(keyArray, valueArray, new uint[0], new uint[valueArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling setdata with empty absolute expiry array returned unexpected HResult array");   
                     }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class N_Key_SizeTooLong : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    byte[] value = null;
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);
                    
                    CreateKeyValuePair(out key, out value);

                    /***** key size too long, valid value *****/
                    byte[] keyTooLong =  new byte[_maxKeyLength + 1];
                    //fill key with some random values.
                    _random.NextBytes(keyTooLong);

                     hr = _xb.SetData(keyTooLong, value, 0, 0);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Insert with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

                 [TestCase]
          class N_KeyArray_Invalid_Cases : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint[] hrArray;
                    byte[][] key = null;
                    byte[][] value = null;
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);

                    /********* KEY CASES **************/
                    
                    //key[0] = null;
                    key = new byte[1][];
                    key[0] = null;
                    value = new byte[][] {new byte[]{1}};
                    
                    hrArray = _xb.SetData(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling SetData with null key first value returned unexpected HResult array");
                    }
                    if (hrArray[0] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[0], "Calling setdata with null key first value returned "+hrArray[0]+" instead of E_INVALIDARG");                           
                    }
                    //key[0] = invalid key, key[1] = valid key w/o reservation, key[2] = invalid key
                    key = new byte[3][];
                    key[0] = new byte[_maxKeyLength + 1];   //key size too long
                    key[1] = new byte[]{2,3,4,5};                   //insert without reservation
                    key[2] = null;                                          //null key
                    value = new byte[][] {new byte[]{1}, new byte[]{3}, new byte[]{5}};      //just random data

                    hrArray = _xb.SetData(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling setdata with null first key array returned unexpected HResult array");
                    }
                    if (hrArray[0] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[0], "Calling setdata with key size too long returned "+hrArray[0]+" instead of E_INVALIDARG");                           
                    }
                    if (hrArray[1] != HResult.S_OK) 
                    {
                        throw new HResultException(hrArray[1], "Calling setdata returned "+hrArray[1]+" instead of S_OK");                           
                    }
                    if (hrArray[2] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[2], "Calling setdata with null key returned "+hrArray[2]+" instead of E_INVALIDARG");                           
                    }

                    /**** VALUE CASES  *****/
                    key = new byte[][] {new byte[]{1}, new byte[]{2}};
                    value = new byte[2][];
                    value[0] = new byte[] {33};
                    value[1] = null;
                    hrArray = _xb.SetData(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling setdata with null second value array returned unexpected HResult array");
                    }
                    if (hrArray[1] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[1], "Calling setdata with null second value array returned "+hrArray[1]+" instead of E_INVALIDARG");                           
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\AccelFuncIncrement.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;
using xonline.common.diagnostics;


namespace AccelTest
{
     public class AccelFuncIncrement : TestNode
     {

          [TestCase]
          class P_Mainline : AccelFuncTestBase
          {
                 /***** valid key, valid value *****/
               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;
					
                    CreateKeyAmountPair(out key, out amount);
                    /***** valid non-existent key, valid amount *****/
                    Increment(key, amount);
                   
                     // increment an existing key (relies on the top part running first)
                    Increment(key, amount, amount * 2, HResult.S_OK);
                    
                    //remove for cleanup
                    Remove(key);

                     //Insert [][] overload
                    byte[][] key2 = null;
                    ulong[] amount2 = null;
                    ulong[] expectedAmount = null;
                    uint[] expectedHR = null;
                    
                    
                    CreateKeyAmountArrayPair(out key2, out amount2);

                    Increment(key2, amount2);
                    
                    expectedAmount = new ulong[key2.Length];
                    expectedHR = new uint[key2.Length];
                    for(int i=0; i<expectedAmount.Length; i++)
                    {
                        expectedAmount[i] = amount2[i] * 2;
                        expectedHR[i] = HResult.S_OK;
                    }
                    Increment(key2, amount2, expectedAmount, expectedHR);
                    
                     //cleanup
                    Remove(key2);
                    
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
           
          [TestCase, Description("Positive basic cases, incrementing a reservation, expired reservation")]
          
          class P_Keys_EdgeCase : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;

                     //pass in key size = 128
                     CreateKeyAmountPair(out key, out amount);
                     //create key
                     key = CreateKey(128);
                  
                    Increment(key, amount);

                    Remove(key);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase]
           class P_KeyArray_EdgeCases : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint[] hr;
                    ulong[] results = null;
                    byte[][] key = new byte[2][];
                    key[0] = new byte[] {34};
                    key[1] = null;
                    ulong[] amount = new ulong[2]; //just some random data
                    amount[0] = 25;
                    amount[1] = 45;
                    
                    hr = _xb.Increment(key, amount, out results);
                    if (hr == null || hr.Length != 2)
                    {
                        throw new Exception("Increment did not return expected HR results");
                    }
                    if (hr[0] != HResult.S_FALSE)
                    {
                        throw new HResultException(hr[1], "Increment returned "+hr[0]+" instead of S_FALSE");
                    }
                    if (hr[1] != HResult.E_INVALIDARG)
                    {
                        throw new HResultException(hr[0], "Increment returned "+hr[1]+" instead of E_INVALIDARG");
                    }

                    //remove for cleanup
                    Remove(key[0]);

                    key = new byte[100][];
                    amount = new ulong[100];
                    for(int i=0; i<key.Length; i++)
                    {
                        key[i] = CreateKey();
                        amount[i] = (ulong) _random.Next(1,10000);
                    }

                    Increment(key, amount);

                    //remove for cleanup
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;
                    
               }
          }

          [TestCase, Description("Call increment with amount edge cases")]
          
          class P_Amount_EdgeCases : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    ResultCode = TEST_RESULTS.PASSED;
                    byte[] key = CreateKey();
                    ulong amount = 0;

                    amount = 0;
                    /**** valid key, ZERO amount *****/
                    Increment(key, amount);
                    Increment(key, amount, amount, HResult.S_OK);
                  
                    //remove for cleanup
                     Remove(key);

                     /**** valid key, MAX_ULONG  amount *****/
                     amount = _maxULong;
                     Increment(key, amount);
                    
                    //increment an amount that is MAX_ULONG. xbanc will cap it at 
                    //MAX_LONG.
                    amount = 100;
                    ulong expected = 0x7FFFFFFFFFFFFFFF;
                    Increment(key, amount, expected, HResult.S_OK);

                    //remove for cleanup
                    Remove(key);

                    //PASS IN amount = 0 of known value to see if we get known value back
                    CreateKeyAmountPair(out key, out amount);
                    Increment(key, amount);
                   
                    Increment(key, 0, amount, HResult.S_OK);

                    Remove(key);

                    //Pass in initial amount of 0 and see if we can decay it
                    CreateKeyAmountPair(out key, out amount);
                    amount = 0;
                    //insert new amount
                     Increment(key, amount);
                    
                      //sleep one second for decay purposes
                    new SleepInfo("Sleep 1 second for decay",1*1000);
                  
                    //try to decay it!should still be zero
                     Increment(key, amount, 1, amount, HResult.S_OK);

                    //remove for cleanup
                     Remove(key);
               }
          }

          [TestCase, Description("Positive basic cases, incrementing a reservation, expired reservation")]
          
          class P_Increment_Reservation : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;

                    //try to increment a reservation
                    CreateKeyAmountPair(out key,out amount);

                    //make the reservation
                    Query(key, null, HResult.S_FALSE);

                    //try to increment it, it should pass!
                    Increment(key, amount);
                    Increment(key, amount, amount * 2, HResult.S_OK);

                     //remove for cleanup
                     Remove(key);
                     ResultCode = TEST_RESULTS.PASSED;
                
               }
          }

            [TestCase, Description("Positive basic cases, incrementing a reservation, expired reservation")]
          
          class P_Increment_ExpiredReservation : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;

                    CreateKeyAmountPair(out key,out amount);
                    //make the reservation

                    Query(key, null, HResult.S_FALSE);
                  
                    //wait 60 seconds for reservation to Expire
                    new SleepInfo("Waiting for reservation to expire",61*1000);
                    
                    //create a increment value on it
                    Increment(key, amount);
                    Increment(key, amount, amount * 2, HResult.S_OK);
                    
                     //remove for cleanup
                     Remove(key);
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

        

           [TestCase, Description("Positive basic cases, incrementing a reservation, expired reservation")]
          
          class P_Increment_OverwriteExpiredIncrement : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;

                    CreateKeyAmountPair(out key,out amount);

                     Increment(key, amount, XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE, 3, 0, amount, HResult.S_FALSE);
                  
                    //wait 3 seconds for increment to Expire
                    new SleepInfo("Waiting for reservation to expire",3*1000);
                    
                    //create a increment value on it
                    Increment(key, amount);
                    Increment(key, amount, amount * 2, HResult.S_OK);
                    
                     //remove for cleanup
                     Remove(key);
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase, Description("Positive basic cases, incrementing a reservation, expired reservation")]
          
          class P_Increment_OverwriteExpiredValue : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null, value = null;
                    ulong amount = 0;
                    CreateKeyValuePair(out key, out value);
                    CreateKeyAmountPair(out key,out amount);

                     SetData(key, value, 0, 3);
                  
                    //wait 3 seconds for set data to Expire
                    new SleepInfo("Waiting for reservation to expire",3*1000);
                    
                    //create a increment value on it
                    Increment(key, amount);
                    Increment(key, amount, amount * 2, HResult.S_OK);
                    
                     //remove for cleanup
                     Remove(key);
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Positive basic cases, incrementing a reservation, expired reservation")]
          
          class P_Increment_OverwriteDifferentExpiry : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null, value = null;
                    ulong amount = 0, result =0;
                    CreateKeyValuePair(out key, out value);
                    CreateKeyAmountPair(out key,out amount);

                     
                    // *******  verify increment expires 10 seconds after insertion **********
                    Increment(key, amount, AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE,3,0, amount, HResult.S_FALSE);
                    
                      //increment value again, with different expiry.
                     hr = _xb.Increment(key, 5876, 100000, 60, 0, out result); //5876, 100000: just some random stuff.
                     if (hr != HResult.S_OK)
                     {
                          throw new HResultException(hr, "Incrementing value 5 seconds after initial increment returned "+hr+" instead of S_OK.");
                     } //we won't check the returned results. decay cases verify this.

                     //wait 3 seconds for set data to Expire
                     new SleepInfo("Waiting for reservation to expire",3*1000);
                     
                     Query(key, null, HResult.S_FALSE);
                     Remove(key);

                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

         

       

          [TestCase, Description("Call increment with halflife = t and halflife = 1 with random amounts")]
          
          class P_Decay_RandomAmountHalfLife: AccelFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;
                    long ticksPerSecond = 10000000;
                    
                     //Pass in random amount of decay it
                     byte[] secondKey = null;
                     ulong secondAmount = 0;
                     
                    CreateKeyAmountPair(out key, out amount);
                    CreateKeyAmountPair(out secondKey, out secondAmount);
                    //insert new amount
                     Increment(key, amount);
                    
                    //insert new amount
                     Increment(secondKey, secondAmount);
                     
                    DateTime now = DateTime.Now;
                    //wait 60 seconds for decaying purposes
                    new SleepInfo("Waiting 30 seconds to decay", 30*1000);
                    DateTime then = DateTime.Now;
                    
                    long secondsPassed = (then.Ticks - now.Ticks)/ticksPerSecond;

                    //try to decay these
                    Increment(key, 0, (uint) secondsPassed, (ulong) amount/2,HResult.S_OK);
                     //halflife = 1 second, results should be halved secondsPassed times
                        // n0 * 1/2^60
                    Increment(secondKey,0, 1, (ulong) ((double) secondAmount /Math.Pow(2, (uint)secondsPassed) ), HResult.S_OK);
                     
                    //remove for cleanup
                    Remove(key);
                    Remove(secondKey);

                    ResultCode = TEST_RESULTS.PASSED;

               }
          }

                     [TestCase, Description("Create a new increment value with decay")]
          
          class P_Decay_NewIncrementValueHalfLifeCase : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;
                    
                    //create a new key/random amount pair                    
                    CreateKeyAmountPair(out key, out amount);
                    uint decayAmount = (uint) _random.Next(1, (int)(_maxUInt/2));
                        
                    //increment and decay a new value
                    Increment(key, amount, decayAmount, amount, HResult.S_FALSE);

                    //remove for cleanup
                    Remove(key);
                    ResultCode = TEST_RESULTS.PASSED;

               }
          }


          [TestCase, Description("Call increment with MAX_UINT, INFINITY, and INFINITY - 1 half life values")]
          
          class P_Decay_MaxUIntandInfinityHalfLifeCase : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] key = null, secondKey = null, thirdKey = null;
                    ulong amount = 0, secondAmount = 0, thirdAmount = 0;
                    long ticksPerSecond = 10000000;
                    
                    CreateKeyAmountPair(out key, out amount);
                    CreateKeyAmountPair(out secondKey, out secondAmount);
                    CreateKeyAmountPair(out thirdKey, out thirdAmount);
                                 
                    /**** valid key, halflife = MAX_UINT*****/

                    //create a new key/random amount pair
                    Increment(key, amount);
                    

                    //create second key/random value pair
                    Increment(secondKey, secondAmount);
                     

                     //create third key/random value pair
                    Increment(thirdKey, thirdAmount);
                     
                    //do my own time keeping, the sleepinfo wait is NOT reliable.
                    DateTime now = DateTime.Now;
                    //wait 30 seconds for decay purposes
                    new SleepInfo("Waiting 30 seconds for decay", 30*1000);
                    
                    //try to decay with halflife = maxuint, there should be no decay (gigantic halflife)
                    Increment(key, 0, _maxUInt, amount, HResult.S_OK);
                     

                     //try to decay with halflife = XBANC_INCREMENT_HALFLIFE_INFINITE
                    Increment(secondKey, 0, AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE, secondAmount, HResult.S_OK);

                    //try to decay with halflife = XBANC_INCREMENT_HALFLIFE_INFINITE - 1
                    DateTime then = DateTime.Now;
                    long secondsPassed = (then.Ticks - now.Ticks)/ticksPerSecond;

                    //we'll leave some increment in the call
                    
                    //calculate the result: N(t) = N0 * e ^(lamda * t)
                    double lamda = Math.Log(2.0, Math.E) / (double)(AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE - 1);
                    ulong newAmount = (ulong) (thirdAmount * Math.Pow(Math.E, -(lamda*secondsPassed)) + thirdAmount);
                    Increment(thirdKey, thirdAmount, AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE - 1, newAmount, HResult.S_OK);
                                     
                    //remove for cleanup
                    Remove(key);
                    Remove(secondKey);
                    Remove(thirdKey);    

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Decay one increment value multiple times with the same half life")]
          class P_Decay_MultipleSameHalfLifeCase : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;
                    long ticksPerSecond = 10000000;
                    
                    CreateKeyAmountPair(out key, out amount);
                                 
                    /**** valid key, halflife = 10*****/

                    //create a new key/random amount pair
                    Increment(key, amount);
                    

                    //do my own time estimation!
                    DateTime now = DateTime.Now;

                    //with halflife seconds 10, lamda = ln(2)/10 = 6.9315
                    double lamda = Math.Log(2.0, Math.E) / (double)(10);
                    //N(t) = N0 * e ^ -(lamda * t)
                    double newAmount = amount;
                    for(int i=0; i<5; i++)
                    {
                        now = DateTime.Now;
                        //wait 5 seconds for decay purposes
                        new SleepInfo("Waiting 5 seconds for decay", 5*1000);
                        //do my own time estimation
                        DateTime then = DateTime.Now;
                        double secondsPassed = (then.Ticks - now.Ticks)/ticksPerSecond;
                        //compute new amount, every 5 seconds with halflife 10
                        newAmount = ( newAmount * Math.Pow(Math.E,-(lamda*secondsPassed))) + 15;
                        //try to decay with halflife = 10 
                        Increment(key, 15, 10, (ulong)newAmount, HResult.S_OK); //increment each time by 15 
                    }

                    //remove for cleanup
                    Remove(key);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Decay one increment value multiple times with different half lives")]
          class P_Decay_MultipleDifferentHalfLifeCase : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;
                    long ticksPerSecond = 10000000;
                    
                    CreateKeyAmountPair(out key, out amount);
                                 
                    /**** valid key, halflife = different*****/

                    //create a new key/random amount pair
                    Increment(key, amount);
                    
                    //do my own time estimation!
                    DateTime now = DateTime.Now;

                    //with halflife seconds 10, lamda = ln(2)/10 = 6.9315

                    //N(t) = N0 * e ^ -(lamda * t)
                    double newAmount = amount;
                    for(int i=0; i<5; i++)
                    {
                        //this time we'll do random halflifes and increments, yay.
                        uint randHalfLife = (uint)_random.Next(1,2147483647); 
                        ulong randAmount = (ulong)_random.Next(0,2147483647);
                        
                        now = DateTime.Now;
                        //wait 5 seconds for decay purposes
                        new SleepInfo("Waiting 5 seconds for decay", 5*1000);
                        //do my own time estimation
                        DateTime then = DateTime.Now;
                        double secondsPassed = (then.Ticks - now.Ticks)/ticksPerSecond;
                        //compute new amount, every 5 seconds 
                        newAmount = randAmount + newAmount * Math.Pow(2, -secondsPassed / (double)randHalfLife);
                        //try to decay with different halflifes

                        Increment(key, randAmount, randHalfLife, (ulong)newAmount, HResult.S_OK); 
                         
                    }

                    //remove for cleanup
                    Remove(key);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Verify decay with constant half life (10) while simulating periodic increments (1 tps)")]
          class P_Decay_ConstantIncrements_LowTps : AccelFuncTestBase
          {
               override protected void Execute()
               {
                   RunIncrementWithDelayTps(10, 1, 10);
               }
          }

          [TestCase, Description("Verify decay with constant half life (10) while simulating periodic increments (10 tps)")]
          class P_Decay_ConstantIncrements_HighTps : AccelFuncTestBase
          {
               override protected void Execute()
               {
                   RunIncrementWithDelayTps(10, 10, 10);
               }
          }

          [TestCase, Description("Verify decay with constant half life (2) while simulating periodic increments (20 tps)")]
          class P_Decay_ConstantIncrements_HigherTps : AccelFuncTestBase
          {
               override protected void Execute()
               {
                   RunIncrementWithDelayTps(2, 20, 10);
               }
          }

          [TestCase, Description("Verify decay with constant half life (60) while simulating periodic increments (20 tps)")]
          class P_Decay_ConstantIncrements_HigherTpsBigHalflife : AccelFuncTestBase
          {
               override protected void Execute()
               {
                   RunIncrementWithDelayTps(60, 20, 10);
               }
          }

           [TestCase]
          
          class P_Expiry_Absolute_Main : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;

                    CreateKeyAmountPair(out key,out amount);

                     Increment(key, amount, AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE, 3, 0, amount, HResult.S_FALSE);
                  
                    //wait 3 seconds for increment to Expire
                    new SleepInfo("Waiting for reservation to expire",3*1000);
                    
                    //create a increment value on it
                    Increment(key, amount);
                    Increment(key, amount, amount * 2, HResult.S_OK);
                    
                     //remove for cleanup
                     Remove(key);
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class P_Expiry_Absolute_DespiteInsertIncrementQuery : AccelFuncTestBase
          {

                override protected void Execute()
               {
                    
                    uint hr;
                    byte[] absoluteKey = null;
                    ulong amount = 0, result = 0;                    
                  
                     //create absolute key, one value
                    CreateKeyAmountPair(out absoluteKey, out amount);
          
                    // *******  verify value expires 30 seconds after insertion despite multiple increments, queries, and inserts **********
                    CreateKeyAmountPair(out absoluteKey, out amount);
                    Increment(absoluteKey, amount, 1, 30, 0, amount, HResult.S_FALSE);
                      //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);

                     //try to insert some value again
                     byte[] value = new byte[] {5,10,15,20};
                     hr = _xb.Insert(absoluteKey, value);
                     if (hr != HResult.E_ACCESSDENIED)
                     {
                          throw new HResultException(hr, "Inserting value on top of increment value 5 seconds after increment returned "+hr+" instead of E_ACCESSDENIED.");
                     }

                     //increment value
                     Increment(absoluteKey, 5876, amount + 5876, HResult.S_OK); //5876 is just some random stuff.
                     
                     //query for the key to get S_OK
                     Query(absoluteKey, null, HResult.S_OK);

                     //increment value again, with different expiry.
                     hr = _xb.Increment(absoluteKey, 5876, 100000, 60, 0, out result); //5876, 100000: just some random stuff.
                     if (hr != HResult.S_OK)
                     {
                         throw new HResultException(hr, "Increment returned "+hr+" instead of S_OK");
                     } //we won't check the returned results. decay cases verify this.
                    
                     //sleep for 25 seocnds, incrememnt value should expire.
                     new SleepInfo("Wait 25 seconds.", 25 * 1000);
                   
                     //try to increment the key to also get S_FALSE
                     Increment(absoluteKey, amount);

                    //remove key for cleanup
                    Remove(absoluteKey);

                    ResultCode = TEST_RESULTS.PASSED;

                   }
          }


           [TestCase]
          
          class P_Expiry_Sliding_Main : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;

                    CreateKeyAmountPair(out key,out amount);

                     Increment(key, amount, AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE, 0, 3, amount, HResult.S_FALSE);
                  
                    //wait 3 seconds for increment to Expire
                    new SleepInfo("Waiting for reservation to expire",3*1000);
                    
                    //create a increment value on it
                    Increment(key, amount);
                    Increment(key, amount, amount * 2, HResult.S_OK);
                    
                     //remove for cleanup
                     Remove(key);
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }


          

             [TestCase, Description("Test sliding expiration with multiple Query, Insert, and Increment calls")]
          class P_Expiry_Sliding_DespiteInsert : AccelFuncTestBase
          {

                override protected void Execute()
               {
                    uint hr;
                    byte[] slidingKey = null;
                    ulong amount = 0;                    
                    
                    CreateKeyAmountPair(out slidingKey, out amount);

                    // *******  verify value expires 30 seconds after insertion despite multiple increments, queries, and inserts **********
                    Increment(slidingKey, amount, 1, 0, 10, amount, HResult.S_FALSE);
                   
                     //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                     
                     //try to insert some value again
                     byte[] value = new byte[] {5,10,15,20};
                     hr = _xb.Insert(slidingKey, value);
                     if (hr != HResult.E_ACCESSDENIED)
                     {
                          throw new HResultException(hr, "Inserting value on top of increment value 5 seconds after increment returned "+hr+" instead of E_ACCESSDENIED.");
                     }

                     //sleep for 5 more seocnds
                     new SleepInfo("Wait 5 more seconds.", 5 * 1000);

                     //try to increment the key to also get s_false
                     Increment(slidingKey, amount);
                                      
                    //remove key for cleanup
                    Remove(slidingKey);

                    ResultCode = TEST_RESULTS.PASSED;
                }
             }

                [TestCase, Description("Test sliding expiration with multiple Query, Insert, and Increment calls")]
          class P_Expiry_Sliding_DespiteMultipleIncrements : AccelFuncTestBase
          {
                override protected void Execute()
               {
                    uint hr;
                    byte[] slidingKey = null;
                    ulong amount = 0, result = 0;                    

                    // *******  verify value expires 30 seconds after insertion despite multiple increments, queries, and inserts **********
                    CreateKeyAmountPair(out slidingKey, out amount);
                    Increment(slidingKey, amount, 1, 0, 10, amount, HResult.S_FALSE);
                    
                     //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                     
                    //try to increment the key to increase sliding expiration
                      hr = _xb.Increment(slidingKey, amount, 1000, out result); //random decay... not going to check it.
                     if (hr != HResult.S_OK)
                     {
                          throw new HResultException(hr, "Increment returned "+hr+" instead of S_OK.");
                     }
                     
                      //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                      
                    //try to increment the key to increase sliding expiration
                      hr = _xb.Increment(slidingKey, amount, 1000, out result); //random decay... not going to check it.
                     if (hr != HResult.S_OK)
                     {
                          throw new HResultException(hr, "Increment returned "+hr+" instead of S_OK.");
                     }
                     //sleep for 10 seocnds for expiry
                     new SleepInfo("Wait 10 seconds for expiry", 10 * 1000);

                     //try to increment the key to also get s_false
                     Increment(slidingKey, amount);

                    //remove key for cleanup
                    Remove(slidingKey);
                    ResultCode = TEST_RESULTS.PASSED;
                }
           }

                  [TestCase, Description("Test sliding expiration with multiple Query, Insert, and Increment calls")]
          class P_Expiry_Sliding_DespiteMultipleIncrementsDiffExpiry : AccelFuncTestBase
          {

                override protected void Execute()
               {
                    uint hr;
                    byte[] slidingKey = null;
                    ulong amount = 0, result = 0;                    
                  

                       _report.Debug("Starting value expires 10 seconds after last Increment with different expiry values.");
                    // *******  verify value expires 30 seconds after insertion despite multiple increments, queries, and inserts **********
                    CreateKeyAmountPair(out slidingKey, out amount);
                    Increment(slidingKey, amount, 1, 0, 10, amount, HResult.S_FALSE);
                   
                     //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                     
                    //try to increment the key to increase sliding expiration
                      hr = _xb.Increment(slidingKey, amount, 1000, 100, 0, out result); //random decay... not going to check it.
                     if (hr != HResult.S_OK)
                     {
                         throw new HResultException(hr, "Increment returned "+hr+" instead of S_OK.");
                     }
                     
                      //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                      
                    //try to increment the key to increase sliding expiration
                      hr = _xb.Increment(slidingKey, amount, 1000, 0, 100, out result); //random decay... not going to check it.
                     if (hr != HResult.S_OK)
                     {
                          throw new HResultException(hr, "Increment returned "+hr+" instead of S_OK.");
                     }
                     //sleep for 10 seocnds for expiry
                     new SleepInfo("Wait 10 seconds for expiry", 10 * 1000);

                     //try to increment the key to also get s_false
                      Increment(slidingKey, amount);
                   
                    //remove key for cleanup
                    Remove(slidingKey);
                    ResultCode = TEST_RESULTS.PASSED;
                }
          }

                    [TestCase, Description("Test sliding expiration with multiple Query, Insert, and Increment calls")]
          class P_Expiry_Sliding_DespiteMultipleQueries : AccelFuncTestBase
          {
                override protected void Execute()
               {
                    byte[] slidingKey = null;
                    ulong amount = 0 ;                    
                  
                    CreateKeyAmountPair(out slidingKey, out amount);
                     Increment(slidingKey, amount, 1, 0, 10, amount, HResult.S_FALSE);
                    
                     //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                     //Query for key to increase sliding expiration
                     Query(slidingKey,null, HResult.S_OK);
                     
                      //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                     //Query for key to increase sliding expiration
                     Query(slidingKey,null, HResult.S_OK);
                     
                     //sleep for 10 seocnds for expiry
                     new SleepInfo("Wait 10 seconds for expiry", 10 * 1000);

                     //try to increment the key to also get s_false
                      Increment(slidingKey, amount);
                      
                    //remove key for cleanup
                    Remove(slidingKey);
                     ResultCode = TEST_RESULTS.PASSED;
                }
          }

           [TestCase, Description("Test sliding expiration with multiple Query, Insert, and Increment calls")]
          class P_Expiry_Sliding_Remove : AccelFuncTestBase
          {
                override protected void Execute()
               {
                    uint hr;
                    byte[] slidingKey = null;
                    ulong amount = 0, result = 0;   
                    
                    CreateKeyAmountPair(out slidingKey, out amount);                    
                  
                    Increment(slidingKey, amount, AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE,0,10, amount, HResult.S_FALSE);
                    
                      //increment value again, with different expiry.
                     hr = _xb.Increment(slidingKey, 5876, 100000, 60, 0, out result); //5876, 100000: just some random stuff.
                     if (hr != HResult.S_OK)
                     {
                           throw new HResultException(hr, "Increment returned "+hr+" instead of S_OK.");
                     } //we won't check the returned results. decay cases verify this.

                      Remove(slidingKey);
                    
                     //try to increment the key to also get s_false
                      Increment(slidingKey, amount);
                      
                    //remove key for cleanup
                     Remove(slidingKey);
                     ResultCode = TEST_RESULTS.PASSED;
                }
          }

                [TestCase, Description("AbsoluteSeconds = 15, slidingSeconds = 10")]
          class P_Expiry_Both_Abs5Slid10 : AccelFuncTestBase
          {

                override protected void Execute()
               {
                    byte[] slidingKey = null;
                    ulong amount = 0;                    
                    
                     //create sliding and absolute keys, one value
                    CreateKeyAmountPair(out slidingKey, out amount);
          
                    //valid key, valid value, 10 seconds sliding expiration          

                    _report.Debug("Starting value expires 5 seconds after insertion test with 10 second sliding expiry.");
                    // *******  verify increment expires 10 seconds after insertion **********
                    Increment(slidingKey, amount, AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE,5,10, amount, HResult.S_FALSE);
                    
                     //sleep for 5 seocnds, value should expire
                     new SleepInfo("Wait 5 seconds for increment to expire", 5 * 1000);
                    
                     //try to increment the key to also get s_false
                     Increment(slidingKey, amount);

                    //remove key for cleanup
                    Remove(slidingKey);
                    ResultCode = TEST_RESULTS.PASSED;
                }
          }

                     [TestCase, Description("AbsoluteSeconds = 15, slidingSeconds = 10")]
          class P_Expiry_Both_Abs10Slid5 : AccelFuncTestBase
          {

                override protected void Execute()
               {
                    byte[] slidingKey = null;
                    ulong amount = 0;                    
                  
                     //create sliding and absolute keys, one value
                    CreateKeyAmountPair(out slidingKey, out amount);
          
                    Increment(slidingKey, amount, AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE,10,5, amount, HResult.S_FALSE);
                    
                     //sleep for 5 seocnds, value should expire
                     new SleepInfo("Wait 5 seconds for increment to expire", 5 * 1000);
                    
                     //try to increment the key to also get s_false
                     Increment(slidingKey, amount);
                  
                    //remove key for cleanup
                    Remove(slidingKey);
                    ResultCode = TEST_RESULTS.PASSED;
                }
          }
          

             [TestCase, Description("AbsoluteSeconds = 15, slidingSeconds = 10")]
          class P_Expiry_Both_DespiteInsertIncrementQuery : AccelFuncTestBase
          {

                override protected void Execute()
               {
                    uint hr;
                    byte[] slidingKey = null;
                    ulong amount = 0, result = 0;                    
                  
                    CreateKeyAmountPair(out slidingKey, out amount);
                    Increment(slidingKey, amount, AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE, 15, 10, amount, HResult.S_FALSE);
                     //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                     
                     //try to insert some value again
                     byte[] rgbValue = new byte[] {5,10,15,20};
                     
                     //increment value again, with different expiry.
                     hr = _xb.Increment(slidingKey, 5876, 100000, 60, 0, out result); //5876, 100000, 60: just some random stuff.
                     if (hr != HResult.S_OK)
                     {
                          throw new HResultException(hr, "Increment returned "+hr+" instead of E_ACCESSDENIED.");
                     } //we won't check the returned results. decay cases verify this.

                     //sleep for 5 more seocnds
                     new SleepInfo("Wait 5 more seconds.", 5 * 1000);

                     //Query for key to increase sliding expiration
                      Query(slidingKey, null, HResult.S_OK); 

                      //sleep for 5 seocnds, value should expire
                     new SleepInfo("Wait 5 seconds for expiry", 5 * 1000);

                     //try to increment the key to also get s_false
                     Increment(slidingKey, amount);

                    //remove key for cleanup
                    Remove(slidingKey);
                    ResultCode = TEST_RESULTS.PASSED;
                  }
          }

          [TestCase, Description("Create new increment value over a reservation, setData over an increment value")]
          class P_Integration_Query : AccelFuncTestBase
          {

                 override protected void Execute()
               {
                   
                    uint hr;
                    byte[] key = null, outValue = null;
                    ulong amount = 0;
                    
                    //create a new key/random amount pair                    
                    CreateKeyAmountPair(out key, out amount);
                    uint decayAmount = (uint) _random.Next(1, (int)(_maxUInt/2));
                    //place a reservation at the key
                    Query(key, null, HResult.S_FALSE);
                    
                    //increment and decay a new value OVER A RESERVATION
                    Increment(key, amount, decayAmount, amount, HResult.S_FALSE);
                  
                    //query for the increment key, check if we get the value back
                    hr = _xb.Query(key, out outValue);
                    if (hr != HResult.S_OK)
                    {
                        throw new HResultException(hr, "Query returned "+hr+" instead of S_OK");
                    }
                     //the returned value should be the amount.
                    ulong returnedValue = (ulong) BitConverter.ToUInt64(outValue,0);
                    ValidateReturnedData(amount, returnedValue);

                    //remove for cleanup
                    Remove(key);
                    ResultCode = TEST_RESULTS.PASSED;

               }
          }

               [TestCase, Description("Create new increment value over a reservation, setData over an increment value")]
          class P_Integration_SetData : AccelFuncTestBase
          {

                 override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;
                    
                    //create a new key/random amount pair                    
                    CreateKeyAmountPair(out key, out amount);
                    uint decayAmount = (uint) _random.Next(1, (int)(_maxUInt/2));
                   
                    //increment and decay a new value 
                    Increment(key, amount, decayAmount, amount, HResult.S_FALSE);
                  
                    //call setdata to overwrite increment value
                    byte[] newValue = new byte[] {1,2,3,4,5,6,7,8}; //just some random value;
                    SetData(key, newValue, 0,0);

                    //remove for cleanup
                    Remove(key);
                    ResultCode = TEST_RESULTS.PASSED;

               }
          }
                    [TestCase, Description("Create an increment value over removed increment values")]
          class P_Integration_Remove: AccelFuncTestBase
          {

                 override protected void Execute()
               {
                    ResultCode = TEST_RESULTS.PASSED;
                    byte[] key = null;
                    ulong amount = 0;
                    
                    //create a new key/random amount pair                    
                    CreateKeyAmountPair(out key, out amount);
                    uint decayAmount = (uint) _random.Next(1, (int)(_maxUInt/2));

                    //bulk remove not supported in acceleration    
                    //increment and decay a new value
                    //Increment(key, amount, decayAmount, amount, HResult.S_FALSE);

                    //remove the key by prefix.
                   // byte[] prefix = new byte[key.Length - 1];
                    //Array.Copy(key,0,prefix,0,key.Length - 1);

                    //Remove(prefix,false);

                    //call increment on this removed value again
                    //increment and decay a new value
                   Increment(key, amount, decayAmount, amount, HResult.S_FALSE);
                    
                    //remove the key exactly
                    Remove(key);

                     //call increment on this removed value again
                    //increment and decay a new value
                     Increment(key, amount, decayAmount, amount, HResult.S_FALSE);

                     //remove key for cleanup
                      Remove(key);
               }
          }
                    
          [TestCase]
          class N_Parameter_Null_Cases : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    ulong result;
                    uint[] hrArray;
                    byte[][] keyArray = new byte[1][];
                    byte[][] keyNull = null;
                    ulong[] amountArray = new ulong[] {1};
                    ulong[] amountNull = null;
                    uint[] halfLives = new uint[] {1};
                    uint[] halfLivesNull = null;
                    uint[] expiryNull = null;
                    ulong[] results = null;
                    keyArray[0] = new byte[] {1};
                    
                     hr = _xb.Increment(null,1, out result);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                     
                     }

                      hr = _xb.Increment(null,1,1, out result);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                           
                     }
                     
                     hr = _xb.Increment(null,1,1, 0,0, out result);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                           
                     }

                     hrArray = _xb.Increment(keyNull, amountArray, halfLives, new uint[amountArray.Length],new uint[amountArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with null key array returned unexpected HResult array");
                     }
                     
                     hrArray = _xb.Increment(keyArray, amountNull, halfLives, new uint[keyArray.Length],new uint[keyArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with null amount array returned unexpected HResult array");
                     }

                     hrArray = _xb.Increment(keyArray, amountArray, halfLivesNull, new uint[keyArray.Length],new uint[keyArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with null half life array returned unexpected HResult array");
                     }

                     hrArray = _xb.Increment(keyArray, amountArray, halfLives, expiryNull ,new uint[keyArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with null absolute returned unexpected HResult array");
                     }

                     hrArray = _xb.Increment(keyArray, amountArray, halfLives, new uint[keyArray.Length], expiryNull, out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with null sliding expiry returned unexpected HResult array");
                     }


                     
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase]
          class N_Parameter_Empty_Cases : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    uint[] hrArray;
                    ulong result;
                    byte[][] keyArray = new byte[1][];
                    byte[][] keyEmpty = new byte[0][];
                    ulong[] amountArray = new ulong[] {1};
                    ulong[] amountEmpty = new ulong[0];
                    uint[] halfLives = new uint[] {1};
                    uint[] halfLivesEmpty = new uint[0];
                    uint[] expiryEmpty = new uint[0];
                    ulong[] results = null;
                    keyArray[0] = new byte[] {1};
                    
                    hr = _xb.Increment(new byte[0],1, out result);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                     
                     }

                      hr = _xb.Increment(new byte[0],1,1, out result);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                           
                     }

                     hr = _xb.Increment(new byte[0],1,1,0,0, out result);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                           
                     }


                     hrArray = _xb.Increment(keyEmpty, amountArray, halfLives, new uint[amountArray.Length],new uint[amountArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with empty key array returned unexpected HResult array");
                     }
                     
                     hrArray = _xb.Increment(keyArray, amountEmpty, halfLives, new uint[keyArray.Length],new uint[keyArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with empty amount array returned unexpected HResult array");
                     }

                     hrArray = _xb.Increment(keyArray, amountArray, halfLivesEmpty, new uint[keyArray.Length],new uint[keyArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with empty half life array returned unexpected HResult array");
                     }

                     hrArray = _xb.Increment(keyArray, amountArray, halfLives, expiryEmpty ,new uint[keyArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with empty absolute returned unexpected HResult array");
                     }

                     hrArray = _xb.Increment(keyArray, amountArray, halfLives, new uint[keyArray.Length], expiryEmpty, out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with empty sliding expiry returned unexpected HResult array");
                     }


                     
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }
               [TestCase]
          class N_Parameter_ZeroHalfLife : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    byte[] key;
                    ulong amount, result;
                    
                    CreateKeyAmountPair(out key, out amount);

                    hr = _xb.Increment(key, amount, 0, out result);
                     if (hr != HResult.E_INVALIDARG)
                    {
                         throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                     
                    }

                    hr = _xb.Increment(key, amount, 0, 0, 0, out result);
                     if (hr != HResult.E_INVALIDARG)
                    {
                         throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                     
                    }
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class N_Key_SizeTooLong : AccelFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    ulong result;
                    
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);
                    byte[] keyTooLong =  CreateKey(_maxKeyLength + 1);

                     hr = _xb.Increment(keyTooLong, 1, out result);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Increment with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }

                    hr = _xb.Increment(keyTooLong, 1, 1, out result);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Increment with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }
                     hr = _xb.Increment(keyTooLong, 1, 1, 0, 0, out result);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Increment with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

              [TestCase]
          class N_KeyArray_Invalid_Cases : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint[] hrArray;
                    byte[][] key = null;
                    ulong[] amountArray = new ulong[] {1};
                    uint[] halfLives = new uint[] {1};
                    ulong[] results = null;
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);

                    //remove the hardcoded key required here.
                    key = new byte[1][];
                    key[0] = new byte[]{2,3,4,5};
                    _xb.Remove(key);

                    /********* KEY CASES **************/
                    
                    //key[0] = null;
                    key = new byte[1][];
                    key[0] = null;
                    
                    hrArray = _xb.Increment(key, amountArray, halfLives, new uint[key.Length], new uint[key.Length], out results);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling Increment with null key first value returned unexpected HResult array");
                    }
                    if (hrArray[0] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[0], "Calling Insert with null key first value returned "+hrArray[0]+" instead of E_INVALIDARG");                           
                    }
                    
                    //key[0] = invalid key, key[1] = valid key, key[2] = invalid key
                    key = new byte[3][];
                    key[0] = new byte[_maxKeyLength + 1];   //key size too long
                    key[1] = new byte[]{2,3,4,5};                   //increment
                    key[2] = null;                                          //null key
                    amountArray = new ulong[] {1, 3, 5};      //just random data
                    halfLives = new uint[] {4, 5, 6};      //just random data

                    hrArray = _xb.Increment(key, amountArray, halfLives, new uint[key.Length], new uint[key.Length], out results);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling Increment with null first key array returned unexpected HResult array");
                    }
                    if (hrArray[0] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[0], "Calling Increment with key size too long returned "+hrArray[0]+" instead of E_INVALIDARG");                           
                    }
                    if (hrArray[1] != HResult.S_FALSE) 
                    {
                        throw new HResultException(hrArray[1], "Calling Increment with key without reservation returned "+hrArray[1]+" instead of S_FALSE");                           
                    }
                    if (hrArray[2] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[2], "Calling Increment with null key returned "+hrArray[2]+" instead of E_INVALIDARG");                           
                    }
                    if (results == null || results[1] != amountArray[1])
                    {
                        throw new Exception("Calling Increment with two invalid keys and one valid key returned "+((results.Length == 3)?results[1].ToString():"null")+" instead of "+amountArray[1]);       
                    }

                    //cleanup
                    Remove(key[1]);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

             [TestCase]
          class N_Increment_NonIncrementValue_Small : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    ulong amount = 0, result = 0;
                    
                     // increment a nonincrementable value sized < the incrementable value size
                    byte[] value = new byte[_random.Next(1,(int) _incrementValueSize)];
                    _random.NextBytes(value);
                    CreateKeyAmountPair(out key,out amount);
                    
                     //insert value sized < incrementable value size
                    SetData(key,value,0,0);
                    
                    //try to increment the value
                    hr = _xb.Increment(key,amount,out result);
                    if (hr != HResult.E_ACCESSDENIED)
                    {
                       throw new HResultException(hr, "Increment returned "+hr+" instead of E_ACCESSDENIED");
                    }
                    
                    //query to make sure nothing went wrong
                    Query(key,value, HResult.S_OK);

                    Remove(key);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class N_Increment_NonIncrementValue_Same : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    ulong amount = 0, result = 0;

                    // increment a nonincrementable value sized == the incrementable value
                    //insert value sized == incrementable value size
                    
                    byte[] value = new byte[_incrementValueSize];
                    _random.NextBytes(value);
                    CreateKeyAmountPair(out key, out amount);
                    
                    SetData(key,value,0,0);
                    
                    //try to increment the value
                    hr = _xb.Increment(key,amount,out result);
                    if (hr != HResult.E_ACCESSDENIED)
                    {
                       throw new HResultException(hr, "Increment returned "+hr+" instead of E_ACCESSDENIED");
                    }
                    
                    //query to make sure nothing went wrong
                    Query(key,value, HResult.S_OK);
                    Remove(key);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase]
          class N_Increment_NonIncrementValue_Large : AccelFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    ulong amount = 0, result = 0;

                    // increment a nonincrementable value sized == the incrementable value
                    //insert value sized == incrementable value size
                    
                    byte[] value = new byte[_random.Next((int) _incrementValueSize+1,(int) _incrementValueSize+1025)];
                    _random.NextBytes(value);
                    CreateKeyAmountPair(out key, out amount);
                    
                    SetData(key,value,0,0);
                    
                    //try to increment the value
                    hr = _xb.Increment(key,amount,out result);
                    if (hr != HResult.E_ACCESSDENIED)
                    {
                       throw new HResultException(hr, "Increment returned "+hr+" instead of E_ACCESSDENIED");
                    }
                    
                    //query to make sure nothing went wrong
                    Query(key,value, HResult.S_OK);
                    Remove(key);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
      }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\AccelTest.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Core.Utilities;
using xonline.common.diagnostics;
using xonline.common.config;
using xonline.common.service;

[assembly: RootNode(typeof(AccelTest.AccelTest))]

namespace AccelTest
{
    [Owner("KKline"),TestFrequency("Regression"),TestCasePriority(3)]
    public class AccelTest : TestNode
    {
        public AccelTest()
        {
            //
            // TODO: Add constructor logic here
            //

            AddChild(new AccelFuncIncrement());
            AddChild(new AccelFuncInsert());
            AddChild(new AccelFuncNotif());
            AddChild(new AccelFuncQuery());
            AddChild(new AccelFuncRemove());
            AddChild(new AccelFuncSequence());
            AddChild(new AccelFuncSetData());
            AddChild(new AccelFuncConcurrency());
            AddChild(new AccelFuncHighVolume());
            //AddChild(new AccelFuncMRU()); -- not supported in Acceleration
            AddChild(new AccelFuncMulti());
        }

        public override void PreRun(RUN_TYPE runType)
        {
            if (runType != RUN_TYPE.STRESS)
            {
                return;
            }

            AccelStressManager.Initialize(Global.Config);
            AccelStressTestBase.Init();
        }
    }

        public class AccelFuncTestBase : TestBase
        {
            protected override void Execute()
            {
                throw new Exception("Execute: The method or operation is not implemented.");
            }

            

            protected ASCIIEncoding _enc = new ASCIIEncoding();
            protected int _incrementValueSize = 20;
            protected string _keyPrefix = "Test";
            protected uint _maxUInt = 4294967295;
            protected ulong _maxULong = 18446744073709551615;
            protected RandomEx _random = new RandomEx();
            protected Report _report = new Report("Log");
            protected uint _reservationExpirySeconds = 60;
            protected int _maxKeyLength = (int)Config.GetUIntSetting(Setting.acceleration_max_key_length);
            protected Acceleration _xb = new Acceleration(Interface.acceleration);

            public class lockObject
            {
                public int lockO;
            }

            public lockObject lo = new lockObject();
            
            public  List<byte[]> _expectedKeys = new List<byte[]>();
            public List<byte[]> _keysToVerify = new List<byte[]>();
            protected bool _notifHandlerCalled = false;

            //*** Used by AccelFuncNotif.cs ***//
            public bool failureCalled = false;
            public void FailureNotif()
            {
                failureCalled = true;
            }
            public bool failure2Called = false;
            public void FailureNotif2()
            {
                lock (lo)
                {
                    lo.lockO = 1;
                    failure2Called = true;
                }
            }

            public byte[][] _retKeys2 = null;
            public bool handler2Called = false;
            public void Handler2(byte[][] retkeys)
            {
                lock (lo)
                {
                    handler2Called = true;
                    _retKeys2 = retkeys;
                }
            }

            public byte[][] _retKeys3 = null;
            public bool handler3Called = false;
            public void Handler3(byte[][] retkeys)
            {
                lock (lo)
                {
                    handler3Called = false;
                    _retKeys3 = retkeys;
                }
            }
            //*** Used by AccelFuncNotif.cs ***//
            protected delegate bool CompareKeysDelegate();
            protected CompareKeysDelegate _compareFunction;

            //we should lock(lo) before calling this function
            protected bool RegularCompareKeys()
            {
                bool retVal = true;
                if (_keysToVerify == null || _expectedKeys == null)
                {
                    throw new Exception("Key lists were null when unexpected.");
                }
                if (_keysToVerify.Count == 0 && _expectedKeys.Count > 0)
                {
                    return false;
                }

                if (_expectedKeys.Count != 0)
                {
                    //make sure none of the returned keys are null
                    int ind = 0;
                    foreach (byte[] key in _keysToVerify)
                    {
                        if (key == null)
                        {
                            throw new Exception("Returned key at index " + ind + " was null when not expected.");
                        }
                        ind++;
                    }
                    for (int i = 0; i < _expectedKeys.Count; i++)
                    {
                        bool found = false;
                        for (int j = _keysToVerify.Count - 1; j >= 0; j--)
                        {
                            if (Acceleration.CompareByteArrays(_expectedKeys[i], _keysToVerify[j]))
                            {
                                found = true;
                                _expectedKeys.RemoveAt(i);
                                _keysToVerify.RemoveAt(j);
                                break;
                            }
                        }
                        if (found == false)
                        {
                            retVal = false;
                        }
                    }
                }
                _report.Info("Regular compare keys passed.");
                return retVal;
            }

            //not to be used except for on ONE SERVER and when we ABSOLUTELY CONTROL ACCELERATION
            //we should lock(lo) before calling this function
            protected bool ExactCompareKeys()
            {

                bool retVal = true;
                if (_keysToVerify == null || _expectedKeys == null)
                {
                    throw new Exception("Key lists were null when unexpected.");
                }

                if (_keysToVerify.Count != _expectedKeys.Count)
                {
                    throw new Exception("Returned key array length of " + _keysToVerify.Count + "was not expected length of " + _expectedKeys.Count);
                }

                if (_expectedKeys.Count != 0)
                {
                    //make sure none of the returned keys are null
                    for (int j = 0; j < _keysToVerify.Count; j++)
                    {
                        if (_keysToVerify[j] == null)
                        {
                            throw new Exception("Returned key at index " + j + " was null when not expected.");
                        }
                    }
                    for (int i = 0; i < _expectedKeys.Count; i++)
                    {
                        bool found = false;
                        for (int j = 0; j < _keysToVerify.Count; j++)
                        {
                            if (Acceleration.CompareByteArrays(_expectedKeys[i], _keysToVerify[j]))
                            {
                                found = true;
                                _keysToVerify.RemoveAt(j);
                                break;
                            }
                        }
                        if (found == false)
                        {
                            throw new Exception("Expected key at index " + i + " was not found in the returned keys.");
                        }
                    }
                    //make sure none of the returned keys are null
                    if (_keysToVerify.Count != 0)
                    {
                        throw new Exception("Found "+_keysToVerify.Count+" unexpected keys in the returned key array.");
                    }

                }
                return retVal;
            }

          //verifies that the expected keys are in the returned keys, ignores extra keys in returned keys
          public void NotificationHandler(byte[][] retKeys)
          {
               lock (lo)
               {
                   _notifHandlerCalled = true;
                   foreach (byte[] key in retKeys)
                   {
                       _keysToVerify.Add(key);
                   }
               }
               _report.Info("Notification handler called with key length " + retKeys.Length + " and expected key length " + _expectedKeys.Count);
          }

            public void FailureNotificationHandler()
            {
                _report.Error("Failure Notification Handler called when unexpected.");
            }

            public void RegisterStrictNotificationHandler(byte[][] keys)
            {
                _compareFunction = ExactCompareKeys;
                lock (lo)
                {
                    _notifHandlerCalled = false;
                }
                foreach(byte[] k in keys)
                {
                   _expectedKeys.Add(k);
                }

                _xb.RegisterNotificationHandler(NotificationHandler);
                _xb.RegisterNotificationFailureHandler(FailureNotificationHandler);
                Thread.Sleep(1000);
            }
          public void RegisterRegularNotificationHandler()
          {
              _compareFunction = RegularCompareKeys;
              lock (lo)
              {
                  _notifHandlerCalled = false;
              }
              _xb.RegisterNotificationHandler(NotificationHandler);
              _xb.RegisterNotificationFailureHandler(FailureNotificationHandler);
              System.Threading.Thread.Sleep(1000);
          }
          public void RegisterRegularNotificationHandler(byte[][] keys)
          {
              foreach(byte[] k in keys)
              {
               _expectedKeys.Add(k);
              }
              
              RegisterRegularNotificationHandler();
          }
          public void RegisterRegularNotificationHandler(byte[] key)
          {

               _expectedKeys.Add(key);
               RegisterRegularNotificationHandler();
          }
            //public override void SetupTestCase()
            //{
            //    UnregisterRegularNotificationHandler();
            //}

          public void UnregisterRegularNotificationHandler()
          {
              _xb.UnregisterHandlers();
              _expectedKeys.Clear();
              _compareFunction = null;
              lock (lo)
              {
                  _keysToVerify.Clear();
                  _notifHandlerCalled = false;
              }
          }

          public void WaitForNotificationHandlerToFire()
          {
               TimeSpan timeout = new TimeSpan(0, 0, 60); // 15 seconds
               DateTime start = DateTime.Now;
               bool done = false;
               while( !done && DateTime.Now - start < timeout)
               {
                   lock (lo)
                   {
                       if (_notifHandlerCalled)
                       {
                           done = _compareFunction();
                       }
                   }
                   Thread.Sleep(100);
               }
               if (done == false)
               {
                   throw new Exception("We did not find all the expected keys after 15 seconds.");
               }
          }

        public bool WaitForValuesToBecomeTrue(bool[] values)
        {
            TimeSpan timeout = new TimeSpan(0, 1, 0); // 1 minute
            DateTime start = DateTime.Now;
            bool done = false;
            while (DateTime.Now - start < timeout)
            {
                bool allTrue = true;
                lock (lo)
                {
                    foreach (bool b in values)
                    {
                        if (b == false)
                        {
                            allTrue = false;
                        }
                    }
                }
                if (allTrue)
                {
                    done = true;
                    break;
                }
                Thread.Sleep(50);
            }

            if (done == false)
            {
                _report.Error("All values were not true within one minute.");
                return false;
            }
            
            return true;
        }

        public bool WaitForValuesToNotBecomeTrue(bool[] values)
        {
            TimeSpan timeout = new TimeSpan(0, 0, 15); // 15 seconds
            DateTime start = DateTime.Now;
            bool anyTrue = false;
            while (DateTime.Now - start < timeout)
            {
                lock (lo)
                {
                    foreach (bool b in values)
                    {
                        if (b)
                        {
                            anyTrue = true;
                            break;
                        }
                    }
                }
                Thread.Sleep(50);
            }

            if (anyTrue)
            {
                _report.Error("A value was true within 15 seconds.");
                return false;
            }
            return true;
        }

            //creates and returns random length and random filled byte[] key and value 
          protected void CreateKeyAmountPair(out byte[] key, out ulong amount)
          {
                int prefixLength = _keyPrefix.Length;
               //create a random length (between 1-128 bytes) key filled with random values, prepended by common prefix 
               byte[] prefix = _enc.GetBytes(_keyPrefix);
               //create random postfix
               byte[] postfix = new byte[_random.Next(1,129-prefixLength)];
               _random.NextBytes(postfix);
                //combine prefix and postfix into key
               key = new byte[prefix.Length + postfix.Length];
              Array.Copy(prefix, 0, key, 0, prefixLength);
              Array.Copy(postfix,0, key , prefixLength, postfix.Length);

               //create a random amount (between 0-MAX_ULONG) 
               amount = (uint) _random.Next(0,999999999);
          }
          protected void CreateKeyAmountArrayPair(out byte[][] key, out ulong[] amount)
          {
                int length = _random.Next(1,25);
                key = new byte[length][];
                amount = new ulong[length];
                for(int i=0; i<length; i++)
                {
                    CreateKeyAmountPair(out key[i], out amount[i]);
                }
          }

          protected byte[][] CreateMaximumLengthKeysArray(int size)
          {
                byte[][] retVal = new byte[size][];
                for(int i=0; i<size; i++)
                {
                    retVal[i] = CreateKey(_maxKeyLength);
                }

                return retVal;
          }
          
             //creates a one byte key[] that maps to the same server
          protected byte[][] CreateKeyArrayThatMapsToSameServer(int numKeys)
          {
                //we need each key to map to the same server. to do this we need the bucket map.
                // first get the servers.
                string[] serverList = Config.GetServerListByInterface(Interface.acceleration);

                // now we have to make the bucket map. 
                uint numBuckets = Config.GetBucketCount(Interface.acceleration);
                int[] bucketMap = new int[numBuckets];

                for (int iBucket = 0; iBucket < numBuckets; iBucket++)
                {
                    bucketMap[iBucket] = -1;

                    IBucketServer b = Config.GetBucketServer(Interface.acceleration, (uint)iBucket);
                    // find this bucket's server in the list of servers
                    for (int iServer = 0; iServer < serverList.Length; iServer++)
                    {
                         if (b.CurrentServerName == serverList[iServer])
                         {
                              // found it.
                              bucketMap[iBucket] = iServer;
                              break;
                         }
                    }
                }

                //create the uNumValues keys that all map to same server
                byte[][] keyArray = new byte[numKeys][];
                byte keyStart= 1;
                keyArray[0] = new byte[] {1};
                for(int i=1; i<numKeys; i++)
                {
                    //make sure the rest of the keys map to the first key's server
                    keyStart++;       
                    keyArray[i] = new byte[] {keyStart};
                    while(keyStart !=1 && bucketMap[HashKeyToBucket(keyArray[i])] != bucketMap[HashKeyToBucket(keyArray[0])])
                    {
                        keyStart++;
                        keyArray[i][0] = keyStart;  
                        
                    }
                    if (keyStart == 0)
                    {
                        //not enough keys to run this test. return
                        _report.Warn("Could not find enough keys to run this test.");
                        return null;
                    }

                }
                return keyArray;
          }

           //creates a one byte key[] that maps to the same server
          protected byte[][] CreateKeyArrayThatMapsToDifferentServers(int numKeys)
          {
                // we need the bucket map.
                // first get the servers.
                string[] serverList = Config.GetServerListByInterface(Interface.acceleration);
                string[] serversWithBuckets = new string[serverList.Length];
                int serversWithBucksLength = 0;
                // now we have to make the bucket map. 
                uint numBuckets = Config.GetBucketCount(Interface.xbanc);
                int[] bucketMap = new int[numBuckets];

                for (int iBucket = 0; iBucket < numBuckets; iBucket++)
                {
                    bucketMap[iBucket] = -1;

                    IBucketServer b = Config.GetBucketServer(Interface.acceleration, (uint)iBucket);
                    // find this bucket's server in the list of servers
                    for (int iServer = 0; iServer < serverList.Length; iServer++)
                    {
                         if (b.CurrentServerName == serverList[iServer])
                         {
                              // found it.
                              bucketMap[iBucket] = iServer;
                              //but it in the serverswithbuckets array, if not already there
                              for(int i=0; i<serversWithBuckets.Length; i++)
                              {
                                    if(serversWithBuckets[i] == null)
                                    {
                                        serversWithBuckets[i] = b.CurrentServerName;
                                        serversWithBucksLength++;
                                        break;
                                    }
                                    if(serversWithBuckets[i] == b.CurrentServerName)
                                    {
                                        break;
                                    }
                              }
                              break;
                         }
                    }
                }
                    
                //create the uNumValues keys that all map to same server
                byte[][] keyArray = new byte[numKeys][];
                if (numKeys > serversWithBucksLength)
                {
                    _report.Warn("There are not enough servers to fufill this request! #Servers = "+serversWithBucksLength+", #keys requested ="+numKeys);
                    for(int i=0; i<numKeys; i++)
                    {
                        keyArray[i] = CreateKey();
                    }
                }
                else
                {
                    //try this numKeys * numberofservers
                    for(int i=0; i<numKeys; i++)
                    {
                        int tries = 0;
                        while (tries < numKeys * serversWithBucksLength * numKeys)
                        {
                            byte[] candidate = CreateKey();
                            //map key to server
                            string server = serverList[bucketMap[HashKeyToBucket(candidate)]];
                            //see if we already have this one
                            for(int j=0; j<serversWithBucksLength; j++)
                            {
                                if (serversWithBuckets[j] == server)
                                {
                                    keyArray[i] = candidate;
                                    serversWithBuckets[j] = "done";
                                    tries += numKeys * serversWithBucksLength * numKeys;
                                }
                            }
                            tries++;
                        }
                        if (keyArray[i] == null)
                        {
                            _report.Warn("Couldn't find suitable keys that mapped to different servers. returning random key.");
                            keyArray[i] = CreateKey();
                        }
                    }
                }
                
                
                return keyArray;
          }

            protected byte[][] CreateKeyArrayThatMapsToSameBucket(int numKeys, uint bucketNum)
            {
                byte[][] keyArray = new byte[numKeys][];
                byte firstDigit = 0, secondDigit = 0, thirdDigit = 0;
                bool useSecond = false, useThird = false;
                while (numKeys!=0)
                {
                    byte[] tempKey=null;
                    if (useSecond == false && useThird == false)
                         tempKey = new byte[] {firstDigit};
                    if (useSecond && useThird == false)
                        tempKey = new byte[] {firstDigit, secondDigit};
                    if (useSecond && useThird)
                        tempKey = new byte[] {firstDigit, secondDigit, thirdDigit};
                    
                    if (HashKeyToBucket(tempKey) == bucketNum)
                    {
                         keyArray[numKeys - 1] = tempKey;
                         numKeys--;
                    }
                    if (firstDigit == 255 && secondDigit == 255 && thirdDigit == 255) return null;
                    if (firstDigit == 255 && secondDigit == 255) { thirdDigit ++; useThird = true;}
                    if (firstDigit == 255) {secondDigit ++; useSecond = true;}

                    firstDigit ++;
                }
                return keyArray;
            }
           
            //creates and returns random length and random filled byte[] key and value 
            protected void CreateKeyValuePair(out byte[] key, out byte[] value)
            {
                int prefixLength = _keyPrefix.Length;
                //create a random length (between 1-128 bytes) key filled with random values, prepended by common prefix 
                byte[] prefix = _enc.GetBytes(_keyPrefix);
                //create random postfix
                byte[] postfix = new byte[_random.Next(1,129-prefixLength)];
                _random.NextBytes(postfix);
                //combine prefix and postfix into key
                key = new byte[prefix.Length + postfix.Length];
                Array.Copy(prefix, 0, key, 0, prefixLength);
                Array.Copy(postfix,0, key , prefixLength, postfix.Length);

                //create a random length (between 1-1024*1024 bytes) key filled with random values 
                value = new byte[_random.Next(1, 4096-key.Length)];
                _random.NextBytes(value);
            }

            protected void CreateKeyValueArrayPair(out byte[][] key, out byte[][] value)
            {
                int length = _random.Next(1,25);
                key = new byte[length][];
                value = new byte[length][];
                for(int i=0; i<length; i++)
                {
                    CreateKeyValuePair(out key[i], out value[i]);
                }
            }
            
            //creates and returns random length and random filled byte[] key 
            protected byte[] CreateKey()
            {
                int prefixLength = _keyPrefix.Length;
                //create a random length (between 1-128 bytes) key filled with random values, prepended by common prefix 
                byte[] prefix = _enc.GetBytes(_keyPrefix);
                //create random postfix
                byte[] postfix = new byte[_random.Next(1,129-prefixLength)];
                _random.NextBytes(postfix);
                //combine prefix and postfix into key
                byte[] key = new byte[prefix.Length + postfix.Length];
                Array.Copy(prefix, 0, key, 0, prefixLength);
                Array.Copy(postfix,0, key , prefixLength, postfix.Length);

                return key;
            }
            protected byte[] CreateKey(int size)
            {
                byte[] key;
                 //create key
                int prefixLength = _keyPrefix.Length;
                 byte[] prefix = _enc.GetBytes(_keyPrefix);
                //create random postfix
                byte[] postfix = new byte[size-prefixLength];
                _random.NextBytes(postfix);
                //combine prefix and postfix into key
                key = new byte[prefix.Length + postfix.Length];
                Array.Copy(prefix, 0, key, 0, prefixLength);
                Array.Copy(postfix,0, key , prefixLength, postfix.Length);
                
                return key;
            }
            
              //creates and returns  random length (between 1-1024*1024 bytes) key filled with random values 
            protected byte[] CreateValue()
            {
                byte[] value = new byte[_random.Next(1,64*1024)];
                _random.NextBytes(value);

                return value;
            }

            protected uint HashKeyToBucket(byte[] key)
            {
                uint sum = 0;
                for (int i = 0; i < key.Length; i++)
                {
                    sum += (uint)key[i];
                }

                return sum % 420;
            }
            
            protected void Increment(byte[] key, ulong amount)
            {
                Increment(key, amount, amount, HResult.S_FALSE);
            }
            protected void Increment(byte[][] key, ulong[] amount)
            {
                uint[] expectedHR = new uint[key.Length];
                for(int i=0; i<key.Length; i++)
                {
                    expectedHR[i] = HResult.S_FALSE;
                }
                Increment(key, amount, amount, expectedHR);
            }
            protected void Increment(byte[] key, ulong amount, ulong expectedAmount, uint expectedResult)
            {
                Increment(key, amount, AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE, 0, 0, expectedAmount, expectedResult);
            }
             protected void Increment(byte[][] key, ulong[] amount, ulong[] expectedAmount, uint[] expectedResult)
            {
                uint[] halfLifeSeconds = new uint[key.Length];
                for(int i=0; i<key.Length; i++)
                {
                    halfLifeSeconds[i] = AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE;
                }
                Increment(key, amount, halfLifeSeconds, new uint[key.Length], new uint[key.Length], expectedAmount, expectedResult);
            }
               protected void Increment(byte[] key, ulong amount, uint halfLifeSeconds, ulong expectedAmount, uint expectedResult)
            {
                Increment(key, amount, halfLifeSeconds, 0, 0, expectedAmount, expectedResult);
            }
            protected void Increment(byte[] key, ulong amount, uint halfLifeSeconds, uint abs, uint slid, ulong expectedAmount, uint expectedResult)
            {
                uint hr;
                ulong result;
                RegisterRegularNotificationHandler(key);
                hr = _xb.Increment(key, amount, halfLifeSeconds, abs, slid, out result);
                if (hr != expectedResult)
                {
                    throw new HResultException(hr, "Increment returned "+hr+" instead of "+expectedResult);
                }
                ValidateReturnedDecayData(expectedAmount, result, 0.15);  // within 15% is fine, since acceleration slows down the increment time
                WaitForNotificationHandlerToFire();
                UnregisterRegularNotificationHandler();
                       
            }
            protected void Increment(byte[][] key, ulong[] amount, uint[] halfLifeSeconds, uint[] abs, uint[] slid, ulong[] expectedAmount, uint[] expectedResult)
            {
                uint[] hr;
                ulong[] result;
                bool waitForHandler = true;
                List<byte[]> keys = new List<byte[]>();
                RegisterRegularNotificationHandler(key);
                hr = _xb.Increment(key, amount, halfLifeSeconds, abs, slid, out result);
                if (hr == null || hr.Length != key.Length)
                {
                    throw new Exception("Increment returned unexpected HResult array");
                }
                
                ValidateReturnedDecayData(expectedAmount, result, 0.05);  // within 5% is fine
                
                for (int i = 0; i < hr.Length; i++)
                {
                    if (hr[i] != expectedResult[i])
                    {
                        throw new HResultException(hr[i], "Increment returned " + hr[i] + " instead of " + expectedResult[i]);
                    }
                    if (hr[i] == HResult.S_OK)
                    {
                        waitForHandler = true;
                        keys.Add(key[i]);
                    }
                }
                if (waitForHandler)
                {
                    _expectedKeys.Clear();
                    for (int i = 0; i < keys.Count; i++)
                    {
                        _expectedKeys.Add(keys[i]);
                    }
                    WaitForNotificationHandlerToFire();
                }
                UnregisterRegularNotificationHandler();
                       
            }
             
            protected void InsertSingleItem(byte[] key, byte[] value)
            {
                InsertSingleItem(key, value, 0, 0);
            }

            //inserts and queries for item for the Simple Test cases then removes the item, returns result of query
            protected void InsertSingleItem(byte[] key, byte[] value, uint abs, uint slid)
            {
                InsertMultipleItems(new byte[][] {key}, new byte[][] {value}, new uint[] {abs}, new uint[] {slid});
            }

            protected void InsertMultipleItems(byte[][] key, byte[][] value)
            {
                InsertMultipleItems(key, value, new uint[key.Length], new uint[key.Length]);
            }

            //inserts and queries for item for the Simple Test cases then removes the item, returns result of query
            protected void InsertMultipleItems(byte[][] key, byte[][] value, uint[] abs, uint[] slid)
            {
                uint[] hr;       
                byte[][] outvalue = null;
                uint[] outseconds = null;


                //call query to make reservations
                hr = _xb.Query(key, out outvalue, out outseconds);
                if(hr == null)
                {
                    throw new Exception("Query returned results were null when not expected.");                     
                }
                for(int i=0; i< hr.Length; i++)
                {
                    if (hr[i] != HResult.S_FALSE)
                    {
                        throw new HResultException(hr[i], "Query returned "+hr[i]+" instead of S_FALSE for the "+i+"th key.");
                    }
                }

                //call insert to put the values in the cache
                RegisterRegularNotificationHandler(key);
                hr = _xb.Insert(key, value, abs, slid);
                if(hr == null)
                {
                    throw new Exception("Insert returned results were null when not expected.");                     
                }
                for(int i=0; i< hr.Length; i++)
                {
                    if (hr[i] != HResult.S_OK)
                    {
                        throw new HResultException(hr[i], "Insert returned "+hr[i]+" instead of S_OK for the "+i+"th key.");
                    }
                }

                WaitForNotificationHandlerToFire();
                UnregisterRegularNotificationHandler();

                //call query to check/return the values
                hr = _xb.Query(key, out outvalue, out outseconds);
                if(hr == null)
                {
                    throw new Exception("Query returned results were null when not expected.");                     
                }
                for(int i=0; i< hr.Length; i++)
                {
                    if (hr[i] != HResult.S_OK)
                    {
                        throw new HResultException(hr[i], "Query returned "+hr[i]+" instead of S_OK for the "+i+"th key.");
                    }
                }

                ValidateReturnedData(value, outvalue);
            }
            protected void RemoveTestHelper(string[] keys, string keyToRemove, string[] keysToCheck, bool matchExact, uint expectedResults)
            {
                if (matchExact == false)
                {
                    throw new Exception("Bulk remove is not supported in Acceleration.");  
                }
                uint hr;
                byte[] value = CreateValue();
                //insert barage of keys
                foreach (string key in keys)
                {
                    byte[] b = _enc.GetBytes(key);
                    InsertSingleItem(b, value);
                }
                //remove sKeyToRemove
                if (expectedResults == HResult.S_OK)
	        	{
					RegisterRegularNotificationHandler(_enc.GetBytes(keyToRemove));
	        	}
                hr = _xb.Remove(_enc.GetBytes(keyToRemove), matchExact);
                if (hr != expectedResults)
                {
                    throw new HResultException(hr, "Remove returned "+hr+" instead of "+expectedResults);
                }
				if (expectedResults == HResult.S_OK)
				{
	                WaitForNotificationHandlerToFire();
	                UnregisterRegularNotificationHandler();
				}

                //Query for SKeyToRemove, leave the reservation, should return nothing
                Query(_enc.GetBytes(keyToRemove), null, HResult.S_FALSE);

                foreach (string key in keysToCheck)
                {
                    byte[] b = _enc.GetBytes(key);
                    Query(b, value, HResult.S_OK);

                    Remove(b);
                }

            }

            protected void SetData(byte[] key, byte[] value)
            {
                SetData(key, value, 0, 0);
            }

            protected void SetData(byte[] key, byte[] value, uint abs, uint slid)
            {
                uint hr;       
                byte[] outvalue = null;
				RegisterRegularNotificationHandler(key);             
                //call insert to put the value in the cache
                hr = _xb.SetData(key, value, abs, slid);
                if (hr != HResult.S_OK)
                {
                    throw new HResultException(hr, "SetData returned " + hr + " instead of S_OK.");
                }

				WaitForNotificationHandlerToFire();
				UnregisterRegularNotificationHandler();
				

                //call query to check/return the value
                hr = _xb.Query(key,  out outvalue);
                if (hr != HResult.S_OK)
                {
                    throw new HResultException(hr, "Query returned "+hr+" instead of S_OK.");
                }

                ValidateReturnedData(value, outvalue);
            }

            protected void SetData(byte[][] key, byte[][] value)
            {
                SetData(key, value, new uint[key.Length], new uint[value.Length]);
            }

            protected void SetData(byte[][] key, byte[][] value, uint[] abs, uint[] slid)
            {
                uint[] hr;       
                byte[][] outvalue = null;
                uint[] seconds;
				RegisterRegularNotificationHandler(key);             
             
                //call insert to put the value in the cache
                hr = _xb.SetData(key, value, abs, slid);
                if(hr == null || hr.Length !=key.Length)
                {
                    throw new Exception("SetData returned HR results were null when not expected.");                     
                }
                foreach(uint h in hr)
                {
                    if (h != HResult.S_OK)
                    {
                        throw new HResultException(h, "SetData returned "+h+" instead of S_OK.");
                    }
                }
				WaitForNotificationHandlerToFire();
				UnregisterRegularNotificationHandler();
				

                //call query to check/return the value
                hr = _xb.Query(key,  out outvalue, out seconds);
                if(hr == null || hr.Length !=key.Length)
                {
                    throw new Exception("Query returned HR results were null when not expected.");                     
                }
                foreach(uint h in hr)
                {
                    if (h != HResult.S_OK)
                    {
                        throw new HResultException(h, "Query returned "+h+" instead of S_OK.");
                    }
                }
                for(int i=0; i<value.Length; i++)
                {
                    ValidateReturnedData(value[i], outvalue[i]);
                }
            }

 //SequenceTestHelper goes through each string passed in functions and performs the function, comparing the result with the corresponding expectedValue
            protected void SequenceTestHelper(string[] functions, uint[] expectedValues)
            {
               uint hr;
               //each sequence will use the same key and value
               byte[] key = null;
               byte[] value = null;
               CreateKeyValuePair(out key, out value);
               
               for (int i=0; i<functions.Length; i++)
               {
                    switch(functions[i])
                    {
                         case "Query":
                              Query(key, value, expectedValues[i]);
                              break;
                              
                         case "Insert":
                              hr = _xb.Insert(key, value);
                              if (hr != expectedValues[i])
                              {
                                    throw new HResultException(hr, "Insert returned "+hr+" instead of "+expectedValues[i]);
                              }
                              break;

                         case "Remove":
                              hr = _xb.Remove(key);
                              if (hr != expectedValues[i])
                              {
                                   throw new HResultException(hr, "Remove returned "+hr+" instead of "+expectedValues[i]);
                              }
                              break;

                         case "SetData":
                              hr = _xb.SetData(key,value,0,0);
                              if (hr != expectedValues[i])
                              {
                                   throw new HResultException(hr, "SetData returned "+hr+" instead of "+expectedValues[i]);
                              }
                              break;
                                   
                    }
               }
          }


            //return a string representation of the passed in byte array
            protected string PrintByteArray(byte[] b)
            {
               if (b.Length == 0) return "";

               string sRet = "";
               for (int i = 0; i < b.Length - 1; i++)
               {
                 sRet += b[i].ToString() + ",";
               }
               sRet += b[b.Length - 1].ToString();
               return sRet;
            }

            protected void QueryCheckTime(byte[] key, byte[] expectedValue, uint expectedSeconds, uint expectedResults)
            {
                uint hr;
                byte[] outvalue;
                uint outtime;
                hr = _xb.Query(key,  out outvalue, out outtime);
                if (hr != expectedResults)
                {
                    throw new HResultException(hr, "Query returned "+hr+" instead of "+expectedResults);
                }
                if (expectedValue != null && expectedResults == HResult.S_OK)
                {
                    ValidateReturnedData(expectedValue, outvalue);
                }
                
                ValidateReturnedTime(expectedSeconds, outtime);
            }
            protected void QueryCheckTime(byte[][] key, byte[][] expectedValues, uint[] expectedSeconds, uint[] expectedResults)
            {
                uint[] hr;
                byte[][] outvalue;
                uint[] outtime;
                hr = _xb.Query(key,  out outvalue, out outtime);
                 if(hr == null || hr.Length != expectedResults.Length)
                {
                    throw new Exception("Query returned results were null when not expected.");                     
                }
                for(int i=0; i< hr.Length; i++)
                {
                    if (hr[i] != expectedResults[i])
                    {
                        throw new HResultException(hr[i], "Query returned "+hr[i]+" instead of "+expectedResults[i]+" for the "+i+"th key.");
                    }
                }
                if (expectedValues != null && outvalue != null)
                {
                     for(int i=0; i< expectedValues.Length; i++)
                    {
                        if(expectedResults[i] == HResult.S_OK)
                        {
                            ValidateReturnedData(expectedValues[i], outvalue[i]);
                        }
                        
                    }
                }
                for(int i=0; i<expectedSeconds.Length; i++)
                {
                    ValidateReturnedTime(expectedSeconds[i], outtime[i]);
                }
                
                
            }

             protected void Query(byte[] key, byte[] expectedValue, uint expectedResults)
            {
                uint hr;
                byte[] outvalue;
                hr = _xb.Query(key,  out outvalue);
                if (hr != expectedResults)
                {
                    throw new HResultException(hr, "Query returned "+hr+" instead of "+expectedResults);
                }
                if (expectedValue != null && expectedResults == HResult.S_OK)
                {
                    ValidateReturnedData(expectedValue, outvalue);
                }
            }

            protected void Query(byte[][] key, byte[][] expectedValues, uint[] expectedResults)
            {
                uint[] hr;
                byte[][] outvalue;
                uint[] outseconds = null;
                hr = _xb.Query(key,  out outvalue, out outseconds);
                if(hr == null || hr.Length !=expectedResults.Length)
                {
                    throw new Exception("Query returned results were null when not expected.");                     
                }
                for(int i=0; i< hr.Length; i++)
                {
                    if (hr[i] != expectedResults[i])
                    {
                        throw new HResultException(hr[i], "Query returned "+hr[i]+" instead of "+expectedResults[i]+" for the "+i+"th key.");
                    }
                }
                if (expectedValues != null && outvalue != null)
                {
                     for(int i=0; i< expectedValues.Length; i++)
                    {
                        if(expectedResults[i] == HResult.S_OK)
                        {
                            ValidateReturnedData(expectedValues[i], outvalue[i]);
                        }
                    }
                }
            }

            protected void Remove(string[] strings)
            {
                byte[][] keys = new byte[strings.Length][];
                for(int i=0; i<strings.Length; i++)
                {
                    keys[i] = _enc.GetBytes(strings[i]);
                }
                
                Remove(keys);
            }
            protected void Remove(string key)
            {
                Remove(new string[] {key});
            }


            protected void Remove(byte[] key)
            {
               Remove(key, true);
            }

             protected void Remove(byte[] key, bool matchExact)
            {
                if (matchExact == false)
                {
                    throw new Exception("Bulk remove is not supported in Acceleration");
                }
                uint hr;
                RegisterRegularNotificationHandler(key);
                hr = _xb.Remove(key, matchExact);
                if (hr != HResult.S_OK)
                {
                    throw new HResultException(hr, "Remove returned "+hr+" instead of S_OK.");
                }
				WaitForNotificationHandlerToFire();
				UnregisterRegularNotificationHandler();
				
            }
            
            protected void Remove(byte[][] key)
            {
                uint[] hr;
                bool waitForHandler = false;
                RegisterRegularNotificationHandler(key);
                hr = _xb.Remove(key);
                if(hr == null)
                {
                    throw new Exception("Remove returned results were null when not expected.");                     
                }
                foreach(uint h in hr)
                {
                    if (h == HResult.S_OK)
                    {
                        waitForHandler = true;
                    }
                    if (HResult.Failed(h))
                    {
                        throw new HResultException(h, "Remove returned "+h+" instead of S_OK or S_FALSE.");
                    }
                }

                if (waitForHandler)
                {
                    WaitForNotificationHandlerToFire();
                }
                UnregisterRegularNotificationHandler();
            }

            protected void ValidateHResult(uint hrGot, uint hrExpected)
            {
                if (hrGot != hrExpected)
                {
                    throw new HResultException(hrGot, "Acceleration method returned "+hrGot+" instead of "+hrExpected);
                }
            }

            protected void ValidateVersion(uint got, uint expected)
            {
                if (got != expected)
                {
                    throw new Exception("Version "+got+" does not equal "+expected);
                }
            }

            protected void ValidateReturnedData(byte[] value, byte[] outValue)
            {
                Assert.IsTrue(Acceleration.CompareByteArrays(value, outValue), "Returned value was not expected");
            }
            
            protected void ValidateReturnedData(ulong value, ulong outValue)
            {
                Assert.IsTrue(value == outValue, "Returned Increment value was not expected");
            }

            protected void ValidateReturnedDecayData(ulong value, ulong outValue, double tolerance)
            {
                _report.Debug("ValidateReturnedData[ulong]: Expecting {0}, got {1}, +/-{2}%", value, outValue, tolerance * 100);
                ulong diff = (ulong)Math.Abs((float)(value - outValue));
                ulong bumper = (ulong)(value * tolerance);
                Assert.IsTrue(diff <= bumper, "Returned Increment value was not expected (outside tolerance)");
            }
            
            protected void ValidateReturnedDecayData(ulong[] value, ulong[] outValue, double tolerance)
            {
                Assert.IsTrue(value.Length == outValue.Length, "Returned values were not expected");
                for(int i=0; i<value.Length; i++)
                {
                    ValidateReturnedDecayData(value[i], outValue[i], tolerance);
                }
            }
              protected void ValidateReturnedData(byte[][] value, byte[][] outValue)
            {
                Assert.IsTrue(value.Length == outValue.Length, "Returned values were not expected");
                for(int i=0; i<value.Length; i++)
                {
                    ValidateReturnedData(value[i], outValue[i]);
                }
            }

            protected void ValidateReturnedTime(uint expectedSeconds, uint outtime)
            {
                Assert.IsTrue(WithinTolerableRange(expectedSeconds,outtime), "Returned time "+outtime+" was not expected time of "+expectedSeconds);
            }

             //returns true if seconds is within one second of expected second
            protected bool WithinTolerableRange(uint seconds, uint expectedSeconds)
            {
                //tolerable range.
                int tol = 3;
                return (Math.Abs((int)seconds - (int)expectedSeconds) <= tol);
            }

            protected void RunIncrementWithDelayTps(uint halflifeSeconds, double tps, uint secondsToRun)
            {
                byte[] key = null;
                ulong amount = 0;
                ulong result;

                ulong incAmount = 1;
                double periodSeconds = 1.0 / tps;

                CreateKeyAmountPair(out key, out amount);

                // Start at 1.. large values won't catch rounding errors as easily
                amount = 1;
                Increment(key, amount);

                double newAmount = amount;
                for(int i=0; i < secondsToRun * tps; i++)
                {
                    DateTime now = DateTime.Now;
                    System.Threading.Thread.Sleep((int)(periodSeconds * 1000));                   
                    // custom increment call and verification
                    uint hr = _xb.Increment(key, incAmount, halflifeSeconds, 0, 0, out result);
                    
                    double secondsPassed = (DateTime.Now - now).TotalSeconds;
                    //compute new amount
                    newAmount = incAmount + newAmount * Math.Pow(2, -secondsPassed / (double)halflifeSeconds);

                    if (hr != HResult.S_OK)
                    {
                        throw new HResultException(hr, "Increment returned "+hr+" instead of 0");
                    }

                    _report.Debug("Expecting {0} ({1}), got {2}", (ulong)newAmount, newAmount, result);
                    if (result != (ulong)newAmount)
                    {
                        if (Math.Abs((float)((ulong)newAmount - result)) <= 2)
                        {
                            _report.Debug("Off by one or two (ok)");
                        }
                        else
                        {
                            Assert.IsTrue(result == (ulong)newAmount, "Returned Increment value was not expected");
                        }
                    }
                }

                //remove for cleanup
                Remove(key);
                ResultCode = TEST_RESULTS.PASSED;
            }



        }
        /*
          override public StressTestBaseList GetStressTests()
          {
          StressTestBaseList tests = new StressTestBaseList();
          tests.Add(typeof(AccelStressInsertSmallValue),6);
          tests.Add(typeof(AccelStressInsertMediumValue),4);
          tests.Add(typeof(AccelStressInsertLargeValue),3);
          tests.Add(typeof(AccelStressSetDataSmallValue),8);
          tests.Add(typeof(AccelStressSetDataMediumValue),2);
          tests.Add(typeof(AccelStressSetDataLargeValue),1);
          tests.Add(typeof(AccelStressSetDataExistingKey),4);
          tests.Add(typeof(AccelStressQueryForSmallValue),11);
          tests.Add(typeof(AccelStressQueryForMediumValue),8);
          tests.Add(typeof(AccelStressQueryForLargeValue),8);
          tests.Add(typeof(AccelStressQueryForExpiredKey),8);
          tests.Add(typeof(AccelStressQueryForNonExpiredValue),10);
          tests.Add(typeof(AccelStressIncrementCreateNew),10);
          tests.Add(typeof(AccelStressIncrementExisting),10);
          tests.Add(typeof(AccelStressRemoveOneValue),2);
          tests.Add(typeof(AccelStressRemovePrefix),1);
          tests.Add(typeof(AccelStressInsertExisitingKey),2);
          tests.Add(typeof(AccelStressQueryNonExisitingKey),2);
          tests.Add(typeof(AccelStressRemoveNonExisitingKey),2);

          return tests;
          }


          }*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\common\AuthCommon.cs ===
namespace xonline.server.activeauth.common
{
    public class AuthCommon
    {
        public static readonly string ACTIVEAUTH_POLICY_IDKEY = "ActiveAuthApiPolicyId";
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\acceleration\Test\AccelStressManager.cs ===
using System;
using System.Collections.Generic;
using System.Collections;
using System.Diagnostics;
using System.Text;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Core.Utilities;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;



namespace AccelTest
{
     //this class keeps track of active keys, values so that stress on XBANC can be run successfully and meaningfully
     public class AccelStressManager 
     {
          private static Report _report = new Report("Log");
          
          //these variables keep track of value sizes to make querying for different types of values much easier (also use for other small things)
          private static byte[][] _bpValueList = new byte[30][];
          private static byte[][] _rpValueList = new byte[30][];
          private static byte[][] _flValueList = new byte[30][];
          private static byte[][] _ciValueList = new byte[30][];

          public static byte[][] _basicPresenceKeys = null;
          public static byte[][] _richPresenceKeys = null;
          public static byte[][] _friendsListKeys = null;
          public static byte[][] _connInfoKeys = null;
          public static byte[][] _keyList = null;
          public static byte[][] _keyListBucket219 = null;
          private static RandomEx _random = new RandomEx();

        public static byte[][] _altData = new byte[5][];
         
          //Settings to be read in from the XBANCTest.xml file upon AccelStressManager.Initialize()
          private static string _LITEPrefix = "LITEPrefix";
    

          public AccelStressManager() 
          {
          }

           //creates a one byte key[] that maps to the same server
          private static byte[][] CreateKeyArrayThatMapsToSameServer(int numKeys, int serverIndex, int[] bucketMap)
          {
                AccelStressManager xbsm = new AccelStressManager();                   
               //create the uNumValues keys that all map to same server
                byte[][] keyArray = new byte[numKeys][];
                for(int i=0; i<numKeys; i++)
                {
                    //make sure the rest of the keys map to the first key's server
                    byte[] possibleKey = xbsm.GetNewKeyLITE();
                    while(bucketMap[HashKeyToBucket(possibleKey) ] != serverIndex)
                    {
                        possibleKey = xbsm.GetNewKeyLITE();                            
                    }
                    keyArray[i] = possibleKey;
                }
                return keyArray;
          }
          private byte[] GetKeyThatMapsToBucket(int bucketNum)
           {
                byte[] possibleKey = GetNewKeyLITE();
                while(AccelStressManager.HashKeyToBucket(possibleKey)  != bucketNum)
                {
                    possibleKey = GetNewKeyLITE();                            
                }
                return possibleKey;
           }

            public static void AltInitialize()
            {
                Global.RO.Error("Alt Initialization");

                _altData[0] = new byte[5];
                _random.NextBytes(_altData[0]);

                _altData[1] = new byte[50];
                _random.NextBytes(_altData[1]);

                _altData[2] = new byte[100];
                _random.NextBytes(_altData[2]);

                _altData[3] = new byte[500];
                _random.NextBytes(_altData[3]);

                _altData[4] = new byte[1000];
                _random.NextBytes(_altData[4]);
            }

            public byte[] AltGetRandomKey()
            {
                //generate from list of prefixs with the length between the lowestkeysize and smallkeysize settings
                ASCIIEncoding enc = new ASCIIEncoding();
                int iPrefixLength = _LITEPrefix.Length;
                int iPostfixLength = 0;
                byte[] rgbRetVal = null;
                byte[] rgbPrefix = enc.GetBytes(_LITEPrefix);

                //generate a random postfix
                byte[] rgbPostfix = BitConverter.GetBytes(_random.Next(100000000));
                iPostfixLength = rgbPostfix.Length;

                //combine cosmic powers!(prefix & postfix)
                rgbRetVal = new byte[iPrefixLength + iPostfixLength];
                Array.Copy(rgbPrefix, 0, rgbRetVal, 0, iPrefixLength);
                Array.Copy(rgbPostfix, 0, rgbRetVal, iPrefixLength, iPostfixLength);

                return rgbRetVal;
            }

            public byte[] AltGetRandomData()
            {
                int val = _random.Next(5);
                switch(val)
                {
                    case 0:
                        return _altData[0];

                    case 1:
                        return _altData[1];

                    case 2:
                        return _altData[2];

                    case 3:
                        return _altData[3];

                    case 4:
                        return _altData[4];
                }

                return null;
            }

          //read settings from xml file, make bucket map using Config
          //returns -1 if no xml settings file found
          public static int Initialize(XmlDocument config)
          {
               int retval = 0;
               XmlNode StressSettings = config.SelectSingleNode("descendant::AccelTest");
               _report.Error("Beginning Initialization, this should take a few minutes");
               Acceleration ac = new Acceleration(Interface.acceleration);
               if (StressSettings == null) 
               {
                    //no xml file found, use default settings
                    _LITEPrefix = "LITEPrefix";
                     retval = -1;
               }
               else
               {
                    //read in the settings from the xml file
                    _LITEPrefix = StressSettings.SelectSingleNode("LITEPrefix").InnerXml;
               }

              //setup the random values
               for (int i = 0; i < _bpValueList.Length; i++)
               {
                   byte[] temp = new byte[56];
                   _random.NextBytes(temp);
                   _bpValueList[i] = temp;
               }
               for (int i = 0; i < _rpValueList.Length; i++)
               {
                   byte[] temp = new byte[_random.Next(20, 1801)];
                   _random.NextBytes(temp);
                   _rpValueList[i] = temp;
               }
               for (int i = 0; i < _flValueList.Length; i++)
               {
                   byte[] temp = new byte[_random.Next(10, 1201)];
                   _random.NextBytes(temp);
                   _flValueList[i] = temp;
               }
               for (int i = 0; i < _ciValueList.Length; i++)
               {
                   byte[] temp = new byte[50];
                   _random.NextBytes(temp);
                   _ciValueList[i] = temp;
               }

               int numKeys = 10;//3000;
               _basicPresenceKeys = new byte[numKeys][];
               _richPresenceKeys = new byte[numKeys][];
               _friendsListKeys = new byte[numKeys][];
               _connInfoKeys = new byte[numKeys][];
            
               //now we create the keys, each server will have numberofkeysperserver that map a value to it
               _keyList = new byte[420][];
               AccelStressManager xbsm = new AccelStressManager();
               for (int i = 0; i < 420; i++)
               {
                   _keyList[i] = xbsm.GetKeyThatMapsToBucket(i);

               }

                //spread out the keys evenly
               for (int i = 0; i < numKeys; i++)
               {
                   _basicPresenceKeys[i] = xbsm.GetKeyThatMapsToBucket(i % 420);
                   _richPresenceKeys[i] = xbsm.GetKeyThatMapsToBucket(i % 420);
                   _friendsListKeys[i] = xbsm.GetKeyThatMapsToBucket(i % 420);
                   _connInfoKeys[i] = xbsm.GetKeyThatMapsToBucket(i % 420);

                   ac.SetData(_basicPresenceKeys[i], xbsm.GetRandomBasicPresenceData(), 0, 0);
                   ac.SetData(_richPresenceKeys[i], xbsm.GetRandomRichPresenceData(), 0, 0);
                   ac.SetData(_friendsListKeys[i], xbsm.GetRandomFriendsListData(), 0, 0);
                   ac.SetData(_connInfoKeys[i], xbsm.GetRandomConnInfoData(), 0, 0);
               }
               
               _keyListBucket219 = new byte[100][];
               for(int i=0; i<100; i++)
               {
                    _keyListBucket219[i] = xbsm.GetKeyThatMapsToBucket(219);
               }

               _report.Error("Initialization Done!");


            AltInitialize();


               return retval;
          }

            public byte[] GetBasicPresenceKey()
            {
              int index = _random.Next(0, _basicPresenceKeys.Length);
              return _basicPresenceKeys[index];
            }
            public byte[] GetRichPresenceKey()
            {
              int index = _random.Next(0, _richPresenceKeys.Length);
              return _richPresenceKeys[index];
            }
            public byte[] GetFriendsListKey()
            {
              int index = _random.Next(0, _friendsListKeys.Length);
              return _friendsListKeys[index];
            }
            public byte[] GetConnInfoKey()
            {
              int index = _random.Next(0, _connInfoKeys.Length);
              return _connInfoKeys[index];
            }
         

            public byte[] GetRandomBasicPresenceData()
            {
                int index = _random.Next(0, _bpValueList.Length);
                return _bpValueList[index];
            }
            public byte[] GetRandomRichPresenceData()
            {
                int index = _random.Next(0, _rpValueList.Length);
                return _rpValueList[index];
            }
            public byte[] GetRandomFriendsListData()
            {
                int index = _random.Next(0, _flValueList.Length);
                return _flValueList[index];
            }
            public byte[] GetRandomConnInfoData()
            {
                int index = _random.Next(0, _ciValueList.Length);
                return _ciValueList[index];
            }

          //this function is used by the LITE stress version to generate random keys with a common prefix
           public byte[] GetNewKeyLITE()
          {    
               //generate from list of prefixs with the length between the lowestkeysize and smallkeysize settings
               ASCIIEncoding enc = new ASCIIEncoding();
               int iPrefixLength = _LITEPrefix.Length;
               int iPostfixLength = 0; 
               byte[] rgbRetVal = null;
               byte[] rgbPrefix = enc.GetBytes(_LITEPrefix);

               //generate a random postfix
              
               //pick postfix size
               iPostfixLength = _random.Next(iPrefixLength+1, 128-iPrefixLength+1);
               byte[] rgbPostfix = new byte[iPostfixLength];
               //fill postfix with random bytes
               _random.NextBytes(rgbPostfix);

               //combine cosmic powers!(prefix & postfix)
               rgbRetVal = new byte[iPrefixLength + iPostfixLength];
               Array.Copy(rgbPrefix, 0, rgbRetVal, 0, iPrefixLength);
               Array.Copy(rgbPostfix,0, rgbRetVal , iPrefixLength, iPostfixLength);
               
               return rgbRetVal;
          }

          

          //*** Yanked from AccelerationProxy.cs ****//
          //Hashes a key to a bucket number according to the hash function found in xbancproxy
          private static uint HashKeyToBucket(byte[] key)
          {
               uint sum = 0;
               for (int i = 0; i < key.Length; i++)
               {
                     sum += (uint)key[i];
               }

               return sum % Config.GetBucketCount(Interface.acceleration);
          }
          private static bool IsServerIndexInBucketMap(int index, int[] bucketMap)
          {
                for(int i=0; i<bucketMap.Length; i++)
                {
                    if (bucketMap[i] == index) return true;
                }
                return false;
          }
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\common\AuthConfig.cs ===
using System;
using System.IO;
using System.Web;
using System.Configuration;
using System.Reflection;
using System.Collections.Specialized;

namespace xonline.server.activeauth.common
{
    public static class AuthConfig
    {
        public static readonly string ActiveAuthConfigInstanceKey = "AuthSGInstance";
        public static readonly string MaxConcurrentConnectionsKey = "MaxConcurrentConnections";
        public static readonly string EnableRequestPipeliningKey = "EnableRequestPipelining";
        public static readonly string ApplicationSettingsFileName = "authsgsettings.xml";
        public static readonly string ApplicationSettingsSectionName = "appSettings";

        private static string GetStringConfigValue(string configKey)
        {
            NameValueCollection appSettings = ConfigurationManager.AppSettings;
            return appSettings[configKey];
        }

        private static string GetStringConfigValueFromExeContext(string configKey)
        {
            //Try to load the configuration file by explicitly specifying the path; necessary
            //if a loaded web assembly (e.g. called by installutil) needs to access local configuration
            //and is not running in an IIS application pool. Don't bother caching since this will only
            //occur on install / uninstall and not in normal operation (for gateway or aamodule)

            NameValueCollection appSettings = GetAppSettingsFromSettingsFile();
            return appSettings[configKey];
        }

        private static string GetValidatedStringConfigValue(string configKey, string value)
        {
            if (String.IsNullOrEmpty(value))
            {
                throw new ConfigurationErrorsException(
                    String.Format("Auth SG config setting [{0}] cannot be null or empty", configKey));
            }

            return value;
        }

        private static bool GetValidatedBoolConfigValue(string configKey, string value)
        {
            bool retval;
            if (String.IsNullOrEmpty(value) || !bool.TryParse(value, out retval))
            {
                throw new ConfigurationErrorsException(
                    String.Format("Auth SG config setting [{0}] must be 'true' or 'false'", configKey));
            }
            
            return retval;
        }

        private static int GetValidatedIntConfigValue(string configKey, string value)
        {
            int retval;
            if (String.IsNullOrEmpty(value) || !int.TryParse(value, out retval) || retval < 0)
            {
                throw new ConfigurationErrorsException(
                    String.Format("Auth SG config setting [{0}] must be a non-negative integer", configKey));
            }
            
            return retval;
        }
        
        private static NameValueCollection GetAppSettingsFromSettingsFile()
        {
                string assemblyPath = System.Reflection.Assembly.GetExecutingAssembly().Location;
                FileInfo assemblyFileInfo = new FileInfo(assemblyPath);
                
                //The path to web.config will be the parent directory for the currently executing assembly
                //since the install lays out the assemblies in vdir\bin\
                DirectoryInfo webApplicationDir = assemblyFileInfo.Directory.Parent;

                if (webApplicationDir == null)
                {
                    //unexpected -- we are executing in an environment with an unsupported file layout
                    throw new ConfigurationErrorsException("Unsupported file layout in current environment: Auth SG instance name not found");
                }

                try
                {
                    Configuration defaultConfig = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);
                    AppSettingsSection appSettingsSection = defaultConfig.AppSettings;
                    appSettingsSection.File = Path.Combine(webApplicationDir.FullName, ApplicationSettingsFileName);
                    
                    // Save the default configuration file and refresh.
                    defaultConfig.Save(ConfigurationSaveMode.Modified);
                    ConfigurationManager.RefreshSection(ApplicationSettingsSectionName);

                    return ConfigurationManager.AppSettings;
                }
                catch (ConfigurationException ex)
                {
                    throw new ConfigurationErrorsException("Auth SG instance name not found", ex);
                }
        }

        //Call this from a web application / health checks
        public static string InstanceName
        {
            get
            {
                string instanceName = AuthConfig.GetStringConfigValue(AuthConfig.ActiveAuthConfigInstanceKey);
                return GetValidatedStringConfigValue(AuthConfig.ActiveAuthConfigInstanceKey, instanceName);
            }
        }

        //Only call this for installers or code loading the assembly outside an IIS hosted environment
        public static string InstanceNameInInstallerContext
        {
            get
            {
                string instanceName = AuthConfig.GetStringConfigValueFromExeContext(AuthConfig.ActiveAuthConfigInstanceKey);
                return GetValidatedStringConfigValue(AuthConfig.ActiveAuthConfigInstanceKey, instanceName);
            }
        }

        public static bool EnableRequestPipelining
        {
            get
            {
                string flag = AuthConfig.GetStringConfigValue(AuthConfig.EnableRequestPipeliningKey);
                return GetValidatedBoolConfigValue(AuthConfig.EnableRequestPipeliningKey, flag);
            }
        }
        
        public static int MaxConcurrentConnections
        {
            get
            {
                string flag = AuthConfig.GetStringConfigValue(AuthConfig.MaxConcurrentConnectionsKey);
                return GetValidatedIntConfigValue(AuthConfig.MaxConcurrentConnectionsKey, flag);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\common\AuthPolicy.cs ===
// 
// AuthPolicy.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Active Auth Module
// Xbox Online Service
//
// Policy class. Handles flow of request and checks.
//
// Author: kgoodier 6/2007
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Web;
using System.Data;
using System.Data.SqlClient;

using System.Security.Cryptography.X509Certificates;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.activeauth.common
{
     [Flags]
    internal enum ActiveAuthMethod
    {
        NOTSPECIFIED      = 0x00,
        NONE              = 0x01,
        WLID10            = 0x02,
        XBL10             = 0x04,
        XBL20             = 0x08,
        X509WP            = 0x10,
        X509MUTUAL        = 0x20,
        X509TRUSTEDMUTUAL = 0x40,
        UNKNOWN           = 0x40000000
    }

    // -----------------------------------------------------------------------------------
    // ApiPolicy class holds information about the policy required for a request to a specific 
    // api.
    // -----------------------------------------------------------------------------------
    internal class ApiPolicy
    {
        // 
        // Properties
        //

        // Is this policy OK to use?
        public bool IsValid
        {
            get { return _PolicyIdKey != null; }
        }

        // Is this a Regex policy?
        public bool IsRegexPolicy
        {
            get { return null != _PolicyRegex; }
        }

        // The parsed URL key provided by the application. This is how we look up a policy.
        public string PolicyIdKey
        {
            get { return _PolicyIdKey; }
        }

        public Regex PolicyRegex
        {
            get { return _PolicyRegex; }
        }

        // Does this api require authentication? That means it needs a Passport ticket and 
        // needs the PUID in the ActiveAuthInfo.
        public bool RequiresAuthentication
        {
            get { return _RequiresAuthentication; }
        }

        // What level of authentication does this api need? This should be "LBI", "MBI", or 
        // "HBI", for instance.
        public string AuthenticationPolicy
        {
            get { return _AuthenticationPolicy; }
        }

        // What type of Authorization Header is required
        // Currently "XBL1.0" is the only special case.  "WLID1.0" is the default when Authentication is required.
        // Others could be supported in the future.
        public string AuthorizationHeader
        {
            get { return _AuthorizationHeader; }
        }

        // Does this api require SSL between the client & module?
        public bool RequiresSsl
        {
            get { return _RequiresSsl; }
        }

        // Does this api need anti-dos checks?
        public bool AntiDosEnabled
        {
            get { return _AntiDosEnabled; }
        }

        // Does this api require a WP ClientCert? Only applies when authentication is required.
        public bool RequiresWPClientCert
        {
            get { return _RequiresWPClientCert; }
        }

        // Does this api require a MachineId? Only applies when authentication is required.
        public bool RequiresMachineId
        {
            get { return _RequiresMachineId; }
        }

        // Does this api require a valid XUID? Only applies when authentication is required.
        public bool RequiresXuid
        {
            get { return _RequiresXuid; }
        }

        // Does this api have throttling limits configured?
        public bool ThrottleEnabled
        {
            get { return _ThrottleEnabled; }
        }

        // Throttle: number of seconds for the half-life decay
        public int ThrottleHalfLifeSeconds
        {
            get { return _ThrottleHalfLifeSeconds; }
        }

        // Throttle: request threshold when throttling kicks in
        public int ThrottleThreshold
        {
            get { return _ThrottleThreshold; }
        }

        // Perfcounter-safe version of policy id key
        public string PolicyIdKeyForPerf
        {
            get { return _PolicyIdKeyForPerf; }
        }

        // Xbanc-safe version of policy id key. Keep it short!
        public string PolicyIdKeyForXbanc
        {
            get { return _PolicyIdKeyForXbanc; }
        }

        // Which types of authentication are permitted for this policy. This is a breaking
        // change from how things have been done in the past and deprecates many other
        // fields in this class.
        public ActiveAuthMethod AllowedAuthMethods
        {
            get { return _AllowedAuthMethods; }
        }

        // 
        // Methods
        //

        // What Auth Instance is this intended for?
        public string AuthInstance
        {
            get { return _AuthInstance; }
        }

        //What environment is this auth policy for?
        public string AuthEnvironment
        {
            get { return _AuthEnvironment; }
        }

        public HybridDictionary AllowListHeaderSetIncoming
        {
            get
            {
                return _AllowlistHeaderSetIncoming;
            }
        }

        public HybridDictionary AllowListHeaderSetOutgoing
        {
            get
            {
                return _AllowlistHeaderSetOutgoing;
            }
        }

        public void AddAllowedPartnerId(Guid partnerId)
        {
            _AllowedPartnerIds.Add(partnerId);
        }

        public bool IsPartnerAllowed(Guid partnerId)
        {
            return _AllowedPartnerIds.Contains(partnerId);
        }

        // Regex Ordering?
        public int RegexOrder
        {
            get { return _RegexOrder; }
        }

        public string HostNameMapping
        {
            get { return _HostNameMapping; }
        }

        public int MaxUrlLength
        {
            get { return _MaxUrlLength; }
        }

        public int MaxContentLength
        {
            get { return _MaxContentLength; }
        }

        public int MaxQueryStringLength
        {
            get { return _MaxQueryStringLength; }
        }

        internal ApiPolicy()
        {
            _PolicyIdKey = null;
        }

        internal ApiPolicy(
            string key,
            bool requiresAuth,
            string authPolicy,
            string authHeader,
            bool ssl,
            bool antiDos,
            bool xuid,
            bool wpClientCert,
            bool machineId,
            bool throttle,
            int throttleHalfLife,
            int throttleThreshold,
            string allowedAuthMethodsOrig,
            string authInstance,
            string authEnvironment,
            string allowListHeaderIncoming,
            string allowListHeaderOutgoing,
            int iRegexOrder,
            string hostnamemapping,
            int maxurllength,
            int maxcontentlength,
            int maxquerystringlength
            )
        {
            _PolicyIdKey = key;
            _RequiresAuthentication = requiresAuth;
            _AuthenticationPolicy = authPolicy;
            _AuthorizationHeader = authHeader;
            _RequiresSsl = ssl;
            _AntiDosEnabled = antiDos;
            _RequiresXuid = xuid;
            _RequiresWPClientCert = wpClientCert;
            _RequiresMachineId = machineId;
            _ThrottleEnabled = throttle;
            _ThrottleHalfLifeSeconds = throttleHalfLife;
            _ThrottleThreshold = throttleThreshold;
            _AllowedAuthMethods = ParseAllowedAuthMethods(allowedAuthMethodsOrig);
            _AuthInstance = authInstance.ToLower();
            _AuthEnvironment = authEnvironment;

            //Convert comma delimited list of headers into dictionary
            //These are rovided per policy
            _AllowlistHeaderSetIncoming =  GetAllowlistHeaders(allowListHeaderIncoming);
            _AllowlistHeaderSetOutgoing =  GetAllowlistHeaders(allowListHeaderOutgoing);

            _PolicyIdKeyForPerf = _PolicyIdKey.Replace('/', '\\');
            // Instance name must be <= 127 chars
            if (_PolicyIdKeyForPerf.Length > 127)
            {
                _PolicyIdKeyForPerf = _PolicyIdKeyForPerf.Substring(0, 127);
            }

            // ok for now. maybe shorter if we can?
            _PolicyIdKeyForXbanc = _PolicyIdKeyForPerf;
            _AllowedPartnerIds = new List<Guid>();

            _RegexOrder = iRegexOrder;
            if (0 != iRegexOrder)
            {
                try
                {
                    _PolicyRegex = new Regex(key, RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);
                }
                catch
                {   // Not a valid Regex expression, invalidate this policy
                    _PolicyIdKey = null;
                }
            }

            _HostNameMapping = hostnamemapping;
            _MaxUrlLength = maxurllength;
            _MaxContentLength = maxcontentlength;
            _MaxQueryStringLength = maxquerystringlength;
        }

        // -------------------------------------------------------------------------
        // GetAllowlistHeaders - given a delimited list of header names, split them up 
        // into a dictionary of allowed http headers. Any other headers sent in the request 
        // will be blocked.
        // -------------------------------------------------------------------------
        public static HybridDictionary GetAllowlistHeaders(string allHeaders)
        {
            string[] allowlistHdrArray = null;
            HybridDictionary allowlistHeaderSet = null;

            if (!String.IsNullOrEmpty(allHeaders))
            {

                // Build the allowlisted forward headers.
                //
                // Don't set "connection", "host", or "content-length" explicitly
                // or else WebClient will likely throw an exception. If you set
                // "data", it seems there will be a duplicate for the client,
                // which is bad.
                //
                allowlistHdrArray = allHeaders.Split(
                        new char[] { ',', ';' }
                        );

                // Create a case-insensitive dictionary of the appropriate size
                allowlistHeaderSet = new HybridDictionary(
                    allowlistHdrArray.Length,
                    true
                    );

                // Fill in the dictionariy with the allowlist members
                foreach (string hdr in allowlistHdrArray)
                {
                    // Put it in the hybriddictionary.  Depending on how many
                    // entries we have, the hybrid dictionary will use either the
                    // hashtable or ListDictionary implementation to make our
                    // lookups faster.

                    string newEntry = hdr.Trim().ToLower();

                    // Exclude "bad" headers. These are internal ones like "AuthZ" and 
                    // "HttpAuthData" that no one should ever place in the allowlist setting, but 
                    // if they do, we'll ignore it.
                    if (XHttpHdr.IsKnownInternalHeader(newEntry))
                    {
                        Trace.High("InitializeAllowlistHeaders: {0} not allowed", newEntry);
                        continue;
                    }

                    Trace.Normal("InitializeAllowlistHeaders: {0}", newEntry);
                    allowlistHeaderSet[newEntry] = 1;
                }
            }
            else
            {
                allowlistHeaderSet = new HybridDictionary(true);
            }

            // Make sure content-type is included in the allowlist so that 
            // GatewayRequest.BeginProcessRequest will set the content-type properly
            if (!allowlistHeaderSet.Contains("content-type"))
            {
                allowlistHeaderSet["content-type"] = 1;
            }
            // Make sure content-length is included in the allowlist so that 
            // GatewayRequest.BeginProcessRequest will set the content-type properly
            if (!allowlistHeaderSet.Contains("content-length"))
            {
                allowlistHeaderSet["content-length"] = 1;
            }
            // Make sure connection is NOT included in the allowlist per RFC:
            // http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
            // The Connection general-header field allows the sender to specify options that are desired for that particular connection and MUST NOT be communicated by proxies over further connections.
            // The Connection header has the following grammar: 
            //       Connection = "Connection" ":" 1#(connection-token)
            //       connection-token  = token        
            if (allowlistHeaderSet.Contains("connection"))
            {
                allowlistHeaderSet.Remove("connection");
                Xom.NtEvent(XEvent.Id.AAGW_CONFIG_INVALID_ALLOWLISTENTRY, "Invalid AllowList entry ({0})", "connection");
            }

            // Swap in the new settings
            return allowlistHeaderSet;
        }

        public bool IsClientAllowed(ActiveAuthMethod clientAuthMethods)
        {
            if (AllowedAuthMethods != ActiveAuthMethod.NOTSPECIFIED)
            {
                // Changing this so that the client just needs one of the allowed auth methods
                // but can be using multiple.
                // This should not be a functional change from current usages but will support the case
                // where the client is using both a WP cert (X509WP) and sending WLID compact ticker (WLID1.0)
                // For the case were allowed auth methods contains WLID1.0 but not X509WP (or vice versa)
                // The X509WP is extra, but it's use should not result in 401 Unauthorized.
                // Before: return ((clientAuthMethods & AllowedAuthMethods) == clientAuthMethods);
                return (0 != (clientAuthMethods & AllowedAuthMethods));
            }
            else
            {
                return true;
            }
        }

        private ActiveAuthMethod ParseAllowedAuthMethods(string allowedAuthMethods)
        {
            if (String.IsNullOrEmpty(allowedAuthMethods))
                return ActiveAuthMethod.NOTSPECIFIED;

            ActiveAuthMethod allMethods = ActiveAuthMethod.NOTSPECIFIED;
            string[] tokens = allowedAuthMethods.Split(new char[] { ',', ' ' }, StringSplitOptions.RemoveEmptyEntries);
            string invalidMethods = null;

            for (int i = 0; i < tokens.Length; i++)
            {
                string methodStr = tokens[i].ToUpper().Trim();
                try
                {
                    ActiveAuthMethod method = (ActiveAuthMethod)Enum.Parse(
                        typeof(ActiveAuthMethod),
                        methodStr);
                    allMethods |= method;
                }
                catch (Exception)
                {
                    // we did not recognize an auth method, set the unknown flag
                    allMethods |= ActiveAuthMethod.UNKNOWN;

                    Trace.Error("ParseAllowedAuthMethods: invalid token '{0}' in input '{1}'",
                        tokens[i], allowedAuthMethods);

                    if (invalidMethods == null)
                    {
                        invalidMethods = tokens[i];
                    }
                    else
                    {
                        invalidMethods += ", " + tokens[i];
                    }
                }
            }

            // Event if there were any invalid methods
            if (!String.IsNullOrEmpty(invalidMethods))
            {
                Xom.NtEvent(XEvent.Id.AAM_CONFIG_WARNING,
                    "A policy contains invalid AuthMethods, the policy will be kept with the invalid methods ignored:\n" +
                    "  Policy Key : {0}\n" +
                    "  AuthMethods : {1}\n" +
                    "  Invalid : {2}"
                    , _PolicyIdKey, allowedAuthMethods, invalidMethods);
            }

            return allMethods;
        }

        public override string ToString()
        {
            string s;
            s = String.Format(
                "ApiPolicy[Key={0}, AuthReq={1}, AuthPolicy={2}, SSL={3}{4}{5}{6}{7}], Environment={8}, Instance={9}",
                _PolicyIdKey,
                _RequiresAuthentication,
                _AuthenticationPolicy,
                _RequiresSsl,
                _AntiDosEnabled ? ", AntiDos" : "",
                _RequiresXuid ? ", XuidReq" : "",
                _RequiresWPClientCert ? ", WP" : "",
                IsRegexPolicy ? ", Regular Expression:" + _RegexOrder.ToString() : "",
                _AuthEnvironment,
                _AuthInstance
                );
            if (_ThrottleEnabled)
            {
                s += String.Format(
                    ", Throttle[threshold={0}, hl={1} sec]",
                    _ThrottleThreshold,
                    _ThrottleHalfLifeSeconds);
            }
            if (_AllowedAuthMethods != ActiveAuthMethod.NOTSPECIFIED)
            {
                s += String.Format(
                    ", Allowed[{0}]",
                    _AllowedAuthMethods);
            }
            return s;
        }

        // 
        // Members
        //

        private string _PolicyIdKey;
        private string _PolicyIdKeyForPerf;
        private string _PolicyIdKeyForXbanc;

        private bool _RequiresAuthentication;
        private string _AuthenticationPolicy;
        private string _AuthorizationHeader;
        private bool _RequiresSsl;
        private bool _AntiDosEnabled;
        private bool _RequiresWPClientCert;
        private bool _RequiresMachineId;
        private bool _RequiresXuid;
        private bool _ThrottleEnabled;
        private int _ThrottleHalfLifeSeconds;
        private int _ThrottleThreshold;
        private ActiveAuthMethod _AllowedAuthMethods;
        private string _AuthEnvironment;
        private string _AuthInstance;

        private HybridDictionary _AllowlistHeaderSetIncoming;
        private HybridDictionary _AllowlistHeaderSetOutgoing;

        private List<Guid> _AllowedPartnerIds;

        private int _RegexOrder;
        private Regex _PolicyRegex = null;

        private string _HostNameMapping;
        private int _MaxUrlLength;
        private int _MaxContentLength;
        private int _MaxQueryStringLength;
    }

    // -----------------------------------------------------------------------------------
    // PolicyManager holds all policy objects. It is responsible for creating, initializing, 
    // reloading, and distributing them. You know, managing them.
    // -----------------------------------------------------------------------------------
    public class PolicyManager
    {
        private Dictionary<string, ApiPolicy> _PolicyStore;
        private RegexPolicyStore _RegexPolicyStore;

        internal int Count
        {
            get { return _PolicyStore != null ? _PolicyStore.Count : 0; }
        }

        internal PolicyManager()
        {
            int count = Reload();
            if (count == 0)
            {
                Xom.NtEvent(XEvent.Id.AAM_CONFIG_WARNING,
                             "No policies were loaded. This means the active auth module " +
                             "will be largely useless. Please check the NPDB table " +
                             "t_activeauth_policies. The xmgmt command \"reload\" can " +
                             "be used to reload the policies from this table.");
            }
        }

        // -------------------------------------------------------------------------------
        // LookupPolicy - given a policy id key (parsed url), returns the corresponding 
        // ApiPolicy. Returns null if one can't be found.
        // -------------------------------------------------------------------------------
        internal ApiPolicy LookupPolicy(string policyIdKey)
        {
            ApiPolicy p = null;
            if (!_PolicyStore.TryGetValue(policyIdKey, out p))
            {   // Exact path lookup failed, try Regex lookup

                if (!_RegexPolicyStore.TryGetValue(policyIdKey, out p))
                {
                    Trace.High("PolicyManager.LookupPolicy: {0} not found", policyIdKey);
                }
            }

            return p;
        }

        // -------------------------------------------------------------------------------
        // GetPolicyIdKey - Ensures a policy Id key always begins with '/'
        // -------------------------------------------------------------------------------
        internal static string GetUrlPrefixedPolicyIdKey(string policyIdKey)
        {
            string sanitizedPolicyId = String.Format("{0}{1}",
                policyIdKey.StartsWith("/") ? "" : "/",
                policyIdKey);

            return sanitizedPolicyId;
        }

        // -------------------------------------------------------------------------------
        // Reload - reloads all policies from NPDB and atomically swaps them with the current 
        // policy set. Returns the number of policies loaded.
        // -------------------------------------------------------------------------------
        internal int Reload()
        {
            Trace.High("PolicyManager.Reload: Reloading policy");

            // Case-insensitive comparisons
            Dictionary<string, ApiPolicy> policyStore;
            policyStore = new Dictionary<string, ApiPolicy>(StringComparer.CurrentCultureIgnoreCase);

            RegexPolicyStore regexPolicyStore = new RegexPolicyStore();

            try
            {
                using (SqlConnection conn = new SqlConnection(ConfigUtil.NpdbConnectionString))
                {
                    conn.Open();

                    using (SqlCommand cmd = conn.CreateCommand())
                    {
                        cmd.CommandText = "p_activeauth_get_policies_v2";
                        cmd.CommandType = CommandType.StoredProcedure;

                        SqlParameter param = new SqlParameter("@vc_instance", SqlDbType.VarChar, 64);
                        param.Value = AuthConfig.InstanceName.ToLower();
                        cmd.Parameters.Add(param);

                        using (SqlDataReader r = cmd.ExecuteReader())
                        {
                            ApiPolicy p;
                            int o_vc_policy_key = r.GetOrdinal("vc_policy_key");
                            int o_b_requires_authentication = r.GetOrdinal("b_requires_authentication");
                            int o_vc_auth_policy = r.GetOrdinal("vc_auth_policy");
                            int o_vc_auth_header = r.GetOrdinal("vc_auth_header");
                            int o_b_ssl = r.GetOrdinal("b_ssl");
                            int o_b_antidos = r.GetOrdinal("b_antidos");
                            int o_b_requires_xuid = r.GetOrdinal("b_requires_xuid");
                            int o_b_requires_clientcert = r.GetOrdinal("b_requires_clientcert");
                            int o_b_requires_machineid = r.GetOrdinal("b_requires_machineid");
                            int o_b_throttle = r.GetOrdinal("b_throttle");
                            int o_i_throttle_halflife_seconds = r.GetOrdinal("i_throttle_halflife_seconds");
                            int o_i_throttle_threshold = r.GetOrdinal("i_throttle_threshold");

                            int o_vc_allowed_auth_methods;
                            try { o_vc_allowed_auth_methods = r.GetOrdinal("vc_allowed_auth_methods"); }
                            catch (IndexOutOfRangeException) { o_vc_allowed_auth_methods = -1; }

                            int o_vc_instance = r.GetOrdinal("vc_instance");
                            int o_vc_environment = r.GetOrdinal("vc_environment");

                            int o_vc_allowlistheaderincoming = r.GetOrdinal("vc_allowlistheadersincoming");
                            int o_vc_allowlistheaderoutgoing = r.GetOrdinal("vc_allowlistheadersoutgoing");
                            int o_i_regex_order = r.GetOrdinal("i_regex_order");
                            int o_vc_hostnamemapping = r.GetOrdinal("vc_hostnamemapping");
                            int o_i_maxurllength_order = r.GetOrdinal("i_max_url_length");
                            int o_i_maxcontentlength_order = r.GetOrdinal("i_max_content_length");
                            int o_i_maxquerystringlength_order = r.GetOrdinal("i_max_query_string_length");

                            while (r.Read())
                            {
                                // (key, requiresAuth, authPolicy, requiresSsl, antiDos)
                                p = new ApiPolicy(
                                    r.GetString(o_vc_policy_key),
                                    r.GetBoolean(o_b_requires_authentication),
                                    r.IsDBNull(o_vc_auth_policy) ? null : r.GetString(o_vc_auth_policy),
                                    r.IsDBNull(o_vc_auth_header) ? null : r.GetString(o_vc_auth_header),
                                    r.GetBoolean(o_b_ssl),
                                    r.GetBoolean(o_b_antidos),
                                    r.GetBoolean(o_b_requires_xuid),
                                    r.GetBoolean(o_b_requires_clientcert),  // really "wp client cert"...
                                    r.GetBoolean(o_b_requires_machineid),
                                    r.GetBoolean(o_b_throttle),
                                    r.IsDBNull(o_i_throttle_halflife_seconds) ? 0 : r.GetInt32(o_i_throttle_halflife_seconds),
                                    r.IsDBNull(o_i_throttle_threshold) ? 0 : r.GetInt32(o_i_throttle_threshold),
                                    o_vc_allowed_auth_methods == -1 || r.IsDBNull(o_vc_allowed_auth_methods) ? null : r.GetString(o_vc_allowed_auth_methods),
                                    r.IsDBNull(o_vc_instance) ?  null : r.GetString(o_vc_instance),
                                    r.IsDBNull(o_vc_environment) ? null : r.GetString(o_vc_environment),
                                    r.IsDBNull(o_vc_allowlistheaderincoming) ? null : r.GetString(o_vc_allowlistheaderincoming),
                                    r.IsDBNull(o_vc_allowlistheaderoutgoing) ? null : r.GetString(o_vc_allowlistheaderoutgoing),
                                    r.GetInt16(o_i_regex_order),
                                    r.IsDBNull(o_vc_hostnamemapping) ? null : r.GetString(o_vc_hostnamemapping),
                                    r.IsDBNull(o_i_maxurllength_order) ? 0 : r.GetInt32(o_i_maxurllength_order),
                                    r.IsDBNull(o_i_maxcontentlength_order) ? 0 : r.GetInt32(o_i_maxcontentlength_order),
                                    r.IsDBNull(o_i_maxquerystringlength_order) ? 0 : r.GetInt32(o_i_maxquerystringlength_order)
                                    );

                                if (p.IsValid)
                                {
                                    Trace.Low("  {0}", p.ToString());
                                    
                                    string sanitizedPolicyId = GetUrlPrefixedPolicyIdKey(p.PolicyIdKey);
                                    
                                    if (!p.IsRegexPolicy)
                                    {
                                        if (policyStore.ContainsKey(sanitizedPolicyId))
                                        {
                                            Trace.High("Adding Duplicate Key : overrides existing key {0}", p.ToString());
                                        }

                                        policyStore[sanitizedPolicyId] = p;
                                    }
                                    else
                                    {
                                        // For Regex policies we want the unaltered policy key, prefixing a '/' messes with the regex meaning of the expression
                                        regexPolicyStore.Add(p.PolicyIdKey, p);
                                    }

                                    // Force perf counter instance to be created at this 
                                    // point, instead of waiting for the first request of this 
                                    // policy to come in.
                                    //ModulePerPolicyCounters counter = ModulePerPolicyCounters.Counters[p.PolicyIdKeyForPerf];

                                }
                            }
                        }
                    }

                    using (SqlCommand cmd = conn.CreateCommand())
                    {
                        cmd.CommandText = "p_activeauth_business_partner_connection_policy_get";
                        cmd.CommandType = CommandType.StoredProcedure;

                        // no params

                        using (SqlDataReader r = cmd.ExecuteReader())
                        {

                            int o_vc_policy_key = r.GetOrdinal("vc_policy_key");
                            int o_vc_partner_sg_cert = r.GetOrdinal("uid_business_partner_id");

                            while (r.Read())
                            {
                                ApiPolicy p = null;
                                
                                string sanitizedPolicyId = GetUrlPrefixedPolicyIdKey(r.GetString(o_vc_policy_key));

                                policyStore.TryGetValue(sanitizedPolicyId, out p);

                                if (p != null)
                                {
                                    p.AddAllowedPartnerId(r.GetGuid(o_vc_partner_sg_cert));
                                }
                            }
                        }
                    }
                }

                // We're going to very quickly swap out the global dictionary holding our 
                // policies with the local copy. Using the Interlocked.Exchange will ensure we 
                // have a memory barrier.

                Interlocked.Exchange(ref _PolicyStore, policyStore);
                Interlocked.Exchange(ref _RegexPolicyStore, regexPolicyStore);

            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.AAM_CONFIG_ERROR, e,
                    "Error reloading policies in PolicyManager.Reload()."
                );

                throw;
            }

            return policyStore.Count;
        }

        // -------------------------------------------------------------------------------
        // ListPolicies - return a human-readable list of policies
        // -------------------------------------------------------------------------------
        internal string ListPolicies(string instance)
        {
            // Local copy of store to prevent exchanges from underneath us
            Dictionary<string, ApiPolicy> policyStore = _PolicyStore;
            RegexPolicyStore regexPolicyStore = _RegexPolicyStore;

            if (policyStore == null)
            {
                return "The list of policies has not been loaded yet.";
            }

            StringBuilder sb = new StringBuilder();

            int count = policyStore.Count;

            foreach (KeyValuePair<string, ApiPolicy> kvp in policyStore)
            {
                sb.Append(kvp.Value.ToString() + "\r\n");
            }
            foreach (KeyValuePair<string, List<ApiPolicy>> kvpregex in regexPolicyStore)
            {
                sb.Append("\tREGEX Key [");
                sb.Append(kvpregex.Key + "]\r\n");
                foreach (ApiPolicy p in kvpregex.Value)
                {
                    sb.Append(p.ToString() + "\r\n");
                    count++;
                }
            }

            sb.AppendFormat("Number of policies: {0}", count);

            return sb.ToString();
        }
    }

    // -----------------------------------------------------------------------------------
    // RegexPolicyStore class holds all the polices marked as regex policies 
    // and methods to manage and test matches 
    // -----------------------------------------------------------------------------------
    internal class RegexPolicyStore : IEnumerable
    {
        static private char startofstringanchor = '^';
        static private char[] regexchars = new char[] { '[', '^', '\\', '*', '+', '?', '|', '#', '{', '$' };
        private Dictionary<string, List<ApiPolicy>> store;

        public RegexPolicyStore()
        {
            this.store = new Dictionary<string, List<ApiPolicy>>(StringComparer.CurrentCultureIgnoreCase);
        }

        public void Add(string keyseed, ApiPolicy p)
        {
            List<ApiPolicy> apiPolicies = null;
            string key = GetKey(keyseed);

            if (this.store.TryGetValue(key, out apiPolicies))
            {
                bool addToEndOfList = true;

                foreach (ApiPolicy lhs in apiPolicies)
                {
                    if (lhs.RegexOrder > p.RegexOrder)
                    {
                        apiPolicies.Insert(apiPolicies.IndexOf(lhs), p);
                        addToEndOfList = false;
                        break;
                    }
                }
                if (addToEndOfList)
                {
                    apiPolicies.Add(p);
                }
            }
            else
            {
                apiPolicies = new List<ApiPolicy>();
                apiPolicies.Add(p);
                this.store.Add(key, apiPolicies);
            }
        }

        public IEnumerator GetEnumerator()
        {
            return this.store.GetEnumerator();
        }

        // -------------------------------------------------------------------------------
        // TryGetValue - Check for a matching Regex for the given path by
        // First, checking if there a Policy Store Key for this "path"
        // Second, checking the string.Empty list
        // -------------------------------------------------------------------------------
        public bool TryGetValue(string path, out ApiPolicy p)
        {
            List<ApiPolicy> apiPolicies = null;

            // See if there' s a Regex list for the Policy Store Key for this "path"
            if (this.store.TryGetValue(GetKey(path), out apiPolicies))
            {
                p = TryGetPolicyFromList(apiPolicies, path);
                if (null != p)
                {
                    return true;
                }
            }

            // Try with the string.Empty list
            this.store.TryGetValue(string.Empty, out apiPolicies);
            p = TryGetPolicyFromList(apiPolicies, path);

            return (null != p);
        }

        protected ApiPolicy TryGetPolicyFromList(List<ApiPolicy> apiPolicies, string path)
        {
            if (null != apiPolicies)
            {   // Check each Regex for a match
                foreach (ApiPolicy policy in apiPolicies)
                {
                    if (policy.PolicyRegex.IsMatch(path))
                    {
                        return policy;
                    }
                }
            }
            return null;
        }

        // Key seed should be of the form "/abc..." including some regex characters
        // and may start with the regex start of line anchor '^'
        static protected string GetKey(string keyseed)
        {
            string key = string.Empty;

            // start after the '/' and after the start of line anchor if present
            int start = (keyseed[0] == startofstringanchor) ? 1 : 0;
            int idx = keyseed.IndexOf("/", start+1);

            if (-1 < idx)
            {
                key = keyseed.Substring(start, idx-start);
                if (-1 < key.IndexOfAny(regexchars))
                {
                    key = string.Empty;
                }
            }

            return key;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\gateway\AssemblyInfo.cs ===
[assembly: System.Reflection.AssemblyTitle("Xbox Live Active Auth Gateway")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\gateway\GatewayMgmt.cs ===
//
// GatewayXomCallback.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Active Auth Gateway Service
// Xbox Online Service
//
// Author: kgoodier 6/2007
//

using System;

using xonline.common.config;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.authsgtrace)]
[assembly: XomAreaDefinition(XomAreaName.authsglog)]

namespace xonline.server.activeauth.gateway
{
    // -------------------------------------------------------------------------
    // GatewayXomCallback class - XMgmt callback handler class
    // -------------------------------------------------------------------------
    public class GatewayXomCallback
    {
        private const string c_HelpText = @"
Active Auth Gateway help:
  reload    : Reload the mapping tables
  list      : Display the mapping tables
";

        // ---------------------------------------------------------------------
        // OnControlRequest - called by XMgmt when a control request is sent
        // ---------------------------------------------------------------------
        public static void OnControlRequest(
            object                  sender,
            ControlRequestEventArgs args
            )
        {
            string str = null;

            // Debug Tracing
            Trace.Low( "OnControlRequest: Begin {0}", args.Command );

            try
            {
                switch(args.Command)
                {

                case "help":
                    str = c_HelpText;
                    break;

                case "list":
                    str = GatewayApp.ListServices( );
                    break;

                case "reload":
                    GatewayApp.Reload();
                    str = "ActiveAuthGateway reloaded";
                    break;

                case "listpolicies":
                    if(GatewayApp.GatewayPolicyManager == null)
                    {
                        str = "Gateway PolicyManager has not been initialized. Please report.";
                    }
                    else
                    {
                        string command = (0 < args.CommandArgs.Length) ? args.CommandArgs[0] : null;
                        str = GatewayApp.GatewayPolicyManager.ListPolicies(command);
                    }
                    break;

                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage(
                    "Error: " + e.ToString() + "\r\n\r\n",
                    args.RequestId
                    );
            }

            if (str != null)
            {
                XomControlConnection.SendMessage(
                    str + "\r\n\r\n",
                    args.RequestId
                    );
                args.Handled = true;
            }

            // Debug Tracing
            Trace.Low( "OnControlRequest: End {0}", args.Command );

        }

    } // class GatewayXomCallback

    // -------------------------------------------------------------------------
    // Trace class - handy wrappers for making tracing prettier and easier
    // -------------------------------------------------------------------------
    internal static class Trace
    {
        internal static void Low(string format, params object[] args)
        {
            Xom.Trace(
                "authsgtrace",
                LogLevel.L_LOW,
                Timestamp + String.Format(format, args)
                );
        }

        internal static void Normal(string format, params object[] args)
        {
            Xom.Trace(
                "authsgtrace",
                LogLevel.L_NORMAL,
                Timestamp + String.Format(format, args)
                );
        }

        internal static void High(string format, params object[] args)
        {
            Xom.Trace(
                "authsgtrace",
                LogLevel.L_HIGH,
                Timestamp + String.Format(format, args)
                );
        }

        internal static void Error(string format, params object[] args)
        {
            Xom.Trace(
                "authsgtrace",
                LogLevel.L_ERROR,
                Timestamp + String.Format(format, args)
                );
        }

        private static string Timestamp
        {
            get
            {
                DateTime dt = DateTime.Now;
                return dt.ToString(@"hh:mm:ss.fff ");
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\gateway\GatewayRequest.cs ===
//
// Gateway Request
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Active Auth Gateway Service
// Xbox Online Service
//
// Author: kgoodier June 2007
//

using System;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Threading;
using System.Web;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;

using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;

using xonline.server.activeauth.common;

namespace xonline.server.activeauth.gateway
{

public class GatewayRequest : IHttpAsyncHandler
{
    public bool IsReusable
    {
        // Why not? We don't store state across invocations.
        get { return true; }
    }

    public GatewayRequest()
    {
        Trace.High("------------------------------------------------------------------------");
        Trace.High("AuthSG GatewayRequest Constructor");
        Trace.High("------------------------------------------------------------------------");

        if (AuthConfig.MaxConcurrentConnections > 0)
        {
            ServicePointManager.DefaultConnectionLimit = AuthConfig.MaxConcurrentConnections;
        }
    }

    public void ProcessRequest(HttpContext context)
    {
        Trace.Error("ProcessRequest called");
        throw new InvalidOperationException();
    }

    public IAsyncResult BeginProcessRequest(
        HttpContext ctx,
        AsyncCallback cb,
        object extraData)
    {
        AsyncOperation asyncOp          = new AsyncOperation(ctx, cb, extraData);
        string         routingKey   = "";
        string         httpMethod       = "";
        bool isRoutedByHostName = false;
        // Verify some stuffs.
        //
        // Probably need to parse the url. Decide on a destination.
        try {

            // get the routing key from the URL
            routingKey = ctx.Request.Url.AbsolutePath.ToLower();
            if ( routingKey == null)
            {

                // Bad Request from Client
                ctx.Response.StatusCode = (int)HttpStatusCode.BadRequest; // 400

                // log the request and throw an error
                throw new ExceptionWithEventId(
                    XEvent.Id.AAGW_HACK_URL,
                    "AuthSg: No URL was specified in the request header. " +
                    "This could be a hacker. Please Monitor."
                    );
            }

            // Get the VERB that was used for this request
            httpMethod = ctx.Request.HttpMethod.ToUpper();

            // lookup the services host name
            if ( GatewayApp.Services == null)
            {

                // Server Config Error
                ctx.Response.StatusCode = (int)HttpStatusCode.InternalServerError; // 500

                // log the request and throw an error
                throw new ExceptionWithEventId(
                    XEvent.Id.AAGW_CONFIG_SERVICE_TABLE,
                    "AuthSg: No Service Table Exists. AuthSg should have " +
                    "services for request forwarding."
                    );
            }

            //Gateway has to build its own dictionary of policies
            //and to look them up it also has to build its own key
            //from the request.
            //Incoming and outgoing allow lists are now per activeauth policy
            //so we have to lookup the individual policy and check in its
            //incoming list to see if all is good. 
            string policyKey = ctx.Items[AuthCommon.ACTIVEAUTH_POLICY_IDKEY].ToString();

            ApiPolicy apPolicy = null;
            string toAddress = null;

            if (!String.IsNullOrEmpty(policyKey))
            {
                apPolicy = GatewayApp.GatewayPolicyManager.LookupPolicy(policyKey);
            }

            if ((apPolicy == null) || (!apPolicy.IsValid))
            {
                Trace.Low(
                        "GateWay LookupPolicy found nothing Policy:{0} Verb:{1} URL:{2} Dest:{3}",
                        policyKey,
                        httpMethod,
                        routingKey,
                        toAddress
                        );

                // Bad Request from Client
                ctx.Response.StatusCode = (int)HttpStatusCode.BadRequest; // 400

                // Log the request and throw an error
                throw new ExceptionWithEventId(
                    XEvent.Id.AAGW_HACK_URL,
                    "AuthSg: The policy [" + policyKey +
                    "] is not found in policy lookup. Please Monitor."
                    );
            }

            IRouteInfo route;

            // the first content length  check  is  against  the
            // overall maximum defined by the HTTP runtime (IIS)

            int contentLength = ctx.Request.ContentLength;

            if (contentLength > GatewayApp.GatewayMaximumRequestLength)
            {
                ctx.Response.StatusCode = (int) HttpStatusCode.RequestEntityTooLarge;
                throw new XRLExceptionWithoutEvent(HResult.E_FAIL, "Request exceeds maximum length, {0}", GatewayApp.GatewayMaximumRequestLength);
            }

            // now look up the route so we can check against
            // the specific policy configured for it

            if (GatewayApp.TryLookupRoutingPolicy(apPolicy, routingKey, out route))
            {
                // We know the URL and recognize it as valid at this point. 
                if (route.IsXRLMapping)
                {
                    asyncOp.Xrl = routingKey;
                }

                // Check the length of the URL is acceptable

                if (routingKey.Length > route.MaxUrlLength)
                {
                    ctx.Response.StatusCode = (int)HttpStatusCode.BadRequest; // 400
                    throw new XRLExceptionWithoutEvent(HResult.E_FAIL, "URL exceeds maximum length for service {0}, {1}", routingKey, route.MaxUrlLength);
                }

                // Check the query string is acceptable

                if (ctx.Request.Url.Query.Length > route.MaxQueryStringLength)
                {
                    ctx.Response.StatusCode = (int)HttpStatusCode.BadRequest; // 400
                    throw new XRLExceptionWithoutEvent(HResult.E_FAIL, "Query string exceeds maximum length for service {0}, {1}", routingKey, route.MaxQueryStringLength);
                }

                // This second content length is against the limit
                // defined within t_xrl_virtual_interface_mappings

                if (route.MaxContentLength != -1 && contentLength > route.MaxContentLength)
                {
                    ctx.Response.StatusCode = (int)HttpStatusCode.RequestEntityTooLarge; // 413
                    throw new XRLExceptionWithoutEvent(HResult.E_FAIL, "Request exceeds maximum length for service {0}, {1}", routingKey, route.MaxContentLength);
                }

                if (route.IsXRLMapping)
                {
                    ServiceNode service = route as ServiceNode;

                    GatewayGlobalCounters.Counters.BytesRecvPerSec.IncrementBy(contentLength);

                    // Grab the virtual interface
                    IVirtualInterfaceInfo serviceVInterface = Config.GetVirtualInterface(
                        service._viface,
                        service._siteid
                        );

                    // Send request through to front door
                    toAddress = "http://" +
                                serviceVInterface.IPAddressString +
                                ":" +
                                serviceVInterface.Port.ToString() +
                                ctx.Request.Url.AbsolutePath +
                                ctx.Request.Url.Query;

                }
                else
                {
                    // Send request through to remapped host, don't touch path.
                    toAddress = "http://" +
                                ((ApiPolicyRouteInfo) route).HostNameMapping +
                                ctx.Request.Url.AbsolutePath +
                                ctx.Request.Url.Query;

                    isRoutedByHostName = true;
                }
            }
            else
            {
                // Bad Request from Client
                ctx.Response.StatusCode = (int)HttpStatusCode.BadRequest; // 400

                // Log the request and throw an error
                throw new ExceptionWithEventId(
                    XEvent.Id.AAGW_HACK_UNKNOWN_SERVICE,
                    "AuthSg: The routeing key " + routingKey.ToString() +
                    " is unknown to AuthSg. This could be a hacker. " +
                    "Please Monitor."
                    );
            }

            // Store information for future logging
            asyncOp.ToAddress     = toAddress;
            Trace.Normal(
                "BPR - Verb:{0} Host: {1} URL:{2} Dest:{3} Length:{4}",
                httpMethod,
                ctx.Request.Url.Host,
                routingKey,
                toAddress,
                contentLength
                );

            // Create our request object with the url
            HttpWebRequest webReq = (HttpWebRequest)WebRequest.Create(toAddress);
            
            // Useful inside the callbacks
            asyncOp.Request = webReq;

            // Don't let IIS blow away failure bodies on routed calls
            if (isRoutedByHostName)
            {
                ctx.Response.TrySkipIisCustomErrors = true;
            }
            
            if (!AuthConfig.EnableRequestPipelining)
            {
                //Pipelineing is enabled by default
                webReq.Pipelined = false;
            }

            // Forward headers. Only do ones in the allowlist.
            //
            // Important note: make sure we strip out any AAInfo-related headers
            // from the client's request, particularly the "Authz" header that
            // is used by us to pass the AAInfo to the front door. The allowlist
            // does this now, but if we move to a denylist in the future, watch
            // out.

            if (apPolicy.IsValid)
            {
                foreach (string hdrKey in ctx.Request.Headers)
                {
                  if ((apPolicy.AllowListHeaderSetIncoming != null) && apPolicy.AllowListHeaderSetIncoming.Contains(hdrKey))
                    {
                        Trace.Low(
                            "BPR - Verb:{0} URL:{1} Dest:{2} Header[{3}]:{4}",
                            httpMethod,
                            routingKey,
                            toAddress,
                            hdrKey,
                            ctx.Request.Headers[hdrKey]
                            );

                        // use special copy function that knows how to deal
                        // with setters and getters for the special headers

                        RequestHeaderHandler.Copy(hdrKey, ctx.Request, webReq);
                    }
                }
            }

            // Insert ActiveAuthInfo stuff here by retrieving from HttpContext
            // and inserting into the headers of the request we're about to
            // forward.
            AAInfo aa = AAInfoInternetTier.Current;
            if (aa == null)
            {
                // We'll pass this through for now, especially since we may want
                // to test the gateway without having the ActiveAuthModule
                // configured. But we should consider making it a fatal error in
                // the future.
                Trace.Error(
                    "ActiveAuthModule did not provide AAInfo in the HttpContext"
                    );
            }
            else
            {
                AAInfo.MarshallToHeaders(webReq.Headers, aa);
            }

            // Take the current IClaimsPrincipal -- from XblAuthProtocolModule or WIF
            // or other -- and serialize it in a custom small format (XAuthdata). Put
            // that in the "Authorization" header for the caller.
            webReq.SetXAuthdata(Thread.CurrentPrincipal as IClaimsPrincipal);

            // Start real work here.

            try
            {
                if ((httpMethod == "GET") || (httpMethod == "DELETE"))
                {
                    webReq.Method = httpMethod;
                    BeginGetResponse(asyncOp);
                }
                else if ((httpMethod == "POST") || (httpMethod == "PUT"))
                {
                    webReq.Method = httpMethod;

                    if (contentLength > 0)
                        BeginGetRequestStream(asyncOp);
                    else
                    {
                        BeginGetResponse(asyncOp);
                    }
                }
                else
                {
                    // Unrecognized verb
                    Trace.Error(
                        "BPR - Bad Verb - Verb:{0} URL:{1} Dest:{2}",
                        httpMethod,
                        routingKey,
                        toAddress
                        );

                    Xom.NtEvent(XEvent.Id.AAGW_HACK_UNKNOWN_SERVICE,
                        "AuthSg: The HttpMethod Verb " + httpMethod.ToString() +
                        " is unknown to AuthSg. This could be a hacker. " +
                        "Please Monitor."
                    );
                    
                    ctx.Response.StatusCode = (int)HttpStatusCode.MethodNotAllowed; // 405
                    asyncOp.CompleteRequest();
                }
            }
            catch (Exception e)
            {
                // This will call asyncOp.CompleteRequest
                HandleException(e, asyncOp);
            }
        }
        catch (Exception e)
        {
            Trace.Error(
                "BPR - Error - Verb:{0} URL:{1} Error:{2}",
                httpMethod,
                routingKey,
                e.Message
                );

            // if we did not set the status code up above, then
            // make it 500.  this assumes we never set  to  200

            if (ctx.Response.StatusCode == (int) HttpStatusCode.OK)
            {
                // Server Error
                ctx.Response.StatusCode = (int) HttpStatusCode.InternalServerError; // 500
            }

            // Call into FEAPP to log the exception
            FrontEndApp.LogException(ctx,e,false);

            asyncOp.CompleteRequest();
        }
        finally
        {
            if (asyncOp.Xrl != null)
                FrontEndApp.XrlCounters(ctx).RequestsInProgress.Increment();
            else
                FrontEndApp.XrlCounters("_unknown_").RequestsInProgress.Increment();
        }
        
        return asyncOp;
    }

    // ------------------------------------------------------------------------
    // EndProcessRequest - callback from IIS/ASP.NET when request has been completed.
    // ------------------------------------------------------------------------
    public void EndProcessRequest(IAsyncResult ar)
    {
        // Let's do some logging. As long as we didn't forget to complete the
        // request (and don't throw an exception here), we should always get a
        // logline. This is good.
        AsyncOperation asyncOp = ar as AsyncOperation;
        if (asyncOp != null)
        {
            HttpContext ctx              = asyncOp.Context;

            // FEAPP perf counters
            IFrontEndAppCounters xrlCounters;
            if (asyncOp.Xrl != null)
                xrlCounters = FrontEndApp.XrlCounters(ctx);
            else
                xrlCounters = FrontEndApp.XrlCounters("_unknown_");

            xrlCounters.TotalRequests.Increment();
            xrlCounters.RequestsPerSec.Increment();
            xrlCounters.RequestsInProgress.Decrement();

            XomRequestTimeElapsed requestTimeElapsed = (XomRequestTimeElapsed)(ctx.Items["FeAppElapsedTime"]);
            long elapsed = requestTimeElapsed != null ? requestTimeElapsed.TimeElapsed : 0;
            xrlCounters.AverageExecutionTime.IncrementBy(elapsed);
            xrlCounters.AverageExecutionTimeBase.Increment();


            // Indicate success or not, who it came from, what URL we were
            // handling, maybe exception details, status code, etc
            // 
            // Log fields:
            // AAGWREQ | HResult | clientip | rawurl | toaddress | requestContentLength | clientStatusCode | serverContentLength | serverStatusCode | timeInMs

            HResult hr = HResult.S_OK;
            if (asyncOp.Error != null) hr = XblException.GetHResult(asyncOp.Error);

            string[] fields = new string[]
            {
                "AAGWREQ",
                hr.ToString(),
                ctx.Request.UserHostAddress,
                (ctx.Request.Url.AbsolutePath + ctx.Request.Url.Query ),
                asyncOp.ToAddress,
                ctx.Request.ContentLength.ToString(),
                ctx.Response.StatusCode.ToString(),
                (asyncOp.Response != null) ? asyncOp.Response.ContentLength.ToString() : string.Empty,
                asyncOp.ServerStatusCode.HasValue ? ((int)asyncOp.ServerStatusCode).ToString() : string.Empty,
                requestTimeElapsed != null ? requestTimeElapsed.MillisecondsElapsed.ToString() : "0",
            };

            string szLog = String.Join("|", fields);
            Xom.Log(XomAreaName.authsglog, szLog);
            Trace.Normal("EPR - {0}",szLog);

            // Perf counter for bytes needs to go here
            GatewayGlobalCounters.Counters.BytesSentPerSec.IncrementBy(asyncOp.Response != null ?
                                                                       asyncOp.Response.ContentLength : 
                                                                       0);

        }
    }


    // ------------------------------------------------------------------------
    // BeginGetRequestStream - calls BeginGetRequestStream and schedules a timer to handle 
    // the timeout.
    // ------------------------------------------------------------------------
    private static IAsyncResult BeginGetRequestStream(AsyncOperation asyncOp)
    {
        Trace.Low("BeginGetRequestStream");
        asyncOp.SetTimeout(GatewayApp.RequestTimeoutMilliseconds, HttpStatusCode.RequestTimeout, HandleException);
        return asyncOp.Request.BeginGetRequestStream(new AsyncCallback(RequestCallback), asyncOp);
    }

    // ------------------------------------------------------------------------                  -
    // BeginGetResponse - calls BeginGetResponse and schedules a timer to handle the 
    // timeout.
    // ------------------------------------------------------------------------
    private static IAsyncResult BeginGetResponse(AsyncOperation asyncOp)
    {
        Trace.Low("BeginGetResponse");
        asyncOp.SetTimeout(GatewayApp.GatewayTimeoutMilliseconds, HttpStatusCode.GatewayTimeout, HandleException);
        return asyncOp.Request.BeginGetResponse(new AsyncCallback(ResponseCallback), asyncOp);
    }

    // ------------------------------------------------------------------------
    // RequestCallback - async callback for when we try to get the request stream from the 
    // client's request. This function will send the request to the server, and will 
    // trigger the next callback, ResponseCallback, to handle the server's response.
    //
    // Do not throw any unhandled exceptions. We are outside the protection of 
    // HttpApplication here.
    // ------------------------------------------------------------------------
    private static void RequestCallback(IAsyncResult asyncResult)
    {
        // Names are confusing. Sorry. AsyncOperation is ours, from the IIS/ASP.NET async 
        // stuff, and is being 'reused' here. Holds everything we need, like a purse.

        Trace.Low("RequestCallback - Start");
        AsyncOperation asyncOp = (AsyncOperation)asyncResult.AsyncState;

        lock (asyncOp)
        {
            if (asyncOp.IsCompleted || asyncOp.Error != null)
            {
                Trace.Low("RequestCallback - End due to prior error or completion");
                return;
            }
        }

        try
        {
            HttpContext    ctx           = asyncOp.Context;
            HttpWebRequest webRequest    = asyncOp.Request;
            int            contentLength = ctx.Request.ContentLength;

            // Don't read 0 bytes, throws exception
            if (contentLength > 0)
            {
                byte[] data = ctx.Request.BinaryRead(contentLength);

                using (Stream postStream  = webRequest.EndGetRequestStream(asyncResult))
                {
                    Trace.Low("RequestCallback - Proxying {0} bytes to {1}", 
                                ctx.Request.ContentLength, asyncOp.ToAddress);

                    if (data == null || data.Length != contentLength)
                    {
                        String msg = String.Format("RequestCallback - ContentLength[{0}] from client doesn't match data length [{1}]",
                                                    contentLength, data != null ? data.Length : 0);
                        Trace.Error(msg);
                        // @@@ no throw!
                        throw new Exception("Content-length header doesn't match data length: " + msg);
                    }

                    Trace.Low("RequestCallback - writing actual {0} bytes", data.Length);
                    postStream.Write(data, 0, contentLength);
                }
            }

            // Retrieve the response now. This should fire off the request to the 
            // server, right? It will keep the chain of async events going.
            BeginGetResponse(asyncOp);
        }
        catch (Exception e)
        {
            HandleException(e, asyncOp);
        }

        Trace.Low("RequestCallback - End");
    }

    // ------------------------------------------------------------------------
    // ResponseCallback - async callback for when we try to get the response stream from 
    // the server we sent the request to. 
    // 
    // Do not throw any unhandled exceptions. We are outside the protection of 
    // HttpApplication here.
    // ------------------------------------------------------------------------
    private static void ResponseCallback(IAsyncResult asyncResult)
    {
        Trace.Low("ResponseCallback - Start");

        AsyncOperation  asyncOp = (AsyncOperation) asyncResult.AsyncState;

        if (asyncOp.Error != null || asyncOp.IsCompleted)
        {
            Trace.Low("ResponseCallback - End due to prior error or completion");
            return;
        }

        try
        {
            asyncOp.Response = (HttpWebResponse) asyncOp.Request.EndGetResponse(asyncResult);
            ProxyWebResponse(asyncOp);

            // All done. Complete the original request. Don't forget this step. Ever.
            asyncOp.CompleteRequest();
        }
        catch (Exception e)
        {
            HandleException(e, asyncOp);
        }
        
        Trace.Low("ResponseCallback - End");
    }

    // ------------------------------------------------------------------------
    // ProxyWebResponse - takes the HttpWebResponse from the server and proxies it to the 
    // HttpContext to return it to the client.
    // ------------------------------------------------------------------------
    private static void ProxyWebResponse(AsyncOperation asyncOp)
    {
        HttpContext ctx = asyncOp.Context;
        HttpWebResponse webResponse = asyncOp.Response;

        // save status code for logging, and copy into response
        ctx.Response.StatusCode = (int) (asyncOp.ServerStatusCode = webResponse.StatusCode);
        ctx.Response.StatusDescription = webResponse.StatusDescription;

        //Gateway has to build its own dictionary of policies
        //and to look them up it also has to build its own key
        //from the request.
        //Incoming and outgoing allow lists are now per activeauth policy
        //so we have to lookup the individual policy and check in its
        //outgoing list to see if all is good.
        string policyKey = ctx.Items[AuthCommon.ACTIVEAUTH_POLICY_IDKEY].ToString();

        ApiPolicy apPolicy = null;

        if (!String.IsNullOrEmpty(policyKey))
        {
            apPolicy = GatewayApp.GatewayPolicyManager.LookupPolicy(policyKey);
        }

        if ((apPolicy != null) || (!apPolicy.IsValid))
        {
            Trace.Low(
                    "GateWay LookupPolicy found nothing Policy:{0}, Uri[{1}]",
                    policyKey,
                    webResponse.ResponseUri
                    );
        }

        // copy the response headers if available.
        if ( webResponse.Headers != null && apPolicy.IsValid)
        {
            foreach( string hdrKey in webResponse.Headers )
            {
                if ((apPolicy.AllowListHeaderSetOutgoing != null) && apPolicy.AllowListHeaderSetOutgoing.Contains(hdrKey))
                {
                    ctx.Response.AppendHeader(
                        hdrKey,
                        webResponse.Headers[hdrKey]
                        );
                }
            }
        }

        Trace.Normal("ProxyWebResponse - Status[{0}], Bytes[{1}], Uri[{2}]", 
                     (int)webResponse.StatusCode,
                     webResponse.ContentLength,
                     webResponse.ResponseUri);

        // Read and write chunks until no data left. Trying to read the whole thing in at 
        // once doesn't work, you aren't guaranteed to have all the data available. Size 
        // is arbitrarily chosen.
        byte[]  buffer          = new byte[32768];
        int     dataRead        = 0;
        
        using (Stream inputStream = webResponse.GetResponseStream())
        {
            using (Stream outputStream = ctx.Response.OutputStream)
            {
                while (0 != (dataRead = inputStream.Read(buffer, 0, buffer.Length)))
                {
                    outputStream.Write(buffer, 0, dataRead);
                }
            }
        }
    }


    // ------------------------------------------------------------------------
    // HandleException - handles any exception, though it is expected to handle only 
    // WebExceptions. Those are special and let us possibly extract a response from the 
    // server.
    //
    // This will complete the async operation and return an error code to the client. No 
    // further processing should occur after HandleException() is called.
    // ------------------------------------------------------------------------
    protected static void HandleException(
        Exception       exception,
        AsyncOperation  asyncOp
        )
    {
        Trace.Error("HandleException - Start\n{0}", exception.ToString());

        // if the operation is completed or we have already
        // processed another error, then we can just return

        lock (asyncOp)
        {
            if (asyncOp.IsCompleted)
            {
                Trace.Low("HandleException: operation is already completed, ignoring error");
                return;
            }

            if (asyncOp.Error != null)
            {
                Trace.Low("HandleException: already encountered a previous error, aborting error handling.");
                return;
            }

            // Store exception so we can check it later
            asyncOp.Error = exception;
        }
        
        try
        {
            // we are not on the original thread, so our http
            // context is gone.  restore it so the  event log
            // code can include  useful  request  information

            HttpContext ctx = HttpContext.Current = asyncOp.Context;

            if (exception is WebException)
            {
                // WebExceptions are special. They tell us stuff. And maybe give us data.
                WebException e = (WebException)exception;
                if ( e.Response == null )
                {
                    // log event
                    Xom.NtEvent(XEvent.Id.AAGW_EXCEPTION_WITH_NO_RESPONSE, e,
                        "A WebException without a Response has occurred in the AuthSG."
                    );

                    Trace.Error("HandleException - WebException without a Response");
                    
                    // WebException without a response. Something bad happened.
                    // Should return 500 with no body (?).
                    ctx.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
                }
                else 
                {
                    // If we got a response, then we will proxy it just like the valid
                    // case. 
                    asyncOp.Response = (HttpWebResponse) e.Response;
                    ProxyWebResponse(asyncOp);
                }
            }
            else
            {
                // log event
                Xom.NtEvent( XEvent.Id.AAGW_EXCEPTION_WITH_NO_RESPONSE, exception,
                    "An unexpected Exception has occurred in the AuthSG." 
                );

                Trace.Error("HandleException - Unknown exception, aborting with 500");
                
                // Unknown/unhandled exception type.
                // Should return 500 with no body (?).
                ctx.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
            }

        }
        catch (System.Web.HttpException e)
        {
            Trace.Error("HandleException: caught HttpException. Client connection {0} likely went away. Exception:\n{1}",
                        asyncOp.Context.Request.UserHostAddress, e.ToString());
        }
        catch (Exception e)
        {
            Trace.Error("HandleException: Unhandled exception:\n{0}", e.ToString());

            Xom.NtEvent(XEvent.Id.AAGW_INTERNAL_ERROR, e,
                "Unhandled exception caught in the HandleException function. " +
                "This is unexpected. Please report to the dev team."
            );
        }
        finally
        {
            // Finish request gracefully, we're done. This may fail, especially if an 
            // IOException or HttpException was thrown. We can swallow errors.
            try
            {
                asyncOp.CompleteRequest();
            }
            catch (Exception e)
            {
                Trace.High("HandleException: CompleteRequest() threw:\n{0}", e.ToString());
            }
        }
    }

}

    public delegate void ExceptionDelegate(Exception e, AsyncOperation asyncOperation);

    public class AsyncOperation : IAsyncResult
    {
        public AsyncOperation(
            HttpContext   ctx,
            AsyncCallback cb,
            object        extraData
            )
        {
            _ctx = ctx;
            _cb = cb;
            _extraData = extraData;
            ToAddress = "";
            Request = null;
            Response = null;
            Error = null;
            Xrl = null;
        }

        private HttpContext       _ctx;
        private AsyncCallback     _cb;
        private object            _extraData;
        private bool              _isCompleted = false;

        public HttpContext Context
        {
            get { return(_ctx); }
        }

        //
        // IAsyncResult interface property implementations
        //

        public object AsyncState
        {
            get { return(_extraData); }

        }

        public bool CompletedSynchronously
        {
            get { return(false); }
        }

        public bool IsCompleted
        {
            get { return(_isCompleted); }
        }

        public WaitHandle AsyncWaitHandle
        {
            get { return null; }
        }

        //
        // Unique to this GatewayRequest api. Mostly used to shove handy data around.
        //

        internal HttpWebRequest         Request;
        internal HttpWebResponse        Response;
        internal string                 ToAddress;
        internal Exception              Error;
        internal string                 Xrl;

        // record the status code returned by the server  which
        // can be different from what we return to  the  client

        internal HttpStatusCode?        ServerStatusCode;

        // timer handles and code to return on timeout
        
        private HttpStatusCode          timeoutStatusCode;
        private ManualResetEvent        timeoutHandle = new ManualResetEvent(false);
        private RegisteredWaitHandle    registeredTimeoutHandle = null;
        private ExceptionDelegate       timeoutExceptionHandler = null;

        public void CompleteRequest()
        {
            lock (this) {
                CancelTimeout();

                if (_isCompleted) return;
                _isCompleted = true;
            }

            // if a callback was registered, invoke it now
            if (_cb != null)
            {
                _cb(this);
            }
        }

        internal void SetTimeout(long milliseconds, HttpStatusCode statusCode, ExceptionDelegate exceptionHandler)
        {
            lock (this)
            {
                CancelTimeout();
                timeoutStatusCode = statusCode;
                timeoutExceptionHandler = exceptionHandler;

                registeredTimeoutHandle = ThreadPool.RegisterWaitForSingleObject(
                    timeoutHandle, OnTimeout, this, milliseconds, true
                );
            }
        }

        internal void CancelTimeout()
        {
            lock (this)
            {
                if (registeredTimeoutHandle != null)
                {
                    registeredTimeoutHandle.Unregister(timeoutHandle);
                    registeredTimeoutHandle = null;
                }

                timeoutHandle.Reset();
            }
        }

        private void OnTimeout(object asyncState, bool timedOut)
        {
            lock (this)
            {
                if (Error != null) return;
                if (_isCompleted) return;

                // if we get here but have not timed  out  then
                // someone cancelled the timeout and we're done

                if (! timedOut) return;

                try
                {
                    try
                    {
                        Context.Response.StatusCode = (int) timeoutStatusCode;
                        CompleteRequest();
                    }
                    finally 
                    {
                        Request.Abort();
                    }
                }

                catch (Exception e)
                {
                    timeoutExceptionHandler(e, this);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\common\Trace.cs ===
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;

using xonline.common.mgmt;

namespace xonline.server.activeauth.common
{

/// <summary>
/// Trace class - handy wrappers for making tracing prettier and easier 
/// </summary>
internal static class Trace
{
    internal static void Low(string format, params object[] args)
    {
        Xom.Trace(XomAreaName.aamodule, LogLevel.L_LOW, Timestamp + format, args);
    }

    internal static void Normal(string format, params object[] args)
    {
        Xom.Trace(XomAreaName.aamodule, LogLevel.L_NORMAL, Timestamp + format, args);
    }

    internal static void High(string format, params object[] args)
    {
        Xom.Trace(XomAreaName.aamodule, LogLevel.L_HIGH, Timestamp + format, args);
    }

    internal static void Error(string format, params object[] args)
    {
        Xom.Trace(XomAreaName.aamodule, LogLevel.L_ERROR, Timestamp + format, args);
    }

    private static string Timestamp
    {
        get
        {
            DateTime dt = DateTime.Now;
            return dt.ToString(@"hh:mm:ss.fff ");
        }
    }

}


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\gateway\PerfCounters.cs ===
// 
// PerfCounters.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Active Auth Gateway Service
// Xbox Online Service
// 
// Author: kgoodier 6/2007
//

using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.activeauth.gateway
{
    [XomPerformanceCounterCategoryAttr( "ActiveAuth Gateway FD", "Xbox Active Auth Gateway Server Performance Counters - Global counters" )]
    public class GatewayGlobalCounters : XomPerformanceCounterCategory
    {
        static public GatewayGlobalCounters Counters = new GatewayGlobalCounters();

        public virtual GatewayGlobalCounters this[string instance]
        {
            get
            {
                return (GatewayGlobalCounters) GetInstance(instance);
            }
        }

        [XomPerformanceCounterAttr(
             "Bytes: Received Per Sec", 
             "Number of bytes received from the Internet per second", 
             PerformanceCounterType.RateOfCountsPerSecond64)]
        public PerformanceCounter BytesRecvPerSec;

        [XomPerformanceCounterAttr(
             "Bytes: Sent Per Sec", 
             "Number of bytes sent to the Internet per second", 
             PerformanceCounterType.RateOfCountsPerSecond64)]
        public PerformanceCounter BytesSentPerSec;

        // Totals across all requests served by the gateway
        [XomPerformanceCounterAttr(
             "Requests: Total", 
             "Total number of requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequests;

        [XomPerformanceCounterAttr(
             "Requests: In Progress", 
             "Number of requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgress;

        [XomPerformanceCounterAttr(
             "Requests: Per Sec", 
             "Number of requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSec;

        [XomPerformanceCounterAttr(
             "Requests: Avg. Execution Time", 
             "Average request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTime;

        [XomPerformanceCounterAttr(
             "Requests: Avg. Execution Time Base", 
             "Base for the average request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBase;
    } 

    
} // namespace xonline.server.activeauth.gateway
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\gateway\Block_InstanceSettingsHealth.cs ===
using System;
using System.Configuration;
using System.Collections.Specialized;
using xonline.server.activeauth.common;
using xonline.common.health;

namespace xonline.server.activeauth.gateway
{
    // -----------------------------------------------------------------------------------
    // AuthSGInstanceSettingsHealth class holds information about the AuthSG instance for
    // this service bank.
    // -----------------------------------------------------------------------------------
    public class AuthSGInstanceSettingsHealth : IHealthBlock
    {
        public ResourceTypeEnum ResourceType 
        { 
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(
            HealthBlockManager  blockManager,
            NameValueCollection blockParams,
            HealthReport        report)
        {
            AuthSGInstanceSettingsHealthReport instanceReport = new AuthSGInstanceSettingsHealthReport();
            report.ExtendedReport = instanceReport;            

            try
            {
                instanceReport.authSGInstanceName = AuthConfig.InstanceName;
                instanceReport.authSGMaxConcurrentConnections = AuthConfig.MaxConcurrentConnections;
                instanceReport.authSGEnableRequestPipelining = AuthConfig.EnableRequestPipelining;
                report.HealthStatus = HealthStatusEnum.Green;
            }
            catch (ConfigurationErrorsException ex)
            {
                report.ErrorDetails = String.Format("Error accessing authSG instance settings: \n{0}", ex.ToString());
                report.HealthStatus = HealthStatusEnum.Red;
            }
        }
    }

    public class AuthSGInstanceSettingsHealthReport : IExtendedHealthReport
    {
        public string authSGInstanceName;
        public int authSGMaxConcurrentConnections;
        public bool authSGEnableRequestPipelining;

        public AuthSGInstanceSettingsHealthReport()
            : base()
        {
            authSGInstanceName = String.Empty;            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\gateway\GatewayApp.cs ===
//
// GatewayApp.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Active Auth Gateway Service
// Xbox Online Service
//
// Author: kgoodier 6/2007
//

using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Web;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Net;
using System.Web.Configuration;

using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.installer;

using xonline.server.activeauth.common;

[assembly: XomInstaller( Interface.authsg, typeof(xonline.common.installer.XomAuthSGConfigurator) )]
[assembly: XomInstaller( Interface.authsg_int, typeof(xonline.common.installer.XomAuthSGConfigurator) )]
[assembly: XomInstaller( Interface.authsg_ssl, typeof(xonline.server.activeauth.gateway.XomAuthSGInstancedConfigurator) )]
[assembly: ConfigAttribute(Component.authsg)]

namespace xonline.server.activeauth.gateway
{

// -----------------------------------------------------------------------------
// GatewayApp class - the main application class
// -----------------------------------------------------------------------------
public class GatewayApp : FrontEndApp
{
    public GatewayApp()
        : base(false)  // we'll do our own per-api counters
    {
    }

    // -------------------------------------------------------------------------
    // Application_Start - called once when the front door starts up
    // -------------------------------------------------------------------------
    protected override void OnApplicationStart()
    {
        Trace.High("------------------------------------------------------------------------");
        Trace.High("AuthSG Application_Start");
        Trace.High("------------------------------------------------------------------------");
        
        // Our events should not retrieve SGInfo, ever.
        EventBuilder.ShowSGInfo = false;

        // Tell XMgmt that we want our handler called for control requests
        XomControl.ControlRequestEvent +=
            new XomControl.ControlRequestEventHandler(
                GatewayXomCallback.OnControlRequest
                );

        // Grab settings

        HttpRuntimeSection runtimeSection = (HttpRuntimeSection) 
            WebConfigurationManager.GetSection("system.web/httpRuntime");

        if (runtimeSection != null) {
            _GatewayMaximumRequestLength = runtimeSection.MaxRequestLength * 1024;
        }

        _GatewayTimeoutMilliseconds = GetIntSettingWithDefault(Setting.authsg_gatewayTimeoutSeconds, 60) * 1000;
        Trace.High("StaticInit: GatewayTimeoutMilliseconds is now {0}", _GatewayTimeoutMilliseconds);

        _RequestTimeoutMilliseconds = GetIntSettingWithDefault(Setting.authsg_requestTimeoutSeconds, 60) * 1000;
        Trace.High("StaticInit: RequestTimeoutMilliseconds is now {0}", _RequestTimeoutMilliseconds);

        // Service forwarding table
        Trace.High("Initializing forwarding service table");
        InitializeServiceTable();

        // Register for setting changes
        Config.SettingChange += new SettingChangeEventHandler(OnSettingChange);
        Config.XrlMappingsChange += new XrlMappingsChangeEventHandler(OnXrlMappingsChange);
        Config.VirtualInterfaceChange += new VirtualInterfaceChangeEventHandler(OnVirtualInterfaceChange);

        //Load up the policies from the active auth policies table
        //so that we can look up headers ingoing/outgoing by policy
        Trace.High("Initializing policy data");
        InitializePolicyData();

        Xom.NtEvent( XEvent.Id.AAGW_CONFIG_INFO,
            "Successfully initialized ActiveAuth gateway."
        );

        // Spam
        Trace.Normal( "Active auth gateway started" );
    }

    // -------------------------------------------------------------------------
    // Application_BeginRequest - called at the beginning of every request
    // -------------------------------------------------------------------------
    public override void Application_BeginRequest( object sender, EventArgs e )
    {
        // Call the base class
        base.Application_BeginRequest( sender, e );

        // Perfcounters
        GatewayGlobalCounters.Counters.RequestsInProgress.Increment();

        Trace.Normal("BeginRequest({0})", HttpContext.Current.Request.RawUrl);
    }

    // -------------------------------------------------------------------------
    // Application_EndRequest - called at the end of every request
    // -------------------------------------------------------------------------
    public override void Application_EndRequest( object sender, EventArgs e )
    {
        // Perf counters
        GatewayGlobalCounters.Counters.RequestsInProgress.Decrement();
        GatewayGlobalCounters.Counters.TotalRequests.Increment();
        GatewayGlobalCounters.Counters.RequestsPerSec.Increment();

        GatewayGlobalCounters.Counters.AverageExecutionTimeBase.Increment();
        GatewayGlobalCounters.Counters.AverageExecutionTime.IncrementBy(
            TimeElapsed
            );

        // Call the base class
        base.Application_EndRequest(sender, e);

        Trace.Normal("EndRequest({0}), {1} ms",
            HttpContext.Current.Request.RawUrl,
            MillisecondsElapsed.ToString()
        );
    }

    public static Dictionary<string, ServiceNode> Services
    {
        get
        {
            return _Services;
        }
    }

    public static PolicyManager GatewayPolicyManager
    {
        get
        {
            return _PolicyMgr;
        }
    }

    internal static bool TryLookupRoutingPolicy(ApiPolicy policy, string url, out IRouteInfo foundRoute)
    {
        if (string.IsNullOrEmpty(policy.HostNameMapping))
        {
            ServiceNode service;

            if (TryLookupService(url, out service))
            {
                foundRoute = service as IRouteInfo;
                return true;
            }
        }
        else
        {
            foundRoute = new ApiPolicyRouteInfo(policy);
            return true;
        }

        foundRoute = null;
        return false;
    }

    // -------------------------------------------------------------------------
    // Looks up a service for a url
    // -------------------------------------------------------------------------
    public static bool TryLookupService(string url, out ServiceNode foundService)
    {
        string urlLower = url.ToLower(); //Currently there is only one caller that already does this.  Leaving this here to protect against future changes.

        // Look for an exact match
        if (Services.TryGetValue(urlLower, out foundService))
        {
            return true;
        }

        // Look for a partial match
        List<KeyValuePair<string, ServiceNode>> partialMatchServices = _ServicesForPartialMatch; //use a local reference in case partialMatchServices is changed during the call

        foreach (KeyValuePair<string, ServiceNode> service in partialMatchServices)
        {
            if (urlLower.StartsWith(service.Key))
            {
                foundService = service.Value;
                return true;
            }
        }

        foundService = null;
        return false;
    }

    // -------------------------------------------------------------------------
    // Reload - performs a dynamic reload of this app. Expected to be called by an xmgmt 
    // command.
    // -------------------------------------------------------------------------
    public static void Reload()
    {
        Trace.Normal("Reinitialize Begin");
        InitializeServiceTable();
        Trace.Normal("Reinitialize Complete");

        Trace.Normal("Reinitialize Policy Manager");
        InitializePolicyData();
        Trace.Normal("Reinitialize Policy Manager Complete");
    }

    // -------------------------------------------------------------------------
    // InitializeServiceTable - loads the global url forwarding service table.
    // -------------------------------------------------------------------------
    public static void InitializeServiceTable()
    {
        Dictionary<string, ServiceNode> services =
            new Dictionary<string, ServiceNode>(
                StringComparer.CurrentCultureIgnoreCase
                );

        List<KeyValuePair<string, ServiceNode>> servicesForPartialMatch;

        // Call the protected function that will find in the service table
        LoadForwardingServiceTable(services);

        servicesForPartialMatch = BuildPartialServiceMatchTable(services);

        // Swap in the new settings
        _Services                = services;
        _ServicesForPartialMatch = servicesForPartialMatch;
    }

    // -------------------------------------------------------------------------
    // Builds the list of XRLs that allow for partial name matches.
    // -------------------------------------------------------------------------
    private static List<KeyValuePair<string, ServiceNode>> BuildPartialServiceMatchTable(Dictionary<string, ServiceNode> services)
    {
        List<KeyValuePair<string, ServiceNode>> servicesForPartialMatch = new List<KeyValuePair<string, ServiceNode>>();

        foreach (KeyValuePair<string, ServiceNode> service in services)
        {
            if (service.Value._allowNoExactMatch)
            {
                servicesForPartialMatch.Add(service); //note that the key in services already been ToLowered() in LoadForwardingServiceTable, so we can re-use the pair as-is.
            }
        }

        return servicesForPartialMatch;
    }

    // ------------------------------------------------------------------------
    // LoadForwardingServiceTable - gets list of services (proxy destinations) from the 
    // npdb, specifically the t_xrl_get_virtual_interface_mappings table where the 
    // ti_authsg column is true.
    // ------------------------------------------------------------------------
    private   static void LoadForwardingServiceTable(
        Dictionary<string, ServiceNode> Services
        )
    {
        SqlConnection  npdbCnt;

        Trace.Normal("LFST - Start");
        using (npdbCnt = new SqlConnection(Config.NpdbConnectionString))
        {
            npdbCnt.Open();

            SqlCommand sqlCmd = new SqlCommand(
                "p_authsg_get_forward_service_list",
                npdbCnt
                );
            sqlCmd.CommandType = CommandType.StoredProcedure;

            using (SqlDataReader sqlReader = sqlCmd.ExecuteReader())
            {
                int row = 0;

                while (sqlReader.Read())
                {
                    int i;

                    //
                    // Check for nulls
                    //
                    for (i = 0; i < 6; ++i)
                    {
                        if (sqlReader.IsDBNull(i))
                        {
                            throw new Exception(
                                "Row " +
                                row.ToString() +
                                " Element " +
                                i.ToString() +
                                " is null."
                                );
                        }
                    }

                    // Create a new service node
                    ServiceNode newService = new ServiceNode();

                    // Get the XRL
                    string xrl = "";
                    xrl = sqlReader.GetString(0).ToLower();

                    try
                    {
                        string strVirtualInterface = sqlReader.GetString(1);

                        // Convert the virtual interface string to an enum value
                        newService._viface = strVirtualInterface;

                        // Fill in the Site ID
                        newService._siteid = sqlReader.GetInt32(2);

                        // Fill in the Max URL length
                        newService._maxUrlLength = sqlReader.GetInt32(3);

                        // Fill in the Max Content Length
                        newService._maxContentLength = sqlReader.GetInt32(4);

                        // Fill in the max Query String Length
                        newService._maxQueryStringLength = sqlReader.GetInt32(5);

                        // Fill in the allow no exact match option
                        newService._allowNoExactMatch = (0 != sqlReader.GetByte(6));

                    } catch (ArgumentException e)
                    {
                        throw new Exception(
                            "Virtual Interface element '" +
                            sqlReader.GetString(1) +
                            "' is not a valid virtual interface name.",
                            e);
                    }

                    // Place the service in the hash table
                    Services[ xrl ] = newService;
                    Trace.Low(
                        "Service[{0}] = [{1},{2},{3},{4},{5},{6}]",
                        xrl,
                        newService._siteid,
                        newService._viface,
                        newService._maxUrlLength,
                        newService._maxContentLength,
                        newService._maxQueryStringLength,
                        newService._allowNoExactMatch
                        );

                    // Next row
                    row++;
                }

            }

            npdbCnt.Close();
        }
        Trace.Normal("LFST - End");

    }


    // ------------------------------------------------------------------------
    // ListServices - xmgmt command handler, lists all configured services (proxy 
    // destinations).
    // ------------------------------------------------------------------------
    public static string ListServices( )
    {
        StringBuilder                   sb       = new StringBuilder();
        Dictionary<string, ServiceNode> services = null;

        // Local copy of store to prevent exchanges from underneath us
        services = GatewayApp.Services;

        if (services == null)
        {
            sb.AppendFormat("No Services Found.\r\n");
            return sb.ToString();
        }

        foreach (KeyValuePair<string, ServiceNode> kvp in services)
        {
            ServiceNode service = (ServiceNode) kvp.Value;

            // Grab the virtual interface
            IVirtualInterfaceInfo serviceVInterface = Config.GetVirtualInterface(
                service._viface,
                service._siteid
                );

            sb.AppendFormat(
                "{0}\r\n" +
                "    Site Id:    {2,-8} Interface:  {1}\r\n" +
                "    Max URL:    {5,-8} Max Query:  {6,-8} Max Content: {7,-8}  Exact Match:{8}\r\n" +
                "    IP Address: {3}:{4}\r\n\r\n",
                kvp.Key,
                service._viface,
                service._siteid,
                serviceVInterface.IPAddressString,
                serviceVInterface.Port.ToString(),
                service._maxUrlLength,
                service._maxQueryStringLength,
                service._maxContentLength,
                !service._allowNoExactMatch
                );

        }
        sb.AppendFormat("Number of services: {0}\r\n", services.Count);
        return sb.ToString();
    }

    // -------------------------------------------------------------------------
    // OnSettingChange - handles changes to npdb settings
    // -------------------------------------------------------------------------
    public static void OnSettingChange(object sender, SettingChangeEventArgs eventArgs)
    {
        int value;

        try
        {
            switch (eventArgs.Setting)
            {
                case Setting.authsg_gatewayTimeoutSeconds:
                    if (Int32.TryParse(eventArgs.ValueNew, out value))
                    {
                        _GatewayTimeoutMilliseconds = value * 1000;
                        Trace.High("OnSettingChange: GatewayTimeoutMilliseconds is now {0}", _GatewayTimeoutMilliseconds);
                        return;
                    }

                    break;

                case Setting.authsg_requestTimeoutSeconds:
                    if (Int32.TryParse(eventArgs.ValueNew, out value))
                    {
                        _RequestTimeoutMilliseconds = value * 1000;
                        Trace.High("OnSettingChange: RequestTimeoutMilliseconds is now {0}", _RequestTimeoutMilliseconds);
                        return;
                    }

                    break;
            }
        }
        catch (Exception e)
        {
            throw new XRLException(
                XblException.GetHResult(e), XEvent.Id.AAGW_CONFIG_INVALID_SETTING, e,
                "Error parsing setting {0}, value = '{1}'", eventArgs.Setting, eventArgs.ValueNew
            );
        }
    }

    // -------------------------------------------------------------------------
    // OnXrlMappingsChange - handles changes to t_xrl_virtual_interface_mappings
    // -------------------------------------------------------------------------
    public static void OnXrlMappingsChange(object sender, EventArgs eventArgs)
    {
        // No info in the event args, so reload everything.
        Trace.High("OnXrlMappingsChange: Initializing forwarding service table");
        InitializeServiceTable();
    }

    // -------------------------------------------------------------------------
    // OnVirtualInterfaceChange - handles changes to virtual interface in NPDB
    // -------------------------------------------------------------------------
    public static void OnVirtualInterfaceChange(object sender, EventArgs eventArgs)
    {
        // We don't need to do anything here.  We are only handling this
        // event because if we don't we do not get the changes
    }

    // -------------------------------------------------------------------------
    // GetIntSettingWithDefault - parses an npdb setting into an int, using a default 
    // value if something goes wrong (also logs an event).
    // -------------------------------------------------------------------------
    public static int GetIntSettingWithDefault(string setting, int defaultVal)
    {
        int val;
        string strVal = Config.GetSetting(setting); 
        if (!Int32.TryParse(strVal, out val))
        {
            Xom.NtEvent(XEvent.Id.AAGW_CONFIG_INVALID_SETTING, 
                "Error parsing setting {0} ({1})",
                setting, strVal
            );

            val = defaultVal;
        }
        return val;
    }

    public static int InitializePolicyData()
    {
        if (_PolicyMgr == null)
        {
            _PolicyMgr = new PolicyManager();
        }

        int count = 0;

        try
        {
            count = _PolicyMgr.Reload();
        }
        catch(Exception)
            {
                Xom.NtEvent(XEvent.Id.AAGW_CONFIG_INVALID_SETTING, "Unable to load activeauth policies"); 
            }

        return count;
    }

    public static int RequestTimeoutMilliseconds {
        get { return _RequestTimeoutMilliseconds; }
    }

    public static int GatewayTimeoutMilliseconds {
        get { return _GatewayTimeoutMilliseconds; }
    }

    public static int GatewayMaximumRequestLength
    {
        get { return _GatewayMaximumRequestLength; }
    }

    // -------------------------------------------------------------------------
    // Private Static Members
    // -------------------------------------------------------------------------
    private static volatile Dictionary<string, ServiceNode>         _Services = null;
    private static volatile List<KeyValuePair<string, ServiceNode>> _ServicesForPartialMatch = null;
    private static volatile PolicyManager                           _PolicyMgr = null;

    // these values are immediately overwritten in application start.
    private static volatile int _RequestTimeoutMilliseconds  = 60000;
    private static volatile int _GatewayTimeoutMilliseconds  = 60000;
    private static volatile int _GatewayMaximumRequestLength = 4 * 1024 * 1024;
}

public interface IRouteInfo
{
    bool IsXRLMapping { get; }

    int MaxUrlLength { get; }

    int MaxContentLength { get; }

    int MaxQueryStringLength { get; }
}

public class ServiceNode : IRouteInfo
{
    public string           _viface;
    public int              _siteid;
    public int              _maxUrlLength;
    public int              _maxContentLength;
    public int              _maxQueryStringLength;
    public bool             _allowNoExactMatch;

    // IRouteInfo Implementation
    public bool IsXRLMapping { get { return true; } }

    public int MaxUrlLength { get { return _maxUrlLength; } }

    public int MaxContentLength { get { return _maxContentLength; } }

    public int MaxQueryStringLength { get { return _maxQueryStringLength; } }
}

internal class ApiPolicyRouteInfo : IRouteInfo
{
    private ApiPolicy   _apiPolicy = null;

    public ApiPolicyRouteInfo(ApiPolicy p)
    {
        this._apiPolicy = p;
    }

    public bool IsXRLMapping
    {
        get { return false; }
    }

    public int MaxUrlLength
    {
        get { return this._apiPolicy.MaxUrlLength; }
    }

    public int MaxContentLength
    {
        get { return this._apiPolicy.MaxContentLength; }
    }

    public int MaxQueryStringLength
    {
        get { return this._apiPolicy.MaxQueryStringLength; }
    }

    public string HostNameMapping
    {
        get { return this._apiPolicy.HostNameMapping; }
    }
}


// Custom healthcheck to block requests on the external interface.

public class AuthsgHealthcheck : xonline.common.health.BaseHealthRequest
{
    public override void ProcessRequest( HttpContext ctx )
    {

        IInterfaceInfo iinfo;
        iinfo = Config.GetInterface(Interface.authsg_int);
        int reqPort = CallSource.GetPort(ctx); 

        if (reqPort != iinfo.Port)
        {
            // not on the authsg_int interface, block it
            ctx.Response.StatusCode = (int)HttpStatusCode.NotFound; // 404
        }
        else
        {
            // it's ok, let it through
            base.ProcessRequest(ctx);
        }
    }

}



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\gateway\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\gateway\RequestHeaderHandler.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Web;

using xonline.common.service;

namespace xonline.server.activeauth.gateway
{
    public class RequestHeaderHandler
    {
        public static void Copy(string name, HttpRequest src, HttpWebRequest dest)
        {
            switch (name = name.ToLowerInvariant())
            {
                case "accept"            : dest.Accept = src.Headers["accept"];    break;
                case "connection"        : throw new NotImplementedException();
                case "content-length"    : dest.ContentLength = src.ContentLength; break;
                case "content-type"      : dest.ContentType = src.ContentType;     break;
                case "date"              :                                         break;
                case "expect"            : dest.Expect = src.Headers["expect"];    break;
                case "host"              :                                         break;

                case "if-modified-since" :
                    DateTime dateTime;

                    if (DateTime.TryParse(src.Headers["if-modified-since"], out dateTime))
                    {
                        dest.IfModifiedSince = dateTime;
                    }

                    break;

                case "referer"           : dest.Referer = src.Headers["referer"];  break;
                case "range"             : RangeHandler(src, dest);                break;
                case "transfer-encoding" : TransferEncodingHandler(src, dest);     break;
                case "user-agent"        : dest.UserAgent = src.UserAgent;         break;



                default:
                    dest.Headers.Add(name, src.Headers[name]);
                    break;
            }
        }

        
        // -------------------------------------------------------------------------
        // http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
        // A byte range operation MAY specify a single range of bytes, or a set of ranges within a single entity.
        //   ranges-specifier = byte-ranges-specifier
        //   byte-ranges-specifier = bytes-unit "=" byte-range-set
        //   byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )
        //   byte-range-spec = first-byte-pos "-" [last-byte-pos]
        //   first-byte-pos  = 1*DIGIT
        //   last-byte-pos   = 1*DIGIT
        // -------------------------------------------------------------------------
        private static void RangeHandler(HttpRequest src, HttpWebRequest dest)
        {
            try
            {
                string[] byteRangesSpecifiers = src.Headers["range"].Split('=');
                string bytesUnit = null;
                string[] rangeSets = null;

                if (2 == byteRangesSpecifiers.Length)
                {
                    bytesUnit = byteRangesSpecifiers[0];
                    rangeSets = byteRangesSpecifiers[1].Split(',');
                }

                if (!string.IsNullOrEmpty(bytesUnit))
                {
                    foreach (string rangeSet in rangeSets)
                    {
                        string[] bytePos = rangeSet.Split('-');
                        int firstBytePos;
                        int lastBytePos;

                        if (2 == bytePos.Length)
                        {
                            if (0 == bytePos[1].Length)
                            {
                                firstBytePos = int.Parse(bytePos[0]);
                                dest.AddRange(bytesUnit, firstBytePos);
                            }
                            else if (0 == bytePos[0].Length)
                            {
                                lastBytePos = int.Parse(bytePos[1]) * -1;
                                dest.AddRange(bytesUnit, lastBytePos);
                            }
                            else
                            {
                                firstBytePos = int.Parse(bytePos[0]);
                                lastBytePos = int.Parse(bytePos[1]);
                                dest.AddRange(bytesUnit, firstBytePos, lastBytePos);
                            }
                        }
                    }
                }
            }
            catch
            {
                // http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
                // The recipient of a byte-range-set that includes one or more syntactically invalid byte-range-spec
                // values MUST ignore the header field that includes that byte-range-set.
                // AKA The entire range set should be ignored if there are any errors in it.
            }
        }


        // -------------------------------------------------------------------------
        // The .Net implementation doesn't seem to agree exactly with the rfc as "chunked" 
        // doesn't seem to be a required value, just one possible value.
        // However the below implementation should at least work given a valid value is 
        // copied from the src header and the SendChunked property does the right thing.
        //
        // http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.41
        // The Transfer-Encoding general-header field indicates what (if any) type of transformation
        // has been applied to the message body in order to safely transfer it between the sender
        // and the recipient. This differs from the content-coding in that the transfer-coding
        // is a property of the message, not of the entity.
        //      Transfer-Encoding       = "Transfer-Encoding" ":" 1#transfer-coding
        // Transfer-codings are defined in section 3.6. An example is: 
        //      Transfer-Encoding: chunked
        // If multiple encodings have been applied to an entity, the transfer- codings MUST be
        // listed in the order in which they were applied. Additional information about the 
        // encoding parameters MAY be provided by other entity-header fields not defined by this specification.
        //
        // http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6
        // Transfer-coding values are used to indicate an encoding transformation that has been,
        // can be, or may need to be applied to an entity-body in order to ensure "safe transport"
        // through the network. This differs from a content coding in that the transfer-coding
        // is a property of the message, not of the original entity.
        //        transfer-coding         = "chunked" | transfer-extension
        //        transfer-extension      = token *( ";" parameter )
        // Parameters are in the form of attribute/value pairs. 
        //        parameter               = attribute "=" value
        //        attribute               = token
        //        value                   = token | quoted-string
        //
        // http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6
        // Whenever a transfer-coding is applied to a message-body, the set of transfer-codings MUST 
        // include "chunked", unless the message is terminated by closing the connection. 
        // When the "chunked" transfer- coding is used, it MUST be the last transfer-coding 
        // applied to the message-body. The "chunked" transfer-coding 
        // MUST NOT be applied more than once to a message-body. 
        // -------------------------------------------------------------------------
        public static void TransferEncodingHandler(HttpRequest src, HttpWebRequest dest)
        {
            string header = src.Headers["Transfer-Encoding"].Trim();

            int idx = header.LastIndexOf(",", StringComparison.OrdinalIgnoreCase);
            if (idx >= 0)
            {
                if (string.Equals(header.Substring(idx + 1).Trim(), "chunked", StringComparison.OrdinalIgnoreCase))
                {
                    dest.SendChunked = true;
                    dest.TransferEncoding = header.Substring(0, idx).Trim();
                }
                else
                {
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_AUTHSG_TRANSFERENCODING_HEADER_NOTVALID,
                        "When the chunked transfer- coding is used, it MUST be the last transfer-coding applied to the message-body.");
                }
            }
            else if (string.Equals(src.Headers["Transfer-Encoding"], "chunked", StringComparison.OrdinalIgnoreCase))
            {
                dest.SendChunked = true;
            }
            else
            {
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_AUTHSG_TRANSFERENCODING_HEADER_NOTVALID, "Transfer-Encoding header MUST include chunked.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\gateway\XomAuthSGInstancedConfigurator.cs ===
/*

AuthSGInstancedConfigurator class

This class overrides the behavior of the XomAuthSGConfigurator class to pick
instance specific cert identifiers from site.xml. It basically changes the
SSL identifier used to access site.xml to the Info1 value in npdb + ".<instanceName>" 
*/

using System;
using xonline.common.installer;
using xonline.server.activeauth.common;

namespace xonline.server.activeauth.gateway
{
    public class XomAuthSGInstancedConfigurator : XomAuthSGConfigurator
    {
        public override string SSLInfoIdentifier
        {
            get
            {
                string sslInfoIdentifier = base.SSLInfoIdentifier;
                return string.Format("{0}.{1}", sslInfoIdentifier, AuthConfig.InstanceNameInInstallerContext);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\module\AssemblyInfo.cs ===
using System.Reflection;

[assembly: AssemblyTitle("Xbox Live Active Auth Module")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\module\ModuleMgmt.cs ===
// 
// ModuleMgmt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Active Auth Module
// Xbox Online Service
//
// Provides XMGMT command handling, output wrappers, etc.
//
// Author: kgoodier 6/2007
//

using System;

using xonline.common.config;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.log)]
[assembly: XomAreaDefinition(XomAreaName.aamodule)]

namespace xonline.server.activeauth.module
{
    // -----------------------------------------------------------------------------------
    // ModuleXomCallback class - XMgmt callback handler class
    // -----------------------------------------------------------------------------------
    public class ModuleXomCallback
    {
        private const string c_HelpText = @"
Active Auth Module help:
  reload         : Reloads the list of policies from the database
  listpolicies   : List currently loaded policies
  listclients    : List currently tracked client records when anti-dos tracking is on
  listips        : List currently configured ip overrides
  healthcheck    : Returns information about the state of the module
";

        // -------------------------------------------------------------------------------
        // OnControlRequest - called by XMgmt when a control request is sent
        // -------------------------------------------------------------------------------
        public static void OnControlRequest( object sender, ControlRequestEventArgs args )
        {
            string str = null;
            try
            {
                switch(args.Command)
                {

                case "help":
                    str = c_HelpText;
                    break;

                case "reload":
                    if (ActiveAuthModule.PolicyMgr == null)
                    {
                        str = "PolicyMgr has not been initialized. Please report.";
                    }
                    else
                    {
                        str = ActiveAuthModule.ReloadPartners();
                        int count = ActiveAuthModule.PolicyMgr.Reload();
                        str += String.Format("Reloaded {0} policies.", count);
                    }
                    break;

                case "listpolicies":
                    if (ActiveAuthModule.PolicyMgr == null)
                    {
                        str = "PolicyMgr has not been initialized. Please report.";
                    }
                    else
                    {
                        string command = (0 < args.CommandArgs.Length) ? args.CommandArgs[0] : null;
                        str = ActiveAuthModule.PolicyMgr.ListPolicies(command);
                    }
                    break;

                case "listclients":
                    if (ActiveAuthModule.ReqTracker == null)
                    {
                        str = "RequestTracker has not been initialized. Please report.";
                    }
                    else
                    {
                        str = ActiveAuthModule.ReqTracker.GetReportAllClients();
                    }
                    break;

                case "listips":
                    if (ActiveAuthModule.IpRanges == null)
                    {
                        str = "IpRanges has not been intialized. Please report.";
                    }
                    else
                    {
                        str = ActiveAuthModule.IpRanges.ToString();
                    }
                    break;

                case "healthcheck":
                    str = ActiveAuthModule.HealthCheck();
                    break;

                }
            }
            catch(Exception e)
            {
                str = "Error: " + e.ToString();
            }

            if (str != null)
            {
                XomControlConnection.SendMessage( str + "\r\n\r\n", args.RequestId );
                args.Handled = true;
            }
        }
    } 


    // -------------------------------------------------------------------------------
    // Trace class - handy wrappers for making tracing prettier and easier
    //
    // Bloody XomTrace macro means I have to copy & paste this class to use different 
    // tracing areas.
    // -------------------------------------------------------------------------------
    internal static class Trace
    {
        internal static void Low(string format, params object[] args)
        {
            Xom.Trace(XomAreaName.aamodule, LogLevel.L_LOW, Timestamp + format, args);
        }

        internal static void Normal(string format, params object[] args)
        {
            Xom.Trace(XomAreaName.aamodule, LogLevel.L_NORMAL, Timestamp + format, args);
        }

        internal static void High(string format, params object[] args)
        {
            Xom.Trace(XomAreaName.aamodule, LogLevel.L_HIGH, Timestamp + format, args);
        }

        internal static void Error(string format, params object[] args)
        {
            Xom.Trace(XomAreaName.aamodule, LogLevel.L_ERROR, Timestamp + format, args);
        }

        private static string Timestamp
        {
            get 
            {
                DateTime dt = DateTime.Now;
                return dt.ToString(@"hh:mm:ss.fff ");
            }
        }


    }



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\module\ModuleMain.cs ===
//
// ModuleMain.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Active Auth Module
// Xbox Online Service
//
// Provides authentication, DOS protection, and more for interested HTTP handlers.
//
// Author: kgoodier 6/2007
//

using System;
using System.Diagnostics;
using System.IO;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using System.Web;
using System.IdentityModel.Selectors;
using System.IdentityModel.Tokens;
using System.ServiceModel.Security;
using System.Collections.Generic;

using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.passport;
using xonline.common.utilities2;
using xonline.common.exceptions;

using xonline.config.sts.interfaces;

using Microsoft.IdentityModel.Web;
using Microsoft.IdentityModel.Web.Configuration;
using Microsoft.IdentityModel.Tokens;
using xonline.server.activeauth.common;

namespace xonline.server.activeauth.module
{

// "a reference to a volatile field will not be treated as volatile"
#pragma warning disable 420

// -----------------------------------------------------------------------------------
// ActiveAuthModule class - the main http module class
// -----------------------------------------------------------------------------------
public class ActiveAuthModule : IHttpModule
{

    public ActiveAuthModule()
    {
        StaticInit();

        Trace.Normal("----------------------------------------");
        Trace.Normal("ActiveAuthModule instantiated");
        Trace.Normal("----------------------------------------");

        ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].TotalInstances.RawValue = _RefCount;
    }

    public String ModuleName
    {
        get { return "ActiveAuthModule"; }
    }

    public void Dispose()
    {
        Trace.Normal("----------------------------------------");
        Trace.Normal("ActiveAuthModule disposed");
        Trace.Normal("----------------------------------------");

        InstanceDispose();

    }

    // -------------------------------------------------------------------------------
    // Init - called by ASP.NET upon init time. We should register for callbacks here if
    // we want to do real work.  Seems to be called when this object is instantiated,
    // which is not for every call.
    // -------------------------------------------------------------------------------
    public void Init(HttpApplication application)
    {
        Trace.Normal("ActiveAuthModule.Init called");

        // Event hooks always need to be added to the application state
        application.AuthenticateRequest += new EventHandler(this.Application_AuthenticateRequest);
        application.EndRequest += new EventHandler(this.Application_EndRequest);
    }

    public static string ReloadPartners()
    {
        IIEBBusinessPartnerConfigurationProvider configProvider = (IIEBBusinessPartnerConfigurationProvider)new xonline.config.sts.databaseconfig.DatabaseConfigurationProvider();

        if (null != configProvider)
        {
            try
            {
                configProvider.Load();
            }
            catch (Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_XSTS_CONFIGURATIONPROVIDER_LOAD, XEvent.Id.XSTS_FD_CONFIGURATIONPROVIDER_LOAD_ERROR, e, "Error calling ISTSConfigurationProvider::Load");
            }
            _Partners = configProvider.IEBBusinessPartners;
            return String.Format("Loaded {0} partners.\r\n", ActiveAuthModule._Partners.Count);
        }
        else
        {
            return "";
        }
    }

    // -------------------------------------------------------------------------------
    // StaticInit - the once-per-module init routine
    // -------------------------------------------------------------------------------
    private static void StaticInit()
    {
        if (_RefCount > 0)
        {
            // Add ourself and get out, someone else has already done the initialization
            Interlocked.Increment(ref _RefCount);
            return;
        }

        // We may be one of the first people to come in. Whether we are or not, we want to
        // block until initialization is done.

        lock(_ConfigLock)
        {
            if (_RefCount > 0)
            {
                // Someone else snuck in
                Interlocked.Increment(ref _RefCount);
                return;
            }

            try
            {

                // Our events should not retrieve SGInfo. Duh.
                EventBuilder.ShowSGInfo = false;

                // Partner setting to not use connection server for partner (LIVEn) deployments of Active Auth Module
                XomControl.ConnectToXmgmt = !Config.GetBoolSetting(Setting.aamodule_suppress_xmgmt_connection);
                
                // FEAPP normally does these
                XomLoggingControl.Init();
                XomPerformanceCounterCategory.InitPerfCtrs();

                Trace.Normal("----------------------------------------");
                Trace.Normal("ActiveAuthModule.StaticInit running");
                Trace.Normal("----------------------------------------");

                // Tell XMgmt that we want our handler called for control requests
                XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler( ModuleXomCallback.OnControlRequest );
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.AAM_CONFIG_ERROR, e,
                    "Error initializing the ActiveAuthModule base components."
                );

                throw;
            }

            try
            {
                string eventMsg = "";

                // Policies
                if (ActiveAuthModule._PolicyMgr != null)
                {
                    Trace.High("  PolicyMgr is not null. This is unexpected.");
                }
                ActiveAuthModule._PolicyMgr = new PolicyManager();
                eventMsg += String.Format("Loaded {0} policies.\r\n", ActiveAuthModule._PolicyMgr.Count);

                eventMsg += ReloadPartners();

                //
                // AntiDos config
                //

                // Request tracking, for antidos
                _ReqTracker = new RequestTracker(
                    Config.GetSetting(Setting.aamodule_antidosTrackingThreshold),
                    Config.GetSetting(Setting.aamodule_antidosThrottlingThreshold),
                    Config.GetSetting(Setting.aamodule_antidosBlockingThreshold),
                    int.Parse(Config.GetSetting(Setting.aamodule_antidosMaxRecordsToTrack)),
                    int.Parse(Config.GetSetting(Setting.aamodule_antidosBanTimeInSeconds)));
                eventMsg += String.Format("Loaded RequestTracker:\r\n{0}\r\n", _ReqTracker.ToString());

                // IP overrides for counts & ranges
                _IpRanges = new IpRangeList<IpRecord>(Config.GetMultiSetting(MultiSetting.aamodule_antidosIpOverrides));
                eventMsg += String.Format("Loaded IP range overrides:\r\n{0}\r\n", _IpRanges.ToString());

                XBanc.Init();

                // XBL1.0 - certificates
                string certSubject = Config.GetSetting(Setting.sts_cert_subject);

                try
                {
                    _XblCertificates = XblSamlToken.GetCertificateBySubjectName(certSubject, false, false);
                }
                catch (XblException e)
                {
                    if ( HResult.XONLINE_E_XBOXLIVETOKEN_CERT_CONFIG == e.HResult )
                        Xom.NtEvent(XEvent.Id.AAM_CONFIG_WARNING, e, "AAModule not configured for XBL1.0 support.");
                    else
                        throw;
                }

                // XBL1.0 - EKU multi settings
                _XblEnhancedKeyUsages = Config.GetMultiSetting(MultiSetting.aamodule_XblEnhancedKeyUsages);
                if (null == _XblEnhancedKeyUsages || 0 == _XblEnhancedKeyUsages.Length)
                    _XblEnhancedKeyUsages = new string[] {"1.3.6.1.4.1.311.71.1.1"};

                // RPS Site Names
                _RpsSiteNames = TrimAll(Config.GetMultiSetting(MultiSetting.aamodule_rpsSiteNames));

                // RPS Delegation Site Names
                _RpsDelegationSiteNames = TrimAll(Config.GetMultiSetting(MultiSetting.aamodule_rpsDelegationSiteNames));

                // RPS Delegation Offer Actions
                _RpsDelegationOfferActions = TrimAll(Config.GetMultiSetting(MultiSetting.aamodule_rpsDelegationOfferActions));

                // RPS Delegation AppIds Allowed 
                _RpsDelegationAppIdsAllowed = HashSetFromStringArray(TrimAll(Config.GetMultiSetting(MultiSetting.aamodule_rpsDelegationAppIdAllowList)), MultiSetting.aamodule_rpsDelegationAppIdAllowList);

                // SSL settings
                AuthHandlers.UseLoadBalancerSslHeaders = Config.GetBoolSetting(Setting.aamodule_useLoadBalancerSslHeaders);

                // Register for setting changes
                Config.MultiSettingChange += new MultiSettingChangeEventHandler(OnMultiSettingsChanged);
                Config.SettingChange += new SettingChangeEventHandler(OnSettingsChanged);

                FederatedAuthentication.ServiceConfigurationCreated += new EventHandler<Microsoft.IdentityModel.Web.Configuration.ServiceConfigurationCreatedEventArgs>(OnServiceConfigurationCreated);

                Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.TraceOutput += (sender, args) =>
                {
                    Trace.Normal("XblAuthProtocolModule: {0}", args.Message);
                };

                Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.AuthenticateError += (sender, args) =>
                {                    
                    // Could be spammy...
                    if (Config.EnvironmentType == "development")
                    {
                        // Also does a trace in addition to the NT event
                        LogException(HttpContext.Current, args.Exception);
                    }
                    else
                    {
                        Trace.Error("XblAuthProtocolModule: {0}", args.Exception.ToString());
                    }
                };

                // Done!
                Interlocked.Increment(ref _RefCount);

                Xom.NtEvent(XEvent.Id.AAM_CONFIG_INFO, "Successfully initialized the ActiveAuth module.\r\n" + eventMsg);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.AAM_CONFIG_ERROR, e,
                    "Error initializing the ActiveAuthModule specific components."
                );

                // Import to release resources, unsubscribe from xmgmt callbacks and clean
                // up anything we did above. I really hate xmgmt.
                XomLoggingControl.Close();
                PerformanceCounter.CloseSharedResources();
                XomControl.ControlRequestEvent -= new XomControl.ControlRequestEventHandler( ModuleXomCallback.OnControlRequest );

                throw;
            }
        }
    }

    // -------------------------------------------------------------------------------
    // InstanceDispose - the once-per-object-instance dispose routine
    // -------------------------------------------------------------------------------
    private void InstanceDispose()
    {
        if (_IsDisposed)
            return;

        lock (_InstanceDisposeLock)
        {
            if (_IsDisposed)
                return;


            int refcount = Interlocked.Decrement(ref _RefCount);
            ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].TotalInstances.RawValue = _RefCount;

            if (refcount == 0)
            {
                XomLoggingControl.Close();
                PerformanceCounter.CloseSharedResources();
            }

            _IsDisposed = true;
        }
    }

    // -------------------------------------------------------------------------------
    // StaticInitPassport - allows for lazy initialization of Passport RPS library
    // -------------------------------------------------------------------------------
    private static void StaticInitPassport()
    {
        if (_RpsSession != null)
            return;

        lock (_RpsSessionLock)
        {
            if (_RpsSession != null)
                return;

            // RPS object
            try
            {
                ActiveAuthModule._RpsSession = new PassportRpsWrapper();
                Xom.NtEvent(XEvent.Id.AAM_CONFIG_INFO,
                    "Sucessfully initialized Passport RPS."
                );
            }
            catch (Exception e)
            {
                Trace.Error("Unable to initialize PassportRpsWrapper: {0}", e.Message);

                Xom.NtEvent(XEvent.Id.AAM_CONFIG_ERROR, e,
                    "Unable to initialize Passport RPS"
                );

                _RpsSession = null;
            }
        }
    }



    // -------------------------------------------------------------------------------
    // Application_AuthenticateRequest - called after BeginRequest but before
    // ProcessRequest.
    // -------------------------------------------------------------------------------
    private void Application_AuthenticateRequest( object source, EventArgs e )
    {
        bool                    fOk = false;
        AuthHandlers            handlers = null;
        XomRequestTimeElapsed   elapsedTime = new XomRequestTimeElapsed();

        HttpApplication application = (HttpApplication)source;
        HttpContext     ctx = application.Context;

        Trace.Normal("ActiveAuthModule.Application_AuthenticateRequest({0}) called", ctx.Request.Url.AbsolutePath);

        // Is module initialized?
        if (_RefCount == 0)
        {
            Trace.High("Module not initialized yet, aborting request for {0}", ctx.Request.Url.AbsolutePath);
            AuthResponder.SetServerUnavailable(ctx);
            CompleteRequest(application);
            return;
        }

        try
        {
            handlers = new AuthHandlers(application);
            if (!handlers.HandleRequest())
            {
                Trace.High("HandleAuthenticateRequest failed, aborting request for {0}", ctx.Request.Url.AbsolutePath);
                CompleteRequest(application);
                return;
            }
            Debug.Assert(handlers.Policy == AuthUtils.GetPolicy(ctx));
            fOk = true;
        }
        catch (Exception ex)
        {
            // Expected to catch XRLException and HandlerException, and of course any
            // random .Net exceptions.
            LogException(ctx, ex);
            CompleteRequest(application);
            return;
        }
        finally
        {
            // Logfile
            string[] fields = new string[]
            {
                // Log fields:
                // AAMREQ | clientip | url | parsedurl | passportpuid | xuid |
                // antidosstatus (antidos only) | tpshistory (throttle only) | statuscode
                // | handlerstatus | handlerHResult | ok | PassportAppId | elapsedms

                "AAMREQ",
                ctx.Request.UserHostAddress,
                ctx.Request.Url.AbsolutePath,
                handlers != null && handlers.Policy != null ? handlers.Policy.PolicyIdKey : "",
                handlers != null ? (handlers.IsSSL ? "SSL" : string.Empty) : string.Empty,
                handlers != null ? (handlers.CertSubject ?? string.Empty) : string.Empty,
                handlers != null ? handlers.PassportPuid.ToString("X") : "0",
                handlers != null ? handlers.LiveXuid.ToString("X") : "0",
                handlers != null ? handlers.AntidosStatus.ToString() : "",
                handlers != null ? handlers.TpsHistory.ToString() : "",
                0 == ctx.Response.SubStatusCode ? ctx.Response.StatusCode.ToString() : ctx.Response.StatusCode.ToString() + "." + ctx.Response.SubStatusCode.ToString(),
                handlers != null ? handlers.HandlerStatus : "",
                handlers != null ? handlers.HandlerHResult.ToString() : "",
                fOk ? "1" : "0",
                handlers != null ? handlers.PassportAppId != null ? handlers.PassportAppId.ToString() : "" : "",
                elapsedTime.MillisecondsElapsed.ToString()
            };
            string szLog = String.Join("|", fields);
            Xom.Log(XomAreaName.log, szLog);

            // Perfcounters
            string perfKey = "_unknown_";
            ApiPolicy policy = AuthUtils.GetPolicy(ctx);
            if (policy != null)
            {
                perfKey = policy.PolicyIdKeyForPerf;
            }

            if (fOk)
            {
                // Success
                ModulePerPolicyCounters.Counters.TotalRequests.Increment();
                ModulePerPolicyCounters.Counters.RequestsPerSec.Increment();
                ModulePerPolicyCounters.Counters[perfKey].TotalRequests.Increment();
                ModulePerPolicyCounters.Counters[perfKey].RequestsPerSec.Increment();
            }
            else
            {
                // Failure
                ModulePerPolicyCounters.Counters.TotalFailedRequests.Increment();
                ModulePerPolicyCounters.Counters.FailedRequestsPerSec.Increment();
                ModulePerPolicyCounters.Counters[perfKey].TotalFailedRequests.Increment();
                ModulePerPolicyCounters.Counters[perfKey].FailedRequestsPerSec.Increment();
            }

            // Since aamodule.dll includes xblcore.dll code, rather than referencing the 
            // assemblye, we can't leave any object behind in the HttpContext cache, or 
            // else the types will be different (despite looking identical). The automatic 
            // flow-token grabbing code in Xom.X automatically caches the AAInfo object in 
            // the cache. We need to prevent that.
            //
            // @@@ There are better ways. Having Floken manage its own backing store is 
            // one way. Calling the floken-explicit Xom.X functions is another.

            AAInfo.ClearCache();

        }

    }


    // -------------------------------------------------------------------------------
    // Application_EndRequest - called at the very end of the request. This will always
    // get called.. but AuthenticateRequest may not (if FEAPP throws an exception, for
    // instance). Keep this in mind.
    // -------------------------------------------------------------------------------
    private void Application_EndRequest( object source, EventArgs e )
    {
        HttpApplication application = (HttpApplication)source;
        HttpContext     ctx         = application.Context;

        // Remove the parent application's AAInfo object, if found, to avoid casting 
        // exceptions. See comments above for more info.
        AAInfo.ClearCache();

        if (ctx == null)
        {
            Trace.High("Application_EndRequest: HttpContext is null, aborting");
            return;
        }

        // Only decrement counter if we incremented it originally
        ApiPolicy policy = AuthUtils.GetPolicy(ctx);
        if (policy == null)
        {
            Trace.Normal("Application_EndRequest: No ApiPolicy found in HttpContext");
            return;
        }
        ModulePerPolicyCounters.Counters.RequestsInProgress.Decrement();
        ModulePerPolicyCounters.Counters[policy.PolicyIdKeyForPerf].RequestsInProgress.Decrement();

        // Policy is non-null which means we incremented the anti-dos counter so decrement it now
        // GetClientRecord may return null, and that's ok. Decrement handles that.
        ActiveAuthModule.ReqTracker.Decrement(AuthUtils.GetClientRecord(ctx));

    }

    // -------------------------------------------------------------------------------
    // LogException - called to log exceptions generated by us
    // -------------------------------------------------------------------------------
    private static void LogException(HttpContext ctx, Exception ex)
    {
        if (ctx == null || ex == null)
        {
            return;
        }

        StringBuilder eventText = new StringBuilder();
        bool          fireEvent = true;
        HResult       hr        = HResult.XONLINE_E_ACTIVE_AUTH_ERROR;
        XEvent.Id     eventId   = XEvent.Id.MC_APPLICATION_ERROR;
        string        msg       = null;

        try
        {
            if (ex is ExceptionWithoutEvent)
            {
                fireEvent = false;
            }
            else
            {
                // grab an event id and message
                msg = ex.Message;

                if (ex is ExceptionWithEvent)
                {
                    eventId = ((ExceptionWithEvent) ex).EventId;

                    // grab the hr
                    if (ex is XRLException)
                    {
                        hr = ((XRLException)ex).HResult;
                    }
                }
                else if (ex is HandlerException)
                {
                    eventId = XEvent.Id.AAM_HANDLEREQUEST_ERROR;
                    hr = XRLException.ToHResult(ex, HResult.XONLINE_E_ACTIVE_AUTH_ERROR);
                }
            }

            // We could respond with the exception text.. but we're not for security
            // reasons.
            AuthResponder.SetServerError(ctx, hr, null);
        }
        catch (Exception ex2)
        {
            eventText.Append("\r\n*********\r\n");
            eventText.Append("A new exception was thrown in the global event handler!\r\n");
            eventText.Append(ex2.ToString());

            // Just add or set this to the event that will get fired below
            msg = (fireEvent ? msg + eventText.ToString() : eventText.ToString());
            fireEvent = true;
        }
        finally
        {
            Trace.Error("ActiveAuthModule: Unhandled exception: {0}", msg);
            if (fireEvent)
            {
                Xom.NtDataDynEvent(eventId, ex, null, msg);
            }
        }
    }

    // -------------------------------------------------------------------------
    // OnMultiSettingsChanged - handles change notifications from Config. We need to build
    // our new list of ip overrides.
    // -------------------------------------------------------------------------
    public static void OnMultiSettingsChanged(object sender, MultiSettingChangeEventArgs eventArgs)
    {
        switch(eventArgs.MultiSetting)
        {
        case MultiSetting.aamodule_antidosIpOverrides:
            _IpRanges.Reload(eventArgs.ValueNew);
            Xom.NtEvent(XEvent.Id.AAM_CONFIG_INFO,
                       "Successfully reloaded the anti-dos IP overrides:\r\n" +
                       _IpRanges.ToString());
            break;
        
        case MultiSetting.aamodule_XblEnhancedKeyUsages:
            _XblEnhancedKeyUsages = eventArgs.ValueNew;
            Xom.NtEvent(XEvent.Id.AAM_CONFIG_INFO,
                       "Successfully reloaded the Xbl Enhanced Key Usages:\r\n" +
                       _XblEnhancedKeyUsages.ToString());
            break;

        case MultiSetting.aamodule_rpsSiteNames:
            _RpsSiteNames = TrimAll(eventArgs.ValueNew);
            Xom.NtEvent(XEvent.Id.AAM_CONFIG_INFO,
                       "Successfully reloaded the Rps Site Names:\r\n" +
                       _RpsSiteNames.ToString());
            break;

        case MultiSetting.aamodule_rpsDelegationSiteNames:
            _RpsDelegationSiteNames = TrimAll(eventArgs.ValueNew);
            Xom.NtEvent(XEvent.Id.AAM_CONFIG_INFO,
                       "Successfully reloaded the Rps Delegation Site Names:\r\n" +
                       _RpsDelegationSiteNames.ToString());
            break;

        case MultiSetting.aamodule_rpsDelegationOfferActions:
            _RpsDelegationOfferActions = TrimAll(eventArgs.ValueNew);
            Xom.NtEvent(XEvent.Id.AAM_CONFIG_INFO,
                       "Successfully reloaded the Rps Delegation Offer Actions:\r\n" +
                       _RpsDelegationOfferActions.ToString());
            break;

        case MultiSetting.aamodule_rpsDelegationAppIdAllowList:
            _RpsDelegationAppIdsAllowed = HashSetFromStringArray(TrimAll(eventArgs.ValueNew), MultiSetting.aamodule_rpsDelegationAppIdAllowList);
            Xom.NtEvent(XEvent.Id.AAM_CONFIG_INFO,
                       "Successfully reloaded the Rps Delegation Allowed AppIds:\r\n" +
                       _RpsDelegationAppIdsAllowed.ToString());
            break;
 
        }
    }

    /// <summary>
    /// Trims all of the strings in a given array.
    /// </summary>
    private static string[] TrimAll (string[] toTrim)
    {
        for (int i = 0; i < toTrim.Length; ++i)
        {
            toTrim[i] = toTrim[i].Trim();
        }

        return toTrim;
    }

    /// <summary>
    /// Return a ulong HashSet from the strings in a given array.
    /// </summary>
    private static HashSet<ulong> HashSetFromStringArray(string[] values, string settingname)
    {
        HashSet<ulong> set = new HashSet<ulong>();
        ulong value;
        StringBuilder badValues = new StringBuilder();

        for (int i = 0; i < values.Length; ++i)
        {
            if (ulong.TryParse(values[i], out value))
            {
                set.Add(value);
            }
            else
            {
                badValues.Append("\n\t" + values[i]);
            }
        }
        if (0 < badValues.Length)
        {
            Xom.NtEvent(XEvent.Id.AAM_CONFIG_ERROR, "Error loading {0}. Invalid values:{1}", settingname, badValues.ToString());
        }

        return set;
    }

    // -------------------------------------------------------------------------
    // OnSettingsChanged - handles changes to npdb settings
    // -------------------------------------------------------------------------
    public static void OnSettingsChanged (object sender, SettingChangeEventArgs eventArgs)
    {
        // If we fail to parse, we'll throw an exception, which is how we tell Config we
        // rejected the setting. Great.
        switch(eventArgs.Setting)
        {
        case Setting.aamodule_antidosTrackingThreshold:
            _ReqTracker.SetTrackingThreshold(eventArgs.ValueNew);
            break;
        case Setting.aamodule_antidosThrottlingThreshold:
            _ReqTracker.SetThrottlingThreshold(eventArgs.ValueNew);
            break;
        case Setting.aamodule_antidosBlockingThreshold:
            _ReqTracker.SetBlockingThreshold(eventArgs.ValueNew);
            break;
        case Setting.aamodule_antidosMaxRecordsToTrack:
            _ReqTracker.MaxRecordsToTrack = int.Parse(eventArgs.ValueNew);
            break;
        case Setting.aamodule_antidosBanTimeInSeconds:
            _ReqTracker.BanTimeInSeconds = int.Parse(eventArgs.ValueNew);
            break;
        case Setting.sts_cert_subject:
            try
            {
                _XblCertificates = XblSamlToken.GetCertificateBySubjectName(eventArgs.ValueNew, false, false);
            }
            catch (XblException e)
            {
                throw new XRLExceptionWithoutEvent(e.HResult, e, e.Message);
            }
            break;
        case Setting.aamodule_useLoadBalancerSslHeaders:
            AuthHandlers.UseLoadBalancerSslHeaders = Config.ConvertBoolSetting(eventArgs.ValueNew);
            break;
        }

    }

    // -------------------------------------------------------------------------------
    // OnServiceConfigurationCreated - callback from WIF once the web.config has been 
    // loaded, but before the configuration has been handed off to the caller. We
    // can make modifications here.
    // -------------------------------------------------------------------------------
    public static void OnServiceConfigurationCreated(object sender, ServiceConfigurationCreatedEventArgs eventArgs)
    {
        string[] audienceUris = Config.GetMultiSetting(MultiSetting.aamodule_audienceUris);
        string[] trustedIssuers = Config.GetMultiSetting(MultiSetting.aamodule_trustedIssuersSubject);
        string[] serviceCertsSubject = Config.GetMultiSetting(MultiSetting.aamodule_serviceCertsSubject);

        AudienceUriMode audienceMode = (AudienceUriMode)Enum.Parse(
            typeof(AudienceUriMode), 
            Config.GetSetting(Setting.aamodule_audienceUriMode));

        X509CertificateValidationMode certValidationMode = (X509CertificateValidationMode)Enum.Parse(
            typeof(X509CertificateValidationMode),
            Config.GetSetting(Setting.aamodule_certificateValidationMode));

        X509RevocationMode certRevocationMode = (X509RevocationMode)Enum.Parse(
            typeof(X509RevocationMode),
            Config.GetSetting(Setting.aamodule_certificateRevocationMode));

        var config = eventArgs.ServiceConfiguration;

        // ------------------------------------------------------------------------------
        //<audienceUris mode="Always">
        //    <add value="https://xboxlive.com/"/>
        //</audienceUris>
        // ------------------------------------------------------------------------------
        config.AudienceRestriction.AudienceMode = audienceMode;
        foreach (string audienceStr in audienceUris)
        {
            Uri audienceUri = new Uri(audienceStr);
            if (!config.AudienceRestriction.AllowedAudienceUris.Contains(audienceUri))
            {
                config.AudienceRestriction.AllowedAudienceUris.Add(audienceUri);
            }
        }

        // ------------------------------------------------------------------------------
        //<issuerNameRegistry type="Microsoft.IdentityModel.Tokens.ConfigurationBasedIssuerNameRegistry, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"> 
        //    <trustedIssuers> 
        //        <add name="xsts.xboxlive.com" thumbprint="6D5764137FD74DE7BDCCB965DDB414583AC29929"/> 
        //    </trustedIssuers> 
        //</issuerNameRegistry> 
        //
        // We're going to use a custom issuer name registry, so we can use subjects instead
        // of thumbprints.
        // ------------------------------------------------------------------------------
        config.IssuerNameRegistry = new TrustedIssuerNameRegistry(trustedIssuers);

        // ------------------------------------------------------------------------------
        //<certificateValidation certificateValidationMode="PeerOrChainTrust" revocationMode="Online" />
        // ------------------------------------------------------------------------------

        config.CertificateValidationMode = certValidationMode;
        config.RevocationMode = certRevocationMode;

        // ------------------------------------------------------------------------------
        // (don't know xml, worked this out in code)
        // ------------------------------------------------------------------------------

        List<SecurityToken> serviceTokens = new List<SecurityToken>();
        for (int i = 0; i < serviceCertsSubject.Length; i++)
        {
            // Slightly odd choice of helper function, but it's used elsewhere in the aamodule.
            try
            {
                var certCollection = XblSamlToken.GetCertificateBySubjectName(serviceCertsSubject[i], true, true);
                if (certCollection != null && certCollection.Count == 1)
                {
                    X509Certificate2 certificate = certCollection[0];
                    serviceTokens.Add(new X509SecurityToken(certificate));
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.AAM_CONFIG_ERROR, e,
                    String.Format("Error loading certificate {0} of {1} with subject name {2}",
                    i + 1, serviceCertsSubject.Length, serviceCertsSubject[i]));

                // Throw if no certificates could be found
                if (i == serviceCertsSubject.Length - 1 && serviceTokens.Count == 0)
                    throw;
            }
        }
        SecurityTokenResolver tokenResolver = SecurityTokenResolver.CreateDefaultSecurityTokenResolver(
            serviceTokens.AsReadOnly(),
            false);
        config.ServiceTokenResolver = tokenResolver;

        List<SecurityToken> issuerTokens = new List<SecurityToken>();
        for (int i = 0; i < trustedIssuers.Length; i++)
        {
            string[] tokens = trustedIssuers[i].Split(new char[] { ',', ' ' }, StringSplitOptions.RemoveEmptyEntries);
            string subject = tokens[0];

            // Slightly odd choice of helper function, but it's used elsewhere in the aamodule.
            try
            {
                var certCollection = XblSamlToken.GetCertificateBySubjectName(subject, false, true);
                issuerTokens.Add(new X509SecurityToken(certCollection[0]));
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.AAM_CONFIG_ERROR, e,
                    String.Format("Error loading certificate {0} of {1} with subject name {2}",
                    i + 1, trustedIssuers.Length, subject));

                // Throw if no certificates could be found
                if (i == trustedIssuers.Length - 1 && issuerTokens.Count == 0)
                    throw;
            }
        }
        SecurityTokenResolver issuerResolver = SecurityTokenResolver.CreateDefaultSecurityTokenResolver(
            issuerTokens.AsReadOnly(),
            false);
        config.IssuerTokenResolver = issuerResolver;

    }

    // -------------------------------------------------------------------------------
    // TrustedIssuerNameRegistry - resolves trusted issuers based on certificate
    // subject name (versus the built-in ConfigurationBasedIssuerNameRegsitry which
    // uses thumbprints).
    // -------------------------------------------------------------------------------
    public class TrustedIssuerNameRegistry : IssuerNameRegistry
    {
        private Dictionary<string, string> _TrustedSubjectNamesToIssuer;

        public TrustedIssuerNameRegistry(string[] trustedSubjectNamesAndIssuers)
        {
            _TrustedSubjectNamesToIssuer = new Dictionary<string, string>();
            foreach (string nameAndIssuer in trustedSubjectNamesAndIssuers)
            {
                if (String.IsNullOrEmpty(nameAndIssuer))
                    continue;
                string[] tokens = nameAndIssuer.Split(new char[] { ',', ' ' }, StringSplitOptions.RemoveEmptyEntries);
                string subject = tokens[0];
                string issuer = tokens.Length >= 2 ? tokens[1] : "xsts.xboxlive.com";
                _TrustedSubjectNamesToIssuer[subject] = issuer;
            }
        }

        public override string GetIssuerName(SecurityToken securityToken)
        {
            X509SecurityToken x509Token = securityToken as X509SecurityToken;
            if (x509Token != null)
            {
                string subjectName = x509Token.Certificate.Subject;

                // Extract the "CN" portion of the name
                int i = subjectName.IndexOf("CN=");
                if (i > -1)
                {
                    i += 3;
                    int j = subjectName.IndexOf(",", i);
                    int len = (j == -1) ? subjectName.Length - i : j - i;
                    subjectName = subjectName.Substring(i, len);
                }

                string issuerName;
                if (_TrustedSubjectNamesToIssuer.TryGetValue(subjectName, out issuerName))
                {
                    return issuerName;
                }
            }
            throw new SecurityTokenException("Token signature is not trusted by the issuer name registry. SubjectName is " + 
                x509Token != null 
                ? x509Token.Certificate.SubjectName.Name
                : "<none>");
        }
    }


    // -------------------------------------------------------------------------------
    // CompleteRequest - aborts a request and returns a result to the client.
    // -------------------------------------------------------------------------------
    private static void CompleteRequest(HttpApplication application)
    {
        application.CompleteRequest();
    }


    // -------------------------------------------------------------------------------
    // HealthCheck - are we in a good state? Returns a human-readable string.
    // -------------------------------------------------------------------------------
    internal static string HealthCheck()
    {
        StringBuilder sb = new StringBuilder();

        sb.Append("\r\n");
        sb.AppendFormat("RpsSession valid     : {0}\r\n",
            ActiveAuthModule.RpsSession != null);
        sb.AppendFormat("PolicyMgr valid      : {0}\r\n",
            ActiveAuthModule.PolicyMgr != null);
        sb.AppendFormat("NumPolicies          : {0}\r\n",
            ActiveAuthModule.PolicyMgr != null ? ActiveAuthModule.PolicyMgr.Count : 0);
        sb.AppendFormat("RequestTracker state : {0}\r\n",
            ActiveAuthModule.ReqTracker != null ? ActiveAuthModule.ReqTracker.CurrentState.ToString() : "n/a");
        sb.AppendFormat("Requests in progress : {0}\r\n",
            ActiveAuthModule.ReqTracker != null ? ActiveAuthModule.ReqTracker.GlobalRequestsInProgress : 0);
        sb.AppendFormat("Active clients       : {0}\r\n",
            ActiveAuthModule.ReqTracker != null ? ActiveAuthModule.ReqTracker.GlobalActiveClients : 0);

        return sb.ToString();
    }


    // -------------------------------------------------------------------------------
    // Static properties to access HttpApplication, HttpContext, etc items
    // -------------------------------------------------------------------------------

    internal static PassportRpsWrapper RpsSession
    {
        get
        {
            if (_RpsSession == null)
                StaticInitPassport();
            return _RpsSession;
        }
    }

    internal static PolicyManager PolicyMgr
    {
        get { return _PolicyMgr; }
    }

    internal static IDictionary<string, IIEBBusinessPartner> BuisnessPartners
    {
        get { return _Partners; }
    }

    internal static RequestTracker ReqTracker
    {
        get { return _ReqTracker; }
    }

    internal static IpRangeList<IpRecord> IpRanges
    {
        get { return _IpRanges; }
    }

    internal static string PolicyIdKey
    {
        get { return (string)HttpContext.Current.Items[AuthUtils.ACTIVEAUTH_POLICY_ID_KEY]; }
        set { HttpContext.Current.Items[AuthUtils.ACTIVEAUTH_POLICY_ID_KEY] = value; }
    }

    internal static string AppPoolId
    {
        get
        {
            if (_AppPoolId == null)
            {
                // Get name of app pool to use as instance name in global counters. No
                // need to worry about multi-threaded problems here, we can stomp this all
                // we want. We have to use the env variable because the httprequest isn't
                // available when we are initializing some perf counters.
                _AppPoolId = Environment.GetEnvironmentVariable("APP_POOL_ID");
            }
            return _AppPoolId;
        }
    }

    internal static X509Certificate2Collection XblCertificates
    {
        get { return _XblCertificates; }
    }
    
    internal static string[] XblEnhancedKeyUsages
    {
        get { return _XblEnhancedKeyUsages; }
    }

    internal static string[] RpsSiteNames
    {
        get { return _RpsSiteNames; }
    }

    internal static string[] RpsDelegationSiteNames
    {
        get { return _RpsDelegationSiteNames; }
    }

    internal static string[] RpsDelegationOfferActions
    {
        get { return _RpsDelegationOfferActions; }
    }

    internal static HashSet<ulong> RpsDelegationAppIdsAllowed
    {
        get { return _RpsDelegationAppIdsAllowed; }
    }

    // Static vars

    private static object                       _ConfigLock     = new object();
    private static volatile int                 _RefCount       = 0;
    private static volatile PassportRpsWrapper  _RpsSession     = null;
    private static object                       _RpsSessionLock = new object();
    private static PolicyManager                _PolicyMgr      = null;    
    private static RequestTracker               _ReqTracker     = null;
    private static IpRangeList<IpRecord>        _IpRanges       = null;
    private static string                       _AppPoolId      = null;
    private static X509Certificate2Collection   _XblCertificates = null;
    private static string[]                     _XblEnhancedKeyUsages = null;
    private static string[]                     _RpsSiteNames   = null;
    private static string[]                     _RpsDelegationSiteNames = null;
    private static string[]                     _RpsDelegationOfferActions = null;
    private static HashSet<ulong>               _RpsDelegationAppIdsAllowed = null;

    private static IDictionary<string, IIEBBusinessPartner> _Partners = null;

    // Instance vars

    private object              _InstanceDisposeLock = new object();
    private volatile bool       _IsDisposed          = false;

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\module\AntiDosUtils.cs ===
// 
// AntiDosUtils.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Active Auth Module
// Xbox Online Service
//
// Collection of helper classes for the ModuleAntiDos implementation.
//
// Author: kgoodier 9/2007
//

using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Web;
using System.Net;

using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.utilities2;

namespace xonline.server.activeauth.module
{

// -----------------------------------------------------------------------------------
// IpRecord
//
// This is the record we store in the IpRangeList data structure. Any data we want to 
// associate with an ip override should go in this class.
// -----------------------------------------------------------------------------------
internal class IpRecord : IIpRangeUserRecord
{
    public IpRecord()
    {
        _ThrottleLimit = 0;
    }

    public void SetParam(string paramName, string paramValue)
    {
        if (String.Compare(paramName, "count", true) == 0)
        {
            _ThrottleLimit = int.Parse(paramValue);
        }
        else
        {
            throw new ArgumentException("Unrecognized parameter name: " + paramName, "paramName");
        }
    }

    internal int ThrottleLimit
    {
        get { return _ThrottleLimit; }
        set { _ThrottleLimit = value; }
    }
    
    public override string ToString()
    {
        return String.Format("({0})", _ThrottleLimit);
    }

    private int _ThrottleLimit;
}


// -----------------------------------------------------------------------------------
// ClientRecord
//
// This is the record we store per-ip address to track the number of requests and event 
// throttling information. These are stored in the LimitedSizeDictionary, which is a 
// hashtable with a limited size.
//
// The template parameter is the dictionary key type. It's the IP address.
// -----------------------------------------------------------------------------------
internal class ClientRecord : ILimitedSizeDictionaryValue<IPAddress>
{
    public IPAddress Key 
    {
        get { return IpAddress; }
        set { IpAddress = value; }
    }

    public bool IsReusable 
    {
        get { return Count <= 0; }
    }

    public void Init(IPAddress key)
    {
        IpAddress           = key;
        Count               = 0;
        LastInfractionTime  = DateTime.MinValue;
    }

    public override string ToString()
    {
        return String.Format("Ip:{0} Cnt:{1} Time:{2})", 
                             IpAddress.ToString(), 
                             Count, 
                             LastInfractionTime.ToString());
    }

    public IPAddress    IpAddress;
    public int          Count;
    public DateTime     LastInfractionTime;

}




}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\module\AuthResponder.cs ===
// 
// AuthResponder.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Active Auth Module
// Xbox Online Service
//
// Handles communication with the client
// 
// Author: kgoodier 6/2007
//

using System;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;
using System.Web;

using xonline.common.service;
using xonline.server.activeauth.common;

namespace xonline.server.activeauth.module
{

// -----------------------------------------------------------------------------------
// AuthResponder class 
//
// Any responses the module returns to the client should come from this class. Just call 
// one of the helper methods and complete the request.
// -----------------------------------------------------------------------------------
internal static class AuthResponder 
{

    internal static void SetAuthorizationRequired(HttpContext httpCtx, ApiPolicy policy)
    {
        SetAuthorizationRequired(httpCtx, policy, 0);
    }

    internal static void SetAuthorizationRequired(HttpContext httpCtx, ApiPolicy policy, HResult hr)
    {
        SetAuthorizationRequired(httpCtx, policy, hr.ToString());
    }

    internal static void SetAuthorizationRequired(HttpContext httpCtx, ApiPolicy policy, string fault)
    {
        // Sample response header:
        //
        // WWW-Authenticate: WLID1.0 realm="WindowsLive", fault="BadContextToken", 
        // policy="MBI", ver="4.0.1532.0"
        //
        // "fault" is optional. Do we want to include a reason?

        if (fault == null || fault == "")
        {
            fault = "";
        }
        else
        {
            fault = String.Format(", fault=\"{0}\"", fault);
        }

        string version = "0";
        if (ActiveAuthModule.RpsSession != null)
        {
            version = ActiveAuthModule.RpsSession.Version;
        }
        const string realm = "WindowsLive";
        
        string hdrVal = String.Format(
            "{0} realm=\"{1}\"{2}, policy=\"{3}\", ver=\"{4}\"",
            AuthUtils.PASSPORT_AUTH_SCHEME_TOKEN,
            realm,
            fault,
            policy.AuthenticationPolicy,
            version);

        SetAuthorizationRequired(httpCtx, hdrVal);
    }

    internal static void SetAuthorizationRequired(HttpContext httpCtx, string authenticateHeaderValue)
    {
        // 401: Unauthorized
        httpCtx.Response.ClearHeaders();
        httpCtx.Response.StatusCode = (int) HttpStatusCode.Unauthorized;
        httpCtx.Response.AddHeader("WWW-Authenticate", authenticateHeaderValue);

        Trace.Normal("AuthResponder.SetAuthorizationRequired[{0}]: StatusCode {1}, WWW-Authenticate: {2}", 
                     httpCtx.Request.UserHostAddress,
                     httpCtx.Response.StatusCode,
                     authenticateHeaderValue);
    } 

    internal static void SetInvalidRequest(HttpContext httpCtx)
    {
        // 400: Bad Request
        httpCtx.Response.ClearHeaders();
        httpCtx.Response.StatusCode = (int) HttpStatusCode.BadRequest;
        Trace.Normal("AuthResponder.SetInvalidRequest[{0}]: StatusCode {1}",
                     httpCtx.Request.UserHostAddress,
                     httpCtx.Response.StatusCode);
    }

    internal static void SetSslRequired(HttpContext httpCtx)
    {
        string message = "ssl required";

        // 403: Forbidden
        httpCtx.Response.ClearHeaders();
        httpCtx.Response.StatusCode = (int) HttpStatusCode.Forbidden;
        httpCtx.Response.Write(message);
        Trace.Normal("AuthResponder.SetSslRequired[{0}]: StatusCode {1}, {2}",
                     httpCtx.Request.UserHostAddress,
                     httpCtx.Response.StatusCode, message);
    }

    internal static void SetClientCertRequired(HttpContext httpCtx)
    {
        string message = "ssl client cert required";

        // 403.7: Forbidden
        httpCtx.Response.ClearHeaders();
        httpCtx.Response.StatusCode = (int) HttpStatusCode.Forbidden;
        httpCtx.Response.SubStatusCode = 7;
        httpCtx.Response.Write(message);
        Trace.Normal("AuthResponder.SetClientCertRequired[{0}]: StatusCode {1}, {2}",
                     httpCtx.Request.UserHostAddress,
                     httpCtx.Response.StatusCode, message);
    }

    internal static void SetClientCertUntrusted(HttpContext httpCtx)
    {
        string message = "ssl client cert untrusted";

        // 403.16: Forbidden
        httpCtx.Response.ClearHeaders();
        httpCtx.Response.StatusCode = (int) HttpStatusCode.Forbidden;
        httpCtx.Response.SubStatusCode = 16;
        httpCtx.Response.Write(message);
        Trace.Normal("AuthResponder.SetClientCertUntrusted[{0}]: StatusCode {1}, {2}",
                     httpCtx.Request.UserHostAddress,
                     httpCtx.Response.StatusCode, message);
    }

    internal static void SetUnknownUrl(HttpContext httpCtx, string parsedUrlKey)
    {
        // 404: Not Found
        httpCtx.Response.ClearHeaders();
        httpCtx.Response.StatusCode = (int) HttpStatusCode.NotFound;
        Trace.Normal("AuthResponder.SetUnknownUrl[{0}]: StatusCode {1}, ParsedUrlKey {2}",
                     httpCtx.Request.UserHostAddress,
                     httpCtx.Response.StatusCode, parsedUrlKey);
    }

    internal static void SetServerError(HttpContext httpCtx, HResult hr, string message)
    {
        // 500: Internal Server Error
        httpCtx.Response.ClearHeaders();
        httpCtx.Response.StatusCode = (int) HttpStatusCode.InternalServerError;
        Trace.Normal("AuthResponder.SetServerError[{0}]: StatusCode {1}, hr = {2}, {3}",
                     httpCtx.Request.UserHostAddress,
                     httpCtx.Response.StatusCode, hr, message);

        // @@@ test only. 
        if (message != null)
        {
            httpCtx.Response.Write(message);
        }
    }

    internal static void SetServerUnavailable(HttpContext httpCtx)
    {
        // 503: Service Unavailable
        httpCtx.Response.ClearHeaders();
        httpCtx.Response.StatusCode = (int) HttpStatusCode.ServiceUnavailable;
        Trace.Normal("AuthResponder.SetServerUnavailable[{0}]: StatusCode {1}",
                     httpCtx.Request.UserHostAddress,
                     httpCtx.Response.StatusCode);
    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\module\AuthUtils.cs ===
// 
// AuthUtils.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Active Auth Module
// Xbox Online Service
//
// ActiveAuth utilities and constants
//
// Author: kgoodier 6/2007
//

using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Web;

using xonline.common.service;
using xonline.server.activeauth.common;

namespace xonline.server.activeauth.module
{

// -----------------------------------------------------------------------------------
// ActiveAuthUtls class, for holding constants, static utility functions, etc.
// -----------------------------------------------------------------------------------
public class AuthUtils
{
    // Used in HttpContext items for the app-parsed url token from the app
    public const string ACTIVEAUTH_POLICY_ID_KEY       = "ActiveAuthPolicyId";

    // Used in HTTP headers
    internal const string PASSPORT_AUTH_SCHEME_TOKEN   = "WLID1.0";
    internal const string XBL1_0_AUTH_SCHEME_TOKEN     = "XBL1.0";
    internal const string XBL2_0_AUTH_SCHEME_TOKEN     = "XBL2.0";

    // ApiPolicy instance for this request.
    internal const string ACTIVEAUTH_POLICY_KEY        = "ActiveAuthApiPolicy";

    // ClientRecord instance for this request.
    internal const string ACTIVEAUTH_CLIENTRECORD_KEY  = "ActiveAuthClientRecord";

    // Default policies
    internal const string DEFAULTPOLICY_ANONYMOUS      = "/default/anonymous";
    internal const string DEFAULTPOLICY_WLID10         = "/default/wlid10";
    internal const string DEFAULTPOLICY_XBL10          = "/default/xbl10";
    internal const string DEFAULTPOLICY_XBL20          = "/default/xbl20";

    // AA claims
    public const string AACLAIM_CLIENTCERT_SUBJECTNAME = "http://schemas.microsoft.com/xbox/2011/07/claims/partner/certsubject";
    public const string AACLAIM_PARTNERID              = "http://schemas.microsoft.com/xbox/2011/07/claims/partner/id";

    // -------------------------------------------------------------------------
    // MarshallAAInfoToContext
    // 
    // Pass up the AAInfo (but actually only the fields we know about) to the 
    // HttpApplication. This is closely tied to the marshalling code in AAInfo.
    // -------------------------------------------------------------------------
    public static void MarshallAAInfoToContext(
        HttpContext ctx, 
        ulong       passportPuid, 
        string      ipAddressInternet,
        ulong       xuid,
        ulong       passportCId,
        DateTime    notAfterDateTime,
        DateTime    issueInstantDateTime,
        string      certDeviceId,
        string      samlToken,
        string      flowTokenString)
    {
        ctx.Items[AAInfo.c_CtxKey_PassportPuid]      = passportPuid;
        ctx.Items[AAInfo.c_CtxKey_IpAddressInternet] = ipAddressInternet;
        if (xuid != 0)
        {
            ctx.Items[AAInfo.c_CtxKey_LiveXuid]      = xuid;
        }
        ctx.Items[AAInfo.c_CtxKey_PassportCId]       = passportCId;
        ctx.Items[AAInfo.c_CtxKey_NotAfterDateTime]  = notAfterDateTime;
        ctx.Items[AAInfo.c_CtxKey_IssueInstantDateTime] = issueInstantDateTime;
        ctx.Items[AAInfo.c_CtxKey_certDeviceId]      = certDeviceId;
        ctx.Items[AAInfo.c_CtxKey_samlToken]         = samlToken;
        ctx.Items[AAInfo.c_CtxKey_flowToken]         = flowTokenString;
    }

    // -------------------------------------------------------------------------
    // SetPolicy - stores the ApiPolicy in the HttpContext
    // -------------------------------------------------------------------------
    internal static void SetPolicy(HttpContext ctx, ApiPolicy policy, string policyKey)
    {
        ctx.Items[ACTIVEAUTH_POLICY_KEY] = policy;
        ctx.Items[AuthCommon.ACTIVEAUTH_POLICY_IDKEY] = policyKey;
    }
    
    // -------------------------------------------------------------------------
    // GetPolicy - retrieves the ApiPolicy hanging off the HttpContext
    // -------------------------------------------------------------------------
    internal static ApiPolicy GetPolicy(HttpContext ctx)
    {
        return (ApiPolicy)ctx.Items[ACTIVEAUTH_POLICY_KEY];
    }

    // -------------------------------------------------------------------------
    // SetClientRecord - stores the ClientRecord in the HttpContext
    // -------------------------------------------------------------------------
    internal static void SetClientRecord(HttpContext ctx, ClientRecord rec)
    {
        ctx.Items[ACTIVEAUTH_CLIENTRECORD_KEY] = rec;
    }

    // -------------------------------------------------------------------------
    // GetClientRecord - retrieves the ClientRecord hanging off the HttpContext
    // -------------------------------------------------------------------------
    internal static ClientRecord GetClientRecord(HttpContext ctx)
    {
        return (ClientRecord)ctx.Items[ACTIVEAUTH_CLIENTRECORD_KEY];
    }

}

// -----------------------------------------------------------------------------------
//
// Exceptions
//
// -----------------------------------------------------------------------------------

internal class HandlerException : Exception
{
    internal HandlerException(string message) 
        : base(message) 
    { 
    }

    internal HandlerException(string format, params object[] args) 
        : base(String.Format(format, args)) 
    { 
    }

    internal new HResult HResult 
    { 
        get { HResult hr = (uint) base.HResult; return hr; }
        set { base.HResult = (int)(uint) value; } 
    }
}



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\module\PerfCounters.cs ===
// 
// PerfCounters.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Active Auth Module
// Xbox Online Service
// 
// Author: kgoodier 6/2007
//

using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.activeauth.module
{
    [XomPerformanceCounterCategoryAttr( "ActiveAuth Module - Global", "Xbox Live Active Auth Module Performance Counters - Global counters" )]
    public class ModuleGlobalCounters : XomPerformanceCounterCategory
    {
        static public ModuleGlobalCounters Counters = new ModuleGlobalCounters();

        public virtual ModuleGlobalCounters this[string instance]
        {
            get
            {
                return (ModuleGlobalCounters) GetInstance(instance);
            }
        }

        [XomPerformanceCounterAttr(
             "Antidos: Active Clients", 
             "Number of current active clients contributing to the total requests in progress count",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ActiveClients;

        [XomPerformanceCounterAttr(
             "Antidos: Requests in Progress", 
             "Total requests in progress count",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ActiveRequests;

        [XomPerformanceCounterAttr(
             "Antidos: Average requests per active client", 
             "Average number of active requests per client, rounded down",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter AverageRequestsPerActiveClient;

        [XomPerformanceCounterAttr(
             "Antidos: Blocking Threshold Off", 
             "Threshold at which Blocking is disabled",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter BlockingThresholdOff;

        [XomPerformanceCounterAttr(
             "Antidos: Blocking Threshold On", 
             "Threshold at which Blocking is enabled",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter BlockingThresholdOn;

        [XomPerformanceCounterAttr(
             "Antidos: Current State", 
             "Current state of the RequestTracker. 0=Off, 1=Tracking, 2=Throttling, 3=Blocking",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter CurrentState;
        
        [XomPerformanceCounterAttr(
             "Antidos: Throttling Threshold Off", 
             "Threshold at which Throttling is disabled",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ThrottlingThresholdOff;

        [XomPerformanceCounterAttr(
             "Antidos: Throttling Threshold On", 
             "Threshold at which Throttling is enabled",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ThrottlingThresholdOn;

        [XomPerformanceCounterAttr(
             "Antidos: Tracking Threshold Off", 
             "Threshold at which Tracking is disabled",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter TrackingThresholdOff;

        [XomPerformanceCounterAttr(
             "Antidos: Tracking Threshold On", 
             "Threshold at which Tracking is enabled",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter TrackingThresholdOn;


        [XomPerformanceCounterAttr(
             "Module: Total instances", 
             "Number of active instance of this Active Auth Module", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalInstances;

        [XomPerformanceCounterAttr(
             "Requests: Authenticated Per Sec", 
             "Number of authenticated (with Passport ticket) requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecAuthenticated;
        
        [XomPerformanceCounterAttr(
             "Requests: Unauthenticated Per Sec", 
             "Number of unauthenticated (no Passport ticket) requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecUnauthenticated;
        
        [XomPerformanceCounterAttr(
             "Requests: SSL Per Sec", 
             "Number of SSL requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecSSL;

        [XomPerformanceCounterAttr(
             "Requests: Non-SSL Per Sec", 
             "Number of non-SSL requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecNonSSL;
       


    } 

    [XomPerformanceCounterCategoryAttr( "ActiveAuth Module - Per-policy", "Xbox Live Active Auth Module Performance Counters - Per-policy counters", PerformanceCounterInstanceLifetime.Global)]
    public class ModulePerPolicyCounters : XomPerformanceCounterCategory
    {
        static public ModulePerPolicyCounters Counters = new ModulePerPolicyCounters();

        public virtual ModulePerPolicyCounters this[string instance]
        {
            get
            {
                return (ModulePerPolicyCounters) GetInstance(instance);
            }
        }

        [XomPerformanceCounterAttr(
             "Requests: In Progress", 
             "Number of requests currently in progress", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter RequestsInProgress;

        [XomPerformanceCounterAttr(
             "Requests: Total", 
             "Total number of requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequests;

        [XomPerformanceCounterAttr(
             "Requests: Total Blocked", 
             "Total number of requests that were blocked by the anti-dos system", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalBlockedRequests;

        [XomPerformanceCounterAttr(
             "Requests: Total Throttled", 
             "Total number of requests that were blocked by the per-api throttling system", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalThrottledRequests;

        [XomPerformanceCounterAttr(
             "Requests: Total Failed", 
             "Total number of requests that failed", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalFailedRequests;

        [XomPerformanceCounterAttr(
             "Requests: Blocked Per Sec", 
             "Number of total blocked (by anti-dos) requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter BlockedRequestsPerSec;

        [XomPerformanceCounterAttr(
             "Requests: Throttled Per Sec", 
             "Number of total blocked (by throttling) requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ThrottledRequestsPerSec;

        [XomPerformanceCounterAttr(
             "Requests: Failed Per Sec", 
             "Number of total failed requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailedRequestsPerSec;

        [XomPerformanceCounterAttr(
             "Requests: Per Sec", 
             "Number of total requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSec;


    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\module\RequestTracker.cs ===
// 
// RequestTracker.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Active Auth Module
// Xbox Online Service
//
// ActiveAuth RequestTracker class to aid in anti-dos implementation. 
//
// Author: kgoodier 9/2007
//

using System;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;
using System.Web;
using System.Diagnostics;

using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.utilities2;

// "a reference to a volatile field will not be treated as volatile"
#pragma warning disable 420

namespace xonline.server.activeauth.module
{

// -----------------------------------------------------------------------------------
// RequestTracker class, for tracking requests
// -----------------------------------------------------------------------------------
internal class RequestTracker
{

    internal RequestTracker(
        string trackingThreshold,
        string throttlingThreshold,
        string blockingThreshold,
        int maxRecordsToTrack,
        int banTimeInSeconds)
    {
        MaxRecordsToTrack = maxRecordsToTrack;
        BanTimeInSeconds  = banTimeInSeconds;

        // Important to do reverse order, high to low. This is to ensure we have good 
        // settings and the built-in checks all pass. Also don't use the safety-wrapped 
        // accessors as the parameters, as high/low can be twiddled around. Seems like we 
        // could find a way to make this less fragile...

        SetBlockingThreshold(blockingThreshold);
        SetThrottlingThreshold(throttlingThreshold);
        SetTrackingThreshold(trackingThreshold);

    }

    // -------------------------------------------------------------------------------
    // SetBlockingThreshold - helper
    // -------------------------------------------------------------------------------
    internal void SetBlockingThreshold(string threshold)
    {
        int high, low;
        GetThresholdSettingValues(threshold, out high, out low);
            
        if (low < ThrottlingThresholdOff)
            throw new ArgumentException("BlockingThresholdOff cannot be less than ThrottlingThresholdOff");
        if (high < ThrottlingThresholdOn)
            throw new ArgumentException("BlockingThresholdOn cannot be less than ThrottlingThresholdOn");

        _BlockingThresholdOn  = high;
        _BlockingThresholdOff = low;
            
        ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].BlockingThresholdOn.RawValue  = high;
        ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].BlockingThresholdOff.RawValue = low;
    }

    // -------------------------------------------------------------------------------
    // SetThrottlingThreshold - helper
    // -------------------------------------------------------------------------------
    internal void SetThrottlingThreshold(string threshold)
    {
        int high, low;
        GetThresholdSettingValues(threshold, out high, out low);
            
        if (low > BlockingThresholdOff || low < TrackingThresholdOff)
            throw new ArgumentException("ThrottlingThresholdOff cannot be greater than BlockingThresholdOff or less than TrackingThresholdOff");
        if (high > BlockingThresholdOn || high < TrackingThresholdOn)
            throw new ArgumentException("ThrottlingThresholdOn cannot be greater than BlockingThresholdOn or less than TrackingThresholdOn");

        _ThrottlingThresholdOn  = high;
        _ThrottlingThresholdOff = low;
            
        ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].ThrottlingThresholdOn.RawValue  = high;
        ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].ThrottlingThresholdOff.RawValue = low;
    }

    // -------------------------------------------------------------------------------
    // SetTrackingTreshold - helper
    // -------------------------------------------------------------------------------
    internal void SetTrackingThreshold(string threshold)
    {
        int high, low;
        GetThresholdSettingValues(threshold, out high, out low);
        
        if (low > ThrottlingThresholdOff)
            throw new ArgumentException("TrackingThresholdOff cannot be greater than ThrottlingThresholdOff");
        if (high > ThrottlingThresholdOn)
            throw new ArgumentException("TrackingThresholdOn cannot be greater than ThrottlingThresholdOn");

        _TrackingThresholdOn  = high;
        _TrackingThresholdOff = low;
            
        ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].TrackingThresholdOn.RawValue  = high;
        ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].TrackingThresholdOff.RawValue = low;
    }


    // -------------------------------------------------------------------------------
    // Return value when looking up a client. Informs caller what action should be taken.
    // -------------------------------------------------------------------------------
    internal enum ClientState
    {
        Ok,             // client is good
        LimitExceeded,  // limit has just been exceeded (throttled or blocked)
        TempBanned,     // client already exceeded limit and is temporarily banned
    };
    
    // -------------------------------------------------------------------------------
    // TrackerState - current state of the ReqestTracker
    // -------------------------------------------------------------------------------
    internal enum TrackerState
    {
        Off,
        Tracking,
        Throttling,
        Blocking
    };


    // -------------------------------------------------------------------------------
    // Increment - Global Perf counter management.
    // -------------------------------------------------------------------------------
    internal void Increment()
    {
        //
        // First thing: increment global count and change current state.
        // 
        int globalRequestsInProgress = Interlocked.Increment(ref _GlobalRequestsInProgress);
        ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].ActiveRequests.RawValue = _GlobalRequestsInProgress;
    }

    // -------------------------------------------------------------------------------
    // HandleRequest - called for each request by a client. Returns the state of the client.  
    // -------------------------------------------------------------------------------
    internal ClientState HandleRequest(string ipAddressString)
    {
        int globalRequestsInProgress = _GlobalRequestsInProgress;

        UpdateState(globalRequestsInProgress);

        if (_State == TrackerState.Off)
        {
            return ClientState.Ok;
        }

        //
        // Lookup ip address
        //
        IPAddress ipAddress = IPAddress.Parse(ipAddressString);
        IPAddress ipBase;
        IpRecord  ipUserRecord;
        bool      fFoundIpRecord; 

#if true
        fFoundIpRecord = ActiveAuthModule.IpRanges.Lookup(ipAddress, out ipBase, out ipUserRecord);
#else
        // @@@ dvt only!! This will include IP+PORT instead of just IP in the key.
        string strPort = HttpContext.Current.Request.ServerVariables.Get("REMOTE_PORT");
        ushort srcPort = (ushort)IPAddress.HostToNetworkOrder((short)Convert.ToUInt16(strPort));
        long dvtIp = ByteOrder.IpAddressToUInt32(ipAddress) + (srcPort);
        ipBase = new IPAddress(dvtIp & 0xFFFFFFFF);
        ipUserRecord = new IpRecord();
        fFoundIpRecord = false;
#endif

        
        //
        // Get client record, update request count
        //
        ClientRecord clientRec = GetClientRecordAndIncrement(ipBase);
        if (clientRec == null)
        {
            Trace.Error("RequestTracker.Increment: tracking dictionary is unexpectedly null.");
            return ClientState.Ok;
        }

        //
        // Ok. Expensive stuff is out of the way. We're going to store the state in a 
        // local var and work with it from here on out.
        //
        TrackerState currentState = _State;
        
        //
        // Get client throttle limit. The AverageRequestsPerActiveClient relies on an 
        // accurate client count, which only happens after GetClientRecordAndIncrement() 
        // is called.
        //
        int clientThrottleLimit;
        if (!fFoundIpRecord)
        {
            // Failed to find override for client. Use fancy threshold instead of the 
            // provided default value.
            clientThrottleLimit = AverageRequestsPerActiveClient;
            Debug.Assert(clientThrottleLimit > 0);
        }
        else
        {
            Trace.Low("IpRanges: {0} mapped to {1}, count {2}", 
                      ipAddress, ipBase, ipUserRecord);
            clientThrottleLimit = ipUserRecord.ThrottleLimit;
        }

        if (clientThrottleLimit >= ThrottlingThresholdOn)
        {
            Trace.High("RequestTracking: clientThrottleLimit {0} is higher than ThrottlingThresholdOn {1}, adjusting for client {2}",
                       clientThrottleLimit, ThrottlingThresholdOn, ipBase);
            clientThrottleLimit = ThrottlingThresholdOn - 1;
        }
  
        
        //
        // Begin the enforcement.
        //

        // If client exceeded the throttling limit and is temporarily banned, meaning she 
        // recently exceeded some limit, then we want to drop the request. We don't want 
        // to log an event to reduce spam. It doesn't matter what state we're in now 
        // (tracking, throttling, or blocking).
        ulong secondsSinceLastInfraction = (ulong)((DateTime.UtcNow - clientRec.LastInfractionTime).TotalSeconds);
        if (secondsSinceLastInfraction < (ulong)BanTimeInSeconds &&
            clientRec.Count > clientThrottleLimit)
        {
            // No event.
            Trace.High("RequestTracker: TempBanned for {0}({1}), count {2}, global {3}, infraction {4}",
                       ipAddress, ipBase, clientRec.Count, globalRequestsInProgress, secondsSinceLastInfraction);

            return ClientState.TempBanned;
        }

        // Nothing more to do if we're only tracking, already did it
        if (currentState == TrackerState.Tracking)
        {
            Trace.Low("RequestTracker: Ok [track only] for {0}({1}), count {2} (limit {3}), global {4}",
                      ipAddress, ipBase, clientRec.Count, clientThrottleLimit, globalRequestsInProgress);

            return ClientState.Ok;
        }

        // Brand new infringement if one of the following:
        // 1. We're blocking everything
        // 2. We're throttling and client exceeded her allowed count
        if (currentState == TrackerState.Blocking ||
            (currentState == TrackerState.Throttling && clientRec.Count > clientThrottleLimit))
        {
            clientRec.LastInfractionTime = DateTime.UtcNow;

            Trace.High("RequestTracker: LimitExceeded for {0}({1}), count {2} (limit {3}), global {4}",
                       ipAddress, ipBase, clientRec.Count, clientThrottleLimit, globalRequestsInProgress);

          Xom.NtEvent(XEvent.Id.AAM_ANTIDOS_LIMIT_EXCEEDED, 
                    "The client at ip address {0}({1}) has been temporarily banned.\r\n" +
                    "Tracking state: {2}.\r\n" +
                    "Request threshold: {3}.\r\n" +
                    "Client requests in progress: {4}.\r\n" +
                    "Global requests in progress: {5}.\r\n" +
                    "Ban time: {6} seconds.", 
                    ipAddress,
                    ipBase,
                    currentState,
                    clientThrottleLimit,
                    clientRec.Count,
                    globalRequestsInProgress,
                    BanTimeInSeconds);

            return ClientState.LimitExceeded;
        }

        Trace.Low("RequestTracker: Ok for {0}({1}), count {2}, global {3}, state {4}",
                  ipAddress, ipBase, clientRec.Count, globalRequestsInProgress, currentState);

        return ClientState.Ok;

    }

    // -------------------------------------------------------------------------------
    // Decrement - called at the end of every request. clientRec may be null, which could 
    // happen if Increment never looked up the client record.  This ok, and we should 
    // handle it.  
    //
    // We will always decrement the global count, though.
    // -------------------------------------------------------------------------------
    internal void Decrement(ClientRecord clientRec)
    {
        // We originally incremented the requests, then the clients. Let's undo that in 
        // reverse order.

        if (clientRec != null)
        {
            Debug.Assert(clientRec.Count > 0);
            Debug.Assert(!clientRec.IsReusable);
           
            // We care about 1 -> 0 transitions
            int newCount = Interlocked.Decrement(ref clientRec.Count);
            if (newCount == 0)
            {
                Interlocked.Decrement(ref _GlobalActiveClients);
                ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].ActiveClients.RawValue = _GlobalActiveClients;
            }
        }

        // Now the request...
        Interlocked.Decrement(ref _GlobalRequestsInProgress);
        ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].ActiveRequests.RawValue = _GlobalRequestsInProgress;
        
        ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].AverageRequestsPerActiveClient.RawValue = AverageRequestsPerActiveClient;
    }
    
    // -------------------------------------------------------------------------------
    // GetReportAllClients - returns a list of all clients being tracked. Watch out.
    // -------------------------------------------------------------------------------
    internal string GetReportAllClients()
    {
        // Get local copy of dictionary (for thread safety)
        LimitedSizeDictionary<IPAddress, ClientRecord> clientDict = _ClientDictionary;
        if (clientDict == null)
        {
            return "Tracking is currently turned off.";
        }

        return clientDict.ToString();
    }


    public override string ToString()
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendFormat("RequestTracker:\r\n");
        sb.AppendFormat("  TrackingThresholdOff   : {0}\r\n", TrackingThresholdOff);
        sb.AppendFormat("  TrackingThresholdOn    : {0}\r\n", TrackingThresholdOn);
        sb.AppendFormat("  ThrottlingThresholdOff : {0}\r\n", ThrottlingThresholdOff);
        sb.AppendFormat("  ThrottlingThresholdOn  : {0}\r\n", ThrottlingThresholdOn);
        sb.AppendFormat("  BlockingThresholdOff   : {0}\r\n", BlockingThresholdOff);
        sb.AppendFormat("  BlockingThresholdOn    : {0}\r\n", BlockingThresholdOn);
        sb.AppendFormat("  MaxRecordsToTrack      : {0}\r\n", MaxRecordsToTrack);
        sb.AppendFormat("  BanTimeInSeconds       : {0}\r\n", BanTimeInSeconds);
        sb.AppendFormat("  CurrentState           : {0}\r\n", CurrentState);
        return sb.ToString();
    }


    // 
    // Begin private members
    //
    
    // -------------------------------------------------------------------------------
    // GetThresholdValues - parses the config string "<on threshold>, <off threshold>". It 
    // does so smartly.
    // -------------------------------------------------------------------------------
    private static void GetThresholdSettingValues(string threshold, out int high, out int low)
    {
        string[] tokens = threshold.Split(new char[] { ',', ';' });
        if (tokens.Length == 0 || tokens.Length > 2)
        {
            throw new ArgumentException("Parameter should be in the format \"<high>, <low>\"", "threshold");
        }

        if (tokens.Length == 1)
        {
            high = int.Parse(tokens[0]);
            low = high;
        }
        else
        {
            high = int.Parse(tokens[0]);
            low  = int.Parse(tokens[1]);
            if (high < low)
            {
                int t = high;
                high = low;
                low = t;
            }
        }
    }



    // -------------------------------------------------------------------------------
    // GetClientRecordAndIncrement - wrapper for retrieving a ClientRecord from the 
    // dictionary
    // -------------------------------------------------------------------------------
    private ClientRecord GetClientRecordAndIncrement(IPAddress ipKey)
    {
        // Get local copy of dictionary (for thread safety)
        LimitedSizeDictionary<IPAddress, ClientRecord> clientDict = _ClientDictionary;
        if (clientDict == null)
        {
            return null;
        }

        // Get client record. The dictionary isn't thread safe, so we have to protect 
        // access to the Get() call with a lock. We also want to increment clientRec.Count 
        // before releasing the lock, so that the record doesn't end up getting 
        // repurposed. 
        //
        // Don't hold this lock any longer than necessary, though.
        ClientRecord clientRec;
        int newCount = 0;
        lock (clientDict)
        {
            clientRec = clientDict.Get(ipKey);

            // We care about 0 -> 1 transitions
            newCount = Interlocked.Increment(ref clientRec.Count);
            // Store client record in local context. Need this on the EndRequest callback.
            AuthUtils.SetClientRecord(HttpContext.Current, clientRec);
        }
        if (newCount == 1)
        {
            Interlocked.Increment(ref _GlobalActiveClients);
            ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].ActiveClients.RawValue = _GlobalActiveClients;
        }

        ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].AverageRequestsPerActiveClient.RawValue = AverageRequestsPerActiveClient;

        return clientRec;
    }



    // -------------------------------------------------------------------------------
    // UpdateState - given a new measurement, updates the internal state. This will log an 
    // event when the state changes. We move up or down in single state increments, even 
    // though multiple states may have been "jumped".  
    // -------------------------------------------------------------------------------
    private void UpdateState(int reqCountGlobal)
    {
        switch (_State)
        {

        case TrackerState.Off:
            if (reqCountGlobal >= TrackingThresholdOn)
            {
                _State = TrackerState.Tracking;
                TurnOnTracking();
//                 Xom//NtEvent(XEvent.Id.AAM_INFO_TRACKING_START, String.Format(
//                            "Anti-Dos request tracking for up to {0} records has been turned on. Count {1} exceeds threshold {2}.",
//                            MaxRecordsToTrack, reqCountGlobal, TrackingThresholdOn));
            }
            break;

        case TrackerState.Tracking:
            if (reqCountGlobal >= ThrottlingThresholdOn)
            {
                _State = TrackerState.Throttling;
                Xom.NtEvent(XEvent.Id.AAM_INFO_THROTTLING_START,
                           "Anti-Dos request throttling has been turned on. Count {0} exceeds threshold {1}.",
                           reqCountGlobal, ThrottlingThresholdOn);
            }
            else if (reqCountGlobal < TrackingThresholdOff)
            {
                _State = TrackerState.Off;
                TurnOffTracking();
//                 Xom//NtEvent(XEvent.Id.AAM_INFO_TRACKING_STOP, String.Format(
//                            "Anti-Dos request tracking has been turned off. Count {0} is below threshold {1}.",
//                            reqCountGlobal, TrackingThresholdOff));
            }
            break;

        case TrackerState.Throttling:
            if (reqCountGlobal >= BlockingThresholdOn)
            {
                _State = TrackerState.Blocking;
                Xom.NtEvent(XEvent.Id.AAM_INFO_BLOCKING_START, 
                           "Anti-Dos request blocking has been turned on. Count {0} exceeds threshold {1}.",
                           reqCountGlobal, BlockingThresholdOn);
            }
            else if (reqCountGlobal < ThrottlingThresholdOff)
            {
                _State = TrackerState.Tracking;
                Xom.NtEvent(XEvent.Id.AAM_INFO_THROTTLING_STOP, 
                           "Anti-Dos request throttling has been turned off. Count {0} is below threshold {1}. Tracking is still enabled.",
                           reqCountGlobal, ThrottlingThresholdOff);
            }
            break;

        case TrackerState.Blocking:
            if (reqCountGlobal < BlockingThresholdOff)
            {
                _State = TrackerState.Throttling;
                Xom.NtEvent(XEvent.Id.AAM_INFO_BLOCKING_STOP, 
                           "Anti-Dos request blocking has been turned off. Count {0} is below threshold {1}. Throttling is still enabled.",
                           reqCountGlobal, BlockingThresholdOff);
            }
            break;
        }
            
        ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].CurrentState.RawValue = (int)_State;
    }

    // -------------------------------------------------------------------------------
    // TurnOnTracking - called to enable the whole system. Allocates memory.
    // -------------------------------------------------------------------------------
    private void TurnOnTracking()
    {
        _ClientDictionary = new LimitedSizeDictionary<IPAddress, ClientRecord>((uint)MaxRecordsToTrack);
    }

    // -------------------------------------------------------------------------------
    // TurnOffTracking - called to disable the whole system. Frees up memory.
    // -------------------------------------------------------------------------------
    private void TurnOffTracking()
    {
        // oh .net, you and your garbage collection...
        _ClientDictionary = null;
    }

    // -------------------------------------------------------------------------------
    // Accessors for the settings.  Changes to the thresholds should be done through the 
    // Set*Threshold() helper functions.
    // -------------------------------------------------------------------------------

    internal int TrackingThresholdOff
    {
        get { return _TrackingThresholdOff; }
    }

    internal int TrackingThresholdOn
    {
        get { return _TrackingThresholdOn; }
    }

    internal int ThrottlingThresholdOff
    {
        get { return _ThrottlingThresholdOff; }
    }

    internal int ThrottlingThresholdOn
    {
        get { return _ThrottlingThresholdOn; }
    }

    internal int BlockingThresholdOff
    {
        get { return _BlockingThresholdOff; }
    }

    internal int BlockingThresholdOn
    {
        get { return _BlockingThresholdOn; }
    }

    internal int MaxRecordsToTrack
    {
        get { return _MaxRecordsToTrack; }
        set 
        { 
            if (value < 0)
                throw new ArgumentException("Value cannot be negative");
            _MaxRecordsToTrack = value; 
            LimitedSizeDictionary<IPAddress, ClientRecord> clientDict = _ClientDictionary;
            if (clientDict != null)
            {
                clientDict.MaxSize = (uint)_MaxRecordsToTrack;
            }
        }
    }

    internal int BanTimeInSeconds
    {
        get { return _BanTimeInSeconds; }
        set { _BanTimeInSeconds = value; }
    }

    internal int GlobalRequestsInProgress
    {
        get { return _GlobalRequestsInProgress; }
    }

    internal int GlobalActiveClients
    {
        get { return _GlobalActiveClients; }
    }

    internal TrackerState CurrentState
    {
        get { return _State; }
    }

    internal int AverageRequestsPerActiveClient
    {
        get 
        {
            int numClients = _GlobalActiveClients;
            int numRequests = _GlobalRequestsInProgress;
            if (numClients <= 0 || numRequests < numClients)
            {
                // Every client is making at least 1 requests.. or else they wouldn't be a 
                // client, now would they?  So let's return 1 for the edge cases & little 
                // race conditions that can crop up.
                Trace.High("AverageRequestsPerActiveClient: numClients {0}, numRequests {1}", numClients, numRequests);
                return 1;
            }
            // We will always return a value >= 1 and < infinity.
            Debug.Assert(numRequests >= numClients);
            Debug.Assert(numClients > 0);
            return (int)(numRequests / numClients);
        }
    }


    // Bunch of settings. The "threshold" ones are in RequestsInProgress units.
    
    private volatile int _TrackingThresholdOff   = 0;
    private volatile int _TrackingThresholdOn    = 0;
    private volatile int _ThrottlingThresholdOff = 0;
    private volatile int _ThrottlingThresholdOn  = 0;
    private volatile int _BlockingThresholdOff   = 0;
    private volatile int _BlockingThresholdOn    = 0;
    private volatile int _MaxRecordsToTrack      = 0;  // must store since dictionary may be unavailable
    private volatile int _BanTimeInSeconds       = 0;

    // Internal members

    private volatile int          _GlobalRequestsInProgress   = 0;
    private volatile int          _GlobalActiveClients        = 0;
    private volatile TrackerState _State                      = TrackerState.Off;
    
    // Our super fancy limited-size dictionary. If you reference this, please make sure to 
    // first grab a local reference. This member could go away at any point, so using 
    // exclusively a local reference is the thread-safe thing to do.

    private volatile LimitedSizeDictionary<IPAddress, ClientRecord> _ClientDictionary = null;


}



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\module\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\module\AuthHandlers.cs ===
// 
// AuthHandlers.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Active Auth Module
// Xbox Online Service
//
// Handlers for various Active Auth Module functions, like Passport ticket verification.
// 
// Author: kgoodier 6/2007
//

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IdentityModel.Tokens;
using System.IO;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using System.Web;
using System.Xml;
using System.Linq;

using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.passport;
using xonline.common.exceptions;
using xonline.config.sts.databaseconfig;
using xonline.config.sts.interfaces;

using Microsoft.IdentityModel.Tokens;
using Microsoft.IdentityModel.Configuration;
using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth.Claims;

using Microsoft.Passport.RPS;
using xonline.server.activeauth.common;

namespace xonline.server.activeauth.module
{

// -----------------------------------------------------------------------------------
// AuthHandlers class 
// -----------------------------------------------------------------------------------
internal class AuthHandlers
{

    //
    // Global members (shortcuts)
    //

    /// <summary>When true, we will look at the headers sent to use by the load balancer which should be terminating the SSL connection.</summary>
    internal static bool UseLoadBalancerSslHeaders { get; set; }

    private readonly HttpApplication httpApp;
    private readonly HttpContext     httpCtx;
  

    //
    // State members
    //
    // Many of these will be set along the way of calling the various handlers.
    //

    private string                      _handlerStatus = "";
    private HResult                     _hr            = HResult.S_OK;
    private ApiPolicy                   _apiPolicy     = null;
    private ulong                       _passportCId   = 0;
    private ulong                       _passportPuid  = 0;
    private ulong                       _liveXuid      = 0;
    private DateTime                    _notAfterDateTime;
    private DateTime                    _issueInstantDateTime;
    private string                      _tokenString   = "";
    private string                      _certDeviceId  = String.Empty;
    private Floken                      _flowToken     = Floken.None;
    private ulong                       _tpsHistory    = 0;
    private RequestTracker.ClientState  _antidosStatus = RequestTracker.ClientState.Ok;
    private ulong?                      _passportAppId = null;

    // SSL related values
    private bool                        _connectionIsSsl;
    private string                      _certSubject;
    private string                      _certThumbprint;
    private Guid?                       _partnerId;
    private bool                        _certIsValidWP;
    private bool                        _hasClientCert;

    private ActiveAuthMethod            _clientAuthMethod = ActiveAuthMethod.NOTSPECIFIED;

    // Constructor
    internal AuthHandlers(HttpApplication application)
    {
        httpApp = application;
        httpCtx = application.Context;
    }

    // -------------------------------------------------------------------------------
    // Accessors
    // -------------------------------------------------------------------------------

    internal string HandlerStatus
    {
        get { return _handlerStatus; }
    }

    internal HResult HandlerHResult
    {
        get { return _hr; }
    }

    internal ulong PassportPuid
    {
        get { return _passportPuid; }
    }

    internal ulong LiveXuid 
    {
        get { return _liveXuid; }
    }

    internal Floken FlowToken
    {
        get { return _flowToken; }
    }

    internal ulong TpsHistory
    {
        get { return _tpsHistory; }
    }

    internal ApiPolicy Policy
    {
        get { return _apiPolicy; }
    }

    internal RequestTracker.ClientState AntidosStatus
    {
        get { return _antidosStatus; }
    }

    internal ulong? PassportAppId
    {
        get { return _passportAppId; }
    }

    internal string CertSubject
    {
        get { return _certSubject; }
    }

    internal bool IsSSL
    {
        get { return _connectionIsSsl; }
    }

    // Xbanc stuff

    public static readonly byte[] ThrottleValueXBancKeyPrefix = new byte[] {
        (byte)'A', (byte)'A', (byte)'T', (byte)'V'
    };

    public byte[] MakeXBancKey(string api)
    {
        MemoryStream ms = new MemoryStream(128);
        BinaryWriter bw = new BinaryWriter(ms);
        bw.Write(ThrottleValueXBancKeyPrefix);
        bw.Write("|");
        bw.Write(api);
        bw.Write("|");
        if (PassportPuid != 0)
        {
            bw.Write(PassportPuid);
        }
        else
        {
            bw.Write(httpCtx.Request.UserHostAddress);
        }
        return ms.ToArray();
    }

    // -------------------------------------------------------------------------------
    // HandleRequest - Entry point for this class to handle a request start to end.
    //
    // Returns
    // - true if everything is okay and request should be allowed through.
    // - false if an error occurred and the request should be aborted. The response will 
    // have been built for you.
    // - An exception will be thrown for the unexpected errors.
    // -------------------------------------------------------------------------------
    internal bool HandleRequest()
    {
        // Sequence of events:
        //
        // parse url
        // lookup policy
        // verify ssl, if required
        // do anti-dos, if required
        // do passport, if required
        // do throttling, if required
        // build AAInfo to provide to application
        //

        // oh sweet macros, where have you gone?

        _handlerStatus = "ClassifyMethod";
        if (!HandleClassifyMethod())
            return false;

        _handlerStatus = "PolicyLookup";
        if (!HandlePolicyLookup())
            return false;

        _handlerStatus = "Connection";
        if (!HandleConnection())
            return false;

        _handlerStatus = "Ssl";
        if (!HandleSsl())
            return false;

        _handlerStatus = "AntiDos";
        if (!HandleAntiDos())
            return false;

        _handlerStatus = "Authorization";
        if (!HandleAuthorization())
            return false;

        _handlerStatus = "Throttle";
        if (!HandleThrottle())
            return false;

        _handlerStatus = "BuildAuthInfo";
        if (!HandleBuildAuthInfo())
            return false;

        _handlerStatus = "Ok";
        return true;
    }


    // -------------------------------------------------------------------------------
    // HandleClassifyMethod
    //
    // Classify the authentication method the client is trying to use
    // -------------------------------------------------------------------------------
    private bool HandleClassifyMethod()
    {
        // Authentication type determination
        string authType = null;
        string authValue = httpCtx.Request.Headers["Authorization"];
        if (null == authValue)
        {
            authValue = httpCtx.Request.Headers["X-Authorization"];
        }
        string[] authTokens;
        if (ParseAuthorizationHeader(authValue, out authTokens) &&
            authTokens != null &&
            authTokens.Length >= 1)
        {
            authType = authTokens[0];
        }

        // SSL determination
        GetSslInfo(httpCtx.Request);

        // Now classify methods
        _clientAuthMethod = ActiveAuthMethod.NOTSPECIFIED;

        if (Thread.CurrentPrincipal is ClaimsPrincipal)
        {
            // Don't actually care if they did this via the XBL2.0 schema or what. Just
            // care that they were able to give us a valid token with claims.
            _clientAuthMethod |= ActiveAuthMethod.XBL20;
        }
        
        if (authType == AuthUtils.PASSPORT_AUTH_SCHEME_TOKEN)
        {
            _clientAuthMethod |= ActiveAuthMethod.WLID10;
        }
        else if (authType == AuthUtils.XBL1_0_AUTH_SCHEME_TOKEN)
        {
            _clientAuthMethod |= ActiveAuthMethod.XBL10;
        }

        if (_hasClientCert)
        {
            _clientAuthMethod |= ActiveAuthMethod.X509MUTUAL;
            if (_certIsValidWP)
            {
                _clientAuthMethod |= ActiveAuthMethod.X509WP;
            }
            else if (_partnerId.HasValue)
            {
                _clientAuthMethod |= ActiveAuthMethod.X509TRUSTEDMUTUAL;
            }
        }
        // Anything set?
        if (_clientAuthMethod == ActiveAuthMethod.NOTSPECIFIED)
        {
            _clientAuthMethod |= ActiveAuthMethod.NONE;
        }

        return true;
    }

    // -------------------------------------------------------------------------------
    // HandlePolicyLookup
    //
    // Uses the parsed url key, which should represent an api, to look up the policy. Also 
    // determines the default policy to use, if needed.
    //
    // Sets _apiPolicy
    // -------------------------------------------------------------------------------
    private bool HandlePolicyLookup()
    {
        Trace.Low("AuthHandlers.HandlePolicyLookup called");

        // List of potential policy id lookup keys. We'll start looking them up from the
        // beginning of the list and work our way through until a policy is found.
        List<string> policyIdKeys = new List<string>();

        // Extract the flow token from the http headers at this point (early).
        string flowTokenString = httpCtx.Request.Headers[Floken.XHTTPHDR_FLOWTOKEN];
        _flowToken = new Floken(flowTokenString);

        // First see if application has set the policy id key in the HttpContext. This is 
        // the top priority lookup.
        if (!String.IsNullOrEmpty(ActiveAuthModule.PolicyIdKey))
        {
            policyIdKeys.Add(PolicyManager.GetUrlPrefixedPolicyIdKey(ActiveAuthModule.PolicyIdKey));
        }

        // If this is a Soap request then we also need to append the API to the AbsolutePath for the Policy lookup
        string soapAction = httpCtx.Request.Headers["SOAPAction"];
        if (!string.IsNullOrEmpty(soapAction))
        {
            // Need to parse the API name of the urn
            int iStart = soapAction.LastIndexOf('/');
            if (-1 < iStart)
            {
                policyIdKeys.Add(httpCtx.Request.Url.AbsolutePath + soapAction.Substring(iStart, soapAction.Length - iStart - 1));
            }
            else
            {
                Trace.Low("  Couldn't parse SOAPAction header! [{0}]", soapAction);
            }
        }

        // Add the url as a possible key. Secondary lookup.
        policyIdKeys.Add(httpCtx.Request.Url.AbsolutePath);

        // And finally, we support a default policy. Whether we actually have a default policy
        // defined or not is dependent on the t_activeauth_policies configuration. The 
        // determination of which default policy to apply depends on what we can detect in 
        // the request:
        //   default/anonymous - no authentication information present
        //   default/xbl20 - claims ticket present ("XBL2.0" auth header)
        //   default/xbl10 - stsv1 ticket present ("XBL1.0" auth header)
        //   default/wlid10 - passport rps ticket present ("WLID1.0" auth header)

        if ((_clientAuthMethod & ActiveAuthMethod.XBL20) > 0)
        {
            // Don't actually care if they did this via the XBL2.0 schema or what. Just
            // care that they were able to give us a valid token with claims.
            policyIdKeys.Add(AuthUtils.DEFAULTPOLICY_XBL20);
        }
        else if ((_clientAuthMethod & ActiveAuthMethod.WLID10) > 0)
        {
            policyIdKeys.Add(AuthUtils.DEFAULTPOLICY_WLID10);
        }
        else if ((_clientAuthMethod & ActiveAuthMethod.XBL10) > 0)
        {
            policyIdKeys.Add(AuthUtils.DEFAULTPOLICY_XBL10);
        }
        else
        {
            policyIdKeys.Add(AuthUtils.DEFAULTPOLICY_ANONYMOUS);
        }

        //
        // Done with policy keys. Now actually look up the policy.
        //
        //we need to know which key we found for the policy as
        //the apipolicy object does not in itself know what the key
        //to find itself, only the dictionary knows that so we have to
        //save it.
        string foundPolicykey = null;

        foreach (string key in policyIdKeys)
        {
            _apiPolicy = ActiveAuthModule.PolicyMgr.LookupPolicy(key);
            if (_apiPolicy != null)
            {
                foundPolicykey = key;
                break;
            }
        }

        AuthUtils.SetPolicy(httpCtx, _apiPolicy, foundPolicykey);

        if (_apiPolicy == null)
        {
            Debug.Assert(policyIdKeys.Count > 0);
            AuthResponder.SetUnknownUrl(httpCtx, policyIdKeys[0]);
            return false;
        }

        // Augment the ClaimsPrincipal with new findings from passport
        ClaimsIdentity identity = GetOrCreateActiveAuthIdentity();
        if (identity != null)
        {
            Claim claim = AuthClaimTypes.Create(
                AuthClaimTypes.FlowToken,
                (_flowToken.IsValid) ? _flowToken.FlowToken.ToString("X") : Floken.NewFloken().FlowToken.ToString("X"),
                AuthClaimTypes.ValueTypes[AuthClaimTypes.FlowToken],
                "aamodule");
            identity.Claims.Add(claim);
        }

        // Increment requests-in-progress perf counter now. This is as early as we can 
        // possibly do it, since we need to know the policy name. AuthUtils.GetPolicy() 
        // will always return a valid ApiPolicy object if we incremented this counter, by 
        // the way.

        ModulePerPolicyCounters.Counters.RequestsInProgress.Increment();
        ModulePerPolicyCounters.Counters[_apiPolicy.PolicyIdKeyForPerf].RequestsInProgress.Increment();

        // Moved ReqTracker global counter management here to tightly couple to the SetPolicy call
        // This solves the cleanup problem in Application_EndRequest which keys off of policy.
        ActiveAuthModule.ReqTracker.Increment();

        Trace.Normal("  {0}", _apiPolicy.ToString());
        return true;
    }

    /// <summary>
    /// Process connection information.  Add available information to claims.
    /// </summary>
    private bool HandleConnection()
    {
        Trace.Low("AuthHandlers.HandleConnection called");
        ClaimsIdentity identity = GetOrCreateActiveAuthIdentity();

        if (identity != null)
        {
            string ip = httpCtx.Request.UserHostAddress;
            identity.Claims.Add(AuthClaimTypes.Create(AuthInternalClaimTypes.Ip, ip, ClaimValueTypes.String, "aamodule"));

            if (_hasClientCert)
            {
                identity.Claims.Add(AuthClaimTypes.Create(AuthUtils.AACLAIM_CLIENTCERT_SUBJECTNAME, _certSubject, ClaimValueTypes.String, "aamodule"));
                if (_partnerId.HasValue) identity.Claims.Add(AuthClaimTypes.Create(AuthUtils.AACLAIM_PARTNERID, _partnerId.Value.ToString(), ClaimValueTypes.String, "aamodule"));
                if (_certIsValidWP) identity.Claims.Add(AuthClaimTypes.Create(AuthClaimTypes.DeviceType, AuthDeviceTypes.WindowsPhone, ClaimValueTypes.String, "aamodule"));
            }
        }

        return true;
    }


    // -------------------------------------------------------------------------------
    // HandleSsl
    //
    // If policy requires SSL, ensure the client is using it. Pretty simple unless we 
    // decide to use an SSL accelerator.
    //
    // Sets _certDeviceId
    // -------------------------------------------------------------------------------
    private bool HandleSsl()
    {
        Debug.Assert(_apiPolicy != null);

        Trace.Low("AuthHandlers.HandleSsl called");

        // Perf counters
        if (_connectionIsSsl)
        {
            ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].RequestsPerSecSSL.Increment();
        }
        else
        {
            ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].RequestsPerSecNonSSL.Increment();
        }

        // Does this api even require ssl? If it doesn't, but the client is using SSL, 
        // that's ok.
        if (_apiPolicy.RequiresSsl && !_connectionIsSsl)
        {
            Trace.High("  SSL is required for {0} but client isn't using it", _apiPolicy.PolicyIdKey);
            AuthResponder.SetSslRequired(httpCtx);
            return false;
        }

        // Is the cert DeviceId needed? This is ONLY FOR WINDOWS PHONE 7 CALLERS.
        if (_apiPolicy.RequiresWPClientCert)
        {
            if (!_hasClientCert)
            {
                Trace.High("  Client certificate is required for {0} but client isn't using it", _apiPolicy.PolicyIdKey);
                AuthResponder.SetClientCertRequired(httpCtx);
                return false;
            }

            if (!_certIsValidWP)
            {
                Trace.High("  Client certificate is untrusted for {0}", _apiPolicy.PolicyIdKey);
                AuthResponder.SetClientCertUntrusted(httpCtx);
                return false;
            }
        }

        // Get it if we have the certDeviceId from this object
        if (_certIsValidWP)
        {
            GetWindowsPhoneInfo();
        }

        return true;
    }

    // -------------------------------------------------------------------------------
    // HandleAuthorization
    //
    // Examines request headers for passport ticket or XBL1.0 SAML token and cracks it
    //
    // -------------------------------------------------------------------------------
    private bool HandleAuthorization()
    {
        Debug.Assert(_apiPolicy != null);

        // Does this api even require a ticket?
        if (!_apiPolicy.RequiresAuthentication && _apiPolicy.AllowedAuthMethods == ActiveAuthMethod.NOTSPECIFIED)
        {
            ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].RequestsPerSecUnauthenticated.Increment();
            return true;
        }

        Trace.Low("AuthHandlers.HandleAuthorization called");
        ModuleGlobalCounters.Counters[ActiveAuthModule.AppPoolId].RequestsPerSecAuthenticated.Increment();

        // At this point, we've completely determined the client's various authentication
        // methods. Enforce.

        _handlerStatus = "ClientAllowed";
        if (!_apiPolicy.IsClientAllowed(_clientAuthMethod))
        {
            string headerVal = "methods=" + _apiPolicy.AllowedAuthMethods.ToString();
            AuthResponder.SetAuthorizationRequired(httpCtx, headerVal);
            return false;
        }

        if ((_clientAuthMethod & ActiveAuthMethod.X509TRUSTEDMUTUAL) != 0)
        {
            // If the request is from a trusted partner cert using mutual auth
            // ensure they are allowed to call the API.
            if (!_apiPolicy.IsPartnerAllowed(_partnerId.Value))
            {
                Trace.High("  Client certificate is untrusted for {0}", _apiPolicy.PolicyIdKey);
                AuthResponder.SetClientCertUntrusted(httpCtx);
                return false;
            }
        }

        // The XblAuthProtocolModule in Microsoft.XboxLive.Auth.dll is expected to handle
        // "XBL2.0" authorization headers. Since it does its work in AuthenticateRequest
        // callback, it will have completed by now. We'll assume any Thread.CurrentPrincipal
        // that is present means some other component -- WIF, XblAuthProtocolModule, etc --
        // has already authenticated the user.

        // Additional authentication
        ClaimsIdentity identity = GetOrCreateActiveAuthIdentity();
        if (identity != null)
        {
            // Add some claims only we know about
            System.Net.IPAddress srcIP = new System.Net.IPAddress(0);
            ushort srcPort = 0;
            SGAddressValidator.GetSourceAddress(httpCtx, ref srcIP, ref srcPort);
            string srcIpPort = srcIP + ":" + srcPort;

            // Add to the device identity, but with us as issuer
            Claim claimClientIp = AuthClaimTypes.Create(AuthClaimTypes.ClientIpPort, srcIpPort, AuthClaimValueTypes.IpAddress, "aamodule");
            identity.Claims.Add(claimClientIp);
        }

        if (AuthUtils.XBL2_0_AUTH_SCHEME_TOKEN == _apiPolicy.AuthorizationHeader ||
            (_clientAuthMethod & ActiveAuthMethod.XBL20) > 0)
        {
            IClaimsPrincipal claimsPrincipal = Thread.CurrentPrincipal as IClaimsPrincipal;
            if (claimsPrincipal != null)
            {
                // @@@ AUTHORIZE AUTHORIZE AUTHORIZE!!!
                // AudienceUri? RP stuff?

                // No more authorization required, this is the new code path and we're 
                // done here.
                return true;
            }
            else
            {
                // An XBL2.0 authorization is required. Let client know this.
                AuthResponder.SetAuthorizationRequired(httpCtx, AuthUtils.XBL2_0_AUTH_SCHEME_TOKEN);
                return false;
            }
        }

        // Go old-school AAModule style

        // Sample client header:
        //
        // Authorization: WLID1.0 t=<base64 ticket data>
        // 
        // Let's get parsing!

        string authValue = httpCtx.Request.Headers["Authorization"];

        if (null == authValue)
        {
            if (AuthUtils.XBL1_0_AUTH_SCHEME_TOKEN == _apiPolicy.AuthorizationHeader)
            {   // try alternate location for header
                authValue = httpCtx.Request.Headers["X-Authorization"];
            }
        }

        string[] authTokens = null;
        bool isParsedHeader = false;
        if (authValue != null)
        {
            isParsedHeader = ParseAuthorizationHeader(authValue, out authTokens);
        }

        if (_apiPolicy.AllowedAuthMethods != ActiveAuthMethod.NOTSPECIFIED)
        {
            // New code path. We've alread validated the client is allowed to do whatever
            // he is trying to do :), so we just need to actually do that.
            // Note: This is the path when vc_allowed_auth_methods is set!

            if (isParsedHeader && 0 == String.Compare(authTokens[0], AuthUtils.PASSPORT_AUTH_SCHEME_TOKEN, true))
            {
                return ValidateAuthorizationWLID10(authValue, authTokens);
            }
            else if (isParsedHeader && 0 == String.Compare(authTokens[0], AuthUtils.XBL1_0_AUTH_SCHEME_TOKEN, true))
            {
                return ValidateAuthorizationXBL10(authValue, authTokens);
            }

            // Else it was XBL2.0 or X509, which has already been processed.
            return true;
        }
        else
        {
            // Old path
            if (!isParsedHeader)
            {
                Trace.High("  Incorrect tokens in header value: {0}", authValue);
                AuthResponder.SetAuthorizationRequired(httpCtx, _apiPolicy);
                return false;
            }

            if (AuthUtils.XBL1_0_AUTH_SCHEME_TOKEN != _apiPolicy.AuthorizationHeader)
            {
                if (0 == String.Compare(authTokens[0], AuthUtils.PASSPORT_AUTH_SCHEME_TOKEN, true))
                {
                    return ValidateAuthorizationWLID10(authValue, authTokens);
                }
            }
            else
            {
                if (0 == String.Compare(authTokens[0], AuthUtils.XBL1_0_AUTH_SCHEME_TOKEN, true))
                {
                    return ValidateAuthorizationXBL10(authValue, authTokens);
                }
            }
        }

        // Bad Auth Token
        Trace.High("  Authorization token \"{0}\" should be \"{1}\" or \"{2}\"",
                   authTokens[0], AuthUtils.PASSPORT_AUTH_SCHEME_TOKEN, AuthUtils.XBL1_0_AUTH_SCHEME_TOKEN);
        AuthResponder.SetAuthorizationRequired(httpCtx, _apiPolicy);
        return false;
    }

    // -------------------------------------------------------------------------------
    // HandleAntiDos
    //
    // -------------------------------------------------------------------------------
    private bool HandleAntiDos()
    {
        Debug.Assert(_apiPolicy != null);

        if (!_apiPolicy.AntiDosEnabled)
        {
            return true;
        }

        Trace.Low("AuthHandlers.HandleAntiDos called");

        _antidosStatus = ActiveAuthModule.ReqTracker.HandleRequest(httpCtx.Request.UserHostAddress);

        // Take action. RequestTracker will trace and log events as necessary.
        switch (_antidosStatus)
        {
        case RequestTracker.ClientState.Ok:
            return true;

        case RequestTracker.ClientState.LimitExceeded:
        case RequestTracker.ClientState.TempBanned:
            AuthResponder.SetServerUnavailable(httpCtx);
            ModulePerPolicyCounters.Counters.TotalBlockedRequests.Increment();
            ModulePerPolicyCounters.Counters[_apiPolicy.PolicyIdKeyForPerf].TotalBlockedRequests.Increment();
            ModulePerPolicyCounters.Counters.BlockedRequestsPerSec.Increment();
            ModulePerPolicyCounters.Counters[_apiPolicy.PolicyIdKeyForPerf].BlockedRequestsPerSec.Increment();
            return false;
        }
        
        return true;
    }

    // -------------------------------------------------------------------------------
    // HandleThrottle
    //
    // Takes care of throttling a given xrl keyed by number of requests from a puid/xuid.  
    // Falls back to IP address if policy is unauthenticated.
    // -------------------------------------------------------------------------------
    private bool HandleThrottle()
    {
        Debug.Assert(_apiPolicy != null);
       
        if (!_apiPolicy.ThrottleEnabled)
        {
            return true;
        }

        Trace.Low("AuthHandlers.HandleThrottle called");

        // Ideally we use passport puid to track the user. If this is not available, then 
        // we'll use the ip address.
        _tpsHistory = 0;
        byte[] xbancKey = MakeXBancKey(_apiPolicy.PolicyIdKeyForXbanc);
        HResult hr = HResult.E_FAIL;
        try
        {
            XBanc xb = new XBanc();
            hr = xb.Increment(
                xbancKey,                                   // key
                1,                                          // 1 request, 1 increment
                (uint)_apiPolicy.ThrottleHalfLifeSeconds,   // halflife
                0,                                          // absolute expiry
                0,                                          // sliding expiry
                out _tpsHistory);                           // the value
        }
        catch (Exception e)
        {
            Trace.Error("HandleThrottle: XBanc threw exception: {0}", e.ToString());
        }

        if (HResult.Failed(hr))
        {
            // Not fatal. No event spam.
            Trace.Error("HandleThrottle: XBanc.Increment failed. hr = {0}, puid=0x{1:X}, ip={2}, api={3} [pass]",
                        hr, PassportPuid, httpCtx.Request.UserHostAddress, _apiPolicy.PolicyIdKeyForXbanc);
            return true;
        }

        // Verify threshold
        if (_tpsHistory >= (ulong)_apiPolicy.ThrottleThreshold)
        {
            AuthResponder.SetServerUnavailable(httpCtx);
            ModulePerPolicyCounters.Counters.TotalThrottledRequests.Increment();
            ModulePerPolicyCounters.Counters[_apiPolicy.PolicyIdKeyForPerf].TotalThrottledRequests.Increment();
            ModulePerPolicyCounters.Counters.ThrottledRequestsPerSec.Increment();
            ModulePerPolicyCounters.Counters[_apiPolicy.PolicyIdKeyForPerf].ThrottledRequestsPerSec.Increment();
            Trace.Normal("HandleThrottle: puid=0x{0:X}, ip={1}, value={2}, threshold={3} [blocked]",
                         PassportPuid, httpCtx.Request.UserHostAddress, _tpsHistory, _apiPolicy.ThrottleThreshold);
            return false;
        }
        else 
        {
            Trace.Low("HandleThrottle: puid=0x{0:X}, ip={1}, value={2}, threshold={3} [ok]",
                      PassportPuid, httpCtx.Request.UserHostAddress, _tpsHistory, _apiPolicy.ThrottleThreshold);
            return true;
        }
    }

    // -------------------------------------------------------------------------------
    // HandleBuildAuthInfo
    //
    // Constructs the appropriate auth info to attach to the HttpContext. For now, we'll 
    // just set some items directly, but in the future we will use an object.
    //
    // Set _liveXuid if policy requires it.
    // -------------------------------------------------------------------------------
    private bool HandleBuildAuthInfo()
    {
        Debug.Assert(_apiPolicy != null);

        Trace.Low("AuthHandlers.HandleBuildAuthInfo called");

        // Gather up all the info we need. Some is stored as a member, some is not.
        string ipAddressInternet = httpCtx.Request.UserHostAddress;

        // For old-school APIs, still push along the AAInfo in the AuthZ header. XBL2.0 
        // apis will have their Thread.CurrentPrincipal set, and the AuthSG will marshall 
        // this into the XAuth header.
        if (_apiPolicy.AuthorizationHeader != AuthUtils.XBL2_0_AUTH_SCHEME_TOKEN &&
            _apiPolicy.AllowedAuthMethods == ActiveAuthMethod.NOTSPECIFIED)
        {
            // Stick the info needed by AAInfo into the context. If policy doesn't require 
            // authentication, the passport puid will be 0.
            // If this was a WLID2.0 request the DateTime values will be populated otherwise they will be null
            AuthUtils.MarshallAAInfoToContext(
                httpCtx,
                PassportPuid,
                ipAddressInternet,
                _liveXuid,
                _passportCId,
                _notAfterDateTime,
                _issueInstantDateTime,
                _certDeviceId,
                _tokenString,
                _flowToken.ToString()
                );
        }

        return true;
    }

    // -------------------------------------------------------------------------------
    // ParseAuthorizationHeader 
    //
    // Parse the Authorization Header.
    // Parses into 2 tokens:
    //  - Authorization Scheme Token - WLID1.0 or XBL1.0
    //  - (WLID1.0) Passport compact ticket prefixed by t=...
    //  - (XBL1.0) XBox Live SAML Token x=<xml SAML token>
    // -------------------------------------------------------------------------------
    private bool ParseAuthorizationHeader( string authValue, out string[] authTokens )
    {
        if (String.IsNullOrEmpty(authValue))
        {
            authTokens = null;
            return false;
        }

        // Parameter validation
        int iIndex = authValue.IndexOf( ' ' );
        if ( 1 > iIndex )
        {
            authTokens = null;
            return false;
        }
        
        string value = authValue;
        List<string> listTokens = new List<string>();

        // 1 - Authorization Token, expecting WLID1.0 or XBL1.0
        listTokens.Add( value.Substring( 0, iIndex ));

        // 2 - Rest of header
        // WLID1.0 - Should always be the compact RPS Ticker t=...
        // XBL1.0 - Should always be the STS generated SAML Token x=...
        listTokens.Add( value.Substring( iIndex+1 ));

        // return tokens
        authTokens = listTokens.ToArray();
        
        return true;
    }

    // -------------------------------------------------------------------------------
    // ValidateAuthorization1_0 
    //
    // Validates AuthTokens and requests passport token validation
    // -------------------------------------------------------------------------------
    private bool ValidateAuthorizationWLID10( string authValue, string[] authTokens )
    {
        bool isAuthorized = true;
        
        if (2 != authTokens.Length)
        {
            Trace.High("  Incorrect tokens in header value: {0}", authValue);
            AuthResponder.SetAuthorizationRequired(httpCtx, _apiPolicy);
            isAuthorized = false;
        }

        if (isAuthorized)
        {
            string rpsToken = authTokens[1];

            if (rpsToken.StartsWith("t="))
            {   // RPS compact ticket
                isAuthorized = ValidatePassportToken(authTokens[1]);
            }
            else
            {   // RPS delegation ticket
                isAuthorized = ValidatePassportDelegationToken(authTokens[1]);
            }
        }

        return isAuthorized;
    }

    // -------------------------------------------------------------------------------
    // ValidateAuthorization2_0 
    //
    // Validates AuthTokens:
    //  requests passport token validation
    //  performs XBox Live SAML Token validation
    // -------------------------------------------------------------------------------
    private bool ValidateAuthorizationXBL10( string authValue, string[] authTokens )
    {
        bool isAuthorized = true;
        
        // Parameter validation
        if (2 != authTokens.Length)
        {
            Trace.High("  Incorrect tokens in header value: {0}", authValue);
            AuthResponder.SetAuthorizationRequired(httpCtx, _apiPolicy);
            isAuthorized = false;
        }

        if ( isAuthorized )
            isAuthorized = ValidateXBoxLiveToken( authTokens[1] );
        
        return isAuthorized;
    }

    // -------------------------------------------------------------------------------
    // IsValidWPCertificate 
    //
    // Validates Enhanced Key Usage (EKU) extension per Windows Phone 7 spec.
    //
    // Note: An enhanced key usage (EKU) extension is a collection of object identifiers 
    // (OIDs) that indicate the applications that use the key.
    // -------------------------------------------------------------------------------
    private bool IsValidWPCertificate(X509Certificate2 cert)
    {
        const string XCN_OID_ENHANCED_KEY_USAGE = "2.5.29.37";
        bool isValid = false;

        foreach (X509Extension ext in cert.Extensions)
        {
            if (XCN_OID_ENHANCED_KEY_USAGE == ext.Oid.Value)
            {
                X509EnhancedKeyUsageExtension ekuExt = (X509EnhancedKeyUsageExtension) ext;

                foreach (System.Security.Cryptography.Oid oid in ekuExt.EnhancedKeyUsages)
                {
                    if (-1 < Array.IndexOf(ActiveAuthModule.XblEnhancedKeyUsages, oid.Value))
                    {
                        isValid = true;
                        break;
                    }
                }
            }
        }
        
        return isValid;
    }

    private bool IsValidWPCertificate(string[] ekuOidList)
    {
        if (ekuOidList != null)
        {
            foreach (string oid in ekuOidList)
            {
                if (-1 < Array.IndexOf(ActiveAuthModule.XblEnhancedKeyUsages, oid))
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    // -------------------------------------------------------------------------------
    // ValidatePassportToken 
    //
    // Validates passport token t=...
    //
    // Sets _passportPuid
    //      _notAfterDateTime 
    //      _issueInstantDateTime 
    // -------------------------------------------------------------------------------
    private bool ValidatePassportToken( string ticketStr )
    {
        // Sanity check our global
        PassportRpsWrapper rps = ActiveAuthModule.RpsSession;
        if (rps == null)
        {
            throw new HandlerException("ValidatePassportToken: No PassportRpsWrapper found in the HTTP Application state. Was RPS successfully initialized?");
        }

        if (!ticketStr.StartsWith("t="))
        {
            Trace.High("ValidatePassportToken: Ticket token does not start with \"t=\"");
            AuthResponder.SetAuthorizationRequired(httpCtx, _apiPolicy);
            return false;
        }

        //
        // Ready to crack the ticket. May throw XRLException.
        //
        try
        {
            Trace.Low("ValidatePassportToken: Cracking ticket using policy \"{0}\"", _apiPolicy.AuthenticationPolicy);

            HResult hr = HResult.E_FAIL;
            Exception validateException = null;
            RPSTicket rpsTicket = null;

            foreach (string siteName in ActiveAuthModule.RpsSiteNames)
            {
                try
                {
                    rpsTicket = rps.GetRpsTicketFromToken(
                        siteName,
                        ticketStr,
                        _apiPolicy.AuthenticationPolicy);

                    // Got it, break out of loop
                    hr = HResult.S_OK;
                    break;
                }
                catch (Exception e)
                {
                    hr = XblException.GetHResult(e);
                    if (hr.IsSuccess())
                    {
                        hr = HResult.E_FAIL;
                    }
                    validateException = e;
                }
            }

            if (hr.IsFailure())
            {
                throw new XRLException(
                    hr,
                    XEvent.Id.COMMON_CODE_146,
                    "ValidatePassportToken: GetRpsTicketFromToken failed for all sites; only last failure included.",
                    validateException);
            }

            _passportPuid = PassportRpsWrapper.GetPuidFromTicket(rpsTicket);
            _notAfterDateTime = PassportRpsWrapper.GetNotAfterDateTimeFromTicket(rpsTicket);
            _issueInstantDateTime = PassportRpsWrapper.GetIssueInstantDateTimeFromTicket(rpsTicket);
            _passportCId = PassportRpsWrapper.GetHexCIdFromTicket(rpsTicket);

            // If xuid is required, let's retrieve it now
            if (_apiPolicy.RequiresXuid)
            {
                try
                {
                    _liveXuid = XCache.LookupPUID(PassportPuid);
                }
                catch (Exception e)
                {
                    // @@@ event here?
                    Trace.Error("ValidatePassportToken: XCache failed for puid=0x{0}. Unable to enforce XUID requirement.\nException: {1}", PassportPuid, e.ToString());
                }

                // failures of any kind block the request. we're mean.
                if (_liveXuid == 0)
                {
                    Trace.High("ValidatePassportToken: xuid required but not found for puid={0}", (Puid)PassportPuid);
                    AuthResponder.SetInvalidRequest(httpCtx);
                    return false;
                }
            }

            // Augment the ClaimsPrincipal with new findings from passport
            ClaimsIdentity identity = GetOrCreateActiveAuthIdentity();
            if (identity != null)
            {
                Claim claim = AuthClaimTypes.Create(
                    AuthClaimTypes.Puid,  _passportPuid.ToString(),
                    AuthClaimTypes.ValueTypes[AuthClaimTypes.Puid],
                    "aamodule");
                identity.Claims.Add(claim);

                if (0 != _liveXuid)
                {
                    claim = AuthClaimTypes.Create(
                        AuthClaimTypes.Xuid, _liveXuid.ToString(),
                        AuthClaimTypes.ValueTypes[AuthClaimTypes.Xuid],
                        "aamodule");
                    identity.Claims.Add(claim);
                }
            }
        }
        catch (XRLException xrle)
        {
            _hr = xrle.HResult;
            if ( xrle.HResult == HResult.XONLINE_E_RPS_REASON_INVALID_AUTHMETHOD 
              || xrle.HResult == HResult.XONLINE_E_RPS_REASON_TIMEWINDOW_EXPIRED 
              || xrle.HResult == HResult.XONLINE_E_RPS_INVALID_TIMEWINDOW 
              || xrle.HResult == HResult.XONLINE_E_RPS_INVALID_SITEID 
              || xrle.HResult == HResult.XONLINE_E_RPS_CERT_NOT_FOUND
              || xrle.HResult == HResult.XONLINE_E_RPS_INVALID_DATATYPE
               )
            {

                // @@@ correct response? do it for ANY exception? or none? others?
                AuthResponder.SetAuthorizationRequired(
                    httpCtx, 
                    _apiPolicy, 
                    xrle.HResult);
            }
            else
            {
                Xom.NtEvent(XEvent.Id.AAM_CONFIG_RPS_ERROR, xrle, "Exception while cracking Passport ticket.");

                AuthResponder.SetServerError(
                    httpCtx, 
                    xrle.HResult,
                    xrle.Message);
            }
            return false;
        }
        return true;
    }

    // -------------------------------------------------------------------------------
    // ValidatePassportDelegationToken 
    //
    // Validates passport token t=...
    //
    // Sets _passportPuid
    //      _notAfterDateTime 
    //      _issueInstantDateTime 
    // -------------------------------------------------------------------------------
    private bool ValidatePassportDelegationToken(string ticketStr)
    {
        // Sanity check our global
        PassportRpsWrapper rps = ActiveAuthModule.RpsSession;
        if (rps == null)
        {
            throw new HandlerException("ValidatePassportDelegationToken: No PassportRpsWrapper found in the HTTP Application state. Was RPS successfully initialized?");
        }

        if (!ticketStr.StartsWith("d="))
        {
            Trace.High("ValidatePassportDelegationToken: Ticket token does not start with \"d=\"");
            AuthResponder.SetAuthorizationRequired(httpCtx, _apiPolicy);
            return false;
        }

        // Drop "d="
        ticketStr = ticketStr.Substring(2); 

        //
        // Ready to crack the ticket. May throw XRLException.
        //
        try
        {
            HResult hr = HResult.E_FAIL;
            Exception validateException = null;
            RPSTicket rpsTicket = null;

            foreach (string siteName in ActiveAuthModule.RpsDelegationSiteNames)
            {
                try
                {
                    rpsTicket = rps.GetRpsTicketFromDelegationToken(
                        siteName,
                        ticketStr,
                        ActiveAuthModule.RpsDelegationOfferActions);

                    // Got it, break out of loop
                    hr = HResult.S_OK;
                    break;
                }
                catch (Exception e)
                {
                    hr = XblException.GetHResult(e);
                    if (hr.IsSuccess())
                    {
                        hr = HResult.E_FAIL;
                    }
                    validateException = e;
                }
            }

            if (hr.IsFailure())
            {
                throw new XRLException(
                    hr,
                    XEvent.Id.COMMON_CODE_146,
                    "ValidatePassportToken: GetRpsTicketFromToken failed for all sites; only last failure included.",
                    validateException);
            }

            _passportPuid = PassportRpsWrapper.GetPuidFromTicket(rpsTicket);
            _notAfterDateTime = PassportRpsWrapper.GetExpiryTimeDateTimeFromTicket(rpsTicket);
            _issueInstantDateTime = PassportRpsWrapper.GetIssueInstantDateTimeFromTicket(rpsTicket);
            _passportCId = PassportRpsWrapper.GetHexCIdFromTicket(rpsTicket);

            _passportAppId = PassportRpsWrapper.GetAppIdFromTicket(rpsTicket);

            ValidatePassportDelegationAppId((ulong)_passportAppId);

            // If xuid is required, let's retrieve it now
            if (_apiPolicy.RequiresXuid)
            {
                try
                {
                    _liveXuid = XCache.LookupPUID(PassportPuid);
                }
                catch (Exception e)
                {
                    // @@@ event here?
                    Trace.Error("ValidatePassportToken: XCache failed for puid=0x{0}. Unable to enforce XUID requirement.\nException: {1}", PassportPuid, e.ToString());
                }

                // failures of any kind block the request. we're mean.
                if (_liveXuid == 0)
                {
                    Trace.High("ValidatePassportToken: xuid required but not found for puid=0x{0}", PassportPuid);
                    AuthResponder.SetInvalidRequest(httpCtx);
                    return false;
                }
            }

            // Augment the ClaimsPrincipal with new findings from passport
            ClaimsIdentity identity = GetOrCreateActiveAuthIdentity();
            if (identity != null)
            {
                Claim claim = AuthClaimTypes.Create(
                    AuthClaimTypes.Puid, _passportPuid.ToString(),
                    AuthClaimTypes.ValueTypes[AuthClaimTypes.Puid],
                    "aamodule");
                identity.Claims.Add(claim);

                if (0 != _liveXuid)
                {
                    claim = AuthClaimTypes.Create(
                        AuthClaimTypes.Xuid, _liveXuid.ToString(),
                        AuthClaimTypes.ValueTypes[AuthClaimTypes.Xuid],
                        "aamodule");
                    identity.Claims.Add(claim);
                }
            }
        }
        catch (XRLException xrle)
        {
            _hr = xrle.HResult;
            if ( xrle.HResult == HResult.XONLINE_E_RPS_REASON_INVALID_AUTHMETHOD
              || xrle.HResult == HResult.XONLINE_E_RPS_REASON_TIMEWINDOW_EXPIRED
              || xrle.HResult == HResult.XONLINE_E_RPS_INVALID_TIMEWINDOW
              || xrle.HResult == HResult.XONLINE_E_RPS_INVALID_SITEID
              || xrle.HResult == HResult.XONLINE_E_RPS_CERT_NOT_FOUND
              || xrle.HResult == HResult.XONLINE_E_PP_E_RPS_NOT_ALL_OFFER_ACTIONS_CONSENTED
              || xrle.HResult == HResult.XONLINE_E_PP_E_RPS_TICKET_HAS_NO_OFFERACTIONS
              || xrle.HResult == HResult.XONLINE_E_PP_E_RPS_REASON_OFFERACTIONS_INVALID
              || xrle.HResult == HResult.XONLINE_E_PP_E_RPS_REASON_APPID_NOT_IN_ALLOWLIST
              || xrle.HResult == HResult.XONLINE_E_RPS_INVALID_DATATYPE
               )
            {

                // @@@ correct response? do it for ANY exception? or none? others?
                AuthResponder.SetAuthorizationRequired(
                    httpCtx,
                    _apiPolicy,
                    xrle.HResult);
            }
            else
            {
                Xom.NtEvent(XEvent.Id.AAM_CONFIG_RPS_ERROR, xrle, "Exception while cracking Passport ticket.");

                AuthResponder.SetServerError(
                    httpCtx,
                    xrle.HResult,
                    xrle.Message);
            }
            return false;
        }
        return true;
    }

    // -------------------------------------------------------------------------------
    // ValidatePassportDelegationAppId 
    //
    // Validates passportAppId retrieved from the Delegation token is included in the
    // RpsDelegationAppIdsAllowed list
    // -------------------------------------------------------------------------------
    bool ValidatePassportDelegationAppId(ulong passportAppId)
    {
        if (ActiveAuthModule.RpsDelegationAppIdsAllowed.Contains(passportAppId))
        {
            return true;
        }
        else
        {
            throw new XRLException
                ( HResult.XONLINE_E_PP_E_RPS_REASON_APPID_NOT_IN_ALLOWLIST
                , XEvent.Id.COMMON_CODE_146
                , "ValidatePassportDelegationAppId appId {0} is not in RpsDelegationAppIdsAllowed list."
                , passportAppId
                );
        }
    }

    // -------------------------------------------------------------------------------
    // ValidateXBoxLiveToken 
    //
    // Validates XBox Live SAML token x=...
    //
    // Sets _passportPuid
    //      _notAfterDateTime 
    //      _issueInstantDateTime 
    // -------------------------------------------------------------------------------
    private bool ValidateXBoxLiveToken( string ticketStr )
    {
        // Parameter validation
        if (!ticketStr.StartsWith("x="))
        {
            Trace.High("  XBox Live SAML token does not start with \"x=\"");
            AuthResponder.SetAuthorizationRequired(httpCtx, _apiPolicy);
            return false;
        }

        //
        // Ready to crack the token
        //
        Trace.Low("  Cracking XBox Live SAML token");
        string tokenString = HttpUtility.HtmlDecode(ticketStr.Substring(2));

        XblSamlToken xblSamlToken;

        try
        {
            xblSamlToken = new XblSamlToken(tokenString);
        }
        catch (Exception e)
        {
            _hr = XblException.GetHResult(e);
            AuthResponder.SetAuthorizationRequired(
                httpCtx,
                _apiPolicy,
                _hr);
            return false;
        }
        
        try
        {
            xblSamlToken.Validate(ActiveAuthModule.XblCertificates, _certDeviceId);
        }
        catch (XblException e)
        {
            _hr = e.HResult;
            AuthResponder.SetAuthorizationRequired(
                httpCtx,
                _apiPolicy,
                e.HResult);
            return false;
        }
        catch (SecurityTokenException e)
        {
            _hr = XblException.GetHResult(e);
            AuthResponder.SetAuthorizationRequired(
                httpCtx,
                _apiPolicy,
                _hr);
            return false;
        }

        // Todo: Additional certificate chain verification or certificate Owner Id verification, to guarantee this is a Window Mobile device only?
        
        _passportPuid = ulong.Parse(xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_puid0));
        _passportCId = ulong.Parse(xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_cid0));

        // Validate XUID if required
        string value;
        if (xblSamlToken.TryGetAttributeValue(XblSamlToken.name_attribute_xuid0, out value))
        {
            _liveXuid = ulong.Parse(value);
        }
        else if (_apiPolicy.RequiresXuid)
        {
            Trace.High("ValidateXBoxLiveToken:  xuid required but not in token");
            AuthResponder.SetInvalidRequest(httpCtx);
            return false;
        }
        _notAfterDateTime = xblSamlToken.ValidTo;
        _issueInstantDateTime = xblSamlToken.NotBefore;

        _tokenString = tokenString;

        // Augment the ClaimsPrincipal with new findings from passport
        ClaimsIdentity identity = GetOrCreateActiveAuthIdentity();
        if (identity != null)
        {
            Claim claim = AuthClaimTypes.Create(
                AuthClaimTypes.Puid, _passportPuid.ToString(),
                AuthClaimTypes.ValueTypes[AuthClaimTypes.Puid],
                "aamodule");
            identity.Claims.Add(claim);

            if (0 != _liveXuid)
            {
                claim = AuthClaimTypes.Create(
                    AuthClaimTypes.Xuid, _liveXuid.ToString(),
                    AuthClaimTypes.ValueTypes[AuthClaimTypes.Xuid],
                    "aamodule");
                identity.Claims.Add(claim);
            }
        }

        return true;
    }

    private Guid? GetPartnerIdForThumbprint(string certThumbprint)
    {
        foreach (KeyValuePair<string, IIEBBusinessPartner> kvp in ActiveAuthModule.BuisnessPartners)
        {
            foreach (IIEBPartnerConnectionInfo connInfo in kvp.Value.IEBPartnerConnectionInfoes)
            {
                if (certThumbprint.Equals(connInfo.SecurityGatewayCertificate.Thumbprint, StringComparison.OrdinalIgnoreCase))
                {
                    IEBBusinessPartner partner = (IEBBusinessPartner)kvp.Value;
                    return new Guid?(partner.Id);
                }
            }
        }
        return null;
    }

    // -------------------------------------------------------------------------------
    // GetSslInfo - retrieves certificate information from the connection.  
    // Supports both SSL connections as well as hardware-terminated connections, which 
    // will proxy certificate information to us in headers.
    // -------------------------------------------------------------------------------
    private void GetSslInfo (HttpRequest httpReq)
    {
        _connectionIsSsl = false;
        _certSubject = null;
        _certThumbprint = null;
        _certIsValidWP = false;
        _hasClientCert = false;
        _partnerId = null;

        if (httpReq.IsSecureConnection)
        {
            _connectionIsSsl = true;

            if (httpReq.ClientCertificate.IsPresent)
            {
                X509Certificate2 cert = new X509Certificate2(httpReq.ClientCertificate.Certificate);

                _hasClientCert = true;
                _certSubject = cert.SubjectName.Name;
                _certThumbprint = cert.Thumbprint;
                _certIsValidWP = IsValidWPCertificate(cert);
                _partnerId = GetPartnerIdForThumbprint(_certThumbprint);
            }
        }
        else if (UseLoadBalancerSslHeaders)
        {
            string lbIsSsl = httpReq.Headers[XHttpHdr.LOADBALANCER_ISSSL];
            if (!String.IsNullOrEmpty(lbIsSsl))
            {
                lbIsSsl = lbIsSsl.ToLower();
                _connectionIsSsl = (lbIsSsl == "true");
            }

            if (_connectionIsSsl)
            {
                _certSubject = httpReq.Headers[XHttpHdr.CERT_SUBJECT];
                _certThumbprint = httpReq.Headers[XHttpHdr.CERT_THUMBPRINT];

                // do we actually have a client cert? [check _connectionIsSsl again for maintainability]
                _hasClientCert = _connectionIsSsl && !(String.IsNullOrEmpty(_certSubject) || String.IsNullOrEmpty(_certThumbprint));

                if (_hasClientCert)
                {
                    // check the EKU OIDs to make sure it has a WP one
                    string oidListStr = httpReq.Headers[XHttpHdr.CERT_EKULIST];
                    if (!String.IsNullOrEmpty(oidListStr))
                    {
                        string[] oidList = oidListStr.Split(new char[] { ',', ' ' }, StringSplitOptions.RemoveEmptyEntries);
                        _certIsValidWP = IsValidWPCertificate(oidList);
                    }

                    // check for a business partner
                    if (_certThumbprint != null)
                    {
                        _partnerId = GetPartnerIdForThumbprint(_certThumbprint);
                    }
                }
            }
        }
    }

    // -------------------------------------------------------------------------------
    // GetWindowsPhoneInfo - Currently support WP7 or WP8
    // The Windows Phone DeviceId information is all we are after today
    // -------------------------------------------------------------------------------
    private void GetWindowsPhoneInfo()
    {
        X500DistinguishedName name = new X500DistinguishedName(_certSubject);
        string[] distinguishedNameParts = name.Decode(X500DistinguishedNameFlags.UseCommas | X500DistinguishedNameFlags.DoNotUseQuotes).Split(',');

        GetWindowsPhone8Info(distinguishedNameParts);

        if (string.IsNullOrEmpty(_certDeviceId))
        {
            GetWindowsPhone7Info(distinguishedNameParts);
        }

        if (string.IsNullOrEmpty(_certDeviceId))
            _certDeviceId = _certThumbprint;

        if (!string.IsNullOrEmpty(_certDeviceId))
        {
            // Augment the ClaimsPrincipal with new findings from the certificate
            ClaimsIdentity identity = GetOrCreateActiveAuthIdentity();
            if (identity != null)
            {
                Claim claimDeviceId = AuthClaimTypes.Create(
                    AuthClaimTypes.DeviceId,
                    _certDeviceId,
                    ClaimValueTypes.String,
                    "aamodule");
                identity.Claims.Add(claimDeviceId);
            }
        }
    }

    private void GetWindowsPhone7Info(string[] distinguishedNameParts)
    {
        string prefix = "CN=" + Config.GetSetting(Setting.aamodule_wp7_deviceId_cert_subject_prefix);

        if (3 == prefix.Length)
        {
            Xom.NtEvent
                (XEvent.Id.AAGW_CONFIG_INVALID_SETTING
                , "aamodule_wp7_deviceId_cert_subject_prefix empty or not present"
                );
            return;
        }

        _certDeviceId = GetDistingushedNamePart(prefix, distinguishedNameParts);
    }

    private void GetWindowsPhone8Info(string[] distinguishedNameParts)
    {
        string prefix = "CN=" + Config.GetSetting(Setting.aamodule_wp8_deviceId_cert_subject_prefix);
        string prefix2 = "OU=";
        string identifier = string.Empty;
        string identifier2 = string.Empty;

        if (3 == prefix.Length)
        {
            Xom.NtEvent
                ( XEvent.Id.AAGW_CONFIG_INVALID_SETTING
                , "aamodule_wp8_deviceId_cert_subject_prefix empty or not present"
                );
            return;
        }

        identifier = GetDistingushedNamePart(prefix, distinguishedNameParts);
        if (!string.IsNullOrEmpty(identifier))
        {
            identifier2 = GetDistingushedNamePart(prefix2, distinguishedNameParts);
        }
        if (!string.IsNullOrEmpty(identifier2))
        {
            _certDeviceId = identifier + identifier2;
        }
    }

    private string GetDistingushedNamePart(string prefix, string[] distinguishedNameParts)
    {
        string namePart;

        foreach (string distinguishedNamePart in distinguishedNameParts)
        {
            namePart = distinguishedNamePart.Trim();
            if (namePart.StartsWith(prefix) && prefix.Length < namePart.Length)
            {
                return namePart.Substring(prefix.Length);
            }
        }

        return string.Empty;
    }

    // -------------------------------------------------------------------------------
    // GetOrCreateActiveAuthIdentity - finds or creates the requested identity in the  
    // ClaimsPrincipal in Thread.CurrentPrincipal.
    // -------------------------------------------------------------------------------
    private ClaimsIdentity GetOrCreateActiveAuthIdentity()
    {
        ClaimsIdentity identity = null;
        IClaimsPrincipal claimsPrincipal = GetOrCreatePrincipal();

        if (claimsPrincipal != null)
        {
            // @@@ Use AuthenticationType or Name?
            identity = (ClaimsIdentity)claimsPrincipal.Identities
                .SingleOrDefault(i => i.AuthenticationType == AuthIdentityTypes.ActiveAuth);
        }

        if (identity == null)
        {
            identity = new ClaimsIdentity(AuthIdentityTypes.ActiveAuth);
            claimsPrincipal.Identities.Add(identity);
        }

        return identity;
    }

    // -------------------------------------------------------------------------------
    // GetOrCreatePrincipal - finds or creates a ClaimsPrincipal in Thread.CurrentPrincipal.
    // -------------------------------------------------------------------------------
    private IClaimsPrincipal GetOrCreatePrincipal()
    {
        IClaimsPrincipal claimsPrincipal = Thread.CurrentPrincipal as IClaimsPrincipal;

        if (null == claimsPrincipal)
        {
            claimsPrincipal = new ClaimsPrincipal();

            // Set on current thread and in ASP.NET context
            Thread.CurrentPrincipal = claimsPrincipal;
            httpCtx.User = claimsPrincipal;
        }

        return claimsPrincipal;
    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\AASettings.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace AAGatewayTests
{
    [TestGroup]
    [Ignore]
    class AASettings : TestNode
    {
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class VerboseHttpClient : TestBase
        {
            protected override void Execute ()
            {
                HttpClient.Verbose = true;
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class IgnoreAAModule : TestBase
        {
            protected override void Execute ()
            {
                AAGatewayTestBase.IgnoreAAModule = true;
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\StrippedDownGateway\GatewayRequest.cs ===
//
// Gateway Request
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Active Auth Gateway Service
// Xbox Online Service
//
// Author: kgoodier June 2007
//

using System;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text.RegularExpressions;
using System.Threading;
using System.Web;

namespace xonline.server.activeauth.gateway
{
    //*** Added to reduce code changes needed
    public class ExceptionWithEventId: System.Exception
    {
        public ExceptionWithEventId()
        {}

        public ExceptionWithEventId(HResult id, params object []message)
        {}

        public ExceptionWithEventId(XEvent.Id id, params object []message)
        {}
    }

    //*** Added to reduce code changes needed
    public class XRLExceptionWithoutEvent: ExceptionWithEventId
    {
        public XRLExceptionWithoutEvent()
        {}

        public XRLExceptionWithoutEvent(HResult id, params object []message)
        {}

        public XRLExceptionWithoutEvent(XEvent.Id id, params object []message)
        {}
    }

    //*** Added to reduce code changes needed
    public class XEvent
    {
        public enum Id
        {
            AAGW_HACK_URL,
            AAGW_CONFIG_SERVICE_TABLE,
            AAGW_HACK_UNKNOWN_SERVICE
        }
    }

    //*** Added to reduce code changes needed
    public enum HResult
    {
        E_FAIL
    }

    public class GatewayRequest : IHttpAsyncHandler
    {
        public bool IsReusable
        {
            // Why not? We don't store state across invocations.
            get { return true; }
        }

        public GatewayRequest()
        {
        }

        public void ProcessRequest(HttpContext context)
        {
            throw new InvalidOperationException();
        }

        public IAsyncResult BeginProcessRequest(
            HttpContext ctx,
            AsyncCallback cb,
            object extraData)
        {
            AsyncOperation asyncOp = new AsyncOperation(ctx, cb, extraData);
            string desiredservice = "";
            string httpMethod = "";
            bool isRoutedService = false;
            // Verify some stuffs.
            //
            // Probably need to parse the url. Decide on a destination.
            try
            {

                // get the desired service from the URL
                desiredservice = ctx.Request.Url.AbsolutePath.ToLower();
                if (desiredservice == null)
                {

                    // Bad Request from Client
                    ctx.Response.StatusCode = (int)HttpStatusCode.BadRequest; // 400

                    // log the request and throw an error
                    throw new ExceptionWithEventId(
                        XEvent.Id.AAGW_HACK_URL,
                        "AuthSg: No URL was specified in the request header. " +
                        "This could be a hacker. Please Monitor."
                        );
                }

                // Get the VERB that was used for this request
                httpMethod = ctx.Request.HttpMethod.ToUpper();

                // lookup the services host name
                if (GatewayApp.Services == null)
                {

                    // Server Config Error
                    ctx.Response.StatusCode = (int)HttpStatusCode.InternalServerError; // 500

                    // log the request and throw an error
                    throw new ExceptionWithEventId(
                        XEvent.Id.AAGW_CONFIG_SERVICE_TABLE,
                        "AuthSg: No Service Table Exists. AuthSg should have " +
                        "services for request forwarding."
                        );
                }

                string toAddress = null;
                string newHost = null;
                ServiceNode service;

                // the first content length  check  is  against  the
                // overall maximum defined by the HTTP runtime (IIS)

                int contentLength = ctx.Request.ContentLength;

                if (contentLength > GatewayApp.GatewayMaximumRequestLength)
                {
                    ctx.Response.StatusCode = (int)HttpStatusCode.RequestEntityTooLarge;
                    throw new XRLExceptionWithoutEvent(HResult.E_FAIL, "Request exceeds maximum length, {0}", GatewayApp.GatewayMaximumRequestLength);
                }

                
                // now look up the service so we can  check  against
                // the specific policy configured for  that  service

                if (GatewayApp.TryLookupService(desiredservice, out service))
                {
                    // We know the URL and recognize it as valid at this point. 
                    asyncOp.Xrl = desiredservice;

                    // Check the length of the URL is acceptable

                    if (desiredservice.Length > service._maxUrlLength)
                    {
                        ctx.Response.StatusCode = (int)HttpStatusCode.BadRequest; // 400
                        throw new XRLExceptionWithoutEvent(HResult.E_FAIL, "URL exceeds maximum length for service {0}, {1}", desiredservice, service._maxUrlLength);
                    }

                    // Check the query string is acceptable

                    if (ctx.Request.Url.Query.Length > service._maxQueryStringLength)
                    {
                        ctx.Response.StatusCode = (int)HttpStatusCode.BadRequest; // 400
                        throw new XRLExceptionWithoutEvent(HResult.E_FAIL, "Query string exceeds maximum length for service {0}, {1}", desiredservice, service._maxQueryStringLength);
                    }

                    // This second content length is against the limit
                    // defined within t_xrl_virtual_interface_mappings

                    if (service._maxContentLength != -1 &&
                        contentLength > service._maxContentLength)
                    {
                        ctx.Response.StatusCode = (int) HttpStatusCode.RequestEntityTooLarge; // 413
                        throw new XRLExceptionWithoutEvent(HResult.E_FAIL, "Request exceeds maximum length for service {0}, {1}", desiredservice, service._maxContentLength);
                    }


                    // Grab the virtual interface
                    // Send request through to front door
                    throw new System.NotImplementedException(); //*** Added since this path doesn't apply and it depends on config

                }
                else if (GatewayApp.TryLookupHost(ctx.Request.Url.Host, out newHost))
                {
                    // Note: do not set asyncOp.Xrl here, since that will cause a per-api perf 
                    // counter to tick, and given we don't recognize the Xrl it could mean a 
                    // potential flood of instances.

                    // Send request through to remapped host, don't touch path.
                    toAddress = "http://" +
                                newHost +
                                ctx.Request.Url.AbsolutePath +
                                ctx.Request.Url.Query;

                    isRoutedService = true;
                }
                else
                {
                    // Bad Request from Client
                    ctx.Response.StatusCode = (int)HttpStatusCode.BadRequest; // 400

                    // Log the request and throw an error
                    throw new ExceptionWithEventId(
                        XEvent.Id.AAGW_HACK_UNKNOWN_SERVICE,
                        "AuthSg: The desired service " + desiredservice.ToString() +
                        " is unknown to AuthSg. This could be a hacker. " +
                        "Please Monitor."
                        );
                }

                // Store information for future logging
                asyncOp.ToAddress = toAddress;

                // Create our request object with the url
                HttpWebRequest webReq = (HttpWebRequest)WebRequest.Create(toAddress);

                // Useful inside the callbacks
                asyncOp.Request = webReq;

                // Don't let IIS blow away failure bodies on routed calls
                if (isRoutedService)
                {
                    ctx.Response.TrySkipIisCustomErrors = true;
                }
            
                //if (!AuthConfig.EnableRequestPipelining)
                {
                    //Pipelineing is enabled by default
                    webReq.Pipelined = false;
                }



                // Forward headers. Only do ones in the allowlist.
                //
                // Important note: make sure we strip out any AAInfo-related headers
                // from the client's request, particularly the "Authz" header that
                // is used by us to pass the AAInfo to the front door. The allowlist
                // does this now, but if we move to a denylist in the future, watch
                // out.

                //if (apPolicy.IsValid)
                {
                    foreach (string hdrKey in ctx.Request.Headers)
                    {
                        //if ((apPolicy.AllowListHeaderSetIncoming != null) && apPolicy.AllowListHeaderSetIncoming.Contains(hdrKey))
                        {
                            // use special copy function that knows how to deal
                            // with setters and getters for the special headers

                            //*** Replaced with a simple copy that ignores errors
                            try
                            {
                                webReq.Headers.Add(hdrKey, ctx.Request.Headers[hdrKey]);
                            }
                            catch {}
                        }
                    }
                }

                // Start real work here.

                try
                {
                    if ((httpMethod == "GET") || (httpMethod == "DELETE"))
                    {
                        webReq.Method = httpMethod;
                        BeginGetResponse(asyncOp);
                    }
                    else if ((httpMethod == "POST") || (httpMethod == "PUT"))
                    {
                        webReq.Method = httpMethod;

                        if (contentLength > 0)
                            BeginGetRequestStream(asyncOp);
                        else
                        {
                            BeginGetResponse(asyncOp);
                        }
                    }
                    else
                    {
                        // Unrecognized verb
                        ctx.Response.StatusCode = (int)HttpStatusCode.MethodNotAllowed; // 405
                        asyncOp.CompleteRequest();
                    }
                }
                catch (Exception e)
                {
                    // This will call asyncOp.CompleteRequest
                    HandleException(e, asyncOp);
                }
            }
            catch (Exception)
            {

                // if we did not set the status code up above, then
                // make it 500.  this assumes we never set  to  200

                if (ctx.Response.StatusCode == (int)HttpStatusCode.OK)
                {
                    // Server Error
                    ctx.Response.StatusCode = (int)HttpStatusCode.InternalServerError; // 500
                }

                asyncOp.CompleteRequest();
            }

            return asyncOp;
        }

        // ------------------------------------------------------------------------
        // EndProcessRequest - callback from IIS/ASP.NET when request has been completed.
        // ------------------------------------------------------------------------
        public void EndProcessRequest(IAsyncResult ar)
        {
            // Let's do some logging. As long as we didn't forget to complete the
            // request (and don't throw an exception here), we should always get a
            // logline. This is good.
            AsyncOperation asyncOp = ar as AsyncOperation;
            if (asyncOp != null)
            {
                HttpContext ctx = asyncOp.Context;

            }
        }

        // ------------------------------------------------------------------------
        // BeginGetRequestStream - calls BeginGetRequestStream and schedules a timer to handle 
        // the timeout.
        // ------------------------------------------------------------------------
        private static IAsyncResult BeginGetRequestStream(AsyncOperation asyncOp)
        {
            asyncOp.SetTimeout(GatewayApp.RequestTimeoutMilliseconds, HttpStatusCode.RequestTimeout, HandleException);
            return asyncOp.Request.BeginGetRequestStream(new AsyncCallback(RequestCallback), asyncOp);
        }

        // ------------------------------------------------------------------------                  -
        // BeginGetResponse - calls BeginGetResponse and schedules a timer to handle the 
        // timeout.
        // ------------------------------------------------------------------------
        private static IAsyncResult BeginGetResponse(AsyncOperation asyncOp)
        {
            asyncOp.SetTimeout(GatewayApp.GatewayTimeoutMilliseconds, HttpStatusCode.GatewayTimeout, HandleException);
            return asyncOp.Request.BeginGetResponse(new AsyncCallback(ResponseCallback), asyncOp);
        }

        // ------------------------------------------------------------------------
        // RequestCallback - async callback for when we try to get the request stream from the 
        // client's request. This function will send the request to the server, and will 
        // trigger the next callback, ResponseCallback, to handle the server's response.
        //
        // Do not throw any unhandled exceptions. We are outside the protection of 
        // HttpApplication here.
        // ------------------------------------------------------------------------
        private static void RequestCallback(IAsyncResult asyncResult)
        {
            // Names are confusing. Sorry. AsyncOperation is ours, from the IIS/ASP.NET async 
            // stuff, and is being 'reused' here. Holds everything we need, like a purse.

            AsyncOperation asyncOp = (AsyncOperation)asyncResult.AsyncState;

            lock (asyncOp)
            {
                if (asyncOp.IsCompleted || asyncOp.Error != null)
                {
                    return;
                }
            }

            try
            {
                HttpContext ctx = asyncOp.Context;
                HttpWebRequest webRequest = asyncOp.Request;
                int contentLength = ctx.Request.ContentLength;

                // Don't read 0 bytes, throws exception
                if (contentLength > 0)
                {
                    byte[] data = ctx.Request.BinaryRead(contentLength);

                    using (Stream postStream = webRequest.EndGetRequestStream(asyncResult))
                    {

                        if (data == null || data.Length != contentLength)
                        {
                            throw new Exception("Content-length header doesn't match data length");
                        }

                        postStream.Write(data, 0, contentLength);
                    }
                }

                // Retrieve the response now. This should fire off the request to the 
                // server, right? It will keep the chain of async events going.
                BeginGetResponse(asyncOp);
            }
            catch (Exception e)
            {
                HandleException(e, asyncOp);
            }
        }

        // ------------------------------------------------------------------------
        // ResponseCallback - async callback for when we try to get the response stream from 
        // the server we sent the request to. 
        // 
        // Do not throw any unhandled exceptions. We are outside the protection of 
        // HttpApplication here.
        // ------------------------------------------------------------------------
        private static void ResponseCallback(IAsyncResult asyncResult)
        {
            AsyncOperation asyncOp = (AsyncOperation)asyncResult.AsyncState;

            if (asyncOp.Error != null || asyncOp.IsCompleted)
            {
                return;
            }

            try
            {
                asyncOp.Response = (HttpWebResponse)asyncOp.Request.EndGetResponse(asyncResult);
                ProxyWebResponse(asyncOp);

                // All done. Complete the original request. Don't forget this step. Ever.
                asyncOp.CompleteRequest();
            }
            catch (Exception e)
            {
                HandleException(e, asyncOp);
            }
        }

        // ------------------------------------------------------------------------
        // ProxyWebResponse - takes the HttpWebResponse from the server and proxies it to the 
        // HttpContext to return it to the client.
        // ------------------------------------------------------------------------
        private static void ProxyWebResponse(AsyncOperation asyncOp)
        {
            HttpContext ctx = asyncOp.Context;
            HttpWebResponse webResponse = asyncOp.Response;

            // save status code for logging, and copy into response
            ctx.Response.StatusCode = (int)(asyncOp.ServerStatusCode = webResponse.StatusCode);
            ctx.Response.StatusDescription = webResponse.StatusDescription;

            // copy the response headers if available.
            //if (webResponse.Headers != null && apPolicy.IsValid)
            {
                foreach (string hdrKey in webResponse.Headers)
                {
                    //if ((apPolicy.AllowListHeaderSetOutgoing != null) && apPolicy.AllowListHeaderSetOutgoing.Contains(hdrKey))
                    {
                        ctx.Response.AppendHeader(
                            hdrKey,
                            webResponse.Headers[hdrKey]
                            );
                    }
                }
            }

            // Read and write chunks until no data left. Trying to read the whole thing in at 
            // once doesn't work, you aren't guaranteed to have all the data available. Size 
            // is arbitrarily chosen.
            byte[] buffer = new byte[32768];
            int dataRead = 0;

            using (Stream inputStream = webResponse.GetResponseStream())
            {
                using (Stream outputStream = ctx.Response.OutputStream)
                {
                    while (0 != (dataRead = inputStream.Read(buffer, 0, buffer.Length)))
                    {
                        outputStream.Write(buffer, 0, dataRead);
                    }
                }
            }
        }


        // ------------------------------------------------------------------------
        // HandleException - handles any exception, though it is expected to handle only 
        // WebExceptions. Those are special and let us possibly extract a response from the 
        // server.
        //
        // This will complete the async operation and return an error code to the client. No 
        // further processing should occur after HandleException() is called.
        // ------------------------------------------------------------------------
        protected static void HandleException(
            Exception exception,
            AsyncOperation asyncOp
            )
        {
            // if the operation is completed or we have already
            // processed another error, then we can just return

            lock (asyncOp)
            {
                if (asyncOp.IsCompleted)
                {
                    return;
                }

                if (asyncOp.Error != null)
                {
                    return;
                }

                // Store exception so we can check it later
                asyncOp.Error = exception;
            }

            try
            {
                // we are not on the original thread, so our http
                // context is gone.  restore it so the  event log
                // code can include  useful  request  information

                HttpContext ctx = HttpContext.Current = asyncOp.Context;

                if (exception is WebException)
                {
                    // WebExceptions are special. They tell us stuff. And maybe give us data.
                    WebException e = (WebException)exception;
                    if (e.Response == null)
                    {
                        // WebException without a response. Something bad happened.
                        // Should return 500 with no body (?).
                        ctx.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
                    }
                    else
                    {
                        // If we got a response, then we will proxy it just like the valid
                        // case.
                        asyncOp.Response = (HttpWebResponse)e.Response;
                        ProxyWebResponse(asyncOp);
                    }
                }
                else
                {
                    // Unknown/unhandled exception type.
                    // Should return 500 with no body (?).
                    ctx.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
                }

            }
            catch (System.Web.HttpException)
            {
            }
            catch (Exception)
            {
            }
            finally
            {
                // Finish request gracefully, we're done. This may fail, especially if an 
                // IOException or HttpException was thrown. We can swallow errors.
                try
                {
                    asyncOp.CompleteRequest();
                }
                catch (Exception)
                {
                }
            }
        }
    }

    public delegate void ExceptionDelegate(Exception e, AsyncOperation asyncOperation);

    public class AsyncOperation : IAsyncResult
    {
        public AsyncOperation(
            HttpContext   ctx,
            AsyncCallback cb,
            object        extraData
            )
        {
            _ctx = ctx;
            _cb = cb;
            _extraData = extraData;
            ToAddress = "";
            Request = null;
            Response = null;
            Error = null;
            Xrl = null;
        }

        private HttpContext       _ctx;
        private AsyncCallback     _cb;
        private object            _extraData;
        private bool              _isCompleted = false;

        public HttpContext Context
        {
            get { return(_ctx); }
        }

        //
        // IAsyncResult interface property implementations
        //

        public object AsyncState
        {
            get { return(_extraData); }

        }

        public bool CompletedSynchronously
        {
            get { return(false); }
        }

        public bool IsCompleted
        {
            get { return(_isCompleted); }
        }

        public WaitHandle AsyncWaitHandle
        {
            get { return null; }
        }

        //
        // Unique to this GatewayRequest api. Mostly used to shove handy data around.
        //

        internal HttpWebRequest         Request;
        internal HttpWebResponse        Response;
        internal string                 ToAddress;
        internal Exception              Error;
        internal string                 Xrl;

        // record the status code returned by the server  which
        // can be different from what we return to  the  client

        internal HttpStatusCode?        ServerStatusCode;

        // timer handles and code to return on timeout
        
        private HttpStatusCode          timeoutStatusCode;
        private ManualResetEvent        timeoutHandle = new ManualResetEvent(false);
        private RegisteredWaitHandle    registeredTimeoutHandle = null;
        private ExceptionDelegate       timeoutExceptionHandler = null;

        public void CompleteRequest()
        {
            lock (this) {
                CancelTimeout();

                if (_isCompleted) return;
                _isCompleted = true;
            }

            // if a callback was registered, invoke it now
            if (_cb != null)
            {
                _cb(this);
            }
        }

        internal void SetTimeout(long milliseconds, HttpStatusCode statusCode, ExceptionDelegate exceptionHandler)
        {
            lock (this)
            {
                CancelTimeout();
                timeoutStatusCode = statusCode;
                timeoutExceptionHandler = exceptionHandler;

                registeredTimeoutHandle = ThreadPool.RegisterWaitForSingleObject(
                    timeoutHandle, OnTimeout, this, milliseconds, true
                );
            }
        }

        internal void CancelTimeout()
        {
            lock (this)
            {
                if (registeredTimeoutHandle != null)
                {
                    registeredTimeoutHandle.Unregister(timeoutHandle);
                    registeredTimeoutHandle = null;
                }

                timeoutHandle.Reset();
            }
        }

        private void OnTimeout(object asyncState, bool timedOut)
        {
            lock (this)
            {
                if (Error != null) return;
                if (_isCompleted) return;

                // if we get here but have not timed  out  then
                // someone cancelled the timeout and we're done

                if (! timedOut) return;

                try
                {
                    try
                    {
                        Context.Response.StatusCode = (int) timeoutStatusCode;
                        CompleteRequest();
                    }
                    finally 
                    {
                        Request.Abort();
                    }
                }

                catch (Exception e)
                {
                    timeoutExceptionHandler(e, this);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\StrippedDownGateway\GatewayApp.cs ===
//
// GatewayApp.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Active Auth Gateway Service
// Xbox Online Service
//
// Author: kgoodier 6/2007
//

using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Web;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Net;
using System.Text.RegularExpressions;
using System.Web.Configuration;

namespace xonline.server.activeauth.gateway
{
public class GatewayApp : HttpApplication
{
    //*** Added: Configure machine to forward to here:
    public const string HardcodedMachineToForwardTo = "10.195.98.225";

    public GatewayApp()
    {
        //*** FeApp OnApplicationStart moved to here
        // Grab settings

        HttpRuntimeSection runtimeSection = (HttpRuntimeSection) 
            WebConfigurationManager.GetSection("system.web/httpRuntime");

        if (runtimeSection != null) {
            _GatewayMaximumRequestLength = runtimeSection.MaxRequestLength * 1024;
        }

        // Hostname mappings (alternate form of routing)
        InitializeHostnameMappings(new string[]{});

        // Service forwarding table
        InitializeServiceTable();
    }

    public static Dictionary<string, ServiceNode> Services
    {
        get
        {
            return _Services;
        }
    }

    // -------------------------------------------------------------------------
    // Looks up a service for a url
    // -------------------------------------------------------------------------
    public static bool TryLookupService(string url, out ServiceNode foundService)
    {
        foundService = null;
        return false;
    }

    // -------------------------------------------------------------------------
    // Looks up a new hostname mapping
    // -------------------------------------------------------------------------
    public static bool TryLookupHost(string host, out string newHost)
    {
        newHost = HardcodedMachineToForwardTo; //***replaced with a simple name or ip of the back-end service
        return true;
    }

    // -------------------------------------------------------------------------
    // InitializeServiceTable - loads the global url forwarding service table.
    // -------------------------------------------------------------------------
    public static void InitializeServiceTable()
    {
        Dictionary<string, ServiceNode> services =
            new Dictionary<string, ServiceNode>(
                StringComparer.CurrentCultureIgnoreCase
                );

        List<KeyValuePair<string, ServiceNode>> servicesForPartialMatch = null;

        // Call the protected function that will find in the service table
        //*** REMOVED ***

        // Swap in the new settings
        _Services                = services;
        _ServicesForPartialMatch = servicesForPartialMatch;
    }

    // -------------------------------------------------------------------------
    // InitializeHostnameMappings - given a delimited list of hostnames, split them up 
    // into a dictionary of [hostname, new hostname] pairs.
    // -------------------------------------------------------------------------
    private static void InitializeHostnameMappings(string[] hostnamePairs)
    {
        Dictionary<string, string> hostnameMappings = 
            new Dictionary<string, string>(
                hostnamePairs.Length,
                StringComparer.CurrentCultureIgnoreCase
                );

        //*** REMOVED ***

        // Swap in new hostnames
        _HostnameMappings = hostnameMappings;
    }

    public static int RequestTimeoutMilliseconds {
        get { return _RequestTimeoutMilliseconds; }
    }

    public static int GatewayTimeoutMilliseconds {
        get { return _GatewayTimeoutMilliseconds; }
    }

    public static int GatewayMaximumRequestLength {
        get { return _GatewayMaximumRequestLength; }
    }

    // -------------------------------------------------------------------------
    // Private Static Members
    // -------------------------------------------------------------------------
    private static volatile Dictionary<string, ServiceNode>         _Services = null;
    private static volatile List<KeyValuePair<string, ServiceNode>> _ServicesForPartialMatch = null;
    private static volatile Dictionary<string, string>              _HostnameMappings = null;

    // these values are immediately overwritten in application start.
    private static volatile int _RequestTimeoutMilliseconds  = 60000;
    private static volatile int _GatewayTimeoutMilliseconds  = 60000;
    private static volatile int _GatewayMaximumRequestLength = 4 * 1024 * 1024;
}

public class ServiceNode
{
    public string           _viface;
    public int              _siteid;
    public int              _maxUrlLength;
    public int              _maxContentLength;
    public int              _maxQueryStringLength;
    public bool             _allowNoExactMatch;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\AAInfo.cs ===
//These tests are shared by both the gateway test suite and the module test suite.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.STS;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

namespace PirateSGTest
{
    [TestGroup, Owner("johnmcp"), TestCasePriority(1)]
    [CompoundCase("GET", "GET")]
    [CompoundCase("POST", "POST")]
    public class SharedAAInfoTests: TestNode
    {
        //a valid passport user that's not a member of xbl
        public static readonly string NON_XBL_PASSPORT_NAME="xbltest-non-user@hotmail-int.com";
        public static readonly string NON_XBL_PASSPORT_PW="pyfgcrl";

        private static string _non_xbl_ticket = null;
        private static DateTime _non_xbl_ticket_got = DateTime.MinValue;
        private static readonly TimeSpan _non_xbl_ticket_expires = new TimeSpan(1, 0, 0);

        public static string NonXblPassportTicket
        {
            get
            {
                if ((DateTime.UtcNow - _non_xbl_ticket_got) > _non_xbl_ticket_expires)
                {
                    _non_xbl_ticket = AuthClientBase.GetAAPassportTicket(NON_XBL_PASSPORT_NAME, NON_XBL_PASSPORT_PW, "MBI");
                    _non_xbl_ticket_got = DateTime.UtcNow;
                }

                return _non_xbl_ticket;
            }
        }

        public const string SimplePath = "/testfd/Reflect/authsg/aainfo/simple";
        public const string AuthPath = "/testfd/Reflect/authsg/aainfo/auth";
        public const string SamlPath = "/testfd/Reflect/authsg/aainfo/saml";

        public const string TestFDQueryString = "?caller=authsg";

        // Properties that are allowed to have exceptions
        private static List<string> ExceptionalProperties = null;

        #region Setup And Utils

        /// <summary>
        /// Adds the TestFD Reflect parameters as a query string.
        /// </summary>
        public static void AddGetDataToRequest (HttpClient.Request req)
        {
            req.URI += TestFDQueryString;
        }

        //adds an acceptable POST content and headers to a request
        public static void AddPostDataToRequest(HttpClient.Request req)
        {
            req.Method="POST";

            TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
            tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
            tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;

            req.SetContentLengthAndBody(tfd_req.ToArray());
            req.OtherHeaders.AddLast("Content-Type: text/xml"); //xrlscan will be a @#$^% and block us without this
        }

        //
        [TestGroupSetup]
        public void GroupSetup()
        {
            if (ExceptionalProperties == null)
            {
                ExceptionalProperties = new List<string>();
                ExceptionalProperties.Add("GamerTag");
                ExceptionalProperties.Add("PlatformType");
                ExceptionalProperties.Add("CountryId");
            }

            //configure URIs to use
            SharedSetup.ConfigureUri(SimplePath, false);
            SharedSetup.ConfigureUri(AuthPath, true);
            SharedSetup.ConfigureUri(new ActiveAuthHttpConfig.PolicyEntry() { Path=SamlPath, AuthRequired=true, AuthHeader="XBL1.0" });

            SharedSetup.Reload();
        }

        #endregion //Setup And Utils


        #region Verification Logic

        public class AuthData
        {
            public enum AuthType
            {
                None, Passport, Saml
            }

            public AuthType Authorization = AuthType.None;
            public bool IsXblUser = false;
            public STSUtil.GetSecurityTicketParameters SamlTokenValues = null;
            public string CertDeviceId = null;
        }

        //Verifies that all the basics about a response are valid. (reflResponse is created from response if null)
        public static void VerifyResponseBasics(HttpClient.Request requestSent, HttpClient.Response response, ref TestFdReflectorResponse reflResponse)
        {
            //make reflResponse if needed
            if (response.Status==200)
            {
                if (reflResponse == null)
                {
                    reflResponse = new TestFdReflectorResponse();
                    reflResponse.ReadBytes(response.ContentBytes);
                }
            }

            //check some http basics
            ResponseVerification.CheckResponse(response);

            //check that the reflection contained what we sent
            if (reflResponse!=null && requestSent!=null)
            {
                ResponseVerification.VerifyOriginalRequest(reflResponse, requestSent);
            }
        }

        //Verifies that the extra headers that the module tacks on are present and sane
        public static void VerifyExtraHeaders (TestFdReflectorResponse reflResponse)
        {
#if !GatewayTests
            bool gotSGIPPort=false;
            bool gotServerPort=false;
#endif

            //check the headers (existance and super simple sanity)
            foreach (string s in reflResponse.HttpRequest.Headers.Dict.Keys)
            {
                if (s == "SGIPPort")
                {
#if !GatewayTests
                    gotSGIPPort = true;
#endif

                    string[] split = reflResponse.HttpRequest.Headers.Dict["SGIPPort"].Split(new char[] { ':' });
                    if (split.Length!=2)
                    {
                        Global.RO.Fatal(""+split.Length);
                        throw new UnexpectedTestResultException("SGIPPort header not in the expected format:\n"+s);
                    }

                    if (split[0].Trim().Length<7 || split[0].Trim().Length>15)
                    {
                        throw new UnexpectedTestResultException("IP portion of header seems wrong:\n"+s);
                    }

                    if (split[1].Trim().Length<1 || split[1].Trim().Length>5)
                    {
                        throw new UnexpectedTestResultException("Port portion of header seems wrong:\n"+s);
                    }

                    if (split[1].Trim()=="0")
                    {
                        throw new UnexpectedTestResultException("Port is 0 in header:\n"+s);
                    }
                }

                if (s == "ServerPort")
                {
#if !GatewayTests
                    gotServerPort = true;
#endif

                    ushort headerPort = ushort.Parse(reflResponse.HttpRequest.Headers.Dict["ServerPort"].Trim());
#if GatewayTests
                    ValueCheck.Test("ServerPort header value", AAGatewayTests.AAGatewayInfo.ReflectorPort, headerPort);
#else
                    ValueCheck.Test("ServerPort header value", ActiveAuthHttpConfig.GetServerPort(), headerPort);
#endif
                }
            }

#if !GatewayTests
            //
            if (!gotSGIPPort)
            {
                throw new UnexpectedTestResultException("Reflected headers did not contain SGIPPort");
            }

            if (!gotServerPort)
            {
                throw new UnexpectedTestResultException("Reflected headers did not contain ServerPort");
            }
#endif
        }

        //verifies AAInfo is sane
        public static void VerifyAAInfo (TestFdReflectorResponse reflResponse, AuthData authData)
        {
            Dictionary<string, string> aainfo = reflResponse.CallerSpecific.Dict;

            // pull out some values
            bool IsAAInfoAvailable = aainfo["IsActiveAuthAvailable"].ToLower() == "true";
            bool IsUserValid = aainfo["IsUserValid"].ToLower() == "true";

            //aa info being available should always be the opposite of whether it was a null value
            ValueCheck.Test("aainfo_available = !aainfo_nullity", !IsAAInfoAvailable,
                aainfo["IsAAInfoNull"].ToLower() == "true");

            //were there exceptions? never should be
            foreach (string key in aainfo.Keys)
            {
                if (key.EndsWith("Exception"))
                {
                    // 9 == "Exception".Length
                    if (!ExceptionalProperties.Contains(key.Substring(0, key.Length - 9)))
                    {
                        throw new UnexpectedTestResultException("Exception returned from reflector (" + key + "): \n" + aainfo[key]);
                    }
                }
            }

            //
            if (!IsAAInfoAvailable)
            {
                throw new UnexpectedTestResultException("We should always get AAInfo if the module lets us through.");
            }
            else
            {
#if GatewayTests
                ValueCheck.Test("AAInfo.IsMiddleTier for Gateway tests", "true", aainfo["IsMiddleTier"].ToLower());
                ValueCheck.Test("AAInfo.IsInternetTier for Gateway tests", "false", aainfo["IsInternetTier"].ToLower());
#elif ModuleTests
                ValueCheck.Test("AAInfo.IsMiddleTier for Module tests", "false", aainfo["IsMiddleTier"].ToLower());
                ValueCheck.Test("AAInfo.IsInternetTier for Module tests", "true", aainfo["IsInternetTier"].ToLower());
#endif

                //sanity checks on the IPs
                IPAddress inetIP = IPAddress.Parse(aainfo["IpAddressInternet"]);

                IPAddress origIP = IPAddress.Parse(aainfo["OriginatingIP"]);

                bool foundLocalIP = false;
                foreach (IPAddress ourIP in Dns.GetHostEntry("").AddressList)
                {
                    if (ourIP.Equals(inetIP))
                    {
                        foundLocalIP = true;
                    }
                }

                if (!foundLocalIP)
                {
                    throw new UnexpectedTestResultException("AAInfo.IpAddressInternet address was not one of the local client IPs.");
                }

#if ModuleTests
                if (!inetIP.Equals(origIP))
                {
                    throw new UnexpectedTestResultException("AAInfo Originating IP should have been the same as the Internet IP");
                }
#endif

                if (authData.Authorization == AuthData.AuthType.Passport)
                {
                    // check times from ticket; we don't know exact answers, but we can enforce some logical things
                    DateTime Now = DateTime.UtcNow;
                    DateTime IssueInstant = DateTime.Parse(aainfo["IssueInstant"]);
                    DateTime NotAfter = DateTime.Parse(aainfo["NotAfter"]);

                    if (IssueInstant >= NotAfter)
                    {
                        throw new UnexpectedTestResultException("AAInfo.IssueInstant is >= AAInfo.NotAfter");
                    }

                    // allow 5 minute time skew between client and server
                    if (Now.AddMinutes(5) <= IssueInstant)
                    {
                        throw new UnexpectedTestResultException("AAInfo.IssueInstant is after DateTime.UtcNow");
                    }

                    // allow 5 minute time skew between client and server
                    if (Now.AddMinutes(-5) >= NotAfter)
                    {
                        throw new UnexpectedTestResultException("AAInfo.NotAfter is before DateTime.UtcNow");
                    }
                    
                    // we should always have a PUID
                    if (aainfo["PassportPuid"] == "0")
                    {
                        throw new UnexpectedTestResultException("AAInfo.PassportPuid was 0");
                    }
                    
                    // make sure CID isn't PUID (at least, I think this should always be the case)
                    if (aainfo["PassportPuid"] == aainfo["PassportCId"])
                    {
                        throw new UnexpectedTestResultException("AAInfo.PassportPuid is equal to AAInfo.PassportCId");
                    }

                    // make sure gamertag and platform aren't present (aka, are exceptions)
                    if (!aainfo.ContainsKey("GamerTagException") || 
                        !aainfo["GamerTagException"].Contains(typeof(XRLExceptionWithoutEvent).FullName))
                    {
                        throw new UnexpectedTestResultException("AAInfo.GamerTag should throw an XRLExceptionWithoutEvent for WLID authorization.");
                    }

                    if (!aainfo.ContainsKey("PlatformTypeException") ||
                        !aainfo["PlatformTypeException"].Contains(typeof(XRLExceptionWithoutEvent).FullName))
                    {
                        throw new UnexpectedTestResultException("AAInfo.PlatformType should throw an XRLExceptionWithoutEvent for WLID authorization.");
                    }

                    //check on whether live-specific user stuff is correct
                    if (authData.IsXblUser)
                    {
                        if (!IsUserValid)
                        {
                            throw new UnexpectedTestResultException("AAInfo.IsUserValid was false for an Xbox Live user");
                        }

                        // sort of a double check since IsUserValid does this too
                        if (aainfo["LiveXuid"] == "0")
                        {
                            throw new UnexpectedTestResultException("AAInfo.LiveXuid was 0 when user was an Xbox Live user");
                        }
                        if (aainfo["LiveXuidFromXCache"] == "0")
                        {
                            throw new UnexpectedTestResultException("AAInfo.LiveXuidFromXCache was 0 when user was an xbox live user");
                        }
                        ValueCheck.Test("aainfo.LiveXuid == aainfo.LiveXuidFromXCache", aainfo["LiveXuidFromXCache"], aainfo["LiveXuid"]);

                        if (aainfo["CountryId"] == "0")
                        {
                            throw new UnexpectedTestResultException("AAInfo.CountryId was 0 when user was valid");
                        }

                        if (aainfo["HasPrivilege"].Length == 0)
                        {
                            throw new UnexpectedTestResultException("AAInfo has no priveleges for an xbox live user");
                        }
                    }
                    else
                    {
                        if (IsUserValid)
                        {
                            throw new UnexpectedTestResultException("AAInfo.IsUserValid was true for a NON-Xbox Live user");
                        }

                        if (aainfo["LiveXuid"] != "0")
                        {
                            throw new UnexpectedTestResultException("AAInfo.LiveXuid was " + aainfo["LiveXuid"] + " when user was NOT an xbox live user");
                        }
                        if (aainfo["LiveXuidFromXCache"] != "0")
                        {
                            throw new UnexpectedTestResultException("AAInfo.LiveXuidFromXCache was " + aainfo["LiveXuidFromXCache"] +
                                " when user was NOT an xbox live user");
                        }

                        if (aainfo["CountryId"] != "0")
                        {
                            throw new UnexpectedTestResultException("AAInfo.CountryId was " + aainfo["CountryId"] + " for a NON xbox live user");
                        }

                        if (aainfo["HasPrivilege"].Length != 0)
                        {
                            throw new UnexpectedTestResultException("AAInfo had '" + aainfo["HasPrivilege"] + "' priveleges for a NON xbox live user");
                        }
                    }
                }
                else if (authData.Authorization == AuthData.AuthType.Saml)
                {
                    STSUtil.GetSecurityTicketParameters gstp = authData.SamlTokenValues;

                    ValueCheck.Test("AAInfo.IssueInstant", gstp.NotBefore, System.DateTime.Parse(aainfo["IssueInstant"]), new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("AAInfo.NotAfter", gstp.NotAfter, System.DateTime.Parse(aainfo["NotAfter"]), new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("AAInfo.PassportPuid", gstp.Puid0.ToString(), aainfo["PassportPuid"]);
                    ValueCheck.Test("AAInfo.PassportCId", gstp.CID0.ToString(), aainfo["PassportCId"]);
                    ValueCheck.Test("AAInfo.GamerTag", gstp.Gamertag0.ToString(), aainfo["GamerTag"]);
                    ValueCheck.Test("AAInfo.PlatformType", gstp.PlatformType.ToString(), aainfo["PlatformType"]);
                    ValueCheck.Test("AAInfo.LiveXuid", gstp.Xuid0.ToString(), aainfo["LiveXuid"]);
                    ValueCheck.Test("AAInfo.IsUserValid", gstp.GenerateUserClaims && (gstp.Xuid0 != "0"), IsUserValid);
                    ValueCheck.Test("AAInfo.HasPrivilege", gstp.Privileges0.ToString(), aainfo["HasPrivilege"]);
                    ValueCheck.Test("AAInfo.LiveXuidFromXCache", gstp.Xuid0.ToString(), aainfo["LiveXuidFromXCache"]);

                    if (!aainfo.ContainsKey("CountryIdException") ||
                        !aainfo["CountryIdException"].Contains(typeof(XRLExceptionWithoutEvent).FullName))
                    {
                        throw new UnexpectedTestResultException("AAInfo.CountryId should throw an XRLExceptionWithoutEvent for XBL authorization.");
                    }
                }

                // cert thumbprint should match exactly (sort of, null -> "")
                ValueCheck.Test("AAInfo.CertDeviceId", (authData.CertDeviceId ?? ""), aainfo["CertDeviceId"]);

                //should always exist in an asp.net/http environment
                ValueCheck.Test("AAInfo.Current", "exists", aainfo["AAInfoCurrent"]);
            }
        }

        //Does all verification possible
        public static void VerifyEverythingPossible (int expectedStatus, HttpClient.Request requestSent, HttpClient.Response response, bool hasAAInfo, bool isXboxUser)
        {
            AuthData ad = new AuthData();
            ad.Authorization = (hasAAInfo ? AuthData.AuthType.Passport : AuthData.AuthType.None);
            ad.IsXblUser = isXboxUser;

            VerifyEverythingPossible(expectedStatus, requestSent, response, ad);
        }

        public static void VerifyEverythingPossible (int expectedStatus, HttpClient.Request requestSent, HttpClient.Response response, AuthData authData)
        {
            if (response == null)
            {
                throw new UnexpectedTestResultException("Expected a response.");
            }

            if (expectedStatus != response.Status)
            {
                throw new UnexpectedTestResultException("Expected " + expectedStatus + " but got " + response.Status + ": " + response.Reason);
            }

            VerifyEverythingPossible(requestSent, response, authData);
        }

        public static void VerifyEverythingPossible (HttpClient.Request requestSent, HttpClient.Response response, AuthData authData)
        {
            //basics
            TestFdReflectorResponse reflResponse = null;

            VerifyResponseBasics(requestSent, response, ref reflResponse);
            VerifyExtraHeaders(reflResponse);
            VerifyFlowtoken(requestSent, reflResponse);
            //aainfo and context checks
            if (reflResponse!=null)
            {
                VerifyAAInfo(reflResponse, authData);
                ResponseVerification.CheckPassportContext(reflResponse, authData.Authorization != AuthData.AuthType.None);
            }
        }

        public static void VerifyFlowtoken (HttpClient.Request requestSent, TestFdReflectorResponse reflResponse)
        {
            // if no request comes in to verify, we will just bail
            if (requestSent == null)
            {
                return;
            }

            //Get the received flowtoken
            string receivedStr = reflResponse.CallerSpecific.Dict["FlowToken"];
            if (receivedStr.StartsWith("FT"))
                receivedStr = receivedStr.Substring(2);

            ulong receivedVal;
            ulong expectedVal = 0; //Default

            if (!ulong.TryParse(receivedStr, out receivedVal))
            {
                throw new Exception("We got a junk flowtoken. Received: " + receivedStr);
            }

            foreach (string s in requestSent.OtherHeaders)
            {
                if (s.StartsWith("X-Floken:"))
                {

                    //Prepare the expected flowtoken
                    string[] kvp = s.Split(':');
                    string sentStr = kvp[1];

                    //Clean up the "FT"s
                    if (sentStr.StartsWith("FT"))
                        sentStr = sentStr.Substring(2);

                    //Parse out the numbers

                    if (!ulong.TryParse(sentStr, out expectedVal))
                    {
                        //Default
                        expectedVal = 0;
                    }


                    break;
                }
            }

            //In the case that nothing was sent, we validate that it is the default, 0.
            //This default might change and break stuff later oh no!
            if (receivedVal != expectedVal)
                throw new Exception(String.Format("Was looking for flowtoken: {0}, Obtained flowtoken:{1}",
                                                expectedVal.ToString("X16"), receivedVal.ToString("X16")));

        }

        #endregion //Verification Logic


        #region Tests

        [TestCase, Description("Simple flowtoken test case with groovy vibes.")]
        [CompoundCase("NoAuthRequired_FlowToken", "01311986")]
        [CompoundCase("NoAuthRequired_NoFlowToken", "")]
        [CompoundCase("NoAuthRequired_BadFlowToken", "JeepersCreepers.")]
        [CompoundCase("NoAuthRequired_NegativeFlowToken", "-1")]
        public class NoAuthRequired_FlowtokenCases : TestBase
        {
            protected override void Execute ()
            {
                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SimplePath);
                if ((string)Parent.Parent.MyValues[0] == "GET") AddGetDataToRequest(req);
                if ((string)Parent.Parent.MyValues[0] == "POST") AddPostDataToRequest(req);
                req.OtherHeaders.AddFirst(String.Format("X-Floken:{0}", MyValues[0].ToString()));

                http.SendRequest(req);
                VerifyEverythingPossible(200, req, http.GetResponse(), false, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Simple Positive normal test case with good vibes")]
        public class NoAuthRequired_NoPassport: TestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SimplePath);
                if ((string)Parent.MyValues[0] == "GET") AddGetDataToRequest(req);
                if ((string)Parent.MyValues[0]=="POST") AddPostDataToRequest(req);

                http.SendRequest(req);
                VerifyEverythingPossible(200, req, http.GetResponse(), false, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Simple Positive normal test case with good vibes")]
        public class NoAuthRequired_WithPassport: TestBase
        {
            protected override void Execute()
            {
                Global.RO.Debug("Making user...");
                KdcUser user=AuthContext.MakeNewGenericUser(true, true);
                string ticket=AuthClientBase.GetAAPassportTicket(user.Passport.UserName, user.Passport.Password, "MBI");

                //
                Global.RO.Debug("Doing request...");
                HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SimplePath);
                if ((string)Parent.MyValues[0] == "GET") AddGetDataToRequest(req);
                if ((string)Parent.MyValues[0]=="POST") AddPostDataToRequest(req);
                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t="+ticket);

                http.SendRequest(req);
                VerifyEverythingPossible(200, req, http.GetResponse(), false, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Valid passport, but the user isn't an xbox live user.")]
        public class AuthRequired_NonXblUser: TestBase
        {
            protected override void Execute()
            {
                ActiveAuthHttpClient client=new ActiveAuthHttpClient();
                client.PassportName=NON_XBL_PASSPORT_NAME;
                client.PassportPassword=NON_XBL_PASSPORT_PW;

                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
                tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;

                HttpClient.Response res;
                if ((string)Parent.MyValues[0] == "POST") res = client.PostPageRequest(AuthPath, tfd_req.ToArray(), "text/xml");
                else res = client.GetPageResponse(AuthPath + TestFDQueryString);
                
                VerifyEverythingPossible(200, null, res, true, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Valid passport and user is an xbl user.")]
        public class AuthRequired_XblUser: TestBase
        {
            protected override void Execute()
            {
                Global.RO.Debug("Making user...");
                KdcUser user=AuthContext.MakeNewGenericUser(true, true);

                //
                Global.RO.Debug("Doing request...");
                ActiveAuthHttpClient client=new ActiveAuthHttpClient();
                client.PassportName=user.Passport.UserName;
                client.PassportPassword=user.Passport.Password;

                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
                tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;

                HttpClient.Response res;
                if ((string)Parent.MyValues[0] == "POST") res = client.PostPageRequest(AuthPath, tfd_req.ToArray(), "text/xml");
                else res = client.GetPageResponse(AuthPath + TestFDQueryString);
                
                VerifyEverythingPossible(200, null, res, true, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Make a user... sign them into the kdc and activeauth... and verify that the priveleges match")]
        [CompoundCase("Silver", false)]
        [CompoundCase("Gold", true)]
        public class CompareToXkdcPrivileges: TestBase
        {
            protected override void Execute()
            {
                bool isGold=(bool)MyValues[0];

                //our crazy user
                Global.RO.Debug("Making "+(isGold?"gold":"silver")+" user...");
                KdcUser user=AuthContext.MakeNewGenericUser(true, isGold);

                //do activeauth
                Global.RO.Debug("Doing activeauth request...");
                ActiveAuthHttpClient client=new ActiveAuthHttpClient();
                client.PassportName=user.Passport.UserName;
                client.PassportPassword=user.Passport.Password;

                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
                tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;

                HttpClient.Response aares;
                if ((string)Parent.Parent.MyValues[0] == "POST") aares = client.PostPageRequest(AuthPath, tfd_req.ToArray(), "text/xml");
                else aares = client.GetPageResponse(AuthPath + TestFDQueryString);
                
                VerifyEverythingPossible(200, null, aares, true, true);
                TestFdReflectorResponse reflResponse = new TestFdReflectorResponse();
                reflResponse.ReadBytes(aares.ContentBytes);
                Dictionary<string, string> aainfo = reflResponse.CallerSpecific.Dict;

                //do kdc
                Global.RO.Debug("Doing xkdc request...");
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                ctx.SetUser(user, 0);
                ctx.SetTitle(0xFFFF0072, 0, 0); //a title with no t_title_priveleges
                XkdcClient xkdc=new XkdcClient(ctx);
                xkdc.SignInXkdc();
                XkdcResult kdcres=ctx.ServiceCtxXe.GetXkdcResult();

                //now compare privileges
                ResultCode = TEST_RESULTS.PASSED;

                string[] privs = aainfo["HasPrivilege"].Split(',');

                for (int i=128; i<256; ++i)
                {
                    string ps = i.ToString();
                    bool hasp = false;
                    foreach (string p in privs)
                    {
                        if (p == ps)
                        {
                            hasp = true;
                            break;
                        }
                    }

                    if (kdcres.HasPrivilege(0, i) && !hasp)
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        Global.RO.Error("xkdc result has privilege "+i+" set but AAInfo doesn't.");
                    }

                    if (!kdcres.HasPrivilege(0, i) && hasp)
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        Global.RO.Error("AAInfo has privilege "+i+" set but xkdc result doesn't doesn't.");
                    }
                }
            }
        }

        [TestCase, Description("Verify that AAInfo data is correct when given a SAML token.")]
        [CompoundCase("Authorization", "Authorization")]
        [CompoundCase("X-Authorization", "X-Authorization")]
        public class BasicSAML : TestNode
        {
            public override void Run()
            {
                STSUtil.GetSecurityTicketParameters gstp = new STSUtil.GetSecurityTicketParameters();
                gstp.Certificate = STSUtil.GetStsSigningCertificate();
                string token = STSUtil.GetSecurityTicket(gstp);

                HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SamlPath);
                if ((string)Parent.Parent.MyValues[0] == "GET") AddGetDataToRequest(req);
                if ((string)Parent.Parent.MyValues[0] == "POST") AddPostDataToRequest(req);
                req.OtherHeaders.AddFirst(MyValues[0].ToString() + ": XBL1.0 x=" + token);

                http.SendRequest(req);
                VerifyEverythingPossible(200, req, http.GetResponse(), new AuthData() { Authorization=AuthData.AuthType.Saml, SamlTokenValues=gstp });
            }
        }

        [TestCase, Description("Valid, self-generated passport, but the user isn't an xbox live user.")]
        public class TicketGen_NonXblUser : TestNode
        {
            public override void Run()
            {
                string ticket = AuthClientBase.GetAAPassportTicketSelfGen(NON_XBL_PASSPORT_NAME, unchecked((long)(XOn.XboxId.UserBase - 1)));

                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), AuthPath);
                if ((string)Parent.MyValues[0] == "GET") AddGetDataToRequest(req);
                if ((string)Parent.MyValues[0] == "POST") AddPostDataToRequest(req);
                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + ticket);

                http.SendRequest(req);
                VerifyEverythingPossible(200, req, http.GetResponse(), true, false);
            }
        }

        [TestCase, Description("Valid, self-generated passport, and the user is an xbox live user.")]
        public class TicketGen_XblUser : TestNode
        {
            public override void Run()
            {
                ServerTestFramework.Database.UserEditor ue = ServerTestFramework.Database.UserEditor.CreateNew();
                ue.LinkPassport((ulong)ue.UserPassportPuid);
                string ticket = AuthClientBase.GetAAPassportTicketSelfGen(ue.Gamertag, ue.UserPassportPuid);

                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), AuthPath);
                if ((string)Parent.MyValues[0] == "GET") AddGetDataToRequest(req);
                if ((string)Parent.MyValues[0] == "POST") AddPostDataToRequest(req);
                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + ticket);

                http.SendRequest(req);
                VerifyEverythingPossible(200, req, http.GetResponse(), true, true);
            }
        }

        [TestCase, Description("An xbox user with a generated ticket from varying WLID sites.")]
        [CompoundCase("{0}", "kdc.xblob.xboxlive.com")]
        [CompoundCase("{0}", "xuacs.xblob.xboxlive.com")]
        [CompoundCase("{0}", "kdc.xboxlive.com")]
        [CompoundCase("{0}", "xuacs.cert.xboxlive.com")]
        [CompoundCase("{0}", "kdc.test.xboxlive.com")]
        [CompoundCase("{0}", "xuacs.test.xboxlive.com")]
        [CompoundCase("{0}", "live.test.xbox.com")]
        [CompoundCase("{0}", "live.dev.xbox.com")]
        [CompoundCase("{0}", "live.stress2.xbox.com")]
        [CompoundCase("{0}", "live.stress.xbox.com")]
        [CompoundCase("{0}", "live.part.xbox.com")]
        [CompoundCase("{0}", "live.cert.xbox.com")]
        public class TicketGen_Multisite : TestNode
        {
            public override void Run ()
            {
                // get our WLID site and the valid ones
                string rpsSite = (string)MyValues[0];
                string[] validAASites = Global.XEnv.MultiSettingRead(MultiSetting.aamodule_rpsSiteNames);
                IEnumerable<uint> validAASiteNumbers = validAASites.Select(site => AuthClientBase.ConvertSiteNameToNumber(site));
                bool siteIsValid = validAASiteNumbers.Contains(AuthClientBase.ConvertSiteNameToNumber(rpsSite));

                ServerTestFramework.Database.UserEditor ue = ServerTestFramework.Database.UserEditor.CreateNew();
                ue.LinkPassport((ulong)ue.UserPassportPuid);
                string ticket = AuthClientBase.GetAAPassportTicketSelfGen(ue.Gamertag, ue.UserPassportPuid, rpsSite);

                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), AuthPath);
                if ((string)Parent.Parent.MyValues[0] == "GET") AddGetDataToRequest(req);
                if ((string)Parent.Parent.MyValues[0] == "POST") AddPostDataToRequest(req);
                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + ticket);

                http.SendRequest(req);
                HttpClient.Response resp = http.GetResponse();

                if (siteIsValid)
                {
                    VerifyEverythingPossible(200, req, resp, true, true);
                }
                else
                {
                    ValueCheck.TestNotNull("HTTP Response", resp);
                    ValueCheck.Test("HTTP Response Status", 401, resp.Status);
                }
            }
        }

        #endregion //Tests
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\AAGateway.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Net;
using System.Net.Sockets;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using xonline.common.protocol;
using xonline.common.config;
using System.IO;

[assembly: RootNode(typeof(AAGatewayTests.AAGateway))]

namespace AAGatewayTests
{
    /// <summary>
    /// Test Plan on the Wiki
    /// http://xblwiki/default.aspx/XboxLive/ActiveAuthGatewayTestPlan.html
    /// </summary>
    [Owner("johnmcp"), TestFrequency("Daily"), EnvRequirement("TestFD")]
    public class AAGateway : TestNode
    {
        public override void PreRun(RUN_TYPE runType)
        {
            //setup passport
            AuthClientBase.InitializePassportIDCRL();

            // set some defaults
            HttpClient.Verbose = false;
            AAGatewayTestBase.IgnoreAAModule = false;

            //
            if (runType == RUN_TYPE.STRESS)
            {
                PirateSGTest.SharedStressTests.SetupStress();
            }
        }

        public override void PostRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.STRESS)
            {
                PirateSGTest.SharedStressTests.EndStress();
            }
        }
    }

    /// <summary>
    /// The base class for all ActiveAuth Gateway tests.
    /// </summary>
    public class AAGatewayTestBase : TestNode
    {
        #region TestBase Related

        private DateTime startTime;

        public override void PreRun()
        {
            startTime = System.DateTime.Now;
        }

        /// <summary>
        /// The time that the test began executing.
        /// </summary>
        protected DateTime TestExecutionBegin
        {
            get
            {
                return startTime;
            }
        }

        /// <summary>
        /// Use AAExecute for test code.
        /// </summary>
        public override void Run()
        {
            AAExecute();
        }

        /// <summary>
        /// The function for real test code.
        /// </summary>
        protected virtual void AAExecute () { }

        /// <summary>
        /// The test case name as a nice XRLScan-passing path and query string.
        /// </summary>
        public string TestCaseQueryString
        {
            get
            {
                return TestFDReflectPath + "?" + String.Join("", Name.Split(new char[] { '_', ' ', '[', ']', '+', '-' }));
            }
        }

        /// <summary>
        /// The virtual interface name of the reflector.
        /// </summary>
        public static string ReflectorVInterfaceName
        {
            get
            {
                return "testfd";
            }
        }

        /// <summary>
        /// If true, the module is assumed to be MIA.
        /// </summary>
        public static bool IgnoreAAModule = false;

        /// <summary>
        /// A path that is known to be mapped through the gateway.
        /// </summary>
        public const string TestFDReflectPath = "/testfd/Reflect.ashx";

        /// <summary>
        /// A path that is known to NOT be mapped through the gateway.
        /// </summary>
        public const string TestFDReflectNoAuthSgPath = "/testfd/ReflectNoAuthSg.ashx";

        /// <summary>
        /// A path that to a folder that should be handled by the reflector.
        /// </summary>
        public const string TestFDReflectFolderPath = "/testfd/Reflect/";

        /// <summary>
        /// A path that is known to be NOT mapped through the gateway.
        /// </summary>
        public const string TestFDNoReflectPath = TestFDReflectFolderPath + "authsg/WillNotReflect.ashx";

        /// <summary>
        /// This should allow the HttpClient to connect to the AAGateway.
        /// </summary>
        public static IPEndPoint AAGatewayServer
        {
            get
            {
                return AAGatewayInfo.AAGatewayServer;
            }
        }

        /// <summary>
        /// The default Host name for our requests.
        /// </summary>
        public static string DefaultHost
        {
            get
            {
                return AAGatewayInfo.GetInstanceHostname("activeauth");
            }
        }

        #endregion

        #region SQL Related

        /// <summary>
        /// The SQL command that gets the mapped XRLs.
        /// </summary>
        public const string GetForwardServiceListString = @"
    select
        vc_XRL,
        vc_virtual_interface,
        vc_environment
    from
        t_xrl_virtual_interface_mappings
    where
        ti_authsg = 1 and
        (vc_environment = 'ALL' or vc_environment = '{0}')
";

        /// <summary>
        /// Simple data about a row from t_xrl_virtual_interface_mappings.
        /// </summary>
        public class XrlMapping
        {
            public class Entry
            {
                public string VirtualInterface;
                public string Environment;
            }

            public XrlMapping ()
            {
                Entries = new List<Entry>();
            }

            public string XRL;
            public List<Entry> Entries;
        }

        /// <summary>
        /// Gets a dictionary of the currently mapped XRLs.
        /// Does not use the stored procedure that the gateway does.
        /// </summary>
        /// <returns>A dictionary of the currently mapped XRLs.</returns>
        public static Dictionary<string, XrlMapping> GetMappedXRLs ()
        {
            Dictionary<string, XrlMapping> ans = new Dictionary<string, XrlMapping>();

            SqlCommand comm = new SqlCommand(string.Format(GetForwardServiceListString, 
                Config.Environment.Replace("'", "''")));
            comm.CommandType = System.Data.CommandType.Text;

            using (SqlConnection conn = new SqlConnection(xonline.common.config.Config.NpdbConnectionString))
            {
                comm.Connection = conn;
                conn.Open();

                SqlDataReader reader = comm.ExecuteReader();

                while (reader.Read())
                {
                    string xrl = reader.GetString(0);
                    string vint = reader.GetString(1);
                    string env = reader.GetString(2);

                    XrlMapping xm = null;

                    if (ans.ContainsKey(xrl))
                    {
                        xm = ans[xrl];
                    }
                    else
                    {
                        xm = new XrlMapping();
                        xm.XRL = xrl;
                        ans.Add(xrl, xm);
                    }

                    xm.Entries.Add(new XrlMapping.Entry() { VirtualInterface = vint, Environment = env });
                }

                conn.Close();
            }

            return ans;
        }

        /// <summary>
        /// Executes SQL against NPDB.
        /// </summary>
        /// <param name="sql">The SQL to execute.</param>
        public static void ExecuteSQL (string sql)
        {
            PirateSGTest.SharedSetup.ExecuteSQL(sql);
        }

        /// <summary>
        /// Executes SQL against NPDB.
        /// </summary>
        /// <param name="sql">The SQL to execute.</param>
        /// <returns>The first column of the first row returned.</returns>
        public static string ExecuteScalarSQL (string sql)
        {
            return PirateSGTest.SharedSetup.ExecuteScalarSQL(sql);
        }

        /// <summary>
        /// Sets up the mapping from the gateway to the virtual interface.  Should also enable the request to pass
        /// through XRLScan at the virtual interface destination.
        /// </summary>
        /// <param name="path">The path to map on the gateway.</param>
        /// <param name="vinterface">The virtual interface to map to.</param>
        /// <remarks>DEPRECATED because this should only be used sparingly.</remarks>
        public static void MapFromGatewayToVirtualInterfaceDEPRECATED(string path, string vinterface, bool ti_authsg)
        {
            ExecuteSQL(MapFromGatewayToVirtualInterface_SQL(path, vinterface, ti_authsg));
        }

        public static void MapFromGatewayToVirtualInterfaceDEPRECATED(string path, string vinterface, bool ti_authsg, bool ti_allow_no_exact_match)
        {
            ExecuteSQL(MapFromGatewayToVirtualInterface_SQL(path, vinterface, ti_authsg, ti_allow_no_exact_match));
        }

        public static string MapFromGatewayToVirtualInterface_SQL(string path, string vinterface, bool ti_authsg)
        {
            return MapFromGatewayToVirtualInterface_SQL(path, vinterface, ti_authsg, false);
        }

        /// <summary>
        /// Creates the sql for setting up the gateway.
        /// </summary>
        /// <param name="path">The path to map on the gateway.</param>
        /// <param name="vinterface">The virtual interface to map to.</param>
        /// <returns>The sql for mapping the gateway to the virtual interface.</returns>
        public static string MapFromGatewayToVirtualInterface_SQL (string path, string vinterface, bool ti_authsg, bool ti_allow_no_exact_match)
        {
            return String.Format(@"
if exists(select null from t_xrl_virtual_interface_mappings where vc_xrl = '{0}' and vc_virtual_interface = '{1}') begin
    update t_xrl_virtual_interface_mappings set
        [ti_xrlscan] = 1, [ti_websg] = 0, [ti_livepxy] = 0, [i_max_url_length] = 10000, 
        [i_max_content_length] = -1, [i_max_query_string_length] = 40000, [ti_allow_text_xml_type] = 1, 
        [ti_dont_get_sg_info] = 1, [ti_allow_no_exact_match] = {2}, [ti_authsg] = {3}
        where vc_xrl = '{0}' and vc_virtual_interface = '{1}'
end else begin
    insert into t_xrl_virtual_interface_mappings
        ([vc_xrl], [vc_virtual_interface], [ti_xrlscan], [ti_websg], [ti_livepxy], [i_max_url_length], 
         [i_max_content_length], [i_max_query_string_length], [ti_allow_text_xml_type], [ti_dont_get_sg_info], 
         [ti_allow_no_exact_match], [ti_authsg], [vc_http_verbs])
        values
        ('{0}', '{1}', 1, 0, 0, 10000, -1, 40000, 1, 1, {2}, {3}, 'GET,POST,PUT,DELETE')
end
                ", path.Replace("'", "''"), vinterface.Replace("'", "''"), (ti_allow_no_exact_match ? "1" : "0"), (ti_authsg ? "1" : "0"));
        }
        /*
        /// <summary>
        /// Removes the mapping from the gateway to the virtual interface.  Should also disable the request to pass
        /// through XRLScan at the virtual interface destination.
        /// </summary>
        /// <param name="path">The path to unmap on the gateway.</param>
        /// <param name="vinterface">The virtual interface to unmap from.</param>
        /// <remarks>DEPRECATED because this should only be used sparingly.</remarks>
        public static void UnmapFromGatewayToVirtualInterfaceDEPRECATED (string path, string vinterface)
        {
            ExecuteSQL(String.Format(@"
delete from t_xrl_virtual_interface_mappings
    where vc_xrl = '{0}' and vc_virtual_interface = '{1}'
                ", path.Replace("'", "''"), vinterface.Replace("'", "''")));

            // give servers some time to pick up the changes
            System.Threading.Thread.Sleep(250);
        }
        */
        /// <summary>
        /// Sets up the module policy to allow the specified path through with no trouble.
        /// </summary>
        /// <param name="path">The path to set up.</param>
        /// <remarks>DEPRECATED because this should only be used sparingly.</remarks>
        public static void SetModulePolicyDEPRECATED (string path)
        {
            if (IgnoreAAModule)
            {
                return;
            }

            // currently the PolicyEntry doesn't escape ', not that a path should have any 's, but its safer
            ActiveAuthHttpConfig.PolicyEntry pe = new ActiveAuthHttpConfig.PolicyEntry();
            pe.Path = path.Replace("'", "''");
            ActiveAuthHttpConfig.SetPolicyEntry(pe);
        }
        
        #endregion

        #region XMGMT Related

        /// <summary>
        /// Calls the XMGMT reload command.
        /// </summary>
        public static bool Reload ()
        {
            AAGatewayInfo[] servers = AAGatewayInfo.Servers;
            bool ans = true;
            string response = null;

            foreach (AAGatewayInfo info in servers)
            {
                if (info.XmgmtEndPoint == null)
                {
                    Global.RO.Debug("A gentle reminder, the server {0} could not be found and will not be reloaded.",
                        info.Name);
                }
                else if (ExecuteXmgmtCmd(info.XmgmtEndPoint, "e :authsg reload", out response))
                {
                    if (response == null || response.Trim() != "ActiveAuthGateway reloaded")
                    {
                        Global.RO.Error("Expecting to get the response 'ActiveAuthGateway reloaded', got: {0}",
                            (response == null ? "<null>" : response.Trim()));
                        ans = false;
                    }
                }
                else if (response != null && response.Trim() == "Process/Component not found")
                {
                    Global.RO.Debug("AAGateway not found on the server, assuming that it has just been unloaded.");
                    ans = true;
                }
                else
                {
                    Global.RO.Error("Error reloading the AAGateway: {0}", (response == null ? "<null>" : response));
                    ans = false;
                }
            }

            Global.RO.Debug("Finished reloading the AAGateway.");
            return ans;
        }

        /// <summary>
        /// Calls Reload, and throws if it fails.
        /// </summary>
        public static void ReloadWithFail ()
        {
            if (!Reload())
            {
                throw new AAGatewayException("The AAGateway reload failed.");
            }
        }

        /// <summary>
        /// Calls configcacherefresh on the authsg.
        /// </summary>
        public static void ConfigCacheRefresh ()
        {
            ExecuteXmgmtCmd("e :authsg configcacherefresh");
        }

        /// <summary>
        /// Calls configcacherefresh on the AAModule.
        /// </summary>
        public static void ConfigCacheRefreshModule ()
        {
            if (!IgnoreAAModule)
            {
                AAGatewayInfo[] servers = AAGatewayInfo.Servers;

                foreach (AAGatewayInfo server in servers)
                {
                    ReloadIISProcessHelper(server.Name, server.XmgmtEndPoint, "authsg", "aamodule configcacherefresh");
                }
            }
        }

        /// <summary>
        /// Reloads the AAModule.
        /// </summary>
        public static void ReloadModule ()
        {
            if (!IgnoreAAModule)
            {
                AAGatewayInfo[] servers = AAGatewayInfo.Servers;

                foreach (AAGatewayInfo server in servers)
                {
                    ReloadIISProcessHelper(server.Name, server.XmgmtEndPoint, "authsg", "aamodule reload");
                }
            }
        }

        /// <summary>
        /// Reloads xrlscan on AuthSG and TestFD.
        /// </summary>
        public static void ReloadXrlscan ()
        {
            ReloadXrlscan(true);
        }

        /// <summary>
        /// Reloads xrlscan on AuthSG, and optionally reloads it on TestFD.
        /// </summary>
        /// <param name="testFdAlso">If true, reloads xrlscan on TestFD; does not otherwise.</param>
        public static void ReloadXrlscan (bool testFdAlso)
        {
            AAGatewayInfo[] servers = AAGatewayInfo.Servers;

            foreach (AAGatewayInfo server in servers)
            {
                ReloadIISProcessHelper(server.Name, server.XmgmtEndPoint, "authsg", "xrlscan reload_mappings");
            }

            // now testfd, if requested
            if (testFdAlso)
            {
                string[] testfds = Global.XEnv.GetServerListByInterface(Interface.testfd);

                foreach (string server in testfds)
                {
                    IPEndPoint ipe = Global.XEnv.GetInterface(Interface.xmgmtsrv, server);

                    ReloadIISProcessHelper(server, ipe, "testfd", "xrlscan reload_mappings");
                }
            }
        }

        /// <summary>
        /// A helper for reload functions that need to know the process id.
        /// </summary>
        protected static void ReloadIISProcessHelper (string serverName, IPEndPoint xmgmgtIpe, string processOwner, string reloadCommand)
        {
            int[] pid = ManagementConsole.GetIISProcessIDs(xmgmgtIpe, processOwner);
            string response;

            if (pid.Length == 0)
            {
                Global.RO.Debug("No " + processOwner + " instance running on " + serverName);
                return;
            }

            if (pid.Length > 1)
            {
                Global.RO.Warn("Multitple " + processOwner + " instances running on " + serverName + ", please investigate.");
            }

            for (int i = 0; i < pid.Length; ++i)
            {
                ExecuteXmgmtCmd(xmgmgtIpe, "e " + pid[i].ToString() + ":" + reloadCommand, out response);
            }
        }

        /// <summary>
        /// A result from executing an Xmgmt command.
        /// </summary>
        public class XmgmtCommandResult
        {
            public AAGatewayInfo Server = null;
            public bool Success = false;
            public string Response = null;
        }

        /// <summary>
        /// Executes an Xmgmt command against all AAGateway servers.
        /// </summary>
        /// <param name="command">The command to execute.</param>
        /// <returns>An array of XmgmtCommandResult s.</returns>
        public static XmgmtCommandResult[] ExecuteXmgmtCmd(string command)
        {
            return ExecuteXmgmtCmd(command, "authsg");
        }

        /// <summary>
        /// Executes an Xmgmt command against all AAGateway servers.
        /// </summary>
        /// <param name="command">The command to execute.</param>
        /// <param name="subProcess">The subProcess to execute against</param>
        /// <returns>An array of XmgmtCommandResult s.</returns>
        public static XmgmtCommandResult[] ExecuteXmgmtCmd (string command, string subProcess)
        {
            AAGatewayInfo[] servers = AAGatewayInfo.Servers;
            string response = null;
            XmgmtCommandResult[] results = new XmgmtCommandResult[servers.Length];
            bool find_pid = command.Contains("%PID%");

            for (int i = 0; i < servers.Length; ++i)
            {
                AAGatewayInfo info = servers[i];

                results[i] = new XmgmtCommandResult();
                results[i].Server = info;

                if (info.XmgmtEndPoint == null)
                {
                    Global.RO.Debug("A gentle reminder, the server {0} could not be found.",
                        info.Name);
                    continue;
                }

                string actual_command = command;

                if (find_pid)
                {
                    int[] pids = ManagementConsole.GetIISProcessIDs(info.XmgmtEndPoint, subProcess);

                    if (pids.Length == 0)
                    {
                        // There are no processes running right now, just let it go
                        return new XmgmtCommandResult[0];
                        //throw new AAGatewayException("Could not find authsg process id.");
                    }

                    actual_command = actual_command.Replace("%PID%", pids[0].ToString());
                }

                if (ExecuteXmgmtCmd(info.XmgmtEndPoint, actual_command, out response))
                {
                    results[i].Success = true;
                }
                else
                {
                    Global.RO.Error("Error executing xmgmt against the AAGateway: {0}", (response == null ? "<null>" : response));
                    results[i].Success = false;
                }

                results[i].Response = response;
            }

            Global.RO.Debug("Finished executing '{0}' against the AAGateway.", command);
            return results;
        }

        /// <summary>
        /// Executes an Xmgmt command against the given endpoint.
        /// </summary>
        /// <param name="endpoint">The endpoint to execute on.</param>
        /// <param name="command">The command to execute.</param>
        /// <param name="response">The response returned by the execution.</param>
        /// <returns>True if the execution succeeded; false if it did not.</returns>
        public static bool ExecuteXmgmtCmd (IPEndPoint endpoint, string command, out string response)
        {
            bool bSuccess = false;
            response = null;

            try
            {
                bSuccess = ManagementConsole.Execute(endpoint, command, out response);
            }
            catch (System.IO.IOException e)
            {
                Global.RO.Error("Error executing \"{0}\" on {1}: {2}", command, endpoint, e.Message);
            }
            catch (System.Net.Sockets.SocketException e)
            {
                Global.RO.Error("Error executing \"{0}\" on {1}: {2}", command, endpoint, e.Message);
            }

            return bSuccess;
        }

        /// <summary>
        /// Executes an Xmgmt command against all AAGateway servers.  If any fail, throws an exception.
        /// </summary>
        public static void ExecuteXmgmtCmdWithFailure (string command)
        {
            ExecuteXmgmtCmdWithFailure(command, "authsg");
        }

        public static void ExecuteXmgmtCmdWithFailure(string command, string server)
        {
            XmgmtCommandResult[] results = ExecuteXmgmtCmd(command, server);

            foreach (XmgmtCommandResult result in results)
            {
                if (!result.Success)
                {
                    throw new AAGatewayException("Executing '{0}' against {1} failed.", command, result.Server.Name);
                }
            }
        }

        #endregion

        #region Event Related

        /// <summary>
        /// Events that the AAGateway can log.
        /// </summary>
        public enum AAGatewayEvent : long
        {
            ///<summary>
            /// Dev cause: No URL was specified in the request header. Possible Hacker.
            /// Ops action: Please monitor
            /// </summary>
            XEVENT_AAGW_HACK_URL = 0xC000F96A,

            ///<summary>
            /// Dev cause: The desired services is unknown to AuthSg. Possible Hacker.
            /// Ops action: Please monitor
            /// </summary>
            XEVENT_AAGW_HACK_UNKNOWN_SERVICE = 0xC000F96B,

            ///<summary>
            /// Dev cause: The HttpMethod specified wasn't HEAD, POST, or GET.
            /// Ops action: Please monitor
            /// </summary>
            XEVENT_AAGW_HACK_UNKNOWN_HTTP_METHOD = 0xC000F96C,

            /// <summary>
            /// Dev cause: URL was too long according to the xrlscan table
            /// Ops action: Please monitor
            /// </summary>
            XEVENT_AAGW_HACK_URL_TOO_LONG = 0xC000F96D,

            /// <summary>
            /// Dev cause: Query was too long according to the xrlscan table
            /// Ops action: Please monitor
            /// </summary>
            XEVENT_AAGW_HACK_QUERY_TOO_LONG = 0xC000F96E,

            /// <summary>
            /// Dev cause: Content was too long according to the xrlscan table
            /// Ops action: Please monitor
            /// </summary>
            XEVENT_AAGW_HACK_CONTENT_TOO_LONG = 0xC000F96F,

            ///<summary>
            /// Dev cause: An Exception without a response occured
            /// Ops action: Please monitor
            /// </summary>
            XEVENT_AAGW_EXCEPTION_WITH_NO_RESPONSE = 0xC000F970,

            ///<summary>
            /// Dev cause: NPDB contains an invalid value for a setting
            /// Ops action: Investigate NPDB setting value
            /// </summary>
            XEVENT_AAGW_CONFIG_INVALID_SETTING = 0xC000F971,

            ///<summary>
            /// Dev cause: No Service Table Exists.
            /// Ops Action: Check that t_xrl_virtual_interface_mapping exists and has some
            ///             services configured for this gateway
            /// </summary>
            XEVENT_AAGW_CONFIG_SERVICE_TABLE = 0xC000F972,

            ///<summary>
            /// Ops action: informational config event
            /// </summary>
            XEVENT_AAGW_CONFIG_INFO = 0x4000F973,

            /// <summary>
            /// Dev cause: Unexpected internal error. Look at exception text.
            /// Ops action: Report event to dev team for investigation. This is an unexpected error.
            /// </summary>
            XEVENT_AAGW_INTERNAL_ERROR = 0xC000F974,
        }

        /// <summary>
        /// Checks for the given event from the time the test started to now on all servers.
        /// Uses a 3 second window on either side to compensate for differing times on the servers.
        /// </summary>
        /// <param name="id">The event to look for.</param>
        public bool CheckForEventAll (AAGatewayEvent id)
        {
            return CheckForEventAll(id, TestExecutionBegin.AddSeconds(-3), DateTime.Now.AddSeconds(3));
        }

        /// <summary>
        /// Checks for the given event between the two times on all servers.
        /// </summary>
        /// <param name="id">The event to look for.</param>
        /// <param name="begin">The earliest time to check.</param>
        /// <param name="end">The latest time to check.</param>
        /// <returns>True if the event is found on all servers; false if not.</returns>
        public static bool CheckForEventAll (AAGatewayEvent id, DateTime begin, DateTime end)
        {
            AAGatewayInfo[] servers = AAGatewayInfo.Servers;

            foreach (AAGatewayInfo info in servers)
            {
                if (info.XmgmtEndPoint != null && 
                    !Events.TestServerForEvents(info.Name, "Application", "", (long) id, begin, end))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Checks for the given string between the two times on any server.
        /// </summary>
        /// <param name="search">A string to search the event for.</param>
        /// <param name="begin">The earliest time to check.</param>
        /// <returns>True if the event is found on any server; false if not.</returns>
        public static bool CheckForEventAny (string search, DateTime begin)
        {
            AAGatewayInfo[] servers = AAGatewayInfo.Servers;

            foreach (AAGatewayInfo info in servers)
            {
                if (info.XmgmtEndPoint != null &&
                    Events.TestServerForEvents(info.Name, "Application", "", search, begin))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Checks for the given event between the two times on any server.
        /// </summary>
        /// <param name="id">The event to look for.</param>
        /// <param name="begin">The earliest time to check.</param>
        /// <param name="end">The latest time to check.</param>
        /// <returns>True if the event is found on any server; false if not.</returns>
        public static bool CheckForEventAny (AAGatewayEvent id, DateTime begin, DateTime end)
        {
            AAGatewayInfo[] servers = AAGatewayInfo.Servers;

            foreach (AAGatewayInfo info in servers)
            {
                if (info.XmgmtEndPoint != null && 
                    Events.TestServerForEvents(info.Name, "Application", "", (long) id, begin, end))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Checks for the given event between the two times on any server.  It must be the correct id and contain
        /// the search string.
        /// </summary>
        /// <param name="id">The event to look for.</param>
        /// <param name="search">A string to search the event for.</param>
        /// <param name="begin">The earliest time to check.</param>
        /// <param name="end">The latest time to check.</param>
        /// <returns>True if the event is found on any server; false if not.</returns>
        public static bool CheckForEventAny (AAGatewayEvent id, string search, DateTime begin, DateTime end)
        {
            AAGatewayInfo[] servers = AAGatewayInfo.Servers;

            foreach (AAGatewayInfo info in servers)
            {
                if (info.XmgmtEndPoint != null &&
                    Events.TestServerForEvents(info.Name, "Application", "", (long) id, search, begin, end))
                {
                    return true;
                }
            }

            return false;
        }

        #endregion

        #region HttpClient Related

        /// <summary>
        /// Checks a response for a specific status code, throws an exception if its not correct.
        /// </summary>
        /// <param name="response">The response to check.</param>
        /// <param name="status">The status code to check for.</param>
        public static void CheckResponseForStatus (HttpClient.Response response, int status)
        {
            if (response == null)
            {
                throw new AAGatewayException("Response is null.");
            }
            CheckResponseForStatus(response.ToString(), response.Status, response.Reason, status);
        }

        /// <summary>
        /// Check the status
        /// </summary>
        /// <param name="responseBody">Content of the response</param>
        /// <param name="responseStatus">Status Code of the Response</param>
        /// <param name="responseReason">Readable translation of the status code</param>
        /// <param name="status">ExpectedStatus</param>
        public static void CheckResponseForStatus(string responseBody, int responseStatus, string responseReason, int status)
        {

            if (responseStatus != status)
            {
                Global.RO.Debug(responseBody);
                throw new AAGatewayException("Expecting status {0}, got status {1} [{2}].  See debug output " +
                    "for full response.", status, responseStatus, responseReason);
            }
        }

        /// <summary>
        /// Checks a response for a specific status code, throws an exception if its not correct.
        /// </summary>
        /// <param name="response">The response to check.</param>
        /// <param name="status">The status code to check for.</param>
        public static void CheckResponseForStatus(HttpWebResponse response, int status)
        {
            if (response == null)
            {
                throw new AAGatewayException("Response is null.");
            }
            using (var responseStream = response.GetResponseStream())
            {
                using (var streamReader = new StreamReader(responseStream))
                {
                    CheckResponseForStatus(streamReader.ReadToEnd(), (int)response.StatusCode, response.StatusCode.ToString(), status);
                }
            }
        }

        /// <summary>
        /// Checks a response for a specific status code, throws an exception if its not correct.
        /// </summary>
        /// <param name="response">The response to check.</param>
        /// <param name="status">The status code to check for.</param>
        /// <param name="description">The status description to check for.</param>
        public static void CheckResponseForStatus (HttpClient.Response response, int status, string description)
        {
            if (response == null)
            {
                throw new AAGatewayException("Response is null.");
            }

            if (response.Status != status)
            {
                Global.RO.Debug(response.ToString());
                throw new AAGatewayException("Expecting status {0}, got status {1} [{2}].  See debug output " +
                    "for full response.", status, response.Status, response.Reason);
            }

            if (response.Reason != description)
            {
                Global.RO.Debug(response.ToString());
                throw new AAGatewayException("Expecting status description '{0}', got status description '{1}'.  " +
                    "See debug output for full response.", description, response.Reason);
            }
        }

        /// <summary>
        /// Checks a response for a specific content length, throws an exception if its not correct.
        /// </summary>
        /// <param name="response">The response to check.</param>
        /// <param name="length">The length to check for.</param>
        public static void CheckResponseForContentLength (HttpClient.Response response, int length)
        {
            if (response == null)
            {
                throw new AAGatewayException("Response is null.");
            }

            if (response.GetSingleHeader("Content-Length") != length.ToString())
            {
                Global.RO.Debug(response.ToString());
                throw new AAGatewayException("Expecting Content-Length {0}, got {1}.  See debug output " +
                    "for full response.", length, response.GetSingleHeader("Content-Length"));
            }
        }

        /// <summary>
        /// Checks a response for specific content body, throws an exception if its not correct.
        /// </summary>
        /// <param name="response">The response to check.</param>
        /// <param name="body">The body to check for.</param>
        public static void CheckResponseForContent (HttpClient.Response response, string body)
        {
            CheckResponseForContentLength(response, body.Length);

            // check actual body against bytes
            string resp_body = response.ContentString;

            if (resp_body.Length != body.Length)
            {
                Global.RO.Debug(response.ToString());
                throw new AAGatewayException("Expecting body length {0}, got {1}.  See debug output " +
                    "for full response.", body.Length, resp_body.Length);
            }

            if (resp_body != body)
            {
                Global.RO.Debug(response.ToString());
                throw new AAGatewayException("Expecting body '{0}', got '{1}'.  See debug output " +
                    "for full response.", body.Substring(0, 20) + (body.Length > 20 ? "..." : ""),
                    resp_body.Substring(0, 20) + (resp_body.Length > 20 ? "..." : ""));
            }
        }

        /// <summary>
        /// Checks a response for a header having the specified value.
        /// </summary>
        /// <param name="response">The response to check.</param>
        /// <param name="name">The name of the header.</param>
        /// <param name="value">The value that the header should have.</param>
        public void CheckResponseForHeader (HttpClient.Response response, string name, string value)
        {
            string respHeader = response.GetSingleHeader(name);
            ValueCheck.Test("Response header " + name, value, respHeader);
        }

        /// <summary>
        /// Checks a response against what we believe the gateway should return for an unknown service.
        /// </summary>
        /// <param name="response">The response to check.</param>
        /// <param name="request">The request that generated the response.</param>
        public void CheckResponseForGatewayUnknownService (HttpClient.Response response, HttpClient.Request request)
        {
            if (response == null)
            {
                throw new AAGatewayException("Response is null.");
            }

            CheckResponseForStatus(response, 400);

            CheckResponseForHeader(response, "X-Err", "0x8015000A");
            CheckResponseForHeader(response, "X-Event", "63851");

            if (response.ContentString != "Bad Request" && response.ContentString != String.Empty)
            {
                System.Xml.XmlDocument xml = new System.Xml.XmlDocument();
                xml.LoadXml(response.ContentString);

                Action<string, string> pathCheck = delegate(string path, string value)
                {
                    System.Xml.XmlNode node = xml.SelectSingleNode(path);
                    if (node == null)
                    {
                        throw new AAGatewayException("Xml node not present.");
                    }
                    ValueCheck.Test("Xml node " + path, value, node.InnerText);
                };

                pathCheck("/Exception/Type", "xonline.common.service.ExceptionWithEventId");
                pathCheck("/Exception/Message", "AuthSg: The desired service " + request.URI.ToLower() +
                    " is unknown to AuthSg. This could be a hacker. Please Monitor.");
                pathCheck("/Exception/HResult", "0x8015000A");
                pathCheck("/Exception/EventId", "63851");
            }

            if (!CheckForEventAny(AAGatewayEvent.XEVENT_AAGW_HACK_UNKNOWN_SERVICE, 
                // look for the string given by the gateway, not feapp
                RemoveQueryString(request.URI).ToLower(),
                // fudge the time a little
                TestExecutionBegin.AddSeconds(-15), DateTime.Now.AddSeconds(15)))
            {
                throw new AAGatewayException("Did not find an event about the requested service being unknown.");
            }
        }

        /// <summary>
        /// Checks a response against what we believe the gateway should return for an unknown method.
        /// </summary>
        /// <param name="response">The response to check.</param>
        /// <param name="request">The request that generated the response.</param>
        public void CheckResponseForGatewayUnknownMethod (HttpClient.Response response, HttpClient.Request request)
        {
            if (response == null)
            {
                throw new AAGatewayException("Response is null.");
            }

            CheckResponseForStatus(response, 405);
            if (request.Method != "HEAD")
            {
                CheckResponseForContentLength(response, 0);
            }

            if (!CheckForEventAny(AAGatewayEvent.XEVENT_AAGW_HACK_UNKNOWN_SERVICE, request.URI,
                // fudge the time a little
                TestExecutionBegin.AddSeconds(-5), DateTime.Now.AddSeconds(5)))
            {
                throw new AAGatewayException("Did not find an event about the requested service being unknown.");
            }
        }

        /// <summary>
        /// Checks the response against the given request to verify that it was reflected properly.
        /// </summary>
        /// <param name="response">The response from the request.</param>
        /// <param name="request">The request that generated the response.</param>
        /// <returns>The reflected response body.</returns>
        public static TestFdReflectorResponse CheckResponseAgainstRequest (HttpClient.Response response,
            HttpClient.Request request)
        {
            return CheckResponseAgainstRequest(response, request, true);
        }

        /// <summary>
        /// Checks the response against the given request to verify that it was reflected properly.
        /// </summary>
        /// <param name="response">The response from the request.</param>
        /// <param name="request">The request that generated the response.</param>
        /// <param name="checkHeaders">If true, check the headers, if false, don't.</param>
        /// <returns>The reflected resp