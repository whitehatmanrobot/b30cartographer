         OpenOptions,
                           NULL,
                           0
                         );

    //
    // Free the buffer for the link name as we are done with it.
    //

    RtlFreeUnicodeString( &NtLinkName );

    if (!NT_SUCCESS( Status )) {
        SetLastError( ERROR_INVALID_NAME );
        RtlFreeUnicodeString( &NtLinkValue );
        return FALSE;
        }

    //
    // Allocate a buffer to set the reparse point.
    //

    ReparseDataLength = (FIELD_OFFSET(REPARSE_DATA_BUFFER, SymbolicLinkReparseBuffer.PathBuffer) -
                         REPARSE_DATA_BUFFER_HEADER_SIZE) +
                        NtLinkValue.Length + sizeof(UNICODE_NULL) +
                        DosLinkValue.Length + sizeof(UNICODE_NULL);
    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)
        RtlAllocateHeap( RtlProcessHeap(),
                         HEAP_ZERO_MEMORY,
                         REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataLength
                       );
    if (ReparseBufferHeader == NULL) {
        NtClose( FileHandle );
        RtlFreeUnicodeString( &NtLinkValue );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
        }

    //
    // Set the reparse point with symbolic link tag.
    //

    if (IsMountPoint) {
        ReparseBufferHeader->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
        }
    else {
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // No support for symbolic links in NT 5.0 Beta 1
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        //
        // ReparseBufferHeader->ReparseTag = IO_REPARSE_TAG_SYMBOLIC_LINK;
        //
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }
    ReparseBufferHeader->ReparseDataLength = (USHORT)ReparseDataLength;
    ReparseBufferHeader->Reserved = 0;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameOffset = 0;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength = NtLinkValue.Length;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameOffset = NtLinkValue.Length + sizeof( UNICODE_NULL );
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength = NtLinkValue.Length;
    RtlCopyMemory( ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer,
                   NtLinkValue.Buffer,
                   NtLinkValue.Length
                 );
    RtlCopyMemory( (PCHAR)(ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer)+
                     NtLinkValue.Length + sizeof(UNICODE_NULL),
                   DosLinkValue.Buffer,
                   DosLinkValue.Length
                 );
    RtlFreeUnicodeString( &NtLinkValue );

    Status = NtFsControlFile( FileHandle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              FSCTL_SET_REPARSE_POINT,
                              ReparseBufferHeader,
                              REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataLength,
                              NULL,
                              0
                            );

    RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );
    NtClose( FileHandle );

    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    return TRUE;
}


BOOL
SetSymbolicLinkW(
    LPCWSTR lpLinkName,
    LPCWSTR lpLinkValue
    )

/*++

Routine Description:

    A symbolic link is established using CreateSymbolicLink.

Arguments:

    lpLinkName - Supplies the DOS file name where the symbolic link is located.  This
        name must exist as a symbolic link to a file/directory.

    lpLinkValue - Points to an DOS name which is the value of the symbolic link.  This
        name may or may not exist.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    BOOLEAN TranslationStatus;
    UNICODE_STRING NtLinkName;
    UNICODE_STRING NtLinkValue;
    UNICODE_STRING DosLinkValue;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    ACCESS_MASK FileAccess;
    ULONG OpenOptions;
    ULONG ReparseDataLength;
    PREPARSE_DATA_BUFFER ReparseBufferHeader;
    WCHAR FullPathLinkValue[ DOS_MAX_PATH_LENGTH+1 ];

    //
    // Ensure that link name was passed.
    //

    if (!ARGUMENT_PRESENT( lpLinkName )) {
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
        }

    //
    // Convert link name and value paths into NT versions
    //

    DosLinkValue.Buffer = FullPathLinkValue;
    DosLinkValue.MaximumLength = sizeof( FullPathLinkValue );
    DosLinkValue.Length = 0;
    if (!MassageLinkValue( lpLinkName,
                           lpLinkValue,
                           &NtLinkName,
                           &NtLinkValue,
                           &DosLinkValue
                         )
       ) {
        if (DosLinkValue.Length == 0) {
            SetLastError( ERROR_INVALID_NAME );
            }
        else {
            SetLastError( ERROR_PATH_NOT_FOUND );
            }

        RtlFreeUnicodeString( &NtLinkName );
        RtlFreeUnicodeString( &NtLinkValue );
        return FALSE;
        }

    InitializeObjectAttributes( &ObjectAttributes,
                                &NtLinkName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    //
    // Notice that FILE_OPEN_REPARSE_POINT inhibits the reparse behavior.
    //

    OpenOptions = FILE_OPEN_FOR_BACKUP_INTENT |
                  FILE_OPEN_REPARSE_POINT |
                  FILE_SYNCHRONOUS_IO_NONALERT |
                  FILE_NON_DIRECTORY_FILE;

    //
    // If no link value specified, then deleting the link
    //

    if (!ARGUMENT_PRESENT( lpLinkValue )) {
        FileAccess = DELETE | SYNCHRONIZE;
        }
    else {
        FileAccess = FILE_WRITE_DATA | FILE_READ_ATTRIBUTES |
                     FILE_WRITE_ATTRIBUTES | SYNCHRONIZE;
        }

    //
    // Open link name.  Must exists.
    //

    Status = NtOpenFile( &FileHandle,
                         FileAccess,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         OpenOptions
                       );

    //
    // Free the buffer for the link name as we are done with it.
    //

    RtlFreeUnicodeString( &NtLinkName );
    if (!NT_SUCCESS( Status )) {
        RtlFreeUnicodeString( &NtLinkValue );
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
        }

    if (!ARGUMENT_PRESENT( lpLinkValue )) {
        FILE_DISPOSITION_INFORMATION Disposition;
        //
        // Delete the link
        //
#undef DeleteFile
        Disposition.DeleteFile = TRUE;

        Status = NtSetInformationFile( FileHandle,
                                       &IoStatusBlock,
                                       &Disposition,
                                       sizeof( Disposition ),
                                       FileDispositionInformation
                                     );
        NtClose( FileHandle );
        if (!NT_SUCCESS( Status )) {
            return FALSE;
            }
        else {
            return TRUE;
            }
        }

    //
    // Allocate a buffer to set the reparse point.
    //

    ReparseDataLength = (FIELD_OFFSET(REPARSE_DATA_BUFFER, SymbolicLinkReparseBuffer.PathBuffer) -
                         REPARSE_DATA_BUFFER_HEADER_SIZE) +
                        NtLinkValue.Length + sizeof(UNICODE_NULL) +
                        DosLinkValue.Length + sizeof(UNICODE_NULL);
    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)
        RtlAllocateHeap( RtlProcessHeap(),
                         HEAP_ZERO_MEMORY,
                         REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataLength
                       );
    if (ReparseBufferHeader == NULL) {
        RtlFreeUnicodeString( &NtLinkValue );
        NtClose( FileHandle );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
        }

    //
    // Set the reparse point with symbolic link tag.
    //

    ReparseBufferHeader->ReparseTag = IO_REPARSE_TAG_SYMBOLIC_LINK;
    ReparseBufferHeader->ReparseDataLength = (USHORT)ReparseDataLength;
    ReparseBufferHeader->Reserved = 0;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameOffset = 0;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength = NtLinkValue.Length;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameOffset = NtLinkValue.Length + sizeof( UNICODE_NULL );
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength = NtLinkValue.Length;
    RtlCopyMemory( ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer,
                   NtLinkValue.Buffer,
                   NtLinkValue.Length
                 );
    RtlCopyMemory( (PCHAR)(ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer)+
                     NtLinkValue.Length + sizeof(UNICODE_NULL),
                   DosLinkValue.Buffer,
                   DosLinkValue.Length
                 );
    RtlFreeUnicodeString( &NtLinkValue );

    Status = NtFsControlFile( FileHandle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              FSCTL_SET_REPARSE_POINT,
                              ReparseBufferHeader,
                              REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataLength,
                              NULL,
                              0
                            );

    RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );
    NtClose( FileHandle );

    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    return TRUE;
}




DWORD
QuerySymbolicLinkW(
    LPCWSTR lpLinkName,
    LPWSTR lpBuffer,
    DWORD nBufferLength
    )

/*++

Routine Description:

    An existing file can be queried for its symbolic link value using QuerySymbolicLink.

Arguments:

    lpLinkName - Supplies the file name of the file to be queried.

    lpBuffer - Points to a buffer where the symbolic link is to be returned.

    nBufferSize - Length of the buffer being passed by the caller.

Return Value:

    If the function suceeds, the return value is the length, in characters, of the
    string copied to lpBuffer, not including the terminating null character. If the
    lpBuffer is too small, the return value is the size of the buffer, in characters,
    required to hold the name.

    Zero is returned if the operation failed. Extended error status is available
        using GetLastError.
--*/

{
    NTSTATUS Status;
    BOOLEAN TranslationStatus;
    UNICODE_STRING FileName;
    RTL_RELATIVE_NAME RelativeName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    ULONG OpenOptions;
    PWSTR pathBuffer;
    USHORT pathLength;
    USHORT NtPathLength;
    USHORT ReturnLength;
    PVOID FreeBuffer;
    REPARSE_DATA_BUFFER ReparseInfo;
    PREPARSE_DATA_BUFFER ReparseBufferHeader;

    if (!ARGUMENT_PRESENT( lpLinkName )) {
        SetLastError( ERROR_INVALID_NAME );
        return 0;
        }

    TranslationStatus = RtlDosPathNameToNtPathName_U( lpLinkName,
                                                      &FileName,
                                                      NULL,
                                                      &RelativeName
                                                    );

    if (!TranslationStatus) {
        SetLastError( ERROR_PATH_NOT_FOUND );
        return 0;
        }
    FreeBuffer = FileName.Buffer;

    if (RelativeName.RelativeName.Length) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes( &ObjectAttributes,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                RelativeName.ContainingDirectory,
                                NULL
                              );

    //
    // Notice that FILE_OPEN_REPARSE_POINT inhibits the reparse behavior.
    //

    OpenOptions = FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT;

    //
    // Open as file for read access.
    //

    Status = NtOpenFile( &FileHandle,
                         FILE_READ_DATA | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         OpenOptions | FILE_NON_DIRECTORY_FILE
                       );

    //
    // Free the buffer for the name as we are done with it.
    //

    RtlFreeHeap( RtlProcessHeap(), 0, FreeBuffer );

    if (!NT_SUCCESS( Status )) {
        SetLastError( ERROR_INVALID_NAME );
        return 0;
        }

    //
    // Query with zero length to get reparse point tag and required buffer length
    //

    Status = NtFsControlFile( FileHandle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              FSCTL_GET_REPARSE_POINT,
                              NULL,
                              0,
                              (PVOID)&ReparseInfo,
                              sizeof( ReparseInfo )
                            );

    //
    // Verify that the reparse point buffer brings back a symbolic link or a
    // mount point, and that we got the required buffer length back via 
    // IoStatus.Information
    //

    ReparseBufferHeader = NULL;
    if ((Status != STATUS_BUFFER_OVERFLOW) ||
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // No support for symbolic links in NT 5.0 Beta 1
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        //
        // (ReparseInfo.ReparseTag != IO_REPARSE_TAG_SYMBOLIC_LINK) ||
        //
        (ReparseInfo.ReparseTag != IO_REPARSE_TAG_MOUNT_POINT)
       ) {
        Status = STATUS_OBJECT_NAME_INVALID;
        }
    else {
        //
        // Allocate a buffer to hold reparse point information
        //

        ReparseBufferHeader = (PREPARSE_DATA_BUFFER)
            RtlAllocateHeap( RtlProcessHeap(),
                             0,
                             REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseInfo.ReparseDataLength
                           );
        if (ReparseBufferHeader == NULL) {
            //
            // Not enough memory.  Fail the call.
            //

            Status = STATUS_NO_MEMORY;
            }
        else {
            //
            // Now query the reparse point information into our allocated buffer.
            // This should not fail.
            //

            Status = NtFsControlFile( FileHandle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &IoStatusBlock,
                                      FSCTL_GET_REPARSE_POINT,
                                      NULL,
                                      0,
                                      (PVOID)ReparseBufferHeader,
                                      REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseInfo.ReparseDataLength
                                    );
            }
        }

    //
    // Done with file handle.
    //

    NtClose( FileHandle );

    //
    // Return any failure to caller
    //

    if (!NT_SUCCESS( Status )) {
        if (ReparseBufferHeader != NULL) {
            RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );
            }

        return 0;
        }

    //
    // See if this is an old style symbolic link reparse point, which only stored the
    // NT path name.  If so, return an error, as we dont have a DOS path to return
    //

    pathBuffer = (PWSTR)(
                    (PCHAR)ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer +
                    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameOffset
                    );
    pathLength = ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength;

    //
    // Sanity check the length. As the tag is fine we do not zero the buffer.
    //

    ReturnLength = pathLength / sizeof( WCHAR );

    //
    // If amount to return is less than callers buffer length, copy the Dos path
    // to the callers buffer
    //

    if (ReturnLength < nBufferLength) {
        RtlMoveMemory( (PUCHAR)lpBuffer,
                       (PCHAR)pathBuffer,
                       pathLength
                     );
        }
    else {
        //
        // If we are failing for insufficient buffer length, tell them how much
        // space they really need including the terminating null character.
        //
        ReturnLength += 1;
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        }

    RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );
    return ReturnLength;
}


VOID
GetCommandLineArgs(
    LPDWORD NumberOfArguments,
    LPWSTR Arguments[]
    )
{
    LPWSTR  lpstrCmd;
    WCHAR   ch;
    WCHAR   ArgumentBuffer[ MAX_PATH ];
    LPWSTR  p;

    lpstrCmd = GetCommandLine();

    // skip over program name
    do {
        ch = *lpstrCmd++;
       }
    while (ch != L' ' && ch != L'\t' && ch != L'\0');

    *NumberOfArguments = 0;
    while (ch != '\0') {
        //  skip over any following white space
        while (ch != L'\0' && _istspace(ch)) {
            ch = *lpstrCmd++;
        }
        if (ch == L'\0') {
            break;
        }

        p = ArgumentBuffer;
        do {
            *p++ = ch;
            ch = *lpstrCmd++;
        } while (ch != L' ' && ch != L'\t' && ch != L'\0');
        *p = L'\0';
        Arguments[ *NumberOfArguments ] = malloc( (_tcslen( ArgumentBuffer ) + 1) * sizeof( WCHAR ) );
        if (Arguments[ *NumberOfArguments ]) {
            _tcscpy( Arguments[ *NumberOfArguments ], ArgumentBuffer );
            *NumberOfArguments += 1;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\supporttools\setup\setup.cpp ===
// setup.cpp : Defines the entry point for the console application.
//

#include "Windows.h"
#include "Tchar.h"

//int main(int argc, char* argv[])
#ifdef UNICODE
    extern "C" int __cdecl
    wmain(
#else
    int __cdecl
    main(
#endif
    int argc,
    TCHAR *argv[])

{
	STARTUPINFO			structStartInfo;
	PROCESS_INFORMATION	structProcInfo;
	BOOL				bRet						=	FALSE;
	DWORD				dwLastRet					=	0L;
	TCHAR				szMsiexecPath[MAX_PATH+1]	=	_T("");
	LPCTSTR				lpszSystem32Path			=	NULL;

	do
	{

		ZeroMemory( (void*)&structStartInfo, sizeof( STARTUPINFO ) );
		ZeroMemory( (void*)&structProcInfo, sizeof( PROCESS_INFORMATION ) );

		structStartInfo.cb = sizeof( STARTUPINFO );
		structStartInfo.cbReserved2 = 0L;
		structStartInfo.dwFillAttribute = 0L; //GUI App.
		structStartInfo.dwFlags = STARTF_USESHOWWINDOW;
		structStartInfo.dwX = 0L;
		structStartInfo.dwXCountChars = 0L;
		structStartInfo.dwXSize = 0L;
		structStartInfo.dwY = 0L;
		structStartInfo.dwYCountChars = 0L;
		structStartInfo.dwYSize = 0L;
		structStartInfo.hStdError = NULL;
		structStartInfo.hStdInput = NULL;
		structStartInfo.hStdOutput = NULL;
		structStartInfo.lpDesktop = NULL;
		structStartInfo.lpReserved = NULL;
		structStartInfo.lpReserved2 = NULL;
		structStartInfo.lpTitle = NULL;
		structStartInfo.wShowWindow = SW_NORMAL;

		lpszSystem32Path = _tgetenv( _T("WINDIR") );
		_tcscpy( szMsiexecPath, lpszSystem32Path );
		_tcscat( szMsiexecPath, _T("\\system32\\msiexec.exe") );

		bRet = CreateProcess( 
					szMsiexecPath,
					_T(" /i suptools.msi"),
					NULL, 
					NULL, 
					FALSE, 
					DETACHED_PROCESS, 
					NULL, 
					NULL, 
					&structStartInfo, 
					&structProcInfo
					);

		if( FALSE == bRet ) {

			dwLastRet = GetLastError();
			break;
		}

		dwLastRet = 0L;
	}
	while( FALSE );

	if( dwLastRet != 0L ) { MessageBox( NULL, _T("Error starting the MSI file"), _T("Error"), MB_OK | MB_ICONERROR ); }

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\symlink\symlink.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    kill.c

Abstract:

    This module implements a task killer application.

Author:

    Wesley Witt (wesw) 20-May-1994

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include "common.h"

VOID
Usage(
    VOID
    );

DWORD NumberOfArguments;
PWSTR Arguments[ 128 ];

int _cdecl
main(
    int argc,
    char *argv[]
    )
{
    PWSTR s, *pArgs;
    BOOLEAN IsMountPoint = FALSE;
    PWSTR LinkName, TargetPath;
    WCHAR TargetPathBuffer[ MAX_PATH ];

    GetCommandLineArgs( &NumberOfArguments, Arguments );

    if (NumberOfArguments == 0) {
        Usage();
        return 1;
        }

    pArgs = &Arguments[ 0 ];
    s = *pArgs;
    if (s && (*s == L'-' || *s == L'/')) {
        _tcslwr( ++s );
        if (*s == L'm') {
            IsMountPoint = TRUE;
            NumberOfArguments -= 1;
            s = *++pArgs;
            }
        else
        if (*s == L'?') {
            Usage();
            return 0;
            }
        else {
            Usage();
            return 1;
            }
        }

    if (NumberOfArguments > 2) {
        Usage();
        return 1;
        }

    LinkName = s;
    if (NumberOfArguments == 2) {
        TargetPath = *++pArgs;
        CreateSymbolicLinkW( LinkName, TargetPath, IsMountPoint, NULL );
        }
    else {
        QuerySymbolicLinkW( LinkName, TargetPathBuffer, MAX_PATH );
        }
    return 0;
}


VOID
Usage(
    VOID
    )

/*++

Routine Description:

    Prints usage text for this tool.

Arguments:

    None.

Return Value:

    None.

--*/

{
    fprintf( stderr, "Microsoft (R) Windows NT (TM) Version 5.0 MKLNK\n" );
    fprintf( stderr, "Copyright (C) 1997 Microsoft Corp. All rights reserved\n\n" );
    fprintf( stderr, "usage: SYMLINK [-m] fileName [targetPath]\n\n" );
    fprintf( stderr, "           -m specifies to create a mount point link\n" );
    fprintf( stderr, "              instead of a symbolic link\n\n" );
    fprintf( stderr, "           fileName\n" );
    fprintf( stderr, "              This is the name of the symbolic link\n" );
    fprintf( stderr, "               to be created, modified or queried.\n" );
    fprintf( stderr, "               \n" );
    fprintf( stderr, "           targetPath\n" );
    fprintf( stderr, "              If not specified, this program displays\n" );
    fprintf( stderr, "              the current targetPath associated with \n" );
    fprintf( stderr, "              the named symbolic link.\n" );
    fprintf( stderr, "              If specified, either creates a new symbolic\n" );
    fprintf( stderr, "              link that points to this targetPath\n" );
    fprintf( stderr, "              or if the named symbolic link already exists,\n" );
    fprintf( stderr, "              modifies its targetPath to the new value.\n" );
    ExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sync\sync.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sync.c

Abstract:

    This is the main module for the Win32 sync command.

Author:

    Mark Lucovsky (markl) 28-Jan-1991

Revision History:

--*/

#include "sync.h"


int
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    BOOLEAN fEject;
    char *p;
    int i;
    char c;
    char DrivePath[ 4 ];

    if (argc > 1 &&
        (!_stricmp( argv[1], "-e" ) || !_stricmp( argv[1], "/e" ))
       ) {
        argc -= 1;
        argv += 1;
        fEject = TRUE;
        }
    else {
        fEject = FALSE;
        }

    if ( argc > 1 ) {
        while (--argc) {
            p = *++argv;
            if ( isalpha(*p) ) {
                sprintf( DrivePath, "%c:", *p );
                SyncVolume( DrivePath, fEject );
                }
            }
        }
    else {
        for(i=0;i<26;i++){
            c = (CHAR)i + (CHAR)'a';
            sprintf( DrivePath, "%c:", i+'A' );
            switch (GetDriveType( DrivePath )) {
            case DRIVE_REMOVABLE:
                if (i <2) {
                    break;
                    }

            case DRIVE_FIXED:
                SyncVolume( DrivePath, fEject );
                break;
            }
        }
    }

    return( 0 );
}

void
SyncVolume(
    PCHAR DrivePath,
    BOOLEAN EjectMedia
    )
{
    UCHAR VolumePath[16];
    HANDLE VolumeHandle;
    DWORD ReturnedByteCount;


    _strupr( DrivePath );
    sprintf( VolumePath, "\\\\.\\%s", DrivePath );
    VolumeHandle = CreateFile( VolumePath,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL
                             );
    if (VolumeHandle == INVALID_HANDLE_VALUE ) {
        fprintf( stderr, "SYNC: Unable to open %s volume (%u)\n", DrivePath, GetLastError() );
        return;
        }

    printf( "Syncing %s ... ", DrivePath );
    if (!FlushFileBuffers( VolumeHandle )) {
        printf( "flush failed (%u)\n", GetLastError() );
        }
    else
    if (!DeviceIoControl( VolumeHandle,
                          FSCTL_LOCK_VOLUME,
                          NULL,
                          0,
                          NULL,
                          0,
                          &ReturnedByteCount,
                          NULL
                        )
       ) {
        printf( "lock volume failed (%u)\n", GetLastError() );
        }
    else
    if (!DeviceIoControl( VolumeHandle,
                          FSCTL_DISMOUNT_VOLUME,
                          NULL,
                          0,
                          NULL,
                          0,
                          &ReturnedByteCount,
                          NULL
                        )
       ) {
        printf( "dismount volume failed (%u)\n", GetLastError() );
        }
    else
    if (EjectMedia && !DeviceIoControl( VolumeHandle,
                                        IOCTL_DISK_EJECT_MEDIA,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        &ReturnedByteCount,
                                        NULL
                                      )
       ) {
        printf( "eject media failed (%u)\n", GetLastError() );
        }
    else {
        printf( "done.  Okay to remove drive.\n" );
        }

    CloseHandle( VolumeHandle );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sync\sync.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    winnt.h

Abstract:

    This is the main header file for the Win32 sync command.

Author:

    Mark Lucovsky (markl) 28-Jan-1991

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>


int
ProcessParameters(
    int argc,
    char *argv[]
    );

void
SyncVolume( PCHAR DrivePath, BOOLEAN EjectMedia );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sysparse\cmdline.cpp ===
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "cmdline.h"

kCommandLine::kCommandLine()
{
    pArgListBegin = (ARGUMENTS *)malloc(sizeof(ARGUMENTS));
    
    if(pArgListBegin) {	
    	pArgListBegin->pNext = NULL;
    	pArgListBegin->szArg = NULL;
    	pArgListBegin->sArgumentNumber = 0;
    	pArgListBegin->pPrevious = NULL;
    	pArgListCurrent = pArgListBegin;
	
        sNumberOfDrives = 0;
        szCommandLine = (char *)malloc((lstrlen(GetCommandLine()) + sizeof(TCHAR)));
    
        if(szCommandLine) {
    	    lstrcpy(szCommandLine, (char *)GetCommandLine());
    	
            if (sNumberOfArgs = GetNumberOfArguments()) {
                WORD wArgNums = 0;   
                wArgNums = FillArgumentList();
            }
        }
    }
}

kCommandLine::~kCommandLine()
{
    if(szCommandLine)
    	free (szCommandLine);
    Rewind();
    if(pArgListCurrent->szArg)
    	free (pArgListCurrent->szArg);
    while (GetNext())
    {
        if(pArgListCurrent->pPrevious)
        	free (pArgListCurrent->pPrevious);  
        if(pArgListCurrent->szArg)
        	free (pArgListCurrent->szArg);
    }
    if(pArgListCurrent)
    	free (pArgListCurrent);
}

void kCommandLine::DebugOutf(char *szFormat, ...)
{
    char szBuffer[MAX_PATH * 4];
    va_list va;
    va_start (va,szFormat);
    vsprintf (szBuffer, szFormat, va);
    va_end (va);
#ifdef DEBUG
    OutputDebugString (szBuffer);
#endif
}

WORD kCommandLine::GetNumberOfArguments()
{
    WORD wSpaceCounter = 0;
    for (WORD wCounter = 4; szCommandLine[wCounter] !=NULL; wCounter++)
        if ( ((szCommandLine[wCounter]=='/') || (szCommandLine[wCounter]=='-')) && szCommandLine[wCounter+1]!=NULL)
            wSpaceCounter++;
    return wSpaceCounter;
}

WORD kCommandLine::FillArgumentList()
{
    WORD wCounter;
    WORD TKCounter;
    WORD wArgNumCounter = 0;
    char szHolder[MAX_PATH * 2];
    szHolder[0] = NULL;
    wCounter = 4;

    for (Rewind(); szCommandLine[wCounter] != NULL; wCounter++)
    {
        if(szCommandLine[wCounter] == '/')
        {
            {
            WORD TempwCounter;
            WORD TempHolderCounter;
            TCHAR TempHolder[MAX_PATH];
            TempHolderCounter = 0;
            TempwCounter=wCounter;
            while ( (szCommandLine[TempwCounter] != ' ') && (szCommandLine[TempwCounter] != NULL) )
            {
                TempHolder[TempHolderCounter] = szCommandLine[TempwCounter];
                TempHolderCounter++;
                TempwCounter++;
            }
            TempHolder[TempHolderCounter] = '\0';
            if (' ' == TempHolder[strlen(TempHolder) - 1])
            {
                TempHolder[strlen(TempHolder)-1] = '\0';
            }
            Add(TempHolder);
            wCounter = TempwCounter;
            }

            while ( (szCommandLine[wCounter] != NULL) && (szCommandLine[wCounter] != ' ') )
            {
                wCounter++;
            }
            wCounter++;
            wArgNumCounter++;
            WORD wTK=0;
            for (TKCounter = 0; TKCounter < 256; TKCounter++)
            {
                szHolder[TKCounter] = '\0';
            }
            while ( (szCommandLine[wCounter] != '/') && (szCommandLine[wCounter] != NULL) )
            {
                szHolder[wTK] = szCommandLine[wCounter];
                wCounter++;
                wTK++;
            }
            if (szHolder[wTK] == ' ')
            {
                szHolder[wTK-1] = NULL;
            }
            if (' ' == szHolder[strlen(szHolder) - 1])
            {
                szHolder[strlen(szHolder)-1] = '\0';
            }
            Add(szHolder);
            wCounter--;
        }
    }//end of for loop
#ifdef _DEBUG
    DebugOutf("FillArgumentList=%d\r\n",wArgNumCounter);
#endif
    return wArgNumCounter;
}

void kCommandLine::Rewind()
{
    pArgListCurrent=pArgListBegin;
}

void kCommandLine::Add(char *szArgpass)
{

    //MessageBox(GetFocus(), szArgpass, "Add", MB_OK);

    FindLast();
    if (pArgListCurrent != pArgListBegin)
    {
        pArgListCurrent->pNext = (ARGUMENTS *)malloc(sizeof ARGUMENTS);
        if(!pArgListCurrent->pNext)
        	return;
        pArgListCurrent->pNext->pPrevious = pArgListCurrent;
        pArgListCurrent = pArgListCurrent->pNext;
        pArgListCurrent->szArg = (char *)malloc(strlen(szArgpass) + 1);
        if(!pArgListCurrent->szArg)
        	return;
        strcpy(pArgListCurrent->szArg, szArgpass);
        pArgListCurrent->pNext = NULL;
        pArgListCurrent->sArgumentNumber = pArgListCurrent->pPrevious->sArgumentNumber + 1;
    }
    else if (pArgListCurrent==pArgListBegin && !pArgListCurrent->szArg)
    {
        pArgListCurrent->szArg = (char *)malloc(strlen(szArgpass)+1);
        if(!pArgListCurrent->szArg)
        	return;
        strcpy(pArgListCurrent->szArg, szArgpass);
        pArgListCurrent->pNext = NULL;
        pArgListCurrent->sArgumentNumber = 1;
        pArgListCurrent->pPrevious = NULL;
    }
    else if (pArgListCurrent == pArgListBegin && pArgListCurrent->szArg)
    {
        pArgListCurrent->pNext = (ARGUMENTS *)malloc(sizeof ARGUMENTS);
        if(!pArgListCurrent->pNext)
        	return;
        pArgListCurrent->pNext->pPrevious = pArgListCurrent;
        pArgListCurrent = pArgListCurrent->pNext;
        pArgListCurrent->szArg = (char *)malloc(strlen(szArgpass)+1);
        if(!pArgListCurrent->szArg)
        	return;
        strcpy(pArgListCurrent->szArg, szArgpass);
        pArgListCurrent->pNext = NULL;
        pArgListCurrent->sArgumentNumber = 2;
    }
#ifdef _DEBUG
    DebugOutf("Arg[%d]=|%s|",pArgListCurrent->sArgumentNumber, pArgListCurrent->szArg);
    DebugOutf(" ArgPass=|%s|\r\n",szArgpass);
#endif
}

void kCommandLine::FindLast()
{
    for(Rewind(); pArgListCurrent->pNext; pArgListCurrent=pArgListCurrent->pNext);
}

WORD kCommandLine::GetArgumentNumber(TCHAR *Argument, BOOL CaseInsensitive)
{
    TCHAR Temp[MAX_PATH * 4];
   
    if (!Argument) 
        return 0;
    Rewind();
    if (CaseInsensitive)
    {
        _strlwr (Argument);
    }
    while (pArgListCurrent)
    {
        if (pArgListCurrent->szArg)
        {
            lstrcpy(Temp, pArgListCurrent->szArg);
            _strlwr(Temp);
            if (!lstrcmp(Temp, Argument))
            {
                return pArgListCurrent->sArgumentNumber;
            }
        }
        pArgListCurrent=pArgListCurrent->pNext;
    }
    return 0;
}

char *kCommandLine::GetNextArgument()
{
    if (pArgListCurrent->pNext)
    {
        pArgListCurrent = pArgListCurrent->pNext;
        return pArgListCurrent->szArg;
    }
    else 
        return NULL;
}

char *kCommandLine::GetSwitchValue(char *szArgpass, BOOL bCaseInsensitive)
{
    Rewind();
    if (bCaseInsensitive)
        _strlwr(szArgpass);
    if (pArgListCurrent->szArg)
    {
        if (!strcmp(szArgpass, pArgListCurrent->szArg) && pArgListCurrent->pNext)
        {
            return pArgListCurrent->pNext->szArg;
        }
        while (GetNext())
        {
            if (!strcmp(szArgpass, pArgListCurrent->szArg) && pArgListCurrent->pNext)
                return pArgListCurrent->pNext->szArg;
        }
    }
    //fallthrough
    return NULL;
}

char *kCommandLine::GetArgumentByNumber(WORD wNumber)
{
    Rewind();
    if (pArgListCurrent->szArg)
    {
        if (pArgListCurrent->sArgumentNumber == wNumber)
        {
            return pArgListCurrent->szArg;
        }
        while (GetNext())
        {
            if (pArgListCurrent->sArgumentNumber == wNumber)
            {
                return pArgListCurrent->szArg;
            }
        }
    }
    //fallthrough
    return NULL;
}

BOOL kCommandLine::IsSpecified(char *szArgpass, BOOL bCaseInsensitive)
{
    char szTemp[MAX_PATH * 4];
    Rewind();
    if (bCaseInsensitive)
        _strlwr(szArgpass);
    if (pArgListCurrent->szArg)
    {
        strcpy(szTemp, pArgListCurrent->szArg);
        if (bCaseInsensitive)
            _strlwr(szTemp);
        //MessageBox(GetFocus(), szArgpass, szTemp, MB_OK);
        if (!strcmp(szArgpass, szTemp))
            return TRUE;
        while (GetNext()) 
        {
            strcpy(szTemp, pArgListCurrent->szArg);
            if (bCaseInsensitive)
                _strlwr(szTemp);
            //MessageBox(GetFocus(), szArgpass, szTemp, MB_OK);
            if (!strcmp(szArgpass, szTemp))
                return TRUE;
        }
    }
    //fallthrough
    return FALSE;
}

ARGUMENTS *kCommandLine::GetNext()
{
    if (pArgListCurrent->pNext)
        pArgListCurrent = pArgListCurrent->pNext;
    else
        return NULL;
    return pArgListCurrent;
}

ARGUMENTS *kCommandLine::GetPrevious()
{
    if (pArgListCurrent->pPrevious)
        pArgListCurrent = pArgListCurrent->pPrevious;
    else
        return NULL;
    return pArgListCurrent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sysparse\cmdline.h ===
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

struct ARGUMENTS
{
   char *szArg;
   short sArgumentNumber;
   ARGUMENTS *pNext;
   ARGUMENTS *pPrevious;
};

class kCommandLine
{
private:
    short sNumberOfArgs;
    short sNumberOfDrives;
    ARGUMENTS *pArgListBegin;
    ARGUMENTS *pArgListCurrent;
    void Add(char *wszArgpass);
    void Remove(ARGUMENTS *);
    void FindLast();
    WORD FillArgumentList();
    void DebugOutf(char *szFormat, ...);
    ARGUMENTS *GetNext();
    ARGUMENTS *GetPrevious();

public:
    char *szCommandLine;
    char *GetNextArgument();
    void Rewind();
    char *GetSwitchValue(char *, BOOL bCaseInsensitive);
    BOOL IsSpecified(char *, BOOL bCaseInsensitive);
    char *GetArgumentByNumber(WORD wArgNum);
    WORD GetArgumentNumber(TCHAR *Argument, BOOL CaseInsensitive);
    WORD GetNumberOfArguments();
    kCommandLine();
    ~kCommandLine();
      
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sysparse\devwalk.cpp ===
#include "globals.h"

kWin9xDevWalk::kWin9xDevWalk(kLogFile *Proc)
{
    LogProc=Proc;
}

kWin9xDevWalk::~kWin9xDevWalk()
{
}

int kWin9xDevWalk::Go()
{
    if(!LoadResourceFile ("c:\\syspar16.exe", "EXEResource1" ))
        return FALSE;

    _spawnl (_P_WAIT, "c:\\syspar16.exe", "c:\\syspar16.exe", "_spawnl", "two", NULL);
    AppendToLogFile("c:\\sp16temp.tmz");

    DeleteFile ("c:\\sp16temp.tmz");
    DeleteFile ("c:\\syspar16.exe");
    return TRUE;
}

BOOL kWin9xDevWalk::LoadResourceFile(PSTR FilePath,PSTR ResName)
{
    HGLOBAL hObj;
    HRSRC hResource;
    LPSTR lpStr;
    DWORD dwSize = 0;
    DWORD dwBytesWritten = 0;
    char ErrorString[MAX_PATH * 4];
    
    if ( !(hResource = FindResource(NULL, ResName, RT_RCDATA)) ) 
        return FALSE; 
        
    if ( !(hObj = LoadResource(NULL,hResource)) ) 
        return FALSE;
            
    if ( !(lpStr = (LPSTR)LockResource(hObj)) ) 
        return FALSE;
        
    if ( !(dwSize = SizeofResource( NULL, hResource)))
    {
        UnlockResource(hObj);
        return FALSE;
    }
                
    HANDLE hfFile = CreateFile(FilePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfFile == INVALID_HANDLE_VALUE)
    {
        UnlockResource(hObj);
        return FALSE;
   }
                
   if (!WriteFile(hfFile, lpStr, dwSize, &dwBytesWritten, NULL))
    {
        UnlockResource(hObj);
        CloseHandle(hfFile);
        return FALSE;
    }
                
    UnlockResource(hObj);
    CloseHandle(hfFile);
    return TRUE;
}

kNT5DevWalk::kNT5DevWalk(kLogFile *Proc)
{
LogProc=Proc;
}

kNT5DevWalk::~kNT5DevWalk()
{
}

int kNT5DevWalk::Go()
{
    if(!LoadResourceFile("c:\\syspar32.exe", "EXEResource2" ))
        return FALSE;
    
    _spawnl(_P_WAIT, "c:\\syspar32.exe", "c:\\syspar32.exe", "_spawnl", "two", NULL);
    AppendToLogFile("c:\\sp32temp.tmz");
    DeleteFile("c:\\sp32temp.tmz");
    DeleteFile("c:\\syspar32.exe");
    return TRUE;
}

BOOL kNT5DevWalk::LoadResourceFile(PSTR FilePath,PSTR ResName)
{
    HGLOBAL hObj;
    HRSRC hResource;
    LPSTR lpStr;
    DWORD dwSize = 0;
    DWORD dwBytesWritten = 0;
    char ErrorString[MAX_PATH * 4];
    
    if ( !(hResource = FindResource(NULL, ResName, RT_RCDATA)) ) 
        return FALSE; 
        
    if ( !(hObj = LoadResource(NULL,hResource)) ) 
        return FALSE;
            
    if ( !(lpStr = (LPSTR)LockResource(hObj)) ) 
        return FALSE;
        
    if ( !(dwSize = SizeofResource( NULL, hResource)))
    {
        UnlockResource(hObj);
        return FALSE;
    }
                
    HANDLE hfFile = CreateFile(FilePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfFile == INVALID_HANDLE_VALUE)
    {
        UnlockResource(hObj);
        return FALSE;
   }
                
   if (!WriteFile(hfFile, lpStr, dwSize, &dwBytesWritten, NULL))
    {
        UnlockResource(hObj);
        CloseHandle(hfFile);
        return FALSE;
    }
                
    UnlockResource(hObj);
    CloseHandle(hfFile);
    return TRUE;
}

void kNT5DevWalk::AppendToLogFile(PTCHAR szFile)
{
    FILE *fFile     = NULL;
    FILE *fOutFile  = NULL;
    PTCHAR szString = NULL;
    
    if( !(fFile = fopen(szFile, "r")))
        return;
        
    if( !(fOutFile = fopen(LogProc->szFile, "a+")))
    {
        fclose(fFile);
        return;
    }
    
    if( !(szString = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 11000)))
    {
        fclose(fFile);
        fclose(fOutFile);
        return;
    }
    
    int iHold;
    
    iHold = fgetc(fFile);
    
    while (EOF != iHold)
    {
        fputc(iHold, fOutFile);
        iHold = fgetc(fFile);
    }

    fclose(fFile);
    fclose(fOutFile);
    HeapFree(GetProcessHeap(), 0, szString);
}

void kWin9xDevWalk::AppendToLogFile(PTCHAR szFile)
{
    FILE *fFile     = NULL;
    FILE *fOutFile  = NULL;
    PTCHAR szString = NULL;
    
    if( !(fFile = fopen(szFile, "r")))
        return;
        
    if( !(fOutFile = fopen(LogProc->szFile, "a+")))
    {
        fclose(fFile);
        return;
    }
    
    if( !(szString = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 11000)))
    {
        fclose(fFile);
        fclose(fOutFile);
        return;
    }
    
    int iHold;
    
    iHold = fgetc(fFile);
    
    while (EOF != iHold)
    {
        fputc(iHold, fOutFile);
        iHold = fgetc(fFile);
    }

    fclose(fFile);
    fclose(fOutFile);
    HeapFree(GetProcessHeap(), 0, szString);
}

//DWORD WalkLogConfForResources(

/*
DWORD EnumerateClasses(ULONG ulIndex)
{
GUID *pClassID=(GUID*)malloc(sizeof(GUID));
char szBuf[500];
ULONG ulSize=499;
DWORD dwRet=0;

dwRet=CM_Enumerate_Classes(ulIndex, pClassID, 0);
CM_Get_Class_Name(pClassID, szBuf, &ulSize, 0);
//printf("CLASS = %s\r\n", szBuf);
GetClassDevs(szBuf);
return dwRet;
}

DWORD GetClassDevs(CHAR *szClassName)
{
HDEVINFO hDevInfo;
LPGUID pguid;
DWORD dwSize=0;
SetupDiClassGuidsFromName(szClassName, pguid, 100, &dwSize);
//SetupDiBuildClassInfoList(NULL, pguid, 1, &dwSize);
//hDevInfo = SetupDiGetClassDevs(szClassName, NULL, NULL, DIGCF_ALLCLASSES);
printf("Need %d more GUIDs for class %s \r\n", dwSize, szClassName);
hDevInfo = SetupDiGetClassDevs(pguid, NULL, NULL, NULL);
printf("hDevInfo=%d\r\n",hDevInfo);
printf("GUid? %c%c%c%c%c%c%c\r\n", pguid->Data4[0],
   pguid->Data4[1], 
   pguid->Data4[2], 
   pguid->Data4[3], 
   pguid->Data4[4], 
   pguid->Data4[5], 
   pguid->Data4[6],  
   pguid->Data4[7]);
return TRUE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sysparse\globals.h ===
#ifndef GLOBALS_H
#define GLOBALS_H

//Use alpha to build axp version.  can use w/ internal or sb flags.  
//use sb or internal to build those specific versions.  Default is external.
//#define INTERNAL
//#define SB
//#define ALPHA
#define NOCHKUPGRD

#include <windows.h>
#include <dbt.h>
#include <stdlib.h>
#include <stdio.h>
#include <process.h>
#include "cfgmgr32.h"
#include <objbase.h>
#include <objidl.h>
#include <shlobj.h>
#include <setupapi.h>
#include <tchar.h>
//#include <e:\root\dev\inc16\setupx.h>

//#define BRYANPARSE

//#define NOCREDE
//#define LOWORD(l)   ((WORD) (l)) 

#define ENUM_SUCCESS            0
#define ENUM_SIBLINGFAILURE     1
#define ENUM_CHILDFAILURE       2
#define ENUM_POSTFAILURE        3
#define ENUM_GENFAILURE         4

#define PLATFORM_9X 0
#define PLATFORM_NT4 1
#define PLATFORM_NT5 2

#define REG_SUCCESS TRUE
#define REG_FAILURE FALSE

#define SYSP_MAX_STR_LEN 1024

//#define szLogFile "c:\\windows\\desktop\\logger.csv"

BOOL LogString(char *szFile, char *szString, ...);
void DebugOutf(char *szFormat, ...);
int EnumerateDevices(DEVNODE dnDevNodeTraverse, int j, DEVNODE dnParentNode);
DWORD EnumerateClasses(ULONG ulIndex);
HRESULT ResolveIt(HWND hwnd, LPCSTR lpszLinkFile, LPSTR lpszPath);

DWORD GetClassDevs(CHAR *szClassName);
extern BOOL g_WalkStartMenu;
//BOOL WalkStartMenu;
//TCHAR g_WindowsDirectory[];

//HWND g_MainWindow;


class kLogFile
{
public:
   BOOL LogString(TCHAR *szString, ...);
   BOOL InitFile(TCHAR *szTempFile, TCHAR* szTempDir);
   kLogFile();
   ~kLogFile();
   TCHAR *szFile;
   BOOL StripCommas(TCHAR *szString);
   void ValidateString(PTCHAR pString, int dwLen);
   TCHAR *szLogDir;
private:
};

class kWin9xDevWalk
{
public:
   int Go();
   kLogFile *LogProc;
   kWin9xDevWalk(kLogFile *Proc);
   BOOL LoadResourceFile(PSTR FilePath,PSTR ResName);
   void AppendToLogFile(PTCHAR szFile);
   ~kWin9xDevWalk();
private:
};

class kNT5DevWalk
{
public:
   int Go();
   kLogFile *LogProc;
   kNT5DevWalk(kLogFile *Proc);
   BOOL LoadResourceFile(PSTR FilePath,PSTR ResName);
   void AppendToLogFile(PTCHAR szFile);
   ~kNT5DevWalk();
private:
};

/*
class kWin9xAppWalk
{
public:
   WORD wStartMenuLen;
   DWORD dwCurrentKey;
   HKEY hkeyRoot;
   BOOL bRegStat;
   char szRootKeyString[1024]; 
   BOOL Begin(WORD dwPlatform);
   BOOL NextKey(WORD wPlatform);
   BOOL Walk(WORD wPlatform);
   BOOL GetUninstallValues(WORD wPlatform, char* szName);
   kWin9xAppWalk(kLogFile *Proc, HWND hIn);
   kLogFile *LogProc;
   HWND hMainWnd;
   BOOL WalkDir(char *szTempPath, char *szFile);
   BOOL WalkStartMenu();
   HRESULT ResolveIt(LPCSTR lpszLinkFile, LPSTR lpszPath);
   BOOL EndsInLnk(char *szFile);
   void GetAppVer(LPSTR pszAppName);
private:
};
*/

class kNT5AppWalk
{
public:
   WORD wStartMenuLen;
   DWORD dwCurrentKey;
   HKEY hkeyRoot;
   BOOL bRegStat;
   char szRootKeyString[1024]; 
   BOOL Begin();
   BOOL NextKey();
   BOOL Walk();
   BOOL GetUninstallValues(char* szName);
   kNT5AppWalk(kLogFile *Proc, HWND hIn);
   kLogFile *LogProc;
   HWND hMainWnd;
   BOOL WalkDir(char *szTempPath, char *szFile);
   BOOL WalkStartMenu();
   HRESULT ResolveIt(LPCSTR lpszLinkFile, LPSTR lpszPath);
   BOOL EndsInLnk(char *szFile);
   void GetAppVer(LPSTR pszAppName);

//   BOOL GetNetStrings();
private:
};

class kNT5NetWalk
{
public:
   WORD wStartMenuLen;
   DWORD dwCurrentKey;
   DWORD dwLevel2Key;
   HKEY hkeyRoot;
   char szRootKeyString[1024]; 
   kLogFile *LogProc;
   HWND hMainWnd;

   kNT5NetWalk(kLogFile *Proc, HWND hIn);
   BOOL Begin();
   BOOL Walk();
   BOOL SearchSubKeys(char *szName);
   BOOL GetKeyValues(char* szName);
private:
};

class kNT4DevWalk
{
public:
   WORD wStartMenuLen;
   DWORD dwCurrentKey;
   DWORD dwLevel2Key;
   HKEY hkeyRoot;
   char szRootKeyString[1024]; 
   kLogFile *LogProc;
   HWND hMainWnd;

   kNT4DevWalk(kLogFile *Proc, HWND hIn);
   BOOL Begin();
   BOOL Walk();
   BOOL SearchSubKeys(char *szName);
   BOOL GetKeyValues(char* szName);
private:
};

typedef UINT (CALLBACK* LPFNDLLFUNC1)(LPCTSTR,PULARGE_INTEGER,PULARGE_INTEGER,PULARGE_INTEGER);
typedef UINT (CALLBACK* LPFNDLLFUNC2)(LPTSTR, UINT);

class CLASS_GeneralAppWalk
{
public:
        BOOL OpenRegistry(void);
        BOOL GetUninstallValues(TCHAR *KeyName);
        BOOL NextKey(void);
        BOOL Walk(void);
        CLASS_GeneralAppWalk(kLogFile *LogProc, HWND hIn);
        BOOL WalkStartMenu(void);
        BOOL WalkDir(TCHAR *TempPath, TCHAR *File);
        BOOL EndsInLnk(TCHAR *File);
        HRESULT ResolveIt(LPCSTR LinkFile, LPSTR Path);
        BOOL GetAppVer(LPSTR AppName);
        BOOL GetCurrentWinDir(void);
        TCHAR g_WindowsDirectory[MAX_PATH];

private:
        HKEY HandleToUninstallKeyRoot;
        kLogFile *LogProc;
        HWND gHandleToMainWindow;
        DWORD CurrentKey;
        TCHAR RootKeyString[1024];
        WORD StartMenuLen;

};

typedef enum {
        Win95,
        Win98,
        NT4,
        Win2000,
        Whistler,
        Unknown
        } ENUM_OS_VERSION;



class CLASS_GeneralInfo
{
public:
        CLASS_GeneralInfo(kLogFile *LogProc, HWND hIn);
        void GetCurrentWindowsDirectory(void);
        void DetermineOS(void);
        BOOL InitLogFile(void);
        BOOL FillInArguments(void);
        BOOL DetermineArgumentValidity(void);
        void WriteVersions(void);
        void DetermineCommandLine(void);
        BOOL CopyInput(void);
        void GetUUID(void);
        void WriteArguments(void);
        void WriteFreeDiskSpace(void);
        void WriteVolumeType(void);
        void WriteMemorySize(void);
        void WriteOSVersion(void);

/*
        WriteDevices
        WriteApps
*/
        void InitHelpers(void);
        void AbuseOtherApps(void);
        BOOL Go(void);
        void ChangeSpaces(TCHAR *Input);
        BOOL ReadInFileInfo(TCHAR *FileName);
        void WriteGeneralInfo(void);
        BOOL AutoRun;
        BOOL RunMinimized;


private:
        HWND gHandleToMainWindow;
        kLogFile *LogProc;
        TCHAR WindowsDirectory[MAX_PATH]; //no trailing "\"
        ENUM_OS_VERSION OSVersion;
        TCHAR Corporation[1024];
        TCHAR Email[1024];
        TCHAR Manufacturer[1024];
        TCHAR Model[1024];
        TCHAR NumComp[1024];
        TCHAR SiteID[1024];
        WORD SiteIDIndex;
        TCHAR Profile[1024];
        TCHAR BetaID[1024];
        TCHAR MachineType[1024];
        WORD MachineTypeIndex;
        TCHAR OriginalMachineUUID[1024];
        TCHAR szRegFile[1024];
        TCHAR PlatformExtension[12];
        BOOL RunChkupgrd;
        BOOL RunDevdump;
        void CatLogFile(TCHAR *szFile);
        BOOL LoadResourceFile(PSTR FilePath,PSTR ResName);
        BOOL OverWrite;
        BOOL UseComputerName;

};


#endif //GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sysparse\logger.cpp ===
//logger.cpp

#include "globals.h"

BOOL kLogFile::StripCommas(PTCHAR szString)
{
    for (int i = 0; i <= (int)lstrlen(szString); i++)
    {
        if (szString[i] == ',')
            szString[i] = ' ';  //Replace comma with a space to make SQL friendly string
    }
    return TRUE;
}

BOOL kLogFile::LogString(PTCHAR szString, ...)
{
    HANDLE hFile;
    DWORD dwRet = 0;
    DWORD dwBytesWrit;
    PTCHAR szBuffer = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * 4);

    if(!szBuffer)
        return FALSE;
        
    va_list va;
    va_start(va,szString);
    vsprintf(szBuffer, szString, va);
    va_end(va);

    hFile = CreateFile(szFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (hFile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hFile, 0, NULL, FILE_END);
        
        if(!WriteFile(hFile, szBuffer, lstrlen(szBuffer), &dwBytesWrit, NULL))
        {
            CloseHandle(hFile);
            HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szBuffer);
            return FALSE;
        }
        
        if ((DWORD)lstrlen(szBuffer) != dwBytesWrit)
            LogString(",ERROR: String lengths differ,\r\n");
    }
    else
    {
        HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szBuffer);
        CloseHandle(hFile);  
        return FALSE;
    }
    
    CloseHandle(hFile);
    HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szBuffer);     
    return TRUE;
}

kLogFile::InitFile(PTCHAR szTempFile, PTCHAR szTempDir)
{
    if (!szTempFile || !szTempDir)
        return FALSE;
        
    if ((lstrlen(szTempFile) <= 0) || (lstrlen(szTempDir) <= 0))
        return FALSE;
        
    szFile = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (lstrlen(szTempFile) + 1) * sizeof(TCHAR));
        
    if(!szFile)
        return FALSE;
            
    szLogDir = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (lstrlen(szTempDir) + 1) * sizeof(TCHAR));
        
    if(!szLogDir)
    {
        free(szFile);
        return FALSE;
    }   
    
    lstrcpy(szFile, szTempFile);
    lstrcpy(szLogDir, szTempDir);
    return TRUE;
}

kLogFile::kLogFile()
{
    szFile = NULL;
    szLogDir = NULL;
}

kLogFile::~kLogFile()
{
    if(szFile)
	    HeapFree (GetProcessHeap(), HEAP_ZERO_MEMORY, szFile);
	if(szLogDir)
	    HeapFree (GetProcessHeap(), HEAP_ZERO_MEMORY, szLogDir);
	    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sysparse\nt4dev.cpp ===
#include "globals.h"

kNT4DevWalk::kNT4DevWalk(kLogFile *Proc, HWND hIn)
{
LogProc=Proc;
hMainWnd=hIn;
}

BOOL kNT4DevWalk::Begin()
{
    DWORD dwRet = 0;
    dwCurrentKey = 0;
    dwLevel2Key = 0;
    lstrcpy(szRootKeyString, "SYSTEM\\CurrentControlSet\\Enum\\Root");

    if (ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, szRootKeyString, 0, KEY_READ, &hkeyRoot))
        return REG_SUCCESS;
    else 
        return REG_FAILURE;
        
    return REG_FAILURE;
}

BOOL kNT4DevWalk::Walk()
{
    DWORD dwIndex = 0;
    PTCHAR pName = NULL, pFull = NULL;
    DWORD dwSizeName = MAX_PATH * 4;
    
    pName = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSizeName);
    
    if(!pName)
        return FALSE;
        
    pFull = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSizeName);

    if(!pFull) {
        HeapFree(GetProcessHeap(), NULL, pName);
        return FALSE;
    }
    
    while (ERROR_SUCCESS == RegEnumKeyEx(hkeyRoot, dwIndex, pName, &dwSizeName, NULL, NULL, NULL, NULL)) {
        wsprintf(pFull, "SYSTEM\\CurrentControlSet\\Enum\\Root\\%s", pName);
            
        if (!lstrcmp(pName, "Control")) {
            GetKeyValues(pFull);
        }
            
        SearchSubKeys(pFull);
        dwSizeName = MAX_PATH * 4;
        dwIndex++;
    }
    
    HeapFree(GetProcessHeap(), NULL, pName);
    HeapFree(GetProcessHeap(), NULL, pFull);
    return TRUE;
}

BOOL kNT4DevWalk::SearchSubKeys(PTCHAR szName)
{
    HKEY hKeyTemp;
    DWORD dwIndex = 0;
    PTCHAR szName2 = NULL;
    DWORD dwSizeName = MAX_PATH * 4;
    
    szName2 = (PTCHAR)malloc(MAX_PATH * 4);
    
    if(!szName2)
        return FALSE;
        
    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, szName, 0, KEY_READ, &hKeyTemp))
    {
        free(szName2);
        return FALSE;
    }
    
    while (ERROR_SUCCESS == RegEnumKeyEx(hKeyTemp, dwIndex, szName2, &dwSizeName, NULL, NULL, NULL, NULL))
    {
        TCHAR szFull[MAX_PATH * 4];
        wsprintf(szFull, "%s\\%s", szName, szName2);

        if (ERROR_SUCCESS == lstrcmp(szName2, "Control"))
        {
            GetKeyValues(szName);
            SearchSubKeys(szFull);
            dwSizeName = MAX_PATH * 4;
            dwIndex++;
        }
    }
    free(szName2);
    return TRUE;
}

BOOL kNT4DevWalk::GetKeyValues(PTCHAR szName)
{
    HKEY hkeyUninstallKey;
    TCHAR szFullKey[MAX_PATH * 4];
    PTCHAR szProductName = NULL;
    DWORD dwProductSize = MAX_PATH * 4;
    DWORD dwType = REG_SZ;
    
    szProductName = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * 4);

    if(!szProductName)
        return FALSE;
        
    wsprintf(szFullKey, "%s\\%s", szRootKeyString, szName);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szName, 0, KEY_READ, &hkeyUninstallKey))
    {
        LogProc->LogString(",%s,", szName);
        szProductName[0] = 0;
        dwProductSize = MAX_PATH * 4;
    
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyUninstallKey, "Class", NULL, &dwType, (PBYTE)szProductName, &dwProductSize)
            && lstrlen(szProductName) != 0)
        {
            LogProc->LogString("%s,", szProductName);
        }         
        else 
        {
            LogProc->LogString("NULL,");
        }

        szProductName[0] = 0;
        dwProductSize = MAX_PATH * 4;

        if (ERROR_SUCCESS == RegQueryValueEx(hkeyUninstallKey, "DeviceDesc", NULL, &dwType, (PBYTE)szProductName, &dwProductSize)
            && lstrlen(szProductName) != 0)
        {
            LogProc->StripCommas(szProductName);
            LogProc->LogString("%s,", szProductName);
        }         
        else 
            LogProc->LogString("NULL,");

        lstrcpy(szProductName, "");
        dwProductSize = MAX_PATH * 4;

        if (ERROR_SUCCESS == RegQueryValueEx(hkeyUninstallKey, "HardWareID", NULL, &dwType, (PBYTE)szProductName, &dwProductSize)
            && lstrlen(szProductName)!=0)
        {
            LogProc->StripCommas(szProductName);
            LogProc->LogString("%s,", szProductName);
        }         
        else 
            LogProc->LogString("NULL,");
        
        szProductName[0] = 0;
        dwProductSize = MAX_PATH * 4;

        if (ERROR_SUCCESS == RegQueryValueEx(hkeyUninstallKey, "Mfg", NULL, &dwType, (PBYTE)szProductName, &dwProductSize)
            && lstrlen(szProductName) != 0)
        {
            LogProc->StripCommas(szProductName);
            LogProc->LogString("%s,", szProductName);
        }         
        else 
            LogProc->LogString("NULL,");
        
        szProductName[0] = 0;
        wsprintf(szFullKey, "%s\\Control", szName);
        HKEY hkTemp;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szFullKey, 0, KEY_READ, &hkTemp))
        {
            dwProductSize = MAX_PATH * 4;

            if (ERROR_SUCCESS == RegQueryValueEx(hkTemp, "ActiveService", NULL, &dwType, (PBYTE)szProductName, &dwProductSize)
                && lstrlen(szProductName) != 0)
            {
                LogProc->StripCommas(szProductName);
                LogProc->LogString("%s,\r\n", szProductName);
            }         
            else
                LogProc->LogString("NULL,\r\n");
            
            szProductName[0] = 0;
            RegCloseKey(hkTemp);
        }
        else 
            LogProc->LogString("NULL,\r\n");
    }
    else 
    {
        HeapFree(GetProcessHeap(), NULL, szProductName);
        return REG_FAILURE;
    }

    HeapFree(GetProcessHeap(), NULL, szProductName);
    RegCloseKey(hkeyUninstallKey);
    return REG_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sysparse\geninfo.cpp ===
#include "globals.h"
#include "cmdline.h"
#include "resource.h"
#include <regstr.h>
TCHAR g_WindowsDirectory[MAX_PATH];
BOOL g_WalkStartMenu;
#define NOT_CASE_SENSITIVE TRUE
#define CASE_SENSITIVE FALSE
typedef struct MYTIMESTRUCT
{
	TCHAR szMonth[10];
	TCHAR szDay[10];
	TCHAR szYear[10];
	TCHAR szHour[10];
	TCHAR szMinute[10];
	TCHAR szSecond[10];
	TCHAR szMillisecond[10];
}MyTimeStruct;

PTCHAR GetUniqueFileName( void );
void FillMyTime(MYTIMESTRUCT *MyTime);

BOOL CLASS_GeneralInfo::Go(void)
{
   BOOL ReturnValue;
   HWND HandleToStatic;
   TCHAR Status[MAX_PATH * 4];
   CLASS_GeneralAppWalk AppWalk(LogProc, gHandleToMainWindow);
   kCommandLine CommandLine;
   HandleToStatic = GetDlgItem(gHandleToMainWindow, IDC_STATIC_STATUS);
   wsprintf(Status, TEXT("Sysparse is now collecting information.  During this process, it will not respond to mouse or keyboard commands, and may appear to be hung for up to 15 minutes."));
   if(INVALID_HANDLE_VALUE != HandleToStatic)
      SendMessage(HandleToStatic, WM_SETTEXT, 0, (LPARAM)Status);
   HandleToStatic = GetDlgItem(gHandleToMainWindow, IDC_STATIC_HELP);
   wsprintf(Status, TEXT(""));
   if(INVALID_HANDLE_VALUE != HandleToStatic)
      SendMessage(HandleToStatic, WM_SETTEXT, 0, (LPARAM)Status);

   ReturnValue = DetermineArgumentValidity();
   if (FALSE == ReturnValue) 
       return FALSE;
   ReturnValue = InitLogFile();
   if (FALSE == ReturnValue) 
       return FALSE;
   //
   // From this point forward we init'd the log file and will always write a section label and a value for each value request,
   // whether that value is a default (usually "Unknown" or "Blank") or the actual value requested.
   //
   
   WriteVersions();
   GetUUID();
   WriteArguments();
   WriteFreeDiskSpace();
   WriteVolumeType();
   WriteMemorySize();
   WriteOSVersion();

      
   switch (OSVersion)
   {
        case Win95:
        {
            TCHAR lWindir[MAX_PATH];
            HANDLE File;
            WIN32_FIND_DATA w32fd;

            GetSystemDirectory(lWindir, MAX_PATH);
            if ( '\\' == lWindir[lstrlen(lWindir)-1] )
            {
                lWindir[lstrlen(lWindir)-1]='\0';
            }
            lstrcat(lWindir, "\\cfgmgr32.dll");
            File = FindFirstFile(lWindir, &w32fd);
            if (INVALID_HANDLE_VALUE != File)
            {
                LogProc->LogString("\r\n,#Syspar32,,\r\n");
                kNT5DevWalk MainNT5DevWalk(LogProc);
                MainNT5DevWalk.Go();
            }
            else
            {
                LogProc->LogString("\r\n,#Syspar16,,\r\n");
                kWin9xDevWalk MainWin9xDevWalk(LogProc);
                MainWin9xDevWalk.Go();
            }
        break;              
        }
        case NT4:
        {
            kNT4DevWalk MainNT4DevWalk(LogProc, gHandleToMainWindow);
            if (MainNT4DevWalk.Begin())
                MainNT4DevWalk.Walk();
        break;
        }
        case Win2000:
        case Whistler:
        {
            LogProc->LogString("\r\n,#Syspar32,,\r\n");
            kNT5DevWalk MainNT5DevWalk(LogProc);
            MainNT5DevWalk.Go();
            kNT5NetWalk MainNT5NetWalk(LogProc, gHandleToMainWindow);
            if (MainNT5NetWalk.Begin()) 
                MainNT5NetWalk.Walk();
        break;
        }
        case Win98:
        {
            LogProc->LogString("\r\n,#Syspar32,,\r\n");
            kNT5DevWalk MainNT5DevWalk(LogProc);
            
            MainNT5DevWalk.Go();
        break;
        }
    }

    WIN32_FIND_DATA *fd2 = (WIN32_FIND_DATA*)malloc(sizeof(WIN32_FIND_DATA));
    WIN32_FIND_DATA *fd3 = (WIN32_FIND_DATA*)malloc(sizeof(WIN32_FIND_DATA));
    if (!fd2)
        return FALSE;
    if(!fd3) {
        free(fd2);
        return FALSE;
    }
       
    FindFirstFile(LogProc->szFile, fd3);
    TCHAR szAr[MAX_PATH * 4];
    TCHAR szLogFilePath[MAX_PATH * 4];
    TCHAR szCurDirectory[MAX_PATH];

	//add specified file name 
	if (CommandLine.IsSpecified(TEXT("/n"),NOT_CASE_SENSITIVE))
		lstrcpy(szAr,CommandLine.GetSwitchValue(TEXT("/n"),NOT_CASE_SENSITIVE));
	else if (CommandLine.IsSpecified(TEXT("/u"),NOT_CASE_SENSITIVE))
        // Whistler - Generate Unique filename (ComputerName+UserName+Time)
		lstrcpy(szAr, GetUniqueFileName());
	else
		lstrcpy(szAr, Profile);
	
	if (!(CommandLine.IsSpecified(TEXT("/x"),NOT_CASE_SENSITIVE)))
		lstrcat(szAr, PlatformExtension);
	
    szAr[8]='\0';

	if(CommandLine.IsSpecified(TEXT("/w"),NOT_CASE_SENSITIVE))
        lstrcpy(szLogFilePath, CommandLine.GetSwitchValue(TEXT("/w"),NOT_CASE_SENSITIVE));
    else
      	lstrcpy(szLogFilePath, WindowsDirectory);

	//	if(GetCurrentDirectory(MAX_PATH, szCurDirectory))
	//		lstrcpy(szArp, szCurDirectory);
			
	if(szLogFilePath[lstrlen(szLogFilePath) - 1] != '\\')
        lstrcat(szLogFilePath, "\\");

   	lstrcat(szLogFilePath, szAr);

    if (CommandLine.IsSpecified(TEXT("/l"),NOT_CASE_SENSITIVE))
		lstrcat(szLogFilePath, ".log");
	else
        lstrcat(szLogFilePath, ".csv");
    
    if(CommandLine.IsSpecified(TEXT("/u"),NOT_CASE_SENSITIVE))
        szLogFilePath[lstrlen(szLogFilePath) - (4 * sizeof(TCHAR))] = '\0';

    if (FindFirstFile(szLogFilePath, fd2) != INVALID_HANDLE_VALUE)
    {
        if ( (lstrlen(fd3->cFileName) > 12) && (NT4 != OSVersion) && (Win2000 != OSVersion) )
        {
            FILE *fGetFile, *fPutFile;
            DWORD dwRet = 0;
            DWORD dwBytesWrit;
            TCHAR szBuffer[50000];
            fGetFile = fopen(szLogFilePath, "r");
            fPutFile = fopen(LogProc->szFile, "a+");
            if (fGetFile && fPutFile)
            {
                while (fgets(szBuffer, 50000, fGetFile))
                {
                    fputs(szBuffer, fPutFile);
                }
                fclose(fPutFile);
                fclose(fGetFile);
            }
            else
            {
                if (fPutFile)
                    fclose(fPutFile);
                if (fGetFile)
                    fclose(fGetFile);
            }
            if (fPutFile)
                fclose(fPutFile);
            if (fGetFile)
                fclose(fGetFile);
            DeleteFile(szLogFilePath);
        }
        if(fd2)
            free(fd2);
        if(fd3)
            free(fd3);
    }

    if (g_WalkStartMenu)
    {
        AppWalk.Walk();
    }
    LogProc->LogString(",#Stop parsing here,,\r\n");

#ifndef NOCHKUPGRD
    if ( (RunChkupgrd) && (!CommandLine.IsSpecified(TEXT("/donotrun1"), TRUE)) )
    {
        TCHAR szUpgr[512];
        lstrcpy(szUpgr, LogProc->szLogDir);
        lstrcat(szUpgr, "\\chkupgrd.exe");
        LoadResourceFile(szUpgr, "EXEResource3" );
        _spawnl(_P_WAIT, szUpgr, szUpgr, "", "", NULL);
        DeleteFile(szUpgr);
        LogProc->LogString("\r\n,#Chkupgrd.log,,\r\n");

        if (Win2000 != OSVersion)
        {
            lstrcpy(szUpgr, LogProc->szLogDir);
            lstrcat(szUpgr, "\\winnt32.log");
            CatLogFile(szUpgr);
            DeleteFile(szUpgr);
            lstrcpy(szUpgr, LogProc->szLogDir);
            lstrcat(szUpgr, "\\config.dmp");
            CatLogFile(szUpgr);
            DeleteFile(szUpgr);
        }
        else
        {
            GetWindowsDirectory(szUpgr, 512);
            if ( '\\' == szUpgr[lstrlen(szUpgr)-1] )
            {
                szUpgr[lstrlen(szUpgr)-1]='\0';
            }
            lstrcat(szUpgr, "\\winnt32.log");
            CatLogFile(szUpgr);
            DeleteFile(szUpgr);
            GetWindowsDirectory(szUpgr, 512);
            if ( '\\' == szUpgr[lstrlen(szUpgr)-1] )
            {
                szUpgr[lstrlen(szUpgr)-1]='\0';
            }
            lstrcat(szUpgr, "\\config.dmp");
            CatLogFile(szUpgr);
            DeleteFile(szUpgr);
        }

        LogProc->LogString("\r\n,#END_Chkupgrd.log,,\r\n");
    }
#endif

#ifndef ALPHA
        if ( (RunDevdump) && (!CommandLine.IsSpecified(TEXT("/donotrun2"),NOT_CASE_SENSITIVE)) && (Win2000==OSVersion))
#else
        if ( ((!RunDevdump) || (CommandLine.IsSpecified(TEXT("/donotrun2"),NOT_CASE_SENSITIVE))) && (Win2000==OSVersion))
#endif
        {
            TCHAR szEx[512];
            TCHAR szUpgr[512];
            lstrcpy(szUpgr, LogProc->szLogDir);
            lstrcat(szUpgr, "\\devdump.exe");
            LoadResourceFile(szUpgr, "EXEResource4" );
            lstrcpy(szEx, szUpgr);
            lstrcat(szUpgr, " ");
            lstrcat(szUpgr, LogProc->szLogDir);
            lstrcat(szUpgr, "\\devdump.log /T");
            _spawnl(_P_WAIT, szEx, szUpgr, "", "", NULL);
            DeleteFile(szUpgr);
            LogProc->LogString("\r\n,#DevDump.log,,\r\n");
            lstrcpy(szUpgr, LogProc->szLogDir);
            lstrcat(szUpgr, "\\devdump.log");
            CatLogFile(szUpgr);
            DeleteFile(szUpgr);
            LogProc->LogString("\r\n,#END_DevDump.log,,\r\n");
        }

        HandleToStatic = GetDlgItem(gHandleToMainWindow, IDC_STATIC_STATUS);
        wsprintf(Status, TEXT("Logfile \"%s\" has been written to disk."), LogProc->szFile);
        //
        // If the filepath is specified on the command line, we are likely running under Winnt32
        // so we hide the files to set a good example to ISV's - bug #229053
        //
        if(CommandLine.IsSpecified(TEXT("/w"),NOT_CASE_SENSITIVE)) {
            SetFileAttributes(LogProc->szFile, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
            SetFileAttributes(szRegFile, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
        }
        SendMessage(HandleToStatic, WM_SETTEXT, 0, (LPARAM)Status);

       return TRUE;
}

CLASS_GeneralInfo::CLASS_GeneralInfo(kLogFile *Proc, HWND hIn)
{
    LogProc=Proc;
    gHandleToMainWindow = hIn;
    GetCurrentWindowsDirectory();
    //RunDevdump = TRUE;
    RunDevdump = FALSE; // Disabled devdump due to whistler bug 355359
    RunChkupgrd = TRUE;
    AutoRun = FALSE;
    RunMinimized = FALSE;
    OverWrite = FALSE;
    UseComputerName = FALSE;
}

// Initialize the global WindowsDirectory variable
void CLASS_GeneralInfo::GetCurrentWindowsDirectory(void)
{
   HINSTANCE hInst2=LoadLibraryEx("kernel32.dll", NULL, DONT_RESOLVE_DLL_REFERENCES);
   LPFNDLLFUNC2 fProc = (LPFNDLLFUNC2)GetProcAddress(hInst2, "GetSystemWindowsDirectoryA");

   if (hInst2 && fProc)
   {
      fProc(WindowsDirectory, MAX_PATH);
   }
   else
   {
      GetWindowsDirectory(WindowsDirectory, MAX_PATH);
   }
   if ( '\\' == WindowsDirectory[lstrlen(WindowsDirectory)-1] )
   {
      WindowsDirectory[lstrlen(WindowsDirectory)-1]='\0';
   }
   lstrcpy(g_WindowsDirectory, WindowsDirectory);
}

void CLASS_GeneralInfo::DetermineOS(void)
{
    OSVERSIONINFO osV;

    osV.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osV))
    {
        switch (osV.dwPlatformId)
        {
            case VER_PLATFORM_WIN32s:
                OSVersion = Unknown;
            break; 
            case VER_PLATFORM_WIN32_WINDOWS:
            {
                if (osV.dwMinorVersion == 0)
                {
                    OSVersion = Win95;
                }
                else if (osV.dwMinorVersion == 10)
                {
                    OSVersion = Win98;
                }
            }
            break;
            case VER_PLATFORM_WIN32_NT:
            {
                if (osV.dwMajorVersion == 4)
                {
                    OSVersion = NT4;
                }
                else if (osV.dwMajorVersion == 5)
                {
                    if(LOWORD(osV.dwBuildNumber) == 2195)
                        OSVersion = Win2000;
                    else if(LOWORD(osV.dwBuildNumber) >= 2196)
                        OSVersion = Whistler;
                    else
                        OSVersion = Unknown;
                }
            }
            break;
            default:
                OSVersion = Unknown;
            break;
        }
    }
    else 
    {
        OSVersion = Unknown;
    }
}

BOOL CLASS_GeneralInfo::InitLogFile(void)
{
    TCHAR szLogFileName[MAX_PATH * 4];
    TCHAR Windy[MAX_PATH * 4];
    TCHAR szCurDirectory[MAX_PATH];
    WIN32_FIND_DATA FileData;
    HANDLE HandleToSearch;
    kCommandLine CommandLine;

    DetermineOS();

    //default to windir
	lstrcpy(szLogFileName, WindowsDirectory);

	if (CommandLine.IsSpecified(TEXT("/w"),NOT_CASE_SENSITIVE))
        lstrcpy(szLogFileName, CommandLine.GetSwitchValue(TEXT("/w"),NOT_CASE_SENSITIVE));

		//if (GetCurrentDirectory(MAX_PATH, szCurDirectory))
		//	lstrcpy(CSV, szCurDirectory);
    if(szLogFileName[lstrlen(szLogFileName) -1] != '\\')
   		lstrcat(szLogFileName, "\\");
   
    if (CommandLine.IsSpecified(TEXT("/n"),NOT_CASE_SENSITIVE))
		lstrcat(szLogFileName,CommandLine.GetSwitchValue(TEXT("/n"),NOT_CASE_SENSITIVE));
    // For Whistler Pre-Beta1 test - Generate Unique filename (ComputerName+UserName+Time)
    else if (CommandLine.IsSpecified(TEXT("/u"),NOT_CASE_SENSITIVE))
	    lstrcat(szLogFileName, GetUniqueFileName());
    else
		lstrcat(szLogFileName, Profile);

    lstrcpy(szRegFile, szLogFileName);
    lstrcat(szRegFile, TEXT(".reg"));

    switch (OSVersion)
    {
        case Win95:
            lstrcpy(PlatformExtension, TEXT("-w95"));
         break;
        case Win98:
            lstrcpy(PlatformExtension, TEXT("-w98"));
         break;
        case NT4:
            lstrcpy(PlatformExtension, TEXT("-nt4"));
         break;
        case Win2000:
            lstrcpy(PlatformExtension, TEXT("-w2k"));
         break;
        default:
            lstrcpy(PlatformExtension, TEXT("-unk"));
         break;
    }

	if (!(CommandLine.IsSpecified(TEXT("/x"),NOT_CASE_SENSITIVE)))
		lstrcat(szLogFileName, PlatformExtension);

	if (CommandLine.IsSpecified(TEXT("/l"),NOT_CASE_SENSITIVE))
		lstrcat(szLogFileName, ".log");
	else
		lstrcat(szLogFileName, ".csv");

    if(CommandLine.IsSpecified(TEXT("/u"),NOT_CASE_SENSITIVE))
        szLogFileName[lstrlen(szLogFileName) - (4 * sizeof (TCHAR))] = '\0';

    HandleToSearch = FindFirstFile(szLogFileName, &FileData);
    if (TRUE == OverWrite)
        DeleteFile(szLogFileName);
    else if (INVALID_HANDLE_VALUE != HandleToSearch)
    {
        //ask to overwrite
        TCHAR ErrorMessage[MAX_PATH * 4];
        int RetVal;

        wsprintf(ErrorMessage, TEXT("Overwrite %s?"), szLogFileName);
        RetVal=MessageBox(gHandleToMainWindow, ErrorMessage, TEXT("Sysparse"), MB_YESNO);
        if (IDYES == RetVal)
            DeleteFile(szLogFileName);
        else if (IDNO == RetVal)
            return FALSE;
    }
    if(HandleToSearch)
        FindClose(HandleToSearch);
    lstrcpy(Windy, WindowsDirectory);
    LogProc->InitFile(szLogFileName, Windy);
    return TRUE;
}

void CLASS_GeneralInfo::InitHelpers(void)
{

}

void CLASS_GeneralInfo::DetermineCommandLine(void)
{

}

BOOL CLASS_GeneralInfo::FillInArguments(void)
{
    kCommandLine CommandLine;
    TCHAR ComputerName[MAX_COMPUTERNAME_LENGTH+1];
    TCHAR CurrentDirectory[MAX_PATH];
    HANDLE FileSearch;
    WIN32_FIND_DATA FileData;
    BOOL PrePopulateFileFound = FALSE;
    DWORD NameBufferSize = MAX_COMPUTERNAME_LENGTH + 1;

    lstrcpy(Corporation, "");
    lstrcpy(Email, "");
    lstrcpy(Manufacturer, "");
    lstrcpy(Model, "");
    lstrcpy(NumComp, "");
    lstrcpy(SiteID, "");
    lstrcpy(Profile, "");
    lstrcpy(BetaID, "");
    lstrcpy(MachineType, "");
    SiteIDIndex=0;
    MachineTypeIndex=0;

    if (0 != GetModuleFileName(NULL, CurrentDirectory, MAX_PATH))
    {
        DWORD NameCounter;

        NameCounter = lstrlen(CurrentDirectory);
        while ( ('\\' != CurrentDirectory[NameCounter]) && (0 != NameCounter) )
            NameCounter--;
        CurrentDirectory[NameCounter]='\0';
        if ('\\' != CurrentDirectory[lstrlen(CurrentDirectory)-1] )
        {
            lstrcat(CurrentDirectory, "\\sysparsq");
        }
        else
        {
            lstrcat(CurrentDirectory, "sysparsq");
        }
        FileSearch=FindFirstFile(CurrentDirectory, &FileData);
        if (INVALID_HANDLE_VALUE != FileSearch)
        {
            //found the INI
            ReadInFileInfo(CurrentDirectory);
            FindClose(FileSearch);
            PrePopulateFileFound = TRUE;
        } 
        else
        {
            lstrcat(CurrentDirectory, TEXT(".ini"));
            FileSearch = FindFirstFile(CurrentDirectory, &FileData);
            if (INVALID_HANDLE_VALUE != FileSearch)
            {
                //found the INI
                ReadInFileInfo(CurrentDirectory);
                FindClose(FileSearch);
                PrePopulateFileFound = TRUE;
            }
        }
        if (CommandLine.IsSpecified("/p",NOT_CASE_SENSITIVE))
        {
            PTCHAR Switch;
            TCHAR Message1[MAX_PATH * 4], Message2[MAX_PATH * 4];
            DWORD ret;
            HANDLE SearchHandle;
            WIN32_FIND_DATA Data;

            Switch = CommandLine.GetSwitchValue("/p",NOT_CASE_SENSITIVE);
            if(!Switch)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            lstrcpy (CurrentDirectory, Switch);
            //"/p filename" file to copy input values from

            SearchHandle = FindFirstFile(CurrentDirectory, &Data);
            if (INVALID_HANDLE_VALUE != SearchHandle)
            {
                PrePopulateFileFound = TRUE;
                ReadInFileInfo(CurrentDirectory);
            }
            else
            {
                wsprintf(Message2, "Could not find file %s specified with /p switch", CurrentDirectory);
                MessageBox(NULL, Message2, "Sysparse", MB_OK);
                return FALSE;
            }
            if(FileSearch)
                FindClose(FileSearch);
        }
/*
//fill this in with the above routine.  (put it in a seperate routine and call it from here.)
      else if (CommandLine.IsSpecified("-p",TRUE))
      {
         TCHAR *Switch;
         Switch=CommandLine.GetSwitchValue("-p",TRUE);
         lstrcpy(CurrentDirectory, Switch);
         PrePopulateFileFound=TRUE;
      }
*/

      //No file to prepopulate sysparse with, find out if
      //there are any commandline arguments to look at
      if (CommandLine.IsSpecified("/a",NOT_CASE_SENSITIVE) || CommandLine.IsSpecified("-a",NOT_CASE_SENSITIVE))
         AutoRun = TRUE;

      if (CommandLine.IsSpecified("/m",NOT_CASE_SENSITIVE) || CommandLine.IsSpecified("-m",NOT_CASE_SENSITIVE))
            RunMinimized = TRUE;
 
        if (CommandLine.IsSpecified("/c",NOT_CASE_SENSITIVE) || CommandLine.IsSpecified("-c",NOT_CASE_SENSITIVE) || (TRUE == UseComputerName) )
        {
            UseComputerName = TRUE;
            
            if (GetComputerName(ComputerName, &NameBufferSize))
            {
                lstrcpy(Profile, ComputerName);
                SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_PROFILE), WM_SETTEXT, 0, (LPARAM)Profile);
            }
        }
      
        if (CommandLine.IsSpecified(TEXT("/o"),NOT_CASE_SENSITIVE) || CommandLine.IsSpecified(TEXT("-o"), NOT_CASE_SENSITIVE))
            OverWrite = TRUE;

        if (CommandLine.IsSpecified(TEXT("/s"),NOT_CASE_SENSITIVE) || CommandLine.IsSpecified(TEXT("-s"), NOT_CASE_SENSITIVE))
            g_WalkStartMenu = FALSE;

        if (CommandLine.IsSpecified("/1",NOT_CASE_SENSITIVE))
        {
            lstrcpy(Corporation, CommandLine.GetSwitchValue("/1",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_CORPORATION), WM_SETTEXT, 0, (LPARAM)Corporation);
        }
        else if (CommandLine.IsSpecified("-1",NOT_CASE_SENSITIVE))
        {
            lstrcpy(Corporation, CommandLine.GetSwitchValue("-1",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_CORPORATION), WM_SETTEXT, 0, (LPARAM)Corporation);
        }

        if (CommandLine.IsSpecified("/2",NOT_CASE_SENSITIVE))
        {
            lstrcpy(Email, CommandLine.GetSwitchValue("/2",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_EMAIL), WM_SETTEXT, 0, (LPARAM)Email);
        }
        else if (CommandLine.IsSpecified("-2",NOT_CASE_SENSITIVE))
        {
            lstrcpy(Email, CommandLine.GetSwitchValue("-2",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_EMAIL), WM_SETTEXT, 0, (LPARAM)Email);
        }

        if (CommandLine.IsSpecified("/6",NOT_CASE_SENSITIVE))
        {
            lstrcpy(Manufacturer, CommandLine.GetSwitchValue("/6",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_MANUFACTURER), WM_SETTEXT, 0, (LPARAM)Manufacturer);
        }
        else if (CommandLine.IsSpecified("-6",NOT_CASE_SENSITIVE))
        {
            lstrcpy(Manufacturer, CommandLine.GetSwitchValue("-6",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_MANUFACTURER), WM_SETTEXT, 0, (LPARAM)Manufacturer);
        }
      
        if (CommandLine.IsSpecified("/7",NOT_CASE_SENSITIVE))
        { 
            lstrcpy(Model, CommandLine.GetSwitchValue("/7",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_MODEL), WM_SETTEXT, 0, (LPARAM)Model);
        }
        else if (CommandLine.IsSpecified("-7",NOT_CASE_SENSITIVE))
        {
            lstrcpy(Model, CommandLine.GetSwitchValue("-7",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_MODEL), WM_SETTEXT, 0, (LPARAM)Model);
        }
      
        if (CommandLine.IsSpecified("/9",NOT_CASE_SENSITIVE))
        {
            lstrcpy(NumComp, CommandLine.GetSwitchValue("/9",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_NUMCOMP), WM_SETTEXT, 0, (LPARAM)NumComp);
        } 
        else if (CommandLine.IsSpecified("-9",NOT_CASE_SENSITIVE))
        {
            lstrcpy(NumComp, CommandLine.GetSwitchValue("-9",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_NUMCOMP), WM_SETTEXT, 0, (LPARAM)NumComp);
        }

        if (CommandLine.IsSpecified("/3",NOT_CASE_SENSITIVE))
        {
            TCHAR Temp[MAX_PATH * 4];
         
            lstrcpy(Temp, CommandLine.GetSwitchValue("/3",NOT_CASE_SENSITIVE));
            SiteIDIndex=(UINT)_ttoi(Temp);
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_COMBO_SITEID), CB_SETCURSEL, SiteIDIndex+1, 0);
            SendMessage(gHandleToMainWindow, WM_COMMAND, MAKEWPARAM(IDC_COMBO_SITEID, 0), (LPARAM)GetDlgItem(gHandleToMainWindow, IDC_COMBO_SITEID));
        }
        else if (CommandLine.IsSpecified("-3",NOT_CASE_SENSITIVE))
        {
            TCHAR Temp[MAX_PATH * 4];
            lstrcpy(Temp, CommandLine.GetSwitchValue("-3",NOT_CASE_SENSITIVE));
            SiteIDIndex = (UINT)_ttoi(Temp);
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_COMBO_SITEID), CB_SETCURSEL, SiteIDIndex+1, 0);
            SendMessage(gHandleToMainWindow, WM_COMMAND, MAKEWPARAM(IDC_COMBO_SITEID, 0), (LPARAM)GetDlgItem(gHandleToMainWindow, IDC_COMBO_SITEID));
        }

        if (CommandLine.IsSpecified("/4",NOT_CASE_SENSITIVE))
        {
            if (!UseComputerName)
            {
                lstrcpy(Profile, CommandLine.GetSwitchValue("/4",NOT_CASE_SENSITIVE));
                SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_PROFILE), WM_SETTEXT, 0, (LPARAM)Profile);
            }
        }
        else if (CommandLine.IsSpecified("-4",NOT_CASE_SENSITIVE))
        {
            if (!UseComputerName)
            {
                lstrcpy(Profile, CommandLine.GetSwitchValue("-4",NOT_CASE_SENSITIVE));
                SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_PROFILE), WM_SETTEXT, 0, (LPARAM)Profile);
            }
        }

        if (CommandLine.IsSpecified("/5",NOT_CASE_SENSITIVE))
        {
            lstrcpy(BetaID, CommandLine.GetSwitchValue("/5",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_BETAID), WM_SETTEXT, 0, (LPARAM)BetaID);
        }
        else if (CommandLine.IsSpecified("-5",NOT_CASE_SENSITIVE))
        {
            lstrcpy(BetaID, CommandLine.GetSwitchValue("-5",NOT_CASE_SENSITIVE));
            SendMessage(GetDlgItem(gHandleToMainWindow, IDC_EDIT_BETAID), WM_SETTEXT, 0, (LPARAM)BetaID);
        }

        if (CommandLine.IsSpecified("/8",NOT_CASE_SENSITIVE))
        {
            TCHAR Temp[MAX_PATH * 4];
            lstrcpy (Temp, CommandLine.GetSwitchValue ("/8",NOT_CASE_SENSITIVE));
            MachineTypeIndex = (UINT)_ttoi(Temp);
            SendMessage (GetDlgItem (gHandleToMainWindow, IDC_COMBO_TYPE), CB_SETCURSEL, MachineTypeIndex + 1, 0);
        }
        else if (CommandLine.IsSpecified("-8",NOT_CASE_SENSITIVE))
        {
            TCHAR Temp[MAX_PATH * 4];
            SendMessage (GetDlgItem (gHandleToMainWindow, IDC_COMBO_TYPE), CB_SETCURSEL, MachineTypeIndex + 1, 0);
        }
    }
    return TRUE;      
}

BOOL CLASS_GeneralInfo::ReadInFileInfo(PTCHAR pFileName)
{
    TCHAR AutoRunText[MAX_PATH * 4];
    HWND HandleToControl;
    DWORD ret;

    if(!pFileName)
        return FALSE;
        
    if(!lstrlen(pFileName))
        return FALSE;
        
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#Corp\"", "", Corporation, MAX_PATH * 4, pFileName);
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#Make\"", "", Manufacturer, MAX_PATH * 4, pFileName);
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#Model\"", "", Model, MAX_PATH * 4, pFileName);
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#UserID\"", "", Email, MAX_PATH * 4, pFileName);
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"##machines_on_profile\"", "", NumComp, MAX_PATH * 4, pFileName);
    ret = 0;
    while ('\0' != NumComp[ret])
    {
        if ( (NumComp[ret] < 48) || (NumComp[ret] > 57) )
        {
            TCHAR Error[MAX_PATH * 4];
            wsprintf(Error, "##machines_on_profile in %s is not valid", pFileName);
            MessageBox(NULL, Error, "Sysparse", MB_OK);
            return FALSE;
        }
        ret++;
    }

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#Event\"", "", SiteID, MAX_PATH * 4, pFileName);
    if (0 != lstrlen(SiteID))
    {
        if (INVALID_HANDLE_VALUE != (HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_COMBO_SITEID)))
            SiteIDIndex = (USHORT)SendMessage(HandleToControl, CB_FINDSTRINGEXACT, -1, (LPARAM)SiteID);

        if (CB_ERR == SiteIDIndex)
        {
            MessageBox(gHandleToMainWindow, "SiteID (#Event) specified in INI is invalid", "Sysparse", MB_OK);
            return FALSE;
        }
        else
        {
            SendMessage(HandleToControl, CB_SETCURSEL, SiteIDIndex, 0);
            SendMessage(gHandleToMainWindow, WM_COMMAND, MAKEWPARAM(IDC_COMBO_SITEID, 0), (LPARAM)GetDlgItem(gHandleToMainWindow, IDC_COMBO_SITEID));
        }
    }
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#Profile\"", "", Profile, MAX_PATH * 4, pFileName);
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#Location\"", "", BetaID, MAX_PATH * 4, pFileName);
    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#MachineType\"", "", MachineType, MAX_PATH * 4, pFileName);

    if (0 != lstrlen(MachineType))
    {
        if (INVALID_HANDLE_VALUE != (HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_COMBO_TYPE)))
            MachineTypeIndex = (USHORT)SendMessage(HandleToControl, CB_FINDSTRINGEXACT, -1, (LPARAM)MachineType);

        if (CB_ERR == MachineTypeIndex)
        {
            MessageBox(gHandleToMainWindow, "MachineType (#Event) specified in INI is not valid", "Sysparse", MB_OK);
            return FALSE;
        }
        else if(INVALID_HANDLE_VALUE != HandleToControl)
        {
            SendMessage(HandleToControl, CB_SETCURSEL, MachineTypeIndex, 0);
        }
        else {
            return FALSE;
        }
    }

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#AutoRun\"", "", AutoRunText, MAX_PATH * 4, pFileName);
    _tcslwr(AutoRunText);
    if (!lstrcmp(AutoRunText, TEXT("yes")))
        AutoRun = TRUE;

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#OverWriteCSV\"", "", AutoRunText, MAX_PATH * 4, pFileName);
    _tcslwr(AutoRunText);
    if (!lstrcmp(AutoRunText, TEXT("yes")))
        OverWrite = TRUE;

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#RunMinimized\"", "", AutoRunText, MAX_PATH * 4, pFileName);
    _tcslwr(AutoRunText);
    if (!lstrcmp(AutoRunText, TEXT("yes")))
        RunMinimized = TRUE;

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#UseComputerName\"", "", AutoRunText, MAX_PATH * 4, pFileName);
    _tcslwr(AutoRunText);
    if (!lstrcmp(AutoRunText, TEXT("yes")))
        UseComputerName = TRUE;

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#donotrun1\"", "", AutoRunText, MAX_PATH * 4, pFileName);
    _tcslwr(AutoRunText);
    if (!lstrcmp(AutoRunText, TEXT("yes")))
        RunChkupgrd=FALSE;

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#donotrun2\"", "", AutoRunText, MAX_PATH * 4, pFileName);
    _tcslwr(AutoRunText);
    if (!lstrcmp(AutoRunText, TEXT("yes")))
        RunDevdump=FALSE;

    GetPrivateProfileString ("HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse", "\"#MachineUUID\"", "", OriginalMachineUUID, MAX_PATH * 4, pFileName);

    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_CORPORATION);
    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)Corporation);
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_EMAIL);
    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)Email);
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_MANUFACTURER);
    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)Manufacturer);
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_MODEL);
    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)Model);
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_NUMCOMP);
    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)NumComp);
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_PROFILE);
    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)Profile);
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_BETAID);
    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)BetaID);
    return TRUE;
}

BOOL CLASS_GeneralInfo::DetermineArgumentValidity(void)
{
    BOOL ReturnValue;
    DWORD Counter;

    ReturnValue = CopyInput();

    if (FALSE == ReturnValue)
      return FALSE;

    Counter=0;
    while (Profile[Counter]!='\0')
    {
        if (Profile[Counter] != 'a' &&
            Profile[Counter] != 'b' &&
            Profile[Counter] != 'c' &&
            Profile[Counter] != 'd' &&
            Profile[Counter] != 'e' &&
            Profile[Counter] != 'f' &&
            Profile[Counter] != 'g' &&
            Profile[Counter] != 'h' &&
            Profile[Counter] != 'i' &&
            Profile[Counter] != 'j' &&
            Profile[Counter] != 'k' &&
            Profile[Counter] != 'l' &&
            Profile[Counter] != 'm' &&
            Profile[Counter] != 'n' &&
            Profile[Counter] != 'o' &&
            Profile[Counter] != 'p' &&
            Profile[Counter] != 'q' &&
            Profile[Counter] != 'r' &&
            Profile[Counter] != 's' &&
            Profile[Counter] != 't' &&
            Profile[Counter] != 'u' &&
            Profile[Counter] != 'v' &&
            Profile[Counter] != 'w' &&
            Profile[Counter] != 'x' &&
            Profile[Counter] != 'y' &&
            Profile[Counter] != 'z' &&
            Profile[Counter] != 'A' &&
            Profile[Counter] != 'B' &&
            Profile[Counter] != 'C' &&
            Profile[Counter] != 'D' &&
            Profile[Counter] != 'E' &&
            Profile[Counter] != 'F' &&
            Profile[Counter] != 'G' &&
            Profile[Counter] != 'H' &&
            Profile[Counter] != 'I' &&
            Profile[Counter] != 'J' &&
            Profile[Counter] != 'K' &&
            Profile[Counter] != 'L' &&
            Profile[Counter] != 'M' &&
            Profile[Counter] != 'N' &&
            Profile[Counter] != 'O' &&
            Profile[Counter] != 'P' &&
            Profile[Counter] != 'Q' &&
            Profile[Counter] != 'R' &&
            Profile[Counter] != 'S' &&
            Profile[Counter] != 'T' &&
            Profile[Counter] != 'U' &&
            Profile[Counter] != 'V' &&
            Profile[Counter] != 'W' &&
            Profile[Counter] != 'X' &&
            Profile[Counter] != 'Y' &&
            Profile[Counter] != 'Z' &&
            Profile[Counter] != '0' &&
            Profile[Counter] != '1' &&
            Profile[Counter] != '2' &&
            Profile[Counter] != '3' &&
            Profile[Counter] != '4' &&
            Profile[Counter] != '5' &&
            Profile[Counter] != '6' &&
            Profile[Counter] != '7' &&
            Profile[Counter] != '8' &&
            Profile[Counter] != '9' &&
            Profile[Counter] != ' ' &&
            Profile[Counter] != '_' &&
            Profile[Counter] != '-' )
        {
            Profile[Counter]=TEXT('_');
        }
        Counter++;
    }

    return TRUE;
}

void CLASS_GeneralInfo::ChangeSpaces(TCHAR *Input)
{
    TCHAR Temp[MAX_PATH * 4];
    DWORD Counter;
    DWORD Len;

    Counter = 0;
    Len = lstrlen(Temp);
    lstrcpy(Temp, Input);
    while (('\0' != Temp[Counter]) && (Counter != Len))
    {
       if ( ' ' == Temp[Counter] )
          Temp[Counter]='_';

      Counter++;
    }
    lstrcpy(Input, Temp);
}

BOOL CLASS_GeneralInfo::CopyInput(void)
{
    HWND HandleToControl;
    TCHAR Holder[MAX_PATH * 4];
    DWORD Retval;

    HandleToControl=GetDlgItem(gHandleToMainWindow, IDC_EDIT_CORPORATION);
    if (HandleToControl)
        SendMessage(HandleToControl, WM_GETTEXT, MAX_PATH * 4, (LPARAM)Corporation);
    if (0 == lstrlen(Corporation))
    {
        MessageBox(gHandleToMainWindow, "Please enter a value for Corporation", "Sysparse", MB_OK);
        return FALSE;
    }
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_EMAIL);
    if (HandleToControl)
        SendMessage(HandleToControl, WM_GETTEXT, MAX_PATH * 4, (LPARAM)Email);
    if (0 == lstrlen(Email))
    {
        MessageBox(gHandleToMainWindow, "Please enter a value for E-mail", "Sysparse", MB_OK);
        return FALSE;
    }
    HandleToControl=GetDlgItem(gHandleToMainWindow, IDC_EDIT_MANUFACTURER);
    if (HandleToControl)
        SendMessage(HandleToControl, WM_GETTEXT, MAX_PATH * 4, (LPARAM)Manufacturer);
    if (0 == lstrlen(Manufacturer))
    {
        MessageBox(gHandleToMainWindow, "Please enter a value for Manufacturer", "Sysparse", MB_OK);
        return FALSE;
    }
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_MODEL);
    if (HandleToControl)
        SendMessage(HandleToControl, WM_GETTEXT, MAX_PATH * 4, (LPARAM)Model);
    if (0 == lstrlen(Model))
    {
        MessageBox(gHandleToMainWindow, "Please enter a value for Model", "Sysparse", MB_OK);
        return FALSE;
    }
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_NUMCOMP);
    if (HandleToControl)
    {
        SendMessage(HandleToControl, WM_GETTEXT, MAX_PATH * 4, (LPARAM)NumComp);
    }
    if (0 == lstrlen(NumComp))
    {
        MessageBox(gHandleToMainWindow, "Please enter a value for # Computers", "Sysparse", MB_OK);
        return FALSE;
    }
    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_COMBO_SITEID);
    if (HandleToControl)
    {
        SiteIDIndex=(unsigned short)SendMessage(HandleToControl, CB_GETCURSEL, 0, 0);
    }
#ifndef SB
    if (0 == SiteIDIndex)
    {
        MessageBox(gHandleToMainWindow, "Please select a value for Site ID", "Sysparse", MB_OK);
        return FALSE;
    }
#else
    if (0 != SiteIDIndex)
    {
        MessageBox(gHandleToMainWindow, "Please select a value for Site ID", "Sysparse", MB_OK);
        return FALSE;
    }
#endif
    else
        SendMessage(HandleToControl, CB_GETLBTEXT, SiteIDIndex, (LPARAM)SiteID);

    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_PROFILE);
    if (HandleToControl)
        Retval=(DWORD)SendMessage(HandleToControl, WM_GETTEXT, MAX_PATH * 4, (LPARAM)Profile);

    if (0 == Retval)
    {
        MessageBox(gHandleToMainWindow, "Please enter a value for Profile", "Sysparse", MB_OK);
        return FALSE;
    }

    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_EDIT_BETAID);
    if (HandleToControl)
        SendMessage(HandleToControl, WM_GETTEXT, MAX_PATH * 4, (LPARAM)BetaID);

    if (0 == lstrlen(BetaID))
    {
        MessageBox(gHandleToMainWindow, TEXT("Please enter a value for Beta ID"), TEXT("Sysparse"), MB_OK);
        return FALSE;
    }

    HandleToControl = GetDlgItem(gHandleToMainWindow, IDC_COMBO_TYPE);

    if (HandleToControl)
        MachineTypeIndex = (unsigned short)SendMessage(HandleToControl, CB_GETCURSEL, 0, 0);

    if (0 == MachineTypeIndex)
    {
        MessageBox(gHandleToMainWindow, TEXT("Please select a value for MachineType"), TEXT("Sysparse"), MB_OK);
        return FALSE;
    }
    else
        SendMessage(HandleToControl, CB_GETLBTEXT, MachineTypeIndex, (LPARAM)MachineType);

    return TRUE;
}

void CLASS_GeneralInfo::WriteVersions(void)
{
    SYSTEMTIME SysTime;
#ifdef INTERNAL
    LogProc->LogString(TEXT(",#Sysparse_Version,,\r\n,02.05.02I,\r\n"));
#else
    LogProc->LogString(TEXT(",#Sysparse_Version,,\r\n,02.05.02E,\r\n"));
#endif
    LogProc->LogString(TEXT(",#ParseTime,,\r\n"));
    GetSystemTime(&SysTime);
    LogProc->LogString (TEXT(",%2d/%2d/%4d %2d:%2d:%2d,\r\n"), SysTime.wMonth, SysTime.wDay, SysTime.wYear, SysTime.wHour, SysTime.wMinute, SysTime.wSecond);
}

void CLASS_GeneralInfo::WriteGeneralInfo(void)
{

}

void CLASS_GeneralInfo::GetUUID(void)
{
    HKEY hOpen;
    LONG lRet;
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\SysParse"), 0, KEY_ALL_ACCESS, &hOpen);

    if (ERROR_SUCCESS == lRet)
    {
        UCHAR *szreg = (UCHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * 4);
        TCHAR szFile[MAX_PATH];
        TCHAR szfilecont[50000];
        DWORD dwlen = MAX_PATH * 4;
        DWORD dwType;
        LPTSTR szval = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * 4);
        lstrcpy(szval, TEXT("#MachineUuid"));
        lRet = RegQueryValueEx(hOpen, szval, NULL, &dwType, szreg, &dwlen);
        if (ERROR_SUCCESS == lRet)
        {
            LogProc->LogString(TEXT(",#MachineUUID,,\r\n"));
            LogProc->LogString(TEXT(",%s,\r\n"), szreg);
            RegSetValueEx(hOpen, TEXT("#Profile"), 0, REG_SZ, (BYTE*)Profile, lstrlen((const char *)Profile)+1);
            RegSetValueEx(hOpen, TEXT("#Corp"), 0, REG_SZ, (BYTE*)Corporation, lstrlen((const char *)Corporation)+1);
            RegSetValueEx(hOpen, TEXT("#UserID"), 0, REG_SZ, (BYTE*)Email, lstrlen((const char *)Email)+1);
            RegSetValueEx(hOpen, TEXT("##machines_on_profile"), 0, REG_SZ, (BYTE*)NumComp, lstrlen((const char *)NumComp)+1);
            RegSetValueEx(hOpen, TEXT("#Make"), 0, REG_SZ, (BYTE*)Manufacturer, lstrlen((const char *)Manufacturer)+1);
            RegSetValueEx(hOpen, TEXT("#Model"), 0, REG_SZ, (BYTE*)Model, lstrlen((const char *)Model)+1);
            RegSetValueEx(hOpen, TEXT("#Event"), 0, REG_SZ, (BYTE*)BetaID, lstrlen((const char *)BetaID)+1);
            RegSetValueEx(hOpen, TEXT("#MachineType"), 0, REG_SZ, (BYTE*)MachineType, lstrlen((const char *)MachineType)+1);
        }
        else
        {
            LogProc->LogString(TEXT(",#MachineUUID,,\r\n"));
            UUID uuid;
            LONG wRet;
            UCHAR *szuuid = 0x0;
            wRet = UuidCreate(&uuid);
            if ((RPC_S_OK == wRet) || (RPC_S_UUID_LOCAL_ONLY))
            {
                wRet=UuidToString(&uuid, &szuuid);
                if (RPC_S_OK == wRet)
                    LogProc->LogString(TEXT(",%s,\r\n"),szuuid);
                else 
                    LogProc->LogString(TEXT(",blank,\r\n"));
            }
            else 
                LogProc->LogString(TEXT(",blank,\r\n"));

            HKEY hKey;
            DWORD dwDisp;
            RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\SysParse"), 0, TEXT("SZ_KEY"), 0, KEY_ALL_ACCESS, NULL, &hKey, &dwDisp);
            RegSetValueEx(hKey, TEXT("#MachineUuid"), 0, REG_SZ, szuuid, lstrlen((const char *)szuuid) + 1);
            lstrcpy((TCHAR *) szreg, (TCHAR *)szuuid);

            RegSetValueEx(hOpen, TEXT("#Profile"), 0, REG_SZ, (BYTE*)Profile, lstrlen((const char *)Profile) + 1);
            RegSetValueEx(hOpen, TEXT("#Corp"), 0, REG_SZ, (BYTE*)Corporation, lstrlen((const char *)Corporation) + 1);
            RegSetValueEx(hOpen, TEXT("#UserID"), 0, REG_SZ, (BYTE*)Email, lstrlen((const char *)Email) + 1);
            RegSetValueEx(hOpen, TEXT("##machines_on_profile"), 0, REG_SZ, (BYTE*)NumComp, lstrlen((const char *)NumComp) + 1);
            RegSetValueEx(hOpen, TEXT("#Make"), 0, REG_SZ, (BYTE*)Manufacturer, lstrlen((const char *)Manufacturer) + 1);
            RegSetValueEx(hOpen, TEXT("#Model"), 0, REG_SZ, (BYTE*)Model, lstrlen((const char *)Model) + 1);
            RegSetValueEx(hOpen, TEXT("#Event"), 0, REG_SZ, (BYTE*)BetaID, lstrlen((const char *)BetaID) + 1);
            RegSetValueEx(hOpen, TEXT("#MachineType"), 0, REG_SZ, (BYTE*)MachineType, lstrlen((const char *)MachineType) + 1);

           if (INVALID_HANDLE_VALUE != hKey ) 
               RegCloseKey(hKey);
        }
        if (INVALID_HANDLE_VALUE != hOpen)
            RegCloseKey(hOpen);

        HANDLE hFile;
        DWORD dwBytesWrit;
        hFile = CreateFile(szRegFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile!=INVALID_HANDLE_VALUE)
        {
            wsprintf(szfilecont, TEXT("REGEDIT4\r\n\r\n[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse]\r\n"));
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#MachineUuid\"=\"%s\"\r\n"), szreg);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Profile\"=\"%s\"\r\n"), Profile);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Corp\"=\"%s\"\r\n"), Corporation);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#UserID\"=\"%s\"\r\n"), Email);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"##machines_on_profile\"=\"%s\"\r\n"), NumComp);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Make\"=\"%s\"\r\n"), Manufacturer);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Model\"=\"%s\"\r\n"), Model);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Event\"=\"%s\"\r\n"), SiteID);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Location\"=\"%s\"\r\n"), BetaID);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#MachineType\"=\"%s\"\r\n"), MachineType);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            CloseHandle(hFile);
        }
        HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szreg);
    }
    else
    {
        LogProc->LogString(",#MachineUUID,,\r\n");
        UUID uuid;
        LONG wRet;
        UCHAR *szuuid = 0x0;
        wRet = UuidCreate(&uuid);
        if ((RPC_S_OK == wRet) || (RPC_S_UUID_LOCAL_ONLY))
        {
            wRet = UuidToString(&uuid, &szuuid);
            if (RPC_S_OK == wRet)
                LogProc->LogString(",%s,\r\n",szuuid);
            else 
                LogProc->LogString(",blank,\r\n");
        }
        else 
            LogProc->LogString(",blank,\r\n");
        HKEY hKey;
        DWORD dwDisp;
        TCHAR szFile[MAX_PATH];
        RegCreateKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\SysParse", 0, "SZ_KEY", 0, KEY_ALL_ACCESS, NULL, &hKey, &dwDisp);
        RegSetValueEx(hKey, "#MachineUuid", 0, REG_SZ, szuuid, lstrlen((const char *)szuuid) + 1);
        RegSetValueEx(hKey, TEXT("#Profile"), 0, REG_SZ, (BYTE*)Profile, lstrlen((const char *)Profile) + 1);
        RegSetValueEx(hKey, TEXT("#Corp"), 0, REG_SZ, (BYTE*)Corporation, lstrlen((const char *)Corporation) + 1);
        RegSetValueEx(hKey, TEXT("#UserID"), 0, REG_SZ, (BYTE*)Email, lstrlen((const char *)Email) + 1);
        RegSetValueEx(hKey, TEXT("##machines_on_profile"), 0, REG_SZ, (BYTE*)NumComp, lstrlen((const char *)NumComp) + 1);
        RegSetValueEx(hKey, TEXT("#Make"), 0, REG_SZ, (BYTE*)Manufacturer, lstrlen((const char *)Manufacturer) + 1);
        RegSetValueEx(hKey, TEXT("#Model"), 0, REG_SZ, (BYTE*)Model, lstrlen((const char *)Model) + 1);
        RegSetValueEx(hKey, TEXT("#Event"), 0, REG_SZ, (BYTE*)BetaID, lstrlen((const char *)BetaID) + 1);
        RegSetValueEx(hKey, TEXT("#MachineType"), 0, REG_SZ, (BYTE*)MachineType, lstrlen((const char *)MachineType) + 1);

        if (INVALID_HANDLE_VALUE != hKey)
            RegCloseKey(hKey);
        HANDLE hFile;
        DWORD dwBytesWrit;
        TCHAR szfilecont[50000];
        hFile = CreateFile(szRegFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile!=INVALID_HANDLE_VALUE)
        {
            wsprintf(szfilecont, TEXT("REGEDIT4\r\n\r\n[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SysParse]\r\n"));
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#MachineUuid\"=\"%s\"\r\n"), szuuid);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Profile\"=\"%s\"\r\n"), Profile);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Corp\"=\"%s\"\r\n"), Corporation);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#UserID\"=\"%s\"\r\n"), Email);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"##machines_on_profile\"=\"%s\"\r\n"), NumComp);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Make\"=\"%s\"\r\n"), Manufacturer);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Model\"=\"%s\"\r\n"), Model);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Event\"=\"%s\"\r\n"), SiteID);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#Location\"=\"%s\"\r\n"), BetaID);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            wsprintf(szfilecont, TEXT("\"#MachineType\"=\"%s\"\r\n"), MachineType);
            WriteFile(hFile, szfilecont, strlen(szfilecont), &dwBytesWrit, NULL);
            CloseHandle(hFile);
        }
    }

    LONG wRet;
    UUID uuid;
    UCHAR *szuuid = 0x0;
    LogProc->LogString(",#PassUUID,,\r\n");
    wRet = UuidCreate(&uuid);
    if ((RPC_S_OK == wRet) || (RPC_S_UUID_LOCAL_ONLY))
    {
        wRet = UuidToString(&uuid, &szuuid);
        if (RPC_S_OK == wRet)
            LogProc->LogString(",%s,\r\n",szuuid);
        else 
            LogProc->LogString(",blank,\r\n");
    }
    else
        LogProc->LogString(",blank,\r\n");
}

void CLASS_GeneralInfo::WriteArguments(void)
{
    LogProc->StripCommas(Profile);
    LogProc->LogString(",#Profile,,\r\n,%s,\r\n",Profile);
    LogProc->StripCommas(Email);
    LogProc->LogString(",#UserID,,\r\n,%s,\r\n",Email);
    LogProc->StripCommas(NumComp);
    LogProc->LogString(",##machines_on_profile,,\r\n,%s,\r\n",NumComp);
    LogProc->StripCommas(Corporation);
    LogProc->LogString(",#Corp,,\r\n,%s,\r\n",Corporation);
    LogProc->StripCommas(Model);
    LogProc->LogString(",#Model,,\r\n,%s,\r\n",Model);
    LogProc->StripCommas(BetaID);
    LogProc->LogString(",#Location,,\r\n,%s,\r\n",BetaID);
    LogProc->LogString(",#BetaID,,\r\n,%s,\r\n",BetaID);
    LogProc->StripCommas(MachineType);
    LogProc->LogString(",#MachineType,,\r\n,%s,\r\n",MachineType);
    LogProc->StripCommas(SiteID);
    LogProc->LogString(",#Event,,\r\n,%s,\r\n",SiteID);
    LogProc->StripCommas(Manufacturer);
    LogProc->LogString(",#Make,,\r\n,%s,\r\n",Manufacturer);
}

void CLASS_GeneralInfo::WriteFreeDiskSpace(void)
{
    TCHAR szWindir[MAX_PATH * 4];
    lstrcpy(szWindir, WindowsDirectory);
    if (0 != lstrlen(szWindir) )
    {
        ULARGE_INTEGER uliCaller, uliNumBytes, uliNumFreeBytes;
        HINSTANCE hInst2 = LoadLibraryEx("kernel32.dll", NULL, DONT_RESOLVE_DLL_REFERENCES);
        LPFNDLLFUNC1 fProc=(LPFNDLLFUNC1)GetProcAddress(hInst2, "GetDiskFreeSpaceExA");
        if (hInst2 && fProc)
        {
            fProc("c:\\", &uliCaller, &uliNumBytes, &uliNumFreeBytes);
            char szTemp[MAX_PATH * 4];
            strcpy(szTemp, szWindir);
            szTemp[3] = '\0';
            LogProc->LogString(",#WinDir_Free_Space,,\r\n");
            LogProc->StripCommas(szWindir);
            LogProc->LogString(",%s,\r\n", szWindir);
            LogProc->LogString(",%I64d,\r\n", uliNumFreeBytes.QuadPart);
        }
        else
        {
            DWORD dwSPC, dwPBS, dwNFC, dwTNC;
            GetDiskFreeSpace("c:\\", &dwSPC, &dwPBS, &dwNFC, &dwTNC);
            char szTemp[MAX_PATH * 4];
            strcpy(szTemp, szWindir);
            szTemp[3] = '\0';
            GetDiskFreeSpace(szTemp,&dwSPC, &dwPBS, &dwNFC, &dwTNC);
            LogProc->LogString(",#WinDir_Free_Space,,\r\n");
            LogProc->StripCommas(szWindir);
            LogProc->LogString(",%s,\r\n", szWindir);
            LogProc->LogString(",%d,\r\n", dwSPC*dwPBS*dwNFC);
        }
    }
}

void CLASS_GeneralInfo::WriteVolumeType(void)
{
    TCHAR szWind[MAX_PATH];
    TCHAR szVol[MAX_PATH];
    TCHAR szVolName[MAX_PATH];
    DWORD dwSer, dwLen, dwFlags;
    
    lstrcpy(szWind, WindowsDirectory);
    //
    // Lop off all but "%DriveLetter%:\"
    //
    szWind[3] = '\0';
    GetVolumeInformation(szWind, szVol, MAX_PATH, &dwSer, &dwLen, &dwFlags, szVolName, MAX_PATH);
    LogProc->LogString(",#WinDir_Volume_Type,,\r\n");
    LogProc->StripCommas(szVolName);
    LogProc->LogString(",%s,\r\n", szVolName);
}

void CLASS_GeneralInfo::WriteMemorySize(void)
{
    LogProc->LogString(",#Total_Memory,,\r\n");
    MEMORYSTATUS MemStat;
    GlobalMemoryStatus(&MemStat);   
    LogProc->LogString(",%d,\r\n",MemStat.dwTotalPhys);
}

void CLASS_GeneralInfo::WriteOSVersion(void)
{
    TCHAR szFullKey[MAX_PATH];
    PTCHAR szProductName = NULL;
    PTCHAR szString = NULL;        
    TCHAR szinf[MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HKEY hKeyReg;
    LPOSVERSIONINFO osv = NULL;
    DWORD dwstringwrit, dwFileSize = 0, dwType, dwProductSize = 0;
   
    lstrcpy(szFullKey, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"));

    LogProc->LogString(TEXT(",#OS_Version,,\r\n"));
    
    if ((Win2000 != OSVersion) && (NT4 != OSVersion) && (Whistler != OSVersion))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, 0, KEY_READ, &hKeyReg))
        {
            if(ERROR_SUCCESS == RegQueryValueEx(hKeyReg, TEXT("ProductName"), NULL, &dwType, NULL, &dwProductSize))
                szProductName = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwProductSize);
            
            if(szProductName)
            {
                RegQueryValueEx(hKeyReg, TEXT("ProductName"), NULL, &dwType, (LPBYTE)szProductName, &dwProductSize);
            }
            
            RegCloseKey(hKeyReg);
        }
    }
    else
    {
        if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szFullKey, 0, KEY_READ, &hKeyReg))
        {
            if(ERROR_SUCCESS == RegQueryValueEx(hKeyReg, TEXT("ProductName"), NULL, &dwType, NULL, &dwProductSize))
                szProductName = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwProductSize);
            
            if(szProductName)
            {
                RegQueryValueEx(hKeyReg, TEXT("ProductName"), NULL, &dwType, (LPBYTE)szProductName, &dwProductSize);
            }
            
            RegCloseKey(hKeyReg);
        }
    }


    //
    // Ensure there is a value to write, otherwise write a default to avoid parser issues
    //
    if (dwProductSize)
    {
        LogProc->StripCommas(szProductName);
        LogProc->LogString(TEXT(",%s,\r\n"), szProductName);
    }
    else
    {
        if (Win2000 == OSVersion)
            LogProc->LogString(TEXT(",Microsoft Windows 2000,\r\n"));
        else if (Whistler == OSVersion)
            LogProc->LogString(TEXT(",Microsoft Windows Whistler,\r\n"));
        else if (Win95 == OSVersion)
            LogProc->LogString(TEXT(",Microsoft Windows 95,\r\n"));
        else if (Win98 == OSVersion)
            LogProc->LogString(TEXT(",Microsoft Windows 98,\r\n"));
        else if (NT4 == OSVersion)
            LogProc->LogString(TEXT(",Microsoft Windows NT4,\r\n"));
        else 
            LogProc->LogString(TEXT(",Unknown,\r\n"));
    }

    if(szProductName)
        HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szProductName);

    if ( (Win2000 == OSVersion) || (NT4 == OSVersion) )
    {
        LogProc->LogString(",#NTType..\r\n");

        lstrcpy(szFullKey, TEXT("System\\CurrentControlSet\\Control\\ProductOptions"));

        if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szFullKey, 0, KEY_READ, &hKeyReg))
        {
            if(ERROR_SUCCESS == RegQueryValueEx(hKeyReg, TEXT("ProductType"), NULL, &dwType, NULL, &dwProductSize))
                szProductName = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwProductSize);
                
            if(!szProductName)
            {
                RegCloseKey(hKeyReg);
                LogProc->LogString(",Workstation,\r\n");
                goto GET_PREV_OS;
            }
            
            RegQueryValueEx(hKeyReg, TEXT("ProductType"), NULL, &dwType, (LPBYTE)szProductName, &dwProductSize);

            if(dwProductSize)
            {
                if(ERROR_SUCCESS == RegQueryValueEx(hKeyReg, TEXT("ProductType"), NULL, &dwType, (LPBYTE)szProductName, &dwProductSize))
                {
                    LogProc->StripCommas(szProductName);
                    LogProc->LogString(",%s,\r\n", szProductName);
                }
            }
            else
                LogProc->LogString(",Workstation,\r\n");

            HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szProductName);
            RegCloseKey(hKeyReg);
        }
        else
            LogProc->LogString(",Workstation,\r\n");
    }
    
GET_PREV_OS:
    //
    // Get the previous OS info, if any
    //
    LogProc->LogString(",#Prev_OS,,\r\n");
    lstrcpy(szinf, WindowsDirectory);
    lstrcat(szinf, TEXT("\\system32\\$winnt$.inf"));
    hFile = CreateFile(szinf, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {    
        LogProc->LogString(",Unknown,\r\n");
    
   
    dwFileSize = GetFileSize(hFile, NULL);
    szString = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize); 
    
    if(!szString)
    {
        LogProc->LogString(",Unknown,\r\n");
    }
    
    if(ReadFile(hFile, szString, dwFileSize, &dwstringwrit, NULL))
    {
        PTCHAR szLoc;
        PTCHAR szLoc2;
        PTCHAR szBuf = NULL;
        TCHAR szFin[MAX_PATH];
        //
        // Find the address for "buildnumber" within $winnt$.inf
        //
        szLoc = strstr(szString, "BuildNumber");
        szBuf = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize); 

        if (szLoc && szBuf)
        {
            //
            // Find the address within that for the first double-quote
            //
            szLoc2 = strstr(szLoc, "\"");
            if (szLoc2)
            {
                //
                // Copy the rest of the string to the buffer
                //
                lstrcpy(szBuf, szLoc2);
                //
                // Just for fun...
                //
                szBuf[0] = '#';
                //
                // Find the last "
                //
                for ( DWORD i = 0; szBuf[i] != '\"'; i++);
                //
                // Terminate the string
                //
                szBuf[i] = '\0';
                //
                // Now, character by character, copy the string to the new buffer - this avoids the # at the beginning
                // of the string
                //
                for (i = 0; i < strlen(szBuf); i++)
                    szFin[i] = szBuf[i + 1];
                //
                // Strip any commas and write to the logfile
                //
                LogProc->StripCommas(szFin);
                LogProc->LogString(",%s,\r\n", szFin);
            }
            else
                LogProc->LogString(",Unknown,\r\n");
        }
        else
            LogProc->LogString(",Unknown,\r\n");
            
        if(szBuf)
            HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szBuf);
    }
    else
        LogProc->LogString(",Unknown,\r\n");


    CloseHandle(hFile);
    }

    if(szString)
        HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, szString);
        
    osv = (LPOSVERSIONINFO)HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(OSVERSIONINFO));
    
    if(!osv)
    {
        LogProc->LogString(",#OS_Major_Version,,\r\n,Unknown,\r\n" ",#OS_Minor_Version,,\r\n,Unknown,\r\n" ",#OS_Build_Number,,\r\n,Unknown,\r\n" ",#OS_Platform_ID,,\r\n,Unknown,\r\n" ",#OS_Extra_Info,,\r\n,Unknown,\r\n");
    }
    else
    {
        osv->dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(osv);
        LogProc->StripCommas(osv->szCSDVersion);
        LogProc->LogString(",#OS_Major_Version,,\r\n,%d,\r\n" ",#OS_Minor_Version,,\r\n,%d,\r\n" ",#OS_Build_Number,,\r\n,%d,\r\n" ",#OS_Platform_ID,,\r\n,%d,\r\n" ",#OS_Extra_Info,,\r\n,%s,\r\n", osv->dwMajorVersion, osv->dwMinorVersion, LOWORD(osv->dwBuildNumber), osv->dwPlatformId, osv->szCSDVersion);
        HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, osv);
    }
}

void CLASS_GeneralInfo::CatLogFile(PTCHAR szFile)
{
    FILE *fFile     = NULL;
    FILE *fOutFile  = NULL;
    PTCHAR szString = NULL;
    
    if( !(fFile = fopen(szFile, "r")))
        return;
        
    if( !(fOutFile = fopen(LogProc->szFile, "a+")))
    {
        fclose(fFile);
        return;
    }
    
    if( !(szString = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 11000)))
    {
        fclose(fFile);
        fclose(fOutFile);
        return;
    }
    
    int iHold;
    
    iHold = fgetc(fFile);
    
    while (EOF != iHold)
    {
        fputc(iHold, fOutFile);
        iHold = fgetc(fFile);
    }

    fclose(fFile);
    fclose(fOutFile);
    HeapFree(GetProcessHeap(), 0, szString);
}

BOOL CLASS_GeneralInfo::LoadResourceFile(PSTR FilePath, PSTR ResName)
{
    HGLOBAL hObj;
    HRSRC hResource;
    LPSTR lpStr;
    DWORD dwSize = 0;
    DWORD dwBytesWritten = 0;
    char ErrorString[MAX_PATH * 4];
    HANDLE hfFile = INVALID_HANDLE_VALUE;
        
    if ( !(hResource = FindResource(NULL, ResName, RT_RCDATA)) ) 
        return FALSE; 
        
    if ( !(hObj = LoadResource(NULL,hResource)) ) 
        return FALSE;
            
    if ( !(lpStr = (LPSTR)LockResource(hObj)) ) 
        return FALSE;
        
    if ( !(dwSize = SizeofResource( NULL, hResource)))
    {
        UnlockResource(hObj);
        return FALSE;
    }
                
    hfFile = CreateFile(FilePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfFile == INVALID_HANDLE_VALUE)
    {
        UnlockResource(hObj);
        return FALSE;
   }
                
   if (!WriteFile(hfFile, lpStr, dwSize, &dwBytesWritten, NULL))
   {
        UnlockResource(hObj);
        CloseHandle(hfFile);
        return FALSE;
    }
                
    UnlockResource(hObj);
    CloseHandle(hfFile);
    return TRUE;
}


PTCHAR GetUniqueFileName( void )
{
	MYTIMESTRUCT MyTime;
    DWORD dwLen = MAX_PATH;
    static TCHAR szUniqueFileName[MAX_PATH] = {'\0'};

    if(!GetComputerName(szUniqueFileName, &dwLen))
        lstrcpy(szUniqueFileName, "ErrorRetrievingComputerName");

    lstrcat(szUniqueFileName+lstrlen(szUniqueFileName), "_");

    if(!GetUserName(szUniqueFileName+lstrlen(szUniqueFileName), &dwLen))
        lstrcat(szUniqueFileName, "ErrorRetrievingUsername");
    
    FillMyTime(&MyTime);

    wsprintf(szUniqueFileName+lstrlen(szUniqueFileName), "_%s%s%s%s%s%s%s.Sysparse", MyTime.szMonth, MyTime.szDay, MyTime.szYear, MyTime.szHour, MyTime.szMinute, MyTime.szSecond, MyTime.szMillisecond);
    return(szUniqueFileName);
}

void FillMyTime(MYTIMESTRUCT *MyTime)
{
	LPSYSTEMTIME lpSystemTime = (LPSYSTEMTIME)malloc(sizeof(LPSYSTEMTIME));
	TCHAR szTemp[MAX_PATH] = {0};

	GetSystemTime(lpSystemTime);
    if(!lpSystemTime)
        return;
        
	if(lpSystemTime->wMonth <= 9)
	{
		lstrcpy(MyTime->szMonth, "0");
		wsprintf(szTemp, "%d", lpSystemTime->wMonth);
		lstrcat(MyTime->szMonth, szTemp);
	}
	else
	{
		wsprintf(szTemp, "%d", lpSystemTime->wMonth);
		lstrcpy(MyTime->szMonth, szTemp);
	}

	ZeroMemory(szTemp, MAX_PATH * sizeof(TCHAR));

	if(lpSystemTime->wDay <= 9)
	{
		lstrcpy(MyTime->szDay, "0");
		wsprintf(szTemp, "%d", lpSystemTime->wDay);
		lstrcat(MyTime->szDay, szTemp);
	}
	else
	{
		wsprintf(szTemp, "%d", lpSystemTime->wDay);
		lstrcpy(MyTime->szDay, szTemp);
	}

	ZeroMemory(szTemp, MAX_PATH * sizeof(TCHAR));

	if(lpSystemTime->wYear <= 9)
	{
		lstrcpy(MyTime->szYear, "0");
		wsprintf(szTemp, "%d", lpSystemTime->wYear);
		lstrcat(MyTime->szYear, szTemp);
	}
	else
	{
		wsprintf(szTemp, "%d", lpSystemTime->wYear);
		lstrcpy(MyTime->szYear, szTemp);
	}

	ZeroMemory(szTemp, MAX_PATH * sizeof(TCHAR));

	if(lpSystemTime->wHour <= 9)
	{
		lstrcpy(MyTime->szHour, "0");
		wsprintf(szTemp, "%d", lpSystemTime->wHour);
		lstrcat(MyTime->szHour, szTemp);
	}
	else
	{
		wsprintf(szTemp, "%d", lpSystemTime->wHour);
		lstrcpy(MyTime->szHour, szTemp);
	}

	ZeroMemory(szTemp, MAX_PATH * sizeof(TCHAR));

	if(lpSystemTime->wMinute <= 9)
	{
		lstrcpy(MyTime->szMinute, "0");
		wsprintf(szTemp, "%d", lpSystemTime->wMinute);
		lstrcat(MyTime->szMinute, szTemp);
	}
	else
	{
		wsprintf(szTemp, "%d", lpSystemTime->wMinute);
		lstrcpy(MyTime->szMinute, szTemp);
	}

	ZeroMemory(szTemp, MAX_PATH * sizeof(TCHAR));

	if(lpSystemTime->wSecond <= 9)
	{
		lstrcpy(MyTime->szSecond, "0");
		wsprintf(szTemp, "%d", lpSystemTime->wSecond);
		lstrcat(MyTime->szSecond, szTemp);
	}
	else
	{
		wsprintf(szTemp, "%d", lpSystemTime->wSecond);
		lstrcpy(MyTime->szSecond, szTemp);
	}

	ZeroMemory(szTemp, MAX_PATH * sizeof(TCHAR));

	if(lpSystemTime->wMilliseconds <= 9)
	{
		lstrcpy(MyTime->szMillisecond, "0");
		wsprintf(szTemp, "%d", lpSystemTime->wMilliseconds);
		lstrcat(MyTime->szMillisecond, szTemp);
	}
	else
	{
		wsprintf(szTemp, "%d", lpSystemTime->wMilliseconds);
		lstrcpy(MyTime->szMillisecond, szTemp);
	}
    if(lpSystemTime)
        free(lpSystemTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sysparse\nt5net.cpp ===
#include "globals.h"

kNT5NetWalk::kNT5NetWalk(kLogFile *Proc, HWND hIn)
{
LogProc=Proc;
hMainWnd=hIn;
}

BOOL kNT5NetWalk::Begin()
{
DWORD dwRet=0;
dwCurrentKey=0;
dwLevel2Key=0;
strcpy(szRootKeyString, "SYSTEM\\CurrentControlSet\\Control\\Network");
dwRet=RegOpenKeyEx(
   HKEY_LOCAL_MACHINE, 
   szRootKeyString,
   0, 
   KEY_READ, 
   &hkeyRoot);
if (dwRet==ERROR_SUCCESS)
   {
//MessageBox(GetFocus(), "Returning REG_SUCCESS", "SP", MB_OK);
   return REG_SUCCESS;
   }      
else 
   {
   char szMessage[1024];
   FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, dwRet, 
      NULL, szMessage, 1024, 0);
   printf("**********\r\n");
   printf("%s[%d] Error: %s", __FILE__, __LINE__, szMessage);
   printf("**********\r\n");
//MessageBox(GetFocus(), "Returning REG_FAIL", "SP", MB_OK);
   return REG_FAILURE;
   }
//else if (dwPlatform==PLATFORM_NT)
//MessageBox(GetFocus(), "Returning REG_FAIL", "SP", MB_OK);
return REG_FAILURE;
}

BOOL kNT5NetWalk::Walk()
{
    DWORD dwIndex = 0;
    PTCHAR szName = NULL;
    DWORD dwSizeName = MAX_PATH * 4;

    LogProc->LogString(",#NT5_Net_Components,,\r\n");
    
    szName = (PTCHAR)malloc(dwSizeName);
    
    if(!szName) {
        return FALSE;
    }
    
    while (ERROR_SUCCESS == RegEnumKeyEx(hkeyRoot, dwIndex, szName, &dwSizeName, NULL, NULL, NULL, NULL))
    {
        TCHAR szFull[MAX_PATH * 4];
        wsprintf(szFull, "SYSTEM\\CurrentControlSet\\Control\\Network\\%s", szName);
        GetKeyValues(szFull);
        SearchSubKeys(szFull);
        dwSizeName = MAX_PATH * 4;
        dwIndex++;
    }
    return TRUE;
}

BOOL kNT5NetWalk::SearchSubKeys(PTCHAR szName)
{
    HKEY hKeyTemp;
    DWORD dwRet = 0;
    PTCHAR szName2 = NULL;
    DWORD dwIndex = 0;
    DWORD dwSizeName = MAX_PATH * 4;
    TCHAR szFull[MAX_PATH * 4];

    if(!szName)
        return FALSE;
        
    szName2 = (PTCHAR)malloc(MAX_PATH * 4);
    
    if(!szName2)
        return FALSE;
        
    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, szName, 0, KEY_READ, &hKeyTemp)) {
        free(szName2);
        return FALSE;
    }
    
    while (ERROR_SUCCESS == RegEnumKeyEx(hKeyTemp, dwIndex, szName2, &dwSizeName, NULL, NULL, NULL, NULL)) {
        wsprintf(szFull, "%s\\%s", szName, szName2);
        GetKeyValues(szFull);
        SearchSubKeys(szFull);
        dwSizeName = MAX_PATH * 4;
        dwIndex++;
    }
    
    free(szName2);
    return TRUE;
}

BOOL kNT5NetWalk::GetKeyValues(char *szName)
{
HKEY hkeyUninstallKey;
char szFullKey[1024];
PUCHAR szProductName=(PUCHAR)malloc(1024);
DWORD dwProductSize=1024;
DWORD dwRet=0;
DWORD dwType=REG_SZ;
strcpy(szFullKey, szRootKeyString);
strcat(szFullKey, "\\");
strcat(szFullKey, szName);
dwRet=RegOpenKeyEx(HKEY_LOCAL_MACHINE, szName, 0, 
   KEY_READ, &hkeyUninstallKey);
if (dwRet==ERROR_SUCCESS)
   {
   dwRet=RegQueryValueEx(hkeyUninstallKey, "ComponentId", NULL, &dwType,
      szProductName, &dwProductSize);
   if (dwRet==ERROR_SUCCESS)
      {
      printf("Product = %s\r\n", szProductName);
LogProc->StripCommas((char*)szProductName);
      LogProc->LogString(",%s,\r\n", szProductName);
      free(szProductName);
      RegCloseKey(hkeyUninstallKey);
      return REG_SUCCESS;
      }         
/*
   else 
      {
      printf("Product = %s\r\n", szName);
LogProc->StripCommas(szName);
      LogProc->LogString(",%s,\r\n", szName);
      free(szProductName);
      RegCloseKey(hkeyUninstallKey);
      return REG_SUCCESS;
      //Check for other ways to get product name
      }
*/
   }
else 
   {
   char szMessage[1024];
   FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, dwRet, 
      NULL, szMessage, 1024, 0);
   printf("**********\r\n");
   printf("%s[%d] Error: %s",__FILE__, __LINE__, szMessage);
   printf("**********\r\n");
   free(szProductName);
   RegCloseKey(hkeyUninstallKey);
   return REG_FAILURE;
   }
free(szProductName);
RegCloseKey(hkeyUninstallKey);
return REG_FAILURE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sysparse\genapwlk.cpp ===
// General app walking helper routines to be used in 9xapwlk.cpp and ntappwlk.cpp
#include "globals.h"
#include <objidl.h>


CLASS_GeneralAppWalk::CLASS_GeneralAppWalk(kLogFile *Proc, HWND hIn)
{
    LogProc=Proc;
    gHandleToMainWindow=hIn;
}

BOOL CLASS_GeneralAppWalk::OpenRegistry(void)
{
   DWORD Return;

   lstrcpy(RootKeyString, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"));
   Return=RegOpenKeyEx(HKEY_LOCAL_MACHINE,
         RootKeyString,
         0,
         KEY_READ,
         &HandleToUninstallKeyRoot);
   if (Return==ERROR_SUCCESS)
   {
      return TRUE;
   }
   else
   {
      return FALSE;
   }
   return TRUE;
}

BOOL CLASS_GeneralAppWalk::Walk(void)
{
if (OpenRegistry())
   {
   CurrentKey=0;
   LogProc->LogString(",#Uninstall_APPS,,\r\n");
   while ( TRUE == NextKey() );
   RegCloseKey(HandleToUninstallKeyRoot);
   }
return WalkStartMenu();
}

BOOL CLASS_GeneralAppWalk::NextKey(void) {
    PTCHAR KeyName = NULL;
    DWORD SizeOfName = MAX_PATH * 4;
    
    if(!GetCurrentWinDir())
        return FALSE;

    KeyName = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * 4);

    if(!KeyName)
        return FALSE;
  
    if (ERROR_SUCCESS != RegEnumKeyEx(HandleToUninstallKeyRoot, CurrentKey, KeyName, &SizeOfName, NULL, NULL, NULL, NULL)) {
        HeapFree(GetProcessHeap(), NULL, KeyName);
        return FALSE;
    }
    
    CurrentKey++;
    GetUninstallValues(KeyName);
    HeapFree(GetProcessHeap(), NULL, KeyName);
    return TRUE;
}

BOOL CLASS_GeneralAppWalk::GetUninstallValues(TCHAR *KeyName)
{
   HKEY UninstallKey;
   char FullKey[1024];
   PUCHAR ProductName=(PUCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024*sizeof(TCHAR));
   DWORD ProductSize=1024;
   DWORD Return=0;
   DWORD Type=REG_SZ;

   lstrcpy(FullKey, RootKeyString);
   lstrcat(FullKey, "\\");
   lstrcat(FullKey, KeyName);
   Return=RegOpenKeyEx(HKEY_LOCAL_MACHINE, FullKey, 0, KEY_READ, &UninstallKey);
   if (ERROR_SUCCESS == Return)
   {
      Return = RegQueryValueEx(UninstallKey, "DisplayName", NULL, &Type,
         ProductName, &ProductSize);
      if (ERROR_SUCCESS == Return)
      {
         LogProc->StripCommas((TCHAR*)ProductName);
//         printf("Product = %s\r\n", ProductName);
         LogProc->LogString(",%s,\r\n", ProductName);
         HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, ProductName);
         RegCloseKey(UninstallKey);
         return TRUE;
      }
      else
      {
//         printf("Product = %s\r\n", szName);
         LogProc->StripCommas((TCHAR*)KeyName);
         LogProc->LogString(",%s,\r\n", KeyName);
         HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, ProductName);
         RegCloseKey(UninstallKey);
         return TRUE;
         //Check for other ways to get product name
      }
   }
   else
   {
      HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, ProductName);
      RegCloseKey(UninstallKey);
      return FALSE;
   }
   HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, ProductName);
   RegCloseKey(UninstallKey);
   return FALSE;
}


BOOL CLASS_GeneralAppWalk::WalkStartMenu(void)
{
    LogProc->LogString(",#StartMenu_APPS,,\r\n");
    PTCHAR Windir = NULL;
    UINT Size = 512;

    if(!GetCurrentWinDir())
        return FALSE;

    Windir = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * 4);
    
    if(!Windir)
        return FALSE;

    wsprintf(Windir, "%s\\Start Menu", g_WindowsDirectory);
    StartMenuLen = (UINT)lstrlen(Windir);
    WalkDir(Windir, NULL);

    wsprintf(Windir, "%s\\profiles", g_WindowsDirectory);
    StartMenuLen = (UINT)lstrlen(Windir);
    WalkDir(Windir, NULL);
    
    wsprintf(Windir, "%s\\Documents and Settings", g_WindowsDirectory);
    StartMenuLen = (UINT)lstrlen(Windir);
    WalkDir(Windir, NULL);

    lstrcpy(Windir, g_WindowsDirectory);
    Windir[2]='\0';
    lstrcat(Windir, "\\Documents and Settings");
    StartMenuLen = (UINT)lstrlen(Windir);
    WalkDir(Windir, NULL);

    /*
    if (S_OK == SHGetFolderPath(NULL, CSIDL_STARTMENU, NULL, SHGFP_TYPE_CURRENT, Windir)) {
        StartMenuLen = lstrlen(Windir);
        WalkDir(Windir, NULL);
    }

    if (S_OK == SHGetFolderPath(NULL, CSIDL_COMMON_STARTMENU,NULL, SHGFP_TYPE_CURRENT, Windir)) {
        StartMenuLen = lstrlen(Windir);
        WalkDir(Windir, NULL);
    }
    */

    HeapFree(GetProcessHeap(), NULL, Windir);
    return TRUE;
}

BOOL CLASS_GeneralAppWalk::WalkDir(TCHAR *TempPath, TCHAR *File)
{
    WORD PathLen;
    PTCHAR Path = NULL;
    HANDLE HandleToSearch;
    WIN32_FIND_DATA FindFile;
    TCHAR CurrentDirectory[MAX_PATH];
    Path = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH *4);

    if(!Path)
        return FALSE;
        
    SetErrorMode (SEM_FAILCRITICALERRORS);
    lstrcpy(Path, TempPath);
    PathLen = (UINT)lstrlen(Path);
    Path = Path + PathLen - 1;

    if (Path[0] != '\\')
        lstrcat(Path, "\\");
    Path = Path - PathLen + 1;

    if (File)
        lstrcat(Path, File);

    if (SetCurrentDirectory(Path))
    {
        GetCurrentDirectory(MAX_PATH, CurrentDirectory);
        HandleToSearch = FindFirstFile("*.*", &FindFile);
        if (lstrcmp(FindFile.cFileName,".") && lstrcmp(FindFile.cFileName,".."))
        {
            if ( FILE_ATTRIBUTE_DIRECTORY == (FindFile.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY))
            {
                WalkDir(Path, FindFile.cFileName);
            }
            else
            {
                TCHAR *cT1 = (TCHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024*sizeof(TCHAR));
                TCHAR *cT2 = (TCHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024*sizeof(TCHAR));
                lstrcpy(cT2, Path);
                if (cT2[lstrlen(cT2)-1] != '\\')
                    lstrcat(cT2, "\\");
                lstrcat(cT2, FindFile.cFileName);
                if (EndsInLnk(cT2))
                    ResolveIt(cT2, cT1);
                HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, cT1);
                HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, cT2);
            }
        }
        while (FindNextFile(HandleToSearch, &FindFile))
        {
            if (lstrcmp(FindFile.cFileName,".") && lstrcmp(FindFile.cFileName,".."))
            {
                if(FILE_ATTRIBUTE_DIRECTORY == (FindFile.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY))
                {
                    PathLen = (UINT)lstrlen(Path);
                    Path = Path + PathLen - 1;
                    if (Path[0] != '\\')
                        lstrcat(Path, "\\");
                    Path = Path - PathLen + 1;
                    WalkDir(Path, FindFile.cFileName);
            }
            else
            {
                TCHAR *cT1 = (TCHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024*sizeof(TCHAR));
                TCHAR *cT2 = (TCHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024*sizeof(TCHAR));
                lstrcpy(cT2, Path);
                if (cT2[lstrlen(cT2)-1] != '\\')
                    lstrcat(cT2, "\\");
                lstrcat(cT2, FindFile.cFileName);
                if (EndsInLnk(cT2))
                {
                    ResolveIt(cT2, cT1);
                }
                HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, cT1);
                HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, cT2);
            }
        }
    }
    FindClose(HandleToSearch);
    }
    HeapFree(GetProcessHeap(), NULL, Path);
    return TRUE;
}

BOOL CLASS_GeneralAppWalk::EndsInLnk(TCHAR *File)
{
TCHAR szTO[1024];
lstrcpy(szTO, File);

if ( (szTO[lstrlen(szTO)-4] == '.') &&
   ((szTO[lstrlen(szTO)-3] == 'l') || (szTO[lstrlen(szTO)-3] == 'L')) &&
   ((szTO[lstrlen(szTO)-2] == 'n') || (szTO[lstrlen(szTO)-2] == 'N')) &&
   ((szTO[lstrlen(szTO)-1] == 'k') || (szTO[lstrlen(szTO)-1] == 'K')) )
   {
   return TRUE;
   }
else return FALSE;
}

HRESULT CLASS_GeneralAppWalk::ResolveIt(LPCSTR LinkFile, LPSTR Path)
{
    HRESULT HandleToResult;
    IShellLink *ShellLink;
    WIN32_FIND_DATA wfd;
    UINT uiPrevErrorMode = 0;
#ifdef MAXDEBUG
    LogProc->LogString("Working on %s:\r\n", lpszLinkFile);
#endif

    *Path = '\0';
    HandleToResult = CoInitialize(NULL);
    HandleToResult = CoCreateInstance(  CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                                        IID_IShellLink, (LPVOID *)&ShellLink );
    if (SUCCEEDED(HandleToResult))
    {
        IPersistFile *ppf;
        HandleToResult = ShellLink->QueryInterface(IID_IPersistFile, (LPVOID *)&ppf );
        if (SUCCEEDED(HandleToResult))
        {
            WCHAR wsz[MAX_PATH];
            MultiByteToWideChar( CP_ACP, 0, LinkFile, -1, wsz, MAX_PATH );   // Load the file.
            HandleToResult = ppf->Load(wsz, STGM_READ );
            if (SUCCEEDED(HandleToResult))
            {
//              HandleToResult = ShellLink->Resolve(g_MainWindow, SLR_ANY_MATCH | SLR_NO_UI);
//              if (SUCCEEDED(HandleToResult))
//              {
                    HandleToResult = ShellLink->GetPath(Path, 1024, &wfd, SLGP_SHORTPATH );
                    //              HandleToResult = ShellLink->GetDescription(Path, 1024);
                    WORD wLen=(UINT)lstrlen(Path);
                    Path += wLen - 4;
                    TCHAR szExt[10];
                    lstrcpy (szExt, Path);
                    if ( (szExt[0] == '.') &&
                       ((szExt[1] == 'e') || (szExt[1] == 'E')) &&
                       ((szExt[2] == 'x') || (szExt[2] == 'X')) &&
                       ((szExt[3] == 'e') || (szExt[3] == 'E')) )
        //              if (!lstrcmp(lpszPath, ".EXE"))
                    {
                        uiPrevErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

                        Path -= wLen - 4;
                        LinkFile += StartMenuLen + 1;
    //                  LinkFile[strlen(lpszLinkFile)-4]='\0';
                        TCHAR szTemp[1024];
                        lstrcpy (szTemp, LinkFile);
                        szTemp[lstrlen (szTemp) - 4] = '\0';

                        //crop off preceding \'s
                        if (szTemp[0] == '\\')
                        {
                            TCHAR szTwo[1024];
                            for (DWORD dwi = 0; dwi<(DWORD)lstrlen (szTemp); dwi++)
                            {
                                szTwo[dwi] = szTemp[dwi + 1];
                            }
                            szTwo[dwi + 1] = '\0';
                            lstrcpy (szTemp, szTwo);
                        }
                        //crop off preceding \'s
                        if (szTemp[0] == '\\')
                        {
                            TCHAR szTwo[1024];
                            for (DWORD dwi=0; dwi<(DWORD)lstrlen(szTemp); dwi++)
                            {
                                szTwo[dwi]=szTemp[dwi+1];
                            }
                            szTwo[dwi+1]='\0';
                            lstrcpy(szTemp, szTwo);
                        }
                        // nuke duplicate \'s in file name
                        for (DWORD dwArgh = 0; dwArgh < 5; dwArgh++)
                        {
                            BOOL Glob1, Glob2, Glob3;
                            Glob1 = Glob2 = Glob3 =TRUE;
                            TCHAR szFin[1024];
                            for (DWORD dw1 = 0; (dw1 < (DWORD)lstrlen(szTemp)) && (Glob1 == TRUE); dw1++)
                            {
                                szFin[dw1] = szTemp[dw1];
                                if (szTemp[dw1] == '\\' && szTemp[dw1+1] == '\\')
                                {
                                    for (DWORD dwThree = 0; dwThree < (DWORD)lstrlen(szTemp); dwThree++)
                                    {
                                        szFin[dw1 + dwThree] = szTemp[dw1+dwThree + 1];
                                    }
                                szFin[dwThree + 1] = '\0';
                                lstrcpy (szTemp, szFin);
                                Glob1 = FALSE;
                                }
                            }
                        }

                        LogProc->StripCommas (szTemp);
                        LogProc->LogString(",%s", szTemp);
    #ifdef MAXDEBUG
                        LogProc->LogString("\r\nGetting version: %s\r\n", lpszLinkFile);
    #endif
                        GetAppVer (Path);
                        LinkFile -= StartMenuLen;
                        SetErrorMode(uiPrevErrorMode);

                    }
                    else
                    {
                        Path -= wLen - 4;
                    }
//              }
            }
        }
        ppf->Release();
    }
    ShellLink->Release();
    return HandleToResult;
}

BOOL CLASS_GeneralAppWalk::GetAppVer(LPSTR AppName)
{
    DWORD dwVerInfoSize;
    DWORD dwZero;
    LPVOID lpvFileInfo;
    DWORD dwRetCode;
    PDWORD pdwVerBuf;
    UINT uLen;
    DWORD dwTranslation;
    TCHAR szString[MAX_PATH * 4];
    TCHAR szFullString[MAX_PATH * 4];
    TCHAR szTempString[MAX_PATH * 4];

    dwVerInfoSize = GetFileVersionInfoSize(AppName, &dwZero);

    if (!dwVerInfoSize) {
        LogProc->LogString(",Blank,Blank,Blank,Blank,Blank,\r\n");
        return TRUE;
    }
    
    lpvFileInfo = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwVerInfoSize);

    if(!lpvFileInfo) {
        LogProc->LogString(",Blank,Blank,Blank,Blank,Blank,\r\n");
        return TRUE;
    }        

    dwRetCode = GetFileVersionInfo(AppName, dwZero, dwVerInfoSize, lpvFileInfo);

    if (!dwRetCode)
    {
        LogProc->LogString(",Blank,Blank,Blank,Blank,Blank,\r\n");
        HeapFree(GetProcessHeap(), NULL, lpvFileInfo);
        return TRUE;
    }

    uLen = 0;
    pdwVerBuf = 0;
    dwRetCode = VerQueryValue(lpvFileInfo, (LPSTR)"\\VarFileInfo\\Translation", (LPVOID*)&pdwVerBuf, &uLen);

    if (!dwRetCode || !pdwVerBuf)
    {
        LogProc->LogString(",Blank,Blank,Blank,Blank,Blank,\r\n");
        HeapFree(GetProcessHeap(), NULL, lpvFileInfo);
        return TRUE;
    }
        
    dwTranslation = *pdwVerBuf;

    wsprintf (szString, "\\StringFileInfo\\%04x%04x\\", LOWORD (dwTranslation), HIWORD(dwTranslation));
    wsprintf (szFullString, "%sOriginalFileName", szString);
    
    dwRetCode = VerQueryValue(lpvFileInfo, szFullString, (LPVOID*)&pdwVerBuf, &uLen);

    if (uLen)
    {
        lstrcpy (szTempString, (TCHAR *)pdwVerBuf);
          
        if (0 != lstrlen (szTempString) )
        {
            LogProc->StripCommas(szTempString);
            LogProc->LogString(",%s", szTempString);
        }
        else
        {
            LogProc->LogString(",Blank");
        }
    }
    else
    {
        LogProc->LogString(",Blank");
    }

    wsprintf(szFullString, "%sFileVersion", szString);
    
    dwRetCode = VerQueryValue(lpvFileInfo, szFullString, (LPVOID*)&pdwVerBuf, &uLen);

    if (uLen)
    {
        lstrcpy(szTempString, (TCHAR *)pdwVerBuf);
            
        if (0 != lstrlen(szTempString))
        {
            LogProc->StripCommas(szTempString);
            LogProc->LogString(",%s", szTempString);
        }
        else
        {
            LogProc->LogString(",Blank");
        }
    }
    else
    {
        LogProc->LogString(",Blank");
    }

    wsprintf(szFullString, "%sProductName", szString);
    
    dwRetCode = VerQueryValue(lpvFileInfo, szFullString, (LPVOID*)&pdwVerBuf, &uLen);

    if (uLen)
    {
        lstrcpy(szTempString, (TCHAR *)pdwVerBuf);

        if (0 != lstrlen(szTempString))
        {
            LogProc->StripCommas(szTempString);
            LogProc->LogString(",%s", szTempString);
        }
        else
        {
            LogProc->LogString(",Blank");
        }
    }
    else
    {
        LogProc->LogString(",Blank");
    }
    
    wsprintf(szFullString, "%sProductVersion", szString);
    
    dwRetCode = VerQueryValue(lpvFileInfo, szFullString, (LPVOID*)&pdwVerBuf, &uLen);

    if (uLen)
    {
        lstrcpy(szTempString, (TCHAR *)pdwVerBuf);

        if (0 != strlen(szTempString))
        {
            LogProc->StripCommas(szTempString);
            LogProc->LogString(",%s", szTempString);
        }
        else
        {
            LogProc->LogString(",Blank");
        }
    }
    else
    {
        LogProc->LogString(",Blank");
    }
    
    wsprintf(szFullString, "%sCompanyName", szString);
    
    dwRetCode = VerQueryValue(lpvFileInfo, szFullString, (LPVOID*)&pdwVerBuf, &uLen);

    if (uLen)
    {
        lstrcpy(szTempString, (TCHAR *)pdwVerBuf);

        if (lstrlen(szTempString))
        {
            LogProc->StripCommas(szTempString);
            LogProc->LogString(",%s", szTempString);
        }
        else
        {
            LogProc->LogString(",Blank");
        }
    }
    else
    {
        LogProc->LogString(",Blank");
    }
    
    LogProc->LogString(",\r\n");
    HeapFree(GetProcessHeap(), NULL, lpvFileInfo);
    return TRUE;
}

BOOL CLASS_GeneralAppWalk::GetCurrentWinDir(void)
{
    HINSTANCE hInst2 = NULL;
    LPFNDLLFUNC2 fProc = NULL;
    
    hInst2 = LoadLibraryEx("kernel32.dll", NULL, DONT_RESOLVE_DLL_REFERENCES);

    if(hInst2)
        fProc = (LPFNDLLFUNC2)GetProcAddress(hInst2, "GetSystemWindowsDirectoryA");

    if(fProc) {
        if(!fProc(g_WindowsDirectory, MAX_PATH)) {
            FreeLibrary(hInst2);
            return FALSE;
        }
    }
    else {
        if(!GetWindowsDirectory(g_WindowsDirectory, MAX_PATH))
            return FALSE;
    }
    
    if ( '\\' == g_WindowsDirectory[lstrlen(g_WindowsDirectory) - sizeof(TCHAR)] ) {
        g_WindowsDirectory[lstrlen(g_WindowsDirectory) - sizeof(TCHAR)] = '\0';
    }
    
    if(hInst2)
        FreeLibrary(hInst2);
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sysparse\sysparse.cpp ===
#include "globals.h"
#include "resource.h"
#include "cmdline.h"

HWND g_MainWindow;
HINSTANCE g_GlobalInst;
BOOL g_HideWindow = FALSE;

BOOL CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);
void FillInCombos(void);

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
{
    static char szAppName[] = "SysParse";
    MSG msg;
    SetErrorMode (SEM_FAILCRITICALERRORS);
    SetErrorMode (SEM_NOOPENFILEERRORBOX);

    g_GlobalInst = hInstance;
    g_WalkStartMenu = TRUE;
    g_MainWindow = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_DIALOG_SYSPARSE), NULL, (DLGPROC)WndProc);

    kCommandLine CommandLine;

    //Do we start minimized?
    if ( CommandLine.IsSpecified(TEXT("/m"), TRUE) || CommandLine.IsSpecified(TEXT("-m"), TRUE) )
        g_HideWindow = TRUE;
        

    while (GetMessage (&msg, NULL, 0, 0))
    {
        if (!IsWindow(g_MainWindow) || !IsDialogMessage(g_MainWindow, &msg))
        {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }
    }
    return 0;
}

BOOL CALLBACK WndProc (HWND DlgWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    static HDC hdc;
    PAINTSTRUCT ps;
    BOOL bCreate;

    static kLogFile LogFile;
    static CLASS_GeneralInfo GeneralInfo((kLogFile*)&LogFile, DlgWnd);
    static enum _EnumProfile {eprofile, easset}EnumProfile;
    static enum _EnumBetaID {flocation, fasset, fevent, fbetaid}EnumBetaID;

    switch (iMsg)
    {
        case WM_INITDIALOG:
        {
            EnumProfile = eprofile;
            EnumBetaID = fbetaid;
            g_MainWindow = DlgWnd;
            if ( g_HideWindow == TRUE) {
                ShowWindow(g_MainWindow, SW_HIDE);
            }
            FillInCombos();
            if (!GeneralInfo.FillInArguments())
                PostQuitMessage(0);
            if (TRUE == GeneralInfo.RunMinimized)
                ShowWindow(DlgWnd, SW_MINIMIZE);
            if (TRUE == GeneralInfo.AutoRun)
                SetTimer(DlgWnd, 20, 20, NULL);
        }
        case WM_CREATE:
            return 0;
        case WM_DESTROY:
            PostQuitMessage (0);
            return 0;
        case WM_CLOSE:
            PostQuitMessage (0);
            return 0;
        case BN_CLICKED:
            return 0;
        case WM_TIMER:
        {
            switch (wParam)
            {
                case 1:
                    return 0;
                break;
                case 20:
                    KillTimer(DlgWnd, 20);
                    //do autorun stuff here.                    
                    GeneralInfo.Go();
                    SendMessage(DlgWnd, WM_CLOSE, 0, 0);
                    return 0;
                break;
                default:
                    return 0;
                break;
            }
        }
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_BUTTON_GO:
                {
                    GeneralInfo.Go();
                    return 0;
                }
                case IDC_BUTTON_EXIT:
                {
                    PostQuitMessage(0);
                    return 0;
                }
                case IDC_BUTTON_HELP:
                {
                    if (DlgWnd)
                    {
                        MessageBox(DlgWnd, "Copyright (c) 1999 - 2001 Microsoft Corp.\n\nFull instructions for running Sysparse can be found on the Sysparse website.\n\nBe aware that Sysparse may take up to 15 minutes to run and will call what appears to be Windows 2000 Setup and a blank MS-DOS window.\n\nSysparse Website:\nHTTP://winfo.microsoft.com/SysParse\nAccount:SysParser\nPassword:SysParser\n(Account name and password are case sensitive.)\n\nCommandline switches:\n/m - run minimized\n/a - autorun\n/o - automatically overwrite CSV\n/c - use computer name for profile\n/p <filename> - use <filename> as input file\n/w - write log to current directory\n/l - use .log extension rather than .csv\n/n<filename> - use <filename> (and .csv or .log) for output\n/x - suppress platform extension\n/1 through /9 - use text following each number for the corresponding data (spaces not allowed)\n/donotrun1 - Windows 2000 Upgrade Compatibility Report\n/donotrun2 - Extended Windows 2000 Device Analysis\n/s - Do not do app walk", "Sysparse", MB_OK);
                    }
                    return 0;
                }
                case IDC_COMBO_SITEID:
                {
                    TCHAR Temp[MAX_PATH];
                    HWND HandleToControl;
                    DWORD dwCR;

                    HandleToControl = (HWND)GetDlgItem(g_MainWindow, IDC_COMBO_SITEID);
                    dwCR = (DWORD)SendMessage(HandleToControl, CB_GETCURSEL, 0, 0);
                    if ((CB_ERR != dwCR))
                    {
                        HWND StaticProfile, StaticBetaID;
                        TCHAR act[MAX_PATH];
                        SendMessage(HandleToControl, CB_GETLBTEXT, dwCR, (LPARAM)(LPCTSTR)act);
                        _tcslwr(act);
                        StaticProfile = GetDlgItem(g_MainWindow, IDC_STATIC_PROFILE);
                        StaticBetaID = GetDlgItem(g_MainWindow, IDC_STATIC_BETAID);
                        if (!lstrcmp(act, TEXT("ntrecon")) || !lstrcmp(act, TEXT("oobe")) || !lstrcmp(act, TEXT("internal")))
                        {
                            SendMessage(StaticProfile, WM_SETTEXT, 0, (LPARAM)"Profile Name:");
                            SendMessage(StaticBetaID, WM_SETTEXT, 0, (LPARAM)"Location:");
                            EnumProfile = eprofile;
                            EnumBetaID = flocation;
                        }
                        else if (!lstrcmp(act, TEXT("whql")))
                        {
                            SendMessage(StaticProfile, WM_SETTEXT, 0, (LPARAM)"Profile Name:");
                            SendMessage(StaticBetaID, WM_SETTEXT, 0, (LPARAM)"Asset #:");
                            EnumProfile = eprofile;
                            EnumBetaID = fasset;
                        }
                        else if (!lstrcmp(act, TEXT("msevent")))
                        {
                            SendMessage(StaticProfile, WM_SETTEXT, 0, (LPARAM)"Profile Name:");
                            SendMessage(StaticBetaID, WM_SETTEXT, 0, (LPARAM)"Event:");
                            EnumProfile = eprofile;
                            EnumBetaID = fevent;
                        }
                        else if (!lstrcmp(act, TEXT("ihv")) || !lstrcmp(act, TEXT("sb")))
                        {
                            SendMessage(StaticProfile, WM_SETTEXT, 0, (LPARAM)"Profile Name:");
                            SendMessage(StaticBetaID, WM_SETTEXT, 0, (LPARAM)"Beta ID:");
                            EnumProfile = eprofile;
                            EnumBetaID = fbetaid;
                        }
                        else if (!lstrcmp(act, TEXT("inventory")))
                        {
                            SendMessage(StaticProfile, WM_SETTEXT, 0, (LPARAM)"Asset #:");
                            SendMessage(StaticBetaID, WM_SETTEXT, 0, (LPARAM)"Location:");
                            EnumProfile = easset;
                            EnumBetaID = flocation;
                        }
                        else
                        {
                            SendMessage(StaticProfile, WM_SETTEXT, 0, (LPARAM)"Profile Name:");
                            SendMessage(StaticBetaID, WM_SETTEXT, 0, (LPARAM)"Beta ID:");
                            EnumProfile = eprofile;
                            EnumBetaID = fbetaid;
                        }
                    }
                    HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                     SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Use either Corp, OEM, SB (System Builder) or BetaSite, depending of your line of business.\nMore Descriptions can be found on the SysParse Web Site (See Help).");
                }
                break;
                case IDC_EDIT_PROFILE:
                {
                    if (EN_SETFOCUS == HIWORD(wParam) )
                    {
                        HWND HandleToControl;
                        HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                        switch (EnumProfile)
                        {
                            case eprofile:
                                SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Unique profile name that describes exactly what the target system is and does.\nExample: \nDev_Machine_Type#2_NT4");
                            break;
                            case easset:
                                SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"MS or Vendor Asset tag on CPU.\nExample: \nV33498");
                            break;
                        }
                    }
                }
                break;
                case IDC_EDIT_BETAID:
                {
                    if (EN_SETFOCUS == HIWORD(wParam) )
                    {
                        HWND HandleToControl;
                        HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                        switch (EnumBetaID)
                        {
                            case fbetaid:
                                SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"BetaID for the user or corporation running SysParse.\nExample: \n441743");
                            break;
                            case flocation:
                                SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Physical location of this machine.\nExample: \n27N/ 2793 / Row 8 Machine 3 or NTRecon Houston Apex Computers");
                            break;
                            case fevent:
                                SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Type or name of event where SysParse is being run.\nExample: \n1-5-99 San Diego Plugfest");
                            break;
                            case fasset:
                                SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"MS or Vendor Asset tag on CPU.\nExample: \nV33498");
                            break;
                        }
                    }
                }
                break;
                case IDC_EDIT_MANUFACTURER:
                {
                    if (EN_SETFOCUS == HIWORD(wParam) )
                    {
                        HWND HandleToControl;
                        HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                        SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Manufacturer of the target system\nExample:\nAwesome Computers");
                    }
                }
                break;
                case IDC_EDIT_CORPORATION:
                {
                    if (EN_SETFOCUS == HIWORD(wParam) )
                    {
                        HWND HandleToControl;
                        HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                        SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Stock ticker name of company running SysParse.  If no stock ticker name is available, spell out the entire name.\nExample: \nMSFT or Halcyon Systems");
                    }
                }
                break;
                case IDC_EDIT_MODEL:
                {
                    if (EN_SETFOCUS == HIWORD(wParam) )
                    {
                        HWND HandleToControl;
                        HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                        SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Model information of the target system.\nExample: \nLaptop 20LMC");
                    }
                }
                break;
                case IDC_COMBO_TYPE:
                {
                    HWND HandleToControl;
                    HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                    SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Example: \nDesktop, Mobile, Server, Workstation");
                }
                break;
                case IDC_EDIT_NUMCOMP:
                {
                    if (EN_SETFOCUS == HIWORD(wParam) )
                    {
                        HWND HandleToControl;
                        HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                        SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Number of computers installed at your site represented by this exact machine profile (for example, 50).\nSystem Manufacturers should set this value to 1.");
                    }
                }
                break;
                case IDC_EDIT_EMAIL:
                {
                    if (EN_SETFOCUS == HIWORD(wParam) )
                    {
                        HWND HandleToControl;
                        HandleToControl = GetDlgItem(g_MainWindow, IDC_STATIC_HELP);
                        SendMessage(HandleToControl, WM_SETTEXT, 0, (LPARAM)"Electronic-mail address of contact responsible for running SysParse\nExample: \njohndoe@microsoft.com");
                    }
                }
                break;
            }
        }
    }
    return 0;
}


void FillInCombos(void)
{
    TCHAR Name[50];
    HWND HandleToControl;

    HandleToControl=GetDlgItem(g_MainWindow, IDC_COMBO_SITEID);
#ifndef SB
    lstrcpy(Name, "");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "CORP");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "OEM");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "BetaSite");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "IHV");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "WHQL");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
#ifdef INTERNAL
    lstrcpy(Name, "NTRECON");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "OOBE");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "WHQL");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "MSEvent");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "Internal");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "Inventory");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "SB");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
#endif //Internal
#endif //SB

#ifdef SB
    lstrcpy(Name, "SB");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
#endif

    HandleToControl = GetDlgItem(g_MainWindow, IDC_COMBO_TYPE);
    lstrcpy(Name, "");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "Desktop");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "Mobile");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "Server");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
    lstrcpy(Name, "Workstation");
    SendMessage(HandleToControl, CB_ADDSTRING, 0, (LPARAM)Name);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\systrack\makefile.inc ===
!IF "$(BUILD_ALT_DIR)" == "d"
SYSTRACK_BIN_DIR=binD
!ELSE
SYSTRACK_BIN_DIR=bin
!ENDIF

copyexe:
    if exist $(_OBJ_DIR)\i386\*.exe copy $(_OBJ_DIR)\i386\*.exe ..\$(SYSTRACK_BIN_DIR)\i386
    if exist $(_OBJ_DIR)\i386\*.dll copy $(_OBJ_DIR)\i386\*.exe ..\$(SYSTRACK_BIN_DIR)\i386
    if exist $(_OBJ_DIR)\Alpha\*.exe copy $(_OBJ_DIR)\Alpha\*.exe ..\$(SYSTRACK_BIN_DIR)\alpha
    if exist $(_OBJ_DIR)\Alpha\*.dll copy $(_OBJ_DIR)\Alpha\*.exe ..\$(SYSTRACK_BIN_DIR)\alpha
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\systrack\process.cxx ===
//                                          
// Systrack - System resource tracking
// Copyright (c) Microsoft Corporation, 1997
//

//
// module: process.cxx
// author: silviuc
// created: Mon Nov 09 16:03:42 1998
//


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <time.h>

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include "assert.hxx"
#include "history.hxx"
#include "table.hxx"
#include "systrack.hxx"


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

#define TRACK_PROCESS_TABLE_SIZE 256
#define TRACK_PROCESS_HISTORY_SIZE 60

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

class TRACK_PROCESS_INFORMATION
{
  public:

    union {
        ULONG Key;
        ULONG Id;
    };

    History<SIZE_T, TRACK_PROCESS_HISTORY_SIZE> Threads;
    History<SIZE_T, TRACK_PROCESS_HISTORY_SIZE> Handles;
    History<SIZE_T, TRACK_PROCESS_HISTORY_SIZE> WorkingSetSize;
    History<SIZE_T, TRACK_PROCESS_HISTORY_SIZE> VirtualSize;
    History<SIZE_T, TRACK_PROCESS_HISTORY_SIZE> PagefileUsage;

  public:

    bool VerifyThreads (SIZE_T DeltaValue) {
        return Threads.Delta (DeltaValue);
    }

    bool VerifyHandles (SIZE_T DeltaValue) {
        return Handles.Delta (DeltaValue);
    }

    bool VerifyWorkingSetSize (SIZE_T DeltaValue) {
        return WorkingSetSize.Delta (DeltaValue);
    }

    bool VerifyVirtualSize (SIZE_T DeltaValue) {
        return VirtualSize.Delta (DeltaValue);
    }

    bool VerifyPagefileUsage (SIZE_T DeltaValue) {
        return PagefileUsage.Delta (DeltaValue);
    }


    void Print (UNICODE_STRING Name) {
        static unsigned Calls = 0;

        if (Calls % 25 == 0)
          {
            printf (" - - - - - - - - - - - - - - - - - - - -");
            printf (" - - - - - - - - - - - - - - - - - - - - \n");
            printf ("%-15s %-5s %-13s %-11s %-11s %-11s %-11s \n", 
                    "Process", "Id", "Handles", "Threads", 
                    "WSet(Mb)", "Vsize(Mb)", "Pfile(Mb)");
            printf (" - - - - - - - - - - - - - - - - - - - -");
            printf (" - - - - - - - - - - - - - - - - - - - - \n");
            fflush( stdout );
          }

        Calls++;

        printf ("%-15ws %-5u ", Name.Buffer, Key);
        printf ("%-6u %-6u %-5u %-5u %-5u %-5u %-5u %-5u %-5u %-5u\n",
                Handles.Last(),
                Handles.First(),
                Threads.Last(),
                Threads.First(),
                WorkingSetSize.Last() / 0x100000,
                WorkingSetSize.First() / 0x100000,
                VirtualSize.Last() / 0x100000,
                VirtualSize.First() / 0x100000,
                PagefileUsage.Last() / 0x100000,
                PagefileUsage.First() / 0x100000);
        fflush( stdout );

        DebugMessage ("systrack: %ws (%u): Hndl: %u +%d, Thrd: %u +%d, "
                      "Wset: %u +%d, Vsize: %u +%d, Pfile: %u +%d\n",
                      Name.Buffer,
                      Key,
                      Handles.Last(),
                      Handles.Last() - Handles.First(),
                      Threads.Last(),
                      Threads.Last() - Threads.First(),
                      WorkingSetSize.Last() / 0x100000,
                      ( (int)WorkingSetSize.Last() - (int)WorkingSetSize.First()) / 0x100000,
                      VirtualSize.Last() / 0x100000,
                      ( (int)VirtualSize.Last() - (int)VirtualSize.First()) / 0x100000,
                      PagefileUsage.Last() / 0x100000,
                      ( (int)PagefileUsage.Last() - (int)PagefileUsage.First()) / 0x100000);
                      
    }
};

typedef TRACK_PROCESS_INFORMATION * PTRACK_PROCESS_INFORMATION;


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

Table<TRACK_PROCESS_INFORMATION, TRACK_PROCESS_TABLE_SIZE> ProcessTable;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

void 
SystemProcessTrack (


    ULONG Period,
    ULONG DeltaHandles,
    ULONG DeltaThreads,
    ULONG DeltaWorkingSetSize,
    SIZE_T DeltaVirtualSize,
    SIZE_T DeltaPagefileUsage)
{
    NTSTATUS Status;
    ULONG RealLength;
    PSYSTEM_PROCESS_INFORMATION Info;
    BOOL FinishNextTime = FALSE;
    BOOL PrintThreads, PrintHandles, PrintWSSize, PrintVirtSize, PrintPageFile;

    for ( ; ; )
      {
        //
        // SystemPoolTagInformation
        //
        
        Info = (PSYSTEM_PROCESS_INFORMATION)QuerySystemProcessInformation();
    
        //
        // Loop over the processes and see if something changed.
        //
        
        for (FinishNextTime = FALSE;
             FinishNextTime == FALSE;
             Info = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)Info + Info->NextEntryOffset)) {

            PTRACK_PROCESS_INFORMATION Process;

            if (Info->NextEntryOffset == 0)
                FinishNextTime = TRUE;

            //
            // Skip over the idle process.
            //
            
            if (Info->UniqueProcessId == 0)
                continue;
            
            //
            // Add process to the process table.
            //
            
            Process = ProcessTable.Add (PtrToUlong(Info->UniqueProcessId));
            assert_ (Process != 0);

            Process->Threads.Add (Info->NumberOfThreads);
            Process->Handles.Add (Info->HandleCount);
            Process->WorkingSetSize.Add (Info->WorkingSetSize);
            Process->VirtualSize.Add (Info->VirtualSize);
            Process->PagefileUsage.Add (Info->PagefileUsage);

            PrintThreads = FALSE;
            if (Process->VerifyThreads (DeltaThreads)) {

                PrintThreads = TRUE;
            }

            PrintHandles = FALSE;
            if (Process->VerifyHandles (DeltaHandles)) {

                PrintHandles = TRUE;
            }

            PrintWSSize = FALSE;
            if (Process->VerifyWorkingSetSize (DeltaWorkingSetSize)) {
                
                PrintWSSize = TRUE;
            }

            PrintVirtSize = FALSE;
            if (Process->VerifyVirtualSize (DeltaVirtualSize)) {
                
                PrintVirtSize = TRUE;
            }

            PrintPageFile = FALSE;
            if (Process->VerifyPagefileUsage (DeltaPagefileUsage)) {

                PrintPageFile = TRUE;
            }

            if( PrintThreads || PrintHandles || PrintWSSize || PrintVirtSize || PrintPageFile ) {
                 
                Process->Print(Info->ImageName);
                
                if( PrintThreads ) {
                    Process->Threads.Reset (Info->NumberOfThreads);
                }

                if( PrintHandles ) {
                    Process->Handles.Reset (Info->HandleCount);
                }

                if( PrintWSSize ) {
                    Process->WorkingSetSize.Reset (Info->WorkingSetSize);
                }

                if( PrintVirtSize ) {
                    Process->VirtualSize.Reset (Info->VirtualSize);
                }

                if( PrintPageFile ) {
                    Process->PagefileUsage.Reset (Info->PagefileUsage);
                }
            }
        }

        //
        // Sleep a little bit.
        //
        
        Sleep (Period);
      }
}


void 
SystemProcessIdTrack (

    ULONG Period,
    ULONG ProcessId,
    ULONG DeltaHandles,
    ULONG DeltaThreads,
    ULONG DeltaWorkingSetSize,
    SIZE_T DeltaVirtualSize,
    SIZE_T DeltaPagefileUsage)
{
    NTSTATUS Status;
    ULONG RealLength;
    PSYSTEM_PROCESS_INFORMATION Info;
    BOOL FinishNextTime = FALSE;
    BOOL PrintThreads, PrintHandles, PrintWSSize, PrintVirtSize, PrintPageFile;

    for ( ; ; )
      {
        //
        // SystemProcessInformation
        //
        
        Info = (PSYSTEM_PROCESS_INFORMATION)QuerySystemProcessInformation();
    
        //
        // Loop over the processes and see if something changed.
        //
        
        for (FinishNextTime = FALSE;
             FinishNextTime == FALSE;
             Info = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)Info + Info->NextEntryOffset)) {

            PTRACK_PROCESS_INFORMATION Process;

            if (Info->NextEntryOffset == 0)
                FinishNextTime = TRUE;

            //
            // Skip over the idle process.
            //
            
            if (Info->UniqueProcessId == 0)
                continue;

            //
            // If this is not the process we want to track
            // skip it.
            //
            
            if ((ULONG_PTR)(Info->UniqueProcessId) != ProcessId)
                continue;

            //
            // Add process to the process table.
            //

            Process = ProcessTable.Add (PtrToUlong(Info->UniqueProcessId));
            assert_ (Process != 0);

            Process->Threads.Add (Info->NumberOfThreads);
            Process->Handles.Add (Info->HandleCount);
            Process->WorkingSetSize.Add (Info->WorkingSetSize);
            Process->VirtualSize.Add (Info->VirtualSize);
            Process->PagefileUsage.Add (Info->PagefileUsage);

            PrintThreads = FALSE;
            if (Process->VerifyThreads (DeltaThreads)) {

                PrintThreads = TRUE;
            }

            PrintHandles = FALSE;
            if (Process->VerifyHandles (DeltaHandles)) {

                PrintHandles = TRUE;
            }

            PrintWSSize = FALSE;
            if (Process->VerifyWorkingSetSize (DeltaWorkingSetSize)) {
                
                PrintWSSize = TRUE;
            }

            PrintVirtSize = FALSE;
            if (Process->VerifyVirtualSize (DeltaVirtualSize)) {
                
                PrintVirtSize = TRUE;
            }

            PrintPageFile = FALSE;
            if (Process->VerifyPagefileUsage (DeltaPagefileUsage)) {

                PrintPageFile = TRUE;
            }

            if( PrintThreads || PrintHandles || PrintWSSize || PrintVirtSize || PrintPageFile ) {
                 
                Process->Print(Info->ImageName);
                
                if( PrintThreads ) {
                    Process->Threads.Reset (Info->NumberOfThreads);
                }

                if( PrintHandles ) {
                    Process->Handles.Reset (Info->HandleCount);
                }

                if( PrintWSSize ) {
                    Process->WorkingSetSize.Reset (Info->WorkingSetSize);
                }

                if( PrintVirtSize ) {
                    Process->VirtualSize.Reset (Info->VirtualSize);
                }

                if( PrintPageFile ) {
                    Process->PagefileUsage.Reset (Info->PagefileUsage);
                }
            }
        }

        //
        // Sleep a little bit.
        //
        
        Sleep (Period);
      }
}


//
// end of module: process.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\systrack\pooltag.cxx ===
//                                          
// Systrack - System resource tracking
// Copyright (c) Microsoft Corporation, 1997
//

//
// module: pooltag.cxx
// author: silviuc
// created: Wed Nov 11 13:45:37 1998
//


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <time.h>

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include "assert.hxx"
#include "history.hxx"
#include "table.hxx"
#include "systrack.hxx"
#include "pooltag.hxx"


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

#define TRACK_POOLTAG_TABLE_SIZE 1024
#define TRACK_POOLTAG_HISTORY_SIZE 60

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

class TRACK_POOLTAG_INFORMATION
{
  public:
    
    union {
        UCHAR Tag[4];
        ULONG Key;
    };

    SIZE_T LastNonPagedUsed;
    SIZE_T LastPagedUsed;

    History<SIZE_T, TRACK_POOLTAG_HISTORY_SIZE> PagedUsed;
    History<SIZE_T, TRACK_POOLTAG_HISTORY_SIZE> NonPagedUsed;

  public:

    bool VerifyNonPagedUsed (SIZE_T DeltaValue) {
        return NonPagedUsed.Delta (DeltaValue);
    }

    bool VerifyPagedUsed (SIZE_T DeltaValue) {
        return PagedUsed.Delta (DeltaValue);
    }

    void Print () {

        static unsigned Calls = 0;
        UCHAR * TagChar;
        ULONG FirstIndex, LastIndex;


        TagChar = (UCHAR *)(& Key);

        if (Calls % 25 == 0)
          {
            printf (" - - - - - - - - - - - - - - - - - - - -");
            printf (" - - - - - - - - - - - - - - - - - - - - \n");
            printf ("%-4s  %-16s  %-16s \n", "Tag", "NP pool", "P pool");
            printf (" - - - - - - - - - - - - - - - - - - - -");
            printf (" - - - - - - - - - - - - - - - - - - - - \n");
            fflush( stdout );
          }

        Calls++;

        printf ("%c%c%c%c  ",
                TagChar[0],
                TagChar[1],
                TagChar[2],
                TagChar[3]);

        printf ("%-8u %-8u %-8u %-8u\n",
                NonPagedUsed.Last(),
                NonPagedUsed.First(),
                PagedUsed.Last(),
                PagedUsed.First());
        
        fflush( stdout );

        DebugMessage ("systrack: pool: %c%c%c%c: NP: %u +%d, P: %u +%d\n",
                TagChar[0],
                TagChar[1],
                TagChar[2],
                TagChar[3],
                NonPagedUsed.Last(),
                NonPagedUsed.Last() - NonPagedUsed.First(),
                PagedUsed.Last(),
                PagedUsed.Last() - PagedUsed.First());
    }
};

typedef TRACK_POOLTAG_INFORMATION* PTRACK_POOLTAG_INFORMATION;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

Table<TRACK_POOLTAG_INFORMATION, TRACK_POOLTAG_TABLE_SIZE> PoolTable;

//////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Pool tag table
//////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

void 
SystemPoolTrack (

    ULONG Period,
    ULONG Delta)
{
    NTSTATUS Status;
    ULONG RealLength;
    PSYSTEM_POOLTAG_INFORMATION Info;
    BOOL PagedDelta, NonPagedDelta;

    for ( ; ; )
      {
        //
        // SystemPoolTagInformation
        //
        
        Info = (PSYSTEM_POOLTAG_INFORMATION)QuerySystemPoolTagInformation();
    
        if (Info == NULL) {
          printf ("Probably pool tags are not enabled on this machine.\n");
          exit (1);
        }
    
        //
        // Loop over the tags and see if something changed.
        //
        
        {
            ULONG Index;
          
            for (Index = 0; Index < Info->Count; Index++) {

                PTRACK_POOLTAG_INFORMATION Tag;

                Tag = PoolTable.Add (Info->TagInfo[Index].TagUlong);
                if (Tag == NULL)
                    printf ("Cannot add pool table entry \n");
                  
                Tag->PagedUsed.Add (Info->TagInfo[Index].PagedUsed);
                Tag->NonPagedUsed.Add (Info->TagInfo[Index].NonPagedUsed);

                NonPagedDelta = FALSE;
                if (Tag->VerifyNonPagedUsed (Delta)) {
                    NonPagedDelta = TRUE;
                }

                PagedDelta = FALSE;
                if (Tag->VerifyPagedUsed (Delta)) {
                    PagedDelta = TRUE;
                }

                if( NonPagedDelta || PagedDelta ) {
                    
                    Tag->Print();

                    if( NonPagedDelta ) {
                        Tag->NonPagedUsed.Reset (Info->TagInfo[Index].NonPagedUsed);
                    }

                    if( PagedDelta ) {
                        Tag->PagedUsed.Reset (Info->TagInfo[Index].PagedUsed);
                    }
                }
            }
        }
        
        //
        // Sleep a little bit.
        //

        Sleep (Period);
      }
}

bool MatchTag (

    UCHAR * Pattern,
    UCHAR * Tag)
{
    unsigned Index;

    for (Index = 0; Index < 4; Index++)
      {
        if (Pattern[Index] == '*')
            return true;
        else if (Pattern[Index] == '?')
            continue;
        else if (Tag[Index] == Pattern[Index])
            continue;
        else
            return false;
      }

    return true;
}


void 
SystemPoolTagTrack (

    ULONG Period,
    UCHAR * PatternTag,
    ULONG Delta)
{
    NTSTATUS Status;
    ULONG RealLength;
    PSYSTEM_POOLTAG_INFORMATION Info;
    BOOL NonPagedUsedDelta, PagedUsedDelta;

    for ( ; ; )
      {
        //
        // SystemPoolTagInformation
        //
        
        Info = (PSYSTEM_POOLTAG_INFORMATION)QuerySystemPoolTagInformation();

        if (Info == NULL) {
          printf ("Probably pool tags are not enabled on this machine.\n");
          exit (1);
        }
    
        //
        // Loop over the tags and see if something changed.
        //
        
        {
            ULONG Index;
          
            for (Index = 0; Index < Info->Count; Index++) {

                PTRACK_POOLTAG_INFORMATION Tag;

                if (! MatchTag (PatternTag, (UCHAR *)(& (Info->TagInfo[Index].TagUlong))))
                    continue;

                Tag = PoolTable.Add (Info->TagInfo[Index].TagUlong);
                if (Tag == NULL)
                    printf ("Cannot add pool table entry \n");
                  
                Tag->PagedUsed.Add (Info->TagInfo[Index].PagedUsed);
                Tag->NonPagedUsed.Add (Info->TagInfo[Index].NonPagedUsed);
                
                NonPagedUsedDelta = FALSE;
                if (Tag->VerifyNonPagedUsed (Delta)) {
                    NonPagedUsedDelta = TRUE;
                }

                PagedUsedDelta = FALSE;
                if (Tag->VerifyPagedUsed (Delta)) { 
                    PagedUsedDelta = TRUE;

                }

                if( NonPagedUsedDelta || PagedUsedDelta ) {

                    Tag->Print();

                    if( NonPagedUsedDelta ) {

                        Tag->NonPagedUsed.Reset (Info->TagInfo[Index].NonPagedUsed);
                    }

                    if( PagedUsedDelta ) {
                        Tag->PagedUsed.Reset (Info->TagInfo[Index].PagedUsed);
                    }
                }
            }
        }
        
        //
        // Sleep a little bit.
        //

        Sleep (Period);
      }
}



//
// end of module: pooltag.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\systrack\memory.cxx ===
//                                          
// Systrack - System resource tracking
// Copyright (c) Microsoft Corporation, 1997
//

//
// module: memory.cxx
// author: silviuc
// created: Fri Nov 20 19:41:38 1998
//


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <time.h>

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include "assert.hxx"
#include "history.hxx"
#include "table.hxx"
#include "memory.hxx"
#include "systrack.hxx"



void TrackPerformanceCounter (
    
    char * Name,
    ULONG Id,
    ULONG Period,
    LONG Delta)
{
    PSYSTEM_PERFORMANCE_INFORMATION Info;
    History<ULONG, 60> History;

    for ( ; ; )
      {
        //
        // SystemPerformanceInformation
        //
        
        Info = (PSYSTEM_PERFORMANCE_INFORMATION)QuerySystemPerformanceInformation();

        switch (Id) {

          case TRACK_AVAILABLE_PAGES: History.Add (Info->AvailablePages); break;
          case TRACK_COMMITTED_PAGES: History.Add (Info->CommittedPages); break;
          case TRACK_COMMIT_LIMIT: History.Add (Info->CommitLimit); break;
          case TRACK_PAGE_FAULT_COUNT: History.Add (Info->PageFaultCount); break;
          case TRACK_SYSTEM_CALLS: History.Add (Info->SystemCalls); break;
          case TRACK_TOTAL_SYSTEM_DRIVER_PAGES: History.Add (Info->TotalSystemDriverPages); break;
          case TRACK_TOTAL_SYSTEM_CODE_PAGES: History.Add (Info->TotalSystemCodePages); break;

          default: printf ("Invalid track performance Id \n"); exit (2); break;
        }

        if (Delta < 0) {
          
            //
            // We are looking for decreasing counters
            //

            if ((History.Last() < History.First()) && 
                ( (int)History.First() - (int)History.Last() > -Delta)) {

                printf ("%s: %u -%u \n",
                        Name,
                        History.Last(),
                        History.First() - History.Last());

                fflush( stdout );

                DebugMessage ("systrack: %s: %u -%d \n",
                              Name,
                              History.Last(),
                              History.First() - History.Last());

                History.Reset (History.Last ());
            }
        }
        else {

            //
            // We are looking for increasing counters
            //

            if ((History.Last() > History.First()) && 
                ( (int)History.Last() - (int)History.First() > Delta)) {

                printf ("%s: %u +%u \n",
                        Name,
                        History.Last(),
                        History.Last() - History.First());

                fflush( stdout );

                DebugMessage ("systrack: %s: %u +%d \n",
                              Name,
                              History.Last(),
                              History.Last() - History.First());

                History.Reset (History.Last ());
            }
        }

        //
        // Sleep a little bit.
        //
        
        Sleep (Period);
      }
}



//
// end of module: memory.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sysparse\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sysparse.rc
//
#define IDD_DIALOG_SYSPARSE             101
#define IDR_ACCELERATOR1                103
#define IDC_EDIT_CORPORATION            1000
#define IDC_EDIT_EMAIL                  1001
#define IDC_EDIT_MAKE                   1002
#define IDC_EDIT_MANUFACTURER           1002
#define IDC_EDIT_MODEL                  1003
#define IDC_EDIT_NUMCOMP                1004
#define IDC_EDIT_PROFILE                1005
#define IDC_EDIT_BETAID                 1006
#define IDC_COMBO_SITEID                1011
#define IDC_COMBO_TYPE                  1012
#define IDC_BUTTON_GO                   1013
#define IDC_BUTTON_EXIT                 1014
#define IDC_BUTTON_HELP                 1015
#define IDC_STATIC_PROFILE              1016
#define IDC_STATIC_BETAID               1017
#define IDC_STATIC_STATUS               1018
#define IDC_STATIC_HELP                 1019
#define ID_ACCEL40001                   40001
#define ID_ACCEL40002                   40002
#define ID_ACCEL40003                   40003
#define ID_ACCEL40004                   40004
#define ID_ACCEL40005                   40005
#define ID_ACCEL40007                   40007
#define ID_ACCEL40008                   40008
#define ID_ACCEL40009                   40009
#define ID_ACCEL40010                   40010
#define ID_ACCEL40011                   40011
#define ID_ACCEL40012                   40012
#define ID_ACCEL40013                   40013
#define ID_ACCEL40014                   40014
#define ID_ACCEL40015                   40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1020
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\systrack\systrack.cxx ===
//
// Systrack - System resource tracking
// Copyright (c) Microsoft Corporation, 1998
//

//
// module: systrack.cxx
// author: silviuc
// created: Mon Nov 09 12:20:41 1998
//


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <time.h>

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <common.ver>

#define VERSION_DEFINITION_MODULE
#include "version.hxx"

#define DEBUGINFO_DEFINITION_MODULE
#include "debug.hxx"

#include "pooltag.hxx"
#include "process.hxx"
#include "memory.hxx"
#include "systrack.hxx"

#define BUFFER_SIZE_STEP    ( 128 * 1024 )

void PrintCurrentTime ();
void PrintSystemBasicInformation ();
void PrintSystemPerformanceInformation ();
void PrintSystemProcessInformation (BOOL ShortDump);
void PrintSystemPoolDetailedInformation ();
void PrintSystemPoolTagInformation ();
void PrintProcessStackInformation ();

VOID
GetProcessStackInfo (
    PSYSTEM_PROCESS_INFORMATION Info,
    PSIZE_T MaxSize,
    PSIZE_T TotalSize,
    PBOOL ErrorsFound
    );

//
// Functions:
//
//     Help
//
// Decription:
//
//     Prints help information to the stdout. Exits with status code 1.
//

static void
Help ()
{
    static char help_text [] =
"                                                                          \n"
"systrack - System resource tracking --" BUILD_MACHINE_TAG "\n"
VER_LEGALCOPYRIGHT_STR "\n"
"                                                                          \n"
"    systrack [INFO-CLASS]                                                 \n"
"                                                                          \n"
"    <> : if no class specified, print process information.                \n"
"    /system : print system basic information.                             \n"
"    /process : print process information.                                 \n"
"    /stack : print stack usage information for all processes.             \n"
"    /performance: print performance information.                          \n"
"    /pool : print pool tag information (pool tags should be enabled).     \n"
"    /pooldetailed : print pool information (only checked builds).         \n"
"    /all : print everything.                                              \n"
"                                                                          \n"
"    /trackpool PERIOD DELTA                                               \n"
"    /trackpooltag PERIOD PATTERN DELTA                                    \n"
"    /trackprocess PERIOD HANDLE THREAD WSET VSIZE PFILE                   \n"
"    /trackprocessid PERIOD ID HANDLE THREAD WSET VSIZE PFILE              \n"
"    /trackavailablepages PERIOD DELTA                                     \n"
"    /trackcommittedpages PERIOD DELTA                                     \n"
"    /trackcommitlimit PERIOD DELTA                                        \n"
"    /trackpagefaultcount PERIOD DELTA                                     \n"
"    /tracksystemcalls PERIOD DELTA                                        \n"
"    /tracktotalsystemdriverpages PERIOD DELTA                             \n"
"    /tracktotalsystemcodepages PERIOD DELTA                               \n"
"                                                                          \n"
"    /help TOPIC  detailed help for the topic (e.g. process, trackpool,    \n"
"                 trackprocessid, etc.).                                   \n"
"    ?, /?        help                                                     \n"
"    -version     version information                                      \n"
"                                                                          \n"
"Examples:                                                                 \n"
"                                                                          \n"
"    systrack /trackpool 1000 10000                                        \n"
"                                                                          \n"
"        Polls every 1000ms the kernel pools and will print every pool tag \n"
"        whose pool usage increased by more than 10000 bytes.              \n"
"                                                                          \n"
"    systrack /trackpooltag 1000 \"G*\" 10000                              \n"
"                                                                          \n"
"        Polls every 1000ms the kernel pools and will print every pool tag \n"
"        that matches the pattern if its pool usage increased by more      \n"
"        than 10000 bytes.                                                 \n"
"                                                                          \n"
"    systrack /trackprocess 1000 5 5 1000000 1000000 1000000               \n"
"                                                                          \n"
"        Polls every 1000ms the processes running and prints every process \n"
"        whose handle count increased by more than 5 or thread count       \n"
"        increased by more than 5 or working set size increased by more    \n"
"        than 1000000 or virtual size increased by more than 1000000 or    \n"
"        pagefile usage increased by more than 1000000.                    \n"
"                                                                          \n"
"    systrack /trackprocessid 1000 136 5 5 1000000 1000000 1000000         \n"
"                                                                          \n"
"        Polls every 1000ms the process with id 136 and reports if the     \n"
"        handle count increased by more than 5 or thread count             \n"
"        increased by more than 5 or working set size increased by more    \n"
"        than 1000000 or virtual size increased by more than 1000000 or    \n"
"        pagefile usage increased by more than 1000000.                    \n"
"                                                                          \n"
"                                                                          \n";

    printf (help_text);
    exit (1);
}


//
// Functions:
//
//     DetailedHelp
//
// Decription:
//
//     Prints help information to the stdout for a specific topic.
//     Exits with status code 1.
//

static void
DetailedHelp (

    char * Topic)
{
    char * help_text;

    if (_stricmp (Topic, "system") == 0) {
      help_text =
          "systrack /system                                                     \n"
          "                                                                     \n"
          "                                                                     \n";
    }
    else if (_stricmp (Topic, "process") == 0) {
      help_text =
          "systrack /proces                                                     \n"
          "                                                                     \n"
          "                                                                     \n";
    }
    else if (_stricmp (Topic, "performance") == 0) {
      help_text =
          "systrack /performance                                                \n"
          "                                                                     \n"
          "                                                                     \n";
    }
    else if (_stricmp (Topic, "trackprocess") == 0) {
      help_text =
          "systrack /trackprocess                                               \n"
          "                                                                     \n"
          "                                                                     \n";
    }
    else if (_stricmp (Topic, "trackprocessid") == 0) {
      help_text =
          "systrack /system                                                     \n"
          "                                                                     \n"
          "                                                                     \n";
    }
    else if (_stricmp (Topic, "trackpool") == 0) {
      help_text =
          "systrack /trackpool                                                  \n"
          "                                                                     \n"
          "                                                                     \n";
    }
    else if (_stricmp (Topic, "trackpooltag") == 0) {
      help_text =
          "systrack /trackpooltag                                               \n"
          "                                                                     \n"
          "                                                                     \n";
    }
    else {
      printf ("Unknown help topic %s \n", Topic);
      exit (1);
    }


    printf (help_text, VERSION_INFORMATION_VERSION);
    exit (1);
}


//
// Function:
//
//     main
//
// Description:
//
//     ?, -?, /? - print help information.
//     -version - print version information
//
//     default (system, process, pool)
//     /process
//     /stack
//     /system
//     /performance
//     /pool
//     /pooldetailed
//
//

void _cdecl
main (int argc, char *argv[])
{
    if (argc == 2 && _stricmp (argv[1], "?") == 0)
        Help ();
    else if (argc == 2 && _stricmp (argv[1], "/?") == 0)
        Help ();
    else if (argc == 2 && _stricmp (argv[1], "-?") == 0)
        Help ();
    else if (argc == 2 && _stricmp (argv[1], "-h") == 0)
        Help ();
    else if (argc == 2 && _stricmp (argv[1], "/h") == 0)
        Help ();
    // if (argc == 3 && _stricmp (argv[1], "/help") == 0)
    //     DetailedHelp (argv[2]);

    if (argc == 2 && _stricmp (argv[1], "-version") == 0)
        dump_version_information ();

    try
      {
        //
        // Here comes the code ...
        //

        PrintCurrentTime ();

        if (argc == 1)
          {
            //
            // <> default options
            //

            // PrintSystemBasicInformation ();
            PrintSystemProcessInformation (TRUE);
            // PrintSystemPoolTagInformation ();
          }
        else if (argc == 2 && _stricmp (argv[1], "/stack") == 0)
          {
            //
            // /stack option
            //

            PrintProcessStackInformation ();
          }
        else if (argc == 2 && _stricmp (argv[1], "/all") == 0)
          {
            //
            // /all option
            //

            PrintSystemBasicInformation ();
            PrintSystemPerformanceInformation ();
            PrintSystemProcessInformation (FALSE);
            PrintSystemPoolTagInformation ();
            PrintSystemPoolDetailedInformation ();
          }
        else if (argc == 4 && _stricmp (argv[1], "/trackpool") == 0)
          {
            //
            // /trackpool PERIOD DELTA
            //

            ULONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Delta == 0)
                Delta = 8192;

            if (Period == 0)
                Period = 1000;

            SystemPoolTrack (Period, Delta);
          }
        else if (argc == 5 && _stricmp (argv[1], "/trackpooltag") == 0)
          {
            //
            // /trackpooltag PERIOD PATTERN DELTA
            //

            ULONG Delta;
            ULONG Period;
            UCHAR * Pattern;

            Period = atoi (argv[2]);
            Pattern = (UCHAR *)(argv[3]);
            Delta = atoi (argv[4]);

            if (Delta == 0)
                Delta = 8192;

            if (Period == 0)
                Period = 1000;

            SystemPoolTagTrack (Period, Pattern, Delta);
          }
        else if (argc == 8 && _stricmp (argv[1], "/trackprocess") == 0)
          {
            //
            // /trackprocess PERIOD HANDLES THREADS WSET VSIZE PFILE
            //

            ULONG DeltaHandles;
            ULONG DeltaThreads;
            ULONG DeltaWorkingSet;
            SIZE_T DeltaVirtualSize;
            SIZE_T DeltaPagefileUsage;
            ULONG Period;

            Period = atoi (argv[2]);
            DeltaHandles = atoi (argv[3]);
            DeltaThreads = atoi (argv[4]);
            DeltaWorkingSet = atoi (argv[5]);
            DeltaVirtualSize = atoi (argv[6]);
            DeltaPagefileUsage = atoi (argv[7]);

            if (Period == 0)
                Period = 1000;

            if (DeltaHandles == 0)
                DeltaHandles = 32;

            if (DeltaThreads == 0)
                DeltaThreads = 8;

            if (DeltaWorkingSet == 0)
                DeltaWorkingSet = 0x100000;

            if (DeltaVirtualSize == 0)
                DeltaVirtualSize = 0x100000;

            if (DeltaPagefileUsage == 0)
                DeltaPagefileUsage = 0x100000;

            SystemProcessTrack (Period,
                                DeltaHandles, DeltaThreads, DeltaWorkingSet,
                                DeltaVirtualSize, DeltaPagefileUsage);
          }
        else if (argc == 9 && _stricmp (argv[1], "/trackprocessid") == 0)
          {
            //
            // /trackprocessid PERIOD ID HANDLES THREADS WSET VSIZE PFILE
            //

            ULONG ProcessId;
            ULONG DeltaHandles;
            ULONG DeltaThreads;
            ULONG DeltaWorkingSet;
            SIZE_T DeltaVirtualSize;
            SIZE_T DeltaPagefileUsage;
            ULONG Period;

            Period = atoi (argv[2]);
            ProcessId = atoi (argv[3]);
            DeltaHandles = atoi (argv[4]);
            DeltaThreads = atoi (argv[5]);
            DeltaWorkingSet = atoi (argv[6]);
            DeltaVirtualSize = atoi (argv[7]);
            DeltaPagefileUsage = atoi (argv[8]);

            if (Period == 0)
                Period = 1000;

            if (ProcessId == 0) {
              printf ("Bad process id %s\n", argv[3]);
              exit (1);
            }

            if (DeltaHandles == 0)
                DeltaHandles = 32;

            if (DeltaThreads == 0)
                DeltaThreads = 8;

            if (DeltaWorkingSet == 0)
                DeltaWorkingSet = 0x100000;

            if (DeltaVirtualSize == 0)
                DeltaVirtualSize = 0x100000;

            if (DeltaPagefileUsage == 0)
                DeltaPagefileUsage = 0x100000;

            SystemProcessIdTrack (Period, ProcessId,
                                  DeltaHandles, DeltaThreads, DeltaWorkingSet,
                                  DeltaVirtualSize, DeltaPagefileUsage);
          }
        else if (argc == 4 && _stricmp (argv[1], "/trackavailablepages") == 0)
          {
            //
            // /trackavailablepages PERIOD DELTA
            //

            LONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Period == 0)
                Period = 1000;

            if (Delta == 0)
                Delta = 100;

            //
            // We track decreasing values therefore delta should be negative.
            //

            TrackPerformanceCounter (argv[1], TRACK_AVAILABLE_PAGES, Period, -Delta);
          }
        else if (argc == 4 && _stricmp (argv[1], "/trackcommittedpages") == 0)
          {
            //
            // /trackcommittedpages PERIOD DELTA
            //

            LONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Period == 0)
                Period = 1000;

            if (Delta == 0)
                Delta = 100;

            //
            // We track increasing values therefore delta should be positive.
            //

            TrackPerformanceCounter (argv[1], TRACK_COMMITTED_PAGES, Period, Delta);
          }
        else if (argc == 4 && _stricmp (argv[1], "/trackcommitlimit") == 0)
          {
            //
            // /trackcommitlimit PERIOD DELTA
            //

            LONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Period == 0)
                Period = 1000;

            if (Delta == 0)
                Delta = 100;

            //
            // We track increasing values therefore delta should be positive.
            //

            TrackPerformanceCounter (argv[1], TRACK_COMMIT_LIMIT, Period, Delta);
          }
        else if (argc == 4 && _stricmp (argv[1], "/trackpagefaultcount") == 0)
          {
            //
            // /trackpagefaultcount PERIOD DELTA
            //

            LONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Period == 0)
                Period = 1000;

            if (Delta == 0)
                Delta = 100;

            //
            // We track increasing values therefore delta should be positive.
            //

            TrackPerformanceCounter (argv[1], TRACK_PAGE_FAULT_COUNT, Period, Delta);
          }
        else if (argc == 4 && _stricmp (argv[1], "/tracksystemcalls") == 0)
          {
            //
            // /tracksystemcalls PERIOD DELTA
            //

            LONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Period == 0)
                Period = 1000;

            if (Delta == 0)
                Delta = 100;

            //
            // We track increasing values therefore delta should be positive.
            //

            TrackPerformanceCounter (argv[1], TRACK_SYSTEM_CALLS, Period, Delta);
          }
        else if (argc == 4 && _stricmp (argv[1], "/tracktotalsystemdriverpages") == 0)
          {
            //
            // /tracktotalsystemdriverpages PERIOD DELTA
            //

            LONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Period == 0)
                Period = 1000;

            if (Delta == 0)
                Delta = 100;

            //
            // We track increasing values therefore delta should be positive.
            //

            TrackPerformanceCounter (argv[1], TRACK_TOTAL_SYSTEM_DRIVER_PAGES, Period, Delta);
          }
        else if (argc == 4 && _stricmp (argv[1], "/tracktotalsystemcodepages") == 0)
          {
            //
            // /tracktotalsystemcodepages PERIOD DELTA
            //

            LONG Delta;
            ULONG Period;

            Period = atoi (argv[2]);
            Delta = atoi (argv[3]);

            if (Period == 0)
                Period = 1000;

            if (Delta == 0)
                Delta = 100;

            //
            // We track increasing values therefore delta should be positive.
            //

            TrackPerformanceCounter (argv[1], TRACK_TOTAL_SYSTEM_CODE_PAGES, Period, Delta);
          }
        else
          {
            for (int Count = 1; Count < argc; Count++)
              {
                if (_stricmp (argv[Count], "/system") == 0)
                    PrintSystemBasicInformation ();
                else if (_stricmp (argv[Count], "/performance") == 0)
                    PrintSystemPerformanceInformation ();
                else if (_stricmp (argv[Count], "/process") == 0)
                    PrintSystemProcessInformation (TRUE);
                else if (_stricmp (argv[Count], "/pool") == 0)
                    PrintSystemPoolTagInformation ();
                else if (_stricmp (argv[Count], "/pooldetailed") == 0)
                    PrintSystemPoolDetailedInformation ();
                else
                    Help ();
              }
          }
      }
    catch (...)
      {
        printf ("unexpected exception ...\n");
        fflush (stdout);
        exit (1);
      }

    exit (0);
}


//
// Function:
//
//     PrintCurrentTime
//
// Description:
//
//     Prints current time, machine name, etc.
//
//

void PrintCurrentTime ()
{
    TCHAR MachineName [32];
    LPCTSTR TimeString;
    time_t Time;
    DWORD Result;

    if (GetEnvironmentVariable (TEXT("COMPUTERNAME"), MachineName, sizeof MachineName) == 0)
        strcpy (MachineName, "unknown");

    time (&Time);
    TimeString = asctime (localtime (&Time));

    printf ("Systrack - System resource tracking, %s\n", VERSION_INFORMATION_VERSION);
    printf ("Machine: %s\n", MachineName);
    printf ("Time: %s\n", TimeString);
    fflush( stdout );
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


//
// Macro:
//
//     _dump_, _dump_quad_ (object, field)
//
// Description:
//
//     Handy macros to dump the fields of a structure.
//

#define _dump_(object,field) printf ("%-30s %08X (%u)\n", #field, (ULONG)(object->field), (ULONG)(object->field))

#define _dump_quad_(object,field) printf ("%-30s %I64X (%I64u)\n", #field, (object->field.QuadPart), (object->field.QuadPart))


//
// Local:
//
//     InfoBuffer
//
// Description:
//
//     Large enough structure to hold theinformation returned by
//     NtQuerySystemInformation. I've opted for this solution because
//     systrack can run under heavy stress conditions and we do not
//     to allocate big chunks of memory dynamically in such a situation.
//
//     Note. If we decide to multithread the application we will need a
//     critical section to protect the information buffer.
//     CRITICAL_SECTION InfoBufferLock;
//

static TCHAR InfoBuffer [0x40000];

//
// Local:
//
//     PoolTagInformationBuffer
//
// Description:
//
//     Buffer for NtQuerySystemInformation( SystemPoolTagInformation ).
//     Its size is grown by QueryPoolTagInformationIterative if necessary.
//     The length of the buffer is held in PoolTagInformationBufferLength.
//

static TCHAR *PoolTagInformationBuffer = NULL;

//
// Local:
//
//     PoolTagInformationBufferLength
//
// Description:
//
//     The current length of PoolTagInformationBuffer.
//

size_t PoolTagInformationBufferLength = 0;


//
// Function:
//
//     QueryPoolTagInformationIterative
//
// Description:
//
// ARGUMENTS:
//
//     CurrentBuffer - a pointer to the buffer currently used for
//                     NtQuerySystemInformation( SystemPoolTagInformation ).
//                     It will be allocated if NULL or its size grown
//                     if necessary.
//
//      CurrentBufferSize - a pointer to a variable that holds the current
//                      size of the buffer.
//
// RETURNS:
//
//      NTSTATUS returned by NtQuerySystemInformation or
//      STATUS_INSUFFICIENT_RESOURCES if the buffer must grow and the
//      heap allocation for it fails.
//

NTSTATUS
QueryPoolTagInformationIterative(
    TCHAR **CurrentBuffer,
    size_t *CurrentBufferSize
    )
{
    size_t NewBufferSize;
    NTSTATUS ReturnedStatus = STATUS_SUCCESS;

    if( CurrentBuffer == NULL || CurrentBufferSize == NULL ) {

        return STATUS_INVALID_PARAMETER;

    }

    if( *CurrentBufferSize == 0 || *CurrentBuffer == NULL ) {

        //
        // there is no buffer allocated yet
        //

        NewBufferSize = sizeof( TCHAR ) * BUFFER_SIZE_STEP;

        *CurrentBuffer = (TCHAR *) malloc( NewBufferSize );

        if( *CurrentBuffer != NULL ) {

            *CurrentBufferSize = NewBufferSize;

        } else {

            //
            // insufficient memory
            //

            ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    //
    // iterate by buffer's size
    //

    while( *CurrentBuffer != NULL ) {

        ReturnedStatus = NtQuerySystemInformation (
            SystemPoolTagInformation,
            *CurrentBuffer,
            (ULONG)*CurrentBufferSize,
            NULL );

        if( ! NT_SUCCESS(ReturnedStatus) ) {

            //
            // free the current buffer
            //

            free( *CurrentBuffer );

            *CurrentBuffer = NULL;

            if (ReturnedStatus == STATUS_INFO_LENGTH_MISMATCH) {

                //
                // try with a greater buffer size
                //

                NewBufferSize = *CurrentBufferSize + BUFFER_SIZE_STEP;

                *CurrentBuffer = (TCHAR *) malloc( NewBufferSize );

                if( *CurrentBuffer != NULL ) {

                    //
                    // allocated new buffer
                    //

                    *CurrentBufferSize = NewBufferSize;

                } else {

                    //
                    // insufficient memory
                    //

                    ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

                    *CurrentBufferSize = 0;

                }

            } else {

                *CurrentBufferSize = 0;

            }

        } else  {

            //
            // NtQuerySystemInformation returned success
            //

            break;

        }
    }

    return ReturnedStatus;
}

//
// Function:
//
//     QuerySystemPoolTagInformation
//
// Description:
//
//     Fills InfoBuffer with SystemPoolTagInformation and returns
//     a pointer to it.
//

PVOID
QuerySystemPoolTagInformation ()
{
    NTSTATUS Status;
    ULONG RealLength;

    //
    // SystemPoolTagInformation
    //

    Status = QueryPoolTagInformationIterative(
        &PoolTagInformationBuffer,
        &PoolTagInformationBufferLength );

    if (! NT_SUCCESS(Status))
        printf ("NtQuerySystemInformation(pooltag): error %08X\n",
            Status);

    return NT_SUCCESS(Status) ? PoolTagInformationBuffer : NULL;
}


//
// Function:
//
//     QuerySystemProcessInformation
//
// Description:
//
//     Fills InfoBuffer with SystemProcessInformation and returns
//     a pointer to it.
//

PVOID
QuerySystemProcessInformation ()
{
    NTSTATUS Status;
    ULONG RealLength;

    //
    // SystemProcessInformation
    //

    Status = NtQuerySystemInformation (
        SystemProcessInformation,
        InfoBuffer,
        sizeof InfoBuffer,
        &RealLength);

    if (! NT_SUCCESS(Status))
        printf ("NtQuerySystemInformation(process): error %08X\n",
            Status);

    return NT_SUCCESS(Status) ? InfoBuffer : NULL;
}


//
// Function:
//
//     QuerySystemPerformanceInformation
//
// Description:
//
//     Fills InfoBuffer with SystemPerformanceInformation and returns
//     a pointer to it.
//

PVOID
QuerySystemPerformanceInformation ()
{
    NTSTATUS Status;
    ULONG RealLength;

    //
    // SystemPerformanceInformation
    //

    Status = NtQuerySystemInformation (
        SystemPerformanceInformation,
        InfoBuffer,
        sizeof InfoBuffer,
        &RealLength);

    if (! NT_SUCCESS(Status))
        printf ("NtQuerySystemInformation(performance): error %08X\n",
            Status);

    return NT_SUCCESS(Status) ? InfoBuffer : NULL;
}


//
// Function:
//
//     PrintSystemBasicInformation
//
// Description:
//
//     Prints SystemPerformanceInformation.
//
//

void PrintSystemBasicInformation ()
{
    NTSTATUS Status;
    ULONG RealLength;

    printf ("\n- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    printf ("System basic information \n");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    fflush( stdout );

    //
    // SystemBasicInformation
    //

    Status = NtQuerySystemInformation (
        SystemBasicInformation,
        InfoBuffer,
        sizeof (SYSTEM_BASIC_INFORMATION),
        &RealLength);

    if (! NT_SUCCESS(Status))
      {
        printf ("NtQuerySystemInformation(Basic): error %08X\n", Status);
        return;
      }

    {
      PSYSTEM_BASIC_INFORMATION Info = (PSYSTEM_BASIC_INFORMATION)InfoBuffer;

      _dump_(Info, PageSize);
      _dump_(Info, NumberOfPhysicalPages);
      _dump_(Info, LowestPhysicalPageNumber);
      _dump_(Info, HighestPhysicalPageNumber);
      _dump_(Info, AllocationGranularity);
      _dump_(Info, MinimumUserModeAddress);
      _dump_(Info, MaximumUserModeAddress);
      _dump_(Info, ActiveProcessorsAffinityMask);
      _dump_(Info, NumberOfProcessors);
    }
}


//
// Function:
//
//     PrintSystemPerformanceInformation
//
// Description:
//
//     Prints systemPerformanceInformation.
//

void PrintSystemPerformanceInformation ()
{
    NTSTATUS Status;
    ULONG RealLength;

    printf ("\n- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    printf ("System performance information \n");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    fflush( stdout );

    //
    // SystemPerformanceInformation
    //

    Status = NtQuerySystemInformation (
        SystemPerformanceInformation,
        InfoBuffer,
        sizeof (SYSTEM_PERFORMANCE_INFORMATION),
        &RealLength);

    if (! NT_SUCCESS(Status))
      {
        printf ("NtQuerySystemInformation(Performance): error %08X\n", Status);
        return;
      }

    {
      PSYSTEM_PERFORMANCE_INFORMATION Info = (PSYSTEM_PERFORMANCE_INFORMATION)InfoBuffer;

      _dump_quad_ (Info, IdleProcessTime);
      _dump_quad_ (Info, IoReadTransferCount);
      _dump_quad_ (Info, IoWriteTransferCount);
      _dump_quad_ (Info, IoOtherTransferCount);

      _dump_ (Info, IoReadOperationCount);
      _dump_ (Info, IoWriteOperationCount);
      _dump_ (Info, IoOtherOperationCount);
      _dump_ (Info, AvailablePages);
      _dump_ (Info, CommittedPages);
      _dump_ (Info, CommitLimit);
      _dump_ (Info, PeakCommitment);
      _dump_ (Info, PageFaultCount);
      _dump_ (Info, CopyOnWriteCount);
      _dump_ (Info, TransitionCount);
      _dump_ (Info, CacheTransitionCount);
      _dump_ (Info, DemandZeroCount);
      _dump_ (Info, PageReadCount);
      _dump_ (Info, PageReadIoCount);
      _dump_ (Info, CacheReadCount);
      _dump_ (Info, CacheIoCount);
      _dump_ (Info, DirtyPagesWriteCount);
      _dump_ (Info, DirtyWriteIoCount);
      _dump_ (Info, MappedPagesWriteCount);
      _dump_ (Info, MappedWriteIoCount);
      _dump_ (Info, PagedPoolPages);
      _dump_ (Info, NonPagedPoolPages);
      _dump_ (Info, PagedPoolAllocs);
      _dump_ (Info, PagedPoolFrees);
      _dump_ (Info, NonPagedPoolAllocs);
      _dump_ (Info, NonPagedPoolFrees);
      _dump_ (Info, FreeSystemPtes);
      _dump_ (Info, ResidentSystemCodePage);
      _dump_ (Info, TotalSystemDriverPages);
      _dump_ (Info, TotalSystemCodePages);
      _dump_ (Info, NonPagedPoolLookasideHits);
      _dump_ (Info, PagedPoolLookasideHits);
#if 0
      _dump_ (Info, Spare3Count);
#endif
      _dump_ (Info, ResidentSystemCachePage);
      _dump_ (Info, ResidentPagedPoolPage);
      _dump_ (Info, ResidentSystemDriverPage);
      _dump_ (Info, CcFastReadNoWait);
      _dump_ (Info, CcFastReadWait);
      _dump_ (Info, CcFastReadResourceMiss);
      _dump_ (Info, CcFastReadNotPossible);
      _dump_ (Info, CcFastMdlReadNoWait);
      _dump_ (Info, CcFastMdlReadWait);
      _dump_ (Info, CcFastMdlReadResourceMiss);
      _dump_ (Info, CcFastMdlReadNotPossible);
      _dump_ (Info, CcMapDataNoWait);
      _dump_ (Info, CcMapDataWait);
      _dump_ (Info, CcMapDataNoWaitMiss);
      _dump_ (Info, CcMapDataWaitMiss);
      _dump_ (Info, CcPinMappedDataCount);
      _dump_ (Info, CcPinReadNoWait);
      _dump_ (Info, CcPinReadWait);
      _dump_ (Info, CcPinReadNoWaitMiss);
      _dump_ (Info, CcPinReadWaitMiss);
      _dump_ (Info, CcCopyReadNoWait);
      _dump_ (Info, CcCopyReadWait);
      _dump_ (Info, CcCopyReadNoWaitMiss);
      _dump_ (Info, CcCopyReadWaitMiss);
      _dump_ (Info, CcMdlReadNoWait);
      _dump_ (Info, CcMdlReadWait);
      _dump_ (Info, CcMdlReadNoWaitMiss);
      _dump_ (Info, CcMdlReadWaitMiss);
      _dump_ (Info, CcReadAheadIos);
      _dump_ (Info, CcLazyWriteIos);
      _dump_ (Info, CcLazyWritePages);
      _dump_ (Info, CcDataFlushes);
      _dump_ (Info, CcDataPages);
      _dump_ (Info, ContextSwitches);
      _dump_ (Info, FirstLevelTbFills);
      _dump_ (Info, SecondLevelTbFills);
      _dump_ (Info, SystemCalls);

    }
}


//
// Function:
//
//     PrintSystemProcessInformation
//
// Description:
//
//     Prints SystemProcessInformation.
//
// Details:
//
//     These are the fields of a SYSTEM_PROCESS_INFORMATION structure:
//
//     ULONG NextEntryOffset;
//     ULONG NumberOfThreads;
//     LARGE_INTEGER SpareLi1;
//     LARGE_INTEGER SpareLi2;
//     LARGE_INTEGER SpareLi3;
//     LARGE_INTEGER CreateTime;
//     LARGE_INTEGER UserTime;
//     LARGE_INTEGER KernelTime;
//     UNICODE_STRING ImageName;
//     KPRIORITY BasePriority;
//     HANDLE UniqueProcessId;
//     HANDLE InheritedFromUniqueProcessId;
//     ULONG HandleCount;
//     ULONG SessionId;
//     ULONG SpareUl3;
//     SIZE_T PeakVirtualSize;
//     SIZE_T VirtualSize;
//     ULONG PageFaultCount;
//     ULONG PeakWorkingSetSize;
//     ULONG WorkingSetSize;
//     SIZE_T QuotaPeakPagedPoolUsage;
//     SIZE_T QuotaPagedPoolUsage;
//     SIZE_T QuotaPeakNonPagedPoolUsage;
//     SIZE_T QuotaNonPagedPoolUsage;
//     SIZE_T PagefileUsage;
//     SIZE_T PeakPagefileUsage;
//     SIZE_T PrivatePageCount;
//     LARGE_INTEGER ReadOperationCount;
//     LARGE_INTEGER WriteOperationCount;
//     LARGE_INTEGER OtherOperationCount;
//     LARGE_INTEGER ReadTransferCount;
//     LARGE_INTEGER WriteTransferCount;
//     LARGE_INTEGER OtherTransferCount;
//

void PrintSystemProcessInformation (

    BOOL ShortDump)
{
    NTSTATUS Status;
    ULONG RealLength;
    SYSTEM_BASIC_INFORMATION SysInfo;
    BOOL FinishNextTime = FALSE;

    if (ShortDump)
      {
        printf ("\n- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
        printf ("- - - - - - - - - - - - - - - - - - - - - -\n");
        printf ("System process information \n");
        printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
        printf ("- - - - - - - - - - - - - - - - - - - - - -\n");
      }
    else
      {
        printf ("\n- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
        printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
        printf ("System process information \n");
        printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
        printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
      }

    fflush( stdout );

    //
    // SystemBasicInformation
    //

    Status = NtQuerySystemInformation (
        SystemBasicInformation,
        &SysInfo,
        sizeof (SysInfo),
        &RealLength);

    if (! NT_SUCCESS(Status))
      {
        printf ("NtQuerySystemInformation(Basic): error %08X\n", Status);
        return;
      }

    //
    // SystemProcessInformation
    //

    Status = NtQuerySystemInformation (
        SystemProcessInformation,
        InfoBuffer,
        sizeof InfoBuffer,
        &RealLength);

    if (! NT_SUCCESS(Status))
      {
        printf ("NtQuerySystemInformation(Process): error %08X\n", Status);
        return;
      }

    {
      PSYSTEM_PROCESS_INFORMATION Info = (PSYSTEM_PROCESS_INFORMATION)InfoBuffer;

      if (ShortDump)
        {
          printf ("%-15s %-5s %-5s %-4s %-5s %-8s %-8s %-5s %-5s %-6s %-5s %-5s %-5s\n",
                  "Process",
                  "Id",
                  "Sess",
                  "Pri",
                  "Thrds",
                  "Faults",
                  "Handles",
                  "Utime",
                  "Ktime",
                  "Wset",
                  "Vsize",
                  "Pfile",
                  "I/O");

          printf ("%-15s %-5s %-5s %-4s %-5s %-8s %-8s %-5s %-5s %-6s %-5s %-5s %-5s\n",
                  "",
                  "",
                  "",
                  "",
                  "",
                  "",
                  "",
                  "%",
                  "%",
                  "pages",
                  "Mb",
                  "Mb",
                  "x1000");
        }
      else
        {
          printf ("%-15s %-5s %-5s %-4s %-5s %-8s %-8s %-5s %-5s %-6s %-5s %-5s %-5s %-5s %-5s\n",
                  "Process",
                  "Id",
                  "Sess",
                  "Pri",
                  "Thrds",
                  "Faults",
                  "Handles",
                  "Utime",
                  "Ktime",
                  "Wset",
                  "Vsize",
                  "Pfile",
                  "I/O",
                  "Npool",
                  "Ppool");

          printf ("%-15s %-5s %-5s %-4s %-5s %-8s %-8s %-5s %-5s %-6s %-5s %-5s %-5s %-5s %-5s\n",
                  "",
                  "",
                  "",
                  "",
                  "",
                  "",
                  "",
                  "%",
                  "%",
                  "pages",
                  "Mb",
                  "Mb",
                  "x1000",
                  "Mb",
                  "Mb");
        }

      if (ShortDump)
        {
          printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
          printf ("- - - - - - - - - - - - - - - - - - - - - -\n");
        }
      else
        {
          printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
          printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
        }

      fflush( stdout );

      for (FinishNextTime = FALSE ;
           FinishNextTime == FALSE;
           Info = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)Info + Info->NextEntryOffset))
        {
          if (Info->NextEntryOffset == 0)
              FinishNextTime = TRUE;

          //
          // User time vs Kernel time.
          //

          ULONG UserPercent, KernelPercent;

          UserPercent = (ULONG)((Info->UserTime.QuadPart) * 100
              / (Info->UserTime.QuadPart + Info->KernelTime.QuadPart));
          KernelPercent = 100 - UserPercent;

          //
          // I/O total count.
          //

          LARGE_INTEGER IoTotalCount;

          IoTotalCount.QuadPart = Info->ReadOperationCount.QuadPart
              + Info->WriteOperationCount.QuadPart
              + Info->OtherOperationCount.QuadPart;

          IoTotalCount.QuadPart /= 1000;

          //
          // Image name (special case the idle process).
          //

          if (Info->ImageName.Buffer == NULL)
              printf ("%-15s ", "Idle");
          else
              printf ("%-15ws ", Info->ImageName.Buffer);

          //
          // Print the stuff.
          //

          if (ShortDump)
            {
              printf ("%-5I64u %-5u %-4u %-5u %-8u %-8u %-5u %-5u %-6u %-5u %-5u %-5I64u\n",
                      (ULONG64)((ULONG_PTR)(Info->UniqueProcessId)),
                      Info->SessionId,
                      Info->BasePriority,
                      Info->NumberOfThreads,
                      Info->PageFaultCount,
                      Info->HandleCount,
                      UserPercent,
                      KernelPercent,
                      Info->WorkingSetSize / SysInfo.PageSize,
                      Info->VirtualSize / 0x100000,
                      Info->PagefileUsage / 0x100000,
                      (IoTotalCount.QuadPart));
            }
          else
            {
              printf ("%-5I64u %-5u %-4u %-5u %-8u %-8u %-5u %-5u %-6u %-5u %-5u %-5I64u %-5u %-5u\n",
                      (ULONG64)((ULONG_PTR)(Info->UniqueProcessId)),
                      Info->SessionId,
                      Info->BasePriority,
                      Info->NumberOfThreads,
                      Info->PageFaultCount,
                      Info->HandleCount,
                      UserPercent,
                      KernelPercent,
                      Info->WorkingSetSize / SysInfo.PageSize,
                      Info->VirtualSize / 0x100000,
                      Info->PagefileUsage / 0x100000,
                      (IoTotalCount.QuadPart),
                      Info->QuotaNonPagedPoolUsage / 0x100000,
                      Info->QuotaPagedPoolUsage / 0x100000);
            }

          fflush( stdout );
        }
    }
}


//
// Function:
//
//     PrintSystemPoolDetailedInformation
//
// Description:
//
//     Prints systemNonPagedPoolInformation and systemPagedPoolInformation.
//     The function returns something meaningful only on checked builds.
//
//     typedef struct _SYSTEM_POOL_ENTRY {
//         BOOLEAN Allocated;
//         BOOLEAN Spare0;
//         USHORT AllocatorBackTraceIndex;
//         ULONG Size;
//         union {
//             UCHAR Tag[4];
//             ULONG TagUlong;
//             PVOID ProcessChargedQuota;
//         };
//     } SYSTEM_POOL_ENTRY, *PSYSTEM_POOL_ENTRY;
//
//     typedef struct _SYSTEM_POOL_INFORMATION {
//         SIZE_T TotalSize;
//         PVOID FirstEntry;
//         USHORT EntryOverhead;
//         BOOLEAN PoolTagPresent;
//         BOOLEAN Spare0;
//         ULONG NumberOfEntries;
//         SYSTEM_POOL_ENTRY Entries[1];
//     } SYSTEM_POOL_INFORMATION, *PSYSTEM_POOL_INFORMATION;
//

void PrintSystemPoolDetailedInformation ()
{
    NTSTATUS Status;
    ULONG RealLength;

    printf ("\n- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    printf ("System pool detailed information \n");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    fflush( stdout );

    //
    // SystemPoolInformation
    //

    Status = NtQuerySystemInformation (
        SystemNonPagedPoolInformation,
        InfoBuffer,
        sizeof InfoBuffer,
        &RealLength);

    if (! NT_SUCCESS(Status))
      {
        printf ("NtQuerySystemInformation(NonPagedPool): error %08X\n", Status);
        return;
      }

    {
      ULONG Index;
      PSYSTEM_POOL_INFORMATION Info = (PSYSTEM_POOL_INFORMATION)InfoBuffer;

      for (Index = 0; Index < Info->NumberOfEntries; Index++)
        {
          if (Index != 0 && Index%5 == 0)
              printf ("\n");

          printf ("%c%c%c%c %-5u ",
                  Info->Entries[Index].Tag[0],
                  Info->Entries[Index].Tag[1],
                  Info->Entries[Index].Tag[2],
                  Info->Entries[Index].Tag[3],
                  Info->Entries[Index].Size);
        }

      fflush( stdout );
    }
}


//
// Function:
//
//     PrintSystemPoolTagInformation
//
// Description:
//
//     Prints SystemPoolTagInformation.
//
//     typedef struct _SYSTEM_POOLTAG {
//         union {
//             UCHAR Tag[4];
//             ULONG TagUlong;
//         };
//         ULONG PagedAllocs;
//         ULONG PagedFrees;
//         SIZE_T PagedUsed;
//         ULONG NonPagedAllocs;
//         ULONG NonPagedFrees;
//         SIZE_T NonPagedUsed;
//     } SYSTEM_POOLTAG, *PSYSTEM_POOLTAG;
//
//     typedef struct _SYSTEM_POOLTAG_INFORMATION {
//         ULONG Count;
//         SYSTEM_POOLTAG TagInfo[1];
//     } SYSTEM_POOLTAG_INFORMATION, *PSYSTEM_POOLTAG_INFORMATION;
//

void PrintSystemPoolTagInformation ()
{
    NTSTATUS Status;
    ULONG RealLength;

    printf ("\n- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    printf ("System pool tag information \n");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    printf ("%-4s     %-8s %-8s %-8s %-8s %-8s %-8s\n",
            "Tag",
            "NP used", "P used",
            "NP alloc", "NP free",
            "P alloc", "P free");
    printf ("%-4s     %-8s %-8s %-8s %-8s %-8s %-8s\n",
            "",
            "x bytes", "x bytes",
            "x ops", "x ops",
            "x ops", "x ops");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - ");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
    fflush( stdout );

    //
    // SystemPoolTagInformation
    //

    Status = NtQuerySystemInformation (
        SystemPoolTagInformation,
        InfoBuffer,
        sizeof InfoBuffer,
        &RealLength);

    if (! NT_SUCCESS(Status))
      {
        printf ("NtQuerySystemInformation(PoolTag): error %08X\n", Status);
        return;
      }

    {
      ULONG Index;
      PSYSTEM_POOLTAG_INFORMATION Info = (PSYSTEM_POOLTAG_INFORMATION)InfoBuffer;

      for (Index = 0; Index < Info->Count; Index++)
        {
          printf ("%c%c%c%c     %-8u %-8u %-8u %-8u %-8u %-8u\n",
                  Info->TagInfo[Index].Tag[0],
                  Info->TagInfo[Index].Tag[1],
                  Info->TagInfo[Index].Tag[2],
                  Info->TagInfo[Index].Tag[3],
                  Info->TagInfo[Index].NonPagedUsed,
                  Info->TagInfo[Index].PagedUsed,
                  Info->TagInfo[Index].NonPagedAllocs,
                  Info->TagInfo[Index].NonPagedFrees,
                  Info->TagInfo[Index].PagedAllocs,
                  Info->TagInfo[Index].PagedFrees);
        }

      fflush( stdout );
    }
}




//
// Function:
//
//     PrintProcessStackInformation
//
// Description:
//
//     Prints stack usage information for each process.
//



BOOL
ComputeMaxStackInProcess (

    DWORD Pid,
    PSIZE_T MaxSize,
    PSIZE_T TotalSize);


VOID 
PrintProcessStackInformation (
    VOID
    )
{
    NTSTATUS Status;
    ULONG RealLength;
    SYSTEM_BASIC_INFORMATION SysInfo;
    BOOL FinishNextTime = FALSE;
    BOOL ErrorsFound = FALSE;
    SIZE_T MaxStack = 0;
    SIZE_T TotalStack = 0;
    BOOLEAN WasEnabled;

    printf ("\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
    printf ("Process stack information \n");
    printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");

    //
    // SystemBasicInformation
    //

    Status = NtQuerySystemInformation (
                                      SystemBasicInformation,
                                      &SysInfo,
                                      sizeof (SysInfo),
                                      &RealLength);

    if (! NT_SUCCESS(Status)) {
        printf ("NtQuerySystemInformation(Basic): error %08X\n", Status);
        return;
    }

    //
    // SystemProcessInformation
    //

    Status = NtQuerySystemInformation (SystemProcessInformation,
                                       InfoBuffer,
                                       sizeof InfoBuffer,
                                       &RealLength);

    if (! NT_SUCCESS(Status)) {
        printf ("NtQuerySystemInformation(Process): error %08X\n", Status);
        return;
    }

    //
    // Get debug privilege.
    //

    Status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                                TRUE,
                                FALSE,
                                &WasEnabled);

    if (! NT_SUCCESS(Status)) {
        printf("Failed to enable debug privilege (%X) \n", Status);
    }

    {
        PSYSTEM_PROCESS_INFORMATION Info = (PSYSTEM_PROCESS_INFORMATION)InfoBuffer;

        printf ("%-15s %-5s %-5s %-4s %-5s %-8s %-5s %-5s\n",
                "",
                "",
                "",
                "",
                "",
                "",
                "Total",
                "Max");

        printf ("%-15s %-5s %-5s %-4s %-5s %-8s %-5s %-5s\n",
                "Process",
                "Id",
                "Sess",
                "Pri",
                "Thrds",
                "Handles",
                "stack",
                "stack");

        printf ("%-15s %-5s %-5s %-4s %-5s %-8s %-5s %-5s\n",
                "",
                "",
                "",
                "",
                "",
                "",
                "Kb",
                "Kb");

        printf ("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");

        for (FinishNextTime = FALSE ;
            FinishNextTime == FALSE;
            Info = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)Info + Info->NextEntryOffset)) {

            if (Info->NextEntryOffset == 0)
                FinishNextTime = TRUE;

            //
            // User time vs Kernel time.
            //

            ULONG UserPercent, KernelPercent;

            UserPercent = (ULONG)((Info->UserTime.QuadPart) * 100
                                  / (Info->UserTime.QuadPart + Info->KernelTime.QuadPart));
            KernelPercent = 100 - UserPercent;

            //
            // I/O total count.
            //

            LARGE_INTEGER IoTotalCount;

            IoTotalCount.QuadPart = Info->ReadOperationCount.QuadPart
                                    + Info->WriteOperationCount.QuadPart
                                    + Info->OtherOperationCount.QuadPart;

            IoTotalCount.QuadPart /= 1000;

            //
            // Image name (special case the idle process).
            //

            if (Info->ImageName.Buffer == NULL) {

                printf ("%-15s ", "Idle");
            }
            else {

                printf ("%-15ws ", Info->ImageName.Buffer);
            }

            //
            // Compute stack info by iterating all threads in the process.
            //

            GetProcessStackInfo (Info, &MaxStack, &TotalStack, &ErrorsFound);
            
            //
            // Print the stuff.
            //

            printf ("%-5I64u %-5u %-4u %-5u %-8u %-5u %-5u\n",
                    (ULONG64)((ULONG_PTR)(Info->UniqueProcessId)),
                    Info->SessionId,
                    Info->BasePriority,
                    Info->NumberOfThreads,
                    Info->HandleCount,
                    (ULONG)(TotalStack/1024),
                    (ULONG)(MaxStack/1024));

        }
    }

    printf(
        "                                                                      \n"
        " * Total stack: total committed memory used for stacks by all threads \n"
        "       in the process.                                                \n"
        " * Max stack: the biggest committed stack in the process.             \n"
        "                                                                      \n");
}


VOID
GetProcessStackInfo (
    PSYSTEM_PROCESS_INFORMATION Info,
    PSIZE_T MaxSize,
    PSIZE_T TotalSize,
    PBOOL ErrorsFound
    )
{
    ULONG Ti;
    HANDLE Id;
    HANDLE Thread;
    HANDLE Process;
    THREAD_BASIC_INFORMATION ThreadInfo;
    TEB TebInfo;
    SIZE_T BytesRead;
    BOOL ReadResult;
    NTSTATUS Status;
    SIZE_T StackSize;
    BOOLEAN WasEnabled;

    *MaxSize = 0;
    *TotalSize = 0;
    *ErrorsFound = FALSE;

    //
    // Open the process.
    // 

    Process = OpenProcess (PROCESS_VM_READ,
                           FALSE,
                           HandleToUlong(Info->UniqueProcessId));

    if (Process == FALSE) {
        //printf("Failed to open process %p (error %u) \n", Info->UniqueProcessId, GetLastError());
        *ErrorsFound = TRUE;
        return;
    }

    //
    // Iterate all threads in the process and for each determine the
    // thread ID, open the thread and query for TEB address. Finally
    // read user mode stack sizes from the TEB.
    //

    for (Ti = 0; Ti < Info->NumberOfThreads; Ti += 1) {

        Id = ((PSYSTEM_THREAD_INFORMATION)(Info + 1) + Ti)->ClientId.UniqueThread;

        Thread = OpenThread (THREAD_QUERY_INFORMATION, 
                             FALSE, 
                             HandleToUlong(Id));

        if (Thread == NULL) {
            //printf("failed to open thread %u \n", GetLastError());
            *ErrorsFound = TRUE;
            continue;
        }

        Status = NtQueryInformationThread (Thread,
                                           ThreadBasicInformation,
                                           &ThreadInfo,
                                           sizeof ThreadInfo,
                                           NULL);


        if (!NT_SUCCESS(Status)) {
            //printf("query thread failed with %X \n", Status);
            *ErrorsFound = TRUE;
            CloseHandle (Thread);
            continue;
        }

        ReadResult = ReadProcessMemory (Process,
                                        ThreadInfo.TebBaseAddress,
                                        &TebInfo,
                                        sizeof TebInfo,
                                        &BytesRead);

        if (ReadResult == FALSE) {
            //printf("failed to read teb with %u \n", GetLastError());
            *ErrorsFound = TRUE;
            CloseHandle (Thread);
            continue;
        }

        StackSize = (SIZE_T)(TebInfo.NtTib.StackBase) - (SIZE_T)(TebInfo.NtTib.StackLimit);

        *TotalSize += StackSize;

        if (StackSize > *MaxSize) {
            *MaxSize = StackSize;
        }

        CloseHandle (Thread);
    }

    CloseHandle (Process);
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//
// Function:
//
//     DebugMessage
//
// Description:
//
//     Printf like function that prints a message into debugger.
//

void __cdecl DebugMessage (char *fmt, ...)
{
    va_list prms;
    char Buffer [1024];

    va_start (prms, fmt);
    vsprintf (Buffer, fmt, prms);
    OutputDebugString (Buffer);
    va_end (prms);
}


//
// end of module: systrack.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tags\ctutil.c ===
#include "ct.h"
#include <stdio.h>
#include <stddef.h>

HANDLE g_hHeap;

/*********************************************************************
* LogMsg
*
*********************************************************************/
void __cdecl
LogMsg(
    DWORD dwFlags,
    char *pszfmt,
    ...)
{
    static BOOL gfAppending = FALSE;

    va_list va;

    if (dwFlags & LM_ERROR) {
        fprintf(stdout, "Error: ");
    } else if (dwFlags & LM_WARNING) {
        fprintf(stdout, "Warning: ");
    } else if (dwFlags & LM_APIERROR) {
        fprintf(stdout, "API error: ");
    }

    va_start(va, pszfmt);
    vfprintf(stdout, pszfmt, va);
    va_end(va);

    fprintf(stdout, "\n");
}

/*********************************************************************
* Alloc
*
*********************************************************************/
LPVOID
Alloc(
        DWORD size)
{
    LPVOID p;

    p = HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, size);

    return p;
}

/*********************************************************************
* ReAlloc
*
*********************************************************************/
LPVOID
ReAlloc(
    PVOID pSrc,
    DWORD size,
    DWORD newSize)
{
    PVOID pDest;

    pDest = Alloc(newSize);

    if (pDest != NULL) {
        if (size > newSize)
            size = newSize;

        memcpy(pDest, pSrc, size);

        Free(pSrc);
    }
    return pDest;
}

/*********************************************************************
* Free
*
*********************************************************************/
BOOL
Free(
    LPVOID p)
{
    return HeapFree(g_hHeap, 0, p);
}

/*********************************************************************
* InitMemManag
*
*********************************************************************/
BOOL
InitMemManag(
    void)
{
    g_hHeap = HeapCreate(0, 1024 * 1024 * 8, 1024 * 1024 * 64);

    if (g_hHeap == NULL)
        return FALSE;

    return TRUE;
}

/*********************************************************************
* FreeMemManag
*
*********************************************************************/
void
FreeMemManag(
    void)
{
    HeapDestroy(g_hHeap);
    g_hHeap = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tags\ct\ct.c ===
#include "ct.h"

#include <stdlib.h>

FILEMAP gfm;

char* g_pszInputFile;
char* g_pszCaller;
char* g_pszCallee;
int   g_nLevel = 1;
BOOL  g_bApplyUserRule = FALSE;

/*********************************************************************
* ParseCommandLine
*
*********************************************************************/
BOOL
ParseCommandLine(
    int           argc,
    LPSTR         argv[])
{
    char c, *p;
    int  argcParm = argc;

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p) {
                switch (toupper(c)) {
                    case 'I':
                        if (g_pszInputFile != NULL) {
                            LogMsg(LM_ERROR, "-i already specified");
                            goto PrintHelp;
                        }
                        argc--, argv++;
                        g_pszInputFile = *argv;
                        break;

                    case 'R':
                        if (g_pszCaller != NULL) {
                            LogMsg(LM_ERROR, "-r already specified");
                            goto PrintHelp;
                        }
                        argc--, argv++;
                        g_pszCaller = *argv;
                        break;

                    case 'U':
                        g_bApplyUserRule = TRUE;
                        break;

                    case 'E':
                        if (g_pszCallee != NULL) {
                            LogMsg(LM_ERROR, "-e already specified");
                            goto PrintHelp;
                        }
                        argc--, argv++;
                        g_pszCallee = *argv;
                        break;

                    case 'L':
                        {
                            char* pszLevel;

                            argc--, argv++;
                            pszLevel = *argv;

                            g_nLevel = atoi(pszLevel);

                            break;
                        }

                    default:
                        LogMsg(LM_ERROR, "Invalid parameter: %c", c);

                    case '?':
                        goto PrintHelp;
                }
            }
        }
    }

    if (g_pszInputFile == NULL) {
        g_pszInputFile = "calltree.out";
    }

    return TRUE;

PrintHelp:
    LogMsg(LM_PRINT, "\nCaller/Callee tree generator");
    LogMsg(LM_PRINT, "Version 2.0\n");
    LogMsg(LM_PRINT, "Usage: ct [-i input_file] -e function -r function -l level\n");
    LogMsg(LM_PRINT, "\t-i input_file - calltree.out generated by the linker");
    LogMsg(LM_PRINT, "\t-e function   - dump the callee tree for the function");
    LogMsg(LM_PRINT, "\t-r function   - dump the caller tree for the function");
    LogMsg(LM_PRINT, "\t-l level      - how deep to go on the tree");
    LogMsg(LM_PRINT, "\t-u            - allpy ntuser rule[s]");
    LogMsg(LM_PRINT, "\nExamples");
    LogMsg(LM_PRINT, "ct -e xxxMoveEvent -l 10");
    LogMsg(LM_PRINT, "ct -i userk.out -r xxxSwitchDesktop -l 2");
    LogMsg(LM_PRINT, "ct -i w32.out -e xxxMoveEvent -r xxxSwitchDesktop -l 2");
    return FALSE;
}

/*********************************************************************
* main
*
*********************************************************************/
int __cdecl
main(
    int argc,
    char *argv[])
{
    if (!InitMemManag()) {
        LogMsg(LM_ERROR, "Memory initialization failed");
        return 0;
    }

    if (!ParseCommandLine(argc, argv))
        return 0;
    
    if (!CtMapFile(g_pszInputFile, &gfm))
        return 0;

    ProcessInputFile(&gfm);

    if (g_pszCaller != NULL)
        ListCallerTree(g_pszCaller, g_nLevel, 1);
    
    if (g_pszCallee != NULL)
        ListCalleeTree(g_pszCallee, g_nLevel, 1);
    
    if (g_bApplyUserRule) {
        CheckUserRule();
        CheckUnnecessaryXXX();
    }
    
    CtUnmapFile(&gfm);

    FreeMemory();

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tags\ctui\ctui.c ===
/***************************************************************************
* Caller/Callee tree views
*
* Written by Corneliu Lupu
\**************************************************************************/

#include "ct.h"

#include <stdlib.h>

#include "resource.h"

/*
 * Global Variables
 */

HINSTANCE g_hInstance;
HWND      g_hDlg;

HWND      g_hwndTree;

FILEMAP   gfm;
char*     g_pszInputFile;

BOOL      g_bCaller;

char      g_szTag[256];

POINT     g_ptLast;

/*
 * Static Variables
 */

/*********************************************************************
* CtuiDlgProc
*
*********************************************************************/
INT_PTR FAR PASCAL
CtuiDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            RECT  rc;
            HICON hIcon;

            g_hDlg = hdlg;

            hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICON));

            SetClassLongPtr(hdlg, GCLP_HICON, (LONG_PTR)hIcon);

            g_hwndTree = GetDlgItem(hdlg, IDC_TREE);

            SendDlgItemMessage(hdlg, IDC_CALLEE, BM_SETCHECK, BST_CHECKED, 0);

            g_bCaller = FALSE;

            GetWindowRect(hdlg, &rc);
            g_ptLast.x = rc.right - rc.left;
            g_ptLast.y = rc.bottom - rc.top;

            SetTimer(hdlg, (UINT_PTR)hdlg, 100, NULL);

            break;
        }
    case WM_TIMER:
        if (wParam == (WPARAM)hdlg) {
            KillTimer(hdlg, (UINT_PTR)hdlg);

            SetCursor(LoadCursor(NULL, IDC_WAIT));

            ProcessInputFile(&gfm);

            PopulateCombo(GetDlgItem(hdlg, IDC_COMBO1));

            SetCursor(LoadCursor(NULL, IDC_ARROW));
        }
        break;

    case WM_NOTIFY:
        if (wParam == IDC_TREE) {
            LPNMHDR pnm = (LPNMHDR)lParam;

            switch (pnm->code) {
            case TVN_KEYDOWN:
                {
                    HTREEITEM   hItem;
                    TV_ITEM     item;
                    PTag        pTag;
                    LONG_PTR        lItem;
                    TV_KEYDOWN* ptvkd = (TV_KEYDOWN*)lParam;

                    /*
                     * use 'F1' to update the selection in the combobox
                     * with the current item
                     */
                    if (ptvkd->wVKey == VK_F1) {
                        hItem = TreeView_GetSelection(g_hwndTree);

                        if (hItem == NULL)
                            break;

                        /*
                         * Ask for pTag in lParam
                         */
                        item.hItem = hItem;
                        item.mask  = TVIF_PARAM;
                        if (!TreeView_GetItem(g_hwndTree, &item))
                            break;

                        pTag = (PTag)item.lParam;

                        /*
                         * Find the string in the combobox
                         */
                        lItem = SendMessage(GetDlgItem(hdlg, IDC_COMBO1),
                                    CB_FINDSTRINGEXACT,
                                    (WPARAM)-1,
                                    (LPARAM)pTag->pszTag);

                        if (lItem == CB_ERR)
                            break;

                        /*
                         * Select the item found
                         */
                        SendMessage(GetDlgItem(hdlg, IDC_COMBO1),
                                    CB_SETCURSEL,
                                    lItem,
                                    0);

                        /*
                         * Update the tree view
                         */
                        lstrcpy(g_szTag, pTag->pszTag);
                        if (*g_szTag) {
                            CreateTree(g_szTag, g_bCaller);
                        }
                    }
                    break;
                }
            case TVN_GETDISPINFO:
                {
                    TV_DISPINFO* pdi = (TV_DISPINFO*)lParam;
                    PTag         pTag;

                    pTag = (PTag)pdi->item.lParam;

                    /*
                     * Supply the text for the tree view control
                     */
                    if (pdi->item.mask & TVIF_TEXT) {
                        pdi->item.pszText    = pTag->pszTag;
                        pdi->item.cchTextMax = lstrlen(pTag->pszTag) + 1;
                    }

                    break;
                }
            case TVN_ITEMEXPANDING:
                {
                    NM_TREEVIEW* ptv = (NM_TREEVIEW*)lParam;
                    TV_ITEM*     pi;
                    HTREEITEM    hChild;
                    PTag         pTag;

                    pi = &ptv->itemNew;

                    pTag = (PTag)pi->lParam;

                    hChild = TreeView_GetChild(g_hwndTree, pi->hItem);

                    if (hChild == NULL) {
                        AddLevel(pi->hItem, pTag, g_bCaller);
                    }
                    break;
                }
            }
        }
        break;

    case WM_SIZE:
        {
            int  dx, dy;
            RECT rcMaster, rcTree;

            if (g_ptLast.x == 0 && g_ptLast.y == 0)
                return TRUE;

            if (wParam == SIZE_MINIMIZED)
                return TRUE;

            /*
             * Make the dialog resizable
             */
            GetWindowRect(hdlg, &rcMaster);

            dx = (rcMaster.right  - rcMaster.left) - g_ptLast.x;
            dy = (rcMaster.bottom - rcMaster.top) - g_ptLast.y;

            g_ptLast.x = rcMaster.right - rcMaster.left;
            g_ptLast.y = rcMaster.bottom - rcMaster.top;

            GetWindowRect(g_hwndTree, &rcTree);

            SetWindowPos(g_hwndTree,
                         NULL,
                         0,
                         0,
                         rcTree.right - rcTree.left + dx,  // resize x
                         rcTree.bottom - rcTree.top + dy,  // resize y
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

            return TRUE;
        }

    case WM_COMMAND:
        switch (wNotifyCode) {
        case CBN_SELCHANGE:
            {
                INT_PTR nSel = SendMessage(GetDlgItem(hdlg, IDC_COMBO1), CB_GETCURSEL, 0, 0);

                /*
                 * Update the tree view with the new selection
                 */
                SendMessage(GetDlgItem(hdlg, IDC_COMBO1), CB_GETLBTEXT, nSel, (LPARAM)g_szTag);

                if (*g_szTag) {
                    CreateTree(g_szTag, g_bCaller);
                }

                return TRUE;
            }
        }
        switch (wCode) {
        case IDC_CALLER:
            if (!g_bCaller) {
                CreateTree(g_szTag, TRUE);
                g_bCaller = TRUE;
            }
            return TRUE;

        case IDC_CALLEE:
            if (g_bCaller) {
                CreateTree(g_szTag, FALSE);
                g_bCaller = FALSE;
            }
            return TRUE;

        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/*********************************************************************
* WinMain
*
*********************************************************************/
int WINAPI
WinMain(
    HINSTANCE hInst,
    HINSTANCE hInstPrev,
    LPSTR     lpszCmd,
    int       swShow)
{
    InitCommonControls();

    g_hInstance = hInst;

    if (!InitMemManag()) {
        LogMsg(LM_ERROR, "Memory initialization failed");
        return 0;
    }

    g_pszInputFile = lpszCmd;

    if (*g_pszInputFile == 0) {
        g_pszInputFile = "calltree.out";
    }

    if (!CtMapFile(g_pszInputFile, &gfm))
        return 0;

    DialogBox(hInst, MAKEINTRESOURCE(IDD_DIALOG), NULL, CtuiDlgProc);

    CtUnmapFile(&gfm);

    FreeMemory();

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tags\ctfile.c ===
#include "ct.h"
#include <memory.h>

/*********************************************************************
* CtUnmapFile
*
*********************************************************************/
void
CtUnmapFile(
    PFILEMAP pfm)
{
    if (pfm->pmap != NULL) {
        UnmapViewOfFile(pfm->pmap);
        
        pfm->pmap    = NULL;
        pfm->pmapEnd = NULL;
    }

    if (pfm->hmap != NULL) {
        CloseHandle(pfm->hmap);
        pfm->hmap = NULL;
    }

    if (pfm->hfile != INVALID_HANDLE_VALUE) {
        CloseHandle(pfm->hfile);
        pfm->hfile = INVALID_HANDLE_VALUE;
    }
}

/*********************************************************************
* CtMapFile
*
*********************************************************************/
BOOL
CtMapFile(
    char* pszFile,
    PFILEMAP pfm)
{
    DWORD dwFileSize;

    pfm->hfile = CreateFile(
                        pszFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                        NULL);
    
    if (pfm->hfile == INVALID_HANDLE_VALUE) {
        LogMsg(LM_APIERROR, "CreateFile");
        goto CleanupAndFail;
    }

    dwFileSize = GetFileSize(pfm->hfile, NULL);

    if (dwFileSize == 0xFFFFFFFF) {
        LogMsg(LM_APIERROR, "GetFileSize");
        goto CleanupAndFail;
    }

    pfm->hmap = CreateFileMapping(
                        pfm->hfile,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL);
    
    if (pfm->hmap == NULL) {
        LogMsg(LM_APIERROR, "CreateFileMapping");
        goto CleanupAndFail;
    }

    pfm->pmap = MapViewOfFile(
                        pfm->hmap,
                        FILE_MAP_READ,
                        0,
                        0,
                        0);
    
    if (pfm->pmap == NULL) {
        LogMsg(LM_APIERROR, "MapViewOfFile");
        goto CleanupAndFail;
    }
    pfm->pmapEnd = pfm->pmap + dwFileSize;

    return TRUE;

CleanupAndFail:
    LogMsg(LM_ERROR, "CtMapFile failed. File: '%s'", pszFile);
    CtUnmapFile(pfm);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tags\ct.h ===
#include "windows.h"

#ifdef _CTUI
#include "commctrl.h"
#endif // _CTUI

#define LM_ERROR    0x0001
#define LM_WARNING  0x0002
#define LM_PRINT    0x0004
#define LM_APIERROR 0x0008

typedef struct tagFILEMAP {
    HANDLE hfile;
    HANDLE hmap;
    char*  pmap;
    char*  pmapEnd;
} FILEMAP, *PFILEMAP;

typedef struct tagTag {
    char*           pszTag;
    UINT            uCallCount;
    UINT            uCallMax;
    struct tagTag** ppCall;
    UINT            uCalleeCount;
    UINT            uCalleeMax;
    struct tagTag** ppCallee;
    BOOL            bWalked;
} Tag, *PTag;

void __cdecl LogMsg(DWORD dwFlags, char *pszfmt, ...);

void CtUnmapFile(PFILEMAP pfm);
BOOL CtMapFile(char* pszFile, PFILEMAP pfm);

int ProcessInputFile(PFILEMAP pfm);

PTag FindTag(char* pszTag, int* pPos);
void ListCallerTree(char* pszTag, int nLevels, BOOL bIndent);
void ListCalleeTree(char* pszTag, int nLevels, BOOL bIndent);
void CheckUserRule(void);
void CheckUnnecessaryXXX(void);
void FreeMemory(void);


LPVOID Alloc(DWORD size);
LPVOID ReAlloc(PVOID pSrc, DWORD size, DWORD newSize);
BOOL   Free(LPVOID p);
BOOL   InitMemManag(void);
void   FreeMemManag(void);

#ifdef _CTUI
void PopulateCombo(HWND hwnd);

void CreateTree(char* pszRoot, BOOL bCaller);
void AddLevel(HTREEITEM hParent, PTag pTagP, BOOL bCaller);
#endif // _CTUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tags\parser.c ===
#include "ct.h"

#include <conio.h>
#include <stdio.h>

#define MAX_TOKEN_LEN   1024

char   g_szToken[MAX_TOKEN_LEN];
char   g_szTokenLink[MAX_TOKEN_LEN];
int    g_TokenLen = 0;

int  g_TagsCount = 0;
int  g_TagsMax = 0;

#define TAGS_DELTA   128
#define CALL_DELTA   4

PTag* g_pTags; // in order

/*************************************************************************
*   SkipSpaces
*
*   skips all the white chars from the current position down.
*
*************************************************************************/
void
SkipSpaces(
    DWORD* pi,
    char*  p)
{
    DWORD i = *pi;

    while (p[i] == ' ' || p[i] == '\t') {
        i++;
    }
    *pi = i;
}

char g_szFunction[ 256 ];
char g_szClass[ 256 ];


/*************************************************************************
*   LinkName2Name
*
*************************************************************************/
void
LinkName2Name(
    char* szLinkName,
    char* szName)
{
    /*
     * the link name is expected like ?Function@Class@@Params
     * to be converted to Class::Function
     */

    static CHAR arrOperators[][8] =
    {
        "",
        "",
        "new",
        "delete",
        "=",
        ">>",
        "<<",
        "!",
        "==",
        "!="
    };

    DWORD dwCrr = 0;
    DWORD dwCrrFunction = 0;
    DWORD dwCrrClass = 0;
    DWORD dwSize;
    BOOL  fIsCpp = FALSE;
    BOOL  fHasClass = FALSE;
    BOOL  fIsContructor = FALSE;
    BOOL  fIsDestructor = FALSE;
    BOOL  fIsNew = FALSE;
    BOOL  fIsDelete = FALSE;
    BOOL  fIsOperator = FALSE;
    DWORD dwOperatorIndex = 0;

    if (*szLinkName == '@')
        szLinkName++;

    dwSize = lstrlen(szLinkName);

    /*
     * skip '?'
     */
    while (dwCrr < dwSize) {
        if (szLinkName[dwCrr] == '?') {

            dwCrr++;
            fIsCpp = TRUE;
        }
        break;
    }

    /*
     * check to see if this is a special function (like ??0)
     */
    if (fIsCpp) {

        if (szLinkName[dwCrr] == '?') {

            dwCrr++;

            /*
             * the next digit should tell as the function type
             */
            if (isdigit(szLinkName[dwCrr])) {

                switch (szLinkName[dwCrr]) {

                case '0':
                    fIsContructor = TRUE;
                    break;
                case '1':
                    fIsDestructor = TRUE;
                    break;
                default:
                    fIsOperator = TRUE;
                    dwOperatorIndex = szLinkName[dwCrr] - '0';
                    break;
                }
                dwCrr++;
            }
        }
    }

    /*
     * get the function name
     */
    while (dwCrr < dwSize) {

        if (szLinkName[dwCrr] != '@') {

            g_szFunction[dwCrrFunction] = szLinkName[dwCrr];
            dwCrrFunction++;
            dwCrr++;
        } else {
            break;
        }
    }
    g_szFunction[dwCrrFunction] = '\0';

    if (fIsCpp) {
        /*
         * skip '@'
         */
        if (dwCrr < dwSize) {

            if (szLinkName[dwCrr] == '@') {
                dwCrr++;
            }
        }

        /*
         * get the class name (if any)
         */
        while (dwCrr < dwSize) {

            if (szLinkName[dwCrr] != '@') {

                fHasClass = TRUE;
                g_szClass[dwCrrClass] = szLinkName[dwCrr];
                dwCrrClass++;
                dwCrr++;
            } else {
                break;
            }
        }
        g_szClass[dwCrrClass] = '\0';
    }

    /*
     * print the new name
     */
    if (fIsContructor) {
        sprintf(szName, "%s::%s", g_szFunction, g_szFunction);
    } else if (fIsDestructor) {
        sprintf(szName, "%s::~%s", g_szFunction, g_szFunction);
    } else if (fIsOperator) {
        sprintf(szName, "%s::operator %s", g_szFunction, arrOperators[dwOperatorIndex]);
    } else if (fHasClass) {
        sprintf(szName, "%s::%s", g_szClass, g_szFunction);
    } else {
        sprintf(szName, "%s", g_szFunction);
    }
}

/*************************************************************************
*   GetToken
*
*************************************************************************/
int
GetToken(
    DWORD* pi,
        char*  p)
{
    DWORD i = *pi;

    SkipSpaces(&i, p);

    g_TokenLen = 0;

    while (p[i] != '\n' && p[i] != '\r' &&
           p[i] != ' '  && p[i] != '\t') {

        g_szTokenLink[g_TokenLen++] = p[i];

        i++;
    }

    g_szTokenLink[g_TokenLen++] = 0;

    LinkName2Name(g_szTokenLink, g_szToken);
    g_TokenLen = lstrlen(g_szToken);

    *pi = i;

    return g_TokenLen;
}

/*************************************************************************
*   DumpTags
*
*************************************************************************/
void
DumpTags(
    void)
{
    PTag pTag;
    int  i;

    LogMsg(LM_PRINT, "Dump tags\n"
        "--------------------------------------");

    for (i = 0; i < g_TagsCount; i++)
    {
        pTag = g_pTags[i];

        LogMsg(LM_PRINT, "%8x %s", pTag, pTag->pszTag);
    }

    LogMsg(LM_PRINT, "--------------------------------------\n");
}

/*************************************************************************
*   FindTag
*
*************************************************************************/
PTag
FindTag(
    char* pszTag,
    int*  pPos)
{
    int l, m, r;
    int val;

    if (g_TagsCount == 0) {
        if (pPos != NULL)
            *pPos = 0;
        return NULL;
    }

    l = 0;
    r = g_TagsCount - 1;

    while (l <= r) {

        m = (r + l) / 2;

        val = lstrcmp(pszTag, g_pTags[m]->pszTag);

        if (val == 0) {
            if (pPos != NULL)
                *pPos = m;

            return g_pTags[m];
        }

        if (val < 0)
            r = m - 1;
        else
            l = m + 1;
    }

    if (pPos != NULL)
        if (val < 0)
            *pPos = m;
        else
            *pPos = m + 1;

    return NULL;
}

/*************************************************************************
*   ResortTags
*
*************************************************************************/
void
ResortTags(
    PTag pTag)
{
    PTag* pArray;
    int   pos;

    g_TagsCount--;

    FindTag(pTag->pszTag, &pos);

    pArray = g_pTags + pos;

    memmove(pArray + 1, pArray, sizeof(PTag) * (g_TagsCount - pos));

    memmove(pArray, &pTag, sizeof(PTag));

    g_TagsCount++;
}

/*************************************************************************
*   IsInArray
*
*************************************************************************/
BOOL
IsInArray(
    PTag* ppTags,
    int   nCount,
    PTag  pTag)
{
    int i;

    for (i = 0; i < nCount; i++) {
        if (ppTags[i] == pTag)
            return TRUE;
    }
    return FALSE;
}

/*************************************************************************
*   AddToArray
*
*************************************************************************/
BOOL
AddToArray(
    DWORD* pCount,
    DWORD* pMax,
    PVOID* ppArray,
    DWORD  size,
    PVOID  pElem,
    UINT   delta)
{
    PVOID pArray;

    if (*pCount == *pMax) {
        if (*pCount == 0) {
            pArray = Alloc(delta * size);
        } else {
            pArray = ReAlloc(
                *ppArray,
                *pMax * size,
                (*pMax + delta) * size);
        }
        if (pArray == NULL) {
            LogMsg(LM_ERROR, "Out of memory in AddToArray");
            return FALSE;
        }

        *ppArray = pArray;
        (*pMax) += delta;
    } else {
        pArray = *ppArray;
    }

    memmove((char*)pArray + *pCount * size, &pElem, size);

    (*pCount)++;

    return TRUE;
}

/*************************************************************************
*   GetTag
*
*************************************************************************/
PTag
GetTag(
    DWORD* pi,
    char*  p)
{
    PTag pTag;

    /*
     * parse the token first
     */
    GetToken(pi, p);

    /*
     * if the there is a ptag for the token just return it
     */
    pTag = FindTag(g_szToken, NULL);

    if (pTag != NULL)
        return pTag;

    /*
     * create a ptag for the token
     */

    pTag = (PTag)Alloc(sizeof(Tag));
    if (pTag == NULL)
        return NULL;

    pTag->pszTag = (char*)Alloc((g_TokenLen + 1) * sizeof(char));

    lstrcpy(pTag->pszTag, g_szToken);

    if (AddToArray(
            &g_TagsCount,
            &g_TagsMax,
            (PVOID*)&g_pTags,
            sizeof(PTag),
            pTag,
            TAGS_DELTA)) {

        ResortTags(pTag);
    }

    return pTag;
}

/*************************************************************************
*   ProcessLine
*
*************************************************************************/
BOOL
ProcessLine(
    int    nLine,
    DWORD* pi,
    char*  p,
    char*  pEnd)
{
    DWORD  i = *pi;
    int    ind;
    PTag   pTag;
    PTag   pTagC;

    /*
     * ignore the first 4 tokens of a line
     */
    for (ind = 0; ind < 4; ind++)
        GetToken(&i, p);

    pTag = GetTag(&i, p);
    if (pTag) {
        while (p[i] != '\n' && p[i] != '\r') {
            pTagC = GetTag(&i, p);
            if (pTagC) {
                if (!IsInArray(pTag->ppCall, pTag->uCallCount, pTagC)) {
                    AddToArray(
                        &pTag->uCallCount,
                        &pTag->uCallMax,
                        (PVOID*)&pTag->ppCall,
                        sizeof(PTag),
                        (PVOID)pTagC,
                        CALL_DELTA);
                }
        
                if (!IsInArray(pTagC->ppCallee, pTagC->uCalleeCount, pTag)) {
                    AddToArray(
                        &pTagC->uCalleeCount,
                        &pTagC->uCalleeMax,
                        (PVOID*)&pTagC->ppCallee,
                        sizeof(PTag),
                        (PVOID)pTag,
                        CALL_DELTA);
                }
            }
        }
    
        while (p[i] == '\n' || p[i] == '\r') {
            i++;
        }
    
        *pi = i;
    }

    return TRUE;
}

/*************************************************************************
*   RemoveWalkFlags
*
*************************************************************************/
void
RemoveWalkFlags(
    void)
{
    PTag pTag;
    int  i;

    for (i = 0; i < g_TagsCount; i++) {
        pTag = g_pTags[i];

        pTag->bWalked = FALSE;
    }
}

#ifndef _CTUI

/*************************************************************************
*   ListCallerTreeRec
*
*************************************************************************/
void
ListCallerTreeRec(
    PTag pTag,
    int  nLevels,
    int  nIndent)
{
    int  i;
    PTag pTagC;
    char szIndent[256];

    /*
     * prepare for indentation
     */
    if (nIndent > 0) {
        memset(szIndent, ' ', nIndent);
        szIndent[nIndent] = 0;

        LogMsg(LM_PRINT, "%s%s", szIndent, pTag->pszTag);
    }

    /*
     * return if we're done with the levels
     */
    if (nLevels == 0)
        return;

    /*
     * return if we get into recursion
     */
    if (pTag->bWalked == TRUE)
        return;

    pTag->bWalked = TRUE;

    if (nIndent > 0)
        nIndent++;

    /*
     * recurse on the children
     */
    for (i = 0; i < (int)pTag->uCallCount; i++) {

        pTagC = pTag->ppCall[i];

        ListCallerTreeRec(pTagC, nLevels - 1, nIndent);
    }

    return;
}

/*************************************************************************
*   ListCallerTree
*
*************************************************************************/
void
ListCallerTree(
    char* pszTag,
        int   nLevels,
        BOOL  bIndent)
{
    int  i;
    PTag pTag;
    PTag pTagC;

    pTag = FindTag(pszTag, NULL);

    if (pTag == NULL) {
        LogMsg(LM_ERROR, "Tag %s not found", pszTag);
        return;
    }

    LogMsg(LM_PRINT, "-------------------------------------\n"
           "%s calls:", pTag->pszTag);

    if (nLevels <= 0)
        return;

    pTag->bWalked = TRUE;

    for (i = 0; i < (int)pTag->uCallCount; i++) {

        pTagC = pTag->ppCall[i];

        ListCallerTreeRec(pTagC, nLevels - 1, bIndent);
    }

    RemoveWalkFlags();

    LogMsg(LM_PRINT, "-------------------------------------\n");

    return;
}

/*************************************************************************
*   ListCalleeTreeRec
*
*************************************************************************/
void
ListCalleeTreeRec(
    PTag pTag,
    int  nLevels,
    int  nIndent)
{
    int  i;
    PTag pTagC;
    char szIndent[256];

    /*
     * prepare for indentation
     */
    if (nIndent > 0) {
        memset(szIndent, ' ', nIndent);
        szIndent[nIndent] = 0;

        LogMsg(LM_PRINT, "%s%s", szIndent, pTag->pszTag);
    }

    /*
     * return if we're done with the levels
     */
    if (nLevels == 0)
        return;

    /*
     * return if we get into recursion
     */
    if (pTag->bWalked == TRUE)
        return;

    pTag->bWalked = TRUE;

    if (nIndent > 0)
        nIndent++;

    /*
     * recurse on the children
     */
    for (i = 0; i < (int)pTag->uCalleeCount; i++) {

        pTagC = pTag->ppCallee[i];

        ListCalleeTreeRec(pTagC, nLevels - 1, nIndent);
    }

    return;
}

/*************************************************************************
*   ListCalleeTree
*
*************************************************************************/
void
ListCalleeTree(
    char* pszTag,
    int   nLevels,
    BOOL  bIndent)
{
    int  i;
    PTag pTag;
    PTag pTagC;

    pTag = FindTag(pszTag, NULL);

    if (pTag == NULL) {
        LogMsg(LM_ERROR, "Tag %s not found", pszTag);
        return;
    }
    LogMsg(LM_PRINT, "-------------------------------------\n"
           "%s is called by:", pTag->pszTag);

    if (nLevels <= 0)
        return;

    pTag->bWalked = TRUE;

    for (i = 0; i < (int)pTag->uCalleeCount; i++) {

        pTagC = pTag->ppCallee[i];

        ListCalleeTreeRec(pTagC, nLevels - 1, bIndent);
    }

    RemoveWalkFlags();

    LogMsg(LM_PRINT, "-------------------------------------\n");

    return;
}

#endif // _CTUI

/*************************************************************************
*   ProcessInputFile
*
*************************************************************************/
int
ProcessInputFile(
    PFILEMAP pfm)
{
    DWORD i;
    int   nLine = 0;

    i = 0;

    while (i < (DWORD)(pfm->pmapEnd - pfm->pmap - 2)) {
        ProcessLine(nLine++, &i, pfm->pmap, pfm->pmapEnd);
    }

    return 0;
}

/*************************************************************************
*   FreeMemory
*
*************************************************************************/
void
FreeMemory(
    void)
{
    PTag pTag;
    int  i;

    for (i = 0; i < g_TagsCount; i++) {
        pTag = g_pTags[i];

        Free(pTag->pszTag);

        if (pTag->ppCall) {
            Free(pTag->ppCall);
        }
        if (pTag->ppCallee) {
            Free(pTag->ppCallee);
        }
        Free(pTag);
    }
    Free(g_pTags);

    FreeMemManag();
}

#ifndef _CTUI

/*************************************************************************
*   StartsWith
*
*************************************************************************/
BOOL
StartsWith(
    char* pszStart,
    char* pszTag)
{
    int lenS, lenT, i;

    lenS = lstrlen(pszStart);
    lenT = lstrlen(pszTag);

    if (lenS > lenT) {
        return FALSE;
    }

    for (i = 0; i < lenS; i++) {
        if (pszStart[i] != pszTag[i]) {
            return FALSE;
        }
    }
    return TRUE;
}

/*************************************************************************
*   CheckUserRule
*
*   Display functions that do not start with NtUser/zzz/xxx and call
*   functions that start with zzz/xxx
*
*************************************************************************/
void
CheckUserRule(
    void)
{
    int  i, j;
    PTag pTag;
    PTag pTagC;

    LogMsg(LM_PRINT, "-------------------------------------\n"
           "Check for ntuser rule in the kernel\n");

    /*
     * walk the tags to find a non xxx/zzz function that directly
     * calls an xxx/zzz function
     */
    for (i = 0; i < g_TagsCount; i++) {
        pTag = g_pTags[i];

        if (StartsWith("xxx", pTag->pszTag) ||
            StartsWith("zzz", pTag->pszTag) ||
            StartsWith("NtUser", pTag->pszTag)) {
            continue;
        }

        /*
         * see if we didn't already display a message for this tag
         */
        if (pTag->bWalked) {
            continue;
        }

        for (j = 0; j < (int)pTag->uCallCount; j++) {
            pTagC = pTag->ppCall[j];

            if (!StartsWith("xxx", pTagC->pszTag) &&
                !StartsWith("zzz", pTagC->pszTag)) {

                continue;
            }
            LogMsg(LM_PRINT, "%-40s calls : %s",
                   pTag->pszTag, pTagC->pszTag);

            break;
        }
    }
    RemoveWalkFlags();
}

/*************************************************************************
*   CheckUnnecessaryXXX
*
*   Display functions that do not start with NtUser/zzz/xxx and call
*   functions that start with zzz/xxx
*
*************************************************************************/
void
CheckUnnecessaryXXX(
    void)
{
    int  i, j;
    PTag pTag;
    PTag pTagC;

    LogMsg(LM_PRINT, "-------------------------------------\n"
           "Check for unnecessary xxx functions in the kernel\n");

    /*
     * walk the tags to find a non xxx/zzz function that directly
     * calls an xxx/zzz function
     */
    for (i = 0; i < g_TagsCount; i++) {
        pTag = g_pTags[i];

        if (!StartsWith("xxx", pTag->pszTag) &&
            !StartsWith("zzz", pTag->pszTag)) {
            continue;
        }

        /*
         * see if we didn't already display a message for this tag
         */
        if (pTag->bWalked) {
            continue;
        }

        for (j = 0; j < (int)pTag->uCallCount; j++) {
            pTagC = pTag->ppCall[j];

            if (StartsWith("xxx", pTagC->pszTag) ||
                StartsWith("zzz", pTagC->pszTag) ||
                StartsWith("LeaveCrit", pTagC->pszTag)) {

                break;
            }
        }
        if (j >= (int)pTag->uCallCount) {
            LogMsg(LM_PRINT, "%-40s should not be an xxx/zzz function",
                   pTag->pszTag);
        }
    }
    RemoveWalkFlags();
}

#else // _CTUI

/*************************************************************************
*   PopulateCombo
*
*************************************************************************/
void
PopulateCombo(
    HWND hwnd)
{
    PTag pTag;
    int  i;

    for (i = 0; i < g_TagsCount; i++) {
        pTag = g_pTags[i];

        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)pTag->pszTag);
    }
}
#endif // _CTUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tags\ctui\tvutil.c ===
#include "ct.h"

extern HWND g_hwndTree;

HTREEITEM g_hTree;

/*********************************************************************
* AddItem
*
*********************************************************************/
HTREEITEM AddItem(
    HTREEITEM hParent,
    PTag      pTag,
    BOOL      bCaller)
{
    HTREEITEM       hItem;
    TV_ITEM         tvi;
    TV_INSERTSTRUCT is;
  
    // The .pszText, .iImage, and .iSelectedImage are filled in.
    tvi.mask      = TVIF_TEXT | TVIF_PARAM | TVIF_CHILDREN;
    tvi.pszText   = LPSTR_TEXTCALLBACK;
    tvi.lParam    = (LPARAM)pTag;
    
    tvi.cChildren = 0;
    
    if (bCaller) {
        if (pTag->ppCall != NULL)
            tvi.cChildren = 1;
    } else {
        if (pTag->ppCallee != NULL)
            tvi.cChildren = 1;
    }
    
    // Insert the item into the tree.
    
    is.hInsertAfter = TVI_LAST;
    is.hParent      = hParent;
    is.item         = tvi;
    
    hItem = TreeView_InsertItem(g_hwndTree, &is);
    
    return hItem;
}

/*********************************************************************
* DestroyTree
*
*********************************************************************/
void
DestroyTree(
    void)
{
    TreeView_DeleteAllItems(g_hwndTree);
    g_hTree = NULL;
}

/*********************************************************************
* AddLevel
*
*********************************************************************/
void
AddLevel(
    HTREEITEM hParent,
    PTag      pTagP,
    BOOL      bCaller)
{
    PTag pTagC;
    int  i;
    
    if (bCaller) {
        for (i = 0; i < (int)pTagP->uCallCount; i++) {
            pTagC = pTagP->ppCall[i];

            AddItem(hParent, pTagC, TRUE);
        }
    } else {
        for (i = 0; i < (int)pTagP->uCalleeCount; i++) {
            pTagC = pTagP->ppCallee[i];

            AddItem(hParent, pTagC, FALSE);
        }
    }
}

/*********************************************************************
* CreateTree
*
*********************************************************************/
void
CreateTree(
    char* pszRoot,
    BOOL  bCaller)
{
    PTag pTag;
    
    if (g_hTree) {
        DestroyTree();
    }
    
    pTag = FindTag(pszRoot, NULL);

    if (pTag == NULL) {
        return;
    }
    
    g_hTree = AddItem(NULL, pTag, bCaller);

    AddLevel(g_hTree, pTag, bCaller);

    TreeView_Expand(g_hwndTree, g_hTree, TVE_EXPAND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tags\ctui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ctui.rc
//

#define IDD_DIALOG                      101
#define IDI_ICON                        102
#define IDC_TREE                        1000
#define IDC_COMBO1                      1001
#define IDC_CALLER                      1002
#define IDC_CALLEE                      1003
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40005
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tee\tee.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tee.c

Abstract:

    Utility program to read stdin and write it to stdout and a file.

Author:

    Steve Wood (stevewo) 01-Feb-1992

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>

void
Usage()
{
    printf("Usage: tee [-a] OutputFileName(s)...\n" );
    exit(1);
}

#define MAX_OUTPUT_FILES 8

__cdecl main( argc, argv )
int argc;
char *argv[];
{
    int i, c;
    char *s, *OpenFlags;
    int NumberOfOutputFiles;
    FILE *OutputFiles[ MAX_OUTPUT_FILES ];

    if (argc < 2) {
        Usage();
        }

    NumberOfOutputFiles = 0;
    OpenFlags = "wb";
    for (i=1; i<argc; i++) {
        s = argv[ i ];
        if (*s == '-' || *s == '/') {
            s++;
            switch( tolower( *s ) ) {
                case 'a':   OpenFlags = "ab"; break;
                default:    Usage();
                }
            }
        else
        if (NumberOfOutputFiles >= MAX_OUTPUT_FILES) {
            fprintf( stderr, "TEE: too many output files specified - %s\n", s );
            }
        else
        if (!(OutputFiles[NumberOfOutputFiles] = fopen( s, OpenFlags ))) {
            fprintf( stderr, "TEE: unable to open file - %s\n", s );
            }
        else {
            NumberOfOutputFiles++;
            }
        }

    if (NumberOfOutputFiles == 0) {
        fprintf( stderr, "TEE: no output files specified.\n" );
        }

    while ((c = getchar()) != EOF) {
        putchar( c );
        for (i=0; i<NumberOfOutputFiles; i++) {
            if (c == '\n') {
                putc('\r', OutputFiles[ i ] ); //CRT reads cr/lf as lf
                putc('\n', OutputFiles[ i ] ); //must write as cr/lf
                fflush( OutputFiles[ i ] );
                }
            else {
                putc( c, OutputFiles[ i ] );
                }
            }
        }

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tc\tc.c ===
/* tc.c - general purpose tree copy program
 *
 *  tc.c recursively walks the source tree and copies the entire structure
 *  to the destination tree, creating directories as it goes along.
 *
 *      2/18/86         dan lipkie  correct error msg v[0] -> v[1]
 *      2/18/86         dan lipkie  allow for out of space on destination
 *      4/11/86         dan lipkie  add /h switch
 *      4/13/86         dan lipkie  allow all switches to use same switch char
 *      17-Jun-1986     dan lipkie  add /n, allow ^C to cancel
 *      11-Jul-1986     dan lipkie  add /s
 *      21-Jul-1986     dan lipkie  add MAXDIRLEN
 *      06-Nov-1986     mz          add /L
 *      13-May-1987     mz          add /F
 *      15-May-1987     mz          Make /F display dirs too
 *      11-Oct-1989     reubenb     fix /L parsing (?)
 *                                  add some void declarations
 *      19-Oct-1989     mz
 *
 */
#include <direct.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <conio.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <windows.h>
#include <tools.h>


// Forward Function Declartions...
void CopyNode( char *, struct findType *, void * );
void MakeDir( char * );
void __cdecl Usage( char *, ... );
void errorexit( char *, unsigned, unsigned, unsigned );
void ChkSpace( int, LONGLONG );
int  FormDest( char * );

char const rgstrUsage[] = {
    "Usage: TC [/adhijnqrstAFLS] src-tree dst-tree\n"
    "    /a  only those files with the archive bit on are copied\n"
    "    /b  copies to inuse files are delayed to reboot\n"
    "    /d  deletes source files/directories as it copies them\n"
    "    /h  copy hidden directories, implied by /d\n"
    "    /i  ignore hidden, has nothing to do with hidden dir\n"
    "    /j  ignore system files, has nothing to do with hidden dir\n"
    "    /n  no subdirectories\n"
    "    /q  silent operation.  Normal mode displays activity\n"
    "    /r  read-only files are overwritten\n"
    "    /s  structure only\n"
    "    /t  only those files with source time > dest time are copied\n"
    "    /A  allow errors from copy (won't delete if /d present)\n"
    "    /F  list files that would be copied\n"
    "    /L  large disk copy (no full disk checking)\n"
    "    /S  produce batch script to do copy"
    };

flagType    fReboot = FALSE;            // TRUE => delay reboot
flagType    fDelete = FALSE;            // TRUE => delete/rmdir source after
flagType    fQuiet = FALSE;             // TRUE => no msg except for error
flagType    fArchive = FALSE;           // TRUE => copy only ARCHIVEed files
flagType    fTime = FALSE;              // TRUE => copy later dated files
flagType    fHidden = FALSE;            // TRUE => copy hidden directories
flagType    fNoSub = FALSE;             // TRUE => do not copy subdirect
flagType    fStructure = FALSE;         // TRUE => copy only directory
flagType    fInCopyNode = FALSE;        // TRUE => prevent recursion
flagType    fIgnoreHidden = FALSE;      // TRUE => don't consider hidden
flagType    fIgnoreSystem;              // TRUE => don't consider system
flagType    fOverwriteRO;               // TRUE => ignore R/O bit
flagType    fLarge = FALSE;             // TRUE => disables ChkSpace
flagType    fFiles = FALSE;             // TRUE => output files
flagType    fScript = FALSE;            // TRUE => output files as script
flagType    fAllowError = FALSE;        // TRUE => fcopy errors ignored
flagType    fRebootNecessary = FALSE;   // TRUE => reboot ultimately necessary



char source[MAX_PATH];
char dest[MAX_PATH];
char tempdir[MAX_PATH];
char tempfile[MAX_PATH];
int  drv;

int srclen, dstlen;


/*  Usage takes a variable number of strings, terminated by zero,
 *  e.g. Usage ("first ", "second ", 0);
 */
void __cdecl Usage( char *p, ... )
{
    char **rgstr;

    rgstr = &p;
    if (*rgstr) {
        fprintf (stderr, "TC: ");
        while (*rgstr)
            fprintf(stderr, "%s", *rgstr++);
        fprintf(stderr, "\n");
        }
    fputs(rgstrUsage, stderr);
    exit (1);
}

void errorexit (fmt, a1, a2, a3)
char *fmt;
unsigned a1, a2, a3;
{
    fprintf (stderr, fmt, a1, a2, a3);
    fprintf (stderr, "\n");
    exit (1);
}


/* chkspace checks to see if there is enough space on drive d to hold a file
 * of size l.  If not, requests a disk swap
 */
void ChkSpace (d, l)
int d;
LONGLONG l;
{
    char *pend;
    char pathStr[MAX_PATH];
    int i;

    if (!fLarge)
        while (freespac (d) < sizeround (l, d)) {
            _cprintf ("Please insert a new disk in drive %c: and strike any key",
                     d + 'A'-1);
            if (_getch () == '\003')  /* ^C */
                exit (1);
            _cprintf ("\n\r");
            pend = pathStr;
            drive(dest, pend);
            pend += strlen(pend);
            path(dest, pend);
            if (fPathChr(pathStr[(i = (strlen(pathStr) - 1))]) && i > 2)
                pathStr[i] = '\0';
            MakeDir(pathStr);
            }
}


__cdecl main (c, v)
int c;
char *v[];
{
    struct findType fbuf;
    char *p;

    ConvertAppToOem( c, v );
    SHIFT(c,v);
    while (c && fSwitChr (*v[ 0 ])) {
        p = v[ 0 ];
        SHIFT(c,v);
        while (*++p)
            switch (*p) {
                case 'b':
                    fReboot = TRUE;
                    break;
                case 'd':
                    fDelete = TRUE;
                    /* fall through; d => h */
                case 'h':
                    fHidden = TRUE;
                    break;
                case 'S':
                    fScript = TRUE;
                    /*  Fall through implies FILES and QUIET */
                case 'F':
                    fFiles = TRUE;
                    /*  Fall through implies QUIET */
                case 'q':
                    fQuiet = TRUE;
                    break;
                case 'a':
                    fArchive = TRUE;
                    break;
                case 't':
                    fTime = TRUE;
                    break;
                case 'n':
                    fNoSub = TRUE;
                    break;
                case 's':
                    fStructure = TRUE;
                    break;
                case 'i':
                    fIgnoreHidden = TRUE;
                    break;
                case 'j':
                    fIgnoreSystem = TRUE;
                    break;
                case 'r':
                    fOverwriteRO = TRUE;
                    break;
                case 'L':
                    fLarge = TRUE;
                    break;
                case 'A':
                    fAllowError = TRUE;
                    break;
                default:
                    Usage ( "Invalid switch - ", p, 0 );
                }
        }

    if (fStructure && fDelete)
        Usage ("Only one of /d and /s may be specified at a time", 0);
    if (c != 2)
        Usage (0);
    if (rootpath (v[0], source))
        Usage ("Invalid source", v[0], 0);
    if (rootpath (v[1], dest))
        Usage ("Invalid dest", v[1], 0);  /* M000 */
    srclen = strlen (source);
    dstlen = strlen (dest);
    if (!strcmp(source, dest))
        Usage ("Source == dest == ", source, 0);
    fbuf.fbuf.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
    drv = toupper(*dest) - 'A' + 1;
    CopyNode (source, &fbuf, NULL);

    return( fRebootNecessary ? 2 : 0 );
}

/* copy node walks the source node and its children (recursively)
 * and creats the appropriate parts on the dst node
 */
void
CopyNode (
    char            *p,
    struct findType *pfb,
    void            *dummy
    )
{
    char *pend;
    int attr;
    flagType fCopy;
    flagType fDestRO;

    DWORD Status;
    char *pszError;

    FormDest (p);
    if (TESTFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        /*  If we're to exclude subdirectories, and we're in one then
         *      skip it altogether
         */
        if (fNoSub && fInCopyNode)
            return;
        fInCopyNode = TRUE;

        /*  Skip the . and .. entries; they're useless
         */
        if (!strcmp (pfb->fbuf.cFileName, ".") || !strcmp (pfb->fbuf.cFileName, ".."))
            return;

        /*  if we're excluding hidden and this one is then
         *      skip it altogether
         */
        if (!fHidden && TESTFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_HIDDEN))
            return;

        /*  if we're not just outputting the list of files then
         *      Make sure that the destination dir exists
         */
    if ( !fFiles ) {
        ChkSpace(drv, 256);
    }
    MakeDir (dest);

    pend = strend (p);
    if (!fPathChr (pend[-1]))
        strcat (p, "\\");
    strcat (p, "*.*");
    forfile (p, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, CopyNode, NULL);
    *pend = '\0';

    /*  if we're not just outputting files then
     *      if we're to delete this node then
     *          ...
     */
    if (!fFiles)
        if (fDelete)
            if (_rmdir (p) == -1)
                Usage ("Unable to rmdir ", p, " - ", error (), 0);
    }
    else
    if (!fStructure) {
        if (_access(p, 04) == -1)        /* If we can read the source */
            Usage ("Unable to peek status of ", p, " - ", error (), 0);

        /*  do not copy the file if:
         *      fIgnoreHidden && hidden
         *      fIgnoreSystem && system
         *      fArchive and archive bit not set
         *      dest exists &&
         *          fTime && src <= dest time ||
         *          dest is readonly && !fOverwriteRO
         */

        fCopy = (flagType)TRUE;
        fDestRO = (flagType)FALSE;
        /* If destination exists, check the time of the destination to
         * see if we should copy the file
         */
        if (_access (dest, 00) != -1 ) {
            struct _stat srcbuf;
            struct _stat dstbuf;
            /* We have now determined that both the source and destination
             * exist, we now want to check to see if the destination is
             * read only, and if the /T switch was specified if the
             * destination is newer than the source.
             */
            if (_stat (p, &srcbuf) != -1) {/* if source is stat'able */
                if (_stat (dest, &dstbuf) != -1 ) { /* and destination too, */
                    attr = GetFileAttributes( dest ); /* get dest's flag */
                    fDestRO = (flagType)TESTFLAG ( attr, FILE_ATTRIBUTE_READONLY ); /* Flag dest R.O. */
                    if ( fTime && srcbuf.st_mtime <= dstbuf.st_mtime)
                        fCopy = FALSE;
                    else
                        if ( fDestRO && !fOverwriteRO ) {
                            if (!fQuiet)
                                printf ("%s => not copied, destination is read only\n", p);
                            fCopy = FALSE;
                        }
                }
            }
        }
        if (fCopy && fIgnoreHidden && TESTFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_HIDDEN))
            fCopy = FALSE;
        if (fCopy && fIgnoreSystem && TESTFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_SYSTEM))
            fCopy = FALSE;
        if (fCopy && fArchive && !TESTFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_ARCHIVE))
            fCopy = FALSE;
        if (fCopy) {
            if (!fFiles) {
                if (fDestRO) {
                    RSETFLAG (attr, FILE_ATTRIBUTE_READONLY);
                    SetFileAttributes( dest, attr );
                }
                _unlink(dest);
                ChkSpace(drv, FILESIZE(pfb->fbuf));
                }
            if (!fQuiet)
                printf ("%s => %s\t", p, dest);

            Status = NO_ERROR;
            pszError = "[OK]";

            if (fFiles) {
                if (fScript)
                    printf ("copy %s %s\n", p, dest);
                else
                    printf ("file %s\n", p, dest);
                }
            else
            if (!CopyFile (p, dest, FALSE)) {
                pszError = error ();
                Status = GetLastError ();

                //  If we received a sharing violation, we try to perform
                //  a boot-delayed copy.

                do {
                    if (Status != ERROR_SHARING_VIOLATION)
                        continue;

                    if (!fReboot)
                        continue;

                    Status = NO_ERROR;
                    pszError = "[reboot necessary]";

                    //  We attempt to delay this operation until reboot.
                    //  Since there is at least one DLL that we cannot
                    //  rename in this fashion, we perform delayed DELETE
                    //  of unused files.

                    //  get a temp name in the same directory
                    upd (dest, ".", tempdir);
                    if (GetTempFileName (tempdir, "tc", 0, tempfile) == 0) {
                        pszError = error ();
                        Status = GetLastError ();
                        continue;
                        }

                    //  rename dest file to temp name
                    if (!MoveFileEx (dest, tempfile, MOVEFILE_REPLACE_EXISTING)) {
                        pszError = error ();
                        Status = GetLastError ();
                        DeleteFile (tempfile);
                        continue;
                        }

                    //  copy again
                    if (!CopyFile (p, dest, TRUE)) {
                        pszError = error ();
                        Status = GetLastError ();
                        DeleteFile (dest);
                        MoveFile (tempfile, dest);
                        continue;
                        }

                    //  mark temp for delete
                    if (!MoveFileEx (tempfile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT)) {
                        pszError = error ();
                        Status = GetLastError ();
                        DeleteFile (dest);
                        MoveFile (tempfile, dest);
                        continue;
                        }

                     fRebootNecessary = TRUE;
                } while (FALSE);

                }

            /*  Display noise if we're not quiet
             */
            if (!fQuiet)
                printf ("%s\n", pszError);

            /*  If we got an error and we're not supposed to ignore them
             *      quit and report error
             */
            if (Status != NO_ERROR)
                if (!fAllowError)
                    Usage ("Unable to copy ", p, " to ", dest, " - ", pszError, 0);
                else
                    printf ("Unable to copy %s to %s - %s\n", p, dest, pszError);

            /*  If we're not just producing a file list and no error on copy
             */
            if (!fFiles && Status == NO_ERROR) {

                /*  If we're supposed to copy archived files and archive was
                 *      set, go reset the source
                 */
                if (fArchive && TESTFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_ARCHIVE)) {
                    RSETFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_ARCHIVE);
                    if( SetFileAttributes( p, pfb->fbuf.dwFileAttributes ) == -1 )
                        Usage ("Unable to set ", p, " attributes - ", error (), 0);
                }

                /*  Copy attributes from source to destination
                 */
                SetFileAttributes( dest, pfb->fbuf.dwFileAttributes );

                /*  If we're supposed to delete the entry
                 */
                if (fDelete) {

                    /*  If the source was read-only then
                     *      reset the source RO bit
                     */
                    if (TESTFLAG (pfb->fbuf.dwFileAttributes, FILE_ATTRIBUTE_READONLY))
                        if( SetFileAttributes( p, 0 ) == -1 )
                            Usage ("Unable to set attributes of ", " - ", error (), 0);

                    /*  Delete source and report error
                     */
                    if (_unlink (p) == -1)
                        Usage ("Unable to del ", p, " - ", error (), 0);
                    }
                }
            }
        }
    dummy;
}

/* given a source pointer, form the correct destination from it
 *
 * cases to consider:
 *
 *  source        dest            p              realdest
 * D:\path1     D:\path2    D:\path1\path3    D:\path2\path3
 * D:\          D:\path1    D:\path2\path3    D:\path1\path2\path3
 * D:\path1     D:\         D:\path1\path2    D:\path2
 * D:\          D:\         D:\               D:\
 */
FormDest (p)
char *p;
{
    char *subsrc, *dstend;

    subsrc = p + srclen;
    if (fPathChr (*subsrc))
        subsrc++;
    dstend = dest + dstlen;
    if (fPathChr (dstend[-1]))
        dstend--;
    *dstend = '\0';
    if (*subsrc != '\0') {
        _strlwr(subsrc);
        strcat (dest, "\\");
        strcat (dest, subsrc);
        }
    return( 0 );
}

/* attempt to make the directory in pieces */
void    MakeDir (p)
char *p;
{
    struct _stat dbuf;
    char *pshort;
    int i;

    if (strlen (p) > 3) {

        if (_stat (p, &dbuf) != -1)
            if (!TESTFLAG (dbuf.st_mode, S_IFDIR))
                Usage (p, " is a file", 0);
            else
                return;

        pshort = strend (p);
        while (pshort > p)
            if (fPathChr (*pshort))
                break;
            else
                pshort--;
        /* pshort points to last path separator */
        *pshort = 0;
        MakeDir (p);
        *pshort = '\\';
        if (!fQuiet)
            printf ("Making %s\t", p);
        if (fFiles)
            if (fScript)
                printf ("mkdir %s\n", p);
            else
                printf ("dir %s\n", p);
        else {
            i = _mkdir (p);
            if (!fQuiet)
                printf ("%s\n", i != -1 ? "[OK]" : "");
            if (i == -1)
                Usage ("Unable to mkdir ", p, " - ", error (), 0);
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tail\tail.c ===
/* tail - first n lines to STDOUT
 *
 *   15-May-1994 PeterWi    Cloned from head.c
 *
 *   1-Apr-1997 v-charls (intel) Added the -f option
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <sys\stat.h>
#include <fcntl.h>
#include <windows.h>

int Tail(char *pszFile, int nLines, BOOL fBanner, BOOL keepOpen);

#define BUFSZ 4096

void Usage(void);

void
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    int  nArg;
    int  cLines = 10;  // default
    int  nFiles = 0;
    int  nErr = 0;
    int  keepOpen = FALSE;  // default

    if ((argc > 1) && ((*argv[1] == '-') || (*argv[1] == '/'))) {
        if (argv[1][1] == '?') {
            Usage( );
            exit( 0 );
        }

        if (argv[1][1] == 'f') {
            keepOpen = TRUE;
        }
        else {
            cLines = atoi( argv[1]+1 );
        }

        nArg = 2;
    }
    else {
        nArg = 1;
    }

    nFiles = argc - nArg;

    //
    // May only keep open exactly one file
    //
    if ((nFiles != 1) && (keepOpen)) {
        Usage( );
        exit( 0 );
    }

    if (nFiles < 1) {
        nErr += Tail( NULL, cLines, FALSE, keepOpen );
    }
    else while (nArg < argc) {
        nErr += Tail( argv[nArg], cLines, (nFiles > 1), keepOpen );
        nArg++;
    }

    if (nErr)
    {
        exit( 2 );
    }
    else
    {
        exit( 0 );
    }
}

void Usage( void )
{
    printf( "usage: TAIL [switches] [filename]*\n"
            "   switches: [-?] display this message\n"
            "             [-n] display last n lines of each file (default 10)\n"
            "             [-f filename] keep checking filename for new lines\n"
            );
}

int Tail( char *pszFile, int nLines, BOOL fBanner, BOOL keepOpen )
{
    int fd;
    int nErr = 0;
    LONGLONG offset;
    int cRead;
    int amt;
    int i;
    int nFound;
    char buff[BUFSZ];
    struct _stati64 fileStat;
    LONGLONG oldSize;
    LONGLONG toRead;


    /*
     * Open file for reading
     */

    if ( pszFile ) {
        if ( (fd = _open( pszFile, O_RDONLY | O_TEXT, 0 )) == -1 ) {
            fprintf( stderr, "TAIL: can't open %s\n", pszFile );
            return 1;
        }
    }
    else {
        fd = 0;
    }

    /*
     * Banner printed if there is more than one input file
     */

    if ( fBanner ) {
        fprintf( stdout, "==> %s <==\n", pszFile );
    }

    if ( (offset = _lseeki64( fd, 0, SEEK_END )) == -1 ) {
        fprintf( stderr, "TAIL: lseeki64() failed %d\n", errno );
        nErr++;
        goto CloseOut;
    }


    // Backup BUFSZ bytes from end of file and see how many lines we have

    if ( _fstati64( fd, &fileStat ) == -1 ) {
        fprintf( stderr, "TAIL: fstati64() failed\n" );
        nErr++;
        goto CloseOut;
    }

    //
    // Save it away for later comparison...
    //
    oldSize = fileStat.st_size;

    if (fileStat.st_size == 0) {
        fileStat.st_size = BUFSZ;
    }

    offset = 0;
    nFound = 0;

    // stop when found the req'd no. of lines or when backed up to
    // the start of the file.

    while ( (nFound <= nLines) && (offset < fileStat.st_size) ) {
        offset += BUFSZ;

        if ( offset > fileStat.st_size ) {
            offset = fileStat.st_size;
        }

        if ( _lseeki64( fd, -offset, SEEK_END ) == -1L ) {
            fprintf( stderr, "TAIL: lseeki64() failed\n" );
            nErr++;
            goto CloseOut;
        }

        if ( (cRead = _read( fd, buff, BUFSZ )) == -1 ) {
            fprintf( stderr, "TAIL: read() failed\n" );
            nErr++;
            goto CloseOut;
        }

        // count back nLines

        i = cRead;

        while ( --i >= 0 ) {
            if ( buff[i] == '\n' ) {
                if ( ++nFound > nLines ) {
                    break;
                }
            }
        }
    }

    i++; // either 1 past start of file or sitting on '\n'. In either
         // case we must advance 1.

    // print from the current index to the end of file.

    while ( cRead != 0 ) {
        if ( _write( 1, &buff[i], cRead - i ) == -1 ) {
            fprintf( stderr, "TAIL: write() failed\n" );
            nErr++;
            goto CloseOut;
        }

        i = 0; // after first buff, all buffers are of cRead bytes

        if ( (cRead = _read( fd, buff, BUFSZ )) == -1 ) {
            fprintf( stderr, "TAIL: read() failed\n" );
            nErr++;
            goto CloseOut;
        }
    }

    if ( fBanner ) {
        fprintf(stdout, "\n");
    }

    if (keepOpen) {
        while (1) {
            if ( _fstati64( fd, &fileStat ) == -1 ) {
                fprintf( stderr, "TAIL: fstat() failed\n" );
                nErr++;
                goto CloseOut;
            }

            toRead = fileStat.st_size - oldSize;

            while (toRead) {
                if (toRead > BUFSZ) {
                    amt = BUFSZ;
                }
                else {
                    amt = (int)toRead;
                }

                if ( (cRead = _read( fd, buff, amt )) == -1 ) {
                    fprintf( stderr, "TAIL: read() failed\n" );
                    nErr++;
                    goto CloseOut;
                }

                if ( cRead == 0 )   { // found EOF
                    break; 
                }

                if (_write( 1, buff, cRead ) != cRead ) {
                    fprintf( stderr, "TAIL: write() failed\n" );
                    nErr++;
                    goto CloseOut;
                }

                toRead -= cRead;
            }

            oldSize = fileStat.st_size;

            SleepEx( 1000, TRUE );
        }
    }

CloseOut:
    if ( _close( fd ) == -1 ) {
        fprintf( stderr, "TAIL: close() failed\n" );
    }

    return nErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\thunk32\thunk32.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    thunk32.c

Abstract:
    This file exists simply to allow for the building of thunk32.lib.
    It contains the extra entrypoints needed in kernel32.lib for the
    Win95 Thunk compiler.

Author:
    BryanT - 2/15/95 for CameronF

Revision History:

--*/

void __stdcall K32Thk1632Epilog( void ) {}
void __stdcall K32Thk1632Prolog( void ) {}
void __stdcall MapLS( int arg1 ) {}
void __stdcall MapSL( int arg1 ) {}
void __stdcall UnMapLS( int arg1 ) {}
void __stdcall MapSLFix( int arg1 ) {}
void __stdcall Callback4( int arg1 ) {}
void __stdcall UnMapSLFixArray( int arg1, int arg2 ) {}
void __stdcall Callback8( int arg1, int arg2 ) {}
void __stdcall Callback12( int arg1, int arg2, int arg3 ) {}
void __stdcall Callback16( int arg1, int arg2, int arg3, int arg4 ) {}
void __stdcall Callback20( int arg1, int arg2, int arg3, int arg4,
                           int arg5 ) {}
void __stdcall ThunkConnect32( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6 ) {}
void __stdcall Callback24( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6 ) {}
void __stdcall Callback28( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7 ) {}
void __stdcall Callback32( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8 ) {}
void __stdcall Callback36( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9 ) {}
void __stdcall Callback40( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9, int arg10 ) {}
void __stdcall Callback44( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9, int arg10, int arg11 ) {}
void __stdcall Callback48( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9, int arg10, int arg11, int arg12 ) {}
void __stdcall Callback52( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9, int arg10, int arg11, int arg12,
                           int arg13 ) {}
void __stdcall Callback56( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9, int arg10, int arg11, int arg12,
                           int arg13, int arg14 ) {}
void __stdcall Callback60( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9, int arg10, int arg11, int arg12,
                           int arg13, int arg14, int arg15 ) {}
void __stdcall Callback64( int arg1, int arg2, int arg3, int arg4,
                           int arg5, int arg6, int arg7, int arg8,
                           int arg9, int arg10, int arg11, int arg12,
                           int arg13, int arg14, int arg15, int arg16 ) {}

void __cdecl FT_Exit0 (void) {}
void __cdecl FT_Exit12(void) {}
void __cdecl FT_Exit16(void) {}
void __cdecl FT_Exit20(void) {}
void __cdecl FT_Exit24(void) {}
void __cdecl FT_Exit28(void) {}
void __cdecl FT_Exit32(void) {}
void __cdecl FT_Exit36(void) {}
void __cdecl FT_Exit4 (void) {}
void __cdecl FT_Exit40(void) {}
void __cdecl FT_Exit44(void) {}
void __cdecl FT_Exit48(void) {}
void __cdecl FT_Exit52(void) {}
void __cdecl FT_Exit56(void) {}
void __cdecl FT_Exit8(void) {}
void __cdecl FT_Prolog(void) {}
void __cdecl FT_Thunk(void) {}
void __cdecl MapHInstLS(void) {}
void __cdecl MapHInstLS_PN(void) {}
void __cdecl MapHInstSL(void) {}
void __cdecl MapHInstSL_PN(void) {}
void __cdecl QT_Thunk(void) {}
void __cdecl SMapLS(void) {}
void __cdecl SMapLS_IP_EBP_12(void) {}
void __cdecl SMapLS_IP_EBP_16(void) {}
void __cdecl SMapLS_IP_EBP_20(void) {}
void __cdecl SMapLS_IP_EBP_24(void) {}
void __cdecl SMapLS_IP_EBP_28(void) {}
void __cdecl SMapLS_IP_EBP_32(void) {}
void __cdecl SMapLS_IP_EBP_36(void) {}
void __cdecl SMapLS_IP_EBP_40(void) {}
void __cdecl SMapLS_IP_EBP_8(void) {}
void __cdecl SUnMapLS(void) {}
void __cdecl SUnMapLS_IP_EBP_12(void) {}
void __cdecl SUnMapLS_IP_EBP_16(void) {}
void __cdecl SUnMapLS_IP_EBP_20(void) {}
void __cdecl SUnMapLS_IP_EBP_24(void) {}
void __cdecl SUnMapLS_IP_EBP_28(void) {}
void __cdecl SUnMapLS_IP_EBP_32(void) {}
void __cdecl SUnMapLS_IP_EBP_36(void) {}
void __cdecl SUnMapLS_IP_EBP_40(void) {}
void __cdecl SUnMapLS_IP_EBP_8(void) {}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\timer\timer.c ===
/* execute a routine and determine the time spent...
 *
 *  26-Jan-1987 bw  Clean up, add 286DOS support
 *  30-Oct-1987 bw  Changed 'DOS5' to 'OS2'
 *  18-Oct-1990 w-barry Removed 'dead' code.
 *  28-Nov-1990 w-barry Replaced DosQuerySysInfo() with the C runtime
 *                      function 'clock' - timing is not as accurate; but,
 *                      until there is a win32 replacement, it will have to
 *                      do...
 */
#define INCL_DOSMISC


#include <process.h>
#include <stdlib.h>
#include <time.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>

__cdecl
main (
    int c,
    char *v[]
    )
{
    int i;
    long t, t1;
    char *newv[128];

    ConvertAppToOem( c, v );
    for (i = 1; i < c; i++)
        printf ("%s ", v[i]);
    printf ("\n");

//    newv[0] = getenv ("COMSPEC");
    newv[0] = getenvOem ("COMSPEC");
    newv[1] = "/C";
    for (i = 1; i < c; i++)
        newv[i+1] = v[i];
    newv[i+1] = NULL;

    t = clock();

    if ( (i = (int) _spawnvp (P_WAIT, newv[0], newv)) == -1) {
        printf("'%s' failed to run - %s\n", newv[0], error());
        exit(1);
        }

    t1 = clock();

    printf ("Results of execution:\n\n");
    printf ("    Exit code %x\n", i);
    t1 -= t;
    printf ("    Time of execution %ld.%03ld\n", t1 / CLK_TCK, t1 % CLK_TCK );

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\takeown\takeown.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Takeown.c

Abstract:

    Implements a recovery scheme to give an Administrator
    access to a file that has been denied to all.

Author:

    Robert Reichel (robertre)   22-Jun-1992

Environment:

    Must be run from an Administrator account in order
    to perform reliably.

Revision History:


--*/
#include <windows.h>
#include <stdio.h>
#include <malloc.h>

BOOL
AssertTakeOwnership(
    HANDLE TokenHandle
    );

BOOL
GetTokenHandle(
    PHANDLE TokenHandle
    );

BOOL
VariableInitialization();


#define VERBOSE 0



PSID AliasAdminsSid = NULL;
PSID SeWorldSid;

static SID_IDENTIFIER_AUTHORITY    SepNtAuthority = SECURITY_NT_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepWorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;



VOID __cdecl
main (int argc, char *argv[])
{


    BOOL Result;
    LPSTR lpFileName;
    SECURITY_DESCRIPTOR SecurityDescriptor;
//    CHAR Dacl[256];
    HANDLE TokenHandle;


    //
    // We expect a file...
    //
    if (argc <= 1) {

        printf("Must specify a file name");
        return;
    }


    lpFileName = argv[1];

#if VERBOSE

    printf("Filename is %s\n", lpFileName );

#endif



    Result = VariableInitialization();

    if ( !Result ) {
        printf("Out of memory\n");
        return;
    }




    Result = GetTokenHandle( &TokenHandle );

    if ( !Result ) {

        //
        // This should not happen
        //

        printf("Unable to obtain the handle to our token, exiting\n");
        return;
    }






    //
    // Attempt to put a NULL Dacl on the object
    //

    InitializeSecurityDescriptor( &SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );



//    Result = InitializeAcl ( (PACL)Dacl, 256, ACL_REVISION2 );
//
//    if ( !Result ) {
//        printf("Unable to initialize Acl, exiting\n");
//        return;
//    }
//
//
//    Result = AddAccessAllowedAce (
//                 (PACL)Dacl,
//                 ACL_REVISION2,
//                 GENERIC_ALL,
//                 AliasAdminsSid
//                 );
//
//
//
//    if ( !Result ) {
//        printf("Unable to create required ACL, error code = %d\n", GetLastError());
//        printf("Exiting\n");
//        return;
//    }


    Result = SetSecurityDescriptorDacl (
                 &SecurityDescriptor,
                 TRUE,
                 NULL,
                 FALSE
                 );



    if ( !Result ) {
        printf("SetSecurityDescriptorDacl failed, error code = %d\n", GetLastError());
        printf("Exiting\n");
        return;
    }

    Result = SetFileSecurity(
                 lpFileName,
                 DACL_SECURITY_INFORMATION,
                 &SecurityDescriptor
                 );

    if ( !Result ) {

#if VERBOSE

        printf("SetFileSecurity failed, error code = %d\n", GetLastError());

#endif

    } else {

        printf("Successful, protection removed\n");
        return;
    }



    //
    // That didn't work.
    //


    //
    // Attempt to make Administrator the owner of the file.
    //


    Result = SetSecurityDescriptorOwner (
                 &SecurityDescriptor,
                 AliasAdminsSid,
                 FALSE
                 );

    if ( !Result ) {
        printf("SetSecurityDescriptorOwner failed, lasterror = %d\n", GetLastError());
        return;
    }


    Result = SetFileSecurity(
                 lpFileName,
                 OWNER_SECURITY_INFORMATION,
                 &SecurityDescriptor
                 );

    if ( Result ) {

#if VERBOSE

        printf("Owner successfully changed to Admin\n");

#endif

    } else {

        //
        // That didn't work either.
        //

#if VERBOSE

        printf("Opening file for WRITE_OWNER failed\n");
        printf("Attempting to assert TakeOwnership privilege\n");

#endif

        //
        // Assert TakeOwnership privilege, then try again
        //

        Result = AssertTakeOwnership( TokenHandle );

        if ( !Result ) {
            printf("Could not enable SeTakeOwnership privilege\n");
            printf("Log on as Administrator and try again\n");
            return;
        }

        Result = SetFileSecurity(
                     lpFileName,
                     OWNER_SECURITY_INFORMATION,
                     &SecurityDescriptor
                     );

        if ( Result ) {

#if VERBOSE
            printf("Owner successfully changed to Administrator\n");

#endif

        } else {

            printf("Unable to assign Administrator as owner\n");
            printf("Log on as Administrator and try again\n");
            return;
        }

    }

    //
    // Try to put a benign DACL onto the file again
    //

    Result = SetFileSecurity(
                 lpFileName,
                 DACL_SECURITY_INFORMATION,
                 &SecurityDescriptor
                 );

    if ( !Result ) {

        //
        // something is wrong
        //

        printf("SetFileSecurity unexpectedly failed, error code = %d\n", GetLastError());

    } else {

        printf("Successful, protection removed\n");
        return;
    }
}





BOOL
GetTokenHandle(
    PHANDLE TokenHandle
    )
{

    HANDLE ProcessHandle;
    BOOL Result;

    ProcessHandle = OpenProcess(
                        PROCESS_QUERY_INFORMATION,
                        FALSE,
                        GetCurrentProcessId()
                        );

    if ( ProcessHandle == NULL ) {

        //
        // This should not happen
        //

        return( FALSE );
    }


    Result = OpenProcessToken (
                 ProcessHandle,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 TokenHandle
                 );

    if ( !Result ) {

        CloseHandle(ProcessHandle);

        //
        // This should not happen
        //

        return FALSE;

    }

    CloseHandle(ProcessHandle);

    return( TRUE );
}


BOOL
AssertTakeOwnership(
    HANDLE TokenHandle
    )
{
    LUID TakeOwnershipValue;
    BOOL Result;
    TOKEN_PRIVILEGES TokenPrivileges;

    //
    // First, assert TakeOwnership privilege
    //


    Result = LookupPrivilegeValue(
                 NULL,
                 "SeTakeOwnershipPrivilege",
                 &TakeOwnershipValue
                 );

    if ( !Result ) {

        //
        // This should not happen
        //

        printf("Unable to obtain value of TakeOwnership privilege\n");
        printf("Error = %d\n",GetLastError());
        printf("Exiting\n");
        return FALSE;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = TakeOwnershipValue;
    TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;




    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                &TokenPrivileges,
                sizeof( TOKEN_PRIVILEGES ),
                NULL,
                NULL
                );

    if ( GetLastError() != NO_ERROR ) {

#if VERBOSE

        printf("GetLastError returned %d from AdjustTokenPrivileges\n", GetLastError() );

#endif

        return FALSE;

    } else {

#if VERBOSE

        printf("TakeOwnership privilege enabled\n");

#endif

    }

    return( TRUE );
}


BOOL
VariableInitialization()
{

    BOOL Result;

    Result = AllocateAndInitializeSid(
                 &SepNtAuthority,
                 2,
                 SECURITY_BUILTIN_DOMAIN_RID,
                 DOMAIN_ALIAS_RID_ADMINS,
                 0,
                 0,
                 0,
                 0,
                 0,
                 0,
                 &AliasAdminsSid
                 );

    if ( !Result ) {
        return( FALSE );
    }


    Result = AllocateAndInitializeSid(
                 &SepWorldSidAuthority,
                 1,
                 SECURITY_WORLD_RID,
                 0,
                 0,
                 0,
                 0,
                 0,
                 0,
                 0,
                 &SeWorldSid
                 );

    if ( !Result ) {
        return( FALSE );
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tlist\common.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    common.c

Abstract:

    This module contains common apis used by tlist & kill.

Author:

    Wesley Witt (wesw) 20-May-1994

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop


//
// global variables
//
PUCHAR  CommonLargeBuffer;
ULONG   CommonLargeBufferSize = 64*1024;

//
// prototypes
//
BOOL CALLBACK
EnumWindowsProc(
    HWND    hwnd,
    LPARAM  lParam
    );

BOOL CALLBACK
EnumWindowStationsFunc(
    LPSTR  lpstr,
    LPARAM lParam
    );

BOOL CALLBACK
EnumDesktopsFunc(
    LPSTR  lpstr,
    LPARAM lParam
    );


DWORD
GetServiceProcessInfo(
    LPENUM_SERVICE_STATUS_PROCESS*  ppInfo
    )

/*++

Routine Description:

    Provides an API for getting a list of process information for Win 32
    services that are running at the time of the API call.

Arguments:

    ppInfo  - address of a pointer to return the information.
              *ppInfo points to memory allocated with malloc.

Return Value:

    Number of ENUM_SERVICE_STATUS_PROCESS structures pointed at by *ppInfo.

--*/

{
    DWORD       dwNumServices = 0;
    SC_HANDLE   hScm;

    typedef
    BOOL
    (__stdcall * PFN_ENUMSERVICSESTATUSEXA) (
        SC_HANDLE    hSCManager,
        SC_ENUM_TYPE InfoLevel,
        DWORD        dwServiceType,
        DWORD        dwServiceState,
        LPBYTE       lpServices,
        DWORD        cbBufSize,
        LPDWORD      pcbBytesNeeded,
        LPDWORD      lpServicesReturned,
        LPDWORD      lpResumeHandle,
        LPCSTR       pszGroupName);

    PFN_ENUMSERVICSESTATUSEXA p_EnumServicesStatusEx;
    HINSTANCE   hAdv = LoadLibrary("advapi32.dll");

    // Initialize the output parmeter.
    *ppInfo = NULL;

    if (hAdv)
    {
        p_EnumServicesStatusEx = (PFN_ENUMSERVICSESTATUSEXA)
            GetProcAddress(hAdv, "EnumServicesStatusExA");

        if (!p_EnumServicesStatusEx)
        {
            return 0;
        }
    } else {
        return 0;
    }

    // Connect to the service controller.
    //
    hScm = OpenSCManager(
                NULL,
                NULL,
                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);
    if (hScm) {
        LPENUM_SERVICE_STATUS_PROCESS   pInfo    = NULL;
        DWORD                           cbInfo   = 4 * 1024;
        DWORD                           cbExtraNeeded = 0;
        DWORD                           dwErr;
        DWORD                           dwResume;
        DWORD                           cLoop    = 0;
        const DWORD                     cLoopMax = 2;

        // First pass through the loop allocates from an initial guess. (4K)
        // If that isn't sufficient, we make another pass and allocate
        // what is actually needed.  (We only go through the loop a
        // maximum of two times.)
        //
        do {
            free (pInfo);
            cbInfo += cbExtraNeeded;
            pInfo = (LPENUM_SERVICE_STATUS_PROCESS)malloc(cbInfo);
            if (!pInfo) {
                dwErr = ERROR_OUTOFMEMORY;
                break;
            }

            dwErr = ERROR_SUCCESS;
            dwResume = 0;
            if (!p_EnumServicesStatusEx(
                    hScm,
                    SC_ENUM_PROCESS_INFO,
                    SERVICE_WIN32,
                    SERVICE_ACTIVE,
                    (LPBYTE)pInfo,
                    cbInfo,
                    &cbExtraNeeded,
                    &dwNumServices,
                    &dwResume,
                    NULL)) {
                dwErr = GetLastError();
            }
        }
        while ((ERROR_MORE_DATA == dwErr) && (++cLoop < cLoopMax));

        if ((ERROR_SUCCESS == dwErr) && dwNumServices) {
            *ppInfo = pInfo;
        } else {
            free (pInfo);
            dwNumServices = 0;
        }

        CloseServiceHandle(hScm);
    }

    return dwNumServices;
}

DWORD
GetTaskListEx(
    PTASK_LIST                          pTask,
    DWORD                               dwNumTasks,
    BOOL                                fThreadInfo,
    DWORD                               dwNumServices,
    const ENUM_SERVICE_STATUS_PROCESS*  pServiceInfo
    )

/*++

Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses internal NT apis and data structures.  This
    api is MUCH faster that the non-internal version that uses the registry.

Arguments:
    pTask           - Array of TASK_LIST structures to fill.
    dwNumTasks      - Maximum number of tasks that the pTask array can hold.
    fThreadInfo     - TRUE if thread information is desired.
    dwNumServices   - Maximum number of entries in pServiceInfo.
    pServiceInfo    - Array of service status structures to reference
                      for supporting services in processes.

Return Value:

    Number of tasks placed into the pTask array.

--*/

{
    PSYSTEM_PROCESS_INFORMATION  ProcessInfo;
    NTSTATUS                     status;
    ANSI_STRING                  pname;
    PCHAR                        p;
    ULONG                        TotalOffset;
    ULONG                        totalTasks = 0;

retry:

    if (CommonLargeBuffer == NULL) {
        CommonLargeBuffer = VirtualAlloc (NULL,
                                          CommonLargeBufferSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE);
        if (CommonLargeBuffer == NULL) {
            return 0;
        }
    }
    status = NtQuerySystemInformation(
                SystemProcessInformation,
                CommonLargeBuffer,
                CommonLargeBufferSize,
                NULL
                );

    if (status == STATUS_INFO_LENGTH_MISMATCH) {
        CommonLargeBufferSize += 8192;
        VirtualFree (CommonLargeBuffer, 0, MEM_RELEASE);
        CommonLargeBuffer = NULL;
        goto retry;
    }

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) CommonLargeBuffer;
    TotalOffset = 0;
    while (TRUE) {
        pname.Buffer = NULL;
        if ( ProcessInfo->ImageName.Buffer ) {
            RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
            if (pname.Buffer) {
                p = strrchr(pname.Buffer,'\\');
                if ( p ) {
                    p++;
                }
                else {
                    p = pname.Buffer;
                }
            } else {
                p = "";
            }
        }
        else {
            p = "System Process";
        }

        strncpy( pTask->ProcessName, p, PROCESS_SIZE );
        pTask->ProcessName[PROCESS_SIZE-1] = '\0';
        pTask->flags = 0;
        pTask->dwProcessId = (DWORD)(DWORD_PTR)ProcessInfo->UniqueProcessId;
        pTask->dwInheritedFromProcessId = (DWORD)(DWORD_PTR)ProcessInfo->InheritedFromUniqueProcessId;
        pTask->CreateTime.QuadPart = (ULONGLONG)ProcessInfo->CreateTime.QuadPart;

        pTask->PeakVirtualSize = ProcessInfo->PeakVirtualSize;
        pTask->VirtualSize = ProcessInfo->VirtualSize;
        pTask->PageFaultCount = ProcessInfo->PageFaultCount;
        pTask->PeakWorkingSetSize = ProcessInfo->PeakWorkingSetSize;
        pTask->WorkingSetSize = ProcessInfo->WorkingSetSize;
        pTask->NumberOfThreads = ProcessInfo->NumberOfThreads;

        if (fThreadInfo) {
            if (pTask->pThreadInfo = malloc(pTask->NumberOfThreads * sizeof(THREAD_INFO))) {

                UINT nThread = pTask->NumberOfThreads;
                PTHREAD_INFO pThreadInfo = pTask->pThreadInfo;
                PSYSTEM_THREAD_INFORMATION pSysThreadInfo =
                    (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);

                while (nThread--) {
                    pThreadInfo->ThreadState = pSysThreadInfo->ThreadState;
                    pThreadInfo->UniqueThread = pSysThreadInfo->ClientId.UniqueThread;

                    pThreadInfo++;
                    pSysThreadInfo++;
                }
            }
        } else {
            pTask->pThreadInfo = NULL;
        }

        pTask->MtsPackageNames[0] = 0;
        
        // Initialize the ServiceNames if this task hosts any.
        //
        *pTask->ServiceNames = 0;
        if (dwNumServices)
        {
            // For each service with this process id, append it's service
            // name to the buffer.  Separate each with a comma.
            //
            BOOL    fFirstTime = TRUE;
            DWORD   iSvc;
            size_t  cchRemain = SERVICENAMES_SIZE - 1;
            size_t  cch;

            for (iSvc = 0; iSvc < dwNumServices; iSvc++) {
                if (pTask->dwProcessId == pServiceInfo[iSvc].ServiceStatusProcess.dwProcessId) {
                    cch = strlen(pServiceInfo[iSvc].lpServiceName);

                    if (fFirstTime) {
                        fFirstTime = FALSE;

                        strncpy(
                            pTask->ServiceNames,
                            pServiceInfo[iSvc].lpServiceName,
                            cchRemain);

                        // strncpy may not terminate the string if
                        // cchRemain <= cch so we do it regardless.
                        //
                        pTask->ServiceNames[cchRemain] = 0;
                    } else if (cchRemain > 1) { // ensure room for the comma
                        strncat(
                            pTask->ServiceNames,
                            ",",
                            cchRemain--);

                        strncat(
                            pTask->ServiceNames,
                            pServiceInfo[iSvc].lpServiceName,
                            cchRemain);
                    }

                    // Counts are unsigned so we have to check before
                    // subtracting.
                    //
                    if (cchRemain < cch) {
                        // No more room for any more.
                        break;
                    } else {
                        cchRemain -= cch;
                    }
                }
            }
        }

        pTask++;
        totalTasks++;
        if (totalTasks == dwNumTasks) {
            break;
        }
        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&CommonLargeBuffer[TotalOffset];
    }

    return totalTasks;
}

DWORD
GetTaskList(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    )
{
    return GetTaskListEx(pTask, dwNumTasks, FALSE, 0, NULL);
}

void
AddMtsPackageNames(
    PTASK_LIST Tasks,
    DWORD NumTasks
    )
{
    HRESULT Hr;
    IMtsGrp* MtsGroup;
    long Packages;
    long i;

    if ((Hr = CoInitialize(NULL)) != S_OK) {
        return;
    }
    if ((Hr = CoCreateInstance(&CLSID_MtsGrp, NULL, CLSCTX_ALL,
                               &IID_IMtsGrp, (void **)&MtsGroup)) != S_OK) {
        goto Uninit;
    }
    
    if ((Hr = MtsGroup->lpVtbl->Refresh(MtsGroup)) != S_OK ||
        (Hr = MtsGroup->lpVtbl->get_Count(MtsGroup, &Packages)) != S_OK) {
        goto ReleaseGroup;
    }

    for (i = 0; i < Packages; i++) {
        IUnknown* Unk;
        IMtsEvents* Events;
        BSTR Name;
        DWORD Pid;
        DWORD TaskIdx;
        
        if ((Hr = MtsGroup->lpVtbl->Item(MtsGroup, i, &Unk)) != S_OK) {
            continue;
        }

        Hr = Unk->lpVtbl->QueryInterface(Unk, &IID_IMtsEvents,
                                         (void **)&Events);

        Unk->lpVtbl->Release(Unk);

        if (Hr != S_OK) {
            continue;
        }
        
        Hr = Events->lpVtbl->GetProcessID(Events, (PLONG)&Pid);
        if (Hr == S_OK) {
            Hr = Events->lpVtbl->get_PackageName(Events, &Name);
        }

        Events->lpVtbl->Release(Events);

        if (Hr != S_OK) {
            continue;
        }

        for (TaskIdx = 0; TaskIdx < NumTasks; TaskIdx++) {
            if (Tasks[TaskIdx].dwProcessId == Pid) {
                break;
            }
        }

        if (TaskIdx < NumTasks) {
            PSTR Str;
            int Conv;

            Str = Tasks[TaskIdx].MtsPackageNames +
                strlen(Tasks[TaskIdx].MtsPackageNames);
            if (Str > Tasks[TaskIdx].MtsPackageNames) {
                *Str++ = ',';
            }

            Conv = WideCharToMultiByte(
                CP_ACP,
                0,
                Name,
                -1,
                Str,
                MTS_PACKAGE_NAMES_SIZE -
                (DWORD)(Str - Tasks[TaskIdx].MtsPackageNames) - 2,
                NULL,
                NULL
                );

            SysFreeString(Name);

            if (Conv == 0 && Str > Tasks[TaskIdx].MtsPackageNames &&
                *(Str - 1) == ',') {
                *(Str - 1) = 0;
            }
        }
    }

 ReleaseGroup:
    MtsGroup->lpVtbl->Release(MtsGroup);
 Uninit:
    CoUninitialize();
    return;
}
    
BOOL
DetectOrphans(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    )
{
    DWORD i, j;
    BOOL Result = FALSE;

    for (i=0; i<dwNumTasks; i++) {
        if (pTask[i].dwInheritedFromProcessId != 0) {
            for (j=0; j<dwNumTasks; j++) {
                if (i != j && pTask[i].dwInheritedFromProcessId == pTask[j].dwProcessId) {
                    if (pTask[i].CreateTime.QuadPart <= pTask[j].CreateTime.QuadPart) {
                        pTask[i].dwInheritedFromProcessId = 0;
                        Result = TRUE;
                        }

                    break;
                    }
                }
            }
        }

    return Result;
}

BOOL
EnableDebugPriv(
    VOID
    )

/*++

Routine Description:

    Changes the tlist process's privilige so that kill works properly.

Arguments:


Return Value:

    TRUE             - success
    FALSE            - failure

--*/

{
    HANDLE hToken;
    LUID DebugValue;
    TOKEN_PRIVILEGES tkp;

    //
    // Retrieve a handle of the access token
    //
    if (!OpenProcessToken(GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken)) {
        printf("OpenProcessToken failed with %d\n", GetLastError());
        return FALSE;
    }

    //
    // Enable the SE_DEBUG_NAME privilege or disable
    // all privileges, depending on the fEnable flag.
    //
    if (!LookupPrivilegeValue((LPSTR) NULL,
            SE_DEBUG_NAME,
            &DebugValue)) {
        printf("LookupPrivilegeValue failed with %d\n", GetLastError());
        return FALSE;
    }

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = DebugValue;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tkp,
            sizeof(TOKEN_PRIVILEGES),
            (PTOKEN_PRIVILEGES) NULL,
            (PDWORD) NULL)) {
        //
        // The return value of AdjustTokenPrivileges be texted
        //
        printf("AdjustTokenPrivileges failed with %d\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

BOOL
KillProcess(
    PTASK_LIST tlist,
    BOOL       fForce
    )
{
    HANDLE            hProcess, hProcess1;
    HDESK             hdeskSave;
    HDESK             hdesk;
    HWINSTA           hwinsta;
    HWINSTA           hwinstaSave;


    if (fForce || !tlist->hwnd) {
        hProcess1 = OpenProcess( PROCESS_ALL_ACCESS, FALSE, tlist->dwProcessId );
        if (hProcess1) {
            hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, tlist->dwProcessId );
            if (hProcess == NULL) {
                CloseHandle(hProcess1);
                return FALSE;
            }

            if (!TerminateProcess( hProcess, 1 )) {
                CloseHandle( hProcess );
                CloseHandle( hProcess1 );
                return FALSE;
            }

            CloseHandle( hProcess );
            CloseHandle( hProcess1 );
            return TRUE;
        }
    }

    //
    // save the current windowstation
    //
    hwinstaSave = GetProcessWindowStation();

    //
    // save the current desktop
    //
    hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

    //
    // open the windowstation
    //
    hwinsta = OpenWindowStation( tlist->lpWinsta, FALSE, MAXIMUM_ALLOWED );
    if (!hwinsta) {
        return FALSE;
    }

    //
    // change the context to the new windowstation
    //
    SetProcessWindowStation( hwinsta );

    //
    // open the desktop
    //
    hdesk = OpenDesktop( tlist->lpDesk, 0, FALSE, MAXIMUM_ALLOWED );
    if (!hdesk) {
        return FALSE;
    }

    //
    // change the context to the new desktop
    //
    SetThreadDesktop( hdesk );

    //
    // kill the process
    //
    PostMessage( tlist->hwnd, WM_CLOSE, 0, 0 );

    //
    // restore the previous desktop
    //
    if (hdesk != hdeskSave) {
        SetThreadDesktop( hdeskSave );
        CloseDesktop( hdesk );
    }

    //
    // restore the context to the previous windowstation
    //
    if (hwinsta != hwinstaSave) {
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hwinsta );
    }

    return TRUE;
}


VOID
GetWindowTitles(
    PTASK_LIST_ENUM te
    )
{
    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    EnumWindowStations( EnumWindowStationsFunc, (LPARAM)te );
}


BOOL CALLBACK
EnumWindowStationsFunc(
    LPSTR  lpstr,
    LPARAM lParam
    )

/*++

Routine Description:

    Callback function for windowstation enumeration.

Arguments:

    lpstr            - windowstation name
    lParam           - ** not used **

Return Value:

    TRUE  - continues the enumeration

--*/

{
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    HWINSTA           hwinsta;
    HWINSTA           hwinstaSave;


    //
    // open the windowstation
    //
    hwinsta = OpenWindowStation( lpstr, FALSE, MAXIMUM_ALLOWED );
    if (!hwinsta) {
        return FALSE;
    }

    //
    // save the current windowstation
    //
    hwinstaSave = GetProcessWindowStation();

    //
    // change the context to the new windowstation
    //
    SetProcessWindowStation( hwinsta );

    te->lpWinsta = _strdup( lpstr );

    //
    // enumerate all the desktops for this windowstation
    //
    EnumDesktops( hwinsta, EnumDesktopsFunc, lParam );

    //
    // restore the context to the previous windowstation
    //
    if (hwinsta != hwinstaSave) {
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hwinsta );
    }

    //
    // continue the enumeration
    //
    return TRUE;
}
BOOL CALLBACK
EnumMessageWindows(
    WNDENUMPROC lpEnumFunc,
    LPARAM lParam
    )

/*++

Routine Description:

    Enumarates message windows (which are not enumarated by EnumWindows)

Arguments:

    lpEnumFunc       - Callback function
    lParam           - Caller data

Return Value:

    TRUE

--*/

{

    HWND hwnd = NULL;
    do {
        hwnd = FindWindowEx(HWND_MESSAGE, hwnd, NULL, NULL);
        if (hwnd != NULL) {
            if (!(*lpEnumFunc)(hwnd, lParam)) {
                break;
            }
        }
    } while (hwnd != NULL);
    return TRUE;
}

BOOL CALLBACK
EnumDesktopsFunc(
    LPSTR  lpstr,
    LPARAM lParam
    )

/*++

Routine Description:

    Callback function for desktop enumeration.

Arguments:

    lpstr            - desktop name
    lParam           - ** not used **

Return Value:

    TRUE  - continues the enumeration

--*/

{
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    HDESK             hdeskSave;
    HDESK             hdesk;


    //
    // open the desktop
    //
    hdesk = OpenDesktop( lpstr, 0, FALSE, MAXIMUM_ALLOWED );
    if (!hdesk) {
        return FALSE;
    }

    //
    // save the current desktop
    //
    hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

    //
    // change the context to the new desktop
    //
    SetThreadDesktop( hdesk );

    te->lpDesk = _strdup( lpstr );

    //
    // enumerate all windows in the new desktop
    //

    ((PTASK_LIST_ENUM)lParam)->bFirstLoop = TRUE;
    EnumWindows( (WNDENUMPROC)EnumWindowsProc, lParam );
    EnumMessageWindows( (WNDENUMPROC)EnumWindowsProc, lParam );

    ((PTASK_LIST_ENUM)lParam)->bFirstLoop = FALSE;
    EnumWindows( (WNDENUMPROC)EnumWindowsProc, lParam );
    EnumMessageWindows( (WNDENUMPROC)EnumWindowsProc, lParam );

    //
    // restore the previous desktop
    //
    if (hdesk != hdeskSave) {
        SetThreadDesktop( hdeskSave );
        CloseDesktop( hdesk );
    }

    return TRUE;
}


BOOL CALLBACK
EnumWindowsProc(
    HWND    hwnd,
    LPARAM  lParam
    )

/*++

Routine Description:

    Callback function for window enumeration.

Arguments:

    hwnd             - window handle
    lParam           - pte

Return Value:

    TRUE  - continues the enumeration

--*/

{
    DWORD             pid = 0;
    DWORD             i;
    CHAR              buf[TITLE_SIZE];
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    PTASK_LIST        tlist = te->tlist;
    DWORD             numTasks = te->numtasks;


    //
    // Use try/except block when enumerating windows,
    // as a window may be destroyed by another thread
    // when being enumerated.
    //
    try {
        //
        // get the processid for this window
        //
        if (!GetWindowThreadProcessId( hwnd, &pid )) {
            return TRUE;
        }

        if ((GetWindow( hwnd, GW_OWNER )) ||
            (!(GetWindowLong(hwnd, GWL_STYLE) & WS_VISIBLE)) && te->bFirstLoop) {
            //
            // not a top level window
            //
            return TRUE;
        }

        //
        // look for the task in the task list for this window
        // If this is the second time let invisible windows through if we don't
        // have a window already
        //
        for (i=0; i<numTasks; i++) {
            if ((tlist[i].dwProcessId == pid) && (te->bFirstLoop || (tlist[i].hwnd == 0))) {
                tlist[i].hwnd = hwnd;
                tlist[i].lpWinsta = te->lpWinsta;
                tlist[i].lpDesk = te->lpDesk;
                //
                // we found the task no lets try to get the
                // window text
                //
                if (GetWindowText( tlist[i].hwnd, buf, sizeof(buf) )) {
                    //
                    // go it, so lets save it
                    //
                    strcpy( tlist[i].WindowTitle, buf );
                }
                break;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    //
    // continue the enumeration
    //
    return TRUE;
}

BOOL
MatchPattern(
    PUCHAR String,
    PUCHAR Pattern
    )
{
    INT   c, p, l;

    for (; ;) {
        switch (p = *Pattern++) {
            case 0:                             // end of pattern
                return *String ? FALSE : TRUE;  // if end of string TRUE

            case '*':
                while (*String) {               // match zero or more char
                    if (MatchPattern (String++, Pattern))
                        return TRUE;
                }
                return MatchPattern (String, Pattern);

            case '?':
                if (*String++ == 0)             // match any one char
                    return FALSE;                   // not end of string
                break;

            case '[':
                if ( (c = *String++) == 0)      // match char set
                    return FALSE;                   // syntax

                c = toupper(c);
                l = 0;
                while (p = *Pattern++) {
                    if (p == ']')               // if end of char set, then
                        return FALSE;           // no match found

                    if (p == '-') {             // check a range of chars?
                        p = *Pattern;           // get high limit of range
                        if (p == 0  ||  p == ']')
                            return FALSE;           // syntax

                        if (c >= l  &&  c <= p)
                            break;              // if in range, move on
                    }

                    l = p;
                    if (c == p)                 // if char matches this element
                        break;                  // move on
                }

                while (p  &&  p != ']')         // got a match in char set
                    p = *Pattern++;             // skip to end of set

                break;

            default:
                c = *String++;
                if (toupper(c) != p)            // check for exact char
                    return FALSE;                   // not a match

                break;
        }
    }
}

BOOL
EmptyProcessWorkingSet(
    DWORD pid
    )
{
    HANDLE  hProcess;
    SIZE_T  dwMinimumWorkingSetSize;
    SIZE_T  dwMaximumWorkingSetSize;


    hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, pid );
    if (hProcess == NULL) {
        return FALSE;
    }

    if (!GetProcessWorkingSetSize(
            hProcess,
            &dwMinimumWorkingSetSize,
            &dwMaximumWorkingSetSize
            )) {
        CloseHandle( hProcess );
        return FALSE;
    }


    SetProcessWorkingSetSize( hProcess, 0xffffffff, 0xffffffff );
    CloseHandle( hProcess );

    return TRUE;
}

BOOL
EmptySystemWorkingSet(
    VOID
    )

{
    SYSTEM_FILECACHE_INFORMATION info;
    NTSTATUS status;

    info.MinimumWorkingSet = 0xffffffff;
    info.MaximumWorkingSet = 0xffffffff;
    if (!NT_SUCCESS (status = NtSetSystemInformation(
                                    SystemFileCacheInformation,
                                    &info,
                                    sizeof (info)))) {
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tlist\common.h ===
#pragma once

#if defined(__cplusplus)
extern "C" {
#endif

#define MAX_TASKS              1024
#define TITLE_SIZE             128
#define PROCESS_SIZE           16
#define SERVICENAMES_SIZE      1024
#define MTS_PACKAGE_NAMES_SIZE 1024

typedef struct _THREAD_INFO {
    ULONG ThreadState;
    HANDLE UniqueThread;
} THREAD_INFO, *PTHREAD_INFO;

typedef struct _FIND_MODULE_INFO {
    LPSTR  szModuleToFind;
    LPSTR  szMatchingModuleName;
    BOOL   fFound;
} FIND_MODULE_INFO, *PFIND_MODULE_INFO;


//
// task list structure
//
typedef struct _TASK_LIST {
    DWORD       dwProcessId;
    DWORD       dwInheritedFromProcessId;
    ULARGE_INTEGER CreateTime;
    BOOL        flags;
    HANDLE      hwnd;
    LPSTR       lpWinsta;
    LPSTR       lpDesk;
    CHAR        ProcessName[PROCESS_SIZE];
    CHAR        WindowTitle[TITLE_SIZE];
    SIZE_T      PeakVirtualSize;
    SIZE_T      VirtualSize;
    ULONG       PageFaultCount;
    SIZE_T      PeakWorkingSetSize;
    SIZE_T      WorkingSetSize;
    ULONG       NumberOfThreads;
    PTHREAD_INFO pThreadInfo;
    CHAR        ServiceNames[SERVICENAMES_SIZE];
    CHAR        MtsPackageNames[MTS_PACKAGE_NAMES_SIZE];
} TASK_LIST, *PTASK_LIST;

typedef struct _TASK_LIST_ENUM {
    PTASK_LIST  tlist;
    DWORD       numtasks;
    LPSTR       lpWinsta;
    LPSTR       lpDesk;
    BOOL        bFirstLoop;
} TASK_LIST_ENUM, *PTASK_LIST_ENUM;


DWORD
GetServiceProcessInfo(
    LPENUM_SERVICE_STATUS_PROCESS*  ppSvcInfo
    );

DWORD
GetTaskList(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    );

DWORD
GetTaskListEx(
    PTASK_LIST                          pTask,
    DWORD                               dwNumTasks,
    BOOL                                fThreadInfo,
    DWORD                               dwNumServices,
    const ENUM_SERVICE_STATUS_PROCESS*  pServiceInfo
    );

void
AddMtsPackageNames(
    PTASK_LIST Tasks,
    DWORD NumTasks
    );
    
void
PrintTasksUsingModule(
    LPTSTR szModuleName
    );


BOOL
DetectOrphans(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    );

BOOL
EnableDebugPriv(
    VOID
    );

BOOL
KillProcess(
    PTASK_LIST tlist,
    BOOL       fForce
    );

VOID
GetWindowTitles(
    PTASK_LIST_ENUM te
    );

BOOL
MatchPattern(
    PUCHAR String,
    PUCHAR Pattern
    );

BOOL
EmptyProcessWorkingSet(
    DWORD pid
    );

BOOL
EmptySystemWorkingSet(
    VOID
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tlist\makefile.inc ===
$(O)\kill.res: kill.rc

$(O)\tlist.res: tlist.rc

$(O)\empty.res: empty.rc

$(O)\emptyq.res: emptyq.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tlist\pch.h ===
#pragma once

// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Public windows headers.
//
#include <windows.h>
#include <comsvcs.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <common.ver>

#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tlist\empty.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    kill.c

Abstract:

    This module implements a working set empty application.

Author:

    Lou Perazzoli (loup) 20-May-1994
    Wesley Witt (wesw) 20-May-1994

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop


DWORD       pid;
CHAR        pname[MAX_PATH];
TASK_LIST   tlist[MAX_TASKS];

CHAR System[] = "System";

VOID GetCommandLineArgs(VOID);


int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD          i;
    DWORD          numTasks;
    int            rval = 0;
    TASK_LIST_ENUM te;
    char           tname[PROCESS_SIZE];
    LPSTR          p;


    GetCommandLineArgs();

    if (pid == 0 && pname[0] == 0) {
        printf( "missing pid or task name\n" );
        return 1;
    }

    //
    // let's be god
    //

    EnableDebugPriv();

    if (pid) {
        if (!EmptyProcessWorkingSet( pid )) {
            printf( "could not empty working set for process #%d\n", pid );
            return 1;
        }
        return 0;
    }

    //
    // get the task list for the system
    //
    numTasks = GetTaskList( tlist, MAX_TASKS );

    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    te.tlist = tlist;
    te.numtasks = numTasks;
    GetWindowTitles( &te );

    for (i=0; i<numTasks; i++) {
        strcpy( tname, tlist[i].ProcessName );
        p = strchr( tname, '.' );
        if (p) {
            p[0] = '\0';
        }
        if (MatchPattern( tname, pname )) {
            tlist[i].flags = TRUE;
        } else if (MatchPattern( tlist[i].ProcessName, pname )) {
            tlist[i].flags = TRUE;
        } else if (MatchPattern( tlist[i].WindowTitle, pname )) {
            tlist[i].flags = TRUE;
        }
    }

    for (i=0; i<numTasks; i++) {
        if (tlist[i].flags) {
            if (!EmptyProcessWorkingSet( tlist[i].dwProcessId )) {
                printf( "could not empty working set for process #%d [%s]\n", tlist[i].dwProcessId, tlist[i].ProcessName );
                rval = 1;
            }
        }
    }

    if (MatchPattern(System, pname )) {
        if (!EmptySystemWorkingSet()) {
            printf( "could not empty working set for process #%d [%s]\n",0,&System );
        }
    }

    return rval;
}

VOID
GetCommandLineArgs(
    VOID
    )
{
    char        *lpstrCmd;
    UCHAR       ch;
    char        *p = pname;


    pid = 0;
    *p = '\0';

    lpstrCmd = GetCommandLine();

    // skip over program name
    do {
        ch = *lpstrCmd++;
    }
    while (ch != ' ' && ch != '\t' && ch != '\0');

    //  skip over any following white space
    while (isspace(ch)) {
        ch = *lpstrCmd++;
    }

    if (isdigit(ch)) {
        while (isdigit(ch)) {
            pid = pid * 10 + ch - '0';
            ch = *lpstrCmd++;
        }
    }
    else {
      while (ch) {
            *p++ = ch;
            ch = *lpstrCmd++;
        }
        *p = '\0';
        _strupr( pname );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tlist\emptyq.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    emptyq.c

Abstract:

    This module implements a working set empty application.

Author:

    Lou Perazzoli (loup) 20-May-1994
    Wesley Witt (wesw) 20-May-1994

Environment:

    User Mode

--*/


#include "pch.h"
#pragma hdrstop


TASK_LIST   tlist[MAX_TASKS];
CHAR        buffer[64*1024];


int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD                       i;
    DWORD                       numTasks;
    int                         rval = 0;
    TASK_LIST_ENUM              te;
    char                        tname[PROCESS_SIZE];
    LPSTR                       p;
    ULONG                       first = FALSE;
    NTSTATUS                    status;
    PSYSTEM_MEMORY_INFORMATION  MemInfo;
    PSYSTEM_MEMORY_INFO         Info;
    PSYSTEM_MEMORY_INFO         InfoEnd;
    PUCHAR                      String;
    ULONG                       TotalValid;
    ULONG                       TotalPageTable;
    SYSTEMTIME                  Time;


    //
    // let's be god
    //

    EnableDebugPriv();

    for (; ; ) {

        SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
        if (first) {
            status = NtQuerySystemInformation (SystemSummaryMemoryInformation,
                                             &buffer,
                                             64*1024,
                                             NULL);
            if (!NT_SUCCESS (status)) {
                printf("query system information failed %lx\n",status);
                return 1;
            }
            GetLocalTime (&Time);

            TotalValid = 0;
            TotalPageTable = 0;
            MemInfo = (PSYSTEM_MEMORY_INFORMATION)buffer;
            Info = &MemInfo->Memory[0];
            InfoEnd = (PSYSTEM_MEMORY_INFO)MemInfo->StringStart;
            printf("  time: %ld %2ld:%2ld.%03ld\n",
                                 Time.wHour,
                                 Time.wMinute,
                                 Time.wSecond,
                                Time.wMilliseconds);
            while (Info < InfoEnd) {
                if (Info->PageTableCount &&
                    ((Info->PageTableCount + 2) >= Info->ValidCount)) {
                    Info += 1;
                    continue;
                }
                if (Info->StringOffset != 0) {
                    if (*(PUCHAR)(Info->StringOffset + 1) != 0) {
                        printf("%4ld. %4ld. %s\n",Info->ValidCount*4,
                                            Info->PageTableCount*4,
                                            Info->StringOffset);
                    } else {
                        printf("%4ld. %4ld. %ws\n",Info->ValidCount*4,
                                        Info->PageTableCount*4,
                                        Info->StringOffset);
                    }
                } else {
                    printf("%4ld. %4ld. unable to get name\n",Info->ValidCount*4,
                                    Info->PageTableCount*4);
                }
                TotalValid += Info->ValidCount;
                TotalPageTable += Info->PageTableCount;
                Info += 1;
            }
            printf("\n%4ld. %4ld.  ** TOTAL **\n\n\n",
                    TotalValid*4,
                    TotalPageTable*4);

        }

        first = TRUE;

        //
        // get the task list for the system
        //

        numTasks = GetTaskList( tlist, MAX_TASKS );

        //
        // enumerate all windows and try to get the window
        // titles for each task
        //

        te.tlist = tlist;
        te.numtasks = numTasks;
        GetWindowTitles( &te );

        for (i=0; i<numTasks; i++) {
                if (!EmptyProcessWorkingSet( tlist[i].dwProcessId )) {
                    //printf( "could not empty working set for process #%d [%s]\n", tlist[i].dwProcessId, tlist[i].ProcessName );
                    rval = 1;
                }
        }

        if (!EmptySystemWorkingSet()) {
                //printf( "could not empty working set for process #%d [%s]\n",0,&System );
        }

        Sleep (1000);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tlist\kill.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    kill.c

Abstract:

    This module implements a task killer application.

Author:

    Wesley Witt (wesw) 20-May-1994

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop


BOOL        ForceKill;

struct _arg {
    DWORD pid;
    CHAR *pname;
} Arguments[ 64 ];
DWORD NumberOfArguments;

TASK_LIST   tlist[MAX_TASKS];


VOID GetCommandLineArgs(VOID);
VOID Usage(VOID);



int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD          i, j;
    DWORD          numTasks;
    TASK_LIST_ENUM te;
    int            rval = 0;
    char           tname[PROCESS_SIZE];
    LPSTR          p;
    DWORD          ThisPid;


    GetCommandLineArgs();

    if (NumberOfArguments == 0) {
        printf( "missing pid or task name\n" );
        return 1;
    }

    //
    // lets be god
    //
    EnableDebugPriv();

    //
    // get the task list for the system
    //
    numTasks = GetTaskList( tlist, MAX_TASKS );

    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    te.tlist = tlist;
    te.numtasks = numTasks;
    GetWindowTitles( &te );

    ThisPid = GetCurrentProcessId();

    for (i=0; i<numTasks; i++) {
        //
        // this prevents the user from killing KILL.EXE and
        // it's parent cmd window too
        //
        if (ThisPid == tlist[i].dwProcessId) {
            continue;
        }
        if (MatchPattern( tlist[i].WindowTitle, "*KILL*" )) {
            continue;
        }

        tname[0] = 0;
        strcpy( tname, tlist[i].ProcessName );
        p = strchr( tname, '.' );
        if (p) {
            p[0] = '\0';
        }

        for (j=0; j<NumberOfArguments; j++) {
            if (Arguments[j].pname) {
                if (MatchPattern( tname, Arguments[j].pname )) {
                    tlist[i].flags = TRUE;
                } else if (MatchPattern( tlist[i].ProcessName, Arguments[j].pname )) {
                    tlist[i].flags = TRUE;
                } else if (MatchPattern( tlist[i].WindowTitle, Arguments[j].pname )) {
                    tlist[i].flags = TRUE;
                }
            } else if (Arguments[j].pid) {
                    if (tlist[i].dwProcessId == Arguments[j].pid) {
                        tlist[i].flags = TRUE;
                    }
            }
        }
    }

    for (i=0; i<numTasks; i++) {
        if (tlist[i].flags) {
            if (KillProcess( &tlist[i], ForceKill )) {
                printf( "process %s (%d) - '%s' killed\n",
                        tlist[i].ProcessName,
                        tlist[i].dwProcessId,
                        tlist[i].hwnd ? tlist[i].WindowTitle : ""
                      );
            } else {
                printf( "process %s (%d) - '%s' could not be killed\n",
                        tlist[i].ProcessName,
                        tlist[i].dwProcessId,
                        tlist[i].hwnd ? tlist[i].WindowTitle : ""
                      );
                rval = 1;
            }
        }
    }

    return rval;
}

VOID
GetCommandLineArgs(
    VOID
    )
{
    char        *lpstrCmd;
    UCHAR       ch;
    DWORD       pid;
    char        pname[MAX_PATH];
    char        *p;

    lpstrCmd = GetCommandLine();

    // skip over program name
    do {
        ch = *lpstrCmd++;
    }
    while (ch != ' ' && ch != '\t' && ch != '\0');

    NumberOfArguments = 0;
    while (ch != '\0') {
        //  skip over any following white space
        while (ch != '\0' && isspace(ch)) {
            ch = *lpstrCmd++;
        }
        if (ch == '\0') {
            break;
        }

        //  process each switch character '-' as encountered

        while (ch == '-' || ch == '/') {
            ch = (UCHAR)tolower(*lpstrCmd++);
            //  process multiple switch characters as needed
            do {
                switch (ch) {
                    case 'f':
                        ForceKill = TRUE;
                        ch = *lpstrCmd++;
                        break;

                    case '?':
                        Usage();
                        ch = *lpstrCmd++;
                        break;

                    default:
                        return;
                }
            } while (ch != ' ' && ch != '\t' && ch != '\0');

            while (ch == ' ' || ch == '\t') {
                ch = *lpstrCmd++;
            }
        }

        if (isdigit(ch)) {
            pid = 0;
            while (isdigit(ch)) {
                pid = pid * 10 + ch - '0';
                ch = *lpstrCmd++;
            }
            Arguments[NumberOfArguments].pid = pid;
            Arguments[NumberOfArguments].pname = NULL;
            NumberOfArguments += 1;
        }
        else
        if (ch != '\0') {
            p = pname;
            do {
                *p++ = ch;
                ch = *lpstrCmd++;
            } while (ch != ' ' && ch != '\t' && ch != '\0');
            *p = '\0';
            _strupr( pname );
            Arguments[NumberOfArguments].pid = 0;
            Arguments[NumberOfArguments].pname = malloc(strlen(pname)+1);
            strcpy(Arguments[NumberOfArguments].pname, pname);
            NumberOfArguments += 1;
        }
    }

    return;
}

VOID
Usage(
    VOID
    )

/*++

Routine Description:

    Prints usage text for this tool.

Arguments:

    None.

Return Value:

    None.

--*/

{
    fprintf( stderr, "Microsoft (R) Windows NT (TM) Version 3.5 KILL\n" );
    fprintf( stderr, "Copyright (C) 1994-1998 Microsoft Corp. All rights reserved\n\n" );
    fprintf( stderr, "usage: KILL [options] <<pid> | <pattern>>*\n\n" );
    fprintf( stderr, "           [options]:\n" );
    fprintf( stderr, "               -f     Force process kill\n\n" );
    fprintf( stderr, "           <pid>\n" );
    fprintf( stderr, "              This is the process id for the task\n" );
    fprintf( stderr, "               to be killed.  Use TLIST to get a\n" );
    fprintf( stderr, "               valid pid\n\n" );
    fprintf( stderr, "           <pattern>\n" );
    fprintf( stderr, "              The pattern can be a complete task\n" );
    fprintf( stderr, "              name or a regular expression pattern\n" );
    fprintf( stderr, "              to use as a match.  Kill matches the\n" );
    fprintf( stderr, "              supplied pattern against the task names\n" );
    fprintf( stderr, "              and the window titles.\n" );
    ExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\touch\touch.c ===
/* touch.c - make last time on file be current time
 *
 *  touch [files] - requires arg expansion
 */

#include <io.h>
#include <sys\types.h>
#include <sys\utime.h>
#include <sys\stat.h>
#include <time.h>
#include <stdio.h>
#include <process.h>
#include <math.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>

#define year  rgInt[0]
#define month rgInt[1]
#define day   rgInt[2]
#define hour  rgInt[3]
#define mins  rgInt[4]
#define sec   rgInt[5]
int rgInt[6];

void usage( char *Msg, int MsgArg )
{
    printf( "usage: TOUCH [/f] [/t year month day hour min sec] files"
            "\n"
            "where: /f - force file touch if read only\n"
            "       /t - specifies a specific time other than the current time.\n"
            "       /c - specifies to create the file if it does not exist.\n"
          );
    printf( "\nTOUCH: " );
    printf( Msg, MsgArg );
    printf( "\n" );
    exit( 1 );
}

int
__cdecl main (c, v)
int c;
char *v[];
{
    time_t ltime;
    struct utimbuf timenow;
    int i;
    int fh;
    char *p;
    int ReturnCode = 0;
    int force = 0;
    int create= 0;

    ConvertAppToOem( c, v );
    SHIFT (c,v);
    if ( c == 0 )
        usage( "invalid number of parameters", 0 );

    time (&ltime);
    while (fSwitChr (*(p = *v))) {
        while (*++p) {
            if (tolower(*p) == 'f')
                force = 1;
            else
            if (tolower(*p) == 'c')
                create = 1;
            else
            if (tolower(*p) == 't') {
                for (i = 0; i < 6; i++) {
                    SHIFT (c, v);
                    if (!c)
                        usage( "incorrect time", 0 );
                    rgInt[i] = atoi (*v);
                    }

                //
                //  do some basic date checking
                //
                if ( (year < 1980) || (month > 12) || (day>31) ||
                     (hour>23) || (mins>59) || (sec>59) ) {
                    usage( "incorrect time", 0 );
                }
                ltime = date2l(year, month, day, hour, mins, sec);
            } else
                usage( "bad switch '%c'", *p );
        }
        SHIFT (c, v);
    }

    timenow.actime = ltime;
    timenow.modtime = ltime;

    while (c) {
        //
        // Set the time
        //

        if (_utime (*v, (void *) &timenow) == -1) {
            //
            // Failed.  Does it exist?
            //
            if (_access(*v, 0) == -1) {
                //
                // Does not exist.  Create if requested and touch created file.
                //
                if (create) {
                    fh = _creat(*v, _S_IREAD|_S_IWRITE);
                    _close(fh);
                    if (_utime (*v, (void *) &timenow) == 0)  // touch it
                        goto shift_it;
                    }
                }
            else
            //
            // File exists, is it read-only and /f specified?
            //
            if (force && (_access(*v,2) == -1)) {
                //
                // Yes, make it read/write and change the time
                // then make it read-only again.
                //
                if (_chmod (*v, _S_IWRITE) == 0) {
                    if (_utime (*v, (void *) &timenow) == 0) {
                        if (_chmod (*v, _S_IREAD) != 0) {
                            printf ("ERROR - changed 'r' attrib on %s, could not change it back\n", *v);
                            ReturnCode = 1;
                            }
                        goto shift_it;
                        }
                    }
                }

            printf ("Can't touch %s - %s\n", *v, error ());
            ReturnCode = 1;
            }
shift_it:
        SHIFT(c,v);
        }
    return ReturnCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tlist\tlist.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    tlist.c

Abstract:

    This module implements a task list application.

Author:

    Wesley Witt (wesw) 20-May-1994
    Mike Sartain (mikesart) 28-Oct-1994  Added detailed task information
    Julian Jiggins (julianj) 19-Mar-1998 Added list processes using specific module feature
    Shaun Cox (shaunco) 9-Jul-1998 Display services running in processes

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop
#include <dbghelp.h>
#include "psapi.h"


#define BAD_PID     ((DWORD)-1)


DWORD       numTasks;
TASK_LIST   tlist[MAX_TASKS];
BOOL        fShowServices;
BOOL        fShowMtsPackages;

const char *Blanks = "                                                                               ";


VOID Usage(VOID);
VOID PrintThreadInfo(PTASK_LIST pTaskList);
BOOL FMatchTaskName(LPTSTR szPN, LPTSTR szWindowTitle, LPTSTR szProcessName);
VOID GetFirstPidWithName(LPTSTR szTask);

VOID
PrintTask(
    DWORD i
    )
{
    BOOL NameShown = FALSE;
    
    printf( "%4d %-16s", tlist[i].dwProcessId, tlist[i].ProcessName );

    if (fShowServices && tlist[i].ServiceNames[0]) {
        printf( "Svcs:  %s", tlist[i].ServiceNames);
        NameShown = TRUE;
    }

    if (fShowMtsPackages && tlist[i].MtsPackageNames[0]) {
        printf( "%sMts:   %s", NameShown ? "  " : "",
                tlist[i].MtsPackageNames);
        NameShown = TRUE;
    }

    if (!NameShown && tlist[i].hwnd) {
        if (fShowServices || fShowMtsPackages) {
            printf( "Title: %s", tlist[i].WindowTitle );
        }
        else {
            printf( "  %s", tlist[i].WindowTitle );
        }
    }

    printf( "\n" );
}

VOID
PrintTaskTree(
    DWORD level,
    DWORD id
    )
{
    DWORD i;

    DetectOrphans( tlist, numTasks );
    for (i=0; i<numTasks; i++) {
        if (tlist[i].flags) {
            continue;
        }

        // NOTE: The format of the output below should stay fixed forever.  There are tools
        // at MS that depend on it.

        if (level == 0 || tlist[i].dwInheritedFromProcessId == id) {
            printf( "%.*s", level*2, Blanks );
            printf( "%s (%d)", tlist[i].ProcessName, tlist[i].dwProcessId );
            if (tlist[i].hwnd) {
                printf( " %s", tlist[i].WindowTitle );
            }
            printf( "\n" );
            tlist[i].flags = TRUE;
            if (tlist[i].dwProcessId != 0) {
                PrintTaskTree( level+1, tlist[i].dwProcessId );
            }
        }
    }
}

int __cdecl
main(
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Main entrypoint for the TLIST application.  This app prints
    a task list to stdout.  The task list include the process id,
    task name, ant the window title.

Arguments:

    argc             - argument count
    argv             - array of pointers to arguments

Return Value:

    0                - success

--*/

{
    DWORD           i;
    TASK_LIST_ENUM  te;
    BOOL            fTree;
    BOOL            fFindTasksUsingModule;
    BOOL            fPidOnly = FALSE;
    DWORD           cchPN = 0;
    LPSTR           szPN  = NULL;
    DWORD           dwPID = BAD_PID;
    DWORD                           dwNumServices = 0;
    LPENUM_SERVICE_STATUS_PROCESS   pServiceInfo  = NULL;

    if (argc > 1 && (argv[1][0] == '-' || argv[1][0] == '/') && argv[1][1] == '?') {
        Usage();
    }

    fTree = FALSE;
    fFindTasksUsingModule = FALSE;
    if (argc > 1) {
        if ((argv[1][0] == '-' || argv[1][0] == '/') && (argv[1][1] == 't' || argv[1][1] == 'T')) {
            fTree = TRUE;
        } else if ((argv[1][0] == '-' || argv[1][0] == '/') && (argv[1][1] == 's' || argv[1][1] == 'S')) {
            fShowServices = TRUE;
        } else if ((argv[1][0] == '-' || argv[1][0] == '/') && (argv[1][1] == 'k' || argv[1][1] == 'K')) {
            fShowMtsPackages = TRUE;
        } else if ((argv[1][0] == '-' || argv[1][0] == '/') && (argv[1][1] == 'p' || argv[1][1] == 'P') && argc == 3) {
            _strlwr(argv[2]);
            if (!strcmp(argv[2], "system process")) {
                printf("0\n");
                return 0;
            }
            fPidOnly = TRUE;
        } else if ((argv[1][0] == '-' || argv[1][0] == '/') && (argv[1][1] == 'p' || argv[1][1] == 'P') && argc == 4) {
            _strlwr(argv[2]);
            if (!strcmp(argv[2], "system")) {
                _strlwr(argv[3]);
                if (!strcmp(argv[3], "process")) {
                    printf("0\n");
                    return 0;
                }
            }
            Usage();
        } else if ((argv[1][0] == '-' || argv[1][0] == '/') && (argv[1][1] == 'm' || argv[1][1] == 'M') && argc == 3) {
            fFindTasksUsingModule = TRUE;
        } else {
            szPN = argv[1];
            if (!(dwPID = atol(szPN)) && szPN[0] != '0' && szPN[1] != 0) {
                dwPID = BAD_PID;
                cchPN = strlen(szPN);
                _strupr(szPN);
            }
        }
    }

    //
    // lets be god
    //
    EnableDebugPriv();

//#if 0 // XXX olegk - enable the block after RI with debugger tree
    //
    // Include 32bit modules in enumeration
    //
    {
        DWORD SymOpt = SymGetOptions();
        SymOpt |= SYMOPT_INCLUDE_32BIT_MODULES;
        SymSetOptions(SYMOPT_INCLUDE_32BIT_MODULES);
    }
//#endif // XXX olegk

    //
    // get the task list for the system
    //
    //
    // Get the process information for all active Win32 services.
    // This allows us to print the service names next to the processes
    // that host them.
    //
    dwNumServices = GetServiceProcessInfo( &pServiceInfo );

    numTasks = GetTaskListEx(
                    tlist,
                    MAX_TASKS,
                    cchPN || (dwPID != BAD_PID),
                    dwNumServices,
                    pServiceInfo);

    free( pServiceInfo );

    if (fShowMtsPackages) {
        AddMtsPackageNames(tlist, numTasks);
    }
            
    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    te.tlist = tlist;
    te.numtasks = numTasks;
    GetWindowTitles( &te );

    //
    // print the task list
    //
    if (fTree) {
        PrintTaskTree( 0, 0 );
    } else if (fFindTasksUsingModule) {
        PrintTasksUsingModule(argv[2]);
    } else if (fPidOnly) {
        GetFirstPidWithName(argv[2]);
    } else {
        for (i=0; i<numTasks; i++) {
            if ((dwPID == BAD_PID) && (!cchPN)) {
                PrintTask( i );
            }
            else
            if ((dwPID == tlist[i].dwProcessId) ||
                (cchPN && FMatchTaskName(szPN, tlist[i].WindowTitle, tlist[i].ProcessName))) {
                    PrintTask( i );
                    PrintThreadInfo(tlist + i);
            }

            if (tlist[i].pThreadInfo) {
                free(tlist[i].pThreadInfo);
            }
        }
    }

    //
    // end of program
    //
    return 0;
}


VOID
GetFirstPidWithName(
    LPTSTR szTask
    )
/*++
Routine Description:

    Returns the PID of the first task with a Name matching the specified
    Name.  IF no task is found -1 is returned
Arguments:

    szTask    - module name to search for

--*/
{
    DWORD i;
    CHAR szPName[PROCESS_SIZE + 1];
    CHAR szNameWExe[PROCESS_SIZE + 1];

    strcpy(szNameWExe, szTask);
    strcat(szNameWExe, ".exe");

    for (i=0; i<numTasks; i++) {
        strcpy(szPName, tlist[i].ProcessName);
        _strlwr(szPName);

        if ((!strcmp(szPName, szTask))||(!strcmp(szPName, szNameWExe))) {
            if (tlist[i].dwProcessId != 0) {
                printf("%d\n", tlist[i].dwProcessId);
                return;
            }
        }
    }
    printf("-1\n");
}


VOID
Usage(
    VOID
    )

/*++

Routine Description:

    Prints usage text for this tool.

Arguments:

    None.

Return Value:

    None.

--*/

{
    fprintf( stderr,
            "Microsoft (R) Windows NT (TM) Version 5.1 TLIST\n"
            VER_LEGALCOPYRIGHT_STR
            "\n\n"
            "usage: TLIST"
            " <<-m <pattern>> | <-t> | <pid> | <pattern> | <-p <processname>>> | <-k> | <-s>\n"
            "           [options]:\n"
            "           -t\n"
            "              Print Task Tree\n\n"
            "           <pid>\n"
            "              List module information for this task.\n\n"
            "           <pattern>\n"
            "              The pattern can be a complete task\n"
            "              name or a regular expression pattern\n"
            "              to use as a match.  Tlist matches the\n"
            "              supplied pattern against the task names\n"
            "              and the window titles.\n\n"
            "           -k\n"
            "              Show MTS packages active in each process.\n\n"
            "           -m <pattern>\n"
            "              Lists all tasks that have DLL modules loaded\n"
            "              in them that match the given pattern name\n\n"
            "           -s\n"
            "              Show services active in each process.\n\n"
            "           -p <processname>\n"
            "              Returns the PID of the process specified or -1\n"
            "              if the specified process doesn't exist.  If there\n"
            "              are multiple instances of the process running only\n"
            "              the instance with the first PID value is returned.\n\n"
            "\n");
    ExitProcess(0);
}


//
// Routines used to list all processes that have a specific module in use
//

BOOL
FindSpecificModuleCallback(
    LPSTR       Name,
    DWORD_PTR   Base,
    DWORD       Size,
    PVOID       Context
    )

/*++

Routine Description:

    Callback function for module enumeration to find a specific module

Arguments:

    Name        - Module name
    Base        - Base address
    Size        - Size of image
    Context     - User context pointer

Return Value:

    TRUE             - Continue enumeration
    FALSE            - Stop enumeration

--*/

{
    PFIND_MODULE_INFO pFindModuleInfo;

    pFindModuleInfo = (PFIND_MODULE_INFO)Context;

    if (MatchPattern(Name, pFindModuleInfo->szModuleToFind))
    {
        pFindModuleInfo->fFound = TRUE;
        strcpy(pFindModuleInfo->szMatchingModuleName, Name);
        return FALSE; // Found Module so stop enumerating
    }

    return TRUE;
}

BOOL
IsTaskUsingModule(
    PTASK_LIST pTask,
    LPTSTR     szModuleName,
    LPTSTR     szMatchingModuleName
    )

/*++

Routine Description:

    Checks if the given task has the given module loaded

Arguments:

    pTaskList   - task to search for module
    szModule    - module name to search for

Return Value:

    TRUE             - if the module is loaded in the task
    FALSE            - if the module is not loaded in the task

--*/

{
    FIND_MODULE_INFO FindModuleInfo;

    FindModuleInfo.fFound = FALSE;
    FindModuleInfo.szModuleToFind = szModuleName;
    FindModuleInfo.szMatchingModuleName = szMatchingModuleName;

    EnumerateLoadedModules(
        (HANDLE) UlongToPtr(pTask->dwProcessId),
        FindSpecificModuleCallback,
        &FindModuleInfo
        );

    return FindModuleInfo.fFound;
}

void
PrintTasksUsingModule(
    LPTSTR szModuleName
    )

/*++

Routine Description:

    Enumerates through all the tasks in the system looking for those that
    have loaded modules of the given name.

Arguments:

    szModule    - module name to search for

Return Value:

    None

--*/

{
    BOOL fUsed = FALSE;
    DWORD i;
    CHAR szMatchingModuleName[64];

    _strupr(szModuleName); // Needed for wildcarding

    for (i=0; i<numTasks; i++) {
        if (IsTaskUsingModule(tlist + i, szModuleName, szMatchingModuleName)) {
            printf("%s - ", szMatchingModuleName);
            PrintTask( i );
            fUsed = TRUE;
        }
    }
    if (!fUsed) {
        printf( "No tasks found using %s\n", szModuleName );
    }
}


BOOL
GetVersionStuff(
    LPTSTR szFileName,
    VS_FIXEDFILEINFO *pvsRet
    )

/*++

Routine Description:

    Get fixedfileinfo for szFileName.

Arguments:

    szFileName       - name of file
    pvsRet           - fixedfileinfo return struct

Return Value:

    TRUE             - success
    FALSE            - failure

--*/

{
    DWORD               dwHandle;
    DWORD               dwLength;
    BOOL                fRet = FALSE;
    LPVOID              lpvData = NULL;

    if (!(dwLength = GetFileVersionInfoSize(szFileName, &dwHandle))) {
        goto err;
    }

    if (lpvData = malloc(dwLength)) {
        if (GetFileVersionInfo(szFileName, 0, dwLength, lpvData)) {

            UINT                uLen;
            VS_FIXEDFILEINFO    *pvs;
            DWORD               *pdwTranslation;
            DWORD               dwDefLang = 0x409;

            if (!VerQueryValue(lpvData, "\\VarFileInfo\\Translation",
                &pdwTranslation, &uLen)) {
                // if we can't get the langid, default to usa
                pdwTranslation = &dwDefLang;
                uLen = sizeof(DWORD);
            }

            if (VerQueryValue(lpvData, "\\", (LPVOID *)&pvs, &uLen)) {
                *pvsRet = *pvs;
                fRet = TRUE;
            }
        }
    }

err:
    if (lpvData)
        free(lpvData);
    return fRet;
}

BOOL
EnumLoadedModulesCallback(
    LPSTR       Name,
    DWORD_PTR   Base,
    DWORD       Size,
    PVOID       Context
    )

/*++

Routine Description:

    Callback function for module enumeration

Arguments:

    Name        - Module name
    Base        - Base address
    Size        - Size of image
    Context     - User context pointer

Return Value:

    TRUE             - Continue enumeration
    FALSE            - Stop enumeration

--*/

{
    VS_FIXEDFILEINFO    vs;
    CHAR                szBuffer[100];


    szBuffer[0] = 0;
    if (GetVersionStuff( Name, &vs )) {
        wsprintf( szBuffer, "%u.%u.%u.%u %s",
            HIWORD(vs.dwFileVersionMS),
            LOWORD(vs.dwFileVersionMS),
            HIWORD(vs.dwFileVersionLS),
            LOWORD(vs.dwFileVersionLS),
            vs.dwFileFlags & VS_FF_DEBUG ? "dbg" : "shp"
            );
    }
    printf( " %18.18s  0x%08x  %s\n", szBuffer, Base, Name );
    return TRUE;
}

BOOL
PrintModuleList(
    ULONG ProcessId
    )

/*++

Routine Description:

    Prints list of modules in ProcessId

Arguments:

    ProcessID       - process id

Return Value:

    TRUE             - success
    FALSE            - failure

--*/

{
    EnumerateLoadedModules(
        (HANDLE) UlongToPtr(ProcessId),
        EnumLoadedModulesCallback,
        NULL
        );
    return TRUE;
}

DWORD
GetWin32StartAddress(
    HANDLE hThread
    )

/*++

Routine Description:

    Get starting address for thread

Arguments:

    hThread

Return Value:

    Starting Thread address or 0

--*/

{
    NTSTATUS    Status;
    DWORD       ThreadInformation;

    // make sure we have a handle
    if (!hThread)
        return 0;

    // get the threadinfo
    Status = NtQueryInformationThread(hThread, ThreadQuerySetWin32StartAddress,
        &ThreadInformation, sizeof(ThreadInformation), NULL);
    if (!NT_SUCCESS(Status))
        return 0;

    return ThreadInformation;
}

ULONG
GetLastThreadErr(
    HANDLE hThread
    )

/*++

Routine Description:

    Get Last Error for a Thread

Arguments:

    hThread

Return Value:

    LastError or 0

--*/

{
    TEB                         Teb;
    NTSTATUS                    Status;
    HANDLE                      hProcess;
    ULONG                       LastErrorValue;
    THREAD_BASIC_INFORMATION    ThreadInformation;

    // make sure we have a handle
    if (!hThread)
        return 0;

    // query for basic thread info
    Status = NtQueryInformationThread(hThread, ThreadBasicInformation,
        &ThreadInformation, sizeof(ThreadInformation), NULL);
    if (!NT_SUCCESS(Status))
        return 0;

    // get handle to process
    if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE,
        (DWORD)(DWORD_PTR)ThreadInformation.ClientId.UniqueProcess))) {
        return 0;
    }

    __try {
        // read the TEB from the process and get the last error value
        if (ReadProcessMemory(hProcess,
            ThreadInformation.TebBaseAddress, &Teb, sizeof(TEB), NULL)) {
            LastErrorValue = Teb.LastErrorValue;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
    }

    // close the hProcess
    CloseHandle(hProcess);

    return LastErrorValue;
}

BOOL
FPrintPEBInfo(
    HANDLE hProcess
    )

/*++

Routine Description:

    Prints cmdline and cwd of hProcess

Arguments:

    hProcess.

Return Value:

    TRUE             - success
    FALSE            - failure

--*/

{
    PEB                         Peb;
    NTSTATUS                    Status;
    PROCESS_BASIC_INFORMATION   BasicInfo;
    BOOL                        fRet = FALSE;
    WCHAR                       szT[MAX_PATH * 2];
    RTL_USER_PROCESS_PARAMETERS ProcessParameters;

    Status = NtQueryInformationProcess(hProcess, ProcessBasicInformation,
        &BasicInfo, sizeof(BasicInfo), NULL);
    if (!NT_SUCCESS(Status)) {
        SetLastError(RtlNtStatusToDosError(Status));
        return fRet;
    }

    __try {
        // get the PEB
        if (ReadProcessMemory(hProcess, BasicInfo.PebBaseAddress, &Peb,
            sizeof(PEB), NULL)) {
            // get the processparameters
            if (ReadProcessMemory(hProcess, Peb.ProcessParameters,
                &ProcessParameters, sizeof(ProcessParameters), NULL)) {
                // get the CWD
                if (ReadProcessMemory(hProcess,
                    ProcessParameters.CurrentDirectory.DosPath.Buffer, szT,
                    sizeof(szT), NULL)) {
                        wprintf(L"   CWD:     %s\n", szT);
                }

                // get cmdline
                if (ReadProcessMemory(hProcess, ProcessParameters.CommandLine.Buffer,
                    szT, sizeof(szT), NULL)) {
                        wprintf(L"   CmdLine: %s\n", szT);
                }

                fRet = TRUE;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
    }

    return fRet;
}


// copied from the win32 API code since we need to run on NT 4 and this is a
// new API to NT 5

HANDLE
TlistOpenThread(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    )

/*++

Routine Description:

    A handle to a thread object may be created using OpenThread.

    Opening a thread creates a handle to the specified thread.
    Associated with the thread handle is a set of access rights that
    may be performed using the thread handle.  The caller specifies the
    desired access to the thread using the DesiredAccess parameter.

Arguments:

    mDesiredAccess - Supplies the desired access to the thread object.
        For NT/Win32, this access is checked against any security
        descriptor on the target thread.  The following object type
        specific access flags can be specified in addition to the
        STANDARD_RIGHTS_REQUIRED access flags.

        DesiredAccess Flags:

        THREAD_TERMINATE - This access is required to terminate the
            thread using TerminateThread.

        THREAD_SUSPEND_RESUME - This access is required to suspend and
            resume the thread using SuspendThread and ResumeThread.

        THREAD_GET_CONTEXT - This access is required to use the
            GetThreadContext API on a thread object.

        THREAD_SET_CONTEXT - This access is required to use the
            SetThreadContext API on a thread object.

        THREAD_SET_INFORMATION - This access is required to set certain
            information in the thread object.

        THREAD_SET_THREAD_TOKEN - This access is required to set the
            thread token using SetTokenInformation.

        THREAD_QUERY_INFORMATION - This access is required to read
            certain information from the thread object.

        SYNCHRONIZE - This access is required to wait on a thread object.

        THREAD_ALL_ACCESS - This set of access flags specifies all of the
            possible access flags for a thread object.

    bInheritHandle - Supplies a flag that indicates whether or not the
        returned handle is to be inherited by a new process during
        process creation.  A value of TRUE indicates that the new
        process will inherit the handle.

    dwThreadId - Supplies the thread id of the thread to open.

Return Value:

    NON-NULL - Returns an open handle to the specified thread.  The
        handle may be used by the calling process in any API that
        requires a handle to a thread.  If the open is successful, the
        handle is granted access to the thread object only to the
        extent that it requested access through the DesiredAccess
        parameter.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    CLIENT_ID ClientId;

    ClientId.UniqueThread = (HANDLE)LongToHandle(dwThreadId);
    ClientId.UniqueProcess = (HANDLE)NULL;

    InitializeObjectAttributes(
        &Obja,
        NULL,
        (bInheritHandle ? OBJ_INHERIT : 0),
        NULL,
        NULL
        );
    Status = NtOpenThread(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess,
                &Obja,
                &ClientId
                );
    if ( NT_SUCCESS(Status) ) {
        return Handle;
        }
    else {
        return NULL;
        }
}



VOID
PrintThreadInfo(
    PTASK_LIST pTaskList
    )

/*++

Routine Description:

    Prints all kinds of info about a task

Arguments:

    PTASK_LIST of task to print

Return Value:

    None.

--*/

{
    UINT    nThread;
    HANDLE  hProcess;

    // from \\kernel\razzle2\src\ntos\inc\ke.h
    #define MAX_THREADSTATE    (sizeof(szThreadState) / sizeof(TCHAR *))
    static const TCHAR  *szThreadState[] = {
        "Initialized",
        "Ready     ",
        "Running   ",
        "Standby   ",
        "Terminated",
        "Waiting   ",
        "Transition",
        "???       " };

    // get a handle to the process
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pTaskList->dwProcessId);
    if (!hProcess)
        return;

    // print the CWD and CmdLine
    FPrintPEBInfo(hProcess);

    printf( "   VirtualSize:   %6ld KB"
            "   PeakVirtualSize:   %6ld KB\n",
                pTaskList->VirtualSize / 1024,
                pTaskList->PeakVirtualSize / 1024);

    printf( "   WorkingSetSize:%6ld KB"
            "   PeakWorkingSetSize:%6ld KB\n",
            pTaskList->WorkingSetSize / 1024,
            pTaskList->PeakWorkingSetSize / 1024);

    printf( "   NumberOfThreads: %ld\n",
            pTaskList->NumberOfThreads);

    // if we got any threadinfo, spit it out
    if (pTaskList->pThreadInfo) {
        for (nThread = 0; nThread < pTaskList->NumberOfThreads; nThread++) {

            PTHREAD_INFO pThreadInfo = &pTaskList->pThreadInfo[nThread];
            HANDLE hThread = TlistOpenThread(THREAD_QUERY_INFORMATION, FALSE,
                (DWORD)(DWORD_PTR)pThreadInfo->UniqueThread);

            printf("   %4d Win32StartAddr:0x%08x LastErr:0x%08x State:%s\n",
                HandleToUlong(pThreadInfo->UniqueThread),
                GetWin32StartAddress(hThread),
                GetLastThreadErr(hThread),
                szThreadState[min(pThreadInfo->ThreadState, MAX_THREADSTATE - 1)]);

            if (hThread)
                NtClose(hThread);
        }
    }

    // print the modules
    PrintModuleList( pTaskList->dwProcessId );

    // close the hProcess
    CloseHandle(hProcess);
}

BOOL
FMatchTaskName(
    LPTSTR szPN,
    LPTSTR szWindowTitle,
    LPTSTR szProcessName
    )
{
    LPTSTR  szT;
    TCHAR   szTName[PROCESS_SIZE];

    strncpy( szTName, szProcessName, PROCESS_SIZE );
    if (szT = strchr( szTName, '.' ))
        szT[0] = '\0';

    if (MatchPattern( szTName, szPN ) ||
        MatchPattern( szProcessName, szPN ) ||
        MatchPattern( szWindowTitle, szPN )) {
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\evntrprv\evntrprv.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) 1998-2000 Microsoft Corporation

\*****************************************************************************/

#include <wmistr.h>
#include <initguid.h>
#include <guiddef.h>
#include <evntrace.h>

#define MAXSTR              1024
#define MAXIMUM_LOGGERS     64  // should be in sync with wmiumkm.h

#define PROVIDER_NAME_EVENTTRACE L"TraceLogger"

#define DECODE_MODE_WBEM_TO_TRACE    1
#define DECODE_MODE_TRACE_TO_WBEM    2

#define G_ALLOC( s )  HeapAlloc( GetProcessHeap(), 0, s )
#define G_FREE( s )   if( s != NULL ) { HeapFree( GetProcessHeap(), 0, s ); }

ULONG EtsGetMaxEnableFlags();
HRESULT
EtsSetExtendedFlags(
    SAFEARRAY *saFlags,
    PEVENT_TRACE_PROPERTIES pLoggerInfo,
    ULONG offset
    );


class CEventTrace : public Provider 
{
public:
	CEventTrace(LPCWSTR chsClassName, LPCWSTR lpszNameSpace);
	virtual ~CEventTrace();

protected:
	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
	virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);

	virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

	virtual HRESULT ExecMethod( const CInstance& Instance,
				            const BSTR bstrMethodName,
				            CInstance *pInParams,
				            CInstance *pOutParams,
				            long lFlags = 0L 
                        );

    HRESULT LoadPropertyValues( 
                CInstance *pInstance, 
                PEVENT_TRACE_PROPERTIES pLoggerInfo,    
                PTRACE_GUID_PROPERTIES  *GuidPropertiesArray,
                ULONG nGuidCount
            );

    HRESULT LoadGuidArray( 
                PVOID* Storage, 
                PULONG pnGuidCount 
            );

private:
    HRESULT WmiFlushTrace( const CInstance &Instance );
    HRESULT WmiStopTrace( const CInstance &Instance );
    HRESULT WmiEnableTrace( const CInstance &Instance, bool bEnable, SAFEARRAY *saFlags, SAFEARRAY *saLevel, SAFEARRAY *saGuid, TRACEHANDLE LoggerHandle );

    HRESULT StartGlobalLogger( IN PEVENT_TRACE_PROPERTIES LoggerInfo );
    HRESULT DeleteGlobalLogger( IN PEVENT_TRACE_PROPERTIES LoggerInfo );
    
    HRESULT InitTraceProperties( PEVENT_TRACE_PROPERTIES* ppLoggerInfo );
    HRESULT DecodeFileMode( CInstance* pInstance, PEVENT_TRACE_PROPERTIES pLoggerInfo, DWORD dwFlags );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\evntrprv\evntrprv.cpp ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) 1998-2000 Microsoft Corporation

\*****************************************************************************/

#include <fwcommon.h>   
#include "evntrprv.h"

LPCWSTR cszGlobalLogger = L"GlobalLogger";
LPCWSTR cszKernelLogger = L"NT Kernel Logger";

_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));

HRESULT
SetGlobalLoggerSettings(
    DWORD StartValue,
    PEVENT_TRACE_PROPERTIES LoggerInfo,
    DWORD ClockType
);

ULONG hextoi( LPWSTR s )
{
    long len;
    ULONG num, base, hex;

    if (s == NULL || s[0] == L'\0') {
        return 0;
    }

    len = (long) wcslen(s);

    if (len == 0) {
        return 0;
    }

    hex  = 0;
    base = 1;
    num  = 0;

    while (-- len >= 0) {
        if (s[len] >= L'0' && s[len] <= L'9'){
            num = s[len] - L'0';
        }else if (s[len] >= L'a' && s[len] <= L'f'){
            num = (s[len] - L'a') + 10;
        }else if (s[len] >= L'A' && s[len] <= L'F'){
            num = (s[len] - L'A') + 10;
        }else if( s[len] == L'x' || s[len] == L'X'){
            break;
        }else{
            continue;
        }

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

CEventTrace SystemEventTraceProv( PROVIDER_NAME_EVENTTRACE, L"root\\wmi" );

const static WCHAR* pEventTraceErrorClass = L"\\\\.\\root\\wmi:EventTraceError";

CEventTrace::CEventTrace (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
    Provider(lpwszName, lpwszNameSpace)
{
}

CEventTrace::~CEventTrace ()
{
}

HRESULT 
CEventTrace::EnumerateInstances( MethodContext* pMethodContext, long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    ULONG i, nLoggers;
    DWORD dwSize;
    PEVENT_TRACE_PROPERTIES pLoggerInfo[MAXIMUM_LOGGERS];
    PEVENT_TRACE_PROPERTIES pStorage;
    PVOID Storage;
    PVOID GuidStorage = NULL;
    PTRACE_GUID_PROPERTIES* GuidPropertiesArray = NULL;
    ULONG nGuidCount = 0;

    dwSize = MAXIMUM_LOGGERS*(sizeof(EVENT_TRACE_PROPERTIES)+2*MAXSTR*sizeof(TCHAR));

    Storage =  G_ALLOC(dwSize);
    if( Storage == NULL ){
        return ERROR_OUTOFMEMORY;
    }

    RtlZeroMemory(Storage, dwSize);

    pStorage = (PEVENT_TRACE_PROPERTIES)Storage;

    for (i=0; i<MAXIMUM_LOGGERS; i++) {

        pStorage->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES)+2*MAXSTR*sizeof(TCHAR);
        pStorage->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES)+MAXSTR*sizeof(TCHAR);
        pStorage->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

        pLoggerInfo[i] = pStorage;

        pStorage = (PEVENT_TRACE_PROPERTIES)( (char*)pStorage + pStorage->Wnode.BufferSize);
    }

    hr = QueryAllTraces(
                pLoggerInfo,
                MAXIMUM_LOGGERS,
                &nLoggers 
            );

    if( ERROR_SUCCESS == hr ){

        try{
            if( ERROR_SUCCESS == LoadGuidArray( &GuidStorage, &nGuidCount ) ){
                GuidPropertiesArray = (PTRACE_GUID_PROPERTIES *)GuidStorage;
            }

            for( i=0; i<nLoggers && i<MAXIMUM_LOGGERS; i++){

                CInstancePtr pInstance( CreateNewInstance(pMethodContext), false );

                assert( NULL != pLoggerInfo[i] );

                if( NULL != pInstance ){
                    if( SUCCEEDED( LoadPropertyValues(pInstance, pLoggerInfo[i], GuidPropertiesArray, nGuidCount ) )){
                        hr = pInstance->Commit();
                    }
                }
            }

        }catch(...){
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    G_FREE( GuidStorage );
    G_FREE( Storage );
    
    return hr;
}

HRESULT CEventTrace::GetObject ( CInstance* pInstance, long lFlags )
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    PEVENT_TRACE_PROPERTIES pLoggerInfo = NULL;
    TRACEHANDLE LoggerHandle = 0;
    CHString LoggerName;
    
    pInstance->GetCHString( L"Name", LoggerName );

    hr = InitTraceProperties( &pLoggerInfo );
    
    if( ERROR_SUCCESS == hr ){

        hr = QueryTraceW( LoggerHandle, (LPCWSTR)LoggerName, pLoggerInfo);
    
        if( hr == ERROR_SUCCESS ){
            
            PVOID GuidStorage = NULL;
            PTRACE_GUID_PROPERTIES* GuidPropertiesArray = NULL;
            ULONG nGuidCount = 0;

            try{
                if( ERROR_SUCCESS == LoadGuidArray( &GuidStorage, &nGuidCount ) ){
                    GuidPropertiesArray = (PTRACE_GUID_PROPERTIES *)GuidStorage;
                }

                hr = LoadPropertyValues( pInstance, pLoggerInfo, GuidPropertiesArray, nGuidCount );
            }catch(...){
                hr = WBEM_E_OUT_OF_MEMORY;
            }
            
            G_FREE( GuidStorage );

        }
 
        G_FREE( pLoggerInfo );
    }

    return hr;
}

HRESULT CEventTrace::LoadGuidArray( PVOID* Storage, PULONG pnGuidCount )
{
    ULONG i;
    ULONG nGuidArray = 16;
    ULONG nGuidCount = 0;
    DWORD dwSize;
    PTRACE_GUID_PROPERTIES* GuidPropertiesArray;
    PTRACE_GUID_PROPERTIES pStorage;
    HRESULT hr;

    do{
        dwSize = nGuidArray * (sizeof(TRACE_GUID_PROPERTIES) + sizeof(PTRACE_GUID_PROPERTIES));
        *Storage = G_ALLOC(dwSize);
        if(*Storage == NULL){
            hr = WBEM_E_OUT_OF_MEMORY;
            break;
        }
        RtlZeroMemory(*Storage, dwSize);
        GuidPropertiesArray = (PTRACE_GUID_PROPERTIES *)(*Storage);
        pStorage = (PTRACE_GUID_PROPERTIES)((char*)(*Storage) + nGuidArray * sizeof(PTRACE_GUID_PROPERTIES));
        for (i=0; i < nGuidArray; i++) {
            GuidPropertiesArray[i] = pStorage;
            pStorage = (PTRACE_GUID_PROPERTIES)((char*)pStorage + sizeof(TRACE_GUID_PROPERTIES));
        }

        hr = EnumerateTraceGuids(GuidPropertiesArray,nGuidArray,&nGuidCount);
        
        if(hr == ERROR_MORE_DATA){
            if( nGuidCount <= nGuidArray ){
                hr = WBEM_E_INVALID_PARAMETER;
                break;
            }
            nGuidArray = nGuidCount;
            G_FREE(*Storage);
            (*Storage) = NULL;
        }

    }while( hr == ERROR_MORE_DATA );
    
    if( ERROR_SUCCESS == hr ){
        *pnGuidCount = nGuidCount;
    }else{
        *pnGuidCount = 0;
    }
        
    return hr;
}

HRESULT 
CEventTrace::LoadPropertyValues( 
        CInstance *pInstanceParam, 
        PEVENT_TRACE_PROPERTIES pLoggerInfo,    
        PTRACE_GUID_PROPERTIES  *GuidPropertiesArray,
        ULONG nGuidCount
    )
{
    LPTSTR strName;
    ULONG i;
    CInstance* pInstance = pInstanceParam;

    if( NULL == pLoggerInfo || NULL == pInstance ){
        return WBEM_E_INVALID_PARAMETER;
    }


    if( NULL != GuidPropertiesArray ){
        SAFEARRAY *saGuids;
        SAFEARRAY *saFlags;
        SAFEARRAY *saLevel;
        BSTR HUGEP *pGuidData;
        DWORD HUGEP *pLevelData;
        DWORD HUGEP *pFlagData;

        ULONG nGuidIndex = 0;
        ULONG nProviderGuids = 0;
        
        if( pLoggerInfo->Wnode.Guid == SystemTraceControlGuid ){
            nProviderGuids = 1;
        }else{
            for (i=0; i < nGuidCount; i++) {
                if( pLoggerInfo->Wnode.HistoricalContext == GuidPropertiesArray[i]->LoggerId ){
                    nProviderGuids++;
                }
            }
        }
        
        if( nProviderGuids ){
            
            saGuids = SafeArrayCreateVector( VT_BSTR, 0, nProviderGuids );
            saFlags = SafeArrayCreateVector( VT_I4, 0, nProviderGuids );
            saLevel = SafeArrayCreateVector( VT_I4, 0, nProviderGuids );

            if( saGuids == NULL || saFlags == NULL || saLevel == NULL ){
                if( saGuids != NULL ){
                    SafeArrayDestroy( saGuids );
                }
                if( saFlags != NULL ){
                    SafeArrayDestroy( saFlags );
                }
                if( saLevel != NULL ){
                    SafeArrayDestroy( saLevel );
                }
            }else{

                SafeArrayAccessData( saGuids, (void HUGEP **)&pGuidData);
                SafeArrayAccessData( saFlags, (void HUGEP **)&pFlagData);
                SafeArrayAccessData( saLevel, (void HUGEP **)&pLevelData);

                if( pLoggerInfo->Wnode.Guid == SystemTraceControlGuid ){
                    WCHAR buffer[128];
                    BSTR strGUID;
                
                    StringFromGUID2( SystemTraceControlGuid, buffer, 128 );
                    strGUID = SysAllocString( buffer );

                    pGuidData[0] = strGUID;
                    pLevelData[0] = 0;
                    pFlagData[0] = pLoggerInfo->EnableFlags;

                }else{
                    for (i=0; i < nGuidCount; i++) {
                    
                        if( pLoggerInfo->Wnode.HistoricalContext == GuidPropertiesArray[i]->LoggerId ){
                        
                            WCHAR buffer[128];
                            BSTR strGUID;
                        
                            StringFromGUID2( GuidPropertiesArray[i]->Guid, buffer, 128 );
                            strGUID = SysAllocString( buffer );

                            pGuidData[nGuidIndex] = strGUID;
                            pLevelData[nGuidIndex] = GuidPropertiesArray[i]->EnableLevel;
                            pFlagData[nGuidIndex] = GuidPropertiesArray[i]->EnableFlags;
                        
                            nGuidIndex++;
                        }
                    }
                }

                SafeArrayUnaccessData( saGuids );    
                SafeArrayUnaccessData( saFlags );    
                SafeArrayUnaccessData( saLevel );    
                VARIANT vArray;
                vArray.vt = VT_ARRAY|VT_I4;
                
                pInstance->SetStringArray( L"Guid", *saGuids );

                vArray.parray = saFlags;
                pInstance->SetVariant( L"EnableFlags", vArray );

                vArray.parray = saLevel;
                pInstance->SetVariant( L"Level", vArray );

                SafeArrayDestroy( saGuids );
                SafeArrayDestroy( saFlags );
                SafeArrayDestroy( saLevel );
            }
        }
    }

    pInstance->SetDWORD( L"BufferSize",         pLoggerInfo->BufferSize );
    pInstance->SetDWORD( L"MinimumBuffers",     pLoggerInfo->MinimumBuffers );
    pInstance->SetDWORD( L"MaximumBuffers",     pLoggerInfo->MaximumBuffers );
    pInstance->SetDWORD( L"MaximumFileSize",    pLoggerInfo->MaximumFileSize );
    pInstance->SetDWORD( L"FlushTimer",         pLoggerInfo->FlushTimer );
    pInstance->SetDWORD( L"AgeLimit",           pLoggerInfo->AgeLimit );
    pInstance->SetDWORD( L"LoggerId",           pLoggerInfo->Wnode.HistoricalContext );
    pInstance->SetDWORD( L"NumberOfBuffers",    pLoggerInfo->NumberOfBuffers );
    pInstance->SetDWORD( L"FreeBuffers",        pLoggerInfo->FreeBuffers );
    pInstance->SetDWORD( L"EventsLost",         pLoggerInfo->EventsLost );
    pInstance->SetDWORD( L"BuffersWritten",     pLoggerInfo->BuffersWritten );
    pInstance->SetDWORD( L"LogBuffersLost",     pLoggerInfo->LogBuffersLost );
    pInstance->SetDWORD( L"RealTimeBuffersLost",pLoggerInfo->RealTimeBuffersLost );
    pInstance->SetDWORD( L"LoggerThreadId",     HandleToUlong( pLoggerInfo->LoggerThreadId ) );

    DecodeFileMode( pInstance, pLoggerInfo, DECODE_MODE_TRACE_TO_WBEM );
    
    strName = (LPTSTR)((char*)pLoggerInfo+pLoggerInfo->LoggerNameOffset);
    pInstance->SetCHString( L"Name", strName );

    strName = (LPTSTR)((char*)pLoggerInfo+pLoggerInfo->LogFileNameOffset );
    pInstance->SetCHString( L"LogFileName", strName );
    
    return WBEM_S_NO_ERROR;
}

HRESULT CEventTrace::DecodeFileMode( CInstance* pInstance, PEVENT_TRACE_PROPERTIES pLoggerInfo, DWORD dwFlags )
{
    HRESULT hr = ERROR_SUCCESS;

    CHString LogFileMode;

    if( dwFlags & DECODE_MODE_WBEM_TO_TRACE ){
        pInstance->GetCHString( L"LogFileMode", LogFileMode );
        if( ! LogFileMode.GetLength() ){
            return hr;
        }
    }

    IWbemClassObject* pClass = pInstance->GetClassObjectInterface();

    if( pClass != NULL ){
        WCHAR buffer[1024] = L"";
        LONG nFlavor;
        VARIANT var;
        SAFEARRAY* saValues = NULL;
        SAFEARRAY* saValueMap = NULL;

        IWbemQualifierSet   *pQualSet = NULL;
        pClass->GetPropertyQualifierSet( L"LogFileMode", &pQualSet );
        if( pQualSet != NULL ){
            hr = pQualSet->Get( L"ValueMap", 0, &var, &nFlavor );
            if( ERROR_SUCCESS == hr && (var.vt & VT_ARRAY) ){
                saValueMap = var.parray;
            }

            hr = pQualSet->Get( L"Values", 0, &var, &nFlavor );
            if( ERROR_SUCCESS == hr && (var.vt & VT_ARRAY) ){
                saValues = var.parray;
            }
    
            if( saValues != NULL && saValueMap != NULL ){
                BSTR HUGEP *pMapData;
                BSTR HUGEP *pValuesData;
                LONG uMapBound, lMapBound;
                LONG uValuesBound, lValuesBound;

                SafeArrayGetUBound( saValueMap, 1, &uMapBound );
                SafeArrayGetLBound( saValueMap, 1, &lMapBound );
                SafeArrayAccessData( saValueMap, (void HUGEP **)&pMapData );
        
                SafeArrayGetUBound( saValues, 1, &uValuesBound );
                SafeArrayGetLBound( saValues, 1, &lValuesBound );
                SafeArrayAccessData( saValues, (void HUGEP **)&pValuesData );

                for ( LONG i=lMapBound; i<=uMapBound; i++) {
                    LONG dwFlag;
            
                    if( i<lValuesBound || i>uValuesBound ){
                        break;
                    }
                    dwFlag = hextoi( pMapData[i] );
                    if( dwFlags & DECODE_MODE_WBEM_TO_TRACE ){
                        if( LogFileMode.Find( pValuesData[i] ) >= 0  ){
                            pLoggerInfo->LogFileMode |= dwFlag;
                        }
                    }else{
                        if( dwFlag & pLoggerInfo->LogFileMode ){
                            if( wcslen(buffer) ){
                                wcscat( buffer, L"|" );
                            }
                            wcscat( buffer, pValuesData[i] );
                        }
                    }
                }

                SafeArrayUnaccessData( saValueMap );
                SafeArrayUnaccessData( saValues );
        
                SafeArrayDestroy( saValueMap );
                SafeArrayDestroy( saValues );

                if( dwFlags & DECODE_MODE_TRACE_TO_WBEM ){
                    if( wcslen( buffer ) ){
                        pInstance->SetCHString( L"LogFileMode", buffer );
                    }else{
                        hr = pQualSet->Get( L"DefaultValue", 0, &var, &nFlavor );
                        if( ERROR_SUCCESS == hr && VT_BSTR == var.vt ){
                            pInstance->SetCHString( L"LogFileMode", var.bstrVal );
                            VariantClear( &var );
                        }
                    }
                }

            }

            pQualSet->Release();
        }
    }

    return hr;
}

HRESULT CEventTrace::PutInstance ( const CInstance &Instance, long lFlags )
{
    HRESULT hr = WBEM_E_UNSUPPORTED_PARAMETER;

    CHString LoggerName;
    CHString LogFileName;
    SAFEARRAY *saGuids = NULL;
    SAFEARRAY *saLevel = NULL;
    SAFEARRAY *saFlags = NULL;
    GUID guid = {0};
    
    LPWSTR strName;
    LPWSTR strFile;

    PEVENT_TRACE_PROPERTIES pLoggerInfo = NULL;
    TRACEHANDLE LoggerHandle = 0;
    BSTR HUGEP *pGuidData;
    VARIANT vArray;
    
    if ( !(lFlags & WBEM_FLAG_CREATE_ONLY|WBEM_FLAG_UPDATE_ONLY ) ){ 
        return hr;
    }
   
    hr = InitTraceProperties( &pLoggerInfo );   
    if( hr != ERROR_SUCCESS ){
        return hr;
    }

    Instance.GetCHString( L"Name", LoggerName );
    strName = (LPWSTR)((char*)pLoggerInfo + pLoggerInfo->LoggerNameOffset );
    if( wcslen( (LPCWSTR)LoggerName ) >= MAXSTR ){
        return WBEM_E_INVALID_PARAMETER;
    }
    wcscpy( strName, (LPCWSTR)LoggerName );
    
    Instance.GetCHString( L"LogFileName", LogFileName );
    strFile = (LPWSTR)((char*)pLoggerInfo + pLoggerInfo->LogFileNameOffset );
    if( wcslen( (LPCWSTR)LogFileName ) >= MAXSTR ){
        return WBEM_E_INVALID_PARAMETER;
    }
    wcscpy( strFile, (LPCWSTR)LogFileName );

    Instance.GetDWORD( L"BufferSize",         pLoggerInfo->BufferSize );
    Instance.GetDWORD( L"MinimumBuffers",     pLoggerInfo->MinimumBuffers );
    Instance.GetDWORD( L"MaximumBuffers",     pLoggerInfo->MaximumBuffers );
    Instance.GetDWORD( L"MaximumFileSize",    pLoggerInfo->MaximumFileSize );
    Instance.GetDWORD( L"FlushTimer",         pLoggerInfo->FlushTimer );
    
    DecodeFileMode( (CInstance*)&Instance, pLoggerInfo, DECODE_MODE_WBEM_TO_TRACE );

    if(! Instance.GetStringArray( L"Guid", saGuids ) ){
        saGuids = NULL;
    }

    Instance.GetVariant( L"EnableFlags", vArray );
    if( VT_NULL != vArray.vt ){
        saFlags = vArray.parray;
    }
   
    Instance.GetVariant( L"Level", vArray );
    if( VT_NULL != vArray.vt ){
        saLevel = vArray.parray;
    }

    if (lFlags & WBEM_FLAG_CREATE_ONLY){
        LONG lBound;

        if( saGuids != NULL ){
            SafeArrayGetLBound( saGuids, 1, &lBound );
            SafeArrayAccessData( saGuids, (void HUGEP **)&pGuidData );
            CLSIDFromString( pGuidData[lBound], &guid );
            SafeArrayUnaccessData( saGuids );
        }

        if( IsEqualGUID( guid, SystemTraceControlGuid ) ){
            
            ULONG offset;
            
            pLoggerInfo->Wnode.Guid = SystemTraceControlGuid;

            offset = sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAXSTR * sizeof(WCHAR);
            hr = EtsSetExtendedFlags(
                            saFlags,
                            pLoggerInfo,
                            offset
                            );

            hr = StartTrace( &LoggerHandle, (LPCWSTR)LoggerName, pLoggerInfo );

        }else if( LoggerName.CompareNoCase( cszGlobalLogger) == 0 ){
            hr = StartGlobalLogger( pLoggerInfo );
        }else{

            hr = StartTrace( &LoggerHandle, (LPCWSTR)LoggerName, pLoggerInfo );
            
            if( ERROR_SUCCESS == hr ){
                hr = WmiEnableTrace( Instance, TRUE, saFlags, saLevel, saGuids, LoggerHandle );
            }
        }
        
        if( NULL != saGuids ){
            SafeArrayDestroy( saGuids );
        }
        if( NULL != saFlags ){
            SafeArrayDestroy( saFlags );
        }
        if( NULL != saLevel ){
            SafeArrayDestroy( saLevel );
        }

    }else if( lFlags & WBEM_FLAG_UPDATE_ONLY ){
        Instance.GetWBEMINT64( L"LoggerId", LoggerHandle );
        hr = UpdateTrace( LoggerHandle, (LPCWSTR)LoggerName, pLoggerInfo );
        if( ERROR_SUCCESS == hr ){
            hr = WmiEnableTrace( Instance, TRUE, saFlags, saLevel, saGuids, LoggerHandle );
        }
    }

    G_FREE( pLoggerInfo );

    return hr; 
}

HRESULT CEventTrace::InitTraceProperties( PEVENT_TRACE_PROPERTIES* ppLoggerInfo )
{
    PEVENT_TRACE_PROPERTIES pLoggerInfo = NULL;

    DWORD dwSize = sizeof(EVENT_TRACE_PROPERTIES) + sizeof(WCHAR)*MAXSTR*2 + EtsGetMaxEnableFlags() * sizeof(ULONG);

    pLoggerInfo = (PEVENT_TRACE_PROPERTIES)G_ALLOC( dwSize );
    
    if( NULL == pLoggerInfo  ){
        return ERROR_OUTOFMEMORY;
    }

    ZeroMemory( pLoggerInfo, dwSize );
    pLoggerInfo->Wnode.BufferSize = dwSize;
    pLoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    pLoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    pLoggerInfo->LogFileNameOffset = pLoggerInfo->LoggerNameOffset+MAXSTR*sizeof(WCHAR);

    *ppLoggerInfo = pLoggerInfo;

    return ERROR_SUCCESS;

}

HRESULT 
CEventTrace::WmiEnableTrace( 
        const CInstance &Instance, 
        bool bEnable,
        SAFEARRAY *saFlags, 
        SAFEARRAY *saLevel, 
        SAFEARRAY *saGuid,
        TRACEHANDLE LoggerHandle
    )
{
    HRESULT hr = ERROR_SUCCESS;

    BSTR HUGEP  *pGuidData;
    DWORD HUGEP  *pFlagData;
    DWORD HUGEP  *pLevelData;
    LONG lGuidBound,uGuidBound;
    LONG lFlagBound,uFlagBound;
    LONG lLevelBound,uLevelBound;
    
    if( NULL == saGuid ){
        return ERROR_SUCCESS;
    }

    SafeArrayGetUBound( saGuid, 1, &uGuidBound );
    SafeArrayGetLBound( saGuid, 1, &lGuidBound );
    SafeArrayAccessData( saGuid, (void HUGEP **)&pGuidData );

    if( saFlags != NULL ){
        SafeArrayGetUBound( saFlags, 1, &uFlagBound );
        SafeArrayGetLBound( saFlags, 1, &lFlagBound );
        SafeArrayAccessData( saFlags, (void HUGEP **)&pFlagData );
    }else{
        uFlagBound = 0;
        lFlagBound = 0;
    }

    if( saLevel != NULL ){
        SafeArrayGetUBound( saLevel, 1, &uLevelBound );
        SafeArrayGetLBound( saLevel, 1, &lLevelBound );
        SafeArrayAccessData( saLevel, (void HUGEP **)&pLevelData );
    }else{
        uLevelBound = 0;
        lLevelBound = 0;
    }

    for ( LONG i=lGuidBound; i<=uGuidBound; i++) {
        
        GUID  guid;
        DWORD dwLevel = 0;
        DWORD dwFlags = 0;

        CLSIDFromString( pGuidData[i], &guid );

        if( i>=lLevelBound && i<=uLevelBound && saLevel != NULL ){
            dwLevel = pLevelData[i];
        }
        if( i>=lFlagBound && i<=uFlagBound && saFlags != NULL ){
            dwFlags = pFlagData[i];
        }

        hr = EnableTrace( bEnable, dwFlags, dwLevel, &guid, LoggerHandle );
    }

    SafeArrayUnaccessData( saGuid );

    if( saFlags != NULL ){
        SafeArrayUnaccessData( saFlags );
    }
    if( saLevel != NULL ){
        SafeArrayUnaccessData( saLevel );
    }

    return hr;
}

HRESULT CEventTrace::WmiFlushTrace( const CInstance &Instance )
{
    HRESULT hr;

    PEVENT_TRACE_PROPERTIES pLoggerInfo = NULL;
    TRACEHANDLE LoggerHandle = 0;

    CHString LoggerName;

    hr = InitTraceProperties( &pLoggerInfo );   
    
    if( hr == ERROR_SUCCESS ){

        Instance.GetCHString( L"Name", LoggerName );
        Instance.GetWBEMINT64( L"LoggerId", LoggerHandle );
 
        hr = ::FlushTraceW( LoggerHandle, (LPCWSTR)LoggerName, pLoggerInfo );

        G_FREE( pLoggerInfo );
    }

    return hr;
}

HRESULT CEventTrace::WmiStopTrace( const CInstance &Instance )
{
    HRESULT hr;

    CHString LoggerName;
    SAFEARRAY *saGuids = NULL;
    LONG nGuidCount,i;
    GUID guid;

    PEVENT_TRACE_PROPERTIES pLoggerInfo = NULL;
    TRACEHANDLE LoggerHandle = 0;
    BSTR HUGEP *pData;
  
    Instance.GetCHString( L"Name", LoggerName );
    Instance.GetWBEMINT64( L"LoggerId", LoggerHandle );

    hr = InitTraceProperties( &pLoggerInfo );   
    
    if( ERROR_SUCCESS == hr ){
   
        Instance.GetStringArray( L"Guid", saGuids );
        if( NULL != saGuids ){

            SafeArrayGetUBound( saGuids, 0, &nGuidCount );
            SafeArrayAccessData( saGuids, (void HUGEP **)&pData );

            for (i=0; i<nGuidCount; i++) {
                CLSIDFromString( pData[i], &guid );
                hr = EnableTrace( FALSE, 0, 0, &guid, LoggerHandle );
            }

            SafeArrayUnaccessData( saGuids );    
            SafeArrayDestroy( saGuids );
        }

        hr = ::StopTraceW( LoggerHandle, (LPCWSTR)LoggerName, pLoggerInfo );
        
        if( LoggerName.CompareNoCase( cszGlobalLogger ) == 0 ){
            hr = DeleteGlobalLogger( pLoggerInfo );
        }
    
        G_FREE( pLoggerInfo );
    }

    return hr;
}

HRESULT 
CEventTrace::StartGlobalLogger(
    IN PEVENT_TRACE_PROPERTIES pLoggerInfo
)
{
	return (SetGlobalLoggerSettings( 1L, pLoggerInfo, 0 ));
}

HRESULT 
CEventTrace::DeleteGlobalLogger(
    IN PEVENT_TRACE_PROPERTIES pLoggerInfo
)
{
	return (SetGlobalLoggerSettings( 0L, pLoggerInfo, 0 ) );
}

HRESULT 
CEventTrace::ExecMethod( 
        const CInstance& Instance,
        const BSTR bstrMethodName,
        CInstance *pInParams,
        CInstance *pOutParams,
        long lFlags
    )
{
    HRESULT hr = WBEM_E_PROVIDER_NOT_CAPABLE;
    HRESULT hResult = ERROR_SUCCESS;

    if( _wcsicmp( bstrMethodName, L"FlushTrace") == 0 ){
        hResult = WmiFlushTrace( Instance );
        hr = WBEM_S_NO_ERROR;
    }

    if( _wcsicmp( bstrMethodName, L"StopTrace") == 0 ){
        hResult = WmiStopTrace( Instance );
        hr = WBEM_S_NO_ERROR;
    }

    if( _wcsicmp( bstrMethodName, L"EnableTrace") == 0 ){

        bool bEnable;
        SAFEARRAY *saGuids = NULL;
        SAFEARRAY *saLevel = NULL;
        SAFEARRAY *saFlags = NULL;
        VARIANT vArray;
        TRACEHANDLE LoggerHandle;

        pInParams->Getbool( L"Enable", bEnable );

        pInParams->GetStringArray( L"Guid", saGuids );
        pInParams->GetVariant( L"Flags", vArray );
        saFlags = vArray.parray;
        pInParams->GetVariant( L"Level", vArray );
        saLevel = vArray.parray;
    
        Instance.GetWBEMINT64( L"LoggerId", LoggerHandle );

        hResult = WmiEnableTrace( Instance, bEnable, saFlags, saLevel, saGuids, LoggerHandle );

        if( NULL != saGuids ){
            SafeArrayDestroy( saGuids );
        }
        if( NULL != saFlags ){
            SafeArrayDestroy( saFlags );    
        }
        if( NULL != saLevel ){
            SafeArrayDestroy( saLevel );
        }

        hr = WBEM_S_NO_ERROR;
    }

    pOutParams->SetDWORD( L"ReturnValue", hResult );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tolower\tolower.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tolower.c

Abstract:

    A tool for issuing persistent reserve commands to a device to see how
    it behaves.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

#define UNICODE 1

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include <assert.h>

#include <windows.h>

#if 0
#define dbg(x) x
#define HELP_ME() printf("Reached line %4d\n", __LINE__);
#else
#define dbg(x)    /* x */
#define HELP_ME() /* printf("Reached line %4d\n", __LINE__); */
#endif


BOOL LowerDirectory(WCHAR *DirectoryName, BOOL Recurse, WCHAR **Patterns, int PatternCount);
BOOL LowerFile(WCHAR *FileName, BOOL Directory);

void PrintUsage(void) {
    printf("Usage: tolower [-s] <file_pattern> ...\n");
    printf("       -s: recurse though directories\n");
    return;
}

int __cdecl wmain(int argc, wchar_t *argv[])
{
    BOOL recurse = FALSE;
    int i = 0;
    HANDLE h;

    WCHAR **patternArray;
    int patternCount;

    if(argc < 2) {
        PrintUsage();
        return -1;
    }

    if(_wcsnicmp(argv[1], L"-s", sizeof(L"s")) == 0) {
        recurse = TRUE;
        dbg(printf("recursive operation\n"));

        patternArray = &(argv[2]);
        patternCount = argc - 2;
    } else {
        patternArray = &(argv[1]);
        patternCount = argc - 1;
    }

    wprintf(L"Will %slowercase files matching the following patterns:\n",
             recurse ? L"recursively" : L"");
    for(i = 0; i < patternCount; i++) {
        wprintf(L"  %d: %s\n", i, patternArray[i]);
    }

    LowerDirectory(L".", recurse, patternArray, patternCount);

    return 0;
}

BOOL
LowerDirectory(
    WCHAR *DirectoryName,
    BOOL Recurse,
    WCHAR **Patterns,
    int PatternCount
    )
{
    WCHAR oldDir[MAX_PATH];

    int i;
    int count = 0;
    BOOL result = TRUE;

    HANDLE iterator = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA data;

    //
    // Make a pass through all the files in the directory to lower case them
    // if they match one of the patterns.
    //

    GetCurrentDirectory(MAX_PATH, oldDir);
    SetCurrentDirectory(DirectoryName);

    wprintf(L"Scanning directory %s\n", DirectoryName);

    for(i = 0; i < PatternCount; i++) {

        dbg(wprintf(L"Checking for %s\n", Patterns[i]));

        for(iterator = FindFirstFile(Patterns[i], &data), result = TRUE;
            (iterator != INVALID_HANDLE_VALUE) && (result == TRUE);
            result = FindNextFile(iterator, &data)) {

            //
            // Don't process . or ..
            //

            if((wcscmp(data.cFileName, L".") == 0) ||
               (wcscmp(data.cFileName, L"..") == 0)) {
                continue;
            }

            LowerFile(data.cFileName,
                      (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY));

            count++;
        }

        if(iterator != INVALID_HANDLE_VALUE) {
            FindClose(iterator);
            iterator = INVALID_HANDLE_VALUE;
        }
    }

    // wprintf(L"%d files or directories processed\n", count);

    count = 0;
    assert(iterator == INVALID_HANDLE_VALUE);

    memset(&data, 0, sizeof(WIN32_FIND_DATA));

    // dbg(wprintf(L"Processing directories in %s\n", buffer));

    for(iterator = FindFirstFile(L"*", &data), result = TRUE;
        (iterator != INVALID_HANDLE_VALUE) && (result == TRUE);
        result = FindNextFile(iterator, &data)) {

        if(data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Don't process . or ..
            //

            if((wcscmp(data.cFileName, L".") == 0) ||
               (wcscmp(data.cFileName, L"..") == 0)) {
                continue;
            }

            LowerDirectory(data.cFileName, Recurse, Patterns, PatternCount);
            count++;
        }
    }

    if(iterator == INVALID_HANDLE_VALUE) {
        wprintf(L"Error %d scanning directory a second time\n", GetLastError());
    }

    // wprintf(L"%d directories processed\n", count);

    SetCurrentDirectory(oldDir);

    return TRUE;
}

BOOL
LowerFile(
    WCHAR *FileName,
    BOOL Directory
    )
{
    WCHAR buffer[_MAX_FNAME] = L"hello";
    int i;

    BOOL result;

    wcsncpy(buffer, FileName, _MAX_FNAME);

    for(i = 0; buffer[i] != UNICODE_NULL; i++) {
        buffer[i] = towlower(buffer[i]);
    }

    if(wcscmp(buffer, FileName) == 0) {
        return TRUE;
    }

    wprintf(L"%s: %s -> %s: ",
            Directory ? L"Dir" : L"File",
            FileName,
            buffer);

    result = MoveFile(FileName, buffer);

    if(result) {
        wprintf(L"succeeded\n");
    } else {
        wprintf(L"error %d\n", GetLastError());
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\evntrprv\glogger.cpp ===
/*****************************************************************************\

    Author: Insung Park (insungp)

    Copyright (c) 1998-2000 Microsoft Corporation

\*****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <evntrace.h>
#include <wmiguid.h>
#include <ntwmi.h>
#include <ntperf.h>
#include <fwcommon.h>

LPCWSTR cszGlobalLoggerKey = L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\WMI\\GlobalLogger";
LPCWSTR cszStartValue = L"Start";
LPCWSTR cszBufferSizeValue = L"BufferSize";
LPCWSTR cszMaximumBufferValue = L"MaximumBuffers";
LPCWSTR cszMinimumBufferValue = L"MinimumBuffers";
LPCWSTR cszFlushTimerValue = L"FlushTimer";
LPCWSTR cszFileNameValue = L"FileName";
LPCWSTR cszEnableKernelValue = L"EnableKernelFlags";
LPCWSTR cszClockTypeValue = L"ClockType";

HRESULT
SetGlobalLoggerSettings(
    DWORD StartValue,
    PEVENT_TRACE_PROPERTIES LoggerInfo,
    DWORD ClockType
)
/*++

Since it is a standalone utility, there is no need for extensive comments. 

Routine Description:

    Depending on the value given in "StartValue", it sets or resets event
    trace registry. If the StartValue is 0 (Global logger off), it deletes
    all the keys (that the user may have set previsouly).
    
    Users are allowed to set or reset individual keys using this function,
    but only when "-start GlobalLogger" is used.

    The section that uses non NTAPIs is not guaranteed to work.

Arguments:

    StartValue - The "Start" value to be set in the registry.
                    0: Global logger off
                    1: Global logger on
    LoggerInfo - The poniter to the resident EVENT_TRACE_PROPERTIES instance.
                whose members are used to set registry keys.

    ClockType - The type of the clock to be set. Use pLoggerInfo->Wnode.ClientContext

Return Value:

    Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS.


--*/
{

    DWORD  dwValue;
    NTSTATUS status;
    HANDLE KeyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeLoggerKey, UnicodeString;
    ULONG Disposition, TitleIndex;

    RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    RtlInitUnicodeString((&UnicodeLoggerKey),(cszGlobalLoggerKey));
    InitializeObjectAttributes( 
        &ObjectAttributes,
        &UnicodeLoggerKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL 
        );

    // instead of opening, create a new key because it may not exist.
    // if one exists already, that handle will be passed.
    // if none exists, it will create one.
    status = NtCreateKey(&KeyHandle,
                         KEY_QUERY_VALUE | KEY_SET_VALUE,
                         &ObjectAttributes,
                         0L,    // not used within this call anyway.
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         &Disposition);
    RtlFreeUnicodeString(&UnicodeLoggerKey);

    if(!NT_SUCCESS(status)) {
        return RtlNtStatusToDosError(status);
    }

    TitleIndex = 0L;


    if (StartValue == 1) { // ACTION_START: set filename only when it is given by a user.
        // setting BufferSize
        if (LoggerInfo->BufferSize > 0) {
            dwValue = LoggerInfo->BufferSize;
            RtlInitUnicodeString((&UnicodeString),(cszBufferSizeValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting MaximumBuffers
        if (LoggerInfo->MaximumBuffers > 0) {
            dwValue = LoggerInfo->MaximumBuffers;
            RtlInitUnicodeString((&UnicodeString),(cszMaximumBufferValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting MinimumBuffers 
        if (LoggerInfo->MinimumBuffers > 0) {
            dwValue = LoggerInfo->MinimumBuffers;
            RtlInitUnicodeString((&UnicodeString),(cszMinimumBufferValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting FlushTimer
        if (LoggerInfo->FlushTimer > 0) {
            dwValue = LoggerInfo->FlushTimer;
            RtlInitUnicodeString((&UnicodeString),(cszFlushTimerValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting EnableFlags
        if (LoggerInfo->EnableFlags > 0) {
            dwValue = LoggerInfo->EnableFlags;
            RtlInitUnicodeString((&UnicodeString),(cszEnableKernelValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }

        dwValue = 0;
        if (LoggerInfo->LogFileNameOffset > 0) {
            UNICODE_STRING UnicodeFileName;
            RtlInitUnicodeString((&UnicodeFileName), (PWCHAR)(LoggerInfo->LogFileNameOffset + (PCHAR) LoggerInfo));
            RtlInitUnicodeString((&UnicodeString),(cszFileNameValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_SZ,
                        UnicodeFileName.Buffer,
                        UnicodeFileName.Length + sizeof(UNICODE_NULL)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            RtlFreeUnicodeString(&UnicodeFileName);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
    }
    else { // if ACTION_STOP then delete the keys that users might have set previously.
        // delete buffer size
        RtlInitUnicodeString((&UnicodeString),(cszBufferSizeValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete maximum buffers
        RtlInitUnicodeString((&UnicodeString),(cszMaximumBufferValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete minimum buffers
        RtlInitUnicodeString((&UnicodeString),(cszMinimumBufferValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete flush timer
        RtlInitUnicodeString((&UnicodeString),(cszFlushTimerValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete enable falg
        RtlInitUnicodeString((&UnicodeString),(cszEnableKernelValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete filename
        RtlInitUnicodeString((&UnicodeString),(cszFileNameValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
    }

    // setting ClockType
    if (ClockType > 0) {
        dwValue = ClockType;
        RtlInitUnicodeString((&UnicodeString),(cszClockTypeValue));
        status = NtSetValueKey(
                    KeyHandle,
                    &UnicodeString,
                    TitleIndex,
                    REG_DWORD,
                    (LPBYTE)&dwValue,
                    sizeof(dwValue)
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status)) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        TitleIndex++;
    }

     // Setting StartValue
    dwValue = StartValue;
    RtlInitUnicodeString((&UnicodeString),(cszStartValue));
    status = NtSetValueKey(
                KeyHandle,
                &UnicodeString,
                TitleIndex,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue)
                );
    RtlFreeUnicodeString(&UnicodeString);
    if (!NT_SUCCESS(status)) {
        NtClose(KeyHandle);
        return RtlNtStatusToDosError(status);
    }
    TitleIndex++;

    NtClose(KeyHandle);
    return 0;
}

ULONG
EtsGetMaxEnableFlags ()
{
    return PERF_NUM_MASKS;
}


HRESULT
EtsSetExtendedFlags(
    SAFEARRAY *saFlags,
    PEVENT_TRACE_PROPERTIES pLoggerInfo,
    ULONG offset
    )

{
    LONG lBound, uBound;
    ULONG HUGEP *pFlagData;

    if( NULL != saFlags ){
        SafeArrayGetLBound( saFlags, 1, &lBound );
        SafeArrayGetUBound( saFlags, 1, &uBound );
        SafeArrayAccessData( saFlags, (void HUGEP **)&pFlagData );
        pLoggerInfo->EnableFlags = pFlagData[lBound];
        if (pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            USHORT i;
            PTRACE_ENABLE_FLAG_EXTENSION FlagExt;
            UCHAR nFlag = (UCHAR) (uBound - lBound);
            if ( nFlag <= PERF_NUM_MASKS ) {
                PULONG pFlags;

                pLoggerInfo->EnableFlags = EVENT_TRACE_FLAG_EXTENSION;
                FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                            &pLoggerInfo->EnableFlags;
                FlagExt->Offset = offset;
                FlagExt->Length = (UCHAR) nFlag;

                pFlags = (PULONG) ( offset + (PCHAR) pLoggerInfo );
                for (i=1; i<=nFlag; i++) {
                    pFlags[i-1] = pFlagData[lBound + i];
                }
            }
        }
        SafeArrayUnaccessData( saFlags );
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\evntrprv\smlogprv.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) 1998-2000 Microsoft Corporation

\*****************************************************************************/

#include <wmistr.h>
#include <evntrace.h>

#define MAXSTR              1024
#define MAXIMUM_LOGGERS     32

#define PROVIDER_NAME_SMONLOG L"SysmonLog"

class CSmonLog : public Provider 
{
public:
	CSmonLog(LPCWSTR chsClassName, LPCWSTR lpszNameSpace);
	virtual ~CSmonLog();

protected:
	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
	virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);

	virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

	virtual HRESULT ExecMethod( const CInstance& Instance,
				            const BSTR bstrMethodName,
				            CInstance *pInParams,
				            CInstance *pOutParams,
				            long lFlags = 0L 
                        );

    HRESULT LoadPropertyValues( 
                CInstance *pInstance, 
                LPWSTR strName
            );
private:
    HRESULT SetRunAs( const CInstance &Instance, CInstance *pInParams );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\evntrprv\maindll.cpp ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) 1998-2000 Microsoft Corporation

\*****************************************************************************/

#include <FWcommon.h>
#include <objbase.h>
#include <initguid.h>

HMODULE ghModule;

WCHAR *EVENTTRACE_GUIDSTRING = L"{9a5dd473-d410-11d1-b829-00c04f94c7c3}";
WCHAR *SYSMONLOG_GUIDSTRING = L"{f95e1664-7979-44f2-a040-496e7f500043}";

CLSID CLSID_CIM_EVENTTRACE;
CLSID CLSID_CIM_SYSMONLOG;

long g_cLock=0;

EXTERN_C BOOL LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
        ghModule = hInstance;
    return TRUE;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CWbemGlueFactory *pObj;

    CLSIDFromString(EVENTTRACE_GUIDSTRING, &CLSID_CIM_EVENTTRACE );
    CLSIDFromString(SYSMONLOG_GUIDSTRING, &CLSID_CIM_SYSMONLOG );

    if( CLSID_CIM_EVENTTRACE != rclsid && CLSID_CIM_SYSMONLOG != rclsid ){
        return E_FAIL;
    }

    pObj= new CWbemGlueFactory();

    if( NULL==pObj ){
        return E_OUTOFMEMORY;
    }

    hr=pObj->QueryInterface(riid, ppv);

    if( FAILED(hr) ){
        delete pObj;
    }

    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    if( (0L==g_cLock) && 
        CWbemProviderGlue::FrameworkLogoffDLL(L"EventTraceProv") && 
        CWbemProviderGlue::FrameworkLogoffDLL(L"SmonLogProv")){
        
        sc = S_OK;

    }else{
        sc = S_FALSE;
    }

    return sc;
}

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os)){
        return FALSE;
    }

    return os.dwMajorVersion >= 4;
}

STDAPI DllRegisterServer(void)
{   
    WCHAR      szCLSID[512];
    WCHAR      szModule[MAX_PATH];
    LPWSTR pName;
    LPWSTR pModel = L"Both";
    HKEY hKey1, hKey2;
    

    // Compile Mof
/*    HRESULT hr;
    hr = CoInitialize(NULL);
    if( SUCCEEDED(hr) ){
        WCHAR drive[_MAX_DRIVE];
        WCHAR dir[_MAX_DIR];
        WCHAR fname[_MAX_FNAME];
        WCHAR ext[_MAX_EXT];
        WBEM_COMPILE_STATUS_INFO  stat;

        IMofCompiler *pMof = NULL;
        hr = CoCreateInstance( CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (void **)&pMof );
        GetModuleFileNameW( ghModule, szModule,  MAX_PATH);

        _wsplitpath( szModule, drive, dir, fname, ext );
        _wmakepath( szModule, drive, dir, L"evntrprv.mof", L"" );

        pMof->CompileFile( szModule, NULL,NULL,NULL,NULL, 0,0,0, &stat );
        pMof->Release();

        CoUninitialize();
    }
*/
    GetModuleFileNameW(ghModule, szModule,  MAX_PATH);

    // Event Trace Provider
    pName = L"Event Trace Logger Provider";
    wcscpy(szCLSID, L"SOFTWARE\\CLASSES\\CLSID\\" );
    wcscat(szCLSID, EVENTTRACE_GUIDSTRING );

    RegCreateKeyW(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueExW(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, (wcslen(pName)+1)*sizeof(WCHAR));
    RegCreateKeyW(hKey1, L"InprocServer32", &hKey2 );

    RegSetValueExW(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, (wcslen(szModule)+1)*sizeof(WCHAR));
    RegSetValueExW(hKey2, L"ThreadingModel", 0, REG_SZ, (BYTE *)pModel, (wcslen(pModel)+1)*sizeof(WCHAR));
    CloseHandle(hKey1);
    CloseHandle(hKey2);

    // Sysmon Log Provider
    pName = L"System Log Provider";
    wcscpy(szCLSID, L"SOFTWARE\\CLASSES\\CLSID\\" );
    wcscat(szCLSID, SYSMONLOG_GUIDSTRING );

    RegCreateKeyW(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueExW(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, (wcslen(pName)+1)*sizeof(WCHAR));
    RegCreateKeyW(hKey1, L"InprocServer32", &hKey2 );

    RegSetValueExW(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, (wcslen(szModule)+1)*sizeof(WCHAR));
    RegSetValueExW(hKey2, L"ThreadingModel", 0, REG_SZ, (BYTE *)pModel, (wcslen(pModel)+1)*sizeof(WCHAR));
    CloseHandle(hKey1);
    CloseHandle(hKey2);

    return NOERROR;
}

STDAPI DllUnregisterServer(void)
{
    WCHAR      wcID[128];
    WCHAR      szCLSID[128];
    HKEY hKey;

    // Event Trace Provider
    CLSIDFromString(EVENTTRACE_GUIDSTRING, &CLSID_CIM_EVENTTRACE);
    StringFromGUID2(CLSID_CIM_EVENTTRACE, wcID, 128);

    wcscpy( szCLSID, L"SOFTWARE\\CLASSES\\CLSID\\");
    wcscpy( szCLSID, wcID);

    DWORD dwRet = RegOpenKeyW(HKEY_LOCAL_MACHINE, szCLSID, &hKey);

    if( dwRet == NO_ERROR ){
        RegDeleteKeyW(hKey, L"InProcServer32" );
        CloseHandle(hKey);
    }

    dwRet = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\CLASSES\\CLSID\\", &hKey);
    if(dwRet == NO_ERROR){
        RegDeleteKeyW(hKey,wcID);
        CloseHandle(hKey);
    }

    // System Log Provider
    CLSIDFromString(SYSMONLOG_GUIDSTRING, &CLSID_CIM_SYSMONLOG);
    StringFromGUID2(CLSID_CIM_SYSMONLOG, wcID, 128);

    wcscpy( szCLSID, L"SOFTWARE\\CLASSES\\CLSID\\");
    wcscpy( szCLSID, wcID);

    dwRet = RegOpenKeyW(HKEY_LOCAL_MACHINE, szCLSID, &hKey);

    if( dwRet == NO_ERROR ){
        RegDeleteKeyW(hKey, L"InProcServer32" );
        CloseHandle(hKey);
    }

    dwRet = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\CLASSES\\CLSID\\", &hKey);
    if(dwRet == NO_ERROR){
        RegDeleteKeyW(hKey,wcID);
        CloseHandle(hKey);
    }

    return NOERROR;
}

BOOL APIENTRY DllMain ( HINSTANCE hInstDLL,
                        DWORD fdwReason,
                        LPVOID lpReserved   )
{
    BOOL bRet = TRUE;
    
    switch( fdwReason ){ 
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hInstDLL);
            ghModule = hInstDLL;
            bRet = CWbemProviderGlue::FrameworkLoginDLL(L"EventTraceProv");
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\evntrprv\smlogprv.cpp ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) 1998-2000 Microsoft Corporation

\*****************************************************************************/

#include <fwcommon.h>
#include <pdhp.h>

#define SECURITY_WIN32
#include <security.h>

#include "smlogprv.h"

CSmonLog SysmonLogProv( PROVIDER_NAME_SMONLOG, L"root\\wmi" );

const static WCHAR* pSmonLogErrorClass = L"\\\\.\\root\\wmi:SmonLogError";

CSmonLog::CSmonLog (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
    Provider(lpwszName, lpwszNameSpace)
{
}

CSmonLog::~CSmonLog ()
{
}

HRESULT 
CSmonLog::EnumerateInstances( MethodContext* pMethodContext, long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwSize = 0;

    LPTSTR mszCollections = NULL;

    hr = PdhPlaEnumCollections( NULL, &dwSize, mszCollections );

    mszCollections = (LPTSTR)malloc( dwSize * sizeof(TCHAR) );
    if( mszCollections ){
        LPTSTR strCollection;
        
        hr = PdhPlaEnumCollections( NULL, &dwSize, mszCollections );
        
        if( hr == ERROR_SUCCESS ){
            
            strCollection = mszCollections;

            while( strCollection != NULL && *strCollection != '\0' ){

                CInstance *pInstance = CreateNewInstance(pMethodContext);
                if( SUCCEEDED( LoadPropertyValues(pInstance, strCollection ) )){
                    hr = pInstance->Commit();
                }

                pInstance->Release();

                strCollection += ( _tcslen( strCollection ) + 1 );
            }
        }
    }
                
    return hr;
}

HRESULT CSmonLog::GetObject ( CInstance* pInstance, long lFlags )
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString Name;
    PDH_PLA_INFO_W info;
    DWORD dwSize = sizeof(PDH_PLA_INFO_W);
    ZeroMemory( &info, dwSize );

    pInstance->GetCHString( L"Name", Name );
    hr = PdhPlaGetInfoW( (LPWSTR)(LPCWSTR)Name, NULL, &dwSize, &info );

    return hr;
}


HRESULT 
CSmonLog::LoadPropertyValues( 
        CInstance *pInstance,
        LPWSTR strName
    )
{
    pInstance->SetCHString( L"Name", strName );

    return WBEM_S_NO_ERROR;
}

HRESULT CSmonLog::PutInstance( const CInstance &Instance, long lFlags )
{
    HRESULT hr = WBEM_E_UNSUPPORTED_PARAMETER;

    return hr; 
}

HRESULT
CSmonLog::SetRunAs( const CInstance &Instance, CInstance *pInParams )
{
    HRESULT hr;

    CHString Name;
    CHString User;
    CHString Password;

    Instance.GetCHString( L"Name", Name );
    pInParams->GetCHString( L"User", User );
    pInParams->GetCHString( L"Password", Password );

    RevertToSelf();
    
    hr = PdhiPlaSetRunAs( (LPWSTR)(LPCWSTR)Name, NULL, (LPWSTR)(LPCWSTR)User, (LPWSTR)(LPCWSTR)Password );
    
    return hr;
}

HRESULT 
CSmonLog::ExecMethod( 
        const CInstance& Instance,
        const BSTR bstrMethodName,
        CInstance *pInParams,
        CInstance *pOutParams,
        long lFlags
    )
{
    HRESULT hr = WBEM_E_PROVIDER_NOT_CAPABLE;
    HRESULT hResult = ERROR_SUCCESS;

    if( _wcsicmp( bstrMethodName, L"SetRunAs") == 0 ){
        hResult = SetRunAs( Instance, pInParams );
        hr = WBEM_S_NO_ERROR;
    }

    pOutParams->SetDWORD( L"ReturnValue", hResult );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\inc\varg.c ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.
        
\*****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <conio.h>
#include <tchar.h>
#include <mbctype.h>
#include "varg.h"

LPTSTR g_strProg;
HANDLE g_hConsole;
WORD g_debug;
WORD g_light;
WORD g_dark;
WORD g_normal;
LPTSTR g_strVerbPrefix;
LPTSTR g_strPrefix;
LPTSTR g_strArgToken;
SHORT g_X;
SHORT g_Y;
LONG  g_nDebug = -1;
LCID g_LCID = 0;

#define COLORIZE( c )   (WORD)((Commands[c].fFlag & (VARG_FLAG_DARKEN|VARG_FLAG_HIDDEN)) ? g_dark : g_normal)
#define HELP_INDENT     32
#define VARG_LOCALE     ( g_LCID ? g_LCID : LOCALE_USER_DEFAULT )

BOOL varg_strlen( LPTSTR str, ULONG* pVisualSize, ULONG* pAcutalSize, BOOL* bCanBreak );
void PrintParam( int idPrompt, int cmd, BOOL bEOL );
BOOL FindString( LPTSTR strBuffer, LPTSTR strMatch );

int varg_vprintf( WORD color, LPCTSTR mask, va_list args )
{
    DWORD dwPrint;
    HANDLE hOut;

    hOut = GetStdHandle(STD_OUTPUT_HANDLE);

    SetConsoleTextAttribute( g_hConsole, color );

    __try {
        LPTSTR buffer = NULL;
        dwPrint = FormatMessage( 
                        FORMAT_MESSAGE_ALLOCATE_BUFFER|
                        FORMAT_MESSAGE_FROM_STRING, 
                        mask, 
                        0, 0, 
                        (LPTSTR)&buffer, 
                        4096, 
                        &args 
                    );

        if( NULL != buffer ){
            BOOL bBreak;
            ULONG len,temp;
            if ((GetFileType(hOut) & ~FILE_TYPE_REMOTE) == FILE_TYPE_CHAR) {
                WriteConsole( hOut, buffer, dwPrint, &dwPrint, NULL );
            }else{
                LPSTR  szAnsiBuffer = NULL;

                szAnsiBuffer = (LPSTR)VARG_ALLOC( (dwPrint+1) * sizeof(WCHAR) );
                if( NULL != szAnsiBuffer ){
                    if( CharToOem( buffer, szAnsiBuffer ) ){
                        WriteFile( hOut, szAnsiBuffer, strlen( szAnsiBuffer ), &temp, NULL );
                    }
                }
                
                VARG_FREE( szAnsiBuffer );
            }
            
            if( varg_strlen( buffer, &len, &temp, &bBreak ) ){
                dwPrint = len;
            }

            LocalFree( buffer );
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwPrint = 0;
    }
    
    SetConsoleTextAttribute( g_hConsole, g_normal );
    
    return (int)dwPrint;
}

int varg_printf( WORD color, LPCTSTR mask, ... )
{
    int nPrint;

    va_list args;
    va_start( args, mask );

    nPrint = varg_vprintf( color, mask, args );

    va_end( args );

    return nPrint;
}

_inline 
BOOL IsArg( LPTSTR str )
{
    int i;
    if( str == NULL ){
        return FALSE;
    }
    for( i=0;i<g_strPrefix[i] != _T('\0');i++){
        if( str[0] == g_strPrefix[i] ){
            return TRUE;
        }
    }

    return FALSE;
}

_inline
BOOL IsCmd( PVARG_RECORD arg, LPTSTR str, BOOL bIni )
{
    BOOL bNegated = FALSE;

    if( !bIni ){
        if( IsArg(str) ){
            str++;
        }else{
            if( arg->fFlag & VARG_FLAG_NOFLAG ){
                if( arg->bDefined ){
                    return FALSE;
                }else{
                    return TRUE;
                }
            }
            if( !( (arg->fFlag & VARG_FLAG_VERB) || (arg->fFlag & VARG_FLAG_ADVERB)) ){
                return FALSE;
            }
        }
    }
    
    if( str[0] == _T('-') ){
        bNegated = TRUE;
        str++;
    }

    if( ( arg->strArg1 != NULL && !_tcsicmp( str, arg->strArg1 ) ) ||
        ( arg->strArg2 != NULL && !_tcsicmp( str, arg->strArg2 ) ) ){

        if( arg->fFlag & VARG_FLAG_NEGATE ){
            arg->bNegated = bNegated;
        }
        
        return TRUE;
    }
    
    return FALSE;
}

_inline
BOOL ArgExpected( PVARG_RECORD arg )
{
    switch(arg->fType){
    case VARG_TYPE_BOOL:
    case VARG_TYPE_HELP:
        return FALSE;
    }

    return TRUE;
}

_inline
BOOL
IsEmpty( LPTSTR str )
{
    if( str == NULL ){
        return TRUE;
    }
    if( *str == _T('\0') ){
        return TRUE;
    }
    return FALSE;
}

void Chomp(LPTSTR pszLine)
{
    size_t lLen;
    LPTSTR pszLineEnd;
    
    if( pszLine == NULL ){
        return;
    }

    lLen = _tcslen(pszLine);

    pszLineEnd = pszLine + lLen - 1;

    while( pszLineEnd >= pszLine && 
          (*pszLineEnd == _T(' ') || 
          *pszLineEnd == _T('\r') || 
          *pszLineEnd == _T('\n') || 
          *pszLineEnd == _T('\t')) ){
    
        pszLineEnd--; 
    }

    pszLineEnd++;

    if (*pszLineEnd == _T(' ') || *pszLineEnd == _T('\n') || *pszLineEnd == _T('\t') ){
       *pszLineEnd = _T('\0');
    }
}

HRESULT 
ReadLong( LPTSTR strNumber, ULONG* pulNumber, ULONG nMax )
{
    LPTSTR strBuffer = NULL;
    ULONG nValue;
    HRESULT hr = ERROR_INVALID_PARAMETER;

    if( NULL == strNumber ){
        *pulNumber = 0;
        hr = ERROR_SUCCESS;
    }else{

        ASSIGN_STRING( strBuffer, strNumber );
        if( NULL == strBuffer ){
            hr = ERROR_OUTOFMEMORY;
        }else{
            LPTSTR strEnd;
            LPTSTR strBegin;
            size_t count;
            nValue = (ULONG)_tcstod( strNumber, &strEnd );
            _stprintf( strBuffer, _T("%lu"), nValue );
    
            strBegin = strNumber;
            while( *strBegin == _T('0') && (strEnd - strBegin) > 1 ){ strBegin++; }
            count = (size_t)(strEnd - strBegin);
           
            if( (_tcsnicmp( strBuffer, strBegin, count ) == 0) ){
                if( nValue <= nMax ){
                    *pulNumber = nValue;
                    hr = ERROR_SUCCESS;
                }
            }
        }
    }

    VARG_FREE( strBuffer );

    return hr;
}

void SetUpColors()
{
    CONSOLE_SCREEN_BUFFER_INFO ConsoleInfo;
    HKEY hkey = NULL;
    HRESULT hr;
    DWORD dwColorize = 0;
    g_hConsole = GetStdHandle( STD_OUTPUT_HANDLE );
    GetConsoleScreenBufferInfo( g_hConsole, &ConsoleInfo );
    
    g_X = (SHORT)(ConsoleInfo.srWindow.Right - ConsoleInfo.srWindow.Left);
    g_Y = (SHORT)(ConsoleInfo.srWindow.Bottom - ConsoleInfo.srWindow.Top);

    hr = RegOpenKeyExW (
                HKEY_CURRENT_USER,
                L"Console",
                0,
                KEY_ALL_ACCESS,
                &hkey 
           );
    if( ERROR_SUCCESS == hr ){
        DWORD dwType;
        DWORD dwSize = sizeof(DWORD);
        hr = RegQueryValueExW (
                    hkey,
                    L"Colorize",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwColorize,
                    &dwSize
                );
    }

    if( ERROR_SUCCESS == hr ){
        if( dwColorize == 0xff ){
            g_normal = ConsoleInfo.wAttributes;
            g_light = (USHORT)(ConsoleInfo.wAttributes | FOREGROUND_INTENSITY);
            g_debug = (USHORT)((ConsoleInfo.wAttributes & 0xF0) | FOREGROUND_INTENSITY | FOREGROUND_RED);
            g_dark = (USHORT)((ConsoleInfo.wAttributes & 0xF0) | FOREGROUND_INTENSITY);
        }else{
            g_normal = (USHORT)(dwColorize & 0x000000FF);
            g_debug = (USHORT)((dwColorize & 0x0000FF00) >> 8);
            g_light = (USHORT)((dwColorize & 0x00FF0000) >> 16);
            g_dark =  (USHORT)((dwColorize & 0xFF000000) >> 24);
        }
    }else{
        g_normal = ConsoleInfo.wAttributes;
        g_debug = g_normal;
        g_light = g_normal;
        g_dark =  g_normal;
    }

    if((g_dark & 0xF) == ((g_dark >> 4) & 0xF)) {
        g_dark = g_normal;
    }

    if((g_light & 0xF) == ((g_light >> 4) & 0xF)) {
        g_light = g_normal;
    }

    if((g_debug & 0xF) == ((g_debug >> 4) & 0xF)) {
        g_debug = g_normal;
    }

    if( NULL != hkey ){
        RegCloseKey ( hkey );
    }
}

void FreeCmd()
{
    int i;
    
    for(i=0;Commands[i].fType != VARG_TYPE_LAST;i++){
        if( Commands[i].fType == VARG_TYPE_STR || 
            Commands[i].fType == VARG_TYPE_MSZ || 
            Commands[i].fType == VARG_TYPE_INI ){
        
            Commands[i].bDefined = FALSE;
            if( !(Commands[i].fFlag & VARG_FLAG_DODEFAULT) ){
                VARG_FREE( Commands[i].strValue );
                Commands[i].strValue = NULL;
            }
        }
        if( Commands[i].strArg1 != NULL ){
            VARG_FREE( Commands[i].strArg1  );
        }
        if( Commands[i].strArg2 != NULL ){
            VARG_FREE( Commands[i].strArg2  );
        }
    }
    VARG_FREE( g_strArgToken );
    VARG_FREE( g_strPrefix );
    VARG_FREE( g_strVerbPrefix );
    
    SetConsoleTextAttribute( g_hConsole, g_normal );
}

void LoadCmd()
{
    int i;
    TCHAR buffer[MAXSTR];
    TCHAR param[MAXSTR];
    LPTSTR str;

    if( LoadString( NULL, IDS_ARG_TOKEN, buffer, MAXSTR ) ){
        ASSIGN_STRING( g_strArgToken, buffer );
    }else{
        str = _T("`");
        ASSIGN_STRING( g_strArgToken, str );
    }

    if( LoadString( NULL, IDS_ARG_PREFIX, buffer, MAXSTR ) ){
        ASSIGN_STRING( g_strPrefix, buffer );
    }else{
        str = _T("-/");
        ASSIGN_STRING( g_strPrefix, str );
    }
    
    if( LoadString( NULL, IDS_VERB_PREFIX, buffer, MAXSTR ) ){
        ASSIGN_STRING( g_strVerbPrefix, buffer );
    }else{
        str = _T("");
        ASSIGN_STRING( g_strVerbPrefix, str );
    }

    for( i=0; Commands[i].fType!=VARG_TYPE_LAST; i++ ){

        LPTSTR strArg1;
        LPTSTR strArg2;
        LPTSTR strParam;
        LPTSTR strHelp;

        LoadString( NULL, Commands[i].idParam, param, MAXSTR );

        strArg1 = _tcstok( param, g_strArgToken );
        strArg2 = _tcstok( NULL, g_strArgToken );
        strParam = _tcstok( NULL, g_strArgToken );
        strHelp = _tcstok( NULL, g_strArgToken );

        ASSIGN_STRING_RC( Commands[i].strArg1, strArg1, _T("*") );
        ASSIGN_STRING_RC( Commands[i].strArg2, strArg2, _T("*") );
        
        if( Commands[i].fFlag & VARG_FLAG_ARG_DATE ){
            TCHAR strDate[80];
            TCHAR strTime[80];
            TCHAR strAM[4];
            TCHAR strPM[4];

            GetLocaleInfo( VARG_LOCALE, LOCALE_SSHORTDATE, strDate, 80 );
            GetLocaleInfo( VARG_LOCALE, LOCALE_STIMEFORMAT, strTime, 80 );
            if( !GetLocaleInfo( VARG_LOCALE, LOCALE_S1159, strAM, 4 ) ){
                strAM[0] = _T('\0');
            }
            if( !GetLocaleInfo( VARG_LOCALE, LOCALE_S2359, strPM, 4 ) ){
                strPM[0] = _T('\0');
            }
            _tcstok( strTime, _T(" ") );
            if( _tcslen( strAM ) && _tcslen(strPM) ){
                if( Commands[i].fFlag & VARG_FLAG_DEFAULTABLE ){
                    _stprintf( buffer, _T("[%s %s[%s|%s]]"), strDate, strTime, strAM, strPM );
                }else{
                    _stprintf( buffer, _T("<%s %s[%s|%s]>"), strDate, strTime, strAM, strPM );
                }
            }else{
                if( Commands[i].fFlag & VARG_FLAG_DEFAULTABLE ){
                    _stprintf( buffer, _T("[%s %s]"), strDate, strTime );
                }else{
                    _stprintf( buffer, _T("<%s %s>"), strDate, strTime );
                }
            }
            ASSIGN_STRING_RC( Commands[i].strParam, buffer, _T("*") );

        }else{
            if( Commands[i].fFlag & VARG_FLAG_ARG_DEFAULT ){
                LoadString( NULL, IDS_ARG_DEFAULT, param, MAXSTR );
                strParam = param;
            }else if( Commands[i].fFlag & VARG_FLAG_ARG_FILENAME ){
                LoadString( NULL, IDS_ARG_FILENAME, param, MAXSTR );
                strParam = param;
            }else if( Commands[i].fFlag & VARG_FLAG_ARG_TIME ){
                LoadString( NULL, IDS_ARG_TIME, param, MAXSTR );
                strParam = param;
            }
            if( strParam != NULL && _tcslen( strParam ) && _tcscmp( strParam, _T("*") ) ){
                if( Commands[i].fFlag & VARG_FLAG_DEFAULTABLE ){
                    if( Commands[i].fType == VARG_TYPE_MSZ && !(Commands[i].fFlag & VARG_FLAG_FLATHELP) ){
                        _stprintf( buffer, _T("[%s [%s ...]]"), strParam, strParam );
                    }else{
                        _stprintf( buffer, _T("[%s]"), strParam );
                    }
                }else{
                    if( Commands[i].fType == VARG_TYPE_MSZ && !(Commands[i].fFlag & VARG_FLAG_FLATHELP)){
                        _stprintf( buffer, _T("<%s [%s ...]>"), strParam, strParam );
                    }else{
                        _stprintf( buffer, _T("<%s>"), strParam );
                    }
                }
                ASSIGN_STRING_RC( Commands[i].strParam, buffer, _T("*") );
            }else{
                strParam = NULL;
                ASSIGN_STRING_RC( Commands[i].strParam, strParam, _T("*") );
            }
        }
    }
}

ULONG MszStrLen( LPTSTR mszBuffer )
{
    ULONG nLength = 0;
    ULONG nTotalLength = 0;
    LPTSTR strScan = mszBuffer;
    ULONG  nTermSize = sizeof(TCHAR) * 2;

    while( strScan != NULL && *strScan != _T('\0') ){
        nLength = (_tcslen( strScan )+1);
        strScan += nLength;
        nTotalLength += nLength;
    }
    
    return (nTotalLength*sizeof(TCHAR) + nTermSize);
}

HRESULT
AddStringToMsz( LPTSTR* mszBuffer, LPTSTR strValue )
{
    ULONG  nNewDataSize = 0;
    ULONG  nOldDataSize = 0;
    LPTSTR strScan = *mszBuffer;
    LPTSTR mszNewBuffer;
    ULONG nLength;

    if( IsEmpty( strValue ) ){
        return ERROR_SUCCESS;
    }

    if( strScan != NULL ){
        while( *strScan != _T('\0') ){
            nLength = (_tcslen( strScan )+1);
            strScan += nLength;
            nOldDataSize += nLength;
        }
    }

    nNewDataSize = ( _tcslen( strValue )+1 ) * sizeof(TCHAR);

    mszNewBuffer = (LPTSTR)VARG_ALLOC( (nOldDataSize + nNewDataSize)*sizeof(TCHAR) + (sizeof(TCHAR)*2) );

    if( NULL == mszNewBuffer ){
        return ERROR_OUTOFMEMORY;
    }

    ZeroMemory( mszNewBuffer, (nOldDataSize + nNewDataSize)*sizeof(TCHAR) + (sizeof(TCHAR)*2) );

    if( nOldDataSize ){
        memcpy( mszNewBuffer, *mszBuffer, nOldDataSize*sizeof(TCHAR) );
        memcpy( (((PUCHAR)mszNewBuffer) + nOldDataSize*sizeof(TCHAR)), strValue, nNewDataSize );
    }else{
        memcpy( mszNewBuffer, strValue, nNewDataSize );
    }

    VARG_FREE( *mszBuffer );
    
    *mszBuffer = mszNewBuffer;
    
    return ERROR_SUCCESS;
}

void ParseIni( LPTSTR strFile )
{
    TCHAR buffer[MAXSTR];
    FILE* f;
    LPTSTR str;
    TCHAR strCmd[MAXSTR];
    LPTSTR strValue;
    BOOL bFound;
    int i;
    
    ZeroMemory( strCmd, MAXSTR*sizeof(TCHAR) );

    if( strFile == NULL || _tcslen( strFile ) == 0 ){
        return;
    }
    
    f = _tfopen( strFile, _T("r") );
    if( NULL == f ){
        return;
    }
    while( _fgetts( buffer, MAXSTR, f ) ){  
        
        if( buffer[0] == _T(';') || // comments
            buffer[0] == _T('#') ){

            continue;
        }
        
        Chomp( buffer );

        if( IsEmpty( buffer ) ){
            continue;
        }

        if( buffer[0] == _T('[') || _tcsstr( buffer, _T("=") ) ){
            str = _tcstok( buffer, _T("[]\n\t=") );
            if( str != NULL ){
                _tcscpy( strCmd, str );
                strValue = _tcstok( NULL, _T("]=\n ") );
            }else{
                strCmd[0] = _T('\0');
                strValue = NULL;
            }
        }else{
            strValue = _tcstok( buffer, _T("\n") );
        }
        
        bFound = FALSE;

        //
        // Check to see if it is a parameter that does not take a value
        //
        for(i=0; Commands[i].fType != VARG_TYPE_LAST && (!bFound);i++ ){
            if( IsCmd( &Commands[i], strCmd, TRUE ) ){
                switch( Commands[i].fType ){
                case VARG_TYPE_HELP:
                    bFound = TRUE;
                    break;
                case VARG_TYPE_BOOL:
                    bFound = TRUE;
                    Commands[i].bValue = Commands[i].bValue ? FALSE : TRUE;
                    break;
                }
                if( bFound ){
                    Commands[i].bDefined = TRUE;

                    if( Commands[i].bDefined && Commands[i].fntValidation != NULL ){
                        Commands[i].fntValidation(i);
                    }
                }
            }
        }

        if( bFound || strValue == NULL || _tcslen( strCmd ) == 0 ){
            continue;
        }

        for(i=0; Commands[i].fType != VARG_TYPE_LAST && (!bFound);i++ ){
            if( IsCmd( &Commands[i], strCmd, TRUE ) ){

                bFound = TRUE;
                if( Commands[i].bDefined && Commands[i].fType != VARG_TYPE_MSZ ){
                    continue;
                }

                switch( Commands[i].fType ){
                case VARG_TYPE_DEBUG:
                case VARG_TYPE_INT:
                    {
                        ULONG nValue;
                        if( ERROR_SUCCESS == ReadLong( strValue, &nValue, MAXLONG ) ){
                            Commands[i].nValue = nValue;
                            if( Commands[i].fType == VARG_TYPE_DEBUG ){
                                g_nDebug = nValue;
                            }
                        }
                    }
                    break;
                case VARG_TYPE_MSZ:
                    if( !Commands[i].bDefined ){
                        Commands[i].strValue = NULL;
                    }
                    if( Commands[i].fFlag & VARG_FLAG_CHOMP ){
                        Chomp( strValue );
                    }
                    AddStringToMsz( &Commands[i].strValue, strValue );
                    break;
                case VARG_TYPE_STR:
                    if( Commands[i].fFlag & VARG_FLAG_CHOMP ){
                        Chomp( strValue );
                    }
                    Commands[i].strValue = (LPTSTR)VARG_ALLOC( (_tcslen(strValue)+1) * sizeof(TCHAR) );
                    if( Commands[i].strValue != NULL ){
                        _tcscpy( Commands[i].strValue, strValue );
                    }
                    break;
                case VARG_TYPE_TIME:
                case VARG_TYPE_DATE:
                    ParseTime( strValue, &Commands[i].stValue, (Commands[i].fType == VARG_TYPE_DATE) );
                    break;
                }

                Commands[i].bDefined = TRUE;

                if( Commands[i].bDefined && Commands[i].fntValidation != NULL ){
                    Commands[i].fntValidation(i);
                }

            }
        }
    }

    fclose(f);
}

void ParseCmd(int argc, LPTSTR argv[] )
{
    int i;
    BOOL bFound;
    BOOL bHelp = FALSE;
    BOOL bBadSyntax = FALSE;

    int nIniIndex = (-1);
    
    g_LCID = VSetThreadUILanguage(0);

    VArgDeclareFormat();
    LoadCmd();
    SetUpColors();

    g_strProg = argv[0];
    argv++;argc--;

    while( argc > 0 ){
        
        bFound = FALSE;

        for(i=0; Commands[i].fType != VARG_TYPE_LAST && (!bFound);i++){
            
            if( IsCmd( &Commands[i], argv[0], FALSE ) ){

                if(Commands[i].bDefined){
                    PrintMessage( g_debug, IDS_MESSAGE_ARG_DUP, Commands[i].strArg1, argv[0] );
                    bBadSyntax = TRUE;
                }

                if( IsArg( argv[0] ) || Commands[i].fFlag & VARG_FLAG_VERB || Commands[i].fFlag & VARG_FLAG_ADVERB ){
                    argv++;argc--;
                }

                bFound = TRUE;

                Commands[i].bDefined = TRUE;

                switch( Commands[i].fType ){
                case VARG_TYPE_HELP:
                    Commands[i].bValue = TRUE;
                    bHelp = TRUE;
                    break;
                case VARG_TYPE_DEBUG:
                    Commands[i].fFlag |= VARG_FLAG_DEFAULTABLE;
                    g_nDebug = Commands[i].nValue;
                case VARG_TYPE_INT:
                    if( argc > 0 && !IsArg( argv[0] ) ){
                        ULONG nValue;
                        HRESULT hr = ReadLong( argv[0], &nValue, MAXLONG );
                        if( ERROR_SUCCESS == hr ){
                            Commands[i].nValue = nValue;   
                        }else{
                            Commands[i].fFlag |= VARG_FLAG_BADSYNTAX;
                        }
                        if( Commands[i].fType == VARG_TYPE_DEBUG ){
                            g_nDebug = Commands[i].nValue;
                        }
                        argv++;argc--;
                    }else if( !(Commands[i].fFlag & VARG_FLAG_DEFAULTABLE) ){
                        if( !Commands[i].bNegated ){
                            Commands[i].fFlag |= VARG_FLAG_BADSYNTAX;
                        }
                    }
                    break;
                case VARG_TYPE_BOOL:
                    Commands[i].bValue = Commands[i].bValue ? FALSE : TRUE;
                    break;
                case VARG_TYPE_MSZ:
                    if( argc > 0 && !IsArg( argv[0] ) ){
                        ASSIGN_STRING( Commands[i].strValue, argv[0] );
                        argv++;argc--;
                        while( argc > 0 && ! IsArg( argv[0] ) ){
                            if( Commands[i].fFlag & VARG_FLAG_CHOMP ){
                                Chomp( argv[0] );
                            }
                            AddStringToMsz( &Commands[i].strValue, argv[0] );
                            argv++;argc--;
                        }
                    }else if( Commands[i].fFlag & VARG_FLAG_DEFAULTABLE || Commands[i].bNegated ){
                        Commands[i].fFlag |= VARG_FLAG_DODEFAULT;
                    }else{
                        Commands[i].fFlag |= VARG_FLAG_BADSYNTAX;
                    }
                    break;
                case VARG_TYPE_INI:
                    nIniIndex = i;
                case VARG_TYPE_STR:
                    if( argc > 0 && ! IsArg( argv[0] ) ){
                        if( Commands[i].fFlag & VARG_FLAG_CHOMP ){
                            Chomp( argv[0] );
                        }
                        Commands[i].strValue = (LPTSTR)VARG_ALLOC( (_tcslen(argv[0])+2) * sizeof(TCHAR) );
                        if( Commands[i].strValue != NULL ){
                            _tcscpy( Commands[i].strValue, argv[0] );
                        }
                        argv++;argc--;
                    }else if( Commands[i].fFlag & VARG_FLAG_DEFAULTABLE || Commands[i].bNegated ){
                        Commands[i].fFlag |= VARG_FLAG_DODEFAULT;
                    }else{
                        if( !(Commands[i].fFlag & VARG_FLAG_NEGATE) ){
                            Commands[i].fFlag |= VARG_FLAG_BADSYNTAX;
                        }
                    }
                    break;
                case VARG_TYPE_TIME:
                case VARG_TYPE_DATE:
                    if( argc > 0 && !IsArg( argv[0] ) ){
                        HRESULT hr;
                        LPTSTR strDate = NULL;
                        LPTSTR strTime = argv[0];
                        argv++;argc--;
                        if( Commands[i].fType == VARG_TYPE_DATE ){
                            if( argc > 0 && !IsArg( argv[0] ) ){
                                strDate = (LPTSTR)VARG_ALLOC( (_tcslen(strTime)+_tcslen(argv[0])+2)*sizeof(TCHAR) );
                                if( NULL != strDate ){
                                    _stprintf( strDate, _T("%s %s"), strTime, argv[0] );
                                    strTime = strDate;
                                }
                                argv++;argc--;
                            }
                        }

                        hr = ParseTime( strTime, &Commands[i].stValue, (Commands[i].fType == VARG_TYPE_DATE) );
                        if( ERROR_SUCCESS != hr ){
                            Commands[i].fFlag |= VARG_FLAG_BADSYNTAX;
                        }
                        VARG_FREE( strDate );
                    }else if( !(Commands[i].fFlag & VARG_FLAG_DEFAULTABLE) && !(Commands[i].bNegated) ){
                        Commands[i].fFlag |= VARG_FLAG_BADSYNTAX;
                    }
                }

                if( Commands[i].fFlag & VARG_FLAG_EXPANDFILES ){
                    ExpandFiles( &Commands[i].strValue, (Commands[i].fType == VARG_TYPE_MSZ) );
                }
            }
        }

        if (!bFound){
            PrintMessage( g_debug, IDS_MESSAGE_UNKNOWNPARAM, (*(argv)));
            argv++;argc--;
            bBadSyntax = TRUE;
        }

    }

    if( nIniIndex >= 0 ){
        if( Commands[nIniIndex].fType == VARG_TYPE_INI && Commands[nIniIndex].bDefined ){
            ParseIni( Commands[nIniIndex].strValue );
        }
    }

    for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){

        if( !bHelp && (Commands[i].bDefined && Commands[i].fntValidation != NULL ) ){
            Commands[i].fntValidation(i);
        }
        if( ( Commands[i].fType == VARG_TYPE_STR || 
            Commands[i].fType == VARG_TYPE_MSZ || 
            Commands[i].fType == VARG_TYPE_INI ) && 
            (!Commands[i].bDefined || Commands[i].fFlag & VARG_FLAG_DODEFAULT ) ){
        
            TCHAR buffer[MAXSTR];
            
            Commands[i].fFlag &= ~VARG_FLAG_DODEFAULT;
            if( Commands[i].fFlag & VARG_FLAG_RCDEFAULT ){
                LoadString( NULL, Commands[i].nValue, buffer, MAXSTR );
                ASSIGN_STRING( Commands[i].strValue, buffer );
            }else if( Commands[i].strValue != NULL ){
                ASSIGN_STRING( Commands[i].strValue, Commands[i].strValue );
            }

        }
    }

    if( bHelp ){
        DisplayCommandLineHelp();
    }

    if( g_nDebug >= 0 ){
        DisplayDebugInfo();
    }

    if( ERROR_SUCCESS != ValidateCommands() || bBadSyntax ){
        PrintMessage( g_debug, IDS_MESSAGE_INCORRECT );
        FreeCmd();
        exit(ERROR_BAD_FORMAT);
    }
}

void
DisplayIniInfo()
{
    int i;
    int nOut;
    BOOL bOpt;
    PrintMessage( g_normal, IDS_MESSAGE_INISYNT );
    for( i=0;i<35;i++){ varg_printf( g_normal, _T("-") ); }
    varg_printf( g_normal,  _T("\n") );
    for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){

        if( Commands[i].fFlag & VARG_FLAG_HIDDEN && !(Commands[i].bDefined) ){
            continue;
        }

        bOpt = ( Commands[i].strArg2 != NULL && _tcslen( Commands[i].strArg2 ) );

        switch( Commands[i].fType ){
        case VARG_TYPE_DEBUG:
        case VARG_TYPE_BOOL:
        case VARG_TYPE_MSZ:
        case VARG_TYPE_STR:
        case VARG_TYPE_INT:
        case VARG_TYPE_TIME:
        case VARG_TYPE_DATE:
            nOut = varg_printf( g_normal,  
                            _T("  %1!-20s! %2!-20s!\n"), 
                            Commands[i].strArg1, bOpt ? 
                            Commands[i].strArg2 : _T("") 
                        );
            break;
        }
    }
    varg_printf( g_normal,  _T("\n") );
}

void
DisplayDebugInfo()
{
    int i;
    int nOut;
    TCHAR strDefault[MAXSTR] = _T("");

    LoadString( NULL, IDS_MESSAGE_DEFAULT, strDefault, MAXSTR );

    for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
        if( !(Commands[i].bDefined) && g_nDebug < 1 ){
            continue;
        }
        if( Commands[i].fType == VARG_TYPE_HELP ){
            continue;
        }
        if( Commands[i].fFlag & VARG_FLAG_HIDDEN && !(Commands[i].bDefined) ){
            continue;
        }
        nOut = varg_printf( g_debug,  _T("%1!-16s! = "), Commands[i].strArg1 );
        switch( Commands[i].fType ){
        case VARG_TYPE_DEBUG:
        case VARG_TYPE_INT:
            varg_printf( g_debug,  _T("%1!-20lu!"), Commands[i].nValue );
            break;
        case VARG_TYPE_BOOL:
            varg_printf( g_debug,  _T("%1!-20s!"),
                Commands[i].bValue ? _T("TRUE") : _T("FALSE")
                );
            break;
        case VARG_TYPE_MSZ:
            if( !IsEmpty( Commands[i].strValue ) ){
                LPTSTR strValue = Commands[i].strValue;
                while( *strValue != _T('\0') ){
                    if( strValue == Commands[i].strValue ){
                        varg_printf( g_debug,  _T("%1!-20s!"), strValue );
                    }else{
                        varg_printf( g_debug,  _T("\n%1!19s!%2!-20s!"), _T(" "), strValue );
                    }
                    strValue += (_tcslen( strValue )+1);
                }
            }else{
                varg_printf( g_debug,  _T("%1!-20s!"), _T("-") );
            }
            break;
        case VARG_TYPE_TIME:
        case VARG_TYPE_DATE:
            {
                int nOut;
                nOut = PrintDateEx( g_debug, &Commands[i].stValue );
                while( nOut++ < 20 ) { varg_printf( g_debug, _T(" ") ); }
            }
            break;
        case VARG_TYPE_INI:
        case VARG_TYPE_STR:
            varg_printf( g_debug,  _T("%1!-20s!"),
                (Commands[i].strValue == NULL || !(_tcslen(Commands[i].strValue)) ) ? 
                _T("-") : Commands[i].strValue
                );
            break;
        }
        if( !Commands[i].bDefined ){
            varg_printf( g_debug, _T(" (%1!s!)"), strDefault );
        }
        varg_printf( g_debug,  _T("\n") );
       
    }
    varg_printf( g_debug,  _T("\n") );
}

int PrintMessage( WORD color, LONG id, ... )
{
    int nLoad;
    TCHAR buffer[MAXSTR];
    va_list args;

    va_start( args, id );
    
    nLoad = LoadString( NULL, id, buffer, MAXSTR );
    
    if( nLoad > 0 ){
        nLoad = varg_vprintf( color, buffer, args );
    }else{
        nLoad = FormatMessage( 
                        FORMAT_MESSAGE_FROM_HMODULE, 
                        GetModuleHandle(NULL), 
                        id, 
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                        buffer, 
                        MAXSTR, 
                        &args 
                    );
        varg_printf( color, buffer );
    }
    
    return nLoad;
}

BOOL varg_strlen( LPTSTR str, ULONG* pVisualSize, ULONG* pActualSize, BOOL* bCanBreak )
{
    BOOL bResult;
    WORD wType[MAXSTR];
    ULONG i;
    
    *pActualSize = _tcslen(str);
    if( *pActualSize > MAXSTR ){
        return FALSE;
    }

    bResult = GetStringTypeEx( VARG_LOCALE, CT_CTYPE3, str, *pActualSize, (LPWORD)&wType );
    if( !bResult ){
        return FALSE;
    }
    
    *pVisualSize = 0;
    *bCanBreak = FALSE;
    for( i=0;i<*pActualSize;i++ ){
        if( wType[i] & (C3_KATAKANA|C3_HIRAGANA|C3_IDEOGRAPH|C3_FULLWIDTH) ){
            *pVisualSize += 2;
            *bCanBreak = TRUE;
        }else{
            *pVisualSize += 1;
        }
    }

    return TRUE;
}

HRESULT PrintHelpString( LONG id, LONG nStart, LONG nCol, LONG nMax, BOOL bSwitch )
{
    int j,nLoad;
    TCHAR buffer[MAXSTR];
    LPTSTR strHelp;
    ULONG nOut;

    if( nMax <= nCol ){
        nMax = 79;
    }

    nLoad = LoadString( NULL, id, buffer, MAXSTR );
    strHelp = _tcstok( buffer, g_strArgToken );
    
    if( bSwitch ){
        _tcstok( NULL, g_strArgToken );
        _tcstok( NULL, g_strArgToken );
        strHelp = _tcstok( NULL, g_strArgToken );
    }
    
    nOut = nStart;

    for(j=nStart;j<nCol;j++){ nOut += varg_printf( g_normal,  _T(" ") ); }

    if( nLoad > 0 && strHelp != NULL && _tcslen( strHelp ) ){
        
        LPTSTR str = strHelp;
        ULONG nChar = 0;
        ULONG nPrint = 0;
        BOOL bCanBreak;
        ULONG nVisualLength, nActualLength;
        LPTSTR strNewLine;
        LPTSTR strFailCheck = NULL;

        while( *str != _T('\0') ){
            nChar++;
            switch( *str ){
            case _T('\t'):
            case _T(' '):
                *str = _T('\0');
            }
            str++;
        }

        str = strHelp;
        nMax -= (nMax%2);
        while( nPrint < nChar ){
            varg_strlen( str, &nVisualLength, &nActualLength, &bCanBreak );
            strNewLine = _tcsstr( str, _T("\n") );
            if( ((SHORT)(nVisualLength+nOut) > (nMax-1)) || (NULL != strNewLine) ){
                if( NULL != strNewLine ){
                    *strNewLine = _T('\0');
                    nPrint += _tcslen( str );
                    varg_printf( g_normal, str );
                    strNewLine++;
                    str = strNewLine;
                }else if(bCanBreak){
                    TCHAR cSaveChar;
                    ULONG nBreak = (ULONG)ceil(((double)(nMax - nOut))/2.0);
                    if( nBreak < nActualLength ){
                        cSaveChar = str[nBreak];
                        str[nBreak] = _T('\0');
                        nPrint += nBreak;
                        varg_printf( g_normal, str );
                        str[nBreak] = cSaveChar;
                        str = str + nBreak;
                    }else if( nBreak == nActualLength ){
                        nPrint += nBreak;
                        varg_printf( g_normal, str );
                        str = str + nBreak;
                        continue;
                    }
                }
                if( str == strFailCheck ){
                    varg_printf( g_normal, str );
                    str += _tcslen(str)+1;
                    nPrint++;
                }else{
                    varg_printf( g_normal, _T("\n") );
                    for(j=0,nOut=0;j<nCol;j++){ nOut += varg_printf( g_normal,  _T(" ") ); }
                }
                strFailCheck = str;
            }else{
                nPrint += nActualLength;
                nOut += varg_printf( g_normal, str );
                if( (SHORT)(nOut) < nMax ){
                    nOut += varg_printf( g_normal, _T(" ") );
                    nPrint++;
                }
                str += _tcslen(str)+1;
            }
        }
        varg_printf( g_normal,  _T("\n") );
        return ERROR_SUCCESS;
    }
    
    return ERROR_FILE_NOT_FOUND;
}

void DisplayVersionInfo()
{
    TCHAR buffer[512];
    TCHAR strProgram[MAXSTR];
    TCHAR strMicrosoft[512];
    DWORD dw;
    BYTE* pVersionInfo;
    LPTSTR pVersion = NULL;
    LPTSTR pProduct = NULL;
    LPTSTR pCopyRight = NULL;

    dw = GetModuleFileName(NULL, strProgram, MAXSTR );
    LoadString( NULL, IDS_MESSAGE_MSR, strMicrosoft, 512 );

    if( dw>0 ){

        dw = GetFileVersionInfoSize( strProgram, &dw );
        if( dw > 0 ){
     
            pVersionInfo = (BYTE*)VARG_ALLOC(dw);
            if( NULL != pVersionInfo ){
                if(GetFileVersionInfo( strProgram, 0, dw, pVersionInfo )){
                    LPDWORD lptr = NULL;
                    VerQueryValue( pVersionInfo, _T("\\VarFileInfo\\Translation"), (void**)&lptr, (UINT*)&dw );
                    if( lptr != NULL ){
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("ProductVersion") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pVersion, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("OriginalFilename") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pProduct, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("LegalCopyright") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pCopyRight, (UINT*)&dw );
                    }
                
                    if( pProduct != NULL && pVersion != NULL && pCopyRight != NULL ){
                        varg_printf( g_normal,  _T("\n%1!s! %2!s! (%3!s!)\n%4!s!\n\n"), strMicrosoft, pProduct, pVersion, pCopyRight );
                    }
                }
                VARG_FREE( pVersionInfo );
            }
        }
    }
}

void
DisplayHelpEx( LONG id )
{
    TCHAR buffer[8];
    DWORD dwSize = 8;

    dwSize = LoadString( NULL, id, buffer, dwSize );
    if( dwSize > 0 ){
        PrintMessage( g_normal, id );
    }
}

void
DisplayCommandLineHelp()
{
    int i,j;
    int nOut;
    BOOL bOpt;
    BOOL bVerbs = FALSE;
    int  nVerbs = 0;
    int  nCommands = 0;
    BOOL bRequired = FALSE;
    int  nConditional = 0;
    int  nDefinedConditional = 0;
    BOOL bFirst = TRUE;
    BOOL bDisplayAll = FALSE;
    DWORD dwVerbMask = 0;
    UCHAR excl1 = 0;
    LPTSTR strNegateHelp = NULL;

    for( i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
        if( (Commands[i].dwSet & VARG_CONDITION) && 
            !(Commands[i].fFlag & VARG_FLAG_VERB) ){
            nConditional++;
            if( Commands[i].bDefined ){
                nDefinedConditional++;
            }
        }
        if( Commands[i].fFlag & VARG_FLAG_VERB ){
            bVerbs = TRUE;
        }

        if( Commands[i].bDefined ){
            if( Commands[i].fFlag & VARG_FLAG_VERB || Commands[i].fFlag & VARG_FLAG_ADVERB){
                nVerbs++;
                dwVerbMask |= (Commands[i].dwVerb & 0x0000FFFF);
                if( Commands[i].dwSet != 0 ){
                    excl1 = (UCHAR)(((Commands[i].dwSet & VARG_GROUPEXCL) >> 24) & 0x0F);
                }
            }else{
                if( Commands[i].fType != VARG_TYPE_HELP && 
                    Commands[i].fType != VARG_TYPE_DEBUG ){
                    nCommands++;
                }
            }
        }
    }
    if( nCommands == 0 && nVerbs == 0 ){
        bDisplayAll = TRUE;
    }
    DisplayVersionInfo();
    
    if( bDisplayAll ){
        if( ERROR_SUCCESS == PrintHelpString( IDS_PROGRAM_DESCRIPTION, 0, 0, g_X, FALSE ) ){
            varg_printf( g_normal,  _T("\n") );
        }
    }
    
    // Usage
    PrintMessage( g_normal, IDS_MESSAGE_USAGE );
    nOut = varg_printf( g_normal,  _T("%1!s! "), g_strProg );
    if( bVerbs ){
        LONG nDispVerbs = 0;
        if( !bDisplayAll ){
            for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
                if( Commands[i].fFlag & VARG_FLAG_VERB && Commands[i].bDefined ){
                    nOut += varg_printf( g_normal,  _T("%1!s! "), Commands[i].strArg1 );
                    nDispVerbs++;
                }
            }
        }
        if( bDisplayAll || !nDispVerbs ){
            nOut += PrintMessage( g_normal,  IDS_MESSAGE_VERB );
        }
    }
    if( nConditional > 1 && nDefinedConditional == 0 ){
        nOut += varg_printf( g_normal,  _T("{ ") );
    }
    for( j=0;j<2;j++){
        for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
            if( j==0 ){
                // show conditional switches
                if( Commands[i].fFlag & VARG_FLAG_HIDDEN || 
                    Commands[i].fFlag & VARG_FLAG_VERB ||
                    !(Commands[i].dwSet & VARG_CONDITION) ){
                    continue;
                }
                if( nDefinedConditional > 0 && !Commands[i].bDefined ){
                    continue;
                }
            }else{
                // show required switches
                if( Commands[i].fFlag & VARG_FLAG_HIDDEN || 
                    Commands[i].fFlag & VARG_FLAG_VERB ||
                    Commands[i].dwSet & VARG_CONDITION ||
                    Commands[i].fFlag & VARG_FLAG_OPTIONAL ){
                    continue;
                }
            }
            if( (!bFirst) && nConditional && nDefinedConditional == 0 ){
                nOut += varg_printf( g_normal,  _T("| ") );
            }
            bFirst = FALSE;
            if( Commands[i].fFlag & VARG_FLAG_NOFLAG ){
                nOut += varg_printf( g_normal,  _T("%1!s! "), Commands[i].strParam );
            }else{
                nOut += varg_printf( g_normal,  _T("%1!c!%2!s!%3!s!%4!s!%5!s! "), 
                        Commands[i].fFlag&VARG_FLAG_VERB ? g_strVerbPrefix[0] : g_strPrefix[0], 
                        Commands[i].fFlag&VARG_FLAG_NEGATE ? _T("[-]"):_T(""),
                        Commands[i].strArg2, 
                        ArgExpected( &Commands[i] ) ? _T(" "): _T(""), 
                        Commands[i].strParam 
                    );
            }
            if( nOut > (g_X - 15) ){
                nOut = 0;
                varg_printf( g_normal, _T("\n") );
                while( nOut++ < HELP_INDENT){ varg_printf( g_normal, _T(" ") ); }
            }
        }
        if( j == 0 && (nConditional>1) && nDefinedConditional == 0 ){
            varg_printf( g_normal,  _T("} ") );
        }
    }
    PrintMessage( g_normal, IDS_MESSAGE_LINEOPT );

    // Verbs
    if( bVerbs ){
        bFirst = TRUE;
        for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
            if( Commands[i].fFlag & VARG_FLAG_HIDDEN && !(Commands[i].bDefined) ){
                continue;
            }
            if( !(Commands[i].fFlag & VARG_FLAG_VERB ) ){
                continue;
            }
            if( !bDisplayAll && !Commands[i].bDefined ){
                continue;
            }
            if( bFirst ){
                PrintMessage( g_normal, IDS_MESSAGE_VERBS );
                bFirst = FALSE;
            }
            bOpt = ( Commands[i].strArg2 != NULL && _tcslen( Commands[i].strArg2 ) );
            nOut = varg_printf( COLORIZE(i),  _T("  %1!s!%2!s! %3!s! "),
                        g_strVerbPrefix,
                        (LPTSTR)(bOpt ? Commands[i].strArg2 : Commands[i].strArg1),
                        Commands[i].strParam
                    );
            if( nOut > HELP_INDENT ){
                nOut += varg_printf( g_normal, _T(" ") );
            }
           
            PrintHelpString( Commands[i].idParam, nOut, HELP_INDENT, g_X, TRUE );
        }
        if( !bFirst ){
            varg_printf( g_normal,  _T("\n") );
        }
    }
    
    // Options
    for(j=0;j<2;j++){
        bFirst = TRUE;
        for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
            if( j==0 ){
                if( !(Commands[i].fFlag & VARG_FLAG_NOFLAG) ||
                    Commands[i].fFlag & (VARG_FLAG_VERB|VARG_FLAG_ADVERB) ){
                    continue;
                }
            }else{
                if( Commands[i].fFlag & VARG_FLAG_NOFLAG || 
                    Commands[i].fFlag & (VARG_FLAG_VERB|VARG_FLAG_ADVERB) ){
                    continue;
                }
            }
            if( ! bDisplayAll && (Commands[i].fType == VARG_TYPE_HELP) ){
                continue;
            }
            if( Commands[i].fFlag & VARG_FLAG_HIDDEN && !(Commands[i].bDefined) ){
                continue;
            }
            if( bDisplayAll || 
                Commands[i].bDefined || 
                (((Commands[i].dwVerb & 0x0000FFFF)& dwVerbMask) && nCommands < 1 )  ){
                UCHAR excl2 = (UCHAR)((((Commands[i].dwSet & VARG_GROUPEXCL) >> 24) & 0xF0) >> 4 );
                if( excl2 & excl1 ){
                    continue;
                }
                if( bFirst ){
                    switch( j ){
                    case 0:
                        PrintMessage( g_normal, IDS_MESSAGE_PARAMETERS );
                        bRequired = TRUE;
                        break;
                    case 1:
                        PrintMessage( g_normal, IDS_MESSAGE_OPTIONS, bRequired ? _T("\n") : _T("") );
                        break;
                    }
                    bFirst = FALSE;
                }
                bOpt = ( Commands[i].strArg2 != NULL && _tcslen( Commands[i].strArg2 ) );
                if( Commands[i].fFlag & VARG_FLAG_NOFLAG ){
                    nOut = varg_printf( COLORIZE(i),  _T("  %1!s! "),
                            Commands[i].strParam
                        );
                }else{
                    nOut = varg_printf( COLORIZE(i),  _T("  %1!c!%2!s!%3!s! %4!s! "),
                            g_strPrefix[0],
                            Commands[i].fFlag & VARG_FLAG_NEGATE ? _T("[-]") : _T(""),
                            bOpt ? Commands[i].strArg2 : Commands[i].strArg1,
                            Commands[i].strParam
                        );
                }
                if( nOut > HELP_INDENT ){
                    nOut += varg_printf( g_normal, _T("  ") );
                }
                if( Commands[i].fFlag & VARG_FLAG_NEGATE && NULL == strNegateHelp ){
                    strNegateHelp = bOpt ? Commands[i].strArg2 : Commands[i].strArg1;
                }
                PrintHelpString( Commands[i].idParam, nOut, HELP_INDENT, g_X, TRUE );
                if( !bDisplayAll ){
                    if( Commands[i].fType == VARG_TYPE_INI ){
                        DisplayIniInfo();
                    }
                }
            }
        }
    }

    if( NULL != strNegateHelp ){
        PrintMessage( g_normal, IDS_MESSAGE_NEGATE, strNegateHelp, strNegateHelp );
    }

    // Notes
    if( bDisplayAll ){
        PrintMessage( g_normal, IDS_MESSAGE_HELPTEXT );
    }

    // Examples
    bFirst = TRUE;
    for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
        if( bDisplayAll || Commands[i].bDefined ){
            if( (bDisplayAll && bVerbs ) && 
                !(Commands[i].fFlag & (VARG_FLAG_VERB|VARG_FLAG_ADVERB) ) ){
                continue;
            }
            if( Commands[i].fFlag & VARG_FLAG_EXHELP ){
                if( bFirst ){
                    PrintMessage( g_normal, IDS_MESSAGE_EXAMPLES );
                    bFirst = FALSE;
                }
                PrintHelpString( Commands[i].idExHelp, 0, 2, 80, FALSE );
            }
        }
    }

    FreeCmd();
    exit(0);
}

void PrintParam( int idPrompt, int cmd, BOOL bEOL )
{
    BOOL bUseArg1;
    TCHAR buffer[MAXSTR];
    bUseArg1 = (Commands[cmd].fFlag & VARG_FLAG_VERB) || 
               (Commands[cmd].fFlag & VARG_FLAG_ADVERB) ||
               ( IsEmpty( Commands[cmd].strArg2 ) );

    if( 0 != idPrompt ){
        LoadString( NULL, idPrompt, buffer, MAXSTR );
        varg_printf( g_debug, buffer );
    }
    
    if( Commands[cmd].fFlag & VARG_FLAG_NOFLAG ){
        varg_printf( g_debug,  _T("%1!s! "),  Commands[cmd].strParam );
    }else{
        if( !(Commands[cmd].fFlag & (VARG_FLAG_VERB|VARG_FLAG_ADVERB)) ){
            varg_printf( g_debug, _T("%1!c!"), g_strPrefix[0] );
        }else if( !IsEmpty( g_strVerbPrefix ) ){
            varg_printf( g_debug, _T("%1!c!"), g_strVerbPrefix[0] );
        }
        if( ArgExpected( &Commands[cmd] ) ){
            varg_printf( g_debug,  _T("%1!s!%2!s! %3!s! "),
                    Commands[cmd].fFlag&VARG_FLAG_NEGATE ? _T("[-]") : _T(""),
                    bUseArg1 ? Commands[cmd].strArg1 : Commands[cmd].strArg2,
                    Commands[cmd].strParam
                );
        }else{
            varg_printf( g_debug,  _T("%1!s!%2!s! "),
                    Commands[cmd].fFlag&VARG_FLAG_NEGATE ? _T("[-]") : _T(""),
                    bUseArg1 ? Commands[cmd].strArg1 : Commands[cmd].strArg2
                );
        }
    }

    if( bEOL ){
        varg_printf( g_debug,  _T("\n") );
    }
    
}

HRESULT
ValidateCommands()
{
    int i,j;
    HRESULT hr = ERROR_SUCCESS;
    BOOL bVerbs = FALSE;
    BOOL nDefinedVerbs = 0;

    for(i=0; Commands[i+1].fType != VARG_TYPE_LAST;i++){
        UCHAR cond1 = (UCHAR)((Commands[i].dwSet & VARG_CONDITION) >> 16);
        if( cond1 ){
            BOOL bFound = FALSE;
            for(j=0; Commands[j].fType != VARG_TYPE_LAST;j++){
                UCHAR cond2 = (UCHAR)((Commands[j].dwSet & VARG_CONDITION) >> 16);
                if( (cond1 & cond2) && Commands[j].bDefined ){
                    bFound = TRUE;
                    break;
                }
            }
            if( ! bFound ){
                for(j=0; Commands[j].fType != VARG_TYPE_LAST;j++){
                    UCHAR cond2 = (UCHAR)((Commands[j].dwSet & VARG_CONDITION) >> 16);
                    if( (cond1 & cond2) && !(Commands[j].fFlag & VARG_FLAG_VERB)){
                        Commands[j].fFlag |= VARG_FLAG_REQUIRED;
                    }
                }
            }
        }
        if( Commands[i].bDefined && (Commands[i].fFlag & VARG_FLAG_REQ_ADV) ){
            BOOL bFound = FALSE;
            WORD wVerb1 = (WORD)( Commands[i].dwVerb & 0x0000FFFF );
            for(j=0; Commands[j].fType != VARG_TYPE_LAST;j++){
                WORD wVerb2 = (WORD)(Commands[j].dwVerb & 0x0000FFFF);
                if( Commands[j].bDefined && (wVerb1 == wVerb2) && (Commands[j].fFlag & VARG_FLAG_ADVERB) ){
                    bFound = TRUE;
                    break;
                }
            }
            if( ! bFound ){
                for(j=0; Commands[j].fType != VARG_TYPE_LAST;j++){
                    WORD wVerb2 = (WORD)(Commands[j].dwVerb & 0x0000FFFF);
                    if( wVerb1 == wVerb2 && Commands[j].fFlag & VARG_FLAG_ADVERB ){
                        Commands[j].fFlag |= VARG_FLAG_REQUIRED;
                    }
                }
            }
        }
        if( Commands[i].bDefined && Commands[i].dwSet ){
            UCHAR excl1 = (UCHAR)((Commands[i].dwSet & VARG_EXCLUSIVE));
            UCHAR incl1 = (UCHAR)((Commands[i].dwSet & VARG_INCLUSIVE) >> 8);
            UCHAR grp_ex1 = (UCHAR)(((Commands[i].dwSet & VARG_GROUPEXCL) >> 24) & 0x0F);
            for(j=i+1; Commands[j].fType != VARG_TYPE_LAST;j++){
                if( Commands[j].dwSet ){
                    UCHAR excl2 = (UCHAR)((Commands[j].dwSet & VARG_EXCLUSIVE));
                    UCHAR incl2 = (UCHAR)((Commands[j].dwSet & VARG_INCLUSIVE) >> 8);
                    UCHAR grp_in2 = (UCHAR)((((Commands[j].dwSet & VARG_GROUPEXCL) >> 24) & 0xF0) >> 4 );
                    if( excl1 && (excl1 & excl2) && Commands[j].bDefined ){
                        PrintParam( 0, i, FALSE );
                        PrintParam( IDS_MESSAGE_AND, j, FALSE );
                        PrintMessage( g_debug, IDS_MESSAGE_EXCLUSIVE );
                        hr = ERROR_BAD_ARGUMENTS;
                    }
                    if( incl1 && (incl1 & incl2) && !Commands[j].bDefined){
                        PrintParam( 0, i, FALSE );
                        PrintParam( IDS_MESSAGE_REQUIRES, j, FALSE );
                        varg_printf( g_debug, _T("\n") );
                        hr = ERROR_BAD_ARGUMENTS;
                    }
                    if( grp_ex1 && (grp_in2 & grp_ex1) && Commands[j].bDefined ){
                        PrintParam( 0, i, FALSE );
                        PrintParam( IDS_MESSAGE_AND, j, FALSE );
                        PrintMessage( g_debug, IDS_MESSAGE_EXCLUSIVE );
                        hr = ERROR_BAD_ARGUMENTS;
                    }
                }
            }
        }

        if( Commands[i].bDefined && (Commands[i].fFlag & VARG_FLAG_LITERAL) ){
            LPTSTR strValues;
            LPTSTR strCheck;
            LPTSTR strArg;
            BOOL bFound = FALSE;
            switch( Commands[i].fType ){
            case VARG_TYPE_MSZ:
            case VARG_TYPE_STR:
                
                strArg = Commands[i].strValue;
                while( strArg != NULL && !(Commands[i].fFlag & VARG_FLAG_BADSYNTAX) ){
                    ASSIGN_STRING( strValues, Commands[i].strParam );
                    if( NULL != strValues ){
                        strCheck = _tcstok( strValues, _T("<>[]|") );
                        while( !bFound && strCheck != NULL ){
                            if( _tcsicmp( strCheck, strArg ) == 0 ){
                                bFound = TRUE;
                                break;
                            }
                            strCheck = _tcstok( NULL, _T("<>[]|") );
                        }
                    }
                    VARG_FREE( strValues );
                    if( !bFound ){
                        Commands[i].fFlag |= VARG_FLAG_BADSYNTAX;
                        hr = ERROR_BAD_ARGUMENTS;
                    }
                    if( Commands[i].fType == VARG_TYPE_MSZ ){
                        strArg += _tcslen( strArg ) + 1;
                        bFound = FALSE;
                        if( *strArg == _T('\0') ){
                            strArg = NULL;
                        }
                    }else{
                        strArg = NULL;
                    }
                }
                break;
            default:
                hr = ERROR_INVALID_PARAMETER;
            }
        }
    }

    for(i=0; Commands[i].fType != VARG_TYPE_LAST;i++){
        if( Commands[i].fFlag & VARG_FLAG_VERB ){
            if( Commands[i].bDefined ){
                nDefinedVerbs++;
            }
            bVerbs = TRUE;
        }
        if( (Commands[i].fFlag & VARG_FLAG_REQUIRED) && !Commands[i].bDefined){
            PrintParam( IDS_MESSAGE_MISSING, i, TRUE );
            hr = ERROR_BAD_ARGUMENTS;
        }
        if( Commands[i].fFlag & VARG_FLAG_BADSYNTAX ){
            PrintParam( IDS_MESSAGE_BADSYNTAX, i, TRUE );
            hr = ERROR_BAD_ARGUMENTS;
        }
    }
        
    if( bVerbs && nDefinedVerbs == 0 ){
        PrintMessage( g_debug, IDS_MESSAGE_NOVERB );
        hr = ERROR_BAD_ARGUMENTS;
    }

    return hr;
}

/*****************************************************************************\
    Utility Functions        
\*****************************************************************************/

HRESULT GetUserInput( LPTSTR strBuffer, ULONG lSize, BOOL bEcho )
{
    TCHAR c;
    UCHAR a;
    ULONG i = 0;
    BOOL bDone = FALSE;
    HANDLE hInput = NULL;
    DWORD dwSize;
    DWORD dwMode;
    
    hInput = GetStdHandle( STD_INPUT_HANDLE );

    GetConsoleMode( hInput, &dwMode);
    SetConsoleMode( hInput, (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & dwMode);

    while( !bDone ){
        if( (GetFileType(hInput) & ~FILE_TYPE_REMOTE) != FILE_TYPE_CHAR ){
            BOOL bRead = ReadFile( hInput, &a, 1, &dwSize, NULL );
            if( 0 == dwSize || !bRead ){
                c = _T('\n');
            }else{
                MultiByteToChar( a, c );
                if( _T('\r') == c ){
                    bRead = ReadFile( hInput, &a, 1, &dwSize, NULL );
                }
            }
        }else{
            ReadConsole( hInput, &c, 1, &dwSize, NULL );
        }
        switch( c ){
        case 8:
            if( i > 0 ){
                strBuffer[i--] = _T('\0');
                if(bEcho){
                    _tprintf( _T("%c %c"), c, c );
                }
            }
            break;
        case 3:
            FreeCmd();
            SetConsoleMode(hInput, dwMode);
            exit(0);
        case _T('\r'):
        case _T('\n'):
            bDone = TRUE;
            varg_printf( g_normal, _T("\n") );
            break;
        default:
            if( i < (lSize-1) ){
                strBuffer[i++] = (TCHAR)c;
                if( bEcho ){
                    varg_printf( g_normal, _T("%1!c!"), c );
                }
            }
        }
    }

    SetConsoleMode(hInput, dwMode);

    if( i > lSize ){
        return ERROR_INSUFFICIENT_BUFFER;
    }else{
        strBuffer[i] = _T('\0');
    }

    return ERROR_SUCCESS;
}

HRESULT
CheckFile( LPTSTR strFile, DWORD dwFlags )
{
    HRESULT hr = ERROR_SUCCESS;
    HANDLE hFile;

    hFile = CreateFile(
                strFile,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
    if( hFile == INVALID_HANDLE_VALUE){
        hr = GetLastError();
    }
    CloseHandle(hFile);
    
    if( dwFlags & VARG_CF_OVERWRITE ){
        if( ERROR_FILE_NOT_FOUND == hr ){
            hr = ERROR_SUCCESS;
        }else if( ERROR_PATH_NOT_FOUND == hr){
            return hr;
        }else if( dwFlags & VARG_CF_PROMPT ){
            
            TCHAR buffer[MAXSTR] = _T("");
            TCHAR yes[16];

            PrintMessage( g_normal, IDS_CF_OVERWRITE, strFile );
            GetUserInput( buffer, MAXSTR, TRUE );
            LoadString( NULL, IDS_ARG_YES, yes, 16 );

            if( FindString( buffer, yes ) ){
                hr = ERROR_SUCCESS;
            }else{
                hr = ERROR_ALREADY_EXISTS;
            }
        }
    }
    
    return hr;
}

HRESULT
ExpandFiles( LPTSTR* mszFiles, BOOL bMultiple )
{
    LPTSTR strFiles = NULL;
    LPTSTR strExpand;

    TCHAR buffer[_MAX_PATH];
    TCHAR drive[_MAX_DRIVE];
    TCHAR dir[_MAX_DIR];
    TCHAR fname[_MAX_FNAME];
    TCHAR ext[_MAX_EXT];
    HANDLE hFile = NULL;

    strExpand = *mszFiles;
    while( strExpand != NULL && *strExpand != _T('\0')){
        WIN32_FIND_DATA file;
        _tsplitpath( strExpand, drive, dir, fname, ext );
        hFile = FindFirstFile( strExpand, &file );
        
        if( hFile != INVALID_HANDLE_VALUE){
            do{
                if( !( !_tcscmp(file.cFileName, _T(".") ) || !_tcscmp(file.cFileName, _T("..")) ) ){
                    _tmakepath( buffer, drive, dir, file.cFileName, _T("") );
                    AddStringToMsz( &strFiles, buffer );
                }
            }while( FindNextFile( hFile, &file ) == TRUE );
            
            FindClose( hFile );

        }else{
            return GetLastError();
        }
        if( bMultiple ){
            strExpand += _tcslen( strExpand )+1;
        }else{
            break;
        }

    }
    
    if( NULL != strFiles ){
        VARG_FREE( *mszFiles );
        *mszFiles = strFiles;
    }

    return ERROR_SUCCESS;
}

BOOL FindString( LPTSTR strBuffer, LPTSTR strMatch )
{
    BOOL bReturn = FALSE;

    LPTSTR buffer;
    LPTSTR match;

    ASSIGN_STRING( buffer, strBuffer );
    ASSIGN_STRING( match, strMatch );
    
    if( buffer != NULL && match != NULL ){
        _tcslwr( buffer );
        _tcslwr( match );

        if( _tcsstr( buffer, match ) ){
            bReturn = TRUE;
        }
    }

    VARG_FREE( match );
    VARG_FREE( buffer );

    return bReturn;
}

HRESULT 
ParseTime( LPTSTR strTime, SYSTEMTIME* pstTime, BOOL bDate )
{
    TCHAR buffer[MAXSTR];
    TCHAR PM[9] = _T("pm");
    TCHAR AM[9] = _T("am");
    TCHAR strDateSep[8] = _T("/");
    TCHAR strTimeSep[8] = _T(":");
    ULONG l;
    LPTSTR str, str2;
    int nDateFormat = 0;
    BOOL bValid = TRUE;
    FILETIME ft;
    HRESULT hr = ERROR_SUCCESS;

    ZeroMemory( pstTime, sizeof( SYSTEMTIME ) );
    
    if( GetLocaleInfo( VARG_LOCALE, LOCALE_IDATE, buffer, MAXSTR ) > 0 ){
        nDateFormat = _ttoi( buffer );
    }
    if( GetLocaleInfo( VARG_LOCALE, LOCALE_S1159, buffer, 9 ) > 0 ){
        _tcsncpy( AM, buffer, 9 );
    }
    if( GetLocaleInfo( VARG_LOCALE, LOCALE_S2359, buffer, 9 ) > 0 ){
        _tcsncpy( PM, buffer, 9 );
    }
    if( GetLocaleInfo( VARG_LOCALE, LOCALE_STIME, buffer, 8 ) > 0 ){
        _tcsncpy( strTimeSep, buffer, 8 );
    }
    if( GetLocaleInfo( VARG_LOCALE, LOCALE_SDATE, buffer, 8 ) > 0 ){
        _tcsncpy( strDateSep, buffer, 8 );
    }

    _tcsncpy( buffer, strTime, MAXSTR );
    buffer[MAXSTR-1] = _T('\0');

    str = _tcstok( buffer, _T(" \n\t") );
    str2 = _tcstok( NULL, _T(" \n\t") );
    while( str ){
        if( _tcsstr( str, strDateSep ) ){

            LPTSTR strMonth = NULL;
            LPTSTR strDay = NULL;
            LPTSTR strYear = NULL;

            switch( nDateFormat ){
            case 0:
                strMonth = _tcstok( str, strDateSep );
                strDay = _tcstok( NULL, strDateSep );
                strYear = _tcstok( NULL, strDateSep );
                break;
            case 1:
                strDay = _tcstok( NULL, strDateSep );
                strMonth = _tcstok( str, strDateSep );
                strYear = _tcstok( NULL, strDateSep );
                break;
            case 2:
                strYear = _tcstok( NULL, strDateSep );
                strMonth = _tcstok( str, strDateSep );
                strDay = _tcstok( NULL, strDateSep );
                break;
            }

            if( NULL != strMonth ){
                hr = ReadLong( strMonth, &l, MAXWORD );
                if( ERROR_SUCCESS == hr ){
                    pstTime->wMonth = (WORD)l;
                }
            }
            if( NULL != strDay ){
                hr = ReadLong( strDay, &l, MAXWORD );
                if( ERROR_SUCCESS == hr ){
                    pstTime->wDay = (WORD)l;
                }
            }
            if( NULL != strYear ){
                hr = ReadLong( strYear, &l, MAXWORD );
                if( ERROR_SUCCESS == hr ){
                    pstTime->wYear = (WORD)l;
                }
            }
        }else{
            LPTSTR tok1 = NULL;
            LPTSTR tok2 = NULL;
            LPTSTR tok3 = NULL;
            UINT nTok = 0;
            BOOL bPM = FALSE;
            BOOL bAM = FALSE;
            LPTSTR szZero = _T("0");

            bPM = FindString( str, PM );
            bAM = FindString( str, AM );

            tok1 = _tcstok( str, strTimeSep );
            if( NULL != tok1 ){
                nTok++;
                tok2 = _tcstok( NULL, strTimeSep );
            }else{
                tok1 = szZero;
            }
            if( NULL != tok2 ){
                nTok++;
                tok3 = _tcstok( NULL, strTimeSep );
            }else{
                tok2 = szZero;
            }
            if( NULL != tok3 ){
                nTok++;
            }else{
                tok3 = szZero;
            }
            if( bDate ){
                nTok = 3;
            }
            switch( nTok ){
            case 1:
                hr = ReadLong( tok1, &l, MAXWORD );
                if( ERROR_SUCCESS == hr ){
                    pstTime->wSecond = (WORD)l;
                }
                break;
            case 2:
                hr = ReadLong( tok1, &l, MAXWORD );
                if( ERROR_SUCCESS == hr ){
                    pstTime->wMinute = (WORD)l;
                    hr = ReadLong( tok2, &l, MAXWORD );
                    if( ERROR_SUCCESS == hr ){
                        pstTime->wSecond = (WORD)l;
                    }
                }
                break;
            case 3:
                hr = ReadLong( tok1, &l, MAXWORD );
                if( ERROR_SUCCESS == hr ){
                    pstTime->wHour = (WORD)l;
                    hr = ReadLong( tok2, &l, MAXWORD );
                    if( ERROR_SUCCESS == hr ){
                        pstTime->wMinute = (WORD)l;
                        hr = ReadLong( tok3, &l, MAXWORD );
                        if( ERROR_SUCCESS == hr ){
                            pstTime->wSecond = (WORD)l;
                        }
                    }
                }
                break;
            }
            if( ERROR_SUCCESS == hr ){
                if( bPM ){
                    if( pstTime->wHour < 12 ){
                        pstTime->wHour += 12;
                    }else if( pstTime->wHour > 12 ){
                        PrintMessage( g_debug, IDS_MESSAGE_BADTIME, PM );
                    }
                }
                if( bAM ){
                    if( pstTime->wHour > 12 ){
                        PrintMessage( g_debug, IDS_MESSAGE_BADTIME, AM );
                    }
                }
            }
        }
        str = str2;
        str2 = NULL;
    }
    
    if( bDate && ERROR_SUCCESS == hr ){
        bValid = SystemTimeToFileTime( pstTime, &ft );
        if( !bValid ){
            hr = GetLastError();
        }
    }

    return hr;
}

void PrintError( HRESULT hr )
{
    PrintErrorEx( hr, NULL );
}

void PrintErrorEx( HRESULT hr, LPTSTR strModule, ... )
{
    LPVOID lpMsgBuf = NULL;
    HINSTANCE hModule = NULL;
    DWORD dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER;

    va_list args;
    va_start( args, strModule );

    if(hr == 0){
        hr = GetLastError();
    }

    if( strModule != NULL ){
        hModule = LoadLibrary( strModule );
    }

    if ( NULL != hModule ) {
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
    }else{
        dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }

    FormatMessage(
            dwFlags,
            hModule,
            hr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR)&lpMsgBuf,
            MAXSTR,
            &args
        );

    if ( NULL != hModule ) {
        FreeLibrary( hModule );
    }
    
    if( g_nDebug >= 0 ){
        PrintMessage( g_debug, IDS_MESSAGE_ERROR_DBG, hr );
    }else{
        PrintMessage( g_debug, IDS_MESSAGE_ERROR );
    }
    if( NULL == lpMsgBuf ){
        PrintMessage( g_debug, IDS_MESSAGE_UNKNOWN );
    }else{
        varg_printf( g_debug, _T("%1!s!\n"), (LPTSTR)lpMsgBuf );
    }

    LocalFree( lpMsgBuf );
}

int 
PrintDateEx( SHORT color, SYSTEMTIME* st )
{
    TCHAR buffer[MAXSTR];
    TCHAR strDateSep[8] = _T("/");
    TCHAR strTimeSep[8] = _T(":");
    int nDateFormat = 0;
    int nOut = 0;

    if( GetLocaleInfo( VARG_LOCALE, LOCALE_IDATE, buffer, MAXSTR ) > 0 ){
        nDateFormat = _ttoi( buffer );
    }
    if( GetLocaleInfo( VARG_LOCALE, LOCALE_STIME, buffer, 8 ) > 0 ){
        _tcscpy( strTimeSep, buffer );
    }
    if( GetLocaleInfo( VARG_LOCALE, LOCALE_SDATE, buffer, 8 ) > 0 ){
        _tcscpy( strDateSep, buffer );
    }

    if( st->wMonth ){
        switch( nDateFormat ){
        case 0:
            nOut = varg_printf( color,  _T("%1!d!%2!s!%3!d!%4!s!%5!d! "), 
                    st->wMonth, 
                    strDateSep, 
                    st->wDay, 
                    strDateSep, 
                    st->wYear
                );
            break;
        case 1:
            nOut = varg_printf( color,  _T("%1!d!%2!s!%3!d!%4!s!%5!d! "), 
                    st->wDay, 
                    strDateSep, 
                    st->wMonth, 
                    strDateSep, 
                    st->wYear
                );
            break;
        case 2:
            nOut = varg_printf( color,  _T("%1!d!%2!s!%3!d!%4!s!%5!d! "), 
                    st->wYear, 
                    strDateSep, 
                    st->wMonth, 
                    strDateSep, 
                    st->wDay
                );
            break;
        }
    }

    nOut += varg_printf( color, _T("%1!d!%2!s!%3!02d!%4!s!%5!02d!"),
                    st->wHour, 
                    strTimeSep, 
                    st->wMinute, 
                    strTimeSep, 
                    st->wSecond
              );

    return nOut;
}

void PrintDate( SYSTEMTIME* st )
{
    PrintDateEx( g_normal, st );
}

/*****************************************************************************\

    VSetThreadUILanguage

    This routine sets the thread UI language based on the console codepage.

    9-29-00    WeiWu    Created.
    6-19-01    coreym   Adapted from Base\Win32\Winnls so that it works in W2K

\*****************************************************************************/

LANGID WINAPI 
VSetThreadUILanguage(WORD wReserved)
{
    //
    //  Cache system locale and CP info
    // 
    static LCID s_lidSystem = 0;
    static UINT s_uiSysCp = 0;
    static UINT s_uiSysOEMCp = 0;

    ULONG uiUserUICp = 0;
    ULONG uiUserUIOEMCp = 0;
    TCHAR szData[16];

    LANGID lidUserUI = GetUserDefaultUILanguage();
    LCID lcidThreadOld = GetThreadLocale();

    //
    //  Set default thread locale to EN-US
    //
    //  This allow us to fall back to English UI to avoid trashed characters 
    //  when console doesn't meet the criteria of rendering native UI.
    //
    LCID lcidThread = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
    UINT uiConsoleCp = GetConsoleOutputCP();

    //
    //  Get cached system locale and CP info.
    //
    if (!s_uiSysCp) {
        LCID lcidSystem = GetSystemDefaultLCID();

        if (lcidSystem) {
            //
            // Get ANSI CP
            //
            GetLocaleInfo(lcidSystem, LOCALE_IDEFAULTANSICODEPAGE, szData, sizeof(szData)/sizeof(TCHAR));
            uiUserUICp = _ttol(szData);

            //
            // Get OEM CP
            //
            GetLocaleInfo(lcidSystem, LOCALE_IDEFAULTCODEPAGE, szData, sizeof(szData)/sizeof(TCHAR));
            s_uiSysOEMCp = _ttol(szData);
            
            //
            // Cache system primary langauge
            //
            s_lidSystem = PRIMARYLANGID(LANGIDFROMLCID(lcidSystem));
        }
    }

    //
    //  Don't cache user UI language and CP info, UI language can be changed without system reboot.
    //
    if (lidUserUI) {
        GetLocaleInfo(MAKELCID(lidUserUI,SORT_DEFAULT), LOCALE_IDEFAULTANSICODEPAGE, szData, sizeof(szData)/sizeof(TCHAR));
        uiUserUICp = _ttol(szData);

        GetLocaleInfo(MAKELCID(lidUserUI,SORT_DEFAULT), LOCALE_IDEFAULTCODEPAGE, szData, sizeof(szData)/sizeof(TCHAR));
        uiUserUIOEMCp = _ttol(szData);
    }

    //
    //  Complex scripts cannot be rendered in the console, so we
    //  force the English (US) resource.
    //
    if (uiConsoleCp && 
        s_lidSystem != LANG_ARABIC && 
        s_lidSystem != LANG_HEBREW &&
        s_lidSystem != LANG_VIETNAMESE && 
        s_lidSystem != LANG_THAI) {
        //
        //  Use UI language for console only when console CP, system CP and UI language CP match.
        //
        if ((uiConsoleCp == s_uiSysCp || uiConsoleCp == s_uiSysOEMCp) && 
            (uiConsoleCp == uiUserUICp || uiConsoleCp == uiUserUIOEMCp)) {

            lcidThread = MAKELCID(lidUserUI, SORT_DEFAULT);
        }
    }

    //
    //  Set the thread locale if it's different from the currently set
    //  thread locale.
    //
    if ((lcidThread != lcidThreadOld) && (!SetThreadLocale(lcidThread))) {
        lcidThread = lcidThreadOld;
    }

    //
    //  Return the thread locale that was set.
    //
    return (LANGIDFROMLCID(lcidThread));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\logman.cpp ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#include <windows.h>
#include <objbase.h>
#include <wbemidl.h>
#include <conio.h>
#include <pdhp.h>
#include <pdhmsg.h>
#include <lmuse.h>
#include "resource.h"
#include <wmistr.h>
#include <initguid.h>
#include <evntrace.h>
#include <shlwapi.h>

#include "logmmsg.h"
#include "varg.c"

// Exclusive
#define GROUP_START     0x01
#define GROUP_END       0x02

// Group Exclusive
#define GROUP_COUNTER   0x01
#define GROUP_TRACE     0x02
#define GROUP_CREATE    0x04

// Conditional
#define GROUP_ARG       0x01

#define VERB_CREATE     0x0001
#define VERB_COUNTER    0x0002
#define VERB_TRACE      0x0004
#define VERB_START      0x0008
#define VERB_STOP       0x0010
#define VERB_UPDATE     0x0020
#define VERB_QUERY      0x0040
#define VERB_DELETE     0x0080
#define VERB_PROV       0x0100

VARG_DECLARE_COMMANDS
    VARG_DEBUG ( VARG_FLAG_OPTIONAL|VARG_FLAG_HIDDEN )    
    VARG_HELP  ( VARG_FLAG_OPTIONAL )
    VARG_BOOL  ( IDS_PARAM_CREATE,      VARG_FLAG_OPTIONAL|VARG_FLAG_VERB|VARG_FLAG_REQ_ADV, FALSE )
    VARG_BOOL  ( IDS_PARAM_COUNTER,     VARG_FLAG_ADVERB|VARG_FLAG_HIDDEN, FALSE )
    VARG_BOOL  ( IDS_PARAM_TRACE,       VARG_FLAG_ADVERB|VARG_FLAG_HIDDEN, FALSE )
    VARG_BOOL  ( IDS_PARAM_START,       VARG_FLAG_OPTIONAL|VARG_FLAG_VERB, FALSE )
    VARG_BOOL  ( IDS_PARAM_STOP,        VARG_FLAG_OPTIONAL|VARG_FLAG_VERB, FALSE )
    VARG_BOOL  ( IDS_PARAM_DELETE,      VARG_FLAG_OPTIONAL|VARG_FLAG_VERB, FALSE )
    VARG_BOOL  ( IDS_PARAM_QUERY,       VARG_FLAG_DEFAULTABLE|VARG_FLAG_VERB|VARG_FLAG_OPT_ADV,  FALSE )
    VARG_BOOL  ( IDS_PARAM_QUERYPROV,   VARG_FLAG_ADVERB|VARG_FLAG_HIDDEN, FALSE )
    VARG_BOOL  ( IDS_PARAM_UPDATE,      VARG_FLAG_OPTIONAL|VARG_FLAG_VERB, FALSE )
    VARG_STR   ( IDS_PARAM_NAME,        VARG_FLAG_NOFLAG|VARG_FLAG_CHOMP, NULL )
    VARG_STR   ( IDS_PARAM_COMPUTER,    VARG_FLAG_OPTIONAL, NULL )
    VARG_INI   ( IDS_PARAM_SETTINGS,    VARG_FLAG_OPTIONAL, NULL )
    VARG_DATE  ( IDS_PARAM_BEGIN,       VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DATE )
    VARG_DATE  ( IDS_PARAM_END,         VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DATE )
    VARG_MSZ   ( IDS_PARAM_MANUAL,      VARG_FLAG_OPTIONAL|VARG_FLAG_FLATHELP|VARG_FLAG_LITERAL, NULL )
    VARG_BOOL  ( IDS_PARAM_REPEAT,      VARG_FLAG_OPTIONAL|VARG_FLAG_NEGATE, FALSE )
    VARG_STR   ( IDS_PARAM_OUTPUT,      VARG_FLAG_OPTIONAL|VARG_FLAG_RCDEFAULT|VARG_FLAG_CHOMP, IDS_DEFAULT_OUTPUT )
    VARG_STR   ( IDS_PARAM_FORMAT,      VARG_FLAG_OPTIONAL|VARG_FLAG_LITERAL, _T("bin") )
    VARG_BOOL  ( IDS_PARAM_APPEND,      VARG_FLAG_OPTIONAL|VARG_FLAG_NEGATE, FALSE )
    VARG_STR   ( IDS_PARAM_VERSION,     VARG_FLAG_OPTIONAL|VARG_FLAG_DEFAULTABLE|VARG_FLAG_NEGATE|VARG_FLAG_RCDEFAULT|VARG_FLAG_LITERAL, IDS_DEFAULT_NNNNN )
    VARG_STR   ( IDS_PARAM_RUNCMD,      VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_NEGATE|VARG_FLAG_CHOMP, NULL )
    VARG_INT   ( IDS_PARAM_MAX,         VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DEFAULT|VARG_FLAG_NEGATE, 0 )
    VARG_TIME  ( IDS_PARAM_NEWFILE,     VARG_FLAG_OPTIONAL|VARG_FLAG_DEFAULTABLE|VARG_FLAG_ARG_TIME|VARG_FLAG_NEGATE )
    VARG_MSZ   ( IDS_PARAM_COUNTERS,    VARG_FLAG_OPTIONAL, NULL )
    VARG_STR   ( IDS_PARAM_COUNTERFILE, VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_CHOMP, NULL )
    VARG_TIME  ( IDS_PARAM_SAMPLERATE,  VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_TIME )
    VARG_STR   ( IDS_PARAM_LOGGERNAME,  VARG_FLAG_OPTIONAL, NULL )
    VARG_BOOL  ( IDS_PARAM_REALTIME,    VARG_FLAG_OPTIONAL|VARG_FLAG_NEGATE, FALSE )
    VARG_MSZ   ( IDS_PARAM_PROVIDER,    VARG_FLAG_OPTIONAL|VARG_FLAG_FLATHELP, NULL )
    VARG_STR   ( IDS_PARAM_PROVIDERFILE,VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_CHOMP, NULL )
    VARG_BOOL  ( IDS_PARAM_USERMODE,    VARG_FLAG_OPTIONAL|VARG_FLAG_NEGATE, FALSE )
    VARG_INT   ( IDS_PARAM_BUFFERSIZE,  VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DEFAULT, 64 )
    VARG_TIME  ( IDS_PARAM_FLUSHTIMER,  VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_TIME )
    VARG_MSZ   ( IDS_PARAM_BUFFERS,     VARG_FLAG_OPTIONAL|VARG_FLAG_FLATHELP, NULL )
    VARG_BOOL  ( IDS_PARAM_FLUSHBUFFERS,VARG_FLAG_OPTIONAL, FALSE )
    VARG_MSZ   ( IDS_PARAM_USER,        VARG_FLAG_OPTIONAL|VARG_FLAG_FLATHELP|VARG_FLAG_NEGATE|VARG_FLAG_DEFAULTABLE, _T("") )
    VARG_TIME  ( IDS_PARAM_RUNFOR,      VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_TIME )
    VARG_BOOL  ( IDS_PARAM_YES,         VARG_FLAG_OPTIONAL, FALSE )
    VARG_BOOL  ( IDS_PARAM_ETS,         VARG_FLAG_OPTIONAL, FALSE )
    VARG_INT   ( IDS_PARAM_AGE,         VARG_FLAG_OPTIONAL|VARG_FLAG_HIDDEN, FALSE )
    VARG_MSZ   ( IDS_PARAM_MODE,        VARG_FLAG_OPTIONAL, NULL )
VARG_DECLARE_NAMES
    eDebug,
    eHelp,
    eCreate,
    eCounter,
    eTrace,
    eStart,
    eStop,
    eDelete,
    eQuery,
    eQueryProv,
    eUpdate,
    eName,
    eComputer,
    eConfig,
    eBegin,
    eEnd,
    eManual,
    eRepeat,
    eOutput,
    eFormat,
    eAppend,
    eVersion,
    eRunCmd,
    eMax,
    eNewFile,
    eCounters,
    eCounterFile,
    eSampleInterval,
    eLoggerName,
    eRealTime,
    eProviders,
    eProviderFile,
    eUserMode,
    eBufferSize,
    eFlushTimer,
    eBuffers,
    eFlushBuffers,
    eUser,
    eRunFor,
    eYes,
    eEts,
    eAgeLimit,
    eMode,
VARG_DECLARE_FORMAT
    VARG_VERB  ( eCreate,        VERB_CREATE )
    VARG_ADVERB( eCounter,       VERB_CREATE, VERB_COUNTER )
    VARG_ADVERB( eTrace,         VERB_CREATE, VERB_TRACE )
    VARG_VERB  ( eStart,         VERB_START )
    VARG_VERB  ( eStop,          VERB_STOP )
    VARG_VERB  ( eDelete,        VERB_DELETE )
    VARG_VERB  ( eQuery,         VERB_QUERY )
    VARG_ADVERB( eQueryProv,     VERB_QUERY, VERB_PROV )
    VARG_VERB  ( eUpdate,        VERB_UPDATE )
    VARG_VERB  ( eName,          VERB_CREATE|VERB_UPDATE|VERB_START|VERB_STOP|VERB_QUERY|VERB_DELETE )
    VARG_VERB  ( eBegin,         VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eEnd,           VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eManual,        VERB_UPDATE|VERB_CREATE|VERB_COUNTER )
    VARG_VERB  ( eRepeat,        VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eOutput,        VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eFormat,        VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eAppend,        VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eVersion,       VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eRunCmd,        VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eMax,           VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eNewFile,       VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eCounters,      VERB_UPDATE|VERB_CREATE|VERB_COUNTER )
    VARG_VERB  ( eCounterFile,   VERB_UPDATE|VERB_CREATE|VERB_COUNTER )
    VARG_VERB  ( eSampleInterval,VERB_UPDATE|VERB_CREATE|VERB_COUNTER )
    VARG_VERB  ( eLoggerName,    VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eRealTime,      VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eProviders,     VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eProviderFile,  VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eUserMode,      VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eBufferSize,    VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eFlushTimer,    VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eBuffers,       VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eFlushBuffers,  VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_VERB  ( eUser,          VERB_UPDATE|VERB_CREATE|VERB_TRACE|VERB_COUNTER|VERB_QUERY )
    VARG_VERB  ( eComputer,      VERB_UPDATE|VERB_CREATE|VERB_TRACE|VERB_COUNTER|VERB_QUERY|VERB_START|VERB_STOP|VERB_DELETE )
    VARG_VERB  ( eRunFor,        VERB_UPDATE|VERB_CREATE )
    VARG_VERB  ( eEts,           VERB_UPDATE|VERB_TRACE|VERB_START|VERB_STOP|VERB_QUERY )
    VARG_VERB  ( eMode,          VERB_UPDATE|VERB_CREATE|VERB_TRACE )
    VARG_GROUP ( eCounter,       VARG_GRPX(GROUP_COUNTER,GROUP_TRACE) )
    VARG_GROUP ( eTrace,         VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eStart,         VARG_EXCL(GROUP_START) )
    VARG_GROUP ( eStop,          VARG_EXCL(GROUP_END) )
    VARG_GROUP ( eQuery,         VARG_COND(GROUP_ARG) )
    VARG_GROUP ( eName,          VARG_COND(GROUP_ARG) )
    VARG_GROUP ( eBegin,         VARG_EXCL(GROUP_START) )
    VARG_GROUP ( eEnd,           VARG_EXCL(GROUP_END) )
    VARG_GROUP ( eManual,        VARG_EXCL(GROUP_START) )
    VARG_GROUP ( eCounters,      VARG_GRPX(GROUP_COUNTER,GROUP_TRACE) )
    VARG_GROUP ( eCounterFile,   VARG_GRPX(GROUP_COUNTER,GROUP_TRACE) )
    VARG_GROUP ( eSampleInterval,VARG_GRPX(GROUP_COUNTER,GROUP_TRACE) )
    VARG_GROUP ( eLoggerName,    VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eRealTime,      VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eProviders,     VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eProviderFile,  VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eUserMode,      VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eBufferSize,    VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eFlushTimer,    VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eBuffers,       VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eFlushBuffers,  VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eEts,           VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_GROUP ( eMode,          VARG_GRPX(GROUP_TRACE,GROUP_COUNTER) )
    VARG_EXHELP( eEts,           IDS_EXAMPLE_ETS )
    VARG_EXHELP( eCreate,        IDS_EXAMPLE_CREATE )
    VARG_EXHELP( eStart,         IDS_EXAMPLE_START )
    VARG_EXHELP( eUpdate,        IDS_EXAMPLE_UPDATE )
VARG_DECLARE_END

typedef struct _PROVIDER_REC {
    _PROVIDER_REC* flink;
    _PROVIDER_REC* blink;
    LPTSTR strProviderName;
    LPTSTR strProviderGuid;
    LPTSTR strFlags;
    LPTSTR strLevel;
} PROVIDER_REC, *PPROVIDER_REC;

ULONG hextoi( LPWSTR s );
DWORD SetCredentials();
DWORD GetCountersFromFile( LPTSTR strFile, PPDH_PLA_ITEM pItem );
DWORD GetFileFormat( LPTSTR str, LPDWORD pdwFormat );
DWORD SetPlaInfo( PPDH_PLA_INFO pInfo );
HRESULT WbemConnect( IWbemServices** pWbemServices );
HRESULT GetProviders( PPDH_PLA_ITEM pItem );
HRESULT GetTraceNameToGuidMap( PPROVIDER_REC pProviders );
HRESULT EventTraceSessionControl();
HRESULT WbemError( HRESULT hr );
PDH_STATUS QueryCollection( LPTSTR strCollection, BOOL bHeader );
PDH_STATUS QuerySingleCollection( LPTSTR strCollection );
PDH_STATUS ScheduleLog();
void ShowValidationError( PDH_STATUS pdhStatus, PPDH_PLA_INFO pInfo );
void LogmanError( DWORD dwStatus );
void PdhError( PDH_STATUS pdhStatus, PPDH_PLA_INFO pInfo );

#define CHECK_STATUS( hr ) if( ERROR_SUCCESS != hr ){ goto cleanup; }

#define SEVERITY( s )    ((ULONG)s >> 30)

#define NT_KERNEL_GUID      _T("{9e814aad-3204-11d2-9a82-006008a86939}")
#define NT_KERNEL_LOGGER    _T("NT Kernel Logger")
#define PDH_MODULE          _T("PDH.DLL")

TCHAR g_strUser[MAXSTR];
TCHAR g_strPassword[MAXSTR];
TCHAR g_strIPC[MAXSTR];

int __cdecl _tmain( int argc, LPTSTR* argv )
{
    HRESULT hr = ERROR_SUCCESS;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD dwStatus = ERROR_SUCCESS;
    PDH_PLA_INFO_W info;

    ZeroMemory( &info, sizeof( PDH_PLA_INFO ) );

    ParseCmd( argc, argv );

    if( Commands[eUser].bDefined && !(Commands[eUser].bNegated) ){
        dwStatus = SetCredentials();
    }else{
        g_strIPC[0] = _T('\0');
    }

    if( dwStatus != ERROR_SUCCESS ){
        dwStatus = LOGMAN_ERROR_LOGON;
        goto cleanup;
    }

    if( Commands[eEts].bValue ){
        hr = EventTraceSessionControl();
        goto cleanup;
    }

    if( Commands[eStart].bValue ){

        pdhStatus = PdhPlaStart( Commands[eName].strValue, Commands[eComputer].strValue );
        CHECK_STATUS(pdhStatus);

    }else if( Commands[eStop].bValue ){

        pdhStatus = PdhPlaStop( Commands[eName].strValue, Commands[eComputer].strValue );
        CHECK_STATUS(pdhStatus);

    }else if( Commands[eDelete].bValue ){

        pdhStatus = PdhPlaDelete( Commands[eName].strValue, Commands[eComputer].strValue );
        CHECK_STATUS(pdhStatus);

    }else if( Commands[eCreate].bDefined ){

        DWORD dwType = 0;
        if( Commands[eCounter].bDefined ){
            dwType = PLA_COUNTER_LOG;
        }else if( Commands[eTrace].bDefined ){
            dwType = PLA_TRACE_LOG;
        }
       
        info.dwMask |= PLA_INFO_FLAG_TYPE;
        info.dwType = dwType;

        dwStatus = SetPlaInfo( &info );
        CHECK_STATUS( dwStatus );

        if( Commands[eYes].bValue ){
            PdhPlaDeleteW( Commands[eName].strValue, Commands[eComputer].strValue );
        }

        pdhStatus = PdhPlaCreate( Commands[eName].strValue, Commands[eComputer].strValue, &info );
        CHECK_STATUS( pdhStatus );
 
        if( Commands[eRunFor].bDefined ||
            Commands[eManual].bDefined ){
        
            pdhStatus = ScheduleLog();
            if( pdhStatus != ERROR_SUCCESS ){
                PdhPlaDeleteW( Commands[eName].strValue, Commands[eComputer].strValue );
            }
            CHECK_STATUS( pdhStatus );
        }

    }else if( Commands[eQuery].bDefined ){

        if( Commands[eQueryProv].bDefined ){
            
            hr = GetTraceNameToGuidMap( NULL );
            goto cleanup;

        }else if( Commands[eName].strValue != NULL ){

            pdhStatus = QuerySingleCollection( Commands[eName].strValue );

        }else{

            DWORD dwSize = 0;
            LPTSTR mszCollections = NULL;

            pdhStatus = PdhPlaEnumCollections( Commands[eComputer].strValue, &dwSize, mszCollections );
            if( ERROR_SUCCESS == pdhStatus || PDH_INSUFFICIENT_BUFFER == pdhStatus ){
                mszCollections = (LPTSTR)VARG_ALLOC( dwSize * sizeof(TCHAR) );
                if( mszCollections ){
                    LPTSTR strCollection;
                    pdhStatus = PdhPlaEnumCollections( Commands[eComputer].strValue, &dwSize, mszCollections );
                    if( ERROR_SUCCESS == pdhStatus ){
                        strCollection = mszCollections;
                        while( strCollection != NULL && *strCollection != _T('\0') ){
                            QueryCollection( strCollection, (strCollection == mszCollections) );
                            strCollection += ( _tcslen( strCollection ) + 1 );
                        }
                        varg_printf( g_normal, _T("\n") );
                    }
                    VARG_FREE( mszCollections );
                }else{ 
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            }
        }

    }else if( Commands[eUpdate].bDefined ){

        dwStatus = SetPlaInfo( &info );
        CHECK_STATUS( dwStatus );

        if( info.dwMask != 0 ){

            // Try update without credentials
            pdhStatus = PdhPlaSetInfoW( Commands[eName].strValue, Commands[eComputer].strValue, &info );

            if( PDH_ACCESS_DENIED == pdhStatus ){
                // Try again with credintials
                dwStatus = SetCredentials();
                CHECK_STATUS( dwStatus );

                if( ERROR_SUCCESS == dwStatus ){
                    info.dwMask |= PLA_INFO_FLAG_USER;
                    info.strUser = g_strUser;
                    info.strPassword = g_strPassword;
    
                    pdhStatus = PdhPlaSetInfoW( Commands[eName].strValue, Commands[eComputer].strValue, &info );
                }
            }
            CHECK_STATUS( pdhStatus );
        }

        if( Commands[eRunFor].bDefined ||
            Commands[eManual].bDefined ){
        
            pdhStatus = ScheduleLog();
            CHECK_STATUS( pdhStatus );
        }

    }
            
cleanup:

    if( ERROR_SUCCESS == dwStatus  && 
        ERROR_SUCCESS == hr  &&
        ERROR_SUCCESS == pdhStatus ){

        PrintMessage( g_normal, IDS_MESSAGE_SUCCESS );

    }else{
        if( ERROR_SUCCESS != dwStatus ){
            LogmanError( dwStatus );
        }
        if( ERROR_SUCCESS != hr ){
            WbemError( hr );
            dwStatus = hr;
        }
        if( ERROR_SUCCESS != pdhStatus ){
            PdhError( pdhStatus, &info );
            dwStatus = pdhStatus;
        }

        if( SEVERITY( dwStatus ) == STATUS_SEVERITY_WARNING ){
            PrintMessage( g_normal, IDS_MESSAGE_SUCCESS );
            dwStatus = ERROR_SUCCESS;
        }
    }

    if( info.dwMask & PLA_INFO_FLAG_COUNTERS && Commands[eCounterFile].bDefined ){
        VARG_FREE( info.Perf.piCounterList.strCounters );
    }
    if( info.dwMask & PLA_INFO_FLAG_PROVIDERS ){
        VARG_FREE( info.Trace.piProviderList.strProviders );
        VARG_FREE( info.Trace.piProviderList.strFlags );
        VARG_FREE( info.Trace.piProviderList.strLevels );
    }

    if( _tcslen( g_strIPC ) ){
        dwStatus = NetUseDel( NULL, g_strIPC, USE_LOTS_OF_FORCE /*luke*/ );
    }

    ZeroMemory( g_strPassword, sizeof(TCHAR)*MAXSTR );
    FreeCmd();
    CoUninitialize();

    return dwStatus;
}

DWORD 
SetPlaInfo( PPDH_PLA_INFO pInfo )
{
    DWORD dwStatus = ERROR_SUCCESS;

    if( Commands[eCounters].bDefined && Commands[eCounters].strValue != NULL ){
        pInfo->dwMask |= PLA_INFO_FLAG_COUNTERS;

        pInfo->Perf.piCounterList.dwType = PLA_COUNTER_LOG;
        pInfo->Perf.piCounterList.strCounters =  Commands[eCounters].strValue;

    }else if( Commands[eCounterFile].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_COUNTERS;

        dwStatus = GetCountersFromFile( Commands[eCounterFile].strValue, &(pInfo->Perf.piCounterList) );
        CHECK_STATUS( dwStatus );
    }

    if( Commands[eProviders].bDefined || Commands[eProviderFile].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_PROVIDERS;
        dwStatus = GetProviders( &(pInfo->Trace.piProviderList) );
        CHECK_STATUS( dwStatus );

        pInfo->Trace.piProviderList.dwType = PLA_TRACE_LOG;
    }

    if( Commands[eFormat].bDefined ){
        DWORD dwFormat;
        dwStatus = GetFileFormat( Commands[eFormat].strValue, &dwFormat );
        CHECK_STATUS( dwStatus );

        pInfo->dwMask |= PLA_INFO_FLAG_FORMAT;
        pInfo->dwFileFormat = dwFormat;
    }
    
    if( Commands[eAppend].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_DATASTORE;
        if( Commands[eAppend].bNegated ){
            pInfo->dwDatastoreAttributes |= PLA_DATASTORE_OVERWRITE;
        }else{
            pInfo->dwDatastoreAttributes |= PLA_DATASTORE_APPEND;
        }
    }
    
    if( Commands[eSampleInterval].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_INTERVAL;

        pInfo->Perf.ptSampleInterval.wDataType = PLA_TT_DTYPE_UNITS;
        pInfo->Perf.ptSampleInterval.dwUnitType = PLA_TT_UTYPE_SECONDS;
        pInfo->Perf.ptSampleInterval.wTimeType = PLA_TT_TTYPE_SAMPLE;
        pInfo->Perf.ptSampleInterval.dwAutoMode = PLA_AUTO_MODE_AFTER;

        pInfo->Perf.ptSampleInterval.dwValue = Commands[eSampleInterval].stValue.wSecond;
        pInfo->Perf.ptSampleInterval.dwValue += Commands[eSampleInterval].stValue.wMinute * 60;
        pInfo->Perf.ptSampleInterval.dwValue += Commands[eSampleInterval].stValue.wHour * 3600;
    }

    if( Commands[eBufferSize].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_BUFFERSIZE;
        pInfo->Trace.dwBufferSize = Commands[eBufferSize].nValue;
    }
    
    if( Commands[eBuffers].bDefined ){
        LPTSTR strMin;
        LPTSTR strMax;
        strMin = Commands[eBuffers].strValue;
        if( NULL != strMin ){
            pInfo->dwMask |= PLA_INFO_FLAG_MINBUFFERS;
            pInfo->Trace.dwMinimumBuffers = _ttoi( strMin );
    
            strMax = strMin + (_tcslen( strMin )+1);
            if( *strMax != _T('\0') ){
                pInfo->dwMask |= PLA_INFO_FLAG_MAXBUFFERS;
                pInfo->Trace.dwMaximumBuffers = _ttoi( strMax );
            }
        }
    }
    
    if( Commands[eFlushTimer].bDefined ){
        DWORD dwSeconds;
        dwSeconds = Commands[eFlushTimer].stValue.wSecond;
        dwSeconds += Commands[eFlushTimer].stValue.wMinute * 60;
        dwSeconds += Commands[eFlushTimer].stValue.wHour * 3600;

        pInfo->dwMask |= PLA_INFO_FLAG_FLUSHTIMER;
        pInfo->Trace.dwFlushTimer = dwSeconds;
    }
    
    if( Commands[eMax].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_MAXLOGSIZE;
        if( Commands[eMax].bNegated ){
            pInfo->dwMaxLogSize = PLA_DISK_MAX_SIZE;
        }else{
            pInfo->dwMaxLogSize = Commands[eMax].nValue;
        }
    }
    
    if( Commands[eRunCmd].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_RUNCOMMAND;
        if( Commands[eRunCmd].bNegated ){
            pInfo->strCommandFileName = _T("");            
        }else{
            pInfo->strCommandFileName = Commands[eRunCmd].strValue;
        }
    }
    
    if( Commands[eOutput].bDefined && NULL != Commands[eOutput].strValue ){

        if( ((pInfo->dwMask & PLA_INFO_FLAG_FORMAT) && 
            pInfo->dwFileFormat == PLA_SQL_LOG ) ||
            !StrCmpNI( Commands[eOutput].strValue, _T("SQL:"), 4 ) ){

            pInfo->dwMask |= PLA_INFO_FLAG_SQLNAME;
            pInfo->strSqlName = Commands[eOutput].strValue;

        }else{
            if( IsEmpty( Commands[eOutput].strValue ) ){
                pInfo->dwMask |= (PLA_INFO_FLAG_DEFAULTDIR|PLA_INFO_FLAG_FILENAME);
                pInfo->strDefaultDir = _T("");
                pInfo->strBaseFileName = _T("");
            }else{
                LPTSTR str = NULL;
                TCHAR full[MAXSTR];
                TCHAR buffer[MAX_PATH];
                TCHAR drive[_MAX_DRIVE];
                TCHAR dir[_MAX_DIR];
                TCHAR fname[_MAX_FNAME];
                TCHAR ext[_MAX_EXT];
                DWORD dwFormat;

                _tfullpath( full, Commands[eOutput].strValue, MAXSTR );
                _tsplitpath( full, drive, dir, fname, ext );
                VARG_FREE( Commands[eOutput].strValue );
                Commands[eOutput].strValue = NULL;
                if( _tcslen( drive ) ){
                    _stprintf( buffer, _T("%s%s"), drive, dir );
                }else{
                    _tcscpy( buffer, dir );
                }
                if( _tcslen( buffer ) ){
                    pInfo->dwMask |= PLA_INFO_FLAG_DEFAULTDIR;         
                    AddStringToMsz( &Commands[eOutput].strValue, buffer );
                }
                dwStatus = GetFileFormat( ext, &dwFormat );
                if( ERROR_SUCCESS == dwStatus ){
                    _stprintf( buffer, _T("%s"), fname );
                }else{
                    _stprintf( buffer, _T("%s%s"), fname, ext );
                    dwStatus = ERROR_SUCCESS;
                }
                if( _tcslen( buffer ) ){
                    pInfo->dwMask |= PLA_INFO_FLAG_FILENAME;         
                    AddStringToMsz( &Commands[eOutput].strValue, buffer );
                }
                str = Commands[eOutput].strValue;
                if( str != NULL  ){
                    if( pInfo->dwMask & PLA_INFO_FLAG_DEFAULTDIR ){
                        pInfo->strDefaultDir = str;
                        str += ( _tcslen( str ) + 1 );
                    }
                    if( pInfo->dwMask & PLA_INFO_FLAG_FILENAME ){
                        pInfo->strBaseFileName = str;
                    }
                }else{
                    dwStatus = ERROR_OUTOFMEMORY;
                    goto cleanup;
                }
            }
        }
    }
    
    if( Commands[eVersion].bDefined ){
        
        DWORD dwFormat = 0;
        pInfo->dwMask |= PLA_INFO_FLAG_AUTOFORMAT;

        if( Commands[eVersion].bNegated ){
            dwFormat = PLA_SLF_NAME_NONE;
        }else if( !_tcsicmp( Commands[eVersion].strValue, _T("nnnnnn") ) ){
            dwFormat = PLA_SLF_NAME_NNNNNN;
        }else if( !_tcsicmp( Commands[eVersion].strValue, _T("mmddhhmm") ) ){
            dwFormat = PLA_SLF_NAME_MMDDHHMM;
        }else{
            dwFormat = PLA_SLF_NAME_NNNNNN;
        }

        pInfo->dwAutoNameFormat = dwFormat;
    }
    
    if( Commands[eRealTime].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_MODE;
        if( Commands[eRealTime].bNegated ){
            pInfo->Trace.dwMode &= ~EVENT_TRACE_REAL_TIME_MODE;
        }else{
            pInfo->Trace.dwMode |= EVENT_TRACE_REAL_TIME_MODE;
        }
    }
    
    if( Commands[eUserMode].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_MODE;
        if( Commands[eUserMode].bNegated ){
            pInfo->Trace.dwMode &= ~EVENT_TRACE_PRIVATE_LOGGER_MODE;
        }else{
            pInfo->Trace.dwMode |= EVENT_TRACE_PRIVATE_LOGGER_MODE;   
        }
    }
    
    if( Commands[eLoggerName].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_LOGGERNAME;
        pInfo->Trace.strLoggerName = Commands[eLoggerName].strValue;
    }
    
    if( Commands[eRepeat].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_REPEAT;
        if( Commands[eRepeat].bNegated ){
            pInfo->ptRepeat.dwAutoMode = PLA_AUTO_MODE_NONE;
        }else{
            pInfo->ptRepeat.wDataType = PLA_TT_DTYPE_UNITS;
            pInfo->ptRepeat.wTimeType = PLA_TT_TTYPE_REPEAT_SCHEDULE;
            pInfo->ptRepeat.dwUnitType = PLA_TT_UTYPE_DAYSOFWEEK;
            pInfo->ptRepeat.dwAutoMode = PLA_AUTO_MODE_CALENDAR;

            pInfo->ptRepeat.dwValue = 0x0000007F;
        }
    }
    
    if( Commands[eNewFile].bDefined ){
        
        pInfo->dwMask |= PLA_INFO_FLAG_CRTNEWFILE;
        
        pInfo->ptCreateNewFile.wTimeType = PLA_TT_TTYPE_CREATENEWFILE;
        pInfo->ptCreateNewFile.wDataType = PLA_TT_DTYPE_UNITS;

        if( Commands[eNewFile].bNegated ){
            pInfo->ptCreateNewFile.dwAutoMode = PLA_AUTO_MODE_NONE;
        }else{
            DWORD dwSeconds = Commands[eNewFile].stValue.wSecond;
            dwSeconds += Commands[eNewFile].stValue.wMinute * 60;
            dwSeconds += Commands[eNewFile].stValue.wHour * 3600;

            if( dwSeconds == 0 ){
                pInfo->ptCreateNewFile.dwAutoMode = PLA_AUTO_MODE_SIZE;
            }else{
                pInfo->ptCreateNewFile.dwAutoMode = PLA_AUTO_MODE_AFTER;
                pInfo->ptCreateNewFile.dwUnitType = PLA_TT_UTYPE_SECONDS;
                pInfo->ptCreateNewFile.dwValue = dwSeconds;
            }
        }
    }

    if( Commands[eUser].bDefined ){
        pInfo->dwMask |= PLA_INFO_FLAG_USER;
        if( Commands[eUser].bNegated ){
            pInfo->strUser = _T("");
            pInfo->strPassword = _T("");
        }else{
            pInfo->strUser = g_strUser;
            pInfo->strPassword = g_strPassword;
        }
    }
               
    if(Commands[eBegin].bDefined){
        FILETIME ft;
        pInfo->dwMask |= PLA_INFO_FLAG_BEGIN;

        SystemTimeToFileTime( &Commands[eBegin].stValue, &ft );
        
        pInfo->ptLogBeginTime.wTimeType = PLA_TT_TTYPE_START;
        pInfo->ptLogBeginTime.wDataType = PLA_TT_DTYPE_DATETIME;
        pInfo->ptLogBeginTime.dwAutoMode = PLA_AUTO_MODE_AT;
        pInfo->ptLogBeginTime.llDateTime = (((ULONGLONG) ft.dwHighDateTime) << 32) + ft.dwLowDateTime;
    }

    if(Commands[eEnd].bDefined){
        FILETIME ft;
        pInfo->dwMask |= PLA_INFO_FLAG_END;

        SystemTimeToFileTime( &Commands[eEnd].stValue, &ft );
        
        pInfo->ptLogEndTime.wTimeType = PLA_TT_TTYPE_STOP;
        pInfo->ptLogEndTime.wDataType = PLA_TT_DTYPE_DATETIME;
        pInfo->ptLogEndTime.dwAutoMode = PLA_AUTO_MODE_AT;
        pInfo->ptLogEndTime.llDateTime = (((ULONGLONG) ft.dwHighDateTime) << 32) + ft.dwLowDateTime;
    }

cleanup:
    return dwStatus;
}

DWORD
GetFileFormat( LPTSTR str, LPDWORD pdwFormat )
{
    *pdwFormat = PLA_BIN_FILE;
    LPTSTR strCmp = str;

    if( strCmp != NULL ){
        if( *strCmp == _T('.') ){
            strCmp++;
        }
        if( !_tcsicmp( strCmp, _T("TSV")) ){
            *pdwFormat = PLA_TSV_FILE;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( strCmp, _T("CSV")) ){
            *pdwFormat = PLA_CSV_FILE;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( strCmp, _T("BLG")) ){
            *pdwFormat = PLA_BIN_FILE;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( strCmp, _T("BIN")) ){
            *pdwFormat = PLA_BIN_FILE;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( strCmp, _T("BINCIRC")) ){
            *pdwFormat = PLA_BIN_CIRC_FILE;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( strCmp, _T("SQL")) ){
            *pdwFormat = PLA_SQL_LOG;
            return ERROR_SUCCESS;
        }
    }

    return LOGMAN_ERROR_FILEFORMAT;
}

PDH_STATUS 
QueryCollection( LPTSTR strCollection, BOOL bHeader )
{
    PDH_STATUS pdhStatus;
    PDH_PLA_INFO  info;
    DWORD dwInfoSize = sizeof( PDH_PLA_INFO );

    TCHAR strType[MAXSTR];
    TCHAR strStatus[MAXSTR];

    if( bHeader ){
        PrintMessage( g_normal, IDS_MESSAGE_QUERY );
        for(int i=0;i<79;i++){ varg_printf( g_normal, _T("-") ); }
        varg_printf( g_normal, _T("\n") );
    }

    info.dwMask = PLA_INFO_FLAG_TYPE|PLA_INFO_FLAG_STATUS;
    pdhStatus = PdhPlaGetInfoW( strCollection, Commands[eComputer].strValue, &dwInfoSize, &info );
    
    if( ERROR_SUCCESS == pdhStatus ){
        switch( info.dwType ){
        case PLA_COUNTER_LOG:
            LoadString( NULL, IDS_MESSAGE_PERF, strType, MAXSTR );
            break;
        case PLA_TRACE_LOG:
            LoadString( NULL, IDS_MESSAGE_EVENTTRACE, strType, MAXSTR );
            break;
        case PLA_ALERT:
            LoadString( NULL, IDS_MESSAGE_ALERT, strType, MAXSTR );
            break;
        }
        switch( info.dwStatus ){
        case PLA_QUERY_STOPPED: 
            LoadString( NULL, IDS_MESSAGE_STOPPED, strStatus, MAXSTR );
            break;
        case PLA_QUERY_RUNNING:
            LoadString( NULL, IDS_MESSAGE_RUNNING, strStatus, MAXSTR );
            break;
        case PLA_QUERY_START_PENDING:
        default:
            LoadString( NULL, IDS_MESSAGE_PENDING, strStatus, MAXSTR );
            break;
        }
        PrintMessage( g_normal, IDS_MESSAGE_QUERYF, strCollection, strType, strStatus );
    }
    
    return pdhStatus;
}

PDH_STATUS 
QuerySingleCollection( LPTSTR strCollection )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    PPDH_PLA_INFO  pInfo = NULL;
    DWORD dwInfoSize = 0;
    TCHAR buffer[MAXSTR];

    pdhStatus = PdhPlaGetInfoW( strCollection, Commands[eComputer].strValue, &dwInfoSize, pInfo );
    if( ERROR_SUCCESS == pdhStatus ){
        pInfo = (PPDH_PLA_INFO)VARG_ALLOC(dwInfoSize);
        if( NULL != pInfo ){
            pInfo->dwMask = PLA_INFO_FLAG_ALL;
            pdhStatus = PdhPlaGetInfoW( strCollection, Commands[eComputer].strValue, &dwInfoSize, pInfo );

            if( pdhStatus == ERROR_SUCCESS ){
                varg_printf( g_normal, _T("\n") );
                PrintMessage( g_normal, IDS_MESSAGE_NAME, strCollection );
                switch( pInfo->dwType ){
                case PLA_COUNTER_LOG: 
                    LoadString( NULL, IDS_MESSAGE_PERF, buffer, MAXSTR );
                    break;
                case PLA_TRACE_LOG:
                    LoadString( NULL, IDS_MESSAGE_EVENTTRACE, buffer, MAXSTR );
                    break;
                case PLA_ALERT:
                    LoadString( NULL, IDS_MESSAGE_ALERT, buffer, MAXSTR );
                    break;
                default:
                    buffer[0] = _T('\0');
                }
                PrintMessage( g_normal, IDS_MESSAGE_TYPE, buffer );

                switch( pInfo->dwStatus ){
                case PLA_QUERY_STOPPED: 
                    LoadString( NULL, IDS_MESSAGE_STOPPED, buffer, MAXSTR );
                    break;
                case PLA_QUERY_RUNNING:
                    LoadString( NULL, IDS_MESSAGE_RUNNING, buffer, MAXSTR );
                    break;
                case PLA_QUERY_START_PENDING:
                default:
                    LoadString( NULL, IDS_MESSAGE_PENDING, buffer, MAXSTR );
                    break;
                }
                PrintMessage( g_normal, IDS_MESSAGE_STATUS, buffer );
                
                DWORD dwStart;
                DWORD dwStop;
                PDH_TIME_INFO TimeInfo;
                pdhStatus = PdhPlaGetScheduleW( strCollection, Commands[eComputer].strValue, &dwStart, &dwStop, &TimeInfo );

                if( ERROR_SUCCESS == pdhStatus ){
                    LoadString( NULL, IDS_MESSAGE_MANUAL, buffer, MAXSTR );
                    PrintMessage( g_normal, IDS_MESSAGE_START );
                    switch( dwStart ){
                    
                    case PLA_AUTO_MODE_NONE:
                        varg_printf( g_normal, buffer );
                        break;
                    case PLA_AUTO_MODE_CALENDAR:
                    case PLA_AUTO_MODE_AT:
                        {
                            SYSTEMTIME st;
                            FILETIME ft;
                            ft.dwLowDateTime  = (DWORD) (TimeInfo.StartTime & 0xFFFFFFFF );
                            ft.dwHighDateTime = (DWORD) (TimeInfo.StartTime >> 32 );
                            FileTimeToSystemTime( &ft, &st );
                            PrintDate( &st );
                            if( dwStart == PLA_AUTO_MODE_CALENDAR ){
                                PrintMessage( g_normal, IDS_MESSAGE_REPEATING );
                            }
                        }
                    }
                    varg_printf( g_normal, _T("\n") );
                
                    PrintMessage( g_normal, IDS_MESSAGE_STOP );
                    switch( dwStop ){
                    case PLA_AUTO_MODE_NONE:
                        varg_printf( g_normal, buffer );
                        break;
                    case PLA_AUTO_MODE_AT:
                        {
                            SYSTEMTIME st;
                            FILETIME ft;
                            ft.dwLowDateTime  = (DWORD) (TimeInfo.EndTime & 0xFFFFFFFF );
                            ft.dwHighDateTime = (DWORD) (TimeInfo.EndTime >> 32 );

                            FileTimeToSystemTime( &ft, &st );
                            PrintDate( &st );
                        }
                        break;
                    case PLA_AUTO_MODE_AFTER:
                        {
                            SYSTEMTIME st;
                            LONGLONG llMS;
                            ZeroMemory( &st, sizeof(SYSTEMTIME) );
                            PlaTimeInfoToMilliSeconds( &pInfo->ptLogEndTime, &llMS );
                            llMS /= 1000;
                        
                            st.wHour = (USHORT)(llMS / 3600);
                            st.wMinute = (USHORT)((llMS%3600) / 60);
                            st.wSecond = (USHORT)((llMS % 60) % 3600);

                            PrintMessage( g_normal, IDS_MESSAGE_AFTER );
                            PrintDate( &st );
                        }
                    }
                    varg_printf( g_normal, _T("\n") );
                }
                if( pInfo->dwMask & PLA_INFO_FLAG_CRTNEWFILE ){
                    if( pInfo->ptCreateNewFile.dwAutoMode == PLA_AUTO_MODE_SIZE ){
                        PrintMessage( g_normal, IDS_MESSAGE_NEWFILE );
                        PrintMessage( g_normal, IDS_MESSAGE_BYSIZE );
                    }else if( pInfo->ptCreateNewFile.dwAutoMode == PLA_AUTO_MODE_AFTER ){
                        SYSTEMTIME st;
                        LONGLONG llMS;
                        ZeroMemory( &st, sizeof(SYSTEMTIME) );
                        PlaTimeInfoToMilliSeconds( &pInfo->ptCreateNewFile, &llMS );
                        llMS /= 1000;
                    
                        st.wHour = (USHORT)(llMS / 3600);
                        st.wMinute = (USHORT)((llMS%3600) / 60);
                        st.wSecond = (USHORT)((llMS % 60) % 3600);

                        PrintMessage( g_normal, IDS_MESSAGE_NEWFILE );
                        PrintMessage( g_normal, IDS_MESSAGE_AFTER );
                        PrintDate( &st );
                        varg_printf( g_normal, _T("\n") );
                    }
                }
                dwInfoSize = MAXSTR;
                pdhStatus = PdhPlaGetLogFileNameW( strCollection, Commands[eComputer].strValue, pInfo, 0, &dwInfoSize, buffer );
                if( pdhStatus != ERROR_SUCCESS ){
                    LoadString( NULL, IDS_MESSAGE_BADPARAM, buffer, MAXSTR );
                    pdhStatus = ERROR_SUCCESS;
                }
                PrintMessage( g_normal, IDS_MESSAGE_FILE, buffer );
                PrintMessage( g_normal, IDS_MESSAGE_RUNAS, pInfo->strUser ? pInfo->strUser : _T("")  );
                
                switch( pInfo->dwType ){
                case PLA_COUNTER_LOG: 
                    {
                        LPTSTR strCounter;
                        PrintMessage( g_normal, IDS_MESSAGE_COUNTERS );
                        strCounter = pInfo->Perf.piCounterList.strCounters;
                        if( NULL != strCounter ){
                            if( PRIMARYLANGID( GetUserDefaultUILanguage()) == LANG_ENGLISH ){
                                while( *strCounter != _T('\0') ){
                                    varg_printf( g_normal, _T("   %1!s!\n"), strCounter );
                                    strCounter += (_tcslen(strCounter)+1);
                                }
                            }else{
                                LPTSTR strLocale = NULL;
                                DWORD dwSize = MAX_PATH;
                                strLocale = (LPTSTR)VARG_ALLOC(dwSize*sizeof(TCHAR));
                                if( NULL != strLocale ){
                                    while( *strCounter != _T('\0') ){
                                        pdhStatus = PdhTranslateLocaleCounter( strCounter, strLocale, &dwSize );
                                        if( PDH_MORE_DATA == pdhStatus ){
                                            LPTSTR strMem = (LPTSTR)VARG_REALLOC( strLocale, (dwSize*sizeof(TCHAR)) );
                                            if( NULL != strMem ){
                                                strLocale = strMem;
                                            }else{
                                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                                VARG_FREE(strLocale);
                                                break;
                                            }
                                        }else if( ERROR_SUCCESS == pdhStatus ){
                                            varg_printf( g_normal, _T("   %1!s!\n"), strLocale );
                                            strCounter += (_tcslen(strCounter)+1);
                                        }else{
                                            pdhStatus = ERROR_SUCCESS;
                                            varg_printf( g_normal, _T("   %1!s!\n"), strCounter );
                                            strCounter += (_tcslen(strCounter)+1);
                                        }
                                    }
                                }else{
                                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                }
                            }
                        }
                    }
                    break;
                case PLA_TRACE_LOG:
                    {
                        LPTSTR strProvider;
                        PrintMessage( g_normal, IDS_MESSAGE_LOGGERNAME, pInfo->Trace.strLoggerName );
                        PrintMessage( g_normal, IDS_MESSAGE_BUFFERSIZE, pInfo->Trace.dwBufferSize );

                        PrintMessage( g_normal, IDS_MESSAGE_PROVIDERS );
                        
                        strProvider = pInfo->Trace.piProviderList.strProviders;
                        if( NULL != strProvider ){
                            while( *strProvider != _T('\0') ){
                                PrintMessage( g_normal, IDS_MESSAGE_PRVGUID, strProvider );
                                strProvider += (_tcslen(strProvider)+1);
                            }
                        }else{
                            StringFromGUID2( SystemTraceControlGuid, buffer, 128 );
                            PrintMessage( g_normal, IDS_MESSAGE_PRVGUID, buffer );
                        }
                    }
                    break;
                case PLA_ALERT:
                    break;
                }
                

            }

            VARG_FREE( pInfo );
        }
    }
    
    varg_printf( g_normal, _T("\n") );

    return pdhStatus;
}

DWORD
SetCredentials( )
{
    DWORD dwStatus = ERROR_SUCCESS;

    LPTSTR strUser = NULL;
    LPTSTR strPassword = NULL;
    TCHAR  buffer[MAXSTR];
    TCHAR  strConnection[MAXSTR];
    
    LoadString( NULL, IDS_MESSAGE_THISCON, strConnection, MAXSTR );

    ZeroMemory( g_strUser, MAXSTR*sizeof(TCHAR) );
    ZeroMemory( g_strPassword, MAXSTR*sizeof(TCHAR) );

    if( Commands[eUser].strValue == NULL || !_tcslen( Commands[eUser].strValue ) ){
        LoadString( NULL, IDS_MESSAGE_EUSER, buffer, MAXSTR );
        varg_printf( g_normal,  
                buffer, 
                Commands[eName].bDefined ? 
                    Commands[eName].strValue : 
                Commands[eComputer].bDefined ? 
                    Commands[eComputer].strValue : 
                strConnection 
            );
        
         GetUserInput( g_strUser, MAXSTR, TRUE );

        strUser = g_strUser;
        strPassword = _T("*");
    }else{
        strUser = Commands[eUser].strValue;
        strPassword = strUser + (_tcslen( strUser ) + 1);
    }

    if( NULL == strPassword ){
        strPassword = _T("");
    }else if( !_tcscmp( _T("*"), strPassword  ) ){
        LoadString( NULL, IDS_MESSAGE_EPASSWORD, buffer, MAXSTR );
        varg_printf( g_normal, buffer,
                Commands[eName].bDefined ? 
                    Commands[eName].strValue : 
                Commands[eComputer].bDefined ? 
                    Commands[eComputer].strValue : 
                strConnection
            );

        GetUserInput( buffer, MAXSTR, FALSE );

        strPassword = buffer;
    }

    _tcscpy( g_strPassword, strPassword );
    if( strUser != NULL ){
        _tcscpy( g_strUser, strUser );
        strUser = g_strUser;
    }

    TCHAR strUserBuffer[MAXSTR];
    _tcscpy( strUserBuffer, strUser );
    
    LPTSTR strDomain = _tcstok( strUserBuffer, _T("\\") );
    strUser = _tcstok( NULL, _T("") );
    if( strUser == NULL ){
        strUser = strDomain;
        strDomain = NULL;
    }

    if( Commands[eComputer].bDefined ){
        if( _tcslen(Commands[eComputer].strValue) > 2 && Commands[eComputer].strValue[1] == _T('\\') ){
            _stprintf( g_strIPC, _T("%s\\ipc$"), Commands[eComputer].strValue );
        }else{
            _stprintf( g_strIPC, _T("\\\\%s\\ipc$"), Commands[eComputer].strValue );
        }
     
        LPTSTR pNetInfo;

        dwStatus = NetUseGetInfo( NULL, g_strIPC, 0, (LPBYTE*)&pNetInfo );
        if( dwStatus != ERROR_SUCCESS ){
        
            USE_INFO_2 info;
            DWORD dwError;

            ZeroMemory( &info, sizeof(USE_INFO_2) );
            info.ui2_local = NULL;
            info.ui2_remote = g_strIPC;
            info.ui2_password = g_strPassword;
            info.ui2_username = strUser;
            info.ui2_domainname = strDomain;
            info.ui2_asg_type = USE_IPC;

            dwStatus = NetUseAdd (
                    NULL,
                    2,
                    (unsigned char *)&info,
                    &dwError
                );
        }else{
            ZeroMemory( g_strIPC, sizeof(TCHAR) * MAXSTR );
        }
    }

    return dwStatus;
}

DWORD GetCountersFromFile( LPTSTR strFile, PPDH_PLA_ITEM pItem )
{
    TCHAR buffer[MAXSTR];
    LPTSTR strList = NULL;
    LPTSTR strItem = NULL;

    FILE* f = _tfopen( strFile, _T("r") );

    if( !f ){
        return GetLastError();
    }

    pItem->dwType = PLA_COUNTER_LOG;
    pItem->strCounters = NULL;
    
    while( NULL != _fgetts( buffer, MAXSTR, f ) ){

        if( buffer[0] == _T(';') || // comments
            buffer[0] == _T('#') ){
            continue;
        }

        Chomp(buffer);

        strItem = _tcstok( buffer, _T("\"\n") );
        if( strItem != NULL ){
            AddStringToMsz( &strList, strItem );
        }
    }

    fclose( f );

    pItem->strCounters = strList;

    return ERROR_SUCCESS;
}

BOOL IsStrGuid( LPTSTR str ){

    if( _tcslen( str ) < 38 ){
        return FALSE;
    }

    if( str[0] == _T('{') &&
        str[9] == _T('-') &&
        str[14] == _T('-') &&
        str[19] == _T('-') &&
        str[24] == _T('-') &&
        str[37] == _T('}')
        ){

        return TRUE;
    }

    return FALSE;
}

HRESULT GetProviders( PPDH_PLA_ITEM pItem )
{
    HRESULT hr = ERROR_SUCCESS;

    TCHAR buffer[MAXSTR];
    LPTSTR strLine = NULL;
    LPTSTR strItem = NULL;
    LPTSTR strLevel;
    LPTSTR strFlags;
    
    PPROVIDER_REC pProviderHead = NULL;
    PPROVIDER_REC pProvider;
    
    FILE* f = NULL;

    if( Commands[eProviderFile].bDefined ){

        f = _tfopen( Commands[eProviderFile].strValue, _T("r") );

        if( !f ){
            return GetLastError();
        }

        strLine = _fgetts( buffer, MAXSTR, f );

        Chomp(buffer);

    }else if( Commands[eProviders].bDefined ){
        strLine = Commands[eProviders].strValue;
    }
    
    while( NULL != strLine ){

        strItem = NULL;
        strFlags = NULL;
        strLevel = NULL;

        if( strLine[0] == _T(';') || // comments
            strLine[0] == _T('#') ){
            continue;
        }
        
        if( Commands[eProviderFile].bDefined ){
            strItem = _tcstok( buffer, _T("\"\n\t ") );
            strFlags = _tcstok( NULL, _T("\n\t ") );
            strLevel = _tcstok( NULL, _T("\n\t ") );
        }else if( Commands[eProviders].bDefined ){
            strItem = strLine;
            if( *strItem != _T('\0') ){
                strFlags = strItem + (_tcslen(strItem)+1);
                if( *strFlags != _T('\0') ){
                    strLevel = strFlags + (_tcslen(strFlags)+1);
                    if( IsEmpty( strLevel ) ){
                        strLevel = NULL;
                    }
                }else{
                    strFlags = NULL;
                }
            }else{
                strItem = NULL;
            }
        }
        
        if( strItem != NULL ){
            pProvider = (PPROVIDER_REC)VARG_ALLOC( sizeof(PROVIDER_REC) );
            if( NULL != pProvider ){
                LPTSTR strZero = _T("0");
                ZeroMemory( pProvider, sizeof(PROVIDER_REC) );
                if( pProviderHead == NULL ){
                    pProviderHead = pProvider;
                }else{
                    pProviderHead->blink = pProvider;
                    pProvider->flink = pProviderHead;
                    pProviderHead = pProvider;
                }
                
                if( IsStrGuid( strItem ) ){
                    ASSIGN_STRING( pProvider->strProviderGuid, strItem );
                }else{
                    ASSIGN_STRING( pProvider->strProviderName, strItem );
                }

                if( strFlags != NULL ){
                    ASSIGN_STRING( pProvider->strFlags, strFlags );
                }else{
                    ASSIGN_STRING( pProvider->strFlags, strZero );
                }

                if( strLevel != NULL ){
                    ASSIGN_STRING( pProvider->strLevel, strLevel );
                }else{
                    ASSIGN_STRING( pProvider->strLevel, strZero );
                }
            }
        }
        if( Commands[eProviderFile].bDefined ){

            strLine = _fgetts( buffer, MAXSTR, f );
            Chomp(buffer);

        }else if( Commands[eProviders].bDefined ){
            break;
        }

    }

    if( NULL != f ){
        fclose( f );
    }

    hr = GetTraceNameToGuidMap( pProviderHead );

    pItem->dwType = PLA_TRACE_LOG;
    pProvider = pProviderHead;
    while( pProvider ){
        hr = AddStringToMsz( &(pItem->strProviders), pProvider->strProviderGuid );
        if( hr != ERROR_SUCCESS ){
            break;
        }
        AddStringToMsz( &(pItem->strLevels), pProvider->strLevel );
        if( hr != ERROR_SUCCESS ){
            break;
        }
        AddStringToMsz( &(pItem->strFlags), pProvider->strFlags );
        if( hr != ERROR_SUCCESS ){
            break;
        }
        pProvider = pProvider->flink;
    }
    
    PPROVIDER_REC pDelete;
    pProvider = pProviderHead;
    while( pProvider ){
        pDelete = pProvider;
        pProvider = pProvider->flink;
        VARG_FREE( pDelete->strProviderGuid );
        VARG_FREE( pDelete->strProviderName );
        VARG_FREE( pDelete->strFlags );
        VARG_FREE( pDelete->strLevel );
        VARG_FREE( pDelete );
    }
    
    return hr;
}

BOOL AllProvidersMapped( PPROVIDER_REC pProviders )
{
    PPROVIDER_REC pProvider = pProviders;
    while( pProvider ){
        if( pProvider->strProviderGuid == NULL ){
            return FALSE;
        }
        if( pProvider->strFlags != NULL ){
            if( *(pProvider->strFlags) == _T('(') ){
                return FALSE;
            }
        }
        pProvider = pProvider->flink;
    }
    
    return TRUE;
}

HRESULT 
DecodeFlags( IWbemClassObject *pClass, LPTSTR strFlags, LPDWORD pdwFlags )
{
    HRESULT hr = ERROR_SUCCESS;
    IWbemQualifierSet   *pQualSet = NULL;

    SAFEARRAY* saValues = NULL;
    SAFEARRAY* saValueMap = NULL;
    LONG nFlavor;
    VARIANT var;

    hr = pClass->GetPropertyQualifierSet( L"Flags", &pQualSet );
    if( pQualSet != NULL ){
        hr = pQualSet->Get( L"ValueMap", 0, &var, &nFlavor );
        if( ERROR_SUCCESS == hr && (var.vt & VT_ARRAY) ){
            saValueMap = var.parray;
        }

        hr = pQualSet->Get( L"Values", 0, &var, &nFlavor );
        if( ERROR_SUCCESS == hr && (var.vt & VT_ARRAY) ){
            saValues = var.parray;
        }

        if( saValues != NULL && saValueMap != NULL ){
            BSTR HUGEP *pMapData;
            BSTR HUGEP *pValuesData;
            LONG uMapBound, lMapBound;
            LONG uValuesBound, lValuesBound;

            SafeArrayGetUBound( saValueMap, 1, &uMapBound );
            SafeArrayGetLBound( saValueMap, 1, &lMapBound );
            SafeArrayAccessData( saValueMap, (void HUGEP **)&pMapData );

            SafeArrayGetUBound( saValues, 1, &uValuesBound );
            SafeArrayGetLBound( saValues, 1, &lValuesBound );
            SafeArrayAccessData( saValues, (void HUGEP **)&pValuesData );

            for ( LONG i=lMapBound; i<=uMapBound; i++) {
                LONG dwFlag;

                if( i<lValuesBound || i>uValuesBound ){
                    break;
                }
                dwFlag = hextoi( pMapData[i] );
                if( FindString( strFlags, pValuesData[i] ) ){
                    *pdwFlags |= dwFlag;
                }
            }

            SafeArrayUnaccessData( saValueMap );
            SafeArrayUnaccessData( saValues );

            SafeArrayDestroy( saValueMap );
            SafeArrayDestroy( saValues );

        }

        pQualSet->Release();
    }

    if( hr == WBEM_S_FALSE ){
        hr = ERROR_SUCCESS;
    }

    return hr;
}

HRESULT
SetProviderGuid( PPROVIDER_REC pProviders, IWbemClassObject *pClass, LPTSTR strProvider, LPTSTR strGuid )
{
    PPROVIDER_REC pProvider = pProviders;
    while( pProvider ){

        if( !IsEmpty(pProvider->strProviderGuid) && IsEmpty( pProvider->strProviderName ) ){
            if( !_tcsicmp(pProvider->strProviderGuid, strGuid ) ){
                ASSIGN_STRING( pProvider->strProviderName, strProvider );
                break;
            }
        }else if( IsEmpty(pProvider->strProviderGuid) && !IsEmpty( pProvider->strProviderName ) ){
            if( !_tcsicmp(pProvider->strProviderName, strProvider ) ){
                ASSIGN_STRING( pProvider->strProviderGuid, strGuid );
                break;
            }
        }

        pProvider = pProvider->flink;
    }

    if( NULL != pProvider ){
        if( pProvider->strFlags != NULL ){
            if( *(pProvider->strFlags) == _T('(') ){
                DWORD dwFlags = 0;
                TCHAR buffer[MAXSTR];
                
                DecodeFlags( pClass, pProvider->strFlags, &dwFlags );
                
                VARG_FREE( pProvider->strFlags );
                pProvider->strFlags = NULL;

                _stprintf( buffer, _T("0x%08x"), dwFlags );
                ASSIGN_STRING( pProvider->strFlags, buffer );
            }
        }
        return ERROR_SUCCESS;
    }

    return ERROR_PATH_NOT_FOUND;
}

HRESULT
GetTraceNameToGuidMap( PPROVIDER_REC pProviders )
{
    HRESULT hr;
    IWbemServices*  pIWbemServices = NULL;
    IEnumWbemClassObject *pEnumProviders = NULL;

    if( pProviders != NULL && AllProvidersMapped( pProviders ) ){
        return ERROR_SUCCESS;
    }

    BSTR bszTraceClass = SysAllocString( L"EventTrace" );
    BSTR bszDescription = SysAllocString( L"Description" );
    BSTR bszGuid = SysAllocString( L"Guid" );

    IWbemQualifierSet   *pQualSet = NULL;
    IWbemClassObject    *pClass = NULL;
    VARIANT vDiscription;
    VARIANT vGuid;
    ULONG nReturned;

    hr = WbemConnect( &pIWbemServices );
    CHECK_STATUS( hr );

    hr = pIWbemServices->CreateClassEnum (
            bszTraceClass,
            WBEM_FLAG_SHALLOW|WBEM_FLAG_USE_AMENDED_QUALIFIERS,
            NULL,
            &pEnumProviders 
        );
    CHECK_STATUS( hr );

    if( pProviders == NULL ){
        PrintMessage( g_normal, IDS_MESSAGE_QUERYP );
        for( int i=0;i<79;i++){ varg_printf( g_normal, _T("-") );}
        varg_printf( g_normal, _T("\n") );
    }
    while( ERROR_SUCCESS == hr ){
        if( pProviders != NULL && AllProvidersMapped( pProviders ) ){
            break;
        }
        
        hr = pEnumProviders->Next( (-1), 1, &pClass, &nReturned );
        
        if( ERROR_SUCCESS == hr ){
            pClass->GetQualifierSet ( &pQualSet );
            if ( pQualSet != NULL ) {
                
                hr = pQualSet->Get ( bszDescription, 0, &vDiscription, 0 );
                if( ERROR_SUCCESS == hr ){
                    hr = pQualSet->Get ( bszGuid, 0, &vGuid, 0 );
                    if( ERROR_SUCCESS == hr ){
                        if( pProviders != NULL ){
                            SetProviderGuid( pProviders, pClass, vDiscription.bstrVal, vGuid.bstrVal );
                        }else{
                            varg_printf( g_normal, _T("%1!-40s! %2!-38s!\n"), vDiscription.bstrVal, vGuid.bstrVal );
                        }
                    }
                }
            }
        }
    }
    
    if( NULL == pProviders ){
        varg_printf( g_normal, _T("\n") );
    }

    if( hr == WBEM_S_FALSE ){
        hr = ERROR_SUCCESS;
    }

cleanup:
    SysFreeString( bszTraceClass );
    SysFreeString( bszDescription );
    SysFreeString( bszGuid );

    if (pIWbemServices){ 
        pIWbemServices->Release(); 
    }

    return hr;
}

PDH_STATUS
ScheduleLog()
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    PDH_TIME_INFO info;

    if( Commands[eRunFor].bDefined){
        
        DWORD dwSeconds = Commands[eRunFor].stValue.wSecond;
    
        ZeroMemory( &info, sizeof(PDH_TIME_INFO) );
        
        dwSeconds += Commands[eRunFor].stValue.wMinute * 60;
        dwSeconds += Commands[eRunFor].stValue.wHour * 3600;
        info.EndTime = dwSeconds;
        info.SampleCount = PLA_TT_UTYPE_SECONDS;

        pdhStatus = PdhPlaSchedule( 
                Commands[eName].strValue, 
                Commands[eComputer].strValue, 
                PLA_AUTO_MODE_AFTER, 
                &info 
            );

    }
    
    if( ERROR_SUCCESS == pdhStatus && Commands[eManual].bDefined ){

        LPTSTR strManual = Commands[eManual].strValue;
    
        ZeroMemory( &info, sizeof(PDH_TIME_INFO) );

        while( strManual != NULL && *strManual != _T('\0') ){
            if( !_tcsicmp( strManual, _T("start")) ){
                info.StartTime = 1;
            }
            if( !_tcsicmp( strManual,_T("stop")) ){
                info.EndTime = 1;
            }
            strManual += (_tcslen( strManual )+1);
        }

        pdhStatus = PdhPlaSchedule( 
                Commands[eName].strValue, 
                Commands[eComputer].strValue, 
                PLA_AUTO_MODE_NONE, 
                &info 
            );

    }
    
    return pdhStatus;
}

HRESULT
WbemConnect( IWbemServices** pWbemServices )
{
    WCHAR buffer[MAXSTR];
    IWbemLocator     *pLocator = NULL;

    BSTR bszNamespace = NULL;

    if( Commands[eComputer].bDefined ){
        _stprintf( buffer, _T("\\\\%s\\%s"), Commands[eComputer].strValue, L"root\\wmi" );
        bszNamespace = SysAllocString( buffer );
    }else{
        bszNamespace = SysAllocString( L"root\\wmi" );
    }

    HRESULT hr = CoInitialize(0);
    hr = CoCreateInstance(
                CLSID_WbemLocator, 
                0, 
                CLSCTX_INPROC_SERVER,
                IID_IWbemLocator, 
                (LPVOID *) &pLocator
            );
    CHECK_STATUS( hr );

    if( Commands[eUser].bDefined ){
        hr = pLocator->ConnectServer(
                bszNamespace,
                g_strUser, 
                g_strPassword, 
                NULL, 
                0L,
                NULL,
                NULL,
                pWbemServices
            );
    }else{
        hr = pLocator->ConnectServer(
                bszNamespace,
                NULL, 
                NULL, 
                NULL, 
                0L,
                NULL,
                NULL,
                pWbemServices
            );
    }
    CHECK_STATUS( hr );

    hr = CoSetProxyBlanket(
            *pWbemServices,               
            RPC_C_AUTHN_WINNT,
            RPC_C_AUTHZ_NONE,
            NULL,
            RPC_C_AUTHN_LEVEL_PKT,
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, 
            EOAC_NONE
        );                     

   
cleanup:
    SysFreeString( bszNamespace );

    if( pLocator ){
        pLocator->Release();    
    }
    
    return hr;
}

HRESULT
EtsQuerySession( IWbemServices *pWbemService, LPTSTR strSession )
{
    HRESULT hr = ERROR_SUCCESS;
    IEnumWbemClassObject* pEnumClass = NULL;
    IWbemClassObject* pClass = NULL;
    IWbemQualifierSet   *pQualSet = NULL;
    TCHAR buffer[MAXSTR];

    BSTR bszClass = SysAllocString( L"TraceLogger" );

    varg_printf( g_normal, _T("\n") );
    if( NULL == strSession ){
        PrintMessage( g_normal, IDS_MESSAGE_ETSQUERY );
        for(int i=0;i<79;i++){ varg_printf( g_normal, _T("-") ); }
        varg_printf( g_normal, _T("\n") );
    }

    hr = pWbemService->CreateInstanceEnum( bszClass, WBEM_FLAG_SHALLOW, NULL, &pEnumClass );
    CHECK_STATUS( hr );

    while ( hr == ERROR_SUCCESS ){
        ULONG nObjects;

        hr = pEnumClass->Next( WBEM_INFINITE, 1, &pClass, &nObjects );
        if( hr == ERROR_SUCCESS ){
            
            VARIANT vValue;
            CIMTYPE vtType;
            LONG nFlavor;

            pClass->Get( L"Name", 0, &vValue, &vtType, &nFlavor );

            if( NULL == strSession ){
                VARIANT vLogger;
                VARIANT vFile;

                pClass->Get( L"LoggerId", 0, &vLogger, &vtType, &nFlavor );
                pClass->Get( L"LogFileName", 0, &vFile, &vtType, &nFlavor );
                
                hr = VariantChangeType( &vLogger, &vLogger, 0, VT_BSTR );
                if( ERROR_SUCCESS == hr ){
                    PrintMessage( g_normal, IDS_MESSAGE_ETSQUERYF, vValue.bstrVal, vLogger.bstrVal, vFile.bstrVal); 
                }

            }else{
                if( _tcsicmp( strSession, vValue.bstrVal ) == 0 ){
                    LoadString( NULL, IDS_MESSAGE_ETSNAME, buffer, MAXSTR );
                    PrintMessage( g_normal, IDS_MESSAGE_ETSQUERYSF, buffer, vValue.bstrVal );
                }else{
                    continue;
                }
                BSTR HUGEP  *pData;

                SAFEARRAY* saProperties;
                LONG uBound, lBound;
                vValue.boolVal = TRUE;
                vValue.vt = VT_BOOL;
                
                hr = pClass->GetNames( L"DisplayName", WBEM_FLAG_ONLY_IF_TRUE, 0, &saProperties );
                if( hr == ERROR_SUCCESS && saProperties != NULL ){
                    SafeArrayGetUBound( saProperties, 1, &uBound );
                    SafeArrayGetLBound( saProperties, 1, &lBound );
                    SafeArrayAccessData( saProperties, (void HUGEP **)&pData );
                    for( LONG i=lBound;i<=uBound;i++){
                        VARIANT vLabel;
                        pClass->GetPropertyQualifierSet( pData[i], &pQualSet );
                        pQualSet->Get( L"DisplayName", 0, &vLabel, &nFlavor );
                        _stprintf( buffer, _T("%s:"), vLabel.bstrVal );
                        pClass->Get( pData[i], 0, &vValue, &vtType, &nFlavor );
                        hr = VariantChangeType( &vValue, &vValue, 0, VT_BSTR );
                        if( SUCCEEDED(hr) ){
                            PrintMessage( g_normal, IDS_MESSAGE_ETSQUERYSF, buffer, vValue.bstrVal );   
                        }
                        VariantClear( &vValue );
                        VariantClear( &vLabel );
                    }
                    SafeArrayUnaccessData( saProperties );
                    SafeArrayDestroy( saProperties );
                }
                hr = pClass->Get( L"Guid", 0, &vValue, &vtType, &nFlavor );
                if( ERROR_SUCCESS == hr && VT_NULL != vValue.vt ){
                    saProperties = vValue.parray;
                    SafeArrayGetUBound( saProperties, 1, &uBound );
                    SafeArrayGetLBound( saProperties, 1, &lBound );
                    SafeArrayAccessData( saProperties, (void HUGEP **)&pData );
                    PrintMessage( g_normal, IDS_MESSAGE_PROVIDERS );
                    for( LONG i=lBound;i<=uBound;i++){
                        PrintMessage( g_normal, IDS_MESSAGE_PRVGUID, pData[i] );
                    }

                }
            }
        }
    }
    if( hr == WBEM_S_FALSE ){
        hr = ERROR_SUCCESS;
    }
    varg_printf( g_normal, _T("\n") );

cleanup:

    SysFreeString( bszClass );

    return hr;
}

#define  FIRST_MODE( b ) if( !b ){wcscat( buffer, L"|" );}else{b=FALSE;}

HRESULT
EtsSetSession( IWbemServices* pWbemService, IWbemClassObject* pTrace )
{
    HRESULT hr = ERROR_SUCCESS;
    VARIANT var;
    WCHAR buffer[MAXSTR];
    BOOL bFirst;

    if( Commands[eOutput].bDefined ){
        
        TCHAR full[MAXSTR];
        _tfullpath( full, Commands[eOutput].strValue, MAXSTR );

        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString( full );
        hr = pTrace->Put( L"LogFileName", 0, &var, 0);
        VariantClear(&var);
        CHECK_STATUS( hr );
    }else if( !Commands[eRealTime].bDefined ){
        TCHAR full[MAXSTR];
        LPTSTR strPath = (LPTSTR)VARG_ALLOC( (_tcslen( Commands[eName].strValue )+6) * sizeof(TCHAR) );
        if( NULL != strPath ){
            _tcscpy( strPath, Commands[eName].strValue );
            _tcscat( strPath, _T(".etl") );

            _tfullpath( full, strPath, MAXSTR );

            var.vt = VT_BSTR;
            var.bstrVal = SysAllocString( full );
            hr = pTrace->Put( L"LogFileName", 0, &var, 0);
            VariantClear(&var);
            VARG_FREE( strPath );
            CHECK_STATUS( hr );
        }else{
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }
    
    if( Commands[eBufferSize].bDefined ){
        var.vt = VT_I4;
        var.lVal = Commands[eBufferSize].nValue;
        hr = pTrace->Put( L"BufferSize", 0, &var, 0);
        VariantClear(&var);
        CHECK_STATUS( hr );
    }

    if( Commands[eBuffers].bDefined ){
        LPTSTR strMin;
        LPTSTR strMax;
        var.vt = VT_I4;

        strMin = Commands[eBuffers].strValue;
        
        if( NULL != strMin ){
            var.lVal = _ttoi( strMin );
            hr = pTrace->Put( L"MinimumBuffers", 0, &var, 0);
            CHECK_STATUS( hr );
    
            strMax = strMin + (_tcslen( strMin )+1);
            if( *strMax != _T('\0') ){
                var.lVal = _ttoi( strMax );
                hr = pTrace->Put( L"MaximumBuffers", 0, &var, 0);
                CHECK_STATUS( hr );
            }
        }
    }

    if( Commands[eMax].bDefined ){
        var.vt = VT_I4;
        var.lVal = Commands[eMax].nValue;
        hr = pTrace->Put( L"MaximumFileSize", 0, &var, 0);
        VariantClear(&var);
        CHECK_STATUS( hr );
    }

    buffer[0] = L'\0';
    var.vt = VT_BSTR;
    bFirst = TRUE;

    if( Commands[eFormat].bDefined || Commands[eAppend].bDefined ){
        DWORD dwFormat = 0;
        hr = GetFileFormat( Commands[eFormat].strValue, &dwFormat );
        switch(dwFormat){
        case PLA_BIN_CIRC_FILE:
            FIRST_MODE( bFirst );
            wcscpy( buffer, L"Circular" );
            break;
        case PLA_BIN_FILE:
        default:
            FIRST_MODE( bFirst );
            wcscpy( buffer, L"Sequential" );
        }
    }
    if( Commands[eAppend].bDefined ){
        FIRST_MODE( bFirst );
        wcscat( buffer, L"Append" );
    }
    if( Commands[eRealTime].bDefined ){
        FIRST_MODE( bFirst );
        wcscat( buffer, L"RealTime" );
    }
    if( Commands[eUserMode].bDefined ){
        FIRST_MODE( bFirst );
        wcscat( buffer, L"Private" );
    }
    if( Commands[eMode].bDefined && Commands[eMode].strValue != NULL ){
        LPTSTR strMode = Commands[eMode].strValue;
        while( *strMode != _T('\0') ){
            if( (wcslen( buffer ) + wcslen( strMode ) + 2) > MAXSTR ){
                break;
            }
            FIRST_MODE( bFirst );
            wcscat( buffer, strMode );
            strMode += (wcslen(strMode)+1);
        }
    }
    var.bstrVal = SysAllocString( buffer );
    hr = pTrace->Put( L"LogFileMode", 0, &var, 0);
    VariantClear( &var );
    CHECK_STATUS( hr );

    if( Commands[eFlushTimer].bDefined ){
        
        DWORD dwSeconds;
        dwSeconds = Commands[eFlushTimer].stValue.wSecond;
        dwSeconds += Commands[eFlushTimer].stValue.wMinute * 60;
        dwSeconds += Commands[eFlushTimer].stValue.wHour * 3600;

        var.vt = VT_I4;
        var.lVal = dwSeconds;

        hr = pTrace->Put( L"FlushTimer", 0, &var, 0);
        
        VariantClear(&var);
        CHECK_STATUS( hr );
    }

    if( Commands[eAgeLimit].bDefined ){
        
        var.vt = VT_I4;
        var.lVal = Commands[eAgeLimit].nValue;

        hr = pTrace->Put( L"AgeLimit", 0, &var, 0);
        
        VariantClear(&var);
        CHECK_STATUS( hr );
    }

    if( !Commands[eProviders].bDefined && !Commands[eProviderFile].bDefined ){

        if( _tcsicmp( Commands[eName].strValue, NT_KERNEL_LOGGER ) == 0 ){
        
            LoadString( NULL, IDS_DEFAULT_ETSENABLE, buffer, MAXSTR );
            Commands[eProviders].bDefined = TRUE;
            ASSIGN_STRING( Commands[eProviders].strValue, NT_KERNEL_GUID );
            AddStringToMsz( &Commands[eProviders].strValue, buffer );
        }
    }

    if( Commands[eProviders].bDefined || Commands[eProviderFile].bDefined ){
        PDH_PLA_ITEM providers;
        
        LPTSTR strGuid;
        LPTSTR strLevel;
        LPTSTR strFlags;
        long dwCount = 0;

        ZeroMemory( &providers, sizeof(PDH_PLA_ITEM) );

        hr = GetProviders( &providers );
        CHECK_STATUS( hr );
        
        strGuid = providers.strProviders;
        strLevel = providers.strLevels;
        strFlags = providers.strFlags;

        if( strGuid != NULL ){
            SAFEARRAY* saGuids;
            SAFEARRAY* saLevel;
            SAFEARRAY* saFlags;

            while( *strGuid != _T('\0') ){
                strGuid += _tcslen( strGuid )+1;
                dwCount++;
            }
            
            strGuid = providers.strProviders;
            saGuids = SafeArrayCreateVector( VT_BSTR, 0, dwCount );
            saFlags = SafeArrayCreateVector( VT_I4, 0, dwCount );
            saLevel = SafeArrayCreateVector( VT_I4, 0, dwCount );

            if( saGuids == NULL || saFlags == NULL || saLevel == NULL ){
                if( saGuids != NULL ){
                    SafeArrayDestroy( saGuids );
                }
                if( saFlags != NULL ){
                    SafeArrayDestroy( saFlags );
                }
                if( saLevel != NULL ){
                    SafeArrayDestroy( saLevel );
                }
            }else{
                BSTR HUGEP *pGuidData;
                DWORD HUGEP *pLevelData;
                DWORD HUGEP *pFlagData;

                SafeArrayAccessData( saGuids, (void HUGEP **)&pGuidData);
                SafeArrayAccessData( saFlags, (void HUGEP **)&pFlagData);
                SafeArrayAccessData( saLevel, (void HUGEP **)&pLevelData);

                for (long i=dwCount-1; i >=0; i--) {
                    if( strGuid != NULL ){
                        BSTR bszGuid = SysAllocString( strGuid );
                        pGuidData[i] = bszGuid;
                        strGuid += _tcslen( strGuid )+1;
                    }
                    if( strLevel != NULL ){
                        pLevelData[i] = _ttoi( strLevel );
                        strLevel += _tcslen( strLevel )+1;
                    }
                    if( strFlags != NULL ){
                        pFlagData[i] = hextoi( strFlags );
                        strFlags += _tcslen( strFlags )+1;
                    }
                }

                SafeArrayUnaccessData( saGuids );    
                SafeArrayUnaccessData( saFlags );    
                SafeArrayUnaccessData( saLevel );    
                VARIANT vArray;

                vArray.vt = VT_ARRAY|VT_BSTR;
                vArray.parray = saGuids;
                pTrace->Put( L"Guid", 0, &vArray, 0 );

                vArray.vt = VT_ARRAY|VT_I4;
                vArray.parray = saFlags;
                pTrace->Put( L"EnableFlags", 0, &vArray, 0 );

                vArray.vt = VT_ARRAY|VT_I4;
                vArray.parray = saLevel;
                pTrace->Put( L"Level", 0, &vArray, 0 );

                SafeArrayDestroy( saGuids );
                SafeArrayDestroy( saFlags );
                SafeArrayDestroy( saLevel );
            }
        }
    }

cleanup:
    return ERROR_SUCCESS;
}

HRESULT
EtsCallSession( IWbemServices *pWbemService, LPWSTR strFunction )
{
    HRESULT hr;

    WCHAR buffer[MAXSTR];
    IWbemClassObject *pOutInst = NULL;
    IWbemCallResult  *pCallResult = NULL;

    BSTR bszFunction = SysAllocString( strFunction );
    BSTR bszNamespace = NULL;
    BSTR bszInstance = NULL;

    wsprintf( buffer, L"TraceLogger.Name=\"%s\"", Commands[eName].strValue );
    bszInstance = SysAllocString( buffer );

    hr = pWbemService->ExecMethod( bszInstance, bszFunction, 0, NULL, NULL, &pOutInst, &pCallResult );
    CHECK_STATUS( hr );

    if( pCallResult ){
        LONG lResult;
        pCallResult->GetCallStatus( WBEM_INFINITE, &lResult );
        hr = lResult;
    }
    
cleanup:
    SysFreeString( bszInstance );
    SysFreeString( bszFunction );

    if( pCallResult ){
        pCallResult->Release();
    }
    if( pOutInst ){
        pOutInst->Release();
    }
    
    return hr;
}

HRESULT
EtsStartSession(IWbemServices *pWbemService)
{
    HRESULT hr = ERROR_SUCCESS;

    IWbemClassObject * pClass = NULL;
    IWbemClassObject* pNewTrace = NULL;
    IWbemCallResult  *pCallResult = NULL;

    VARIANT var;

    BSTR bszClass = SysAllocString( L"TraceLogger" );
    
    hr = pWbemService->GetObject( bszClass, 0, NULL, &pClass, NULL);
    CHECK_STATUS( hr );

    hr = pClass->SpawnInstance( 0, &pNewTrace );
    CHECK_STATUS( hr );
    
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString( Commands[eName].strValue );
    hr = pNewTrace->Put( L"Name", 0, &var, 0);
    VariantClear(&var);

    hr = EtsSetSession( pWbemService, pNewTrace );
    CHECK_STATUS( hr );
    
    hr = pWbemService->PutInstance( pNewTrace, WBEM_FLAG_CREATE_ONLY, NULL, &pCallResult );
    CHECK_STATUS( hr );
    
    if( pCallResult ){
        LONG lResult;
        pCallResult->GetCallStatus( WBEM_INFINITE, &lResult );
        hr = lResult;
    }
    CHECK_STATUS( hr );

cleanup:
    
    SysFreeString( bszClass );

    if( pCallResult ){
        pCallResult->Release();
    }

    return hr;
}

HRESULT
EtsEnableSession(IWbemServices *pWbemService)
{
    HRESULT hr;

    WCHAR buffer[MAXSTR];
    IWbemClassObject *pOutInst = NULL;
    IWbemCallResult  *pCallResult = NULL;
    IWbemClassObject *pTrace = NULL;

    BSTR bszNamespace = NULL;
    BSTR bszInstance = NULL;

    wsprintf( buffer, L"TraceLogger.Name=\"%s\"", Commands[eName].strValue );
    bszInstance = SysAllocString( buffer );

    hr = pWbemService->GetObject( bszInstance, 0, NULL, &pTrace, NULL);
    CHECK_STATUS( hr );

    hr = EtsSetSession( pWbemService, pTrace );
    CHECK_STATUS( hr );

    hr = pWbemService->PutInstance( pTrace, WBEM_FLAG_UPDATE_ONLY, NULL, &pCallResult );
    CHECK_STATUS( hr );

    if( pCallResult ){
        LONG lResult;
        pCallResult->GetCallStatus( WBEM_INFINITE, &lResult );
        hr = lResult;
    }
    CHECK_STATUS( hr );
    
cleanup:
    SysFreeString( bszInstance );

    if( pCallResult ){
        pCallResult->Release();
    }
    if( pOutInst ){
        pOutInst->Release();
    }
    
    return hr;
}

HRESULT EventTraceSessionControl()
{
    HRESULT hr = ERROR_SUCCESS;
    IWbemServices *pWbemService = NULL;

    hr = WbemConnect( &pWbemService );
    CHECK_STATUS( hr );

    if( Commands[eFlushBuffers].bValue ){
        hr = EtsCallSession( pWbemService, L"FlushTrace" );
    }else if( Commands[eQuery].bDefined ){
        hr = EtsQuerySession( pWbemService, Commands[eName].strValue );
    }else if( Commands[eStart].bDefined || Commands[eCreate].bDefined ){
        hr = EtsStartSession( pWbemService );
        if( SUCCEEDED(hr) ){
            EtsQuerySession( pWbemService, Commands[eName].strValue );
        }
    }else if( Commands[eStop].bDefined || Commands[eDelete].bDefined ){
        hr = EtsCallSession( pWbemService, L"StopTrace" );
    }else if( Commands[eUpdate].bDefined ){
        hr = EtsEnableSession( pWbemService );
    }

cleanup:
    if( pWbemService ){
        pWbemService->Release();
    }

    return hr;
}

HRESULT WbemError( HRESULT hr )
{
    WCHAR szError[MAXSTR] = { NULL };
    WCHAR szFacility[MAXSTR] = { NULL };
    IWbemStatusCodeText * pStatus = NULL;
    
    SCODE sc = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
                                        IID_IWbemStatusCodeText, (LPVOID *) &pStatus);

    if(sc == S_OK){
        BSTR bstr = 0;
        sc = pStatus->GetErrorCodeText(hr, 0, 0, &bstr);
        if(sc == S_OK){
            wcsncpy(szError, bstr, MAXSTR-1);
            SysFreeString(bstr);
            bstr = 0;
        }

        sc = pStatus->GetFacilityCodeText(hr, 0, 0, &bstr);
        if(sc == S_OK){
            wcsncpy(szFacility, bstr, MAXSTR-1);
            SysFreeString(bstr);
            bstr = 0;
        }
        
        pStatus->Release();
    }
 
    if( Commands[eDebug].bDefined ){
        if( _tcscmp( szFacility, L"<Null>" ) == 0 ){
            LoadString( NULL, IDS_MESSAGE_SYSTEM, szFacility, MAXSTR );
        }

        PrintMessage( g_debug, LOGMAN_ERROR_WBEM, hr, szFacility, szError );
    }else{
        PrintMessage( g_debug, IDS_MESSAGE_ERROR );
        varg_printf( g_debug, _T("%1!s!"), szError );
    }

    return ERROR_SUCCESS;
}

void 
ShowValidationError( PDH_STATUS pdhStatus, PPDH_PLA_INFO pInfo )
{
    DWORD dwFlag;
    DWORD dwMask; 
    
    if( SEVERITY( pdhStatus ) == STATUS_SEVERITY_WARNING ){
        dwMask = pInfo->dwReserved2;
    }else{
        dwMask = pInfo->dwMask;
    }

    if( 0 == dwMask ){
        return;
    }

    for( ULONG i=1;i<0x80000000; i*=2 ){
        
        dwFlag = (i & dwMask);
        
        if( 0 == dwFlag ){
            continue;
        }

        switch( SEVERITY( pdhStatus ) ){
        case STATUS_SEVERITY_ERROR:
            PrintMessage( g_debug, IDS_MESSAGE_ERROR );
            break;
        case STATUS_SEVERITY_WARNING:
            PrintMessage( g_debug, IDS_MESSAGE_WARNING );
            break;
        }
    
        switch( dwFlag ){
        case PLA_INFO_FLAG_FORMAT:
            PrintMessage( g_debug, LOGMAN_ERROR_FILEFORMAT, pInfo->dwFileFormat );
            break;
        case PLA_INFO_FLAG_INTERVAL:
            PrintMessage( g_debug, LOGMAN_ERROR_INTERVAL );
            break;
        case PLA_INFO_FLAG_BUFFERSIZE:
            PrintMessage( g_debug, LOGMAN_ERROR_BUFFERSIZE, pInfo->Trace.dwBufferSize );
            break;
        case PLA_INFO_FLAG_MINBUFFERS:
            PrintMessage( g_debug, LOGMAN_ERROR_MINBUFFER, pInfo->Trace.dwMinimumBuffers );
            break;
        case PLA_INFO_FLAG_MAXBUFFERS:
            PrintMessage( g_debug, LOGMAN_ERROR_MAXBUFFER, pInfo->Trace.dwMinimumBuffers );
            break;
        case PLA_INFO_FLAG_FLUSHTIMER:
            PrintMessage( g_debug, LOGMAN_ERROR_FLUSHTIMER, pInfo->Trace.dwFlushTimer );
            break;
        case PLA_INFO_FLAG_MAXLOGSIZE:
            PrintMessage( g_debug, LOGMAN_ERROR_MAXLOGSIZE, pInfo->dwMaxLogSize );
            break;
        case PLA_INFO_FLAG_RUNCOMMAND:
            PrintMessage( g_debug, LOGMAN_ERROR_CMDFILE, pInfo->strCommandFileName );
            break;
        case PLA_INFO_FLAG_FILENAME:
            if( Commands[eOutput].bDefined ){
                PrintMessage( g_debug, LOGMAN_ERROR_FILENAME );
            }else{
                PrintMessage( g_debug, LOGMAN_ERROR_FILENAME_DEFAULT );
            }
            break;
        case PLA_INFO_FLAG_AUTOFORMAT:
            PrintMessage( g_debug, LOGMAN_ERROR_AUTOFORMAT );
            break;
        case PLA_INFO_FLAG_USER:
            PrintMessage( g_debug, LOGMAN_ERROR_USER, pInfo->strUser );
            break;
        case PLA_INFO_FLAG_DATASTORE:
            switch( pInfo->dwDatastoreAttributes & PLA_DATASTORE_APPEND_MASK ){
            case PLA_DATASTORE_APPEND:
                PrintMessage( g_debug, LOGMAN_ERROR_DATASTOREA );
                break;
            case PLA_DATASTORE_OVERWRITE:
                PrintMessage( g_debug, LOGMAN_ERROR_DATASTOREO );
                break;
            }
            break;
        case PLA_INFO_FLAG_MODE:
            PrintMessage( g_debug, LOGMAN_ERROR_TRACEMODE, pInfo->Trace.dwMode );
            break;
        case PLA_INFO_FLAG_LOGGERNAME:
            PrintMessage( g_debug, LOGMAN_ERROR_LOGGERNAME, pInfo->Trace.strLoggerName );
            break;
        case PLA_INFO_FLAG_REPEAT:
            PrintMessage( g_debug, LOGMAN_ERROR_REPEATMODE );
            break;
        case PLA_INFO_FLAG_TYPE:
            PrintMessage( g_debug, LOGMAN_ERROR_COLLTYPE, pInfo->dwType );
            break;
        case PLA_INFO_FLAG_DEFAULTDIR:
        case PLA_INFO_FLAG_PROVIDERS:
            PrintMessage( g_debug, LOGMAN_ERROR_PROVIDER );
            break;
        case PLA_INFO_FLAG_COUNTERS:
            {
                LPTSTR strCounter = pInfo->Perf.piCounterList.strCounters;
                if( strCounter != NULL ){
                    DWORD dwCount = 0;
                    while(*strCounter != _T('\0') ){
                        if( dwCount++ == pInfo->dwReserved1 ){
                            break;
                        }
                        strCounter += (_tcslen( strCounter )+1 );
                    }
                }

                PrintMessage( g_debug, LOGMAN_ERROR_COUNTERPATH, strCounter ? strCounter : _T("") );
            }
            break;
        default:
            PrintMessage( g_debug, LOGMAN_ERROR_UNKNOWN );
        }
    }

    varg_printf( g_debug, _T("\n") );
}

void
PdhError( PDH_STATUS pdhStatus, PPDH_PLA_INFO pInfo )
{
    switch( pdhStatus ){
    case PDH_PLA_VALIDATION_ERROR:
    case PDH_PLA_VALIDATION_WARNING:
        ShowValidationError( pdhStatus, pInfo );
        break;
    case PDH_PLA_COLLECTION_ALREADY_RUNNING:
    case PDH_PLA_COLLECTION_NOT_FOUND:
    case PDH_PLA_ERROR_NOSTART:
    case PDH_PLA_ERROR_ALREADY_EXISTS:
        PrintErrorEx( pdhStatus, PDH_MODULE, Commands[eName].strValue );
        break;
    default:
        PrintErrorEx( pdhStatus, PDH_MODULE );
    }
}

void
LogmanError( DWORD dwStatus )
{
    switch( dwStatus ){
    case LOGMAN_ERROR_FILEFORMAT:
        PrintMessage( g_debug, LOGMAN_ERROR_FILEFORMAT );
        break;
    case LOGMAN_ERROR_LOGON:
        PrintMessage( g_debug, LOGMAN_ERROR_LOGON );
        break;
    default:
        PrintError( dwStatus );
    }
}

ULONG hextoi( LPWSTR s )
{
    long len;
    ULONG num, base, hex;

    if (s == NULL || s[0] == L'\0') {
        return 0;
    }

    len = (long) wcslen(s);

    if (len == 0) {
        return 0;
    }

    hex  = 0;
    base = 1;
    num  = 0;

    while (-- len >= 0) {
        if (s[len] >= L'0' && s[len] <= L'9'){
            num = s[len] - L'0';
        }else if (s[len] >= L'a' && s[len] <= L'f'){
            num = (s[len] - L'a') + 10;
        }else if (s[len] >= L'A' && s[len] <= L'F'){
            num = (s[len] - L'A') + 10;
        }else if( s[len] == L'x' || s[len] == L'X'){
            break;
        }else{
            continue;
        }

        hex += num * base;
        base = base * 16;
    }
    return hex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\resource.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) 1998-2001 Microsoft Corporation

\*****************************************************************************/

#define    IDS_PARAM_COMPUTER       104
#define    IDS_PARAM_CREATE         108
#define    IDS_PARAM_START          109
#define    IDS_PARAM_STOP           112
#define    IDS_PARAM_DELETE         115
#define    IDS_PARAM_QUERY          118
#define    IDS_PARAM_BEGIN          124
#define    IDS_PARAM_END            127
#define    IDS_PARAM_REPEAT         130
#define    IDS_PARAM_NAME           133
#define    IDS_PARAM_OUTPUT         137
#define    IDS_PARAM_FORMAT         140
#define    IDS_PARAM_APPEND         144
#define    IDS_PARAM_VERSION        147
#define    IDS_PARAM_RUNCMD         151
#define    IDS_PARAM_MAX            154
#define    IDS_PARAM_NEWFILE        157
#define    IDS_PARAM_COUNTERS       160
#define    IDS_PARAM_COUNTERFILE    164
#define    IDS_PARAM_SAMPLERATE     167
#define    IDS_PARAM_LOGGERNAME     170
#define    IDS_PARAM_REALTIME       173
#define    IDS_PARAM_PROVIDER       176
#define    IDS_PARAM_PROVIDERFILE   179
#define    IDS_PARAM_USERMODE       182
#define    IDS_PARAM_BUFFERSIZE     185
#define    IDS_PARAM_FLUSHTIMER     188
#define    IDS_PARAM_BUFFERS        191
#define    IDS_PARAM_FLUSHBUFFERS   195
#define    IDS_PARAM_UPDATE         198
#define    IDS_PARAM_USER           202
#define    IDS_PARAM_RUNFOR         206
#define    IDS_PARAM_YES            209
#define    IDS_PARAM_MANUAL         217
#define    IDS_PARAM_ETS            218
#define    IDS_PARAM_AGE            219
#define    IDS_PARAM_MODE           220
#define    IDS_PARAM_COUNTER        221
#define    IDS_PARAM_TRACE          222
#define    IDS_PARAM_QUERYPROV      223

#define    IDS_MESSAGE_QUERY        600
#define    IDS_MESSAGE_QUERYF       601
#define    IDS_MESSAGE_PERF         605
#define    IDS_MESSAGE_EVENTTRACE   606
#define    IDS_MESSAGE_ALERT        607
#define    IDS_MESSAGE_STOPPED      608
#define    IDS_MESSAGE_RUNNING      609
#define    IDS_MESSAGE_PENDING      610
#define    IDS_MESSAGE_STATUS       611
#define    IDS_MESSAGE_NAME         612
#define    IDS_MESSAGE_TYPE         613
#define    IDS_MESSAGE_FILE         614
#define    IDS_MESSAGE_RUNAS        615
#define    IDS_MESSAGE_EUSER        616
#define    IDS_MESSAGE_EPASSWORD    617
#define    IDS_MESSAGE_THISCON      618
#define    IDS_MESSAGE_ETSQUERY     619
#define    IDS_MESSAGE_ETSQUERYF    620
#define    IDS_MESSAGE_ETSQUERYSF   621
#define    IDS_MESSAGE_COUNTERS     622
#define    IDS_MESSAGE_LOGGERNAME   623
#define    IDS_MESSAGE_BUFFERSIZE   624
#define    IDS_MESSAGE_BADPARAM     625
#define    IDS_MESSAGE_START        626
#define    IDS_MESSAGE_STOP         627
#define    IDS_MESSAGE_MANUAL       628
#define    IDS_MESSAGE_AFTER        629
#define    IDS_MESSAGE_REPEATING    630
#define    IDS_MESSAGE_BYSIZE       631
#define    IDS_MESSAGE_NEWFILE      632
#define    IDS_MESSAGE_PRVGUID      633
#define    IDS_MESSAGE_PROVIDERS    634
#define    IDS_MESSAGE_SYSTEM       635
#define    IDS_MESSAGE_QUERYP       636
#define    IDS_MESSAGE_ETSNAME      637

#define    IDS_DEFAULT_OUTPUT       700
#define    IDS_DEFAULT_NNNNN        701
#define    IDS_DEFAULT_ETSENABLE    702

#define    IDS_EXAMPLE_ETS          800
#define    IDS_EXAMPLE_START        801
#define    IDS_EXAMPLE_CREATE       802
#define    IDS_EXAMPLE_UPDATE       803
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\inc\varg.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.
        
\*****************************************************************************/

#ifndef _VARG_H_012599_
#define _VARG_H_012599_

#define MAXSTR                   1024

#define VARG_HELP_ALL            (-1)

#define VARG_TYPE_INT            0
#define VARG_TYPE_BOOL           1
#define VARG_TYPE_STR            2
#define VARG_TYPE_HELP           3
#define VARG_TYPE_DEBUG          4
#define VARG_TYPE_MSZ            5
#define VARG_TYPE_LAST           6
#define VARG_TYPE_INI            7
#define VARG_TYPE_TIME           8
#define VARG_TYPE_DATE           9

#define VARG_FLAG_OPTIONAL       0x00000001
#define VARG_FLAG_REQUIRED       0x00000002
#define VARG_FLAG_DEFAULTABLE    0x00000004
#define VARG_FLAG_NOFLAG         0x00000008
#define VARG_FLAG_HIDDEN         0x00000010
#define VARG_FLAG_VERB           0x00000020
#define VARG_FLAG_EXPANDFILES    0x00000040
#define VARG_FLAG_EXHELP         0x00000080
#define VARG_FLAG_DARKEN         0x00000100
#define VARG_FLAG_FLATHELP       0x00000200
#define VARG_FLAG_CHOMP          0x00000400
#define VARG_FLAG_LITERAL        0x00000800
#define VARG_FLAG_ARG_DEFAULT    0x00001000
#define VARG_FLAG_ARG_FILENAME   0x00002000
#define VARG_FLAG_ARG_DATE       0x00004000
#define VARG_FLAG_ARG_TIME       0x00008000
#define VARG_FLAG_NEGATE         0x00010000
#define VARG_FLAG_RCDEFAULT      0x00020000
#define VARG_FLAG_ADVERB         0x00100000
#define VARG_FLAG_OPT_ADV        0x00200000
#define VARG_FLAG_REQ_ADV        0x00400000

#define VARG_FLAG_DODEFAULT      0x01000000
#define VARG_FLAG_BADSYNTAX      0x02000000

#define VARG_CF_OVERWRITE        0x00000001
#define VARG_CF_EXISTS           0x00000002
#define VARG_CF_PROMPT           0x00000004

#define IDS_PROGRAM_DESCRIPTION  500

#define IDS_PARAM_DEBUG          501
#define IDS_PARAM_HELP           502
#define IDS_PARAM_SETTINGS       511

#define IDS_ARG_DEFAULT          503
#define IDS_ARG_FILENAME         504
#define IDS_ARG_TIME             505
#define IDS_ARG_DATE             506
#define IDS_ARG_TOKEN            507
#define IDS_ARG_PREFIX           508
#define IDS_ARG_YES              512
#define IDS_VERB_PREFIX          509

#define IDS_MESSAGE_ARG_DUP      550
#define IDS_MESSAGE_BADSYNTAX    551
#define IDS_MESSAGE_UNKNOWNPARAM 552
#define IDS_MESSAGE_AND          553
#define IDS_MESSAGE_REQUIRES     554
#define IDS_MESSAGE_MISSING      555
#define IDS_MESSAGE_NOVERB       556
#define IDS_MESSAGE_UNKNOWN      557
#define IDS_MESSAGE_ERROR        558
#define IDS_MESSAGE_EXCLUSIVE    559
#define IDS_MESSAGE_VERB         560
#define IDS_MESSAGE_VERBS        561
#define IDS_MESSAGE_LINEOPT      562
#define IDS_MESSAGE_PARAMETERS   563
#define IDS_MESSAGE_OPTIONS      564
#define IDS_MESSAGE_INISYNT      565
#define IDS_MESSAGE_USAGE        566
#define IDS_MESSAGE_BADTIME      567
#define IDS_MESSAGE_INCORRECT    568
#define IDS_CF_OVERWRITE         569
#define IDS_MESSAGE_MSR          570
#define IDS_MESSAGE_SUCCESS      571
#define IDS_MESSAGE_DEFAULT      572
#define IDS_MESSAGE_NEGATE       573
#define IDS_MESSAGE_HELPTEXT     574
#define IDS_MESSAGE_ERROR_DBG    575
#define IDS_MESSAGE_WARNING_DBG  576
#define IDS_MESSAGE_WARNING      577
#define IDS_MESSAGE_EXAMPLES     578

#define VARG_BOOL( id, flags, value )   id,0,0,                 NULL,NULL,NULL, VARG_TYPE_BOOL,     flags,  (CMD_TYPE)value,    0,0,0,NULL,
#define VARG_STR( id, flags, value )    id,0,0,                 NULL,NULL,NULL, VARG_TYPE_STR,      flags,  (CMD_TYPE)value,    0,0,0,NULL,
#define VARG_MSZ( id, flags, value )    id,0,0,                 NULL,NULL,NULL, VARG_TYPE_MSZ,      flags,  (CMD_TYPE)value,    0,0,0,NULL,
#define VARG_TIME( id, flags )          id,0,0,                 NULL,NULL,NULL, VARG_TYPE_TIME,     flags,  (CMD_TYPE)0,        0,0,0,NULL, 
#define VARG_DATE( id, flags )          id,0,0,                 NULL,NULL,NULL, VARG_TYPE_DATE,     flags,  (CMD_TYPE)0,        0,0,0,NULL, 
#define VARG_INT( id, flags, value )    id,0,0,                 NULL,NULL,NULL, VARG_TYPE_INT,      flags,  (CMD_TYPE)value,    0,0,0,NULL, 
#define VARG_INI( id, flags, value )    id,0,0,                 NULL,NULL,NULL, VARG_TYPE_INI,      flags|VARG_FLAG_ARG_FILENAME|VARG_FLAG_CHOMP,   (CMD_TYPE)value,    0,0,0,NULL,
#define VARG_DEBUG( flags )             IDS_PARAM_DEBUG,0,0,    NULL,NULL,NULL, VARG_TYPE_DEBUG,    flags,  (CMD_TYPE)0,        0,0,0,NULL,
#define VARG_HELP( flags )              IDS_PARAM_HELP,0,0,     NULL,NULL,NULL, VARG_TYPE_HELP,     flags,  (CMD_TYPE)FALSE,    0,0,0,NULL,
#define VARG_TERMINATOR                 0,0,0,                  NULL,NULL,NULL, VARG_TYPE_LAST,     0,      (CMD_TYPE)0,        0,0,0,NULL

#define VARG_ADJECTIVE    0xFFFF0000
#define VARG_EXCLUSIVE    0x000000FF
#define VARG_INCLUSIVE    0x0000FF00
#define VARG_CONDITION    0x00FF0000
#define VARG_GROUPEXCL    0xFF000000

#define VARG_EXCL( x )    ((DWORD)(x))
#define VARG_INCL( x )    ((DWORD)((x) << 8 ))
#define VARG_COND( x )    ((DWORD)((x) << 16))
#define VARG_GRPX( i, x ) ((DWORD)(((i<<4)|x) << 24))

#define VARG_DECLARE_COMMANDS  VARG_RECORD Commands[] = {
#define VARG_DECLARE_NAMES     VARG_TERMINATOR }; typedef enum _Commands {
#define VARG_DECLARE_FORMAT    };void VArgDeclareFormat() {
#define VARG_DECLARE_END       }
#define VARG_VERB( e, v )      Commands[e].dwVerb = (v & 0x0000FFFF);
#define VARG_GROUP( e, g )     Commands[e].dwSet |= g;
#define VARG_ADVERB( e, v, a ) Commands[e].dwVerb = ( v & 0x0000FFFF) | (a<<16);
#define VARG_EXHELP( e, rc )   Commands[e].fFlag |= VARG_FLAG_EXHELP; Commands[e].idExHelp = rc;

#define ASSIGN_STRING_RC( dest, src, c )                            \
if( IsEmpty( src ) || _tcscmp( src, c )==0 ){                       \
    ASSIGN_STRING( dest, NULL );                                    \
}else{                                                              \
    ASSIGN_STRING( dest, src );                                     \
}                                                                   \

#define ASSIGN_STRING( dest, src )                                  \
if( !IsEmpty(src) ){                                                \
    LPTSTR s = src;   /*in case dest==src*/                         \
    DWORD dwSize = (_tcslen(src)+2)*sizeof(TCHAR);                  \
    dest = (LPTSTR)VARG_ALLOC( dwSize );                            \
    if( NULL != dest ){                                             \
        ZeroMemory( dest, dwSize );                                 \
        _tcscpy( dest, s );                                         \
    }                                                               \
}else{                                                              \
    dest = (LPTSTR)VARG_ALLOC( 2*sizeof(TCHAR) );                   \
    if( NULL != dest ){                                             \
        _tcscpy(dest, _T("") );                                     \
    }                                                               \
}                                                                   \

#ifdef UNICODE
#define MultiByteToChar( a, c )       MultiByteToWideChar( _getmbcp(), 0, (LPCSTR)&a, 1, &c, 1 )
#else
#define MultiByteToChar( a, c )       a = c
#endif

#define VARG_ALLOC( s )  HeapAlloc( GetProcessHeap(), 0, s )
#define VARG_FREE( s )   if( s != NULL ) { HeapFree( GetProcessHeap(), 0, s ); }
#define VARG_REALLOC( p, s )   HeapReAlloc( GetProcessHeap(), 0, p, s )

#ifdef __cplusplus
extern "C" 
{
#endif

#define CMD_TYPE    void*

#pragma warning ( disable : 4201 )

typedef struct _VARG_RECORD
{
    LONG    idParam;
    LONG    idExHelp;
    DWORD   dwSet;
    LPTSTR  strArg1;
    LPTSTR  strArg2;
    LPTSTR  strParam;
    int     fType;
	DWORD   fFlag;
    union{
        void*       vValue;
        LPTSTR      strValue;
        ULONG       nValue;
        BOOL        bValue;
        SYSTEMTIME  stValue;
    };
    BOOL	bDefined;
    BOOL	bNegated;
    DWORD   dwVerb;
    void	(*fntValidation)(int);
} VARG_RECORD, *PVARG_RECORD;

#pragma warning ( default : 4201 )

void ParseCmd(int argc, LPTSTR argv[] );
void VArgDeclareFormat();
void DisplayCommandLineHelp();
void DisplayDebugInfo();

ULONG MszStrLen( LPTSTR mszBuffer );
HRESULT AddStringToMsz( LPTSTR* mszBuffer, LPTSTR strValue );
HRESULT ValidateCommands();

void PrintError( HRESULT hr );
void PrintErrorEx( HRESULT hr, LPTSTR strModule, ... );
void PrintDate( SYSTEMTIME* st );
int  PrintDateEx( SHORT color, SYSTEMTIME* st );

LANGID WINAPI 
VSetThreadUILanguage(
    WORD wReserved
);

int PrintMessage( WORD color, LONG id, ... );
void Chomp(LPTSTR pszLine);

HRESULT GetUserInput( 
    LPTSTR strBuffer, 
    ULONG lSize, 
    BOOL bEcho 
);

HRESULT 
ParseTime( 
    LPTSTR strTime, 
    SYSTEMTIME* pstTime,
    BOOL bDate
);

HRESULT
ExpandFiles( 
    LPTSTR* mszFiles,  
    BOOL bMultiple 
);

HRESULT
CheckFile( 
    LPTSTR strFile, 
    DWORD dwFlags 
);

void FreeCmd();

extern VARG_RECORD Commands[];

extern WORD g_debug;
extern WORD g_light;
extern WORD g_dark;
extern WORD g_normal;

#ifdef __cplusplus
}
#endif

#endif //_VARG_H_012599_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\logman.cpp ===
// logman.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "strings.h"
#include "unihelpr.h"
#include "utils.h"
#include "proputil.h"
#include "propbag.h"
#include "logman.h"
#include "resource.h"
#include "varg.c"

//
// Forward routines:
//

ARG_RECORD Commands[] = {

    IDS_HELP_DEBUG,    
    IDS_ARG1_DEBUG,  NULL, 
    IDS_ARG2_DEBUG,  NULL,
    IDS_PARAM_DEFAULT, NULL,
    ARG_TYPE_DEBUG, ARG_FLAG_OPTIONAL|ARG_FLAG_HIDDEN,  
    (CMD_TYPE)0,     
    0,  NULL,

    IDS_HELP_HELP,
    IDS_ARG1_HELP,     NULL,
    IDS_ARG2_HELP,     NULL,
    0, NULL,
    ARG_TYPE_HELP,   ARG_FLAG_OPTIONAL,
    (CMD_TYPE)FALSE,
    0,  NULL,

    IDS_HELP_COMPUTER,
    IDS_ARG1_COMPUTER, NULL,
    IDS_ARG2_COMPUTER, NULL,
    IDS_ARG1_COMPUTER, NULL,
    ARG_TYPE_STR,    ARG_FLAG_OPTIONAL,
    (CMD_TYPE)NULL,
    0,  NULL,

    IDS_HELP_NAME,
    IDS_ARG1_NAME, NULL,
    IDS_ARG2_NAME, NULL,
    IDS_ARG1_NAME, NULL,
    ARG_TYPE_STR,    ARG_FLAG_CONDITIONAL|ARG_FLAG_NOFLAG,
    (CMD_TYPE)NULL,
    0,  NULL,

    IDS_HELP_START,
    IDS_ARG1_START, NULL,
    IDS_ARG2_START, NULL,
    0, NULL,
    ARG_TYPE_BOOL,    ARG_FLAG_OPTIONAL,
    (CMD_TYPE)NULL,
    0,  NULL,

    IDS_HELP_STOP,
    IDS_ARG1_STOP, NULL,
    IDS_ARG2_STOP, NULL,
    0,NULL,
    ARG_TYPE_BOOL,    ARG_FLAG_OPTIONAL,
    (CMD_TYPE)NULL,
    0,  NULL,

    IDS_HELP_SETTINGS,
    IDS_ARG1_SETTINGS, NULL,
    IDS_ARG2_SETTINGS, NULL,
    IDS_PARAM_FILENAME, NULL,
    ARG_TYPE_STR,    ARG_FLAG_CONDITIONAL,
    (CMD_TYPE)NULL,
    0,  NULL,

    IDS_HELP_OVER,
    IDS_ARG1_OVER, NULL,
    IDS_ARG2_OVER, NULL,
    0, NULL,
    ARG_TYPE_BOOL,    ARG_FLAG_OPTIONAL,
    (CMD_TYPE)NULL,
    0,  NULL,

    ARG_TERMINATOR
};

enum _Commands {
    eDebug,
    eHelp,
    eComputer,
    eName,
    eStart,
    eStop,
    eSettings,
    eOverwrite
};

DWORD   _stdcall
ValidateComputerName (
    LPCTSTR  szComputerName );

DWORD   _stdcall
LoadSettingsFile (
    LPCTSTR szFileName,
    LPTSTR& szFileBuffer );

DWORD   _stdcall
DeleteQuery (
    HKEY            hkeyLogQueries,
    LPCWSTR         szQueryName );

DWORD   _stdcall
InitializeNewQuery (
    HKEY            hkeyLogQueries,
    HKEY&           rhKeyQuery,
    LPCWSTR         szQueryName );

DWORD _stdcall 
CreateDefaultLogQueries (
    HKEY hkeyLogQueries );

DWORD _stdcall 
Install (
    HKEY    hkeyMachine,
    HKEY&   rhkeyLogQueries );

DWORD   _stdcall
ConnectToRegistry (
    LPCTSTR szComputerName,
    HKEY& rhkeyLogQueries );

DWORD   _stdcall   
WriteRegistryLastModified ( 
    HKEY hkeyQuery );

DWORD   _stdcall
WriteToRegistry (
    HKEY            hkeyLogQueries,
    CPropertyBag*   pPropBag,
    LPWSTR          szQueryName,
    DWORD&          rdwLogType );

DWORD   _stdcall
ValidateProperties (
    HKEY            hkeyLogQueries,
    CPropertyBag*   pPropBag,
    DWORD*          pdwLogType,
    LPWSTR          szQueryName,
    DWORD*          pdwNameBufLen );

DWORD   _stdcall
ProcessSettingsObject (
    HKEY            hkeyLogQueries,
    CPropertyBag*   pPropBag );

DWORD   _stdcall
ProcessSettingsFile (
    LPCTSTR szComputerName,
    LPCTSTR szFileName );

DWORD   _stdcall
StartQuery (
    LPCTSTR szComputerName,
    LPCTSTR szQueryName );

DWORD   _stdcall
StopQuery (
    LPCTSTR szComputerName,
    LPCTSTR szQueryName );

DWORD   _stdcall
ConnectToQuery (
    LPCTSTR szComputerName,
    LPCTSTR szQueryName,
    HKEY*   phkeyQuery );

DWORD   _stdcall
GetState ( 
    LPCTSTR szComputerName,
    DWORD&  rdwState );

DWORD   _stdcall
Synchronize ( 
    LPCTSTR szComputerName );

//
//  Routines
//


DWORD   _stdcall
ValidateComputerName (
    LPCTSTR  szComputerName )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    if ( NULL != szComputerName ) {
        if ( ! ( MAX_COMPUTERNAME_LENGTH < lstrlen ( szComputerName ) ) ) {
        } else {
            dwStatus = ERROR_INVALID_COMPUTERNAME;
        }
    }
        
    return dwStatus;
}

DWORD   _stdcall
LoadSettingsFile (
    LPCTSTR szFileName,
    LPTSTR& szFileBuffer )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwLogManStatus = ERROR_SUCCESS;
    HANDLE          hOpenFile = NULL;
    TCHAR           szLocalName [MAX_PATH];     // Todo:  Allocate
    LPTSTR          pFileNameStart = NULL;
    HANDLE          hFindFile = NULL;
    LPTSTR          szData = NULL;
    WIN32_FIND_DATA FindFileInfo;
    INT             iNameOffset;

    USES_CONVERSION;

    lstrcpy ( szLocalName, szFileName );       // Todo:  Handle error
    szFileBuffer = NULL;

    pFileNameStart = ExtractFileName (szLocalName) ;
    iNameOffset = (INT)(pFileNameStart - szLocalName);

    // convert short filename to long NTFS filename if necessary
    hFindFile = FindFirstFile ( szLocalName, &FindFileInfo) ;
    if (hFindFile && hFindFile != INVALID_HANDLE_VALUE) {

        // append the file name back to the path name
        lstrcpy (&szLocalName[iNameOffset], FindFileInfo.cFileName) ;
        FindClose (hFindFile) ;
        // Open the file
        hOpenFile = CreateFile (
                        szLocalName, 
                        GENERIC_READ,
                        0,                  // Not shared
                        NULL,               // Security attributes
                        OPEN_EXISTING,     
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

        if ( hOpenFile && hOpenFile != INVALID_HANDLE_VALUE ) {
            DWORD dwFileSize;
            DWORD dwFileSizeHigh;
        
            // Read the file contents into a memory buffer.
            dwFileSize = GetFileSize ( hOpenFile, &dwFileSizeHigh );

            assert ( 0 == dwFileSizeHigh );
            // Todo:  Handle non-zero file size high

            szData = new TCHAR[(dwFileSize + sizeof(TCHAR))/sizeof(TCHAR)];

            if ( NULL != szData ) {
                if ( FileRead ( hOpenFile, szData, dwFileSize ) ) {
                    szFileBuffer = szData;
                } else {
                    dwLogManStatus = LOGMAN_SETTINGS_FILE_NOT_LOADED;
                    dwStatus = GetLastError();
                }
            } else {
                dwLogManStatus = LOGMAN_SETTINGS_FILE_NOT_LOADED;
                dwStatus = ERROR_OUTOFMEMORY;
            }
            CloseHandle ( hOpenFile );
        } else {
            dwLogManStatus = LOGMAN_SETTINGS_FILE_NOT_OPEN;
            dwStatus = GetLastError();
        }
    } else {
        dwLogManStatus = LOGMAN_SETTINGS_FILE_NOT_OPEN;
        dwStatus = GetLastError();
    }

    if ( ERROR_SUCCESS != dwLogManStatus ) {
        DisplayErrorMessage ( dwLogManStatus, T2W(szFileName) );
    }

    if ( ERROR_SUCCESS != dwStatus ) {
        DisplayErrorMessage ( dwStatus );
    }

    dwStatus = dwLogManStatus;

    return dwStatus;
}

DWORD   _stdcall
DeleteQuery (
    HKEY            hkeyLogQueries,
    LPCWSTR         szQueryName )
{
    DWORD dwStatus = ERROR_SUCCESS;

    // Delete in the registry
    dwStatus = RegDeleteKeyW ( hkeyLogQueries, szQueryName );


    return dwStatus;
}

DWORD   _stdcall
InitializeNewQuery (
    HKEY            hkeyLogQueries,
    HKEY&           rhKeyQuery,
    LPCWSTR         szQueryName )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwDisposition = 0;

    // Create the query specified, checking for duplicate query.
    dwStatus = RegCreateKeyExW (
        hkeyLogQueries,
        szQueryName,
        0,
        NULL, 
        0,
        KEY_ALL_ACCESS,
        NULL,
        &rhKeyQuery,
        &dwDisposition);

    if ( ERROR_SUCCESS == dwStatus ) {
        if ( REG_OPENED_EXISTING_KEY == dwDisposition && !Commands[eOverwrite].bValue ) {
            dwStatus = LOGMAN_DUP_QUERY_NAME;
        } else {
            
            DWORD   dwRegValue;
            // Initialize the current state value.  After it is 
            // initialized, it is only modified when:
            //      1) Set to Stopped or Started by the service
            //      2) Set to Start Pending by the config snapin.
    
            dwRegValue = SLQ_QUERY_STOPPED;
            dwStatus = WriteRegistryDwordValue ( 
                        rhKeyQuery, 
                        cwszRegCurrentState, 
                        &dwRegValue );

            if ( ERROR_SUCCESS == dwStatus ) {
                // Initialize the log type to "new" to indicate partially created logs
                dwRegValue = SLQ_NEW_LOG;
                dwStatus = WriteRegistryDwordValue (
                            rhKeyQuery,
                            cwszRegLogType,
                            &dwRegValue );
            }
        }
    } 

    return dwStatus;
}

DWORD _stdcall 
CreateDefaultLogQueries (
    HKEY hkeyLogQueries )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr = NOERROR;
    LPWSTR  szPropValue;
    HKEY    hkeyQuery = NULL;
    LPWSTR  szMszBuf = NULL;
    DWORD   dwMszBufLen = 0;
    DWORD   dwMszStringLen = 0;


    // Create default "System Overview" counter log query

    // Todo:  check and translate HRESULT failures
    szPropValue = ResourceString ( IDS_DEFAULT_CTRLOG_QUERY_NAME );
    
    if ( ERROR_SUCCESS == dwStatus ) {    
    //Todo:  ResourceString return failure how?
        dwStatus = InitializeNewQuery ( 
                    hkeyLogQueries,
                    hkeyQuery,
                    szPropValue );
    } 
    
    if ( ERROR_SUCCESS == dwStatus ) {
        szPropValue = ResourceString ( IDS_DEFAULT_CTRLOG_CPU_PATH );

        hr = AddStringToMszBufferAlloc ( 
            szPropValue,
            &szMszBuf,
            &dwMszBufLen,
            &dwMszStringLen );

        if ( SUCCEEDED ( hr ) ) {

            szPropValue = ResourceString ( IDS_DEFAULT_CTRLOG_MEMORY_PATH );

            hr = AddStringToMszBufferAlloc ( 
                szPropValue,
                &szMszBuf,
                &dwMszBufLen,
                &dwMszStringLen );

            if ( SUCCEEDED ( hr ) ) {

                szPropValue = ResourceString ( IDS_DEFAULT_CTRLOG_DISK_PATH );

                hr = AddStringToMszBufferAlloc ( 
                    szPropValue,
                    &szMszBuf,
                    &dwMszBufLen,
                    &dwMszStringLen );
            }
        }

        if ( SUCCEEDED ( hr ) ) {
            dwStatus = WriteRegistryStringValue ( 
                            hkeyQuery, 
                            cwszRegCounterList, 
                            REG_MULTI_SZ, 
                            szMszBuf, 
                            dwMszStringLen );
            if ( ERROR_SUCCESS != dwStatus ) {
                hr = HRESULT_FROM_WIN32 ( dwStatus );
            }
        }

        if ( NULL != szMszBuf ) {
            delete szMszBuf;
        }
    }        
    // Counter strings are required fields.
    if ( SUCCEEDED ( hr ) && ERROR_SUCCESS == dwStatus ) {
        DWORD           dwTemp;
        SLQ_TIME_INFO   stiData;
        
        szPropValue = ResourceString ( IDS_DEFAULT_CTRLOG_COMMENT );

        dwStatus = WriteRegistryStringValue ( 
                        hkeyQuery, 
                        cwszRegComment, 
                        REG_SZ, 
                        szPropValue, 
                        lstrlenW ( szPropValue ) );

        dwTemp = SLF_NAME_NONE;
        dwStatus = WriteRegistryDwordValue ( hkeyQuery, cwszRegLogFileAutoFormat, &dwTemp );

        // Start mode and time set to manual        
        memset (&stiData, 0, sizeof(stiData));
        stiData.wTimeType = SLQ_TT_TTYPE_START;
        stiData.wDataType = SLQ_TT_DTYPE_DATETIME;
        stiData.dwAutoMode = SLQ_AUTO_MODE_NONE;
        stiData.llDateTime = MAX_TIME_VALUE;

        dwStatus = WriteRegistrySlqTime ( hkeyQuery, cwszRegStartTime, &stiData );

        // Stop and Sample time fields are defaults, but Smlogsvc generates
        // warning events if fields are missing.
        InitDefaultSlqTimeInfo ( SLQ_COUNTER_LOG, SLQ_TT_TTYPE_STOP, &stiData );
        dwStatus = WriteRegistrySlqTime ( hkeyQuery, cwszRegStopTime, &stiData );
        
        InitDefaultSlqTimeInfo ( SLQ_COUNTER_LOG, SLQ_TT_TTYPE_SAMPLE, &stiData );
        dwStatus = WriteRegistrySlqTime ( hkeyQuery, cwszRegSampleInterval, &stiData );
        
 
        // The following file fields are defaults, but Smlogsvc generates
        // warning events if fields are missing.
        dwStatus = WriteRegistryStringValue ( 
                        hkeyQuery, 
                        cwszRegLogFileFolder, 
                        REG_SZ, 
                        cwszDefaultLogFileFolder, 
                        lstrlenW ( cwszDefaultLogFileFolder ) );

        dwTemp = DEFAULT_LOG_FILE_SERIAL_NUMBER;
        dwStatus = WriteRegistryDwordValue ( hkeyQuery, cwszRegLogFileSerialNumber, &dwTemp );
        
        dwTemp = DEFAULT_LOG_FILE_MAX_SIZE;
        dwStatus = WriteRegistryDwordValue ( hkeyQuery, cwszRegLogFileMaxSize, &dwTemp );
        
        dwTemp = SLF_BIN_FILE;
        dwStatus = WriteRegistryDwordValue ( hkeyQuery, cwszRegLogFileType, &dwTemp );       
        
        szPropValue = ResourceString ( IDS_DEFAULT_CTRLOG_QUERY_NAME );
        dwStatus = WriteRegistryStringValue ( 
                        hkeyQuery, 
                        cwszRegLogFileBaseName, 
                        REG_SZ, 
                        szPropValue, 
                        lstrlenW ( szPropValue ) );

        // The sample query is "ExecuteOnly"
        dwTemp = 1;
        dwStatus = WriteRegistryDwordValue ( hkeyQuery, cwszRegExecuteOnly, &dwTemp );

        // Reset the log type from "new" to real type
        dwTemp = SLQ_COUNTER_LOG;
        dwStatus = WriteRegistryDwordValue ( hkeyQuery, cwszRegLogType, &dwTemp );

        dwStatus = WriteRegistryLastModified ( hkeyQuery );
    
        dwStatus = ERROR_SUCCESS;   // Non-required fields.
    } else {
        // Todo:  Translate status, display message re: default log not installed
        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = (DWORD) hr;
        }
        szPropValue = ResourceString ( IDS_DEFAULT_CTRLOG_QUERY_NAME );

        if ( NULL != hkeyQuery ) {
            RegCloseKey ( hkeyQuery );
            hkeyQuery = NULL;
        }
        DeleteQuery ( hkeyLogQueries, szPropValue ); 
    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    return dwStatus;
}

DWORD _stdcall 
Install (
    HKEY    hkeyMachine,
    HKEY&   rhkeyLogQueries )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HKEY    hkeySysmonLog;
    DWORD   dwDisposition;
    
    assert ( NULL != hkeyMachine );

    rhkeyLogQueries = NULL;

    dwStatus = RegOpenKeyExW (
                    hkeyMachine,
                    cwszRegKeySysmonLog,
                    0,
                    KEY_READ | KEY_WRITE,
                    &hkeySysmonLog);
    
    if ( ERROR_SUCCESS == dwStatus ) {
        // Create registry subkey for Log Queries
        dwStatus = RegCreateKeyExW (
                        hkeySysmonLog,
                        cwszRegKeyLogQueries,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &rhkeyLogQueries,
                        &dwDisposition);
    } 
    
    if ( ERROR_ACCESS_DENIED == dwStatus ) {
        dwStatus = LOGMAN_INSTALL_ACCESS_DENIED;
        DisplayErrorMessage ( dwStatus );
    } else if ( ERROR_SUCCESS == dwStatus ) {
        dwStatus = CreateDefaultLogQueries( rhkeyLogQueries );
        // Todo:  Handle failure
    }

    return dwStatus;
}   
    
DWORD   _stdcall
ConnectToRegistry (
    LPCTSTR szComputerName,
    HKEY& rhkeyLogQueries )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HKEY    hkeyMachine = HKEY_LOCAL_MACHINE;    
    WCHAR   wszComputerName[MAX_COMPUTERNAME_LENGTH+1];

    USES_CONVERSION;
    
    wszComputerName[0] = NULL_W;

    // Connect to registry on specified machine.
    if ( NULL != szComputerName ) {
        if ( NULL_T != szComputerName[0] ) {
        
            lstrcpyW ( wszComputerName, T2W ( szComputerName ) );

            dwStatus = RegConnectRegistryW (
                wszComputerName,
                HKEY_LOCAL_MACHINE,
                &hkeyMachine );        
        } else {
            hkeyMachine = HKEY_LOCAL_MACHINE;
        }
    } else {
        hkeyMachine = HKEY_LOCAL_MACHINE;
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        assert ( NULL != hkeyMachine );
        dwStatus = RegOpenKeyExW (
            hkeyMachine,
            cwszRegKeyFullLogQueries,
            0,
            KEY_ALL_ACCESS,
            &rhkeyLogQueries ); 
        
        if ( ERROR_ACCESS_DENIED == dwStatus ) {
            dwStatus = IDS_LOGMAN_REG_ACCESS_DENIED;
        } else if ( ERROR_SUCCESS != dwStatus ) {
            // Install displays error messages
            dwStatus = Install ( hkeyMachine, rhkeyLogQueries );
        }         
    } else {
        if ( 0 == lstrlenW ( wszComputerName ) ) {
            lstrcpyW ( wszComputerName, cwszLocalComputer );
        }

        DisplayErrorMessage ( LOGMAN_NO_COMPUTER_CONNECT, wszComputerName );
        DisplayErrorMessage ( dwStatus );
        dwStatus = LOGMAN_NO_COMPUTER_CONNECT;
    }

    if ( NULL != hkeyMachine ) {
        RegCloseKey ( hkeyMachine );
    }

    return dwStatus;
}
    
//
//  WriteRegistryLastModified function.
//      Copies the current "last modified date" to the registry where 
//      it is read by the log service.
//
DWORD   _stdcall   
WriteRegistryLastModified ( HKEY hkeyQuery )
{
    LONG    dwStatus = ERROR_SUCCESS;

    SLQ_TIME_INFO   plqLastModified;
    SYSTEMTIME  stLocalTime;
    FILETIME    ftLocalTime;

    // Get local time for last modified value.
    GetLocalTime (&stLocalTime);
    SystemTimeToFileTime (&stLocalTime, &ftLocalTime);
    
    plqLastModified.wDataType = SLQ_TT_DTYPE_DATETIME;
    plqLastModified.wTimeType = SLQ_TT_TTYPE_LAST_MODIFIED;
    plqLastModified.dwAutoMode = SLQ_AUTO_MODE_NONE;    // not used.
    plqLastModified.llDateTime = *(LONGLONG *)&ftLocalTime;

    dwStatus = WriteRegistrySlqTime (
        hkeyQuery, 
        cwszRegLastModified,
        &plqLastModified);

    return dwStatus;
}

DWORD   _stdcall
ValidateProperties (
    HKEY            hkeyLogQueries,
    CPropertyBag*   pPropBag,
    DWORD*          pdwLogType,
    LPWSTR          szQueryName,
    DWORD*          pdwNameBufLen )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr = NOERROR;
    LPWSTR  szPropBagBuf = NULL;
    DWORD   dwPropBagBufLen = 0;
    DWORD   dwPropBagStringLen = 0;
    DWORD   dwLocalLogType;

    // Query key is not necessary for validation, so set it to NULL.
    CPropertyUtils  cPropertyUtils ( Commands[eComputer].strValue, NULL, pPropBag, NULL, hkeyLogQueries );

    USES_CONVERSION;

    *pdwLogType = 0;
    szQueryName[0] = NULL_W;

    // Todo:  Version info

    // Query type and name are required properties.

    hr = DwordFromPropertyBag (
                pPropBag,      
                cwszHtmlLogType,
                dwLocalLogType );
    
    if ( SUCCEEDED ( hr ) ) {
        if ( SLQ_ALERT != dwLocalLogType ) {
            hr = StringFromPropBagAlloc ( pPropBag, cwszHtmlLogName, &szPropBagBuf, &dwPropBagBufLen, &dwPropBagStringLen );
        } else {
            hr = StringFromPropBagAlloc ( pPropBag, cwszHtmlAlertName, &szPropBagBuf, &dwPropBagBufLen, &dwPropBagStringLen );
        }

        if ( FAILED ( hr ) ) {
            dwStatus = LOGMAN_NO_OBJECT_NAME;
/*        } else {

            // Validate query name.  
            // Todo:  Length check.  Must be <= MAX_PATH;
            lstrcpynW ( szTempCheck, szPropBagBuf, MAX_PATH );
            szTokenCheck = _tcstok ( szTempCheck, cwszInvalidLogNameChars );
            if ( 0 != lstrcmpi (szTempCheck, szTokenCheck ) ) {
                dwStatus = LOGMAN_INVALID_QUERY_NAME;
            }
*/
        }
    } else {
        dwStatus = LOGMAN_NO_OBJECT_LOGTYPE;
    }

    // At this point, any hr failure is reflected in dwStatus.

    if ( ERROR_SUCCESS == dwStatus ) {    
        if ( NULL == szQueryName 
                || ( *pdwNameBufLen < ( dwPropBagStringLen + 1 ) ) ) {
            dwStatus = ERROR_INSUFFICIENT_BUFFER;
        } else {
            lstrcpyW ( szQueryName, szPropBagBuf ) ;
        }
        *pdwNameBufLen = dwPropBagStringLen + 1;    // Room for NULL.

        *pdwLogType = dwLocalLogType;
    } 
    
    // If required query type and name exist, then validate all other properties
    if ( ERROR_SUCCESS != dwStatus ) {
        // Todo:  Error message re: Validation failure -or print that and write success messages
        // in the "Process object" method.
        // Todo:  Handle "invalid query name" elsewhere.
        if ( LOGMAN_INVALID_QUERY_NAME == dwStatus ) {
            DisplayErrorMessage ( dwStatus, szQueryName );
        } else {
            DisplayErrorMessage ( dwStatus );
        }
    } else {

        // Initialize the query name string in CPropertyUtils, for error message display.
        cPropertyUtils.SetQueryName ( szQueryName );

        // Validate required parameters first:

        if ( SLQ_TRACE_LOG == dwLocalLogType ) {
            //DWORD dwKernelValid;
            dwStatus = cPropertyUtils.Validate ( IdGuidListProp, dwLocalLogType );

            // Todo:  Check for kernel flags.  Must have Guids or Kernel, cannot have both.

        } else {
            assert ( SLQ_COUNTER_LOG == dwLocalLogType || SLQ_ALERT == dwLocalLogType );
            dwStatus = cPropertyUtils.Validate ( IdCounterListProp, dwLocalLogType );

            // Todo: Validate Alert action flags here.  If all subfields are messed up,
            // do not continue processing (?)
        }

        // All other fields are non-required
        if ( ERROR_SUCCESS == dwStatus ) {

            // Handle failures individually?  Use exception handling?

            if ( SLQ_TRACE_LOG == dwLocalLogType ) {
                
                dwStatus = cPropertyUtils.Validate ( IdTraceBufferSizeProp );
                dwStatus = cPropertyUtils.Validate ( IdTraceBufferMinCountProp );
                dwStatus = cPropertyUtils.Validate ( IdTraceBufferMaxCountProp );
                dwStatus = cPropertyUtils.Validate ( IdTraceBufferFlushIntProp );
                
            } else if ( SLQ_ALERT == dwLocalLogType ) {

                dwStatus = cPropertyUtils.Validate ( IdActionFlagsProp );
                dwStatus = cPropertyUtils.Validate ( IdCommandFileProp );
// Validated as part of action flags validation dwStatus = cPropertyUtils.Validate ( IdNetworkNameProp );
                dwStatus = cPropertyUtils.Validate ( IdUserTextProp );
                dwStatus = cPropertyUtils.Validate ( IdPerfLogNameProp );
            }

            // Properties common to counter and trace logs
            if ( SLQ_COUNTER_LOG == dwLocalLogType 
                    || SLQ_TRACE_LOG == dwLocalLogType ) {

                dwStatus = cPropertyUtils.Validate ( IdLogFileTypeProp );
                dwStatus = cPropertyUtils.Validate ( IdLogFileAutoFormatProp );
                dwStatus = cPropertyUtils.Validate ( IdLogFileSerialNumberProp );
                dwStatus = cPropertyUtils.Validate ( IdLogFileBaseNameProp );
                dwStatus = cPropertyUtils.Validate ( IdLogFileMaxSizeProp );
                dwStatus = cPropertyUtils.Validate ( IdLogFileFolderProp );
                dwStatus = cPropertyUtils.Validate ( IdEofCommandFileProp );
            }

            // Properties common to alerts and counter logs
            if ( SLQ_COUNTER_LOG == dwLocalLogType 
                    || SLQ_ALERT == dwLocalLogType ) {
                dwStatus = cPropertyUtils.Validate ( IdSampleProp );
            }

            // Properties common to all query types
            dwStatus = cPropertyUtils.Validate ( IdCommentProp );
            dwStatus = cPropertyUtils.Validate ( IdRestartProp, dwLocalLogType );

            dwStatus = cPropertyUtils.Validate ( IdStartProp, dwLocalLogType );
            dwStatus = cPropertyUtils.Validate ( IdStopProp, dwLocalLogType );
        
            // Todo:  Validation is currently ignored until fully implemented
            dwStatus = ERROR_SUCCESS;

        } else {
            // Display error message re: missing required property.
            // Need log-type specific message.
            if ( SLQ_COUNTER_LOG == dwLocalLogType ) {
        //        DisplayErrorMessage ( dwStatus );
            } else if ( SLQ_TRACE_LOG == dwLocalLogType ) {
                // Attempt to load kernel trace flags
//                dwStatus = cPropertyUtils.Validate ( IdTraceFlagsProp );
                if ( ERROR_SUCCESS == dwStatus ) {
                    // Todo:  Check for kernel flag.  Need either Kernel flag OR provider GUIDs
                    // and NOT both.
                }
            } else if ( SLQ_ALERT == dwLocalLogType ) {
            }

            // Todo:  Need status processing method to determine if any required subfields are incorrect.
            // If so, then stop processing this HTML file.
            
            
            // Todo:  Validation is currently ignored until fully implemented
            dwStatus = ERROR_SUCCESS;
        }
    }
    // Todo:  Validation is currently ignored until fully implemented
    dwStatus = ERROR_SUCCESS;
    return dwStatus;
}    
    
DWORD   _stdcall
WriteToRegistry (
    HKEY            hkeyLogQueries,
    CPropertyBag*   pPropBag,
    LPWSTR          szQueryName,
    DWORD&          rdwLogType )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr = NOERROR;
    HKEY    hkeyQuery = NULL;
    CPropertyUtils  cPropertyUtils ( Commands[eComputer].strValue );

    USES_CONVERSION;
    // Write all properties to the registry.

    // All errors are displayed as messages within this
    // routine or its subroutines.

    // Create log key 
    dwStatus = InitializeNewQuery (
            hkeyLogQueries,
            hkeyQuery,
            szQueryName );     
    if ( ERROR_SUCCESS != dwStatus ) {
        if ( LOGMAN_DUP_QUERY_NAME == dwStatus ) {
            if ( Commands[eOverwrite].bValue ) {
                // If Overwrite option specified, overwrite after displaying warning.
                DisplayErrorMessage ( LOGMAN_OVERWRITE_DUP_QUERY, szQueryName );
                
                dwStatus = DeleteQuery ( hkeyLogQueries, szQueryName );
                if ( ERROR_SUCCESS == dwStatus ) {
                    dwStatus = InitializeNewQuery (
                                hkeyLogQueries,
                                hkeyQuery,
                                szQueryName ); 
                    if ( ERROR_SUCCESS != dwStatus ) {
                        DisplayErrorMessage ( dwStatus );
                    }
                }
            } else {
               DisplayErrorMessage ( dwStatus, szQueryName );
            }
        } else {
            DisplayErrorMessage ( dwStatus );
        }
    }
    
    // If failed before this point, do not continue loading.

    if ( ERROR_SUCCESS == dwStatus ) {
    
        // Use log key to write properties to the registry.
        // When loading properties, continue even if errors.
        //
        // On error, nothing is written to the registry.  
        // In this case, the default value will  
        // be read in by the log service.

        // Note:  StringFromPropBagAlloc and AddStringToMszBuffer 
        // allocate data buffers that must be deleted by the caller.
        // These methods also indicate length of string returned
        // vs. length of buffer returned.

        // hkeyQueryList is not required for writing to the the registry, 
        // so leave it NULL.
        // Todo:  Some fields will require validation in this method,
        // to ensure that default values are used instead of incorrect values.
        cPropertyUtils.SetQueryName ( szQueryName );
        cPropertyUtils.SetPropertyBag ( pPropBag );
        cPropertyUtils.SetQueryKey ( hkeyQuery );

        // Required properties:  Counter list for counter logs and alerts,
        // provider guid list or kernel flags for trace logs.
        if ( SLQ_TRACE_LOG == rdwLogType ) {
            hr = cPropertyUtils.BagToRegistry ( IdGuidListProp, rdwLogType );
        } else {
            assert ( SLQ_COUNTER_LOG == rdwLogType || SLQ_ALERT == rdwLogType );
            hr = cPropertyUtils.BagToRegistry ( IdCounterListProp, rdwLogType );
        }

        if ( FAILED ( hr ) ) {
            // Todo:  At this point, the problem would be an internal error,
            // because validated previous to this.
            // Todo:  Type - specific error message
            if ( SLQ_COUNTER_LOG == rdwLogType ) {
            } else if ( SLQ_TRACE_LOG == rdwLogType ) {
                // Attemp to load kernel trace flags
                hr = cPropertyUtils.BagToRegistry ( IdTraceFlagsProp );
                if ( FAILED ( hr ) ) {
                    //Todo:  Check for kernel flag.  Need either Kernel flag OR provider GUIDs
                }
            } else if ( SLQ_ALERT == rdwLogType ) {
                // Todo:  Special case to write action properties.  Only write correct ones?
                // Or stop processing if any invalid?
            }
        } else {
            if ( SLQ_TRACE_LOG == rdwLogType ) {
                
                hr = cPropertyUtils.BagToRegistry ( IdTraceBufferSizeProp );
                hr = cPropertyUtils.BagToRegistry ( IdTraceBufferMinCountProp );
                hr = cPropertyUtils.BagToRegistry ( IdTraceBufferMaxCountProp );
                hr = cPropertyUtils.BagToRegistry ( IdTraceBufferFlushIntProp );
                
            } else if ( SLQ_ALERT == rdwLogType ) {

                hr = cPropertyUtils.BagToRegistry ( IdActionFlagsProp );
                hr = cPropertyUtils.BagToRegistry ( IdCommandFileProp );
                hr = cPropertyUtils.BagToRegistry ( IdNetworkNameProp );
                hr = cPropertyUtils.BagToRegistry ( IdUserTextProp );
                hr = cPropertyUtils.BagToRegistry ( IdPerfLogNameProp );
            }
            hr = NOERROR;
            // Todo:  ensure dwLogType is valid

            // Properties common to counter and trace logs
            if ( SLQ_COUNTER_LOG == rdwLogType 
                    || SLQ_TRACE_LOG == rdwLogType ) {

                hr = cPropertyUtils.BagToRegistry ( IdLogFileMaxSizeProp );
                hr = cPropertyUtils.BagToRegistry ( IdLogFileTypeProp );
                hr = cPropertyUtils.BagToRegistry ( IdLogFileAutoFormatProp );
                hr = cPropertyUtils.BagToRegistry ( IdLogFileSerialNumberProp );
                hr = cPropertyUtils.BagToRegistry ( IdLogFileBaseNameProp );
                hr = cPropertyUtils.BagToRegistry ( IdLogFileMaxSizeProp );
                hr = cPropertyUtils.BagToRegistry ( IdLogFileFolderProp );
                hr = cPropertyUtils.BagToRegistry ( IdEofCommandFileProp );
                hr = NOERROR;
            }
    
            // Properties common to alerts and counter logs
            if ( SLQ_COUNTER_LOG == rdwLogType 
                    || SLQ_ALERT == rdwLogType ) {
                // Time values default if error
                hr = cPropertyUtils.BagToRegistry ( IdSampleProp );
                hr = NOERROR;
            }

            // Properties common to all query types
            hr = cPropertyUtils.BagToRegistry ( IdCommentProp );
            hr = cPropertyUtils.BagToRegistry ( IdRestartProp, rdwLogType );

            hr = cPropertyUtils.BagToRegistry ( IdStartProp, rdwLogType );
            hr = cPropertyUtils.BagToRegistry ( IdStopProp, rdwLogType );
        
            hr = NOERROR;
            dwStatus = ERROR_SUCCESS;   // Non-required fields

            // Required fields, ending the creation process.
            // Reset the log type from "new" to real type
            dwStatus = WriteRegistryDwordValue ( hkeyQuery, cwszRegLogType, &rdwLogType );
            if ( ERROR_SUCCESS == dwStatus ) {
                dwStatus = WriteRegistryLastModified ( hkeyQuery );
            }
            if ( ERROR_SUCCESS == dwStatus ) {
                DisplayErrorMessage ( IDS_LOGMAN_QUERY_CONFIG_SUCCESS, szQueryName );
            } /* else //Todo:  Error message re: unable to complete query in the registry */
        }

        if ( FAILED ( hr ) || ( ERROR_SUCCESS != dwStatus ) ) {
            RegCloseKey ( hkeyQuery );
            hkeyQuery = NULL;
            DeleteQuery ( hkeyLogQueries, szQueryName );
        }
    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    return dwStatus;
}

DWORD   _stdcall
ProcessSettingsObject (
    HKEY            hkeyLogQueries,
    CPropertyBag*   pPropBag )
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwLogType;
    WCHAR szQueryName [MAX_PATH];       // Todo:  Remove length restriction
    DWORD dwNameBufLen = MAX_PATH;

    // Validate all properties
    // Todo:  Ensure that at least one provider, counter, or alert was added. 
    dwStatus = ValidateProperties ( 
                    hkeyLogQueries,
                    pPropBag,
                    &dwLogType,
                    szQueryName,
                    &dwNameBufLen );
    // ValidateProperties() displays messages for all errors

    if ( ERROR_SUCCESS == dwStatus ) {

        // Write all properties to the registry.
        // WriteToRegistry() displays messages for all errors
        dwStatus = WriteToRegistry (
                        hkeyLogQueries,
                        pPropBag,
                        szQueryName,
                        dwLogType );
    }

    return dwStatus;
}

DWORD   _stdcall
ProcessSettingsFile (
    LPCTSTR szComputerName,
    LPCTSTR szFileName )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    LPTSTR          szFirstObject = NULL;

    // Open file

    dwStatus = LoadSettingsFile ( szFileName, szFirstObject );

    if ( ERROR_SUCCESS == dwStatus && NULL != szFirstObject ) {
        HKEY    hkeyLogQueries = NULL;
                
        dwStatus = ConnectToRegistry (
                    szComputerName,
                    hkeyLogQueries );

        if ( ERROR_SUCCESS == dwStatus ) {
            LPTSTR  szCurrentObject = NULL;
            LPTSTR  szNextObject = NULL;
            BOOL    bAtLeastOneSysmonObjectRead = FALSE;

            assert ( NULL != hkeyLogQueries );

            szCurrentObject = szFirstObject;

            while ( ERROR_SUCCESS == dwStatus && NULL != szCurrentObject ) {
                CPropertyBag    PropBag;

                dwStatus = PropBag.LoadData ( szCurrentObject, szNextObject );

                if ( ERROR_SUCCESS == dwStatus ) {
                    dwStatus = ProcessSettingsObject (
                                    hkeyLogQueries,
                                    &PropBag );

                    if ( ERROR_SUCCESS == dwStatus ) {
                        bAtLeastOneSysmonObjectRead = TRUE;
                    } else {
                        if ( LOGMAN_NO_SYSMON_OBJECT != dwStatus ) {
                            bAtLeastOneSysmonObjectRead = TRUE;
                        }
                        // Error messages handled (displayed) within 
                        // ProcessSettingsObject(), so reset dwStatus
                        dwStatus = ERROR_SUCCESS;
                    }

                } else {
                    // Handle (display) error message, then reset
                    // dwStatus to continue.
                    if ( LOGMAN_NO_SYSMON_OBJECT != dwStatus ) {
                        DisplayErrorMessage ( dwStatus );
                    }
                    dwStatus = ERROR_SUCCESS;   
                }
                szCurrentObject = szNextObject;
            }

            if ( !bAtLeastOneSysmonObjectRead ) {
                dwStatus = LOGMAN_NO_SYSMON_OBJECT;
                DisplayErrorMessage ( dwStatus );
            }

            RegCloseKey ( hkeyLogQueries );
        } // else error message displayed by ConnectToRegistry()
    } // else error message displayed by LoadSettingsFile()


    // Delete data buffer allocated by LoadSettingsFile
    if ( NULL != szFirstObject ) {
        delete szFirstObject;
    }
    return dwStatus;
}

DWORD   _stdcall
ConnectToQuery (
    LPCTSTR szComputerName,
    LPCTSTR szQueryName,
    HKEY&   rhkeyQuery )
{
    DWORD dwStatus = ERROR_SUCCESS;
    HKEY  hkeyQuery = NULL;
    HKEY  hkeyLogQueries = NULL;
                
    USES_CONVERSION;

    dwStatus = ConnectToRegistry (
                szComputerName,
                hkeyLogQueries );

    if ( ERROR_SUCCESS == dwStatus ) {
        dwStatus = RegOpenKeyEx (
            hkeyLogQueries,
            szQueryName,
            0,
            KEY_ALL_ACCESS,
            &hkeyQuery );

        if ( ERROR_SUCCESS != dwStatus ) {
            if ( ERROR_ACCESS_DENIED == dwStatus ) {
                dwStatus = LOGMAN_REG_ACCESS_DENIED;
                DisplayErrorMessage ( dwStatus );
            } else if ( ERROR_FILE_NOT_FOUND == dwStatus ) {
                dwStatus = LOGMAN_NO_QUERY_CONNECT;
                DisplayErrorMessage ( dwStatus, T2W( szQueryName ) );
            }
        }
    }

    RegCloseKey ( hkeyLogQueries );

    rhkeyQuery = hkeyQuery;
    
    return dwStatus;
}

#pragma warning ( disable : 4706 ) 
DWORD   _stdcall
StartQuery (
    LPCTSTR szComputerName,
    LPCTSTR szQueryName )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;

    USES_CONVERSION;

    // ConnectToQuery displays any errors
    dwStatus = ConnectToQuery ( szComputerName, szQueryName, hkeyQuery );

    if ( ERROR_SUCCESS == dwStatus ) {
        SLQ_TIME_INFO   stiData;
        DWORD           dwRegValue;
        BOOL            bSetStopToMax;
   
        // Todo:  Warn the user if start mode is not manual.
        // Set start mode to manual, start time = MIN_TIME_VALUE
        memset (&stiData, 0, sizeof(stiData));
        stiData.wTimeType = SLQ_TT_TTYPE_START;
        stiData.wDataType = SLQ_TT_DTYPE_DATETIME;
        stiData.dwAutoMode = SLQ_AUTO_MODE_NONE;
        stiData.llDateTime = MIN_TIME_VALUE;

        dwStatus = WriteRegistrySlqTime ( hkeyQuery, cwszRegStartTime, &stiData );
    
        if ( ERROR_SUCCESS == dwStatus ) {
            // If stop time mode set to manual, or StopAt with time before Now,
            // set the mode to Manual, value to MAX_TIME_VALUE
            bSetStopToMax = FALSE;
            dwStatus = ReadRegistrySlqTime ( hkeyQuery, cwszRegStopTime, &stiData );

            if ( ERROR_SUCCESS == dwStatus ) {
                if ( SLQ_AUTO_MODE_NONE == stiData.dwAutoMode ) {
                    bSetStopToMax = TRUE;
                } else if ( SLQ_AUTO_MODE_AT == stiData.dwAutoMode ) {
                    SYSTEMTIME      stLocalTime;
                    FILETIME        ftLocalTime;
                    LONGLONG        llLocalTime;

                    // get local time
                    GetLocalTime (&stLocalTime);
                    SystemTimeToFileTime (&stLocalTime, &ftLocalTime);
        
                    llLocalTime = *(LONGLONG*)&ftLocalTime;

                    if ( llLocalTime >= stiData.llDateTime ) {
                        bSetStopToMax = TRUE;
                    }    
                }
            }

            if ( ERROR_SUCCESS == dwStatus && bSetStopToMax ) {    
                assert( SLQ_TT_DTYPE_DATETIME == stiData.wDataType );
                stiData.dwAutoMode = SLQ_AUTO_MODE_NONE;
                stiData.llDateTime = MAX_TIME_VALUE;
                dwStatus = WriteRegistrySlqTime ( hkeyQuery, cwszRegStopTime, &stiData );
            }
        }
        // Service needs to distinguish between Running and Start Pending
        // at service startup, so always set state to start pending.
        
        // Todo:  Check to see if running, before executing this.
        if ( ERROR_SUCCESS == dwStatus ) {
            dwRegValue = SLQ_QUERY_START_PENDING;
            dwStatus = WriteRegistryDwordValue ( 
                        hkeyQuery, 
                        cwszRegCurrentState, 
                        &dwRegValue );
        }

        // Set LastModified
        if ( ERROR_SUCCESS == dwStatus ) { 
            dwStatus = WriteRegistryLastModified ( hkeyQuery );
        }
        
        // Start the service on the target machine
        if ( ERROR_SUCCESS == dwStatus ) { 
            DWORD   dwTimeout = 3;
            DWORD   dwState = 0;

            dwStatus = Synchronize ( szComputerName );

            while (--dwTimeout && ERROR_SUCCESS == dwStatus ) {
                dwStatus = GetState ( szComputerName, dwState  );

                if ( SERVICE_RUNNING == dwState ) {
                    break;
                }

            }
            if ( ERROR_SUCCESS == dwStatus && SERVICE_RUNNING != dwState ) {
                dwStatus = LOGMAN_START_TIMED_OUT;
            }
        }   

        if ( ERROR_SUCCESS != dwStatus ) {
            if ( LOGMAN_START_TIMED_OUT == dwStatus ) {
                DisplayErrorMessage ( dwStatus, T2W(szQueryName) );
            } else {
                DisplayErrorMessage ( LOGMAN_START_FAILED, T2W(szQueryName) );
                DisplayErrorMessage ( dwStatus );
            }
        }
    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        DisplayErrorMessage ( LOGMAN_QUERY_START_SUCCESS, T2W(szQueryName) );
    }

    return dwStatus;
}
#pragma warning ( default: 4706 ) 

#pragma warning ( disable: 4706 ) 
DWORD   _stdcall
StopQuery (
    LPCTSTR szComputerName,
    LPCTSTR szQueryName )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;

    USES_CONVERSION;

    // ConnectToQuery displays any errors
    dwStatus = ConnectToQuery ( szComputerName, szQueryName, hkeyQuery );

    if ( ERROR_SUCCESS == dwStatus ) {
        SLQ_TIME_INFO stiData;
        DWORD dwRestartMode = 0;
        
        // If query is set to restart on end, clear the restart flag.
        dwStatus = ReadRegistryDwordValue ( hkeyQuery, cwszRegRestart, &dwRestartMode );

        // Todo:  Warn user
        if ( ERROR_SUCCESS == dwStatus && SLQ_AUTO_MODE_NONE != dwRestartMode ) {
            dwRestartMode = SLQ_AUTO_MODE_NONE;
            dwStatus = WriteRegistryDwordValue ( hkeyQuery, cwszRegRestart, &dwRestartMode, REG_BINARY );
        }

        // Set stop mode to manual, stop time to MIN_TIME_VALUE
        if ( ERROR_SUCCESS == dwStatus ) {
            memset (&stiData, 0, sizeof(stiData));
            stiData.wTimeType = SLQ_TT_TTYPE_STOP;
            stiData.wDataType = SLQ_TT_DTYPE_DATETIME;
            stiData.dwAutoMode = SLQ_AUTO_MODE_NONE;
            stiData.llDateTime = MIN_TIME_VALUE;

            dwStatus = WriteRegistrySlqTime ( hkeyQuery, cwszRegStopTime, &stiData );
        }

        // If start time mode set to manual, set the value to MAX_TIME_VALUE
        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = ReadRegistrySlqTime ( hkeyQuery, cwszRegStartTime, &stiData );

            if ( ERROR_SUCCESS == dwStatus 
                    && SLQ_AUTO_MODE_NONE == stiData.dwAutoMode ) {
                assert( SLQ_TT_DTYPE_DATETIME == stiData.wDataType );
                stiData.llDateTime = MAX_TIME_VALUE;
                dwStatus = WriteRegistrySlqTime ( hkeyQuery, cwszRegStartTime, &stiData );
            }
        }

        // Set LastModified
        if ( ERROR_SUCCESS == dwStatus ) { 
            dwStatus = WriteRegistryLastModified ( hkeyQuery );
        }
        // Start the service on the target machine
        if ( ERROR_SUCCESS == dwStatus ) { 
            DWORD   dwTimeout = 3;
            DWORD   dwState = 0;

            dwStatus = Synchronize ( szComputerName );

            while (--dwTimeout && ERROR_SUCCESS == dwStatus ) {
                dwStatus = GetState ( szComputerName, dwState  );

                if ( SERVICE_STOPPED == dwState ) {
                    break;
                }

            }
            if ( ERROR_SUCCESS == dwStatus && SERVICE_STOPPED != dwState ) {
                dwStatus = LOGMAN_STOP_TIMED_OUT;
            }
        }   
        if ( ERROR_SUCCESS != dwStatus ) {
            if ( LOGMAN_STOP_TIMED_OUT == dwStatus ) {
                DisplayErrorMessage ( dwStatus, T2W(szQueryName) );
            } else {
                DisplayErrorMessage ( LOGMAN_STOP_FAILED, T2W(szQueryName) );
                DisplayErrorMessage ( dwStatus );
            }
        }
    }
    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        DisplayErrorMessage ( LOGMAN_QUERY_STOP_SUCCESS, T2W(szQueryName) );
    }

    return dwStatus;
}
#pragma warning ( default: 4706 ) 

DWORD   _stdcall
GetState ( 
    LPCTSTR szComputerName,
    DWORD&  rdwState )
{
    DWORD dwStatus = ERROR_SUCCESS;
    SERVICE_STATUS  ssData;
    SC_HANDLE   hSC;
    SC_HANDLE   hLogService;
    
    rdwState = 0;       // Error by default.

    // open SC database
    hSC = OpenSCManager ( szComputerName, NULL, SC_MANAGER_CONNECT);

    if (hSC != NULL) {
    
        // open service
        hLogService = OpenServiceW (
                        hSC, 
                        cwszLogService,
                        SERVICE_INTERROGATE );
    
        if (hLogService != NULL) {
            if ( ControlService (
                    hLogService, 
                    SERVICE_CONTROL_INTERROGATE,
                    &ssData)) {

                rdwState = ssData.dwCurrentState;
            } else {
                dwStatus = GetLastError();
                rdwState = SERVICE_STOPPED;
                // *** error message
                assert (dwStatus != 0);
            }

            CloseServiceHandle (hLogService);
        
        } else {
            // *** error message
            dwStatus = GetLastError();
            assert (dwStatus != 0);
        }

        CloseServiceHandle (hSC);
    } else {
        // *** error message
        dwStatus = GetLastError();
        assert (dwStatus != 0);
    } // OpenSCManager

    if ( ERROR_SERVICE_NOT_ACTIVE == dwStatus
            || ERROR_SERVICE_REQUEST_TIMEOUT == dwStatus ) {
        rdwState = SERVICE_STOPPED;
        dwStatus = ERROR_SUCCESS;
    }

    return dwStatus;
}

#pragma warning ( disable: 4706 ) 
DWORD   _stdcall
Synchronize ( 
    LPCTSTR szComputerName )
{
    // If the service is running, tell it to synchronize itself,
    // Check the state afterwards to see if it got the message.
    // If stop pending or stopped, wait until the service is
    // stopped and then attempt to start it.  The service 
    // synchronizes itself from the registry when it is started.

    // Return ERROR_SUCCESS for success, other for failure.

    SC_HANDLE   hSC = NULL;
    SC_HANDLE   hLogService = NULL;
    SERVICE_STATUS  ssData;
    DWORD       dwCurrentState;
    DWORD       dwTimeout = 25;
    LONG        dwStatus = ERROR_SUCCESS;

    dwStatus = GetState ( szComputerName, dwCurrentState );

    if ( ERROR_SUCCESS == dwStatus && 0 != dwCurrentState ) {
        // open SC database
        hSC = OpenSCManager ( szComputerName, NULL, SC_MANAGER_CONNECT);

        if ( NULL != hSC ) {
            // open service
            hLogService = OpenServiceW (
                            hSC, 
                            cwszLogService,
                            SERVICE_USER_DEFINED_CONTROL 
                            | SERVICE_START );
    
            if ( NULL != hLogService ) {

                if ( ( SERVICE_STOPPED != dwCurrentState ) 
                        && ( SERVICE_STOP_PENDING != dwCurrentState ) ) {

                    // Wait 100 milliseconds before synchronizing service,
                    // to ensure that registry values are written.
                    Sleep ( 100 );

                    ControlService ( 
                        hLogService, 
                        SERVICE_CONTROL_SYNCHRONIZE, 
                        &ssData);
                
                    dwCurrentState = ssData.dwCurrentState;
                }

                // Make sure that the ControlService call reached the service
                // while it was in run state.
                if ( ( SERVICE_STOPPED == dwCurrentState ) 
                    || ( SERVICE_STOP_PENDING == dwCurrentState ) ) {

                    if ( SERVICE_STOP_PENDING == dwCurrentState ) {
                        // wait for the service to stop before starting it.
                        while ( --dwTimeout && ERROR_SUCCESS == dwStatus ) {
                            dwStatus = GetState ( szComputerName, dwCurrentState );
                            if ( SERVICE_STOP_PENDING == dwCurrentState ) {
                                Sleep(200);
                            } else {
                                break;
                            }
                        }
                    }
                    dwTimeout = 25;
                    if ( SERVICE_STOPPED == dwCurrentState ) {
                        if ( StartService (hLogService, 0, NULL) ) {
                            // wait for the service to start or stop 
                            // before returning
                            while ( --dwTimeout && ERROR_SUCCESS == dwStatus ) {
                                dwStatus = GetState ( szComputerName, dwCurrentState );
                                if ( SERVICE_START_PENDING == dwCurrentState ) {
                                    Sleep(200);
                                } else {
                                    break;
                                }
                            }
                        } else {
                            dwStatus = GetLastError();
                        }
                    } else {
                        // *** error message
                    }
                    // *** ensure that dwCurrentState is not stopped?
                }
            }
            CloseServiceHandle ( hLogService );

        } else {
            dwStatus = GetLastError();
        }

        CloseServiceHandle (hSC);

    } else {
        dwStatus = GetLastError();
    }

    // Todo:  Update Auto Start service config
    return dwStatus;
}
#pragma warning ( default : 4706 ) 

int __cdecl
_tmain (
    INT argc, 
    LPTSTR argv[] )
{
    DWORD   dwStatus = 0;

    // Accept user input.
    // The command line arguments are the objects to sample. 
    // If no user input, then display help.
    ParseCmd( argc, argv );

    if (Commands[eSettings].bDefined) {
        dwStatus = ProcessSettingsFile (
                Commands[eComputer].strValue,
                Commands[eSettings].strValue );
    // Error messages displayed within ProcessSettingsFile method
    }
    if ( Commands[eStart].bDefined ) {
        dwStatus = StartQuery ( 
                Commands[eComputer].strValue,
                Commands[eName].strValue
                );
    // Error messages displayed within StartQuery method
    }
    if ( Commands[eStop].bDefined ) {
        dwStatus = StopQuery ( 
                Commands[eComputer].strValue,
                Commands[eName].strValue
                );
    // Error messages displayed within StopQuery method
    }


    // Error messages displayed within submethods, so reset dwStatus.

    dwStatus = 0;
    FreeCmd();
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\common.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    common.h

Abstract:

    SMONLOG common definitions

--*/

#ifndef _SMONLOG_COMMON_H_
#define _SMONLOG_COMMON_H_

#include <wtypes.h>

#define _CONFIG_DLL_NAME_W_     L"SmLogCfg.dll"
#define _SERVICE_EXE_NAME_W_    L"SmLogSvc.exe"   

// Communication between smlogcfg and smlogsvc

#define SERVICE_CONTROL_SYNCHRONIZE 128
#define SLQ_QUERY_STOPPED       ((DWORD)0x00000000)              
#define SLQ_QUERY_RUNNING       ((DWORD)0x00000001)
#define SLQ_QUERY_START_PENDING ((DWORD)0x00000002)

#define SLQ_NEW_LOG         ((DWORD)0xFFFFFFFF)
#define SLQ_FIRST_LOG_TYPE  ((DWORD)0x00000000)
#define SLQ_COUNTER_LOG     ((DWORD)0x00000000)
#define SLQ_TRACE_LOG       ((DWORD)0x00000001)
#define SLQ_ALERT           ((DWORD)0x00000002)
#define SLQ_LAST_LOG_TYPE   ((DWORD)0x00000002)
#define SLQ_NUM_LOG_TYPES   ((DWORD)0x00000003)

// Sysmon log output file configuration definitions

#define SLF_FIRST_FILE_TYPE ((DWORD)0x00000000)
#define SLF_CSV_FILE        ((DWORD)0x00000000)
#define SLF_TSV_FILE        ((DWORD)0x00000001)
#define SLF_BIN_FILE        ((DWORD)0x00000002)
#define SLF_BIN_CIRC_FILE   ((DWORD)0x00000003)
#define SLF_CIRC_TRACE_FILE ((DWORD)0x00000004)
#define SLF_SEQ_TRACE_FILE  ((DWORD)0x00000005)
#define SLF_SQL_LOG         ((DWORD)0x00000006)
#define SLF_FILE_OVERWRITE  ((DWORD)0x00010000)
#define SLF_NUM_FILE_TYPES  ((DWORD)0x00000007)

#define SLF_NAME_NONE           ((DWORD)0xFFFFFFFF)
#define SLF_NAME_FIRST_AUTO     ((DWORD)0x00000000)
#define SLF_NAME_MMDDHH         ((DWORD)0x00000000)
#define SLF_NAME_NNNNNN         ((DWORD)0x00000001)
#define SLF_NAME_YYYYDDD        ((DWORD)0x00000002)
#define SLF_NAME_YYYYMM         ((DWORD)0x00000003)
#define SLF_NAME_YYYYMMDD       ((DWORD)0x00000004)
#define SLF_NAME_YYYYMMDDHH     ((DWORD)0x00000005)
#define SLF_NAME_MMDDHHMM       ((DWORD)0x00000006)
#define SLF_NUM_AUTO_NAME_TYPES ((DWORD)0x00000007)

// Sysmon log query types and constants

// Constants
#define SLQ_DISK_MAX_SIZE   ((DWORD)-1)

#define SLQ_TLI_ENABLE_BUFFER_FLUSH         ((DWORD)0x00000001)
#define SLQ_TLI_ENABLE_KERNEL_TRACE         ((DWORD)0x00000002)
#define SLQ_TLI_ENABLE_MEMMAN_TRACE         ((DWORD)0x00000004)
#define SLQ_TLI_ENABLE_FILEIO_TRACE         ((DWORD)0x00000008)
#define SLQ_TLI_ENABLE_PROCESS_TRACE        ((DWORD)0x00000010)
#define SLQ_TLI_ENABLE_THREAD_TRACE         ((DWORD)0x00000020)
#define SLQ_TLI_ENABLE_DISKIO_TRACE         ((DWORD)0x00000040)
#define SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE  ((DWORD)0x00000080)

#define SLQ_TLI_ENABLE_MASK                 ((DWORD)0x000000FF)
#define SLQ_TLI_ENABLE_KERNEL_MASK          ((DWORD)0x000000FE)


// dwMode values
#define SLQ_AUTO_MODE_NONE  ((DWORD)0x00000000)       // Manual
#define SLQ_AUTO_MODE_SIZE  ((DWORD)0x00000001)       // Size
#define SLQ_AUTO_MODE_AT    ((DWORD)0x00000002)       // Time
#define SLQ_AUTO_MODE_AFTER ((DWORD)0x00000003)       // Value & unit type

// wDataType values
#define SLQ_TT_DTYPE_DATETIME   ((WORD)0x0001)
#define SLQ_TT_DTYPE_UNITS      ((WORD)0x0002)

// wTimeType values
#define SLQ_TT_TTYPE_START          ((WORD)0x0001)
#define SLQ_TT_TTYPE_STOP           ((WORD)0x0002)
#define SLQ_TT_TTYPE_RESTART        ((WORD)0x0003)
#define SLQ_TT_TTYPE_SAMPLE         ((WORD)0x0004)
#define SLQ_TT_TTYPE_LAST_MODIFIED  ((WORD)0x0005)

// dwUnitType values
#define SLQ_TT_UTYPE_SECONDS        ((DWORD)0x00000001)    
#define SLQ_TT_UTYPE_MINUTES        ((DWORD)0x00000002)   
#define SLQ_TT_UTYPE_HOURS          ((DWORD)0x00000003)   
#define SLQ_TT_UTYPE_DAYS           ((DWORD)0x00000004)   

#pragma warning ( disable : 4201 )

typedef struct _SLQ_TIME_INFO {
    WORD    wDataType;
    WORD    wTimeType;
    DWORD   dwAutoMode;
    union {
        LONGLONG    llDateTime; // filetime stored as a LONGLONG
        struct {
            DWORD   dwValue;
            DWORD   dwUnitType;
        };
    };
} SLQ_TIME_INFO, *PSLQ_TIME_INFO;

#pragma warning ( default : 4201 )

// alert action flags
#define ALRT_ACTION_LOG_EVENT   ((DWORD)0x00000001)
#define ALRT_ACTION_SEND_MSG    ((DWORD)0x00000002)
#define ALRT_ACTION_EXEC_CMD    ((DWORD)0x00000004)
#define ALRT_ACTION_START_LOG   ((DWORD)0x00000008)
#define ALRT_ACTION_MASK        ((DWORD)0x0000000F)

#define ALRT_CMD_LINE_SINGLE    ((DWORD)0x00000100)
#define ALRT_CMD_LINE_A_NAME    ((DWORD)0x00000200)
#define ALRT_CMD_LINE_C_NAME    ((DWORD)0x00000400)
#define ALRT_CMD_LINE_D_TIME    ((DWORD)0x00000800)
#define ALRT_CMD_LINE_L_VAL     ((DWORD)0x00001000)
#define ALRT_CMD_LINE_M_VAL     ((DWORD)0x00002000)
#define ALRT_CMD_LINE_U_TEXT    ((DWORD)0x00004000)
#define ALRT_CMD_LINE_MASK      ((DWORD)0x00007F00)

#define ALRT_DEFAULT_ACTION     ((DWORD)0x00000001) // log event is default

#define AIBF_UNDER  0L
#define AIBF_OVER   ((DWORD)0x00000001) // true when "over" limit is selected
#define AIBF_SEEN   ((DWORD)0x00000002) // set when the user has seen this value
#define AIBF_SAVED  ((DWORD)0x00000004) // true when user has saved this entry in an edit box

#ifdef __cplusplus
extern "C" {
#endif
 
typedef struct _ALERT_INFO_BLOCK {
    DWORD   dwSize;
    LPTSTR  szCounterPath;
    DWORD   dwFlags;
    double  dLimit;
} ALERT_INFO_BLOCK, *PALERT_INFO_BLOCK;

// functions found in utils.c
// Replace spaces with underscores.
void __stdcall ReplaceBlanksWithUnderscores ( LPWSTR szString);
BOOL __stdcall MakeInfoFromString (LPCTSTR szBuffer, PALERT_INFO_BLOCK pInfo, LPDWORD pdwBufferSize);
BOOL __stdcall MakeStringFromInfo (PALERT_INFO_BLOCK pInfo, LPTSTR szBuffer, LPDWORD pcchBufferLength);
BOOL __stdcall GetLocalFileTime (LONGLONG    *pFileTime );
DWORD __stdcall ParseFolderPath (LPCTSTR szOrigPath, LPTSTR szBuffer, INT* piBufLen );

void __stdcall TimeInfoToMilliseconds ( SLQ_TIME_INFO* pTimeInfo, LONGLONG* pllmsecs );

#ifdef __cplusplus
}
#endif

#endif //_SMONLOG_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\logmmsg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    logmmsg

Abstract:

    Performance Log Manager messages

--*/
//
// This file is automatically generated from logmmsg.mc
//
#ifndef _LOGMMSG_H_
#define _LOGMMSG_H_
//
// Messages
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: LOGMAN_INVALID_COMPUTER
//
// MessageText:
//
//  The /COMPUTER_NAME command qualifier has been included but the 
//  computer name is either incorrect or has not been specified.
//
#define LOGMAN_INVALID_COMPUTER          ((DWORD)0xC0001770L)

//
// MessageId: LOGMAN_INVALID_STARTNAME
//
// MessageText:
//
//  The /START command qualifier has been included but the 
//  log or alert name is either incorrect or has not been specified.
//
#define LOGMAN_INVALID_STARTNAME         ((DWORD)0xC0001771L)

//
// MessageId: LOGMAN_INVALID_STOPNAME
//
// MessageText:
//
//  The /STOP command qualifier has been included but the 
//  log or alert name is either incorrect or has not been specified.
//
#define LOGMAN_INVALID_STOPNAME          ((DWORD)0xC0001772L)

//
// MessageId: LOGMAN_INVALID_SETTINGS
//
// MessageText:
//
//  The /SETTINGS command qualifier has been included but the file name is either 
//  incorrect or has not been specified.  The file name must specify the path of 
//  an existing HTML log or alert configuration file.
//
#define LOGMAN_INVALID_SETTINGS          ((DWORD)0xC0001773L)

//
// MessageId: LOGMAN_INVALID_COMMAND
//
// MessageText:
//
//  Specify one of the following command qualifiers: /SETTINGS, /START or /STOP.
//
#define LOGMAN_INVALID_COMMAND           ((DWORD)0xC0001774L)

//
// MessageId: LOGMAN_SETTINGS_FILE_NOT_OPEN
//
// MessageText:
//
//  Unable to open /SETTINGS configuration file '%1'.
//
#define LOGMAN_SETTINGS_FILE_NOT_OPEN    ((DWORD)0xC0001775L)

//
// MessageId: LOGMAN_NO_SYSMON_OBJECT
//
// MessageText:
//
//  The settings do not contain any complete System Monitor Html objects.
//
#define LOGMAN_NO_SYSMON_OBJECT          ((DWORD)0xC0001776L)

//
// MessageId: LOGMAN_DUP_QUERY_NAME
//
// MessageText:
//
//  A log or alert with name '%1' already exists, and will not be overwritten.
//
#define LOGMAN_DUP_QUERY_NAME            ((DWORD)0x80001777L)

//
// MessageId: LOGMAN_OVERWRITE_DUP_QUERY
//
// MessageText:
//
//  A log or alert with name '%1' already exists.  Its properties will be overwritten by the new configuration.
//
#define LOGMAN_OVERWRITE_DUP_QUERY       ((DWORD)0x80001778L)

//
// MessageId: LOGMAN_PROCESSING_COMPLETE
//
// MessageText:
//
//  The following logs and alerts have been configured on computer %1:
//
#define LOGMAN_PROCESSING_COMPLETE       ((DWORD)0x40001779L)

//
// MessageId: LOGMAN_NO_COMPUTER_CONNECT
//
// MessageText:
//
//  Unable to connect to registry on %1.
//
#define LOGMAN_NO_COMPUTER_CONNECT       ((DWORD)0xC000177AL)

//
// MessageId: LOGMAN_SETTINGS_FILE_NOT_LOADED
//
// MessageText:
//
//  Unable to load /SETTINGS configuration file '%1' into memory.
//
#define LOGMAN_SETTINGS_FILE_NOT_LOADED  ((DWORD)0xC000177BL)

//
// MessageId: LOGMAN_NO_OBJECT_LOGTYPE
//
// MessageText:
//
//  Unable to load the LogType property for the current log or alert. This log or alert
//  will not be configured.
//
#define LOGMAN_NO_OBJECT_LOGTYPE         ((DWORD)0x8000177CL)

//
// MessageId: LOGMAN_NO_OBJECT_NAME
//
// MessageText:
//
//  Unable to load the Name property for the current log or alert. This log or alert
//  will not be configured.
//
#define LOGMAN_NO_OBJECT_NAME            ((DWORD)0x8000177DL)

//
// MessageId: LOGMAN_QUERY_CONFIG_SUCCESS
//
// MessageText:
//
//  Configured the %1 log or alert.
//
#define LOGMAN_QUERY_CONFIG_SUCCESS      ((DWORD)0x4000177EL)

//
// MessageId: LOGMAN_START_TIMED_OUT
//
// MessageText:
//
//  The start action was executed for %1. 
//  Unable to detect the current status within the timeout period. 
//  See the application event log on the target computer for any status
//  or error events, or use Performance to determine status.
//
#define LOGMAN_START_TIMED_OUT           ((DWORD)0xC000177FL)

//
// MessageId: LOGMAN_STOP_TIMED_OUT
//
// MessageText:
//
//  The stop action was executed for %1.  Unable to detect
//  the current status within the timeout period. See the application event log
//  on the target computer for any error events, or use Performance
//  to determine status.
//
#define LOGMAN_STOP_TIMED_OUT            ((DWORD)0xC0001780L)

//
// MessageId: LOGMAN_NO_QUERY_CONNECT
//
// MessageText:
//
//  The %1 log or alert does not exist on the target computer.
//
#define LOGMAN_NO_QUERY_CONNECT          ((DWORD)0xC0001781L)

//
// MessageId: LOGMAN_INVALID_TOKEN
//
// MessageText:
//
//  Parameter value invalid or not found.
//
#define LOGMAN_INVALID_TOKEN             ((DWORD)0xC0001782L)

//
// MessageId: LOGMAN_START_FAILED
//
// MessageText:
//
//  Unable to start the %1 log or alert on target computer.
//
#define LOGMAN_START_FAILED              ((DWORD)0xC0001783L)

//
// MessageId: LOGMAN_STOP_FAILED
//
// MessageText:
//
//  Unable to stop the %1 log or alert on target computer.
//
#define LOGMAN_STOP_FAILED               ((DWORD)0xC0001784L)

//
// MessageId: LOGMAN_REQUIRED_PROP_MISSING
//
// MessageText:
//
//  Required property '%1' is missing for the %2 log or alert.
//
#define LOGMAN_REQUIRED_PROP_MISSING     ((DWORD)0x80001785L)

//
// MessageId: LOGMAN_REQUIRED_PROP_INVALID
//
// MessageText:
//
//  Required property '%1' is invalid for the %2 log or alert.
//
#define LOGMAN_REQUIRED_PROP_INVALID     ((DWORD)0x80001786L)

//
// MessageId: LOGMAN_NONREQ_PROP_MISSING
//
// MessageText:
//
//  Property '%1' is missing for the %2 log or alert and will be set to the default value.
//
#define LOGMAN_NONREQ_PROP_MISSING       ((DWORD)0x40001787L)

//
// MessageId: LOGMAN_NONREQ_PROP_INVALID
//
// MessageText:
//
//  Property '%1' is invalid for the %2 log or alert and will be set to the default value.
//
#define LOGMAN_NONREQ_PROP_INVALID       ((DWORD)0x80001788L)

//
// MessageId: LOGMAN_OUT_OF_RANGE
//
// MessageText:
//
//  The value %1 for property %2 in the %3 log or alert is invalid and will be set to its default value.
//  The valid range is %4 to %5.
//
#define LOGMAN_OUT_OF_RANGE              ((DWORD)0x40001789L)

//
// MessageId: LOGMAN_REG_ACCESS_DENIED
//
// MessageText:
//
//  Unable to complete the current operation on the target system. You must have read
//  and write access to the HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SysmonLog\Log Queries 
//  registry subkey and its subkeys on that system.
//
#define LOGMAN_REG_ACCESS_DENIED         ((DWORD)0x4000178AL)

//
// MessageId: LOGMAN_INSTALL_ACCESS_DENIED
//
// MessageText:
//
//  Unable to install the Performance Logs and Alerts configuration on the target system. You must have read
//  and write access to the HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SysmonLog
//  registry subkey and its subkeys on that system.
//
#define LOGMAN_INSTALL_ACCESS_DENIED     ((DWORD)0x4000178BL)

//
// MessageId: LOGMAN_INSTALL_FAILURE
//
// MessageText:
//
//  Unable to install the Performance Logs and Alerts configuration on the target system.
//
#define LOGMAN_INSTALL_FAILURE           ((DWORD)0x4000178CL)

//
// MessageId: LOGMAN_QUERY_START_SUCCESS
//
// MessageText:
//
//  Started the %1 log or alert.
//
#define LOGMAN_QUERY_START_SUCCESS       ((DWORD)0x4000178DL)

//
// MessageId: LOGMAN_QUERY_STOP_SUCCESS
//
// MessageText:
//
//  Stopped the %1 log or alert.
//
#define LOGMAN_QUERY_STOP_SUCCESS        ((DWORD)0x4000178EL)

//
// MessageId: LOGMAN_INVALID_PARAM
//
// MessageText:
//
//  Invalid command qualifier "%1".
//
#define LOGMAN_INVALID_PARAM             ((DWORD)0xC000178FL)

//
// MessageId: LOGMAN_INVALID_QUERY_NAME
//
// MessageText:
//
//  Invalid log or alert name "%1".
//  A log or alert name cannot contain any of the following characters:\ / : * ? " < > | .
//
#define LOGMAN_INVALID_QUERY_NAME        ((DWORD)0x80001790L)

//
// MessageId: LOGMAN_TOO_MANY_COMMANDS
//
// MessageText:
//
//  Specify only one of the following qualifiers: /SETTINGS, /START or /STOP.
//
#define LOGMAN_TOO_MANY_COMMANDS         ((DWORD)0xC0001791L)

//
// MessageId: LOGMAN_DISPLAY_HELP
//
// MessageText:
//
//  No message.  Display the help file.
//
#define LOGMAN_DISPLAY_HELP              ((DWORD)0xC0001792L)

#endif //_LOGMMSG_H_
// end of generated file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\logman.h ===
/*++

Copyright (C) 1999-2000 Microsoft Corporation

Module Name:

    logman.h

Abstract:

    This file contains constants and definitions for logman.exe


--*/

#ifndef _LOGMAN_H_
#define _LOGMAN_H_

#include "logmmsg.h"

#define IDS_DEFAULT_CTRLOG_QUERY_NAME   300
#define IDS_DEFAULT_CTRLOG_CPU_PATH     301
#define IDS_DEFAULT_CTRLOG_MEMORY_PATH  302
#define IDS_DEFAULT_CTRLOG_DISK_PATH    303
#define IDS_DEFAULT_CTRLOG_COMMENT      304

#define FIRST_STATUS_VALUE                  6000

#define IDS_LOGMAN_INVALID_COMPUTER         FIRST_STATUS_VALUE
#define IDS_LOGMAN_STARTNAME_INVALID        FIRST_STATUS_VALUE+1
#define IDS_LOGMAN_STOPNAME_INVALID         FIRST_STATUS_VALUE+2
#define IDS_LOGMAN_INVALID_SETTINGS         FIRST_STATUS_VALUE+3
#define IDS_LOGMAN_INVALID_COMMAND          FIRST_STATUS_VALUE+4
#define IDS_LOGMAN_SETTINGS_FILE_NOT_OPEN   FIRST_STATUS_VALUE+5
#define IDS_LOGMAN_NO_SYSMON_OBJECT         FIRST_STATUS_VALUE+6 
#define IDS_LOGMAN_DUP_QUERY_NAME           FIRST_STATUS_VALUE+7  
#define IDS_LOGMAN_OVERWRITE_DUP_QUERY      FIRST_STATUS_VALUE+8
#define IDS_LOGMAN_PROCESSING_COMPLETE      FIRST_STATUS_VALUE+9
#define IDS_LOGMAN_NO_COMPUTER_CONNECT      FIRST_STATUS_VALUE+10
#define IDS_LOGMAN_SETTINGS_FILE_NOT_LOADED FIRST_STATUS_VALUE+11
#define IDS_LOGMAN_NO_OBJECT_LOGTYPE        FIRST_STATUS_VALUE+12
#define IDS_LOGMAN_NO_OBJECT_NAME           FIRST_STATUS_VALUE+13
#define IDS_LOGMAN_QUERY_CONFIG_SUCCESS     FIRST_STATUS_VALUE+14
#define IDS_LOGMAN_START_TIMED_OUT          FIRST_STATUS_VALUE+15
#define IDS_LOGMAN_STOP_TIMED_OUT           FIRST_STATUS_VALUE+16

#define IDS_LOGMAN_NO_QUERY_CONNECT         FIRST_STATUS_VALUE+17
#define IDS_LOGMAN_INVALID_TOKEN            FIRST_STATUS_VALUE+18
#define IDS_LOGMAN_START_FAILED             FIRST_STATUS_VALUE+19
#define IDS_LOGMAN_STOP_FAILED              FIRST_STATUS_VALUE+20

#define IDS_LOGMAN_REQUIRED_PROP_MISSING    FIRST_STATUS_VALUE+21
#define IDS_LOGMAN_REQUIRED_PROP_INVALID    FIRST_STATUS_VALUE+22
#define IDS_LOGMAN_NONREQ_PROP_MISSING      FIRST_STATUS_VALUE+23
#define IDS_LOGMAN_NONREQ_PROP_INVALID      FIRST_STATUS_VALUE+24
#define IDS_LOGMAN_OUT_OF_RANGE             FIRST_STATUS_VALUE+25
#define IDS_LOGMAN_REG_ACCESS_DENIED        FIRST_STATUS_VALUE+26
#define IDS_LOGMAN_INSTALL_ACCESS_DENIED    FIRST_STATUS_VALUE+27
#define IDS_LOGMAN_INSTALL_FAILURE          FIRST_STATUS_VALUE+28
#define IDS_LOGMAN_QUERY_START_SUCCESS      FIRST_STATUS_VALUE+29
#define IDS_LOGMAN_QUERY_STOP_SUCCESS       FIRST_STATUS_VALUE+30
#define IDS_LOGMAN_INVALID_PARAM            FIRST_STATUS_VALUE+31
#define IDS_LOGMAN_INVALID_QUERY_NAME       FIRST_STATUS_VALUE+32
#define IDS_LOGMAN_TOO_MANY_COMMANDS        FIRST_STATUS_VALUE+33
#define IDS_LOGMAN_DISPLAY_HELP             FIRST_STATUS_VALUE+34   // No message

// Current max = 40 in utils.h ::IsLogManMessage()
#endif // _LOGMAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\makefile.inc ===
!IFNDEF BUILDMSG
BUILDMSG=
!ENDIF

.\logmmsg.h .\msg00001.bin .\logmmsg.rc : .\logmmsg.mc
	mc -v  logmmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\propbag.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ipropbag.h

Abstract:

    <abstract>

--*/

#ifndef _PROPBAG_H_
#define _PROPBAG_H_

#include <oaidl.h>
        
// Property Bag Class
class CPropertyBag {

    public:
                CPropertyBag ( void );
        virtual ~CPropertyBag ( void );

                HRESULT Read ( LPCWSTR, VARIANT* );
                HRESULT Write ( LPCWSTR, VARIANT* );

                LPWSTR  GetData ( void );
                DWORD   LoadData ( LPCTSTR pszData, LPTSTR& rpszNextData );

    private:

        typedef struct _param_data {
            _param_data*    pNextParam; 
            WCHAR           pszPropertyName[MAX_PATH];
            VARIANT         vValue;
        } PARAM_DATA, *PPARAM_DATA;

        enum eConstants {
            eDefaultBufferLength = 0x010000      // 64K
        };

        PPARAM_DATA FindProperty ( LPCWSTR pszPropName );
        void        DataListAddHead ( PPARAM_DATA );
        PPARAM_DATA DataListRemoveHead ( void );

        LPWSTR          m_pszData;
        DWORD           m_dwCurrentDataLength;
        PPARAM_DATA     m_plistData;
};

typedef CPropertyBag *PCPropertyBag;

#endif // _PROPBAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\propbag.cpp ===
/*++

Copyright (C) 1999-2000 Microsoft Corporation

Module Name:

    PropBag.cpp

Abstract:

    Implementation of the private IPropertyBag interface used by
    the Performance Log Manager.

--*/

#include "logman.h"
#include "stdafx.h"
#include "unihelpr.h"
#include "strings.h"
#include "propbag.h"

#define MAX_GUID_STRING_LENGTH 39

/*
 * CPropertyBag::CPropertyBag
 *
 * Purpose:
 *  Constructor.
 *
 * Return Value:
 */

CPropertyBag::CPropertyBag ( void )
:   m_pszData ( NULL ),
    m_dwCurrentDataLength ( 0 ),
    m_plistData ( NULL )
{
    return; 
}

/*
 * CPropertyBag::~CPropertyBag
 *
 * Purpose:
 *  Destructor.
 *
 * Return Value:
 */

CPropertyBag::~CPropertyBag ( void ) 
{   
    if ( NULL != m_pszData ) {
        delete m_pszData;
    }

    while ( NULL != m_plistData ) {
        PPARAM_DATA pData = DataListRemoveHead();
        VariantClear ( &pData->vValue ); 
        delete pData;
    }

    return; 
}


/*
 * CPropertyBag::Read
 *
 * Purpose:
 *
 *  This function is called to read a property from the property bag.
 *
 * Parameters:
 *  pszPropName     Pointer to name of property to be read
 *  pVar            Pointer to the VARIANT to receive the property value
 *  pIErrorLog      Pointer to the caller's error log
 */

HRESULT
CPropertyBag::Read (
    LPCWSTR pszPropName,    //Pointer to the property to be read
    VARIANT* pVar )         //Pointer to the VARIANT to receive the 
                            //property value
{
    HRESULT     hr = NOERROR;
    PPARAM_DATA pData = NULL;

    assert ( NULL != pszPropName );
    assert ( NULL != pVar );

    if ( NULL == pszPropName )
        return ResultFromScode ( E_POINTER );

    if ( NULL == pVar )
        return ResultFromScode ( E_POINTER );

    //Read the specified data into the passed variant.
    pData = FindProperty ( pszPropName );

    if ( NULL != pData ) {
        hr = VariantChangeType ( pVar, &pData->vValue, NULL, pVar->vt );
    } else {
        hr = E_INVALIDARG;
    }

    return hr;
}

/*
 * CPropertyBag::Write
 *
 * Purpose:
 *
 *  This function is called to write a property to the property bag.
 *
 * Parameters:
 *  pszPropName     Pointer to name of property to be written
 *  pVar            Pointer to the VARIANT containing the property value
 */

HRESULT 
CPropertyBag::Write (
    LPCWSTR pszPropName,    //Pointer to the property to be written
    VARIANT* pVar )         //Pointer to the VARIANT containing the  
                            //property value and type
{
    HRESULT     hr = S_OK;
    VARIANT     vValueBstr;
    DWORD       dwNameLength;
    DWORD       dwDataLength;
    static DWORD dwDelimiterLength = 0;
    static DWORD dwParamNameLength = 0;
    static DWORD dwEolTagLength = 0;
    static DWORD dwValueTagLength = 0;
    HRESULT     hrConvert;
    LPWSTR      pszNextField = m_pszData;
    DWORD       dwCurrentDataUsedLength;

    assert ( NULL != pszPropName );
    assert ( NULL != pVar );    
    
    if ( NULL == pszPropName )
        return ResultFromScode ( E_POINTER );

    if ( NULL == pVar )
        return ResultFromScode ( E_POINTER );

    USES_CONVERSION

    VariantInit ( &vValueBstr );

    hrConvert = VariantChangeType ( &vValueBstr, pVar, NULL, VT_BSTR );
    // All length values calculated number of WCHARs.

    if ( 0 == dwDelimiterLength ) {
        // Initialize static values

        dwParamNameLength = lstrlenW (cwszHtmlParamTag);
        dwValueTagLength = lstrlenW ( cwszHtmlValueTag );
        dwEolTagLength = lstrlenW ( cwszHtmlValueEolTag );
        
        dwDelimiterLength = dwParamNameLength + dwValueTagLength + dwEolTagLength;  
    }

    if ( SUCCEEDED ( hr ) ) {
        hr = E_NOTIMPL;
        // Todo:  Implement

        dwNameLength = lstrlenW ( pszPropName );
        dwDataLength = lstrlenW ( vValueBstr.bstrVal );
        dwCurrentDataUsedLength = lstrlenW ( m_pszData );

        // Add 1 to size calculation for NULL buffer terminator.
        if ( m_dwCurrentDataLength 
            < dwCurrentDataUsedLength + dwNameLength + dwDataLength + dwDelimiterLength + 1 ) { 

            LPWSTR pszNewBuffer;
        
            if ( 0 == m_dwCurrentDataLength ) {
                m_dwCurrentDataLength += eDefaultBufferLength;
            } else {
                m_dwCurrentDataLength *= 2;
            }
            pszNewBuffer = new WCHAR[m_dwCurrentDataLength];

            if ( NULL == pszNewBuffer )
                return E_OUTOFMEMORY;

            if ( NULL != m_pszData ) {
                memcpy ( pszNewBuffer, m_pszData, dwCurrentDataUsedLength * sizeof(WCHAR) );
                delete m_pszData;
            }
            m_pszData = pszNewBuffer;
        }

        // Build the new string and add it to the current data.

        pszNextField = m_pszData + dwCurrentDataUsedLength;
        memcpy ( pszNextField, cwszHtmlParamTag, dwParamNameLength * sizeof(WCHAR) );

        pszNextField += dwParamNameLength;
        memcpy ( pszNextField, pszPropName, dwNameLength * sizeof(WCHAR) );

        pszNextField += dwNameLength;
        memcpy ( pszNextField, cwszHtmlValueTag, dwValueTagLength * sizeof(WCHAR) );

        pszNextField += dwValueTagLength;
        memcpy ( pszNextField, W2T(vValueBstr.bstrVal), dwDataLength * sizeof(WCHAR) );

        pszNextField += dwDataLength;
        memcpy ( pszNextField, cwszHtmlValueEolTag, dwEolTagLength * sizeof(WCHAR) );

        pszNextField += dwEolTagLength;
        lstrcpyW ( pszNextField, cwszNull );

    }
    return hr;
}

/*
 * CPropertyBag::GetData
 *
 * Purpose:
 *  Return pointer to the data buffer.
 *
 * Return Value:
 *  Pointer to the data buffer.
 */

LPWSTR
CPropertyBag::GetData ( void ) 
{   
    return m_pszData;
}

/*
 * CPropertyBag::LoadData
 *
 * Purpose:
 *  Load data from the supplied buffer into internal data structures.
 *
 * Return Value:
 *  Status.
 */

DWORD
CPropertyBag::LoadData ( 
    LPCTSTR  pszData,
    LPTSTR& rpszNextData ) 
{   
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  szNextEoo = NULL;
    BOOL    bUnicode = TRUE;

    USES_CONVERSION

    assert ( NULL != pszData );

    rpszNextData = NULL;

    if ( NULL != pszData ) {
        LPWSTR  pszDataW = NULL;
        LPWSTR  pszDataAllocW = NULL;
        LPWSTR  pszCurrentPos;
        LPWSTR  pszGuid;

        // Unicode search:  Begin the search after the first instance 
        // of the System Monitor class id.
        
        pszGuid = wcstok ( const_cast<LPWSTR>(cwszHtmlObjectClassId), L"{} " );
        pszCurrentPos = wcsstr( (LPWSTR) pszData, pszGuid );

        // Handle wide vs ansi.
        if ( NULL != pszCurrentPos ) {
            pszDataW = (LPWSTR)pszData;
			bUnicode = TRUE;
        } else {
            // Check for ANSI version:
            LPSTR   pszGuidA = NULL;
            LPSTR   pszCurrentPosA = NULL;
            LPSTR   pszDataA = (CHAR*) pszData;
             
            pszGuidA = W2A( pszGuid );
            pszCurrentPosA = strstr ( pszDataA, pszGuidA );

            if ( NULL != pszCurrentPosA ) {
                pszDataAllocW = A2W ( pszDataA );
                pszDataW = pszDataAllocW;
				bUnicode = FALSE;
                pszCurrentPos = wcsstr(pszDataW, pszGuid );
            }
        }

        if ( NULL != pszCurrentPos ) {
            LPWSTR  szEoo;

            // End of object is the first object footer tag after the first sysmon
            // class id found. If multiple objects in the data block, only parse the first sysmon.
            szEoo = wcsstr(pszCurrentPos, cwszHtmlObjectFooter );

            if ( NULL != szEoo ) {

                // Find first parameter tag.
                pszCurrentPos = wcsstr(pszCurrentPos, cwszHtmlParamSearchTag );

                while ( NULL != pszCurrentPos && pszCurrentPos < szEoo ) {
    
                    LPWSTR      pszNextPos;
                    INT         lStrLength;
                    PPARAM_DATA pParamData;
                    LPWSTR      szTemp;

                    // Store parameter/property name.
                    // Find one past first quote.
                    pszCurrentPos = wcsstr(pszCurrentPos, cwszQuote ) + 1;

                    // The param name is between first and second quote.
                    pszNextPos = wcsstr(pszCurrentPos, cwszQuote );

                    lStrLength = ( (INT)((UINT_PTR)pszNextPos - (UINT_PTR)pszCurrentPos) ) / sizeof ( WCHAR ) ;

                    pParamData = new PARAM_DATA;

                    if ( NULL != pParamData ) {
                        pParamData->pNextParam = NULL;
                        VariantInit ( &pParamData->vValue );
                        pParamData->vValue.vt = VT_BSTR;
                    } else {
                        dwStatus = ERROR_OUTOFMEMORY;
                        break;
                    }

                    wcsncpy ( pParamData->pszPropertyName, pszCurrentPos, lStrLength );
                    pParamData->pszPropertyName[lStrLength] = TEXT ('\0');

                    // Find value tag and store parameter/property value.
                    // Find value tag
                    pszCurrentPos = wcsstr ( pszCurrentPos, cwszHtmlValueSearchTag );
                    // Find one past first quote
                    pszCurrentPos = wcsstr ( pszCurrentPos, cwszQuote ) + 1;
                    // The value is between first and second quote.
                    pszNextPos = wcsstr ( pszCurrentPos, cwszQuote );
            
                    lStrLength = ( (INT)((UINT_PTR)pszNextPos - (UINT_PTR)pszCurrentPos) ) / sizeof ( WCHAR );

                    szTemp = new WCHAR[lStrLength+1];
                    if (szTemp != NULL) {
                        wcsncpy ( szTemp, pszCurrentPos, lStrLength );
                        szTemp[lStrLength] = TEXT('\0');

                        pParamData->vValue.bstrVal = 
                                    SysAllocString ( szTemp );

                        delete szTemp;
                        DataListAddHead ( pParamData );
                        // Find next parameter/property tag.
                        pszCurrentPos = wcsstr(pszCurrentPos, cwszHtmlParamSearchTag );
                    } else {
                        delete pParamData;
                        dwStatus = ERROR_OUTOFMEMORY;
                        break;
                    }
                } // While parameter tags exist for a single object.

				// Search for next object
				// Start after current object footer
                szEoo += lstrlenW ( cwszHtmlObjectFooter );

                szNextEoo = wcsstr(szEoo, cwszHtmlObjectFooter);
            
                // Successful. Return pointer to end of the current object, or NULL if all 
                // objects have been processed.
                if ( NULL != szNextEoo ) {
                    if ( bUnicode ) {
                        rpszNextData = (LPTSTR)szEoo;
                    } else {
                        INT lStrLength;
                        lStrLength = ( (INT)((UINT_PTR)szEoo - (UINT_PTR)pszDataW) ) / sizeof ( WCHAR ) ;
                       
						// Add string length to original buffer pointer
                        rpszNextData = (LPTSTR)((LPSTR)pszData + lStrLength);
                    }
				}
            } else {
                dwStatus = LOGMAN_NO_SYSMON_OBJECT;
            }
        } else {
            dwStatus = LOGMAN_NO_SYSMON_OBJECT;
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    return dwStatus;
}

void
CPropertyBag::DataListAddHead ( PPARAM_DATA pData ) 
{

    assert ( NULL != pData );

    pData->pNextParam = m_plistData;
    m_plistData = pData;
    return;
}

CPropertyBag::PPARAM_DATA
CPropertyBag::DataListRemoveHead ( ) 
{
    PPARAM_DATA pReturnData;

    pReturnData = m_plistData;
    
    if ( NULL != m_plistData )
        m_plistData = m_plistData->pNextParam;
    
    return pReturnData;
}


CPropertyBag::PPARAM_DATA
CPropertyBag::FindProperty ( LPCWSTR pszPropName ) 
{
    PPARAM_DATA pReturnData;

    pReturnData = m_plistData;
    
    while ( NULL != pReturnData ) {
        if ( 0 == lstrcmpiW ( pszPropName, pReturnData->pszPropertyName ) )
            break;
        pReturnData = pReturnData->pNextParam;
    }

    return pReturnData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifndef _STDAFX_H_ 
#define _STDAFX_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <assert.h>
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <pdh.h>
#include <wtypes.h> 
#include "common.h"

#endif // ifndef _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\strids.h ===
/*++

Copyright (C) 1999-2000 Microsoft Corporation

Module Name:

    strids.h

Abstract:

    This file contains constants for all of the resource strings. It must
    parallel file strings.rc which contains the strings themselves.

    Constants of the form IDS_*_BASE are not strings but are base values
    for use in indexing within the string group. The base value must match the
    ID of the first string and the order of the strings must not be changed.

--*/

#ifndef _STRIDS_H_
#define _STRIDS_H_

#define HTML_MIN_ID         200
// Error Messages



#define IDS_HTML_FILE               210
#define IDS_HTML_EXTENSION          211
#define IDS_HTML_FILE_HEADER1       212
#define IDS_HTML_FILE_HEADER2       213
#define IDS_HTML_FILE_FOOTER        214
#define IDS_HTML_FILE_OVERWRITE     215

#define RCSTRING_MIN_ID             400

#endif // _STRIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\resource.h ===
#define    IDS_HELP_COMPUTER        110
#define    IDS_ARG1_COMPUTER        111
#define    IDS_ARG2_COMPUTER        112

#define    IDS_HELP_START           113
#define    IDS_ARG1_START           114
#define    IDS_ARG2_START           115

#define    IDS_HELP_STOP            116
#define    IDS_ARG1_STOP            117
#define    IDS_ARG2_STOP            118

#define    IDS_HELP_SETTINGS        119
#define    IDS_ARG1_SETTINGS        120
#define    IDS_ARG2_SETTINGS        121

#define    IDS_HELP_NAME            131
#define    IDS_ARG1_NAME            132
#define    IDS_ARG2_NAME            133

#define    IDS_HELP_OVER            134
#define    IDS_ARG1_OVER            135
#define    IDS_ARG2_OVER            136
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\strings.cpp ===
/*++

Copyright (C) 1999-2000 Microsoft Corporation

Module Name:

    strings.c

Abstract:

    String constants used by the functions in the logman program

--*/

#include "stdafx.h"

//LPCWSTR    cszAppShortName = (LPCWSTR)L"LOGMAN";

// Command parameter strings
/*
LPCTSTR     cszQuestionMark = TEXT("?");
LPCTSTR     cszComputerName = TEXT("computer");
LPCTSTR     cszSettings = TEXT("settings");
LPCTSTR     cszOverwrite = TEXT("overwrite");
LPCTSTR     cszStart = TEXT("start");
LPCTSTR     cszStop = TEXT("stop");
LPCTSTR     cszParamDelimiters = TEXT(" =\":");
*/
LPCTSTR     cszComputerNameDelimiters = TEXT(" =\"\\:"); 
LPCTSTR     cszLogNameDelimiters = TEXT(" =\"\\:"); 
LPCTSTR     cszFileNameDelimiters = TEXT("=\"");
LPCTSTR     cszComputerNameInvalidChars = TEXT("/");        // Todo:  Any others?
LPCTSTR     cszFilePathInvalidChars = TEXT("/\"");            // Todo:  Need separate check for file name chars
LPCTSTR     cszLogNameInvalidChars = TEXT("\\ /:*?\"<>|.");

// Registry path, key and value strings

// Registry key strings
LPCWSTR cwszRegKeySysmonLog         = (LPCWSTR)L"System\\CurrentControlSet\\Services\\SysmonLog";
LPCWSTR cwszRegKeyFullLogQueries    = (LPCWSTR)L"System\\CurrentControlSet\\Services\\SysmonLog\\Log Queries";
LPCWSTR cwszRegKeyLogQueries        = (LPCWSTR)L"Log Queries";

// Registry property key strings
LPCWSTR cwszRegComment             = (LPCWSTR)L"Comment";
LPCWSTR cwszRegLogType             = (LPCWSTR)L"Log Type"; 
LPCWSTR cwszRegCurrentState        = (LPCWSTR)L"Current State"; 
LPCWSTR cwszRegLogFileMaxSize      = (LPCWSTR)L"Log File Max Size"; 
LPCWSTR cwszRegLogFileBaseName     = (LPCWSTR)L"Log File Base Name"; 
LPCWSTR cwszRegLogFileFolder       = (LPCWSTR)L"Log File Folder"; 
LPCWSTR cwszRegLogFileSerialNumber = (LPCWSTR)L"Log File Serial Number"; 
LPCWSTR cwszRegLogFileAutoFormat   = (LPCWSTR)L"Log File Auto Format"; 
LPCWSTR cwszRegLogFileType         = (LPCWSTR)L"Log File Type"; 
LPCWSTR cwszRegStartTime           = (LPCWSTR)L"Start"; 
LPCWSTR cwszRegStopTime            = (LPCWSTR)L"Stop"; 
LPCWSTR cwszRegRestart             = (LPCWSTR)L"Restart"; 
LPCWSTR cwszRegLastModified        = (LPCWSTR)L"Last Modified"; 
LPCWSTR cwszRegCounterList         = (LPCWSTR)L"Counter List"; 
LPCWSTR cwszRegSampleInterval      = (LPCWSTR)L"Sample Interval"; 
LPCWSTR cwszRegEofCommandFile      = (LPCWSTR)L"EOF Command File"; 
LPCWSTR cwszRegCommandFile         = (LPCWSTR)L"Command File"; 
LPCWSTR cwszRegNetworkName         = (LPCWSTR)L"Network Name"; 
LPCWSTR cwszRegUserText            = (LPCWSTR)L"User Text"; 
LPCWSTR cwszRegPerfLogName         = (LPCWSTR)L"Perf Log Name"; 
LPCWSTR cwszRegActionFlags         = (LPCWSTR)L"Action Flags"; 
LPCWSTR cwszRegTraceBufferSize     = (LPCWSTR)L"Trace Buffer Size"; 
LPCWSTR cwszRegTraceBufferMinCount = (LPCWSTR)L"Trace Buffer Min Count"; 
LPCWSTR cwszRegTraceBufferMaxCount = (LPCWSTR)L"Trace Buffer Max Count"; 
LPCWSTR cwszRegTraceBufferFlushInt = (LPCWSTR)L"Trace Buffer Flush Interval"; 
LPCWSTR cwszRegTraceFlags          = (LPCWSTR)L"Trace Flags"; 
LPCWSTR cwszRegTraceProviderList   = (LPCWSTR)L"Trace Provider List"; 

LPCWSTR cwszRegAlertThreshold      = (LPCWSTR)L"Counter%05d.AlertThreshold"; 
LPCWSTR cwszRegAlertOverUnder      = (LPCWSTR)L"Counter%05d.AlertOverUnder"; 
//LPCWSTR cwszRegTraceProviderCount  = (LPCWSTR)L"TraceProviderCount"; 
//LPCWSTR cwszRegTraceProviderGuid   = (LPCWSTR)L"TraceProvider%05d.Guid"; 

// Properties in registry but not in HTML file
LPCWSTR cwszRegExecuteOnly     = (LPCWSTR)L"ExecuteOnly"; 

// HTML strings
LPCWSTR cwszHtmlObjectClassId  = (LPCWSTR)L"C4D2D8E0-D1DD-11CE-940F-008029004347";
LPCWSTR cwszHtmlObjectHeader   = (LPCWSTR)L"<OBJECT ID=\"DISystemMonitor1\" WIDTH=\"100%\" HEIGHT=\"100%\"\r\nCLASSID=\"CLSID:C4D2D8E0-D1DD-11CE-940F-008029004347\">\r\n";
LPCWSTR cwszHtmlObjectFooter   = (LPCWSTR)L"</OBJECT>";
LPCWSTR cwszHtmlParamTag       = (LPCWSTR)L"\t<PARAM NAME=\"";
LPCWSTR cwszHtmlValueTag       = (LPCWSTR)L"\" VALUE=\"";
LPCWSTR cwszHtmlParamSearchTag = (LPCWSTR)L"PARAM NAME";
LPCWSTR cwszHtmlValueSearchTag = (LPCWSTR)L"VALUE";
LPCWSTR cwszHtmlValueEolTag    = (LPCWSTR)L"\">\r\n";

LPCWSTR cwszHtmlComment             = (LPCWSTR)L"Comment";
LPCWSTR cwszHtmlLogType             = (LPCWSTR)L"LogType";
LPCWSTR cwszHtmlCurrentState        = (LPCWSTR)L"CurrentState";
LPCWSTR cwszHtmlLogFileMaxSize      = (LPCWSTR)L"LogFileMaxSize";
LPCWSTR cwszHtmlLogFileBaseName     = (LPCWSTR)L"LogFileBaseName";
LPCWSTR cwszHtmlLogFileFolder       = (LPCWSTR)L"LogFileFolder";
LPCWSTR cwszHtmlLogFileSerialNumber = (LPCWSTR)L"LogFileSerialNumber";
LPCWSTR cwszHtmlLogFileAutoFormat   = (LPCWSTR)L"LogFileAutoFormat";
LPCWSTR cwszHtmlLogFileType         = (LPCWSTR)L"LogFileType";
LPCWSTR cwszHtmlEofCommandFile      = (LPCWSTR)L"EOFCommandFile";
LPCWSTR cwszHtmlCommandFile         = (LPCWSTR)L"CommandFile";
LPCWSTR cwszHtmlNetworkName         = (LPCWSTR)L"NetworkName";
LPCWSTR cwszHtmlUserText            = (LPCWSTR)L"UserText";
LPCWSTR cwszHtmlPerfLogName         = (LPCWSTR)L"PerfLogName";
LPCWSTR cwszHtmlActionFlags         = (LPCWSTR)L"ActionFlags";
LPCWSTR cwszHtmlTraceBufferSize     = (LPCWSTR)L"TraceBufferSize";
LPCWSTR cwszHtmlTraceBufferMinCount = (LPCWSTR)L"TraceBufferMinCount";
LPCWSTR cwszHtmlTraceBufferMaxCount = (LPCWSTR)L"TraceBufferMaxCount";
LPCWSTR cwszHtmlTraceBufferFlushInt = (LPCWSTR)L"TraceBufferFlushInterval";
LPCWSTR cwszHtmlTraceFlags          = (LPCWSTR)L"TraceFlags";
LPCWSTR cwszHtmlSysmonLogFileName   = (LPCWSTR)L"LogFileName";
LPCWSTR cwszHtmlSysmonCounterCount  = (LPCWSTR)L"CounterCount";
LPCWSTR cwszHtmlSysmonSampleCount   = (LPCWSTR)L"SampleCount";
LPCWSTR cwszHtmlSysmonUpdateInterval= (LPCWSTR)L"UpdateInterval";
LPCWSTR cwszHtmlSysmonCounterPath   = (LPCWSTR)L"Counter%05d.Path";
LPCWSTR cwszHtmlRestartMode         = (LPCWSTR)L"RestartMode";
LPCWSTR cwszHtmlSampleIntUnitType   = (LPCWSTR)L"SampleIntervalUnitType";
LPCWSTR cwszHtmlSampleIntValue      = (LPCWSTR)L"SampleIntervalValue";
LPCWSTR cwszHtmlStartMode           = (LPCWSTR)L"StartMode";
LPCWSTR cwszHtmlStartAtTime         = (LPCWSTR)L"StartAtTime";
LPCWSTR cwszHtmlStopMode            = (LPCWSTR)L"StopMode";
LPCWSTR cwszHtmlStopAtTime          = (LPCWSTR)L"StopAtTime";
LPCWSTR cwszHtmlStopAfterUnitType   = (LPCWSTR)L"StopAfterUnitType";
LPCWSTR cwszHtmlStopAfterValue      = (LPCWSTR)L"StopAfterValue";    
LPCWSTR cwszHtmlAlertThreshold      = (LPCWSTR)L"Counter%05d.AlertThreshold";
LPCWSTR cwszHtmlAlertOverUnder      = (LPCWSTR)L"Counter%05d.AlertOverUnder";
LPCWSTR cwszHtmlTraceProviderCount  = (LPCWSTR)L"TraceProviderCount";
LPCWSTR cwszHtmlTraceProviderGuid   = (LPCWSTR)L"TraceProvider%05d.Guid";
LPCWSTR cwszHtmlLogName             = (LPCWSTR)L"LogName";
LPCWSTR cwszHtmlAlertName           = (LPCWSTR)L"AlertName";
LPCWSTR cwszHtmlSysmonVersion       = (LPCWSTR)L"_Version";

// other general strings
LPCWSTR cwszNewLine                 = (LPCWSTR)L"\n";
LPCWSTR cwszQuote                   = (LPCWSTR)L"\"";
LPCWSTR cwszNull                    = (LPCWSTR)L"";
LPCWSTR cwszGreaterThan             = (LPCWSTR)L">";
LPCWSTR cwszLessThan                = (LPCWSTR)L"<";
LPCWSTR cwszAlertFormatString       = (LPCWSTR)L"%s%s%0.23g";
LPCWSTR cwszMissingResourceString   = (LPCWSTR)L"????";
LPCWSTR cwszMessageIdFormatString   = (LPCWSTR)L"0x%08lX";
LPCWSTR cwszPdhDll                  = (LPCWSTR)L"PDH.DLL";
LPCWSTR cwszDefaultLogFileFolder    = (LPCWSTR)L"%SystemDrive%\\PerfLogs";
LPCWSTR cwszNoErrorMessage          = (LPCWSTR)L"Unable to access LogMan error message.";
LPCWSTR cwszLogService              = (LPCWSTR)L"SysmonLog";
LPCWSTR cwszSystemError             = (LPCWSTR)L"System Error: %s";
LPCWSTR cwszLocalComputer           = (LPCWSTR)L"local computer";
LPCWSTR cwszGuidFormat              = (LPCWSTR)L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}";

// strings only used in DEBUG builds
#ifdef _DEBUG
//LPCWSTR    cszNameDontMatch = (LPCWSTR)L"Last Machine Name does not match the current selection";
//LPCWSTR    cszNotice = (LPCWSTR)L"Notice!";
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\strings.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    strings.h

Abstract:

    String constants used by the functions in the PDH.DLL library

--*/

#ifndef _LOGMAN_STRINGS_H_
#define _LOGMAN_STRINGS_H_

#define POUNDSIGN_W     ((WCHAR)L'#')
#define SPLAT_W         ((WCHAR)L'*')
#define SLASH_W         ((WCHAR)L'/')
#define BACKSLASH_W     ((WCHAR)L'\\')
#define LEFTPAREN_W     ((WCHAR)L'(')
#define RIGHTPAREN_W    ((WCHAR)L')')
#define SPACE_W         ((WCHAR)L' ')
#define COLON_W         ((WCHAR)L':')
#define ATSIGN_W		((WCHAR)L'@')
#define NULL_W		    ((WCHAR)L'\0')

#define SLASH_T         ((TCHAR)_T('/'))
#define QUESTION_T      ((TCHAR)_T('?'))
#define NULL_T          ((TCHAR)_T('\0'))
#define COLON_T         ((TCHAR)_T(':'))
#define SPACE_T         ((TCHAR)_T(' '))
#define BACKSLASH_T     ((TCHAR)_T('\\'))

// extern LPCWSTR    cszAppShortName;

// Command parameter strings
extern LPCTSTR  cszQuestionMark;
extern LPCTSTR  cszComputerName;
extern LPCTSTR  cszSettings;
extern LPCTSTR  cszOverwrite;
extern LPCTSTR  cszStart;
extern LPCTSTR  cszStop;
extern LPCTSTR  cszParamDelimiters;
extern LPCTSTR  cszComputerNameDelimiters;
extern LPCTSTR  cszLogNameDelimiters;
extern LPCTSTR  cszFileNameDelimiters;
extern LPCTSTR  cszComputerNameInvalidChars;
extern LPCTSTR  cszFilePathInvalidChars;
extern LPCTSTR  cszLogNameInvalidChars;

// registry path, key and value strings
extern LPCWSTR cwszRegKeySysmonLog;
extern LPCWSTR cwszRegKeyFullLogQueries; 
extern LPCWSTR cwszRegKeyLogQueries; 

// Property/Parameter names for HTML files and registry
extern LPCWSTR cwszRegComment;             
extern LPCWSTR cwszRegLogType;               
extern LPCWSTR cwszRegCurrentState;        
extern LPCWSTR cwszRegLogFileMaxSize;        
extern LPCWSTR cwszRegLogFileBaseName;       
extern LPCWSTR cwszRegLogFileFolder;        
extern LPCWSTR cwszRegLogFileSerialNumber;   
extern LPCWSTR cwszRegLogFileAutoFormat;     
extern LPCWSTR cwszRegLogFileType;           
extern LPCWSTR cwszRegStartTime;             
extern LPCWSTR cwszRegStopTime;              
extern LPCWSTR cwszRegRestart;               
extern LPCWSTR cwszRegLastModified;          
extern LPCWSTR cwszRegCounterList;           
extern LPCWSTR cwszRegSampleInterval;        
extern LPCWSTR cwszRegEofCommandFile;        
extern LPCWSTR cwszRegCommandFile;           
extern LPCWSTR cwszRegNetworkName;           
extern LPCWSTR cwszRegUserText;              
extern LPCWSTR cwszRegPerfLogName;           
extern LPCWSTR cwszRegActionFlags;           
extern LPCWSTR cwszRegTraceBufferSize;       
extern LPCWSTR cwszRegTraceBufferMinCount;   
extern LPCWSTR cwszRegTraceBufferMaxCount;   
extern LPCWSTR cwszRegTraceBufferFlushInt;   
extern LPCWSTR cwszRegTraceFlags;            
extern LPCWSTR cwszRegTraceProviderList;     
extern LPCWSTR cwszRegAlertThreshold;        
extern LPCWSTR cwszRegAlertOverUnder;        
//extern LPCWSTR cwszRegTraceProviderCount;    
//extern LPCWSTR cwszRegTraceProviderGuid;     

// Properties in registry but not in HTML files
extern LPCWSTR cwszRegExecuteOnly;

// HTML strings
extern LPCWSTR cwszHtmlObjectClassId;
extern LPCWSTR cwszHtmlObjectHeader;
extern LPCWSTR cwszHtmlObjectFooter;   
extern LPCWSTR cwszHtmlParamTag;       
extern LPCWSTR cwszHtmlValueTag;       
extern LPCWSTR cwszHtmlParamSearchTag; 
extern LPCWSTR cwszHtmlValueSearchTag;
extern LPCWSTR cwszHtmlValueEolTag;    

extern LPCWSTR cwszHtmlComment;                     
extern LPCWSTR cwszHtmlLogType;                     
extern LPCWSTR cwszHtmlCurrentState;                
extern LPCWSTR cwszHtmlLogFileMaxSize;              
extern LPCWSTR cwszHtmlLogFileBaseName;             
extern LPCWSTR cwszHtmlLogFileFolder;               
extern LPCWSTR cwszHtmlLogFileSerialNumber;         
extern LPCWSTR cwszHtmlLogFileAutoFormat;           
extern LPCWSTR cwszHtmlLogFileType;                 
extern LPCWSTR cwszHtmlEofCommandFile;              
extern LPCWSTR cwszHtmlCommandFile;                 
extern LPCWSTR cwszHtmlNetworkName;                 
extern LPCWSTR cwszHtmlUserText;                    
extern LPCWSTR cwszHtmlPerfLogName;                 
extern LPCWSTR cwszHtmlActionFlags;                 
extern LPCWSTR cwszHtmlTraceBufferSize;             
extern LPCWSTR cwszHtmlTraceBufferMinCount;         
extern LPCWSTR cwszHtmlTraceBufferMaxCount;         
extern LPCWSTR cwszHtmlTraceBufferFlushInt;         
extern LPCWSTR cwszHtmlTraceFlags;                  
extern LPCWSTR cwszHtmlSysmonLogFileName;                         
extern LPCWSTR cwszHtmlSysmonCounterCount;          
extern LPCWSTR cwszHtmlSysmonSampleCount;           
extern LPCWSTR cwszHtmlSysmonUpdateInterval;        
extern LPCWSTR cwszHtmlSysmonCounterPath;           
extern LPCWSTR cwszHtmlRestartMode;                                  
extern LPCWSTR cwszHtmlSampleIntUnitType;                             
extern LPCWSTR cwszHtmlSampleIntValue;                                
extern LPCWSTR cwszHtmlStartMode;                                     
extern LPCWSTR cwszHtmlStartAtTime;                                  
extern LPCWSTR cwszHtmlStopMode;                                      
extern LPCWSTR cwszHtmlStopAtTime;                                    
extern LPCWSTR cwszHtmlStopAfterUnitType;                              
extern LPCWSTR cwszHtmlStopAfterValue;                                
extern LPCWSTR cwszHtmlAlertThreshold;              
extern LPCWSTR cwszHtmlAlertOverUnder;              
extern LPCWSTR cwszHtmlTraceProviderCount;          
extern LPCWSTR cwszHtmlTraceProviderGuid;           
extern LPCWSTR cwszHtmlLogName;                     
extern LPCWSTR cwszHtmlAlertName;                   
extern LPCWSTR cwszHtmlSysmonVersion;               

// Other general strings
extern LPCWSTR cwszNewLine;
extern LPCWSTR cwszNull;
extern LPCWSTR cwszQuote;
extern LPCWSTR cwszGreaterThan;
extern LPCWSTR cwszLessThan;
extern LPCWSTR cwszAlertFormatString;
extern LPCWSTR cwszMissingResourceString;
extern LPCWSTR cwszMessageIdFormatString;
extern LPCWSTR cwszPdhDll;
extern LPCWSTR cwszDefaultLogFileFolder;
extern LPCWSTR cwszNoErrorMessage;
extern LPCWSTR cwszLogService;
extern LPCWSTR cwszSystemError;
extern LPCWSTR cwszLocalComputer;  
extern LPCWSTR cwszGuidFormat;  


// strings only used in DEBUG builds
#ifdef _DEBUG
//extern LPCWSTR    cszNameDontMatch;
//extern LPCWSTR    cszNotice;
#endif

#endif //_LOGMAN_STRINGS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\proputil.cpp ===
/*++

Copyright (C) 1999-2000 Microsoft Corporation

Module Name:

    proputil.cpp

Abstract:

    This file contains all static data related to log and alert properties, 
    along with routines to access that data.

--*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include "stdafx.h"
#include "strings.h"
#include "logmmsg.h"
#include "propbag.h"
#include "utils.h"
#include "proputil.h"

//==========================================================================//
//                              Constants and Types                         //
//==========================================================================//

// Property constants represent indexes into the static PropertyDataMap table.
const DWORD IdFirstProp	        	    =  0; 
  		              
// The property constants in this first section have a one-to-one 
// correspondence between HTML parameter and registry value
const DWORD IdCommentProp	        	= IdFirstProp +  0;   		                
const DWORD IdLogTypeProp		        = IdFirstProp +  1;   		                
const DWORD IdCurrentStateProp		    = IdFirstProp +  2;                 
const DWORD IdLogFileMaxSizeProp		= IdFirstProp +  3;   	         
const DWORD IdLogFileBaseNameProp		= IdFirstProp +  4;  	        
const DWORD IdLogFileFolderProp		    = IdFirstProp +  5;   	          
const DWORD IdLogFileSerialNumberProp	= IdFirstProp +  6;   
const DWORD IdLogFileAutoFormatProp		= IdFirstProp +  7;       
const DWORD IdLogFileTypeProp		    = IdFirstProp +  8;   	            
const DWORD IdEofCommandFileProp		= IdFirstProp +  9;   	         
const DWORD IdCommandFileProp		    = IdFirstProp + 10;   		            
const DWORD IdNetworkNameProp		    = IdFirstProp + 11;   		            
const DWORD IdUserTextProp		        = IdFirstProp + 12;   		                   
const DWORD IdPerfLogNameProp	    	= IdFirstProp + 13;   		            
const DWORD IdTraceBufferSizeProp		= IdFirstProp + 14;   	        
const DWORD IdTraceBufferMinCountProp	= IdFirstProp + 15;     
const DWORD IdTraceBufferMaxCountProp	= IdFirstProp + 16;     
const DWORD IdTraceBufferFlushIntProp	= IdFirstProp + 17;
const DWORD IdActionFlagsProp		    = IdFirstProp + 18;   		            
const DWORD IdTraceFlagsProp		    = IdFirstProp + 19;

// Property constants below require special handling for BagToRegistry,
// because there is not a one-to-one correspondence between HTML
// parameter and registry value.      
const DWORD IdRestartProp		        = IdFirstProp + 20;   	                                 
const DWORD IdStartProp		            = IdFirstProp + 21;   	                                 
const DWORD IdStopProp		            = IdFirstProp + 22;   	                                 
const DWORD IdSampleProp		        = IdFirstProp + 23;   	                                 
const DWORD IdCounterListProp           = IdFirstProp + 24;
const DWORD IdGuidListProp              = IdFirstProp + 25;

const DWORD IdLastProp                  = IdFirstProp + 25;  		

/*
// Not handled yet, or covered by special values above.
// Some of these might be needed when writing to HTML file from registry.
//
const DWORD IdSysmonVersionProp		    = IdFirstProp + 29;  
 		      
const DWORD IdSysmonCounterCountProp	= IdFirstProp + 29;       
const DWORD IdSysmonCounterPathProp		= IdFirstProp + 21;   	  
const DWORD IdAlertThresholdProp		= IdFirstProp + 23;  		     
const DWORD IdAlertOverUnderProp		= IdFirstProp + 24;   		     
const DWORD IdTraceProviderCountProp	= IdFirstProp + 25;   	 
const DWORD IdTraceProviderGuidProp		= IdFirstProp + 26;   	  

const DWORD IdLogNameProp		        = IdFirstProp + 27;   		                    
const DWORD IdAlertNameProp		        = IdFirstProp + 28;   		              
const DWORD IdStartModeProp		        = SLQ_TT_TTYPE_LAST + ;   		                                
const DWORD IdStartAtTimeProp		    = SLQ_TT_TTYPE_LAST + ;   		                             
const DWORD IdStopModeProp		        = SLQ_TT_TTYPE_LAST + ;   		                                     
const DWORD IdStopAtTimeProp		    = SLQ_TT_TTYPE_LAST + ;   		                               
const DWORD IdStopAfterUnitTypeProp		= SLQ_TT_TTYPE_LAST + ;   	                     
const DWORD IdStopAfterValueProp		= SLQ_TT_TTYPE_LAST + ;   		                       
const DWORD IdSampleIntUnitTypeProp		= IdFirstProp + 21;   	                    
const DWORD IdSampleIntValueProp		= IdFirstProp + 21;   		                       
const DWORD IdSysmonUpdateIntervalProp	= SLQ_TT_TTYPE_LAST + ;     

const DWORD IdSysmonSampleCountProp		= IdFirstProp + 20;         
const DWORD IdSysmonLogFileNameProp		= IdFirstProp + 18;                       

const DWORD IdExecuteOnlyProp		    = IdFirstProp + 30; 
*/

//==========================================================================//
//                              Local Constants                             //
//==========================================================================//

const DWORD cdwFortyfiveDays    =  ((DWORD)(0xE7BE2C00));
const WORD  cwFirstValidYear    =  ((DWORD)(2000));
const DWORD cdwNoMaxSizeLimit   =  ((DWORD)(0xFFFFFFFF));   		                
const DWORD cdwNoRange          =  ((DWORD)(0xFFFFFFFF));   		                
const DWORD cdwSeverityMask     =  ((DWORD)(0xC0000000));   		                

const CPropertyUtils::PROPERTY_DATA_MAP CPropertyUtils::m_PropertyDataMap[] = 
{
    {IdCommentProp,             REG_SZ,     cwszHtmlComment,            cwszRegComment
        ,(ValidationMethod)ValidateString           ,FALSE  ,NULL               ,NULL },
    {IdLogTypeProp,             REG_DWORD,  cwszHtmlLogType,            cwszRegLogType              
        ,(ValidationMethod)ValidateDwordInterval    ,TRUE   ,SLQ_FIRST_LOG_TYPE ,SLQ_LAST_LOG_TYPE },
    {IdCurrentStateProp,        REG_DWORD,  cwszHtmlCurrentState,       cwszRegCurrentState         
        ,(ValidationMethod)ValidateDwordInterval    ,FALSE  ,SLQ_QUERY_STOPPED  ,SLQ_QUERY_RUNNING },
    {IdLogFileMaxSizeProp,      REG_DWORD,  cwszHtmlLogFileMaxSize,     cwszRegLogFileMaxSize       
        ,(ValidationMethod)ValidateMaxFileSize      ,FALSE  ,1                  ,0x0100000 },
    {IdLogFileBaseNameProp,     REG_SZ,     cwszHtmlLogFileBaseName,    cwszRegLogFileBaseName      
        ,(ValidationMethod)ValidateFileName         ,FALSE  ,NULL               ,NULL },
    {IdLogFileFolderProp,       REG_SZ,     cwszHtmlLogFileFolder,      cwszRegLogFileFolder        
        ,(ValidationMethod)ValidateDirectoryPath    ,FALSE  ,NULL               ,NULL },
    {IdLogFileSerialNumberProp, REG_DWORD,  cwszHtmlLogFileSerialNumber,cwszRegLogFileSerialNumber  
        ,(ValidationMethod)ValidateDwordInterval    ,FALSE  ,0                  ,999999 },
	{IdLogFileAutoFormatProp,   REG_DWORD,  cwszHtmlLogFileAutoFormat,	cwszRegLogFileAutoFormat    
        ,(ValidationMethod)ValidateDwordInterval    ,FALSE  ,0                  ,1 },	
    {IdLogFileTypeProp,		    REG_DWORD,  cwszHtmlLogFileType,        cwszRegLogFileType          
        ,(ValidationMethod)ValidateLogFileType      ,FALSE  ,cdwNoRange         ,cdwNoRange },
	{IdEofCommandFileProp,		REG_SZ,     cwszHtmlEofCommandFile,     cwszRegEofCommandFile       
        ,(ValidationMethod)ValidateFilePath         ,FALSE  ,NULL               ,NULL },  
	{IdCommandFileProp,		    REG_SZ,     cwszHtmlCommandFile,        cwszRegCommandFile          
        ,(ValidationMethod)ValidateFilePath         ,FALSE  ,NULL               ,NULL },
    {IdNetworkNameProp,		    REG_SZ,     cwszHtmlNetworkName,        cwszRegNetworkName          
        ,(ValidationMethod)ValidateString           ,TRUE   ,NULL               ,NULL },    
	{IdUserTextProp,		    REG_SZ,     cwszHtmlUserText,           cwszRegUserText             
        ,(ValidationMethod)ValidateString           ,FALSE  ,NULL               ,NULL },
	{IdPerfLogNameProp,	    	REG_SZ,     cwszHtmlPerfLogName,        cwszRegPerfLogName          
        ,(ValidationMethod)ValidateLogExists        ,FALSE  ,NULL               ,NULL },
	{IdTraceBufferSizeProp,		REG_DWORD,  cwszHtmlTraceBufferSize,    cwszRegTraceBufferSize      
        ,(ValidationMethod)ValidateDwordInterval    ,FALSE  ,1                  ,1024 },
	{IdTraceBufferMinCountProp,	REG_DWORD,  cwszHtmlTraceBufferMinCount,cwszRegTraceBufferMinCount  
        ,(ValidationMethod)ValidateDwordInterval    ,FALSE  ,2                  ,400 },
    {IdTraceBufferMaxCountProp,	REG_DWORD,  cwszHtmlTraceBufferMaxCount,cwszRegTraceBufferMaxCount  
        ,(ValidationMethod)ValidateTraceBufferMaxCount,FALSE,2                  ,400 },
	{IdTraceBufferFlushIntProp,	REG_DWORD,  cwszHtmlTraceBufferFlushInt,cwszRegTraceBufferFlushInt  
        ,(ValidationMethod)ValidateDwordInterval    ,FALSE  ,0                  ,300 },
    {IdActionFlagsProp,         REG_DWORD,  cwszHtmlActionFlags,        cwszRegActionFlags          
        ,(ValidationMethod)ValidateAlertActions     ,FALSE  ,cdwNoRange         ,cdwNoRange },
    {IdTraceFlagsProp,          REG_DWORD,  cwszHtmlTraceFlags,         cwszRegTraceFlags           
        ,(ValidationMethod)ValidateTraceFlags       ,FALSE  ,cdwNoRange         ,cdwNoRange },
    {IdRestartProp,             REG_BINARY, cwszHtmlRestartMode,        cwszRegRestart              
        ,(ValidationMethod)ValidateSlqTimeInfo      ,FALSE  ,0                  ,1 },
    {IdStartProp,               REG_BINARY  ,NULL,                      cwszRegStartTime            
        ,(ValidationMethod)ValidateSlqTimeInfo      ,FALSE  ,cdwNoRange         ,cdwNoRange },
    {IdStopProp,                REG_BINARY  ,NULL,                      cwszRegStopTime             
        ,(ValidationMethod)ValidateSlqTimeInfo      ,FALSE  ,cdwNoRange         ,cdwNoRange },
    {IdSampleProp,              REG_BINARY  ,NULL,                      cwszRegSampleInterval       
        ,(ValidationMethod)ValidateSlqTimeInfo      ,FALSE  ,cdwNoRange         ,cdwNoRange },
    {IdCounterListProp,         REG_MULTI_SZ,NULL,                      NULL                        
        ,(ValidationMethod)ValidatePrimaryObjectList,TRUE   ,cdwNoRange         ,cdwNoRange },
    {IdGuidListProp,            REG_MULTI_SZ,NULL,                      NULL                        
        ,(ValidationMethod)ValidatePrimaryObjectList,FALSE  ,cdwNoRange         ,cdwNoRange }

};

const DWORD CPropertyUtils::m_dwPropertyDataMapEntries 
                = sizeof(CPropertyUtils::m_PropertyDataMap)/sizeof(CPropertyUtils::m_PropertyDataMap[0]);                
                

//==========================================================================//
//                              Friend Functions                            //
//==========================================================================//
    
DWORD 
ValidateDwordInterval (
    CPropertyUtils* pUtils,
    DWORD   dwPropId,
    DWORD   /* dwLogType */)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr;
    DWORD   dwValue;

    hr = DwordFromPropertyBag ( 
            pUtils->m_pPropBag, 
            CPropertyUtils::m_PropertyDataMap[dwPropId].cwszHtmlName, 
            dwValue );
    
    if ( SUCCEEDED ( hr ) ) {
        if ( ( dwValue < CPropertyUtils::m_PropertyDataMap[dwPropId].dwMin )
                || (dwValue > CPropertyUtils::m_PropertyDataMap[dwPropId].dwMax ) ) {

            dwStatus = pUtils->GetInvalidStatus ( dwPropId );
        }
    } else {
        dwStatus = pUtils->GetMissingStatus ( dwPropId );
    }

    if ( pUtils->IsDisplayLevelMessage ( dwStatus ) ) {
        if ( pUtils->GetInvalidStatus ( dwPropId ) == dwStatus ) {
            WCHAR   szBufVal [64];
            WCHAR   szBufMin [64];
            WCHAR   szBufMax [64];

            swprintf (szBufVal, L"%ld", dwValue );
            swprintf (szBufMin, L"%ld", CPropertyUtils::m_PropertyDataMap[dwPropId].dwMin );
            swprintf (szBufMax, L"%ld", CPropertyUtils::m_PropertyDataMap[dwPropId].dwMax  );

            DisplayErrorMessage ( 
                LOGMAN_OUT_OF_RANGE, 
                szBufVal, 
                CPropertyUtils::m_PropertyDataMap[dwPropId].cwszHtmlName,
                pUtils->GetQueryName(),
                szBufMin,
                szBufMax );
        } else {
            assert ( pUtils->GetMissingStatus ( dwPropId ) == dwStatus );
            DisplayErrorMessage ( 
                dwStatus, 
                CPropertyUtils::m_PropertyDataMap[dwPropId].cwszHtmlName,
                pUtils->GetQueryName() );
        }
    }

    return dwStatus;
}

DWORD 
ValidatePrimaryObjectList (
    CPropertyUtils* pUtils,
    DWORD   dwPropId,
    DWORD   dwLogType )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr;
    UNICODE_STRING  ustrGuid;
    GUID            guid;
    DWORD   dwCount = 0;
    WCHAR   achInfoBufNew[sizeof(PDH_COUNTER_PATH_ELEMENTS_W) + MAX_PATH + 5];
    PPDH_COUNTER_PATH_ELEMENTS_W pPathInfoNew = (PPDH_COUNTER_PATH_ELEMENTS_W)achInfoBufNew;
    ULONG   ulBufSize;
    DWORD   dwIndex;
    WCHAR   szPropName [MAX_PATH+1];          // Todo: Remove length restriction
    DWORD   dwPropBagStringLen = 0;
    DWORD   dwTemp = 0;
    DOUBLE  dThreshold = 0;

    LPCWSTR szHtmlCountProp = NULL;
    LPCWSTR szHtmlPathProp = NULL;

    assert ( REG_MULTI_SZ == CPropertyUtils::m_PropertyDataMap[dwPropId].dwRegType );

    if ( IdCounterListProp == dwPropId ) {
        if ( SLQ_COUNTER_LOG == dwLogType 
                || SLQ_ALERT == dwLogType ) {
            szHtmlCountProp = cwszHtmlSysmonCounterCount;
            szHtmlPathProp = cwszHtmlSysmonCounterPath;
        } else {
            assert ( FALSE );
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    } else if ( IdGuidListProp == dwPropId ) {
        if ( SLQ_TRACE_LOG == dwLogType ) {
            szHtmlCountProp = cwszHtmlTraceProviderCount;
            szHtmlPathProp = cwszHtmlTraceProviderGuid;
        } else {
            assert ( FALSE );
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    } else {
        assert ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if ( ERROR_SUCCESS == dwStatus ) {
    
        hr = DwordFromPropertyBag (
                pUtils->m_pPropBag,
                szHtmlCountProp,
                dwCount );            // Todo:  Require counter count? Yes for now

        if ( SUCCEEDED ( hr ) ) {

            // Todo:  Add dwCount to properties table?
            if ( 0 < dwCount ) {
                for ( dwIndex = 1; 
                        dwIndex <= dwCount && SUCCEEDED ( hr ); 
                        dwIndex++ ) {

                    swprintf ( szPropName, szHtmlPathProp, dwIndex );

                    hr = StringFromPropBagAlloc ( 
                            pUtils->m_pPropBag, 
                            szPropName, 
                            &pUtils->m_szPropBagBuffer, 
                            &pUtils->m_dwPropBagBufLen,
                            &dwPropBagStringLen );

                    if ( SUCCEEDED (hr ) ) {
                       
                        if ( SLQ_COUNTER_LOG == dwLogType ) {
                            
                            // Validate counter path  
                            ulBufSize = sizeof(achInfoBufNew);
                            ZeroMemory ( achInfoBufNew, ulBufSize );

                            dwStatus = PdhParseCounterPathW(
                                            pUtils->m_szPropBagBuffer, 
                                            pPathInfoNew, 
                                            &ulBufSize, 
                                            0);

                            if ( ERROR_SUCCESS != dwStatus ) {
                                dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                            }
                        } else if ( SLQ_TRACE_LOG == dwLogType ) {

                            // Validate guid
                            // Check to ensure that the length and form are correct
                            ustrGuid.Length = (USHORT)(dwPropBagStringLen*sizeof(WCHAR));
                            ustrGuid.MaximumLength = (USHORT)(dwPropBagStringLen*sizeof(WCHAR));
                            ustrGuid.Buffer = pUtils->m_szPropBagBuffer;
        
                            dwStatus = GuidFromString (&ustrGuid, &guid );

                            if ( ERROR_SUCCESS != dwStatus ) {
                                dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                            }
                            
                        } else if ( SLQ_ALERT == dwLogType ) {
                            // Alert threshold and threshold log values are required.
                            
                            swprintf ( szPropName, cwszHtmlAlertOverUnder, dwIndex );
                            hr = DwordFromPropertyBag ( 
                                    pUtils->m_pPropBag, 
                                    szPropName,
                                    dwTemp );
                        
                            if ( SUCCEEDED (hr ) ) { 
                                if ( ( dwTemp != AIBF_OVER )
                                        && ( dwTemp != AIBF_UNDER ) ) {
                                    dwStatus = LOGMAN_REQUIRED_PROP_INVALID;
                                }
                            } else {
                                dwStatus = LOGMAN_REQUIRED_PROP_MISSING;
                                break;
                            }
                            if ( ERROR_SUCCESS == dwStatus && SUCCEEDED ( hr ) ) {
                                
                                swprintf ( szPropName, cwszHtmlAlertThreshold, dwIndex );

                                hr = DoubleFromPropertyBag ( 
                                        pUtils->m_pPropBag, 
                                        szPropName, 
                                        dThreshold );
                                if ( SUCCEEDED (hr ) ) { 
                                    // Validate threshold value
                                    if ( 0.0 >= dThreshold ) {
                                        dwStatus = LOGMAN_REQUIRED_PROP_INVALID;
                                    }
                                } else {
                                    dwStatus = LOGMAN_REQUIRED_PROP_MISSING;
                                    break;
                                }
                            }
                        } // else invalid log type.                           
                    } else {
                        dwStatus = pUtils->GetMissingStatus ( dwPropId );
                        break;
                    }
                } // for dwIndex
            } else {
                dwStatus = pUtils->GetInvalidStatus ( dwPropId );
            }
            if ( ERROR_SUCCESS != dwStatus ) {
                // Display error, to include property name
            }

        } else {
            //Todo:  Will need to display errors here, in order to include property name
            dwStatus = pUtils->GetMissingStatus ( dwPropId );
        }
    }
    
    // Todo: Display error messages.

    return dwStatus;
}

DWORD 
ValidateSlqTimeInfo (
    CPropertyUtils* pUtils,
    DWORD   dwPropId,
    DWORD   dwLogType )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr = NOERROR;
    SLQ_TIME_INFO   stiData;
    SLQ_TIME_INFO   stiDefault;
    WORD            wTimeType;
    LONGLONG        llmsecs;

    if ( IdRestartProp == dwPropId ) {
        dwStatus = ValidateDwordInterval ( pUtils, dwPropId, dwLogType );
    } else {
        assert ( IdStartProp == dwPropId
                    || IdStopProp == dwPropId
                    || IdSampleProp == dwPropId );

        if ( IdStartProp == dwPropId ) {
            wTimeType = SLQ_TT_TTYPE_START;
        } else if ( IdStopProp == dwPropId ) {
            wTimeType = SLQ_TT_TTYPE_STOP;
        } else {
            assert ( IdSampleProp == dwPropId );
            wTimeType = SLQ_TT_TTYPE_SAMPLE;
        }

        // Initialize time structure to default, in case of missing fields.
        hr = InitDefaultSlqTimeInfo ( 
                dwLogType, 
                wTimeType, 
                &stiDefault );

        if ( SUCCEEDED ( hr ) ) {
            ZeroMemory ( &stiData, sizeof(stiData) );
            hr = SlqTimeFromPropertyBag ( 
                    pUtils->m_pPropBag, 
                    wTimeType,  
                    &stiDefault, 
                    &stiData );
            if ( SUCCEEDED ( hr ) ) {
                if ( IdStartProp == dwPropId ) {
                    if ( SLQ_AUTO_MODE_AT == stiData.dwAutoMode ) {
                        if ( !pUtils->IsValidDateTime ( stiData.llDateTime ) ) {
                            dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                        }
                    } else if ( SLQ_AUTO_MODE_NONE == stiData.dwAutoMode ) {
                        if ( MIN_TIME_VALUE != stiData.llDateTime 
                                && MAX_TIME_VALUE != stiData.llDateTime ) {
                            dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                        }
                    } else {
                        dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                    }
                } else if ( IdStopProp == dwPropId ) {
                    if ( SLQ_AUTO_MODE_AT == stiData.dwAutoMode ) {
                        if ( !pUtils->IsValidDateTime ( stiData.llDateTime ) ) {
                            dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                        }
                        // Todo:  Ensure stop is after start time.
                        // Todo:  Ensure stop is after current time.
                        // Todo:  Ensure session time is >= Sample time
                    } else if ( SLQ_AUTO_MODE_NONE == stiData.dwAutoMode ) {
                        if ( MIN_TIME_VALUE != stiData.llDateTime 
                                && MAX_TIME_VALUE != stiData.llDateTime ) {
                            dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                        }
                    } else if ( SLQ_AUTO_MODE_AFTER == stiData.dwAutoMode ) {
                        if ( SLQ_TT_UTYPE_SECONDS > stiData.dwUnitType
                                || SLQ_TT_UTYPE_DAYS < stiData.dwUnitType ) {
                            dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                        } else {
                            if ( 1 > stiData.dwValue 
                                    || 100000 < stiData.dwValue ) {
                                dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                            }
                        }

                    } else {
                        dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                    }
                } else {
                    assert ( IdSampleProp == dwPropId );
                    if ( SLQ_TT_UTYPE_SECONDS > stiData.dwUnitType
                            || SLQ_TT_UTYPE_DAYS < stiData.dwUnitType ) {
                        dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                    } else {
                        // Sample time interval must be less than or equal to 45 days.
                        if ( SlqTimeToMilliseconds ( &stiData, &llmsecs ) ) {
                            if ( cdwFortyfiveDays < llmsecs ) {
                                dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                            } else {


                            // Todo:  Ensure session time is >= Sample time
       
                            }
                        } else {
                            dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                        }
                    }
                }
            } else {
                dwStatus = pUtils->GetMissingStatus ( dwPropId );
            }
        }
    }
    // Todo: Display error messages here.
    return dwStatus;
}

DWORD 
ValidateMaxFileSize (
    CPropertyUtils* pUtils,
    DWORD   dwPropId,
    DWORD   /* dwLogType */ )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr;
    DWORD   dwValue;

    hr = DwordFromPropertyBag ( 
            pUtils->m_pPropBag, 
            CPropertyUtils::m_PropertyDataMap[dwPropId].cwszHtmlName, 
            dwValue );

    if ( SUCCEEDED ( hr ) ) {
        if ( cdwNoMaxSizeLimit != dwValue ) {
            if ( ( dwValue < CPropertyUtils::m_PropertyDataMap[dwPropId].dwMin )
                    || (dwValue > CPropertyUtils::m_PropertyDataMap[dwPropId].dwMax ) ) {
                dwStatus = pUtils->GetInvalidStatus ( dwPropId );
            } 
        } else {
            hr = DwordFromPropertyBag ( 
                    pUtils->m_pPropBag, 
                    CPropertyUtils::m_PropertyDataMap[IdLogFileTypeProp].cwszHtmlName, 
                    dwValue );
            if ( SUCCEEDED ( hr ) ) {
                if ( SLF_BIN_CIRC_FILE == dwValue 
                        || SLF_CIRC_TRACE_FILE == dwValue ) {
                    dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                }
            } // else, default file type is not circular, so not a problem.
        }
    } else {
        dwStatus = pUtils->GetMissingStatus ( dwPropId );
    }
    // Todo: Display error messages here.

    return dwStatus;
}

DWORD 
ValidateLogFileType (
    CPropertyUtils* pUtils,
    DWORD   dwPropId,
    DWORD   dwLogType )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr;
    DWORD   dwValue;

    assert ( IdLogFileTypeProp == dwPropId );

    hr = DwordFromPropertyBag ( 
            pUtils->m_pPropBag, 
            CPropertyUtils::m_PropertyDataMap[dwPropId].cwszHtmlName, 
            dwValue );

    if ( SUCCEEDED ( hr ) ) {
        if ( SLQ_COUNTER_LOG == dwLogType ) {
            if ( SLF_CSV_FILE != dwValue
                    && SLF_TSV_FILE      != dwValue
                    && SLF_BIN_FILE      != dwValue
                    && SLF_BIN_CIRC_FILE != dwValue ) {
                dwStatus = pUtils->GetInvalidStatus ( dwPropId );
            }
        } else if ( SLQ_TRACE_LOG == dwLogType ) {
            if ( SLF_CIRC_TRACE_FILE != dwValue
                    && SLF_SEQ_TRACE_FILE != dwValue ) {
                dwStatus = pUtils->GetInvalidStatus ( dwPropId );
            }
        } else {
            dwStatus = pUtils->GetInvalidStatus ( dwPropId );
        }
    } else {
        dwStatus = pUtils->GetMissingStatus ( dwPropId );
    }
    // Todo: Display error messages here.

    return dwStatus;
}

DWORD 
ValidateString (
    CPropertyUtils* pUtils,
    DWORD   dwPropId,
    DWORD   /* dwLogType */)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr = NOERROR;
    DWORD   dwPropBagStringLen = 0;

    hr = StringFromPropBagAlloc ( 
            pUtils->m_pPropBag, 
            CPropertyUtils::m_PropertyDataMap[dwPropId].cwszHtmlName, 
            &pUtils->m_szPropBagBuffer, 
            &pUtils->m_dwPropBagBufLen,
            &dwPropBagStringLen );

    // Just check for missing or empty string.
    
    if ( SUCCEEDED ( hr ) ) {
        if ( NULL == pUtils->m_szPropBagBuffer ) {
            dwStatus = pUtils->GetMissingStatus ( dwPropId );
        } else {
            if ( 0 == lstrlenW ( pUtils->m_szPropBagBuffer ) ) {
                dwStatus = pUtils->GetMissingStatus ( dwPropId );
            }
        }
    } else {
        dwStatus = pUtils->GetMissingStatus ( dwPropId );
    }

    // Todo: Display error messages here.
    return dwStatus;
}

DWORD 
ValidateTraceFlags (
    CPropertyUtils* pUtils,
    DWORD   dwPropId,
    DWORD   dwLogType )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr;
    DWORD   dwValue;


    if ( IdTraceFlagsProp == dwPropId && SLQ_TRACE_LOG != dwLogType ) {
        assert ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    } else {
        hr = DwordFromPropertyBag ( 
                pUtils->m_pPropBag, 
                CPropertyUtils::m_PropertyDataMap[dwPropId].cwszHtmlName, 
                dwValue );
    
        if ( SUCCEEDED ( hr ) ) {
            if ( SLQ_TLI_ENABLE_MASK != ( dwValue | SLQ_TLI_ENABLE_MASK ) ) {
                // Too many flags specified.
                dwStatus = pUtils->GetInvalidStatus ( dwPropId );
            }    
        } else {
            dwStatus = pUtils->GetMissingStatus ( dwPropId );
        }
    }
    // Todo: Display error messages here.
    
    return dwStatus;
}

DWORD 
ValidateAlertActions (
    CPropertyUtils* pUtils,
    DWORD   dwPropId,
    DWORD   dwLogType )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr;
    DWORD   dwValue;


    if ( IdActionFlagsProp == dwPropId && SLQ_ALERT != dwLogType ) {
        assert ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    } else {
        hr = DwordFromPropertyBag ( 
                pUtils->m_pPropBag, 
                CPropertyUtils::m_PropertyDataMap[dwPropId].cwszHtmlName, 
                dwValue );
    
        if ( SUCCEEDED ( hr ) ) {
            if ( IdActionFlagsProp == dwPropId ) {
                // Todo: Validate, and check for empty fields.  Yes.
                if ( (0 == dwValue )
                        || ( ALRT_ACTION_MASK != ( dwValue | ALRT_ACTION_MASK ) ) ) {
                    dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                }  

                // No validation for ALRT_ACTION_LOG_EVENT

                if ( ERROR_SUCCESS == dwStatus ) {
                    if ( ALRT_ACTION_SEND_MSG & dwValue ) {
                        dwStatus = pUtils->Validate ( IdNetworkNameProp );
                    }

                    if ( ALRT_ACTION_START_LOG & dwValue ) {
/*
                            // Todo: Validate log existence
                            dwIndividualStatus = 
                                
                                if ( ERROR_SUCCESS != dwIndividualStatus ) {
                                    dwStatus = general failure status
                                }
                        }
*/
                    }

                    if ( ALRT_ACTION_EXEC_CMD & dwValue ) {
                        // Todo: Validate command file
                        if ( 0 == ( dwValue | ALRT_CMD_LINE_MASK ) ) {
                            //dwLocalStatus = pUtils->GetInvalidStatus ( dwPropId );
                            // Todo:  Display error message here.
                        }
                    }
                }

            } else {
                assert ( FALSE );
                hr = E_INVALIDARG;
            }
    
        } else {
            dwStatus = pUtils->GetMissingStatus ( dwPropId );
        }
    }
    // Todo: Display error messages here.
    
    return dwStatus;
}

DWORD 
ValidateDirectoryPath (
    CPropertyUtils* pUtils,
    DWORD   dwPropId,
    DWORD   dwLogType )
{
    DWORD dwStatus = ERROR_SUCCESS;

    // Todo:  Implement
    // Validate the existence of the directory path, if local machine?
    pUtils;
    dwPropId;
    dwLogType;

    // Todo: Display error messages here.
    return dwStatus;
}

DWORD 
ValidateTraceBufferMaxCount (
    CPropertyUtils* pUtils,
    DWORD   dwPropId,
    DWORD   dwLogType )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr;
    DWORD   dwMaxValue;
    DWORD   dwMinValue;

    if ( SLQ_TRACE_LOG == dwLogType 
        && IdTraceBufferMaxCountProp == dwPropId ) {
        hr = DwordFromPropertyBag ( 
                pUtils->m_pPropBag, 
                CPropertyUtils::m_PropertyDataMap[dwPropId].cwszHtmlName, 
                dwMaxValue );

        if ( SUCCEEDED ( hr ) ) {
            if ( ( dwMaxValue < CPropertyUtils::m_PropertyDataMap[dwPropId].dwMin )
                    || (dwMaxValue > CPropertyUtils::m_PropertyDataMap[dwPropId].dwMax ) ) {
                dwStatus = pUtils->GetInvalidStatus ( dwPropId );
            } else {
                hr = DwordFromPropertyBag ( 
                        pUtils->m_pPropBag, 
                        CPropertyUtils::m_PropertyDataMap[IdTraceBufferMinCountProp].cwszHtmlName, 
                        dwMinValue );
                if ( SUCCEEDED ( hr ) ) {
                    if ( dwMinValue > dwMaxValue ) {
                        dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                    }
                } // else no min value specified, and default min is always <= max
            }
        } else {
            dwStatus = pUtils->GetMissingStatus ( dwPropId );
        }
    } else {
        assert ( FALSE );
        hr = E_INVALIDARG;
    }
    // Todo: Display error messages here.
    return dwStatus;
}

DWORD 
ValidateFileName (
    CPropertyUtils* pUtils,
    DWORD   dwPropId,
    DWORD   /* dwLogType */ )
{
    DWORD dwStatus = ERROR_SUCCESS;
    HRESULT hr = NOERROR;
    DWORD   dwPropBagStringLen = 0;

    if ( NULL != pUtils ) {
        hr = StringFromPropBagAlloc ( 
                pUtils->m_pPropBag, 
                CPropertyUtils::m_PropertyDataMap[dwPropId].cwszHtmlName, 
                &pUtils->m_szPropBagBuffer, 
                &pUtils->m_dwPropBagBufLen,
                &dwPropBagStringLen );

        if ( SUCCEEDED ( hr ) ) {
            if ( 0 != dwPropBagStringLen ) {
                if ( !IsValidFileName ( pUtils->m_szPropBagBuffer ) ) {
                    dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                }
            } else {
                dwStatus = pUtils->GetMissingStatus ( dwPropId );
            }
        } else {
            dwStatus = pUtils->GetMissingStatus ( dwPropId );
        }
    } else {
        assert ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    // Todo: Display error messages here.
    return dwStatus;
}

DWORD 
ValidateFilePath (
    CPropertyUtils* pUtils,
    DWORD   dwPropId,
    DWORD   /* dwLogType */ )
{
    DWORD dwStatus = ERROR_SUCCESS;
    HRESULT hr = NOERROR;
    DWORD   dwPropBagStringLen = 0;
    HANDLE hOpenFile = NULL;

    if ( NULL != pUtils ) {
        hr = StringFromPropBagAlloc ( 
                pUtils->m_pPropBag, 
                CPropertyUtils::m_PropertyDataMap[dwPropId].cwszHtmlName, 
                &pUtils->m_szPropBagBuffer, 
                &pUtils->m_dwPropBagBufLen,
                &dwPropBagStringLen );

        if ( SUCCEEDED ( hr ) ) {
            if ( 0 != dwPropBagStringLen ) {
                hOpenFile =  CreateFileW (
                                pUtils->m_szPropBagBuffer,
                                GENERIC_READ,
                                0,              // Not shared
                                NULL,           // Security attributes
                                OPEN_EXISTING,  //
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );

                if ( ( NULL == hOpenFile ) 
                        || INVALID_HANDLE_VALUE == hOpenFile ) {
                    dwStatus = pUtils->GetInvalidStatus ( dwPropId );
                } else {
                    CloseHandle( hOpenFile );
                }
            } else {
                dwStatus = pUtils->GetMissingStatus ( dwPropId );
            }
        } else {
            dwStatus = pUtils->GetMissingStatus ( dwPropId );
        }
    } else {
        assert ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    // Todo: Display error messages here.
    return dwStatus;
}

DWORD 
ValidateLogExists (
    CPropertyUtils* pUtils,
    DWORD   dwPropId,
    DWORD   dwLogType )
{
    DWORD dwStatus = ERROR_SUCCESS;

    // Todo:  Implement.  Check via m_hkeyQueries
    pUtils;
    dwPropId;
    dwLogType;

    // Todo: Display error messages here.
    return dwStatus;
}

/*
 * CPropertyUtils::CPropertyUtils
 *
 * Purpose:
 *  Constructor.
 *
 * Return Value:
 */

CPropertyUtils::CPropertyUtils (
                    LPCWSTR         cszMachineName,
                    LPCWSTR         cszQueryName,
                    CPropertyBag*   pPropBag,
                    HKEY            hkeyQuery,
                    HKEY            hkeyQueryList )
:   m_szPropBagBuffer ( NULL ),
    m_dwPropBagBufLen ( 0 ),
    m_pPropBag ( pPropBag ),
    m_hkeyQuery ( hkeyQuery ),
    m_hkeyQueryList ( hkeyQueryList ),
    m_eMessageDisplayLevel ( eWarnings )
{
    if ( NULL != cszMachineName ) {
        lstrcpynW ( m_szMachineName, cszMachineName, sizeof(m_szMachineName) );
    } else {
        m_szMachineName[0] = NULL_W;
    }

    if ( NULL != cszQueryName ) {
        lstrcpynW ( m_szQueryName, cszQueryName, sizeof(m_szQueryName) );
    } else {
        m_szQueryName[0] = NULL_W;
    }
    return; 
}

/*
 * CPropertyUtils::CPropertyUtils
 *
 * Purpose:
 *  Constructor.
 *
 * Return Value:
 */

CPropertyUtils::CPropertyUtils ( LPCWSTR cszMachineName )
:   m_szPropBagBuffer ( NULL ),
    m_dwPropBagBufLen ( 0 ),
    m_pPropBag ( NULL ),
    m_hkeyQuery ( NULL ),
    m_hkeyQueryList ( NULL ),
    m_eMessageDisplayLevel ( eWarnings )
{
    if ( NULL != cszMachineName ) {
        lstrcpynW ( m_szMachineName, cszMachineName, sizeof(m_szMachineName) );
    } else {
        m_szMachineName[0] = NULL_W;
    }
    m_szQueryName[0] = NULL_W;
    return; 
}

/*
 * CPropertyUtils::~CPropertyUtils
 *
 * Purpose:
 *  Destructor.
 *
 * Return Value:
 */

CPropertyUtils::~CPropertyUtils ( void ) 
{   
    if ( NULL != m_szPropBagBuffer ) {
        delete m_szPropBagBuffer;
    }

    return; 
}

//
//  Public methods
//

void
CPropertyUtils::SetQueryName ( LPCWSTR szQueryName )
{
    assert ( NULL != szQueryName );
    if ( NULL != szQueryName ) {
        lstrcpynW ( m_szQueryName, szQueryName, sizeof(m_szQueryName) );
    }
}

LPCWSTR
CPropertyUtils::GetQueryName ( void )
{
    return m_szQueryName;
}

void
CPropertyUtils::SetPropertyBag ( CPropertyBag* pPropBag )
{
    m_pPropBag = pPropBag;
}

void
CPropertyUtils::SetQueryKey ( HKEY hkeyQuery )
{
    m_hkeyQuery = hkeyQuery;
}

void
CPropertyUtils::SetQueryListKey ( HKEY hkeyQueryList )
{
    m_hkeyQueryList = hkeyQueryList;
}

void
CPropertyUtils::SetMessageDisplayLevel ( eMessageDisplayLevel eLevel )
{
    m_eMessageDisplayLevel = eLevel;
}

CPropertyUtils::eMessageDisplayLevel
CPropertyUtils::GetMessageDisplayLevel ( void )
{
    return m_eMessageDisplayLevel;
}


DWORD
CPropertyUtils::Validate (
    DWORD           dwPropId,
    DWORD           dwLogType )
{
    DWORD   dwStatus = ERROR_INVALID_PARAMETER;

    assert ( NULL != m_pPropBag );
    assert ( ( IdFirstProp <= dwPropId ) && ( IdLastProp >= dwPropId ) ); 

    if ( NULL != m_pPropBag ) {

        if ( ( IdFirstProp <= dwPropId )
                && ( IdLastProp >= dwPropId ) ) {
            if ( NULL != m_PropertyDataMap[dwPropId].fValidate ) {
                dwStatus = m_PropertyDataMap[dwPropId].fValidate ( this, dwPropId, dwLogType );
            }
        }
    }

    return dwStatus;
}

HRESULT
CPropertyUtils::BagToRegistry (
    DWORD           dwPropId,
    DWORD           dwLogType )
{
    HRESULT hr = NOERROR;

    if ( ( IdFirstProp > dwPropId )
            || ( IdLastProp < dwPropId ) ) {
        assert ( FALSE );
        hr = E_INVALIDARG;
    } else if ( NULL == m_pPropBag || NULL == m_hkeyQuery ) {
        assert ( FALSE );
        hr = E_POINTER;
    } else {

        switch ( m_PropertyDataMap[dwPropId].dwRegType ) {

            case REG_SZ:
                hr = StringBagToRegistry ( dwPropId, dwLogType );
                break;

            case REG_BINARY:
                hr = SlqTimeBagToRegistry ( dwPropId, dwLogType );
                break;

            case REG_DWORD:
                hr = DwordBagToRegistry ( dwPropId, dwLogType );
                break;

            case REG_MULTI_SZ:
                hr = MultiSzBagToRegistry ( dwPropId, dwLogType ); 
                break;

            default:
                hr = E_FAIL;
        }
    }
    return hr;
}

//
//  Private methods
//

HRESULT 
CPropertyUtils::MultiSzBagToBufferAlloc ( 
    DWORD   dwPropId,
    DWORD   dwLogType,
    LPWSTR* pszMszBuf,
    DWORD*  pdwMszBufLen,
    DWORD*  pdwMszStringLen )
{
    HRESULT hr = NOERROR;
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD dwCount = 0;

    LPCWSTR szHtmlCountProp = NULL;
    LPCWSTR szHtmlPathProp = NULL;
    
    if ( IdCounterListProp == dwPropId ) {
        if ( SLQ_COUNTER_LOG == dwLogType 
                || SLQ_ALERT == dwLogType ) {
            szHtmlCountProp = cwszHtmlSysmonCounterCount;
            szHtmlPathProp = cwszHtmlSysmonCounterPath;
        } else {
            assert ( FALSE );
            hr = E_INVALIDARG;
        }
    } else if ( IdGuidListProp == dwPropId ) {
        if ( SLQ_TRACE_LOG == dwLogType ) {
            szHtmlCountProp = cwszHtmlTraceProviderCount;
            szHtmlPathProp = cwszHtmlTraceProviderGuid;
        } else {
            assert ( FALSE );
            hr = E_INVALIDARG;
        }
    } else {
        assert ( FALSE );
        hr = E_INVALIDARG;
    }
        
    if ( SUCCEEDED ( hr ) ) {
    
        hr = DwordFromPropertyBag (
                m_pPropBag,
                szHtmlCountProp,
                dwCount );                       // Todo:  Require counter count? Yes for now

        if ( SUCCEEDED ( hr ) ) {
            DWORD   dwIndex;
            DWORD   dwPropBagStringLen = 0;

            assert ( 0 < dwCount );

            for ( dwIndex = 1; 
                    dwIndex <= dwCount && SUCCEEDED ( hr ); 
                    dwIndex++ ) {

                WCHAR   szPropName [MAX_PATH+1];          // Todo: Remove length restriction

                swprintf ( szPropName, szHtmlPathProp, dwIndex );
    
                hr = StringFromPropBagAlloc ( 
                        m_pPropBag, 
                        szPropName, 
                        &m_szPropBagBuffer, 
                        &m_dwPropBagBufLen,
                        &dwPropBagStringLen );


                if ( SUCCEEDED (hr ) ) {
                    if ( SLQ_ALERT != dwLogType ) {
                        dwStatus = AddStringToMszBufferAlloc ( 
                                    m_szPropBagBuffer,
                                    pszMszBuf,
                                    pdwMszBufLen,
                                    pdwMszStringLen );
                        if ( ERROR_SUCCESS != dwStatus ) {
                            hr = HRESULT_FROM_WIN32 ( dwStatus );
                        }
                    } else {
                        DWORD dwTemp;
                        DOUBLE dThreshold = 0;
                        WCHAR  szAlert [MAX_PATH*2];    // Todo:  Remove length restriction

                        swprintf ( szPropName, cwszHtmlAlertOverUnder, dwIndex );

                        hr = DwordFromPropertyBag ( 
                                m_pPropBag, 
                                szPropName,
                                dwTemp );

                        if ( SUCCEEDED (hr ) ) { 
                            swprintf ( szPropName, cwszHtmlAlertThreshold, dwIndex );

                            hr = DoubleFromPropertyBag ( 
                                    m_pPropBag, 
                                    szPropName, 
                                    dThreshold );

                            if ( SUCCEEDED ( hr ) ) {
                                swprintf ( 
                                    szAlert, 
                                    cwszAlertFormatString, 
                                    m_szPropBagBuffer,
                                    ( AIBF_OVER == (dwTemp&AIBF_OVER ) ) ? cwszGreaterThan : cwszLessThan,
                                    dThreshold );

                                dwStatus = AddStringToMszBufferAlloc ( 
                                            szAlert,
                                            pszMszBuf,
                                            pdwMszBufLen,
                                            pdwMszStringLen );
                                if ( ERROR_SUCCESS != dwStatus ) {
                                    hr = HRESULT_FROM_WIN32 ( dwStatus );
                                }
                            }
                        }
                    } 
                }
            }
        }
    }
    return hr;
}

HRESULT 
CPropertyUtils::MultiSzBagToRegistry ( 
    DWORD dwPropId,
    DWORD dwLogType )
{
    HRESULT hr = NOERROR;
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  szMszBuf = NULL;
    DWORD   dwMszBufLen = 0;
    DWORD   dwMszStringLen = 0;

    LPCWSTR szRegListProp = NULL;

    if ( IdCounterListProp == dwPropId ) {
        if ( SLQ_COUNTER_LOG == dwLogType 
                || SLQ_ALERT == dwLogType ) {
            szRegListProp = cwszRegCounterList;
        } else {
            assert ( FALSE );
            hr = E_INVALIDARG;
        }
    } else if ( IdGuidListProp == dwPropId ) {
        if ( SLQ_TRACE_LOG == dwLogType ) {
            szRegListProp = cwszRegTraceProviderList;
        } else {
            assert ( FALSE );
            hr = E_INVALIDARG;
        }
    } else {
        assert ( FALSE );
        hr = E_INVALIDARG;
    }
        
    if ( SUCCEEDED ( hr ) ) {
  
        hr = MultiSzBagToBufferAlloc (
                dwPropId,
                dwLogType,
                &szMszBuf,
                &dwMszBufLen,
                &dwMszStringLen );

        if ( SUCCEEDED ( hr ) ) {
            // Write buffer to the registry
            if ( SUCCEEDED ( hr ) ) {
                dwStatus = WriteRegistryStringValue ( 
                                m_hkeyQuery, 
                                szRegListProp, 
                                REG_MULTI_SZ, 
                                szMszBuf, 
                                dwMszStringLen );
                if ( ERROR_SUCCESS != dwStatus ) {
                    hr = HRESULT_FROM_WIN32 ( dwStatus );
                }
            } 
        }
    }
    
    if ( NULL != szMszBuf ) {
        delete szMszBuf;
    }

    return hr;
}

HRESULT
CPropertyUtils::StringBagToRegistry (
    DWORD           dwPropId,
    DWORD           /* dwLogType */ )
{
    HRESULT hr = NOERROR;
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwStringLen = 0;

    hr = StringFromPropBagAlloc ( 
            m_pPropBag, 
            m_PropertyDataMap[dwPropId].cwszHtmlName, 
            &m_szPropBagBuffer, 
            &m_dwPropBagBufLen,
            &dwStringLen );

    if ( SUCCEEDED ( hr ) && 0 != m_dwPropBagBufLen ) {
        dwStatus = WriteRegistryStringValue ( 
                    m_hkeyQuery, 
                    m_PropertyDataMap[dwPropId].cwszRegName,
                    m_PropertyDataMap[dwPropId].dwRegType, 
                    m_szPropBagBuffer,
                    dwStringLen );

        if ( ERROR_SUCCESS != dwStatus ) {
            hr = HRESULT_FROM_WIN32 ( dwStatus );
        }
    }
    
    return hr;
}

HRESULT
CPropertyUtils::DwordBagToRegistry (
    DWORD           dwPropId,
    DWORD           /* dwLogType */ )
{
    HRESULT hr = NOERROR;
    DWORD   dwValue = 0;

    hr = DwordFromPropertyBag ( 
            m_pPropBag, 
            m_PropertyDataMap[dwPropId].cwszHtmlName, 
            dwValue );

    if ( SUCCEEDED ( hr ) ) {
        DWORD dwStatus;
        dwStatus = WriteRegistryDwordValue ( 
            m_hkeyQuery, 
            m_PropertyDataMap[dwPropId].cwszRegName,
            &dwValue,
            m_PropertyDataMap[dwPropId].dwRegType);         // Some values, e.g. Restart, are REG_BINARY

        if ( ERROR_SUCCESS != dwStatus ) {
            hr = HRESULT_FROM_WIN32 ( dwStatus );
        }
    }
    
    return hr;
}

HRESULT
CPropertyUtils::SlqTimeBagToRegistry (
    DWORD           dwPropId,
    DWORD           dwLogType )
{
    HRESULT hr = NOERROR;
    DWORD   dwStatus = ERROR_SUCCESS;
    SLQ_TIME_INFO   stiData;
    SLQ_TIME_INFO   stiDefault;
    LPCWSTR         cwszRegPropName;
    WORD            wTimeType;

    assert ( IdRestartProp == dwPropId
                || IdStartProp == dwPropId
                || IdStopProp == dwPropId
                || IdSampleProp == dwPropId );

    if ( IdRestartProp == dwPropId ) {
        // Dword processing can handle REG_BINARY as well.
        hr = DwordBagToRegistry ( dwPropId, dwLogType );

    } else { 
        
        assert ( IdStartProp == dwPropId
                    || IdStopProp == dwPropId
                    || IdSampleProp == dwPropId );

        if ( IdStartProp == dwPropId ) {
            wTimeType = SLQ_TT_TTYPE_START;
            cwszRegPropName  = cwszRegStartTime;
        } else if ( IdStopProp == dwPropId ) {
            wTimeType = SLQ_TT_TTYPE_STOP;
            cwszRegPropName  = cwszRegStopTime;
        } else {
            assert ( IdSampleProp == dwPropId );
            wTimeType = SLQ_TT_TTYPE_SAMPLE;
            cwszRegPropName  = cwszRegSampleInterval;
        }

        // Initialize time structure to default, in case of missing fields.
        hr = InitDefaultSlqTimeInfo ( 
                dwLogType, 
                wTimeType, 
                &stiDefault );

        if ( SUCCEEDED ( hr ) ) {
            ZeroMemory ( &stiData, sizeof(stiData) );
            hr = SlqTimeFromPropertyBag ( 
                    m_pPropBag, 
                    wTimeType,  
                    &stiDefault, 
                    &stiData );

            if ( SUCCEEDED ( hr ) ) {
                dwStatus = WriteRegistrySlqTime ( 
                                m_hkeyQuery, 
                                cwszRegPropName,  
                                &stiData );
                if ( ERROR_SUCCESS != dwStatus ) {
                    hr = HRESULT_FROM_WIN32 ( dwStatus );
                }
            }
        }    
    }

    return hr;
}
DWORD 
CPropertyUtils::GetInvalidStatus (
    DWORD   dwPropId )
{   
    DWORD   dwStatus;

    if ( CPropertyUtils::m_PropertyDataMap[dwPropId].bRequired ) {
        dwStatus = LOGMAN_REQUIRED_PROP_INVALID;
    } else {
        dwStatus = LOGMAN_NONREQ_PROP_INVALID;
    }
    
    return dwStatus;
}

DWORD 
CPropertyUtils::GetMissingStatus (
    DWORD   dwPropId )
{   
    DWORD   dwStatus;

    if ( CPropertyUtils::m_PropertyDataMap[dwPropId].bRequired ) {
        dwStatus = LOGMAN_REQUIRED_PROP_MISSING;
    } else {
        dwStatus = LOGMAN_NONREQ_PROP_MISSING;
    }
    
    return dwStatus;
}

BOOL 
CPropertyUtils::IsValidDateTime (
    LONGLONG&   rllDateTime )
{
    BOOL        bIsValid = TRUE;
    SYSTEMTIME  SystemTime;

    // Make sure that the date is reasonable.  That is, not before 10/99

    if (FileTimeToSystemTime((FILETIME*)&rllDateTime, &SystemTime)) {
        if ( cwFirstValidYear > SystemTime.wYear ) {
            bIsValid = FALSE;
        } 
    } else {
        bIsValid = FALSE;
    }
    return bIsValid;
}

BOOL
CPropertyUtils::IsKernelTraceMode (
    IN DWORD dwTraceFlags )
{
    BOOL bReturn;

    bReturn = ( SLQ_TLI_ENABLE_KERNEL_MASK & dwTraceFlags ) ? TRUE : FALSE;

    return bReturn;
}

BOOL
CPropertyUtils::IsDisplayLevelMessage (
    IN DWORD dwStatus )
{
    BOOL    bDisplay = FALSE;
    DWORD   dwSeverity = 0;

    dwSeverity = dwStatus >> 30;
    if ( dwSeverity >= (DWORD)m_eMessageDisplayLevel ) {
        bDisplay = TRUE;
    }
    return bDisplay;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\proputil.h ===
/*++

Copyright (C) 1999-2000 Microsoft Corporation

Module Name:

    proputil.h

Abstract:

    <abstract>

--*/

#ifndef _PROPUTIL_H_
#define _PROPUTIL_H_

#include "stdafx.h"

//===========================================================================
// Constants
//===========================================================================

// Property constants represent indexes into the static PropertyDataMap table.
extern const DWORD IdFirstProp;   		                

// The property constants in this first section have a one-to-one 
// correspondence between HTML parameter and registry value
extern const DWORD IdCommentProp;   		                
extern const DWORD IdLogTypeProp;   		                
extern const DWORD IdCurrentStateProp;                 
extern const DWORD IdLogFileMaxSizeProp;   	         
extern const DWORD IdLogFileBaseNameProp;  	        
extern const DWORD IdLogFileFolderProp;   	          
extern const DWORD IdLogFileSerialNumberProp;   
extern const DWORD IdLogFileAutoFormatProp;
extern const DWORD IdLogFileTypeProp;   	            
extern const DWORD IdEofCommandFileProp;   	         
extern const DWORD IdCommandFileProp;   		            
extern const DWORD IdNetworkNameProp;   		            
extern const DWORD IdUserTextProp;   		                   
extern const DWORD IdPerfLogNameProp; 
extern const DWORD IdTraceBufferSizeProp;   	        
extern const DWORD IdTraceBufferMinCountProp;     
extern const DWORD IdTraceBufferMaxCountProp;     
extern const DWORD IdTraceBufferFlushIntProp;
extern const DWORD IdActionFlagsProp;   		            
extern const DWORD IdTraceFlagsProp;   		             
     
// Property constants below require special handling for BagToRegistry,
// because there is not a one-to-one correspondence between HTML
// parameter and registry value.      
extern const DWORD IdRestartProp;   	                                 
extern const DWORD IdStartProp;   	                                 
extern const DWORD IdStopProp;   	                                 
extern const DWORD IdSampleProp;   	                                 
extern const DWORD IdCounterListProp;  		      
extern const DWORD IdGuidListProp;  		      
/*
// Not handled yet, or covered by special values above.
// Some of these might be needed when writing to HTML file from registry.
//
extern const DWORD IdSysmonVersionProp;
 
extern const DWORD IdSysmonCounterCountProp;       
extern const DWORD IdSysmonCounterPathProp;   	  
extern const DWORD IdAlertThresholdProp;   		     
extern const DWORD IdAlertOverUnderProp;   		     
extern const DWORD IdTraceProviderCountProp;   	 
extern const DWORD IdTraceProviderGuidProp;   	  

extern const DWORD IdLogNameProp;   		                    
extern const DWORD IdAlertNameProp;   		              
extern const DWORD IdStartModeProp;   		                                
extern const DWORD IdStartAtTimeProp;   		                             
extern const DWORD IdStopModeProp;   		                                     
extern const DWORD IdStopAtTimeProp;   		                               
extern const DWORD IdStopAfterUnitTypeProp;   	                     
extern const DWORD IdStopAfterValueProp;   		                       
extern const DWORD IdSampleIntUnitTypeProp;   	                    
extern const DWORD IdSampleIntValueProp;   		                       
extern const DWORD IdSysmonUpdateIntervalProp;
     
extern const DWORD IdSysmonSampleCountProp;         
extern const DWORD IdSysmonLogFileNameProp;                       

extern const DWORD IdExecuteOnlyProp; 

*/
extern const DWORD IdExecuteOnlyProp;   		

class CPropertyBag;
class CPropertyUtils;

class CPropertyUtils {

    public:

        enum eMessageDisplayLevel {
            eAll        = 0,    //STATUS_SEVERITY_SUCCESS,
            eInfo       = 1,    //STATUS_SEVERITY_INFORMATIONAL,
            eWarnings   = 2,    //STATUS_SEVERITY_WARNING,       // Default level
            eError      = 3,    //STATUS_SEVERITY_ERROR,
            eNone       = 4,    //STATUS_SEVERITY_ERROR + 1
        };

                        CPropertyUtils ( LPCWSTR cszMachineName );
                        CPropertyUtils ( 
                            LPCWSTR cszMachineName,
                            LPCWSTR cszQueryName, 
                            CPropertyBag*, 
                            HKEY hkeyQuery, 
                            HKEY hkeyQueryList );

        virtual         ~CPropertyUtils ( void );
        
                void    SetQueryName ( LPCWSTR );
                void    SetPropertyBag ( CPropertyBag* );
                void    SetQueryKey ( HKEY );
                void    SetQueryListKey ( HKEY );

                void    SetMessageDisplayLevel ( eMessageDisplayLevel );
                eMessageDisplayLevel    GetMessageDisplayLevel ( void );

                // BagToRegistry requires property bag and parent registry key
                HRESULT BagToRegistry ( DWORD dwPropId, DWORD dwLogType = SLQ_COUNTER_LOG );

                // ValidateProperty requires property bag
                DWORD   Validate ( DWORD dwPropId, DWORD dwLogType = SLQ_COUNTER_LOG ); 

    private:

        typedef DWORD ( *ValidationMethod )( CPropertyUtils*, DWORD, DWORD );

        typedef struct _PROPERTY_DATA_MAP {
            DWORD               dwPropertyId;
            DWORD               dwRegType;
            LPCWSTR             cwszHtmlName;
            LPCWSTR             cwszRegName;
            ValidationMethod    fValidate;
            BOOL                bRequired;
            DWORD               dwMin;
            DWORD               dwMax;
        } PROPERTY_DATA_MAP, *PPROPERTY_DATA_MAP;


        friend  DWORD   ValidateDwordInterval ( CPropertyUtils* pUtils, DWORD dwPropId, DWORD dwLogType );
        friend  DWORD   ValidatePrimaryObjectList ( CPropertyUtils* pUtils, DWORD dwPropId, DWORD dwLogType );
        friend  DWORD   ValidateSlqTimeInfo ( CPropertyUtils* pUtils, DWORD dwPropId, DWORD dwLogType );
        friend  DWORD   ValidateMaxFileSize ( CPropertyUtils* pUtils, DWORD dwPropId, DWORD dwLogType );
        friend  DWORD   ValidateLogFileType ( CPropertyUtils* pUtils, DWORD dwPropId, DWORD dwLogType );
        friend  DWORD   ValidateString ( CPropertyUtils* pUtils, DWORD dwPropId, DWORD dwLogType );
        friend  DWORD   ValidateTraceFlags ( CPropertyUtils* pUtils, DWORD dwPropId, DWORD dwLogType );
        friend  DWORD   ValidateAlertActions ( CPropertyUtils* pUtils, DWORD dwPropId, DWORD dwLogType );
        friend  DWORD   ValidateDirectoryPath ( CPropertyUtils* pUtils, DWORD dwPropId, DWORD dwLogType );
        friend  DWORD   ValidateTraceBufferMaxCount ( CPropertyUtils* pUtils, DWORD dwPropId, DWORD dwLogType );
        friend  DWORD   ValidateFileName ( CPropertyUtils* pUtils, DWORD dwPropId, DWORD dwLogType );
        friend  DWORD   ValidateFilePath ( CPropertyUtils* pUtils, DWORD dwPropId, DWORD dwLogType );
        friend  DWORD   ValidateLogExists ( CPropertyUtils* pUtils, DWORD dwPropId, DWORD dwLogType );

        HRESULT StringBagToRegistry ( DWORD dwPropId, DWORD dwLogType );
        HRESULT DwordBagToRegistry ( DWORD dwPropId, DWORD dwLogType );
        HRESULT SlqTimeBagToRegistry ( DWORD dwPropId, DWORD dwLogType );
        HRESULT MultiSzBagToRegistry ( DWORD dwPropId, DWORD dwLogType ); 


        HRESULT MultiSzBagToBufferAlloc ( 
                    DWORD   dwPropId,
                    DWORD   dwLogType,
                    LPWSTR* pszMszBuf,
                    DWORD*  pdwMszBufLen,
                    DWORD*  pdwMszStringLen );

                LPCWSTR GetQueryName ( void );
                BOOL    IsValidDateTime ( LONGLONG& rllDateTime );
                BOOL    IsDisplayLevelMessage ( DWORD dwStatus ); 
                BOOL    IsKernelTraceMode ( DWORD dwTraceFlags );

                DWORD   GetInvalidStatus ( DWORD dwPropId );
                DWORD   GetMissingStatus ( DWORD dwPropId );

        static const    PROPERTY_DATA_MAP   m_PropertyDataMap[];
        static const    DWORD               m_dwPropertyDataMapEntries;        
                        
                        CPropertyBag*       m_pPropBag;

                        LPWSTR              m_szPropBagBuffer;
                        DWORD               m_dwPropBagBufLen;
                        eMessageDisplayLevel    m_eMessageDisplayLevel;
                        HKEY                m_hkeyQuery;
                        HKEY                m_hkeyQueryList;
                        WCHAR               m_szQueryName[MAX_PATH + 1];    // Todo:  Remove size limit
                        WCHAR               m_szMachineName[MAX_COMPUTERNAME_LENGTH + 1];

};

typedef CPropertyUtils *PCPropertyUtils;

#endif //_PROPUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\unihelpr.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    unihelpr.h

Abstract:

    <abstract>

--*/

#ifndef _UNIHELPR_H_
#define _UNIHELPR_H_

/*
    These macros are based on the MFC macros found in file afxconv.h. They have been modified
    slightly to delete references to the MFC helper functions AfxW2AHelper and AfxA2WHelper
    so that the MFC DLL is not required.
*/

#include <malloc.h>

#define _MbToWide(dst, src, cnt) \
	MultiByteToWideChar(CP_ACP, 0, src, cnt, dst, cnt)

#define _WideToMb(dst, src, cnt) \
	WideCharToMultiByte(CP_ACP, 0, src, cnt, dst, 2 * cnt, NULL, NULL)


#define A2CW(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : ( \
		_convert = (lstrlenA(lpa)+1), \
		_convPtr = alloca(_convert*2), \
		_MbToWide((LPWSTR)_convPtr, lpa, _convert), \
		(LPCWSTR)_convPtr \
	) \
)

#define A2W(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : ( \
		_convert = (lstrlenA(lpa)+1), \
		_convPtr = alloca(_convert*2), \
		_MbToWide((LPWSTR)_convPtr, lpa, _convert),\
		(LPWSTR)_convPtr \
	) \
)

#define W2CA(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : ( \
		_convert = (wcslen(lpw)+1), \
		_convPtr = alloca(_convert*2),  \
		_WideToMb((LPSTR)_convPtr, lpw, _convert), \
		(LPCSTR)_convPtr \
	)\
)

#define W2A(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : (\
		_convert = (wcslen(lpw)+1),\
		_convPtr = alloca(_convert*2), \
		_WideToMb((LPSTR)_convPtr, lpw, _convert), \
		(LPSTR)_convPtr \
	)\
)

#ifndef _DEBUG
#define USES_CONVERSION int _convert; void *_convPtr; _convPtr, _convert;
#else
#define USES_CONVERSION int _convert = 0; void *_convPtr = NULL; assert( 0 == _convert ); assert( NULL ==_convPtr );
#endif


#ifdef _UNICODE
	#define T2A W2A
	#define A2T A2W
	#define T2W(x)  (x)
	#define W2T(x)  (x)
#else
	#define T2W A2W
	#define W2T W2A
	#define T2A(x)  (x)
	#define A2T(x)  (x)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\relog\resource.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#define    IDS_PARAM_APPEND          110
#define    IDS_PARAM_FORMAT          113
#define    IDS_PARAM_INPUT           116
#define    IDS_PARAM_INTERVAL        119
#define    IDS_PARAM_OUTPUT          122
#define    IDS_PARAM_QUERY           125
#define    IDS_PARAM_COUNTERS        128
#define    IDS_PARAM_BEGIN           131
#define    IDS_PARAM_END             134
#define    IDS_PARAM_COUNTERFILE     140
#define    IDS_PARAM_YES             141

#define    IDS_DEFAULT_OUTPUT        600

#define    IDS_MESSAGE_INPUT         700
#define    IDS_MESSAGE_OUTPUT        701
#define    IDS_MESSAGE_FILE          702
#define    IDS_MESSAGE_FILES         703
#define    IDS_MESSAGE_BEGIN         704
#define    IDS_MESSAGE_END           705
#define    IDS_MESSAGE_SAMPLES       706
#define    IDS_MESSAGE_LOG_OLD_BIN   707
#define    IDS_MESSAGE_LOG_CSV       708
#define    IDS_MESSAGE_LOG_TSV       709
#define    IDS_MESSAGE_LOG_BINARY    710
#define    IDS_MESSAGE_LOG_PERFMON   711
#define    IDS_MESSAGE_LOG_UNKNOWN   712    
#define    IDS_MESSAGE_BADFILES      713
#define    IDS_MESSAGE_BADFORMAT     714
#define    IDS_MESSAGE_BADRANGE      715

#define    IDS_EXAMPLE_FORMAT        800
#define    IDS_EXAMPLE_QUERY         801
#define    IDS_EXAMPLE_COUNTERFILE   802
#define    IDS_EXAMPLE_COUNTERS      803
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\utils.cpp ===
/*++

Copyright (C) 1992-1999 Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    This file contains miscellaneous utiltity routines, mostly 
    low-level windows helpers. These routines are not specific
    to the System Monitor control.

--*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include "stdafx.h"
#include "unihelpr.h"
#include "strings.h"
#include "utils.h"

//==========================================================================//
//                              Constants                                   //
//==========================================================================//

#define DEFAULT_MSZ_BUF_LEN ((DWORD)0x01000)
#define MAX_MESSAGE_LENGTH  ((DWORD)0x00C00)
#define MESSAGE_RESOURCE_ID_MASK ((DWORD)0x0000ffff)

// Time conversion constants

#define SECONDS_IN_DAY      86400
#define SECONDS_IN_HOUR      3600
#define SECONDS_IN_MINUTE      60

//==========================================================================//
//                              Local Functions                             //
//==========================================================================//

static
DWORD   _stdcall
ScanHexFormat(
    IN LPCWSTR  szBuffer,
    IN ULONG    ulMaximumLength,
    IN LPCWSTR  szFormat,
    ...);


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


BOOL
TruncateLLTime (
    IN  LONGLONG llTime,
    OUT LONGLONG* pllTime
    )
{
    SYSTEMTIME SystemTime;

    if (!FileTimeToSystemTime((FILETIME*)&llTime, &SystemTime))
        return FALSE;

    SystemTime.wMilliseconds = 0;

    return SystemTimeToFileTime(&SystemTime, (FILETIME*)pllTime);
}


BOOL
LLTimeToVariantDate (
    IN  LONGLONG llTime,
    OUT DATE *pdate
    )
{
    SYSTEMTIME SystemTime;

    if (!FileTimeToSystemTime((FILETIME*)&llTime, &SystemTime))
        return FALSE;

    return SystemTimeToVariantTime(&SystemTime, pdate);
}

    
BOOL
VariantDateToLLTime (
    IN  DATE date,
    OUT LONGLONG *pllTime
    )
{
    SYSTEMTIME SystemTime;
    if (!VariantTimeToSystemTime(date, &SystemTime))
        return FALSE;

    return SystemTimeToFileTime(&SystemTime,(FILETIME*)pllTime);
}

//
// Property bag I/O 
//

HRESULT _stdcall
DwordFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    DWORD& rdwData )
{
    VARIANT vValue;
    HRESULT hr;

    VariantInit( &vValue );
    vValue.vt = VT_I4;
    vValue.lVal = 0;

    hr = pPropBag->Read ( szPropName, &vValue );

    if ( SUCCEEDED ( hr ) ) {
        rdwData = vValue.lVal;
    }

    return hr;
}

HRESULT _stdcall
BOOLFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    BOOL& rbData )
{
    VARIANT vValue;
    HRESULT hr;

    VariantInit( &vValue );
    vValue.vt = VT_BOOL;

    hr = pPropBag->Read ( szPropName, &vValue );

    if ( SUCCEEDED ( hr ) ) {
        rbData = vValue.boolVal;
    }

    return hr;
}

HRESULT _stdcall
DoubleFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    DOUBLE& rdblData )
{
    VARIANT vValue;
    HRESULT hr;

    VariantInit( &vValue );
    vValue.vt = VT_R8;

    hr = pPropBag->Read ( szPropName, &vValue );

    if ( SUCCEEDED ( hr ) ) {
        rdblData = vValue.dblVal;
    }

    return hr;
}

HRESULT _stdcall
FloatFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    FLOAT& rfData )
{
    VARIANT vValue;
    HRESULT hr;

    VariantInit( &vValue );
    vValue.vt = VT_R4;

    hr = pPropBag->Read ( szPropName, &vValue );

    if ( SUCCEEDED ( hr ) ) {
        rfData = vValue.fltVal;
    }

    return hr;
}

HRESULT _stdcall
ShortFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    SHORT& riData )
{
    VARIANT vValue;
    HRESULT hr;

    VariantInit( &vValue );
    vValue.vt = VT_I2;

    hr = pPropBag->Read ( szPropName, &vValue );

    if ( SUCCEEDED ( hr ) ) {
        riData = vValue.iVal;
    }

    return hr;
}

HRESULT _stdcall
CyFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    CY& rcyData )
{
    VARIANT vValue;
    HRESULT hr;

    VariantInit( &vValue );
    vValue.vt = VT_CY;
    vValue.cyVal.int64 = 0;

    hr = pPropBag->Read ( szPropName, &vValue );
    
    if ( SUCCEEDED( hr ) ) {
        hr = VariantChangeType ( &vValue, &vValue, NULL, VT_CY );

        if ( SUCCEEDED ( hr ) ) {
            rcyData.int64 = vValue.cyVal.int64;
        }
    }

    return hr;
}


HRESULT _stdcall
StringFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    LPWSTR  szData,
    DWORD*  pdwBufLen )
{
    VARIANT vValue;
    HRESULT hr;
 
    VariantInit( &vValue );
    vValue.vt = VT_BSTR;
    vValue.bstrVal = NULL;

    hr = pPropBag->Read(szPropName, &vValue );

    // Todo: Return buflen = 1 when no data?
    // Todo: Return e_fail if data found, but buffer not big enough?
    if ( SUCCEEDED(hr) && vValue.bstrVal ) {
        DWORD dwNewBufLen = SysStringLen(vValue.bstrVal) + 1;  // 1 for NULL terminator
        if ( dwNewBufLen > 1 ) {
            if ( *pdwBufLen >= dwNewBufLen && NULL != szData ) {
                lstrcpyW ( szData, vValue.bstrVal );
            } else {
                // Insufficient buffer
                hr = HRESULT_FROM_WIN32 ( ERROR_INSUFFICIENT_BUFFER );
            }
        } else if ( NULL != szData ) {  
            // Property found, string is NULL
            szData[0] = NULL_W;
        }
        *pdwBufLen = dwNewBufLen;
    } else {
        *pdwBufLen = 0;
    }

    return hr;
}

HRESULT _stdcall
LLTimeFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    LONGLONG& rllData )
{
    VARIANT vValue;
    HRESULT hr;

    VariantInit( &vValue );
    vValue.vt = VT_DATE;

    hr = pPropBag->Read ( szPropName, &vValue );

    if ( SUCCEEDED(hr) ) {
        if ( !VariantDateToLLTime ( vValue.date, &rllData ) ) {
            hr = E_FAIL;
        }
        VariantClear( &vValue );
    }
    return hr;
}

HRESULT _stdcall
SlqTimeFromPropertyBag (
    CPropertyBag* pPropBag,
    WORD wFlags, 
    PSLQ_TIME_INFO pstiDefault,
    PSLQ_TIME_INFO pstiData )
{
    HRESULT hr = NOERROR;

    assert ( NULL != pstiData );

    if ( NULL == pstiData ) {
        hr = E_POINTER;
    } else {

// Todo:  Error handling

        // This method sets missing fields to default value.
        
        switch (wFlags) {
            case SLQ_TT_TTYPE_START:

                pstiData->wTimeType = SLQ_TT_TTYPE_START;
                pstiData->wDataType = SLQ_TT_DTYPE_DATETIME;

                hr = DwordFromPropertyBag ( 
                        pPropBag, 
                        cwszHtmlStartMode,
                        pstiData->dwAutoMode );

            
                if ( SLQ_AUTO_MODE_AT == pstiData->dwAutoMode ) {
                    hr = LLTimeFromPropertyBag ( 
                            pPropBag, 
                            cwszHtmlStartAtTime,
                            pstiData->llDateTime );

                } else {
                    // Original state is stopped.
                    assert ( SLQ_AUTO_MODE_NONE == pstiData->dwAutoMode );
                    pstiData->llDateTime = MAX_TIME_VALUE;
                }
            
                break;

            case SLQ_TT_TTYPE_STOP:
                pstiData->wTimeType = SLQ_TT_TTYPE_STOP;

                hr = DwordFromPropertyBag ( 
                        pPropBag, 
                        cwszHtmlStopMode,
                        pstiData->dwAutoMode );
            
                if ( SLQ_AUTO_MODE_AT == pstiData->dwAutoMode ) {
                    pstiData->wDataType = SLQ_TT_DTYPE_DATETIME;
                    hr = LLTimeFromPropertyBag ( 
                            pPropBag, 
                            cwszHtmlStopAtTime,
                            pstiData->llDateTime );

                } else if ( SLQ_AUTO_MODE_AFTER == pstiData->dwAutoMode ) {
                    pstiData->wDataType = SLQ_TT_DTYPE_UNITS;

                    hr = DwordFromPropertyBag ( 
                            pPropBag, 
                            cwszHtmlStopAfterUnitType, 
                            pstiData->dwUnitType );

                    hr = DwordFromPropertyBag ( 
                            pPropBag, 
                            cwszHtmlStopAfterValue,
                            pstiData->dwValue );
                } else {
                    // Original state is stopped.
                    assert ( SLQ_AUTO_MODE_NONE == pstiData->dwAutoMode );
                    pstiData->wDataType = SLQ_TT_DTYPE_DATETIME;
                    pstiData->llDateTime = MIN_TIME_VALUE;
                }
            
                break;
            
            case SLQ_TT_TTYPE_SAMPLE:
            {
                BOOL bUnitTypeMissing = FALSE;
                BOOL bUnitValueMissing = FALSE;

                pstiData->wTimeType = pstiDefault->wTimeType;
                pstiData->dwAutoMode = pstiDefault->dwAutoMode;
                pstiData->wDataType = pstiDefault->wDataType;

                hr = DwordFromPropertyBag ( 
                                pPropBag, 
                                cwszHtmlSampleIntUnitType,
                                pstiData->dwUnitType );

                if ( FAILED ( hr ) ) {
                    pstiData->dwUnitType = pstiDefault->dwUnitType;
                    bUnitTypeMissing = TRUE;
                }

                hr = DwordFromPropertyBag ( 
                                pPropBag, 
                                cwszHtmlSampleIntValue,
                                pstiData->dwValue );

                if ( FAILED ( hr ) ) {
                    pstiData->dwValue = pstiDefault->dwValue;
                    bUnitValueMissing = TRUE;
                }

                if ( bUnitTypeMissing || bUnitValueMissing ) {
                    FLOAT fUpdateInterval;

                    // If unit type or unit count missing from the property bag,
                    // look for "UpdateInterval" value, from the Sysmon control object,
                    // and use it to approximate the sample time.

                    hr = FloatFromPropertyBag ( 
                            pPropBag, 
                            cwszHtmlSysmonUpdateInterval,
                            fUpdateInterval );

                    if ( SUCCEEDED ( hr ) ) {
                        pstiData->dwValue = (DWORD)(fUpdateInterval);
                        pstiData->dwUnitType = SLQ_TT_UTYPE_SECONDS;
                    }
                }
                break;
            }
       
        // Restart mode stored as a single DWORD
            case SLQ_TT_TTYPE_RESTART:
            default:
                hr = E_INVALIDARG;
                break;
        }
    }

    return hr;
}

// 
//  Registry I/O
//

LONG _stdcall
WriteRegistryStringValue (
    HKEY    hKey,
    LPCWSTR cwszValueName,
    DWORD   dwType,
    LPCWSTR pszBuffer,
    DWORD   dwBufLen
)
//  writes the contents of pszBuffer to szValue under hKey
{
    LONG    dwStatus = ERROR_SUCCESS;
    DWORD   dwBufByteCount;
    CONST BYTE *pLclBuffer;

    assert ((dwType == REG_SZ) || 
            (dwType == REG_MULTI_SZ) ||
            (dwType == REG_EXPAND_SZ));
    
    if ( NULL == pszBuffer ) {
        // substitute an empty string
        pLclBuffer = (CONST BYTE *)cwszNull;
        dwBufByteCount = 0;
    } else {
        // use args passed in
        pLclBuffer = (CONST BYTE *)pszBuffer;
        dwBufByteCount = dwBufLen * sizeof(WCHAR);
    }

    dwStatus = RegSetValueExW (hKey, 
        cwszValueName, 
        0L,
        dwType,
        (CONST BYTE *)pLclBuffer,
        dwBufByteCount ); 

    return dwStatus;
}

LONG _stdcall
WriteRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    LPDWORD  pdwValue,
    DWORD    dwType   
)
{
    LONG    dwStatus = ERROR_SUCCESS;
    DWORD   dwValue = sizeof(DWORD);

    assert ((dwType == REG_DWORD) || 
            (dwType == REG_BINARY));
    
    dwStatus = RegSetValueExW (
        hKey, 
        cwszValueName, 
        0L,
        dwType,
        (CONST BYTE *)pdwValue,
        dwValue);

    return dwStatus;
}

LONG _stdcall
WriteRegistrySlqTime (
    HKEY     hKey,
    LPCWSTR cwszValueName,
    PSLQ_TIME_INFO  pstiData
)
{
    LONG    dwStatus = ERROR_SUCCESS;
    DWORD   dwValue = sizeof(SLQ_TIME_INFO);

    dwStatus = RegSetValueExW (
        hKey, 
        cwszValueName, 
        0L,
        REG_BINARY,
        (CONST BYTE *)pstiData,
        dwValue);

    return dwStatus;
}

LONG _stdcall
ReadRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    LPDWORD  pdwValue
)
{
    LONG    dwStatus = ERROR_SUCCESS;
    DWORD   dwValue = sizeof(DWORD);
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;
    SLQ_TIME_INFO   slqLocal;

    assert ( NULL != hKey );
    assert ( NULL != pdwValue );
    assert ( NULL != cwszValueName );
    assert ( NULL_T != cwszValueName[0] );

    memset (&slqLocal, 0, sizeof(SLQ_TIME_INFO));

    dwStatus = RegQueryValueExW (
        hKey, 
        cwszValueName, 
        NULL,
        &dwType,
        NULL,
        &dwBufferSize );

    if ( ERROR_SUCCESS == dwStatus ) {
        if ( ( dwBufferSize == sizeof(DWORD) ) 
                && ( ( REG_DWORD == dwType ) || ( REG_BINARY == dwType ) ) ) {
            // then there's something to read
            dwType = 0;
            dwStatus = RegQueryValueExW (
                hKey,
                cwszValueName,
                NULL,
                &dwType,
                (LPBYTE)&dwValue,
                &dwBufferSize);
        } else {
            // nothing to read                
            dwStatus = ERROR_NO_DATA;
        }
    } // else dwStatus has error.
    
    if ( ERROR_SUCCESS == dwStatus ) {
        *pdwValue = dwValue;
    }

    return dwStatus;
}

LONG _stdcall
ReadRegistrySlqTime (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    PSLQ_TIME_INFO  pstiData
)
{
    LONG    dwStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;
    SLQ_TIME_INFO   slqLocal;

    assert ( NULL != hKey );
    assert ( NULL != pstiData );
    assert ( NULL != cwszValueName );
    assert ( NULL_T != cwszValueName[0] );

    memset (&slqLocal, 0, sizeof(SLQ_TIME_INFO));

    dwStatus = RegQueryValueExW (
        hKey, 
        cwszValueName, 
        NULL,
        &dwType,
        NULL,
        &dwBufferSize );

    if ( ERROR_SUCCESS == dwStatus ) {
        if ( (dwBufferSize == sizeof(SLQ_TIME_INFO)) && ( REG_BINARY == dwType ) ) {
            // then there's something to read
            dwType = 0;
            dwStatus = RegQueryValueExW (
                hKey,
                cwszValueName,
                NULL,
                &dwType,
                (LPBYTE)&slqLocal,
                &dwBufferSize);
        } else {
            // nothing to read                
            dwStatus = ERROR_NO_DATA;
        }
    }
    
    if ( ERROR_SUCCESS == dwStatus ) {
        *pstiData = slqLocal;
    }

    return dwStatus;
}

//
// Wrapper functions for html to registry
//

HRESULT _stdcall
StringFromPropBagAlloc (
    CPropertyBag*   pPropBag,
    LPCWSTR         szPropertyName,
    LPWSTR*         pszBuffer,
    DWORD*          pdwBufLen,
    DWORD*          pdwStringLen )
{
    HRESULT hr = NOERROR;
    LPWSTR  szLocalBuffer = *pszBuffer;
    DWORD   dwLocalBufLen = *pdwBufLen;

    hr = StringFromPropertyBag ( pPropBag, szPropertyName, szLocalBuffer, &dwLocalBufLen );

    if ( HRESULT_FROM_WIN32 ( ERROR_INSUFFICIENT_BUFFER ) == hr ) {    

        assert ( dwLocalBufLen > *pdwBufLen ); 

        if ( NULL != szLocalBuffer ) {
            delete szLocalBuffer;
        }
        
        szLocalBuffer = new WCHAR[ dwLocalBufLen ]; 

        if ( NULL != szLocalBuffer ) {
            *pdwBufLen = dwLocalBufLen;
            hr = StringFromPropertyBag ( pPropBag, szPropertyName, szLocalBuffer, &dwLocalBufLen );
        } else {
            hr = E_OUTOFMEMORY;
        }
    }

    *pszBuffer =  szLocalBuffer;
    // Length of actual string returned.
    if ( NULL != pdwStringLen ) {
        *pdwStringLen = dwLocalBufLen - 1;      // Buffer length includes space for NULL
    }
   
    return hr;
}

DWORD _stdcall
AddStringToMszBuffer (
    LPCWSTR szString,
    LPWSTR  szBuffer,
    DWORD*  pdwBufLen,
    DWORD*  pdwBufStringLen )
{
    DWORD dwStatus = ERROR_SUCCESS;

    assert ( NULL != szString );

    if ( NULL == szString ) {
        dwStatus = ERROR_INVALID_PARAMETER;
    } else {
        DWORD   dwNewBufStringLen = 0;
        DWORD   dwStringLen;
        DWORD   dwLocalBufStringLen;

        if ( NULL == szBuffer ) {
            dwLocalBufStringLen = 0;
        } else {
           // Todo:  Trust the user?  Check in debug mode?  If need to check in non-debug mode, then
           // just calculate
        }

        dwStringLen = lstrlenW ( szString );

        if ( *pdwBufStringLen > 0 ) {
            // Existing buffer length includes double NULL at end
            dwLocalBufStringLen = *pdwBufStringLen - 1;   
        } else {
            dwLocalBufStringLen = 0;
        }

        dwNewBufStringLen = dwStringLen 
                                + 1                             // NULL string end
                                + dwLocalBufStringLen           
                                + 1;                            // NULL Msz buffer end

        if ( dwNewBufStringLen > *pdwBufLen ) {
            *pdwBufLen = dwNewBufStringLen;
            dwStatus = ERROR_INSUFFICIENT_BUFFER;
        } else {
            LPWSTR szNextString;

            szNextString = szBuffer + dwLocalBufStringLen;

            lstrcpyW ( szNextString, szString );

            szNextString += dwStringLen + 1;        // +1 for string NULL

            szNextString[0] = NULL_W;               // Msz NULL

            *pdwBufStringLen = dwNewBufStringLen;
        }
    }
    return dwStatus;
}

HRESULT _stdcall
AddStringToMszBufferAlloc (
    LPCWSTR     szString,
    LPWSTR*     pszBuffer,
    DWORD*      pdwBufLen,
    DWORD*      pdwBufStringLen )
{
    HRESULT hr = NOERROR;
    DWORD   dwStatus;
    DWORD   dwLocalBufLen = *pdwBufLen;
    DWORD   dwLocalBufStringLen = *pdwBufStringLen;
    LPWSTR  szLocalBuffer = *pszBuffer;

    dwStatus = AddStringToMszBuffer (
                    szString,
                    szLocalBuffer,
                    &dwLocalBufLen,
                    &dwLocalBufStringLen );

    if ( ERROR_INSUFFICIENT_BUFFER == dwStatus ) {

        LPWSTR  szNewMszBuffer = NULL;
        DWORD   dwNewBufSize = *pdwBufLen + DEFAULT_MSZ_BUF_LEN;

        assert ( dwLocalBufLen < ( *pdwBufLen + dwNewBufSize ) );

        if ( dwLocalBufLen < dwNewBufSize ) {
            dwLocalBufLen = dwNewBufSize;
        }

        szNewMszBuffer = new WCHAR[ dwLocalBufLen ]; 

        if ( NULL != szNewMszBuffer ) {
            if ( NULL != szLocalBuffer ) {
                memcpy ( 
                    szNewMszBuffer, 
                    szLocalBuffer, 
                    dwLocalBufStringLen * sizeof(WCHAR) );
                delete szLocalBuffer;
            }             
            szLocalBuffer = szNewMszBuffer;

            dwStatus = AddStringToMszBuffer (
                            szString,
                            szLocalBuffer,
                            &dwLocalBufLen,
                            &dwLocalBufStringLen );

        } else {
            hr = E_OUTOFMEMORY;
            dwLocalBufLen = 0;
        }
    } else {

        assert ( ERROR_INSUFFICIENT_BUFFER != dwStatus );

        if ( ERROR_SUCCESS != dwStatus ) {
            if ( ERROR_INVALID_PARAMETER == dwStatus ) {
                hr = E_INVALIDARG;
            } else {
                hr = E_UNEXPECTED;
            }
        }
    }

    *pszBuffer = szLocalBuffer;
    *pdwBufLen = dwLocalBufLen;
    *pdwBufStringLen = dwLocalBufStringLen;
   
    return hr;
}

HRESULT _stdcall
InitDefaultSlqTimeInfo (
    DWORD           dwQueryType,
    WORD            wTimeType,
    PSLQ_TIME_INFO  pstiData )
{
    HRESULT hr = NOERROR;

    assert ( NULL != pstiData );

    if ( NULL == pstiData ) {
        hr = E_POINTER;         
    } else {
        switch ( wTimeType ) {
            case SLQ_TT_TTYPE_START:
                {
                    SYSTEMTIME  stLocalTime;
                    FILETIME    ftLocalTime;

                    GetLocalTime (&stLocalTime);
                    SystemTimeToFileTime (&stLocalTime, &ftLocalTime);

                    pstiData->wTimeType = SLQ_TT_TTYPE_START;
                    pstiData->dwAutoMode = SLQ_AUTO_MODE_AFTER;
                    pstiData->wDataType = SLQ_TT_DTYPE_DATETIME;
                    pstiData->llDateTime = *(LONGLONG *)&ftLocalTime;

                    break;
                }
            case SLQ_TT_TTYPE_STOP:
                pstiData->wTimeType = SLQ_TT_TTYPE_STOP;
                pstiData->dwAutoMode = SLQ_AUTO_MODE_NONE;
                pstiData->wDataType = SLQ_TT_DTYPE_DATETIME;
                pstiData->llDateTime = MAX_TIME_VALUE;

                break;

            case SLQ_TT_TTYPE_SAMPLE:
                pstiData->wTimeType = SLQ_TT_TTYPE_SAMPLE;
                pstiData->dwAutoMode = SLQ_AUTO_MODE_AFTER;
                pstiData->wDataType = SLQ_TT_DTYPE_UNITS;
                pstiData->dwUnitType = SLQ_TT_UTYPE_SECONDS;

                if ( SLQ_COUNTER_LOG == dwQueryType ) {
                    pstiData->dwValue = 15;
                } else if ( SLQ_ALERT == dwQueryType ) {
                    pstiData->dwValue = 5;
                } else {
                    hr = E_INVALIDARG;
                }

                break;

            // Restart mode stored as a single DWORD
            case SLQ_TT_TTYPE_RESTART:
            default:
                hr = E_INVALIDARG;
                break;
        }
    }
    return hr;
}
    
/*

HRESULT
ProcessStringProperty (
    CPropertyBag*   pPropBag,
    HKEY            hKeyParent,
    LPCWSTR         szHtmlPropertyName,
    LPCWSTR         szRegPropertyName,
    DWORD           dwRegType,
    LPWSTR*         pszBuffer,
    DWORD*          pdwBufLen )
{
    HRESULT hr;

    hr = StringFromPropBagAlloc ( pPropBag, szPropertyName, *pszBuffer, *pdwBufLen );

    if ( SUCCEEDED ( hr ) ) {
        hr = WriteRegistryStringValue ( hKeyParent, szPropertyName, dwRegType, *pszBuffer );
    }

    return hr;
}
*/

LPWSTR
ResourceString (
    UINT    uID 
    )
{
#define STRING_BUF_LEN  256
#define NUM_BUFFERS     16

    static WCHAR aszBuffers[NUM_BUFFERS][STRING_BUF_LEN];
    static INT iBuffIndex = 0;
    static WCHAR szMissingString [8];

    // Use next buffer
    if (++iBuffIndex >= NUM_BUFFERS)
        iBuffIndex = 0;

    // Load and return string
    if (LoadStringW( NULL, uID, aszBuffers[iBuffIndex], STRING_BUF_LEN)) {
        return aszBuffers[iBuffIndex];
    } else {
        lstrcpyW ( szMissingString, cwszMissingResourceString );
        return szMissingString;
    }
}


BOOL    _stdcall 
IsLogManMessage (
    DWORD dwMessageId,
    DWORD*  pdwResourceId )
{
    BOOL    bIsLogManMsg = FALSE;
    DWORD   dwLocalId;


    dwLocalId = dwMessageId & MESSAGE_RESOURCE_ID_MASK;

    if ( 6000 <= dwLocalId && 6040 >= dwLocalId ) {
        bIsLogManMsg = TRUE;
    }

    if ( NULL != pdwResourceId ) {
        *pdwResourceId = dwLocalId;
    }

    return bIsLogManMsg;
}    

DWORD   _stdcall 
FormatResourceString (
    DWORD   dwResourceId,
    LPWSTR  szFormatted,
    va_list*    pargList )
{
    DWORD dwStatus = ERROR_SUCCESS;
    LPWSTR  szUnformatted = NULL;

    // Format string into temporary buffer szFormatted
    szUnformatted = ResourceString ( dwResourceId );

    // Todo: Remove argument count restriction - currently 1 LPWSTR
    if ( 0 != lstrcmpiW ( cwszMissingResourceString, szUnformatted ) ) {
        LPWSTR  p1 = NULL; 
        LPWSTR  p2 = NULL;
        LPWSTR  p3 = NULL;
        LPWSTR  p4 = NULL;
        LPWSTR  p5 = NULL;      // Handle up to 5 arguments.
        LPWSTR  p6 = NULL;
//        dwStatus = swprintf ( szFormatted, szUnformatted, pargList ); 
        
        p1 = va_arg ( *pargList, LPWSTR );
        
        if ( NULL == p1 ) {
            dwStatus = swprintf ( szFormatted, szUnformatted ); 
        } else {
            p2 = va_arg ( *pargList, LPWSTR );
            if ( NULL == p2 ) {
                dwStatus = swprintf ( szFormatted, szUnformatted, p1 ); 
            } else {
                p3 = va_arg ( *pargList, LPWSTR );
                if ( NULL == p3 ) {
                    dwStatus = swprintf ( szFormatted, szUnformatted, p1, p2 ); 
                } else {
                    p4 = va_arg ( *pargList, LPWSTR );
                    if ( NULL == p4 ) {
                        dwStatus = swprintf ( szFormatted, szUnformatted, p1, p2, p3 ); 
                    } else {
                        p5 = va_arg ( *pargList, LPWSTR );
                        if ( NULL == p5 ) {
                            dwStatus = swprintf ( szFormatted, szUnformatted, p1, p2, p3, p4 ); 
                        } else {
                            p6 = va_arg ( *pargList, LPWSTR );\
                            assert ( NULL == p6 );
                            dwStatus = swprintf ( szFormatted, szUnformatted, p1, p2, p3, p4, p5 );                            
                        }
                    }
                }
            }
        }
        // Swprintf returns length of formatted string
        if ( 0 != dwStatus ) {
            dwStatus = ERROR_SUCCESS;
        } else {
            dwStatus = ERROR_GEN_FAILURE;
        }

    } else { 
        dwStatus = ERROR_GEN_FAILURE;                   // No resource string found
    }

    return dwStatus;

}

void    _stdcall 
DisplayResourceString (
    DWORD dwResourceId,
    ... )
{
    DWORD dwStatus = ERROR_SUCCESS;
    WCHAR szTemp [MAX_MESSAGE_LENGTH];               // Todo:  Eliminate length restriction

    va_list argList;
    va_start(argList, dwResourceId);

    dwStatus = FormatResourceString (
                dwResourceId,
                szTemp,
                &argList ); 

    if ( ERROR_SUCCESS == dwStatus ) {
        wprintf ( szTemp );
    } else {
        wprintf ( cwszNoErrorMessage );          
    }
    wprintf ( cwszNewLine );

    va_end(argList);

    return;
}

void    _stdcall
DisplayErrorMessage (
    DWORD dwMessageId,
    ... )
{
    DWORD dwStatus = ERROR_SUCCESS;
    WCHAR szTemp [MAX_MESSAGE_LENGTH];                // Todo:  Eliminate length restriction
    DWORD dwResourceId;

    va_list(argList);
    va_start(argList, dwMessageId);

    if ( IsLogManMessage ( dwMessageId, &dwResourceId ) ) {

        dwStatus = FormatResourceString ( 
                    dwResourceId,
                    szTemp,
                    &argList );
    } else {

        // Format message into temporary buffer szTemp

        dwStatus = FormatSystemMessage (
                    dwMessageId,
                    szTemp,
                    MAX_MESSAGE_LENGTH,
                    &argList );                         

    }

    if ( ERROR_SUCCESS == dwStatus ) {
        wprintf ( szTemp );
    } else {
        wprintf ( cwszNoErrorMessage );            
    };
    wprintf ( cwszNewLine );
        
    va_end(argList);

    return;
}

DWORD   _stdcall
FormatSystemMessage (
    DWORD   dwMessageId,
    LPWSTR  pszSystemMessage, 
    DWORD   dwBufLen,
    ... )
{
    DWORD dwReturn = 0;
    HMODULE hModule = NULL;
    LPVOID  pMsgBuf = NULL;
    DWORD dwFlags;
    
    va_list(argList);
    va_start(argList, dwBufLen);

    pszSystemMessage[0] = NULL_W;

    dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM;

    hModule = LoadLibraryW ( cwszPdhDll );

    if ( NULL != hModule ) {
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    dwReturn = ::FormatMessageW ( 
                     dwFlags,           
                     hModule,
                     dwMessageId,
                     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                     (LPWSTR)&pMsgBuf,
                     0,
                     NULL );

    // Todo: dwReturn seems to return failure even on success.  Possibly because argList is non-Null?
    if ( NULL != hModule ) {
        FreeLibrary ( hModule );
    }
    
    // TODO:  Check buffer length
    if ( 0 == lstrlenW ( (LPWSTR)pMsgBuf ) ) {
        swprintf ( pszSystemMessage, cwszMessageIdFormatString, dwMessageId );
    } else {
        swprintf ( pszSystemMessage, cwszSystemError, (LPWSTR)pMsgBuf );
    }

    LocalFree ( pMsgBuf );

    va_end(argList);
    
    return ERROR_SUCCESS;
}

INT
GetNumSeparators  (
    LPTSTR& rpDecimal,
    LPTSTR& rpThousand )
{
#define NUM_BUF_LEN  4
    INT iLength;

    static TCHAR szDecimal[NUM_BUF_LEN];
    static TCHAR szThousand[NUM_BUF_LEN];

    rpDecimal = NULL;
    rpThousand = NULL;

    iLength = GetLocaleInfo (
                    LOCALE_USER_DEFAULT,
                    LOCALE_SDECIMAL,
                    szDecimal,
                    NUM_BUF_LEN );

    if ( 0 != iLength ) {
        iLength  = GetLocaleInfo (
                        LOCALE_USER_DEFAULT,
                        LOCALE_STHOUSAND,
                        szThousand,
                        NUM_BUF_LEN );

    }

    if ( 0 != iLength ) {
        rpDecimal = szDecimal;
        rpThousand = szThousand;
    }

    return iLength;
}


BOOL    _stdcall 
FileRead (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToRead)
{  
    BOOL           bSuccess ;
    DWORD          nAmtRead ;

    bSuccess = ReadFile (hFile, lpMemory, nAmtToRead, &nAmtRead, NULL) ;
    return (bSuccess && (nAmtRead == nAmtToRead)) ;
}  // FileRead

BOOL    _stdcall 
FileWrite (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToWrite)
{  
   BOOL           bSuccess = FALSE;
   DWORD          nAmtWritten  = 0;
   DWORD          dwFileSizeLow, dwFileSizeHigh;
   LONGLONG       llResultSize;
    
   dwFileSizeLow = GetFileSize (hFile, &dwFileSizeHigh);
   // limit file size to 2GB

   if (dwFileSizeHigh > 0) {
      SetLastError (ERROR_WRITE_FAULT);
      bSuccess = FALSE;
   } else {
      // note that the error return of this function is 0xFFFFFFFF
      // since that is > the file size limit, this will be interpreted
      // as an error (a size error) so it's accounted for in the following
      // test.
      llResultSize = dwFileSizeLow + nAmtToWrite;
      if (llResultSize >= 0x80000000) {
          SetLastError (ERROR_WRITE_FAULT);
          bSuccess = FALSE;
      } else {
          // write buffer to file
          bSuccess = WriteFile (hFile, lpMemory, nAmtToWrite, &nAmtWritten, NULL) ;
          if (bSuccess) 
              bSuccess = (nAmtWritten == nAmtToWrite ? TRUE : FALSE);
          if ( !bSuccess ) {
              SetLastError (ERROR_WRITE_FAULT);
          }
      }
   }

   return (bSuccess) ;

}  // FileWrite

// This routine extract the filename portion from a given full-path filename
LPTSTR  _stdcall 
ExtractFileName (LPTSTR pFileSpec)
{
   LPTSTR   pFileName = NULL ;
   TCHAR    DIRECTORY_DELIMITER1 = TEXT('\\') ;
   TCHAR    DIRECTORY_DELIMITER2 = TEXT(':') ;

   if (pFileSpec)
      {
      pFileName = pFileSpec + lstrlen (pFileSpec) ;

      while (*pFileName != DIRECTORY_DELIMITER1 &&
         *pFileName != DIRECTORY_DELIMITER2)
         {
         if (pFileName == pFileSpec)
            {
            // done when no directory delimiter is found
            break ;
            }
         pFileName-- ;
         }

      if (*pFileName == DIRECTORY_DELIMITER1 ||
         *pFileName == DIRECTORY_DELIMITER2)
         {
         // directory delimiter found, point the
         // filename right after it
         pFileName++ ;
         }
      }
   return pFileName ;
}  // ExtractFileName


BOOL    _stdcall
LoadDefaultLogFileFolder(
    TCHAR *szFolder
    )
{
    DWORD   nErr;
    HKEY    hKey;
    DWORD   dwDataType;
    DWORD   dwDataSize;

    if (szFolder == NULL)
        return FALSE;
    nErr = RegOpenKey(
             HKEY_LOCAL_MACHINE,
             _T("System\\CurrentControlSet\\Services\\SysmonLog"),
             &hKey
             );
    if (nErr != ERROR_SUCCESS)
        return FALSE;

    *szFolder = 0;

    // NOTE: Assumes szFolder has enough storage for RegQuery to work
    nErr = RegQueryValueEx(
             hKey,
             _T("DefaultLogFileFolder"),
             NULL,
             &dwDataType,
             (LPBYTE) szFolder,
             (LPDWORD) &dwDataSize
             );
    RegCloseKey(hKey);
    return (nErr == ERROR_SUCCESS);
}

DWORD   _stdcall
ParseFolderPath(
    LPCTSTR szOrigPath,
    LPTSTR  szBuffer,
    INT*    piBufLen )
{
    DWORD dwStatus = ERROR_SUCCESS;

    TCHAR   szLocalPath[MAX_PATH];
    TCHAR   cPercent = _T('%');
    TCHAR*  pBeginSymChar;
    const TCHAR*  pNonSymChar;
    TCHAR*  pLocalPathNext;
    INT iTempLen;

    // Return error if original buffer isn't large enough.

    pNonSymChar = szOrigPath;
    pLocalPathNext = szLocalPath;

    // Find and parse each symbol, adding to szLocalPath
    while ( NULL != ( pBeginSymChar = _tcschr ( pNonSymChar, cPercent ) ) ) {

        TCHAR*  pEndSymChar;

        // Move pre-symbol part of path to szLocalPath
        // lstrcpyn count includes terminating NULL character.
        iTempLen = (INT)( pBeginSymChar - pNonSymChar ) + 1;
        lstrcpyn ( pLocalPathNext, pNonSymChar, iTempLen );
        // Move pointer to NULL terminator
        pLocalPathNext += iTempLen - 1;

        // Find end symbol delimiter
        pEndSymChar = _tcschr ( pBeginSymChar + 1, cPercent );

        if ( NULL != pEndSymChar ) {
            TCHAR   szSymbol[MAX_PATH];
            TCHAR*  pszTranslated;

            // Parse symbol
            lstrcpyn ( szSymbol,
                       pBeginSymChar + 1,
                       (int)(pEndSymChar - pBeginSymChar) );
            pszTranslated = _tgetenv ( szSymbol );

            if ( NULL != pszTranslated ) {
                iTempLen = lstrlen (pszTranslated) + 1;
                lstrcpyn ( pLocalPathNext, pszTranslated, iTempLen );
                // Move pointer to NULL terminator
                pLocalPathNext += iTempLen - 1;

                // Set up to find next symbol.
                pNonSymChar = pEndSymChar + 1;
                if ( 0 == lstrlen (pNonSymChar) ) {
                    // Done.
                    break;
                }

            } else {
                // Path incorrect.
                dwStatus = ERROR_BAD_PATHNAME;
                break;
            }
        } else {
            // Path incorrect.
            dwStatus = ERROR_BAD_PATHNAME;
            break;
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        // Move last part of path to szLocalPath
        iTempLen = lstrlen (pNonSymChar) + 1;
        lstrcpyn ( pLocalPathNext, pNonSymChar, iTempLen );

        // Move string to buffer, checking size.
        // Add room for NULL termination
        iTempLen = lstrlen (szLocalPath ) + 1;

        if ( *piBufLen >= iTempLen ) {
            lstrcpy ( szBuffer, szLocalPath );
        } else {
            dwStatus = ERROR_INSUFFICIENT_BUFFER;
        }

        *piBufLen = iTempLen;
    }

    return dwStatus;
}

DWORD 
SlqTimeToMilliseconds (
    SLQ_TIME_INFO* pTimeInfo,
    LONGLONG* pllmsecs)
{
    BOOL bStatus = TRUE;    // Success

    if ( SLQ_TT_DTYPE_UNITS == pTimeInfo->wDataType ) {

        switch (pTimeInfo->dwUnitType) {
            case SLQ_TT_UTYPE_SECONDS:
                *pllmsecs = pTimeInfo->dwValue;
                break;
            case SLQ_TT_UTYPE_MINUTES:
                *pllmsecs = pTimeInfo->dwValue * SECONDS_IN_MINUTE;
                break;

            case SLQ_TT_UTYPE_HOURS:
                *pllmsecs = pTimeInfo->dwValue * SECONDS_IN_HOUR;
                break;

            case SLQ_TT_UTYPE_DAYS:
                *pllmsecs = pTimeInfo->dwValue * SECONDS_IN_DAY;
                break;

            default:
                bStatus = FALSE;
                *pllmsecs = 0;
        }

        *pllmsecs *= 1000;

    } else {
        bStatus = FALSE;
    }

    return bStatus;
}

static
DWORD   _stdcall
ScanHexFormat(
    IN LPCWSTR  szBuffer,
    IN ULONG    ulMaximumLength,
    IN LPCWSTR  szFormat,
    ...)
/*++

Routine Description:

    Scans a source szBuffer and places values from that buffer into the parameters
    as specified by szFormat.

Arguments:

    szBuffer -
        Contains the source buffer which is to be scanned.

    ulMaximumLength -
        Contains the maximum length in characters for which szBuffer is searched.
        This implies that szBuffer need not be UNICODE_NULL terminated.

    szFormat -
        Contains the format string which defines both the acceptable string format
        contained in szBuffer, and the variable parameters which follow.

    NOTE:  This code is from \ntos\rtl\guid.c

Return Value:

    Returns the number of parameters filled if the end of the szBuffer is reached,
    else -1 on an error.

--*/
{
    va_list ArgList;
    int     iFormatItems;

    va_start(ArgList, szFormat);
    for (iFormatItems = 0;;) {
        switch (*szFormat) {
        case 0:
            return (*szBuffer && ulMaximumLength) ? -1 : iFormatItems;
        case '%':
            szFormat++;
            if (*szFormat != '%') {
                ULONG   Number;
                int     Width;
                int     Long;
                PVOID   Pointer;

                for (Long = 0, Width = 0;; szFormat++) {
                    if ((*szFormat >= '0') && (*szFormat <= '9')) {
                        Width = Width * 10 + *szFormat - '0';
                    } else if (*szFormat == 'l') {
                        Long++;
                    } else if ((*szFormat == 'X') || (*szFormat == 'x')) {
                        break;
                    }
                }
                szFormat++;
                for (Number = 0; Width--; szBuffer++, ulMaximumLength--) {
                    if (!ulMaximumLength)
                        return (DWORD)(-1);
                    Number *= 16;
                    if ((*szBuffer >= '0') && (*szBuffer <= '9')) {
                        Number += (*szBuffer - '0');
                    } else if ((*szBuffer >= 'a') && (*szBuffer <= 'f')) {
                        Number += (*szBuffer - 'a' + 10);
                    } else if ((*szBuffer >= 'A') && (*szBuffer <= 'F')) {
                        Number += (*szBuffer - 'A' + 10);
                    } else {
                        return (DWORD)(-1);
                    }
                }
                Pointer = va_arg(ArgList, PVOID);
                if (Long) {
                    *(PULONG)Pointer = Number;
                } else {
                    *(PUSHORT)Pointer = (USHORT)Number;
                }
                iFormatItems++;
                break;
            }
            /* no break */
        default:
            if (!ulMaximumLength || (*szBuffer != *szFormat)) {
                return (DWORD)(-1);
            }
            szBuffer++;
            ulMaximumLength--;
            szFormat++;
            break;
        }
    }
}

DWORD _stdcall
GuidFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID* Guid
    )
/*++

Routine Description:

    Retrieves a the binary format of a textual GUID presented in the standard
    string version of a GUID: "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    GuidString -
        Place from which to retrieve the textual form of the GUID.

    Guid -
        Place in which to put the binary form of the GUID.

    NOTE:  This code is from \ntos\rtl\guid.c

Return Value:

    Returns ERROR_SUCCESS if the buffer contained a valid GUID, else
    ERROR_INVALID_PARAMETER if the string was invalid.

--*/
{
    USHORT    Data4[8];
    int       Count;

    if (ScanHexFormat(GuidString->Buffer, GuidString->Length / sizeof(WCHAR), cwszGuidFormat, &Guid->Data1, &Guid->Data2, &Guid->Data3, &Data4[0], &Data4[1], &Data4[2], &Data4[3], &Data4[4], &Data4[5], &Data4[6], &Data4[7]) == -1) {
        return (DWORD)(ERROR_INVALID_PARAMETER);
    }
    for (Count = 0; Count < sizeof(Data4)/sizeof(Data4[0]); Count++) {
        Guid->Data4[Count] = (UCHAR)Data4[Count];
    }
    return ERROR_SUCCESS;
}

DWORD __stdcall
IsValidDirPath (    
    LPCWSTR cszPath,
    BOOL    bLastNameIsDirectory,
    BOOL    bCreateMissingDirs,
    BOOL&   rbIsValid )
/*++

Routine Description:

    Creates the directory specified in szPath and any other "higher"
        directories in the specified path that don't exist.

Arguments:

    IN  LPCWSTR cszPath
        directory path to create (assumed to be a DOS path, not a UNC)

    IN  BOOL bLastNameIsDirectory
        TRUE when the last name in the path is a Directory and not a File
        FALSE if the last name is a file

    IN  BOOL bCreateMissingDirs
        TRUE will create any dirs in the path that are not found
        FALSE will only test for existence and not create any
            missing dirs.

    OUT BOOL rbIsValid
        TRUE    if the directory path now exists
        FALSE   if error (GetLastError to find out why)

Return Value:

    DWSTATUS
--*/
{
    WCHAR   szLocalPath[MAX_PATH+1];
    LPWSTR  szEnd;
    LPSECURITY_ATTRIBUTES   lpSA = NULL;
    DWORD   dwAttr;
    DWORD   dwStatus = ERROR_SUCCESS;

    rbIsValid = FALSE;

    ZeroMemory ( szLocalPath, sizeof ( szLocalPath ) );

    if ( 0 < GetFullPathNameW (
                cszPath,
                MAX_PATH,
                szLocalPath,
                NULL ) ) {

        szEnd = &szLocalPath[3];

        if ( NULL_W != *szEnd ) {
            // then there are sub dirs to create
            while ( NULL_W != *szEnd ) {
                // go to next backslash
                while ( ( BACKSLASH_W != *szEnd ) && ( NULL_W != *szEnd ) ) {
                    szEnd++;
                }
                if ( BACKSLASH_W != *szEnd ) {
                    // terminate path here and create directory
                    *szEnd = NULL_W;
                    if (bCreateMissingDirs) {
                        if (!CreateDirectoryW (szLocalPath, lpSA)) {
                            // see what the error was and "adjust" it if necessary
                            dwStatus = GetLastError();
                            if ( ERROR_ALREADY_EXISTS == dwStatus ) {
                                // this is OK
                                dwStatus = ERROR_SUCCESS;
                                rbIsValid = TRUE;
                            } else {
                                rbIsValid = FALSE;
                            }
                        } else {
                            // directory created successfully so update count
                            rbIsValid = TRUE;
                        }
                    } else {
                        if ((dwAttr = GetFileAttributesW(szLocalPath)) != 0xFFFFFFFF) {
                            // make sure it's a dir
                            if ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) ==
                                FILE_ATTRIBUTE_DIRECTORY) {
                                rbIsValid = TRUE;
                            } else {
                                // if any dirs fail, then clear the return value
                                rbIsValid = FALSE;
                            }
                        } else {
                            // if any dirs fail, then clear the return value
                            rbIsValid = FALSE;
                        }
                    }
                    // replace backslash and go to next dir
                    *szEnd++ = BACKSLASH_W;
                }
            }
            // create last dir in path now if it's a dir name and not a filename
            if ( bLastNameIsDirectory ) {
                if (bCreateMissingDirs) {
                    if (!CreateDirectoryW (szLocalPath, lpSA)) {
                        // see what the error was and "adjust" it if necessary
                        dwStatus = GetLastError();
                        if ( ERROR_ALREADY_EXISTS == dwStatus ) {
                            // this is OK
                            dwStatus = ERROR_SUCCESS;
                            rbIsValid = TRUE;
                        } else {
                            rbIsValid = FALSE;
                        }
                    } else {
                        // directory created successfully
                        rbIsValid = TRUE;
                    }
                } else {
                    if ((dwAttr = GetFileAttributesW(szLocalPath)) != 0xFFFFFFFF) {
                        // make sure it's a dir
                        if ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) ==
                            FILE_ATTRIBUTE_DIRECTORY) {
                            rbIsValid = TRUE;
                        } else {
                            // if any dirs fail, then clear the return value
                            rbIsValid = FALSE;
                        }
                    } else {
                        // if any dirs fail, then clear the return value
                        rbIsValid = FALSE;
                    }
                }
            }
        } else {
            // else this is a root dir only so return success.
            dwStatus = ERROR_SUCCESS;
            rbIsValid = TRUE;
        }
    } else {
        dwStatus = GetLastError();
    }
        
    return dwStatus;
}

BOOL    _stdcall
IsValidFileName ( LPCWSTR cszFileName )
{   
    LPWSTR szNext;
    BOOL bRetVal = TRUE;

    if ( MAX_PATH < lstrlenW(cszFileName) ) {
        bRetVal = FALSE;
    } else {
        szNext = const_cast<LPWSTR>(cszFileName);
        while(*szNext != '\0'){
            if (*szNext == '?' ||
                *szNext == '\\' ||
                *szNext == '*' ||
                *szNext == '|' ||
                *szNext == '<' ||
                *szNext == '>' ||
                *szNext == '/' ||
                *szNext == ':' ||
                *szNext == '.' ||
                *szNext == '\"'
                ){
                bRetVal = FALSE;
                break;
            }
            szNext++;
        } 
    }
    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\logman\win2000\utils.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    <abstract>

--*/

#ifndef _UTILS_H_
#define _UTILS_H_


//#include <nttypes.h>
#include <ntsecapi.h>       // For PUNICODE_STRING
#include "stdafx.h"
#include "propbag.h"

//===========================================================================
// Macro Definitions
//===========================================================================

#define  DEFAULT_LOG_FILE_SERIAL_NUMBER ((DWORD)0x00000001)
#define  DEFAULT_LOG_FILE_MAX_SIZE      ((DWORD)-1)
#define  DEFAULT_CTR_LOG_FILE_TYPE      SLF_BIN_FILE


//===========================================================================
// Exported Functions
//===========================================================================

//
// Conversion
//
BOOL TruncateLLTime (LONGLONG llTime, LONGLONG* pllTime);
BOOL LLTimeToVariantDate (LONGLONG llTime, DATE *pDate);
BOOL VariantDateToLLTime (DATE Date, LONGLONG *pllTime);
DWORD SlqTimeToMilliseconds ( SLQ_TIME_INFO* pTimeInfo, LONGLONG* pllmsecs);

//
// Property bag I/O 
//

HRESULT _stdcall
DwordFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    DWORD&  rdwData );

HRESULT _stdcall
ShortFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    SHORT& riData );

HRESULT _stdcall
BOOLFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    BOOL& rbData );

HRESULT _stdcall
DoubleFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    DOUBLE& rdblData );

HRESULT _stdcall
FloatFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    FLOAT& rfData );

HRESULT _stdcall
CyFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    CY& rcyData );

HRESULT _stdcall
StringFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    LPWSTR  szData,
    DWORD*  pdwBufLen );

HRESULT _stdcall 
LLTimeFromPropertyBag (
    CPropertyBag* pPropBag,
    LPCWSTR szPropName, 
    LONGLONG& rllData );

HRESULT _stdcall
SlqTimeFromPropertyBag (
    CPropertyBag* pPropBag,
    WORD wFlags, 
    PSLQ_TIME_INFO pstiDefault,
    PSLQ_TIME_INFO pstiData );

// Registry I/O

DWORD _stdcall
AddStringToMszBuffer (
    LPCWSTR szString,
    LPWSTR  szBuffer,
    DWORD*  pdwBufLen,
    DWORD*  pdwBufStringLen );

LONG _stdcall    
WriteRegistryStringValue (
    HKEY    hKey, 
    LPCWSTR cwszValueName,
    DWORD   dwType,     
    LPCWSTR pszBuffer,
    DWORD   dwBufLen );

LONG _stdcall    
WriteRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    LPDWORD  pdwValue,
    DWORD    dwType=REG_DWORD);     // Also supports REG_BINARY

LONG _stdcall    
WriteRegistrySlqTime (
    HKEY    hKey,
    LPCWSTR cwszValueName,
    PSLQ_TIME_INFO    pstiData );

LONG _stdcall    
ReadRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    LPDWORD  pdwValue );     

LONG _stdcall    
ReadRegistrySlqTime (
    HKEY    hKey,
    LPCWSTR cwszValueName,
    PSLQ_TIME_INFO    pstiData );

//
// Wrapper and helper functions for html to registry
//
HRESULT _stdcall
StringFromPropBagAlloc (
    CPropertyBag*   pPropBag,
    LPCWSTR         szPropertyName,
    LPWSTR*         pszBuffer,
    DWORD*          pdwBufferLen,
    DWORD*          pdwStringLen = NULL );

HRESULT _stdcall
AddStringToMszBufferAlloc (
    LPCWSTR     szString,
    LPWSTR*     pszBuffer,
    DWORD*      pdwBufLen,
    DWORD*      pdwBufStringLen );

    
HRESULT _stdcall
InitDefaultSlqTimeInfo (
    DWORD           dwQueryType,
    WORD            wTimeType,
    PSLQ_TIME_INFO  pstiData );

/*
HRESULT
ProcessStringProperty (
    CPropertyBag*   pPropBag,
    HKEY            hKeyParent,
    LPCWSTR         szHtmlPropertyName,
    LPCWSTR         szRegPropertyName,
    DWORD           dwRegType,
    LPWSTR*         pszBuffer,
    DWORD*          pdwBufferLen );
*/
//
// Resources
//
LPWSTR ResourceString(UINT uID);

//
// Messages
//

DWORD   _stdcall
FormatSystemMessage (
    DWORD   dwMessageId,
    LPWSTR  pszSystemMessage, 
    DWORD   dwBufSize,
    ... );

DWORD   _stdcall
FormatResourceString (
    DWORD   dwResourceId,
    LPWSTR  pszFormattedString, 
    DWORD   dwBufSize,
    va_list*    pargList );

    
void    _stdcall
DisplayResourceString (
    DWORD dwResourceId,
    ... );

void    _stdcall
DisplayErrorMessage (
    DWORD dwMessageId,
    ... );

BOOL    _stdcall
IsLogManMessage ( 
    DWORD   dwMessageId,
    DWORD*  pdwResourceId = NULL );

//
// Files
//

BOOL    _stdcall 
FileRead (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToRead );

BOOL    _stdcall                                
FileWrite (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToWrite );

BOOL    _stdcall
IsValidFileName ( 
    LPCWSTR cszFileName );


LPTSTR  _stdcall    
ExtractFileName (
    LPTSTR pFileSpec );
//
// Folder path 
//
BOOL    _stdcall
LoadDefaultLogFileFolder(
    TCHAR *szFolder
    );

DWORD   _stdcall
ParseFolderPath(
    LPCTSTR szOrigPath,
    LPTSTR  szBuffer,
    INT*    piBufLen );

DWORD __stdcall
IsValidDirPath (    
    LPCWSTR cszPath,
    BOOL    bLastNameIsDirectory,
    BOOL    bCreateMissingDirs,
    BOOL&   rbIsValid );
    
//
// Guids
//
DWORD _stdcall
GuidFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID* Guid );



#endif //_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\relog\relogger.cpp ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <wtypes.h>

#include <pdh.h>
#include <pdhmsg.h>
#include <pdhp.h>

#include "resource.h"

#include "varg.c"


DWORD GetLogFormat( LPTSTR str, LPDWORD pdwFormat );
PDH_STATUS GetCountersFromFile( BOOL bExpand, HLOG hLog, HQUERY hQuery );
PDH_STATUS QueryLog( HLOG hLog, HQUERY hQuery, FILE* f );
PDH_STATUS AddCounters( BOOL bExpand, HLOG hLog, HQUERY hQuery );
_inline BOOL IsTextFormat( DWORD dwFormat );

#define PDH_LOG_TYPE_RETIRED_BIN_ 3
#define CHECK_STATUS( hr )       if( ERROR_SUCCESS != hr ){ goto cleanup; }

#define RELOG_ERROR_BADFILES    0xF0000001
#define RELOG_ERROR_BADFORMAT   0xF0000002
#define RELOG_ERROR_TIMERANGE   0xF0000003
#define RELOG_ERROR_BADAPPEND   0xF0000004

VARG_DECLARE_COMMANDS
    VARG_DEBUG( VARG_FLAG_OPTIONAL|VARG_FLAG_HIDDEN )
    VARG_HELP ( VARG_FLAG_OPTIONAL )
    VARG_BOOL ( IDS_PARAM_APPEND,       VARG_FLAG_OPTIONAL, FALSE )    
    VARG_MSZ  ( IDS_PARAM_COUNTERS,     VARG_FLAG_OPTIONAL, _T("") )
    VARG_STR  ( IDS_PARAM_COUNTERFILE,  VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME, _T("") )
    VARG_STR  ( IDS_PARAM_FORMAT,       VARG_FLAG_OPTIONAL|VARG_FLAG_LITERAL, _T("BIN") )
    VARG_MSZ  ( IDS_PARAM_INPUT,        VARG_FLAG_REQUIRED|VARG_FLAG_NOFLAG|VARG_FLAG_EXPANDFILES|VARG_FLAG_ARG_FILENAME, _T("") ) 
    VARG_INT  ( IDS_PARAM_INTERVAL,     VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DEFAULT, 0 )
    VARG_STR  ( IDS_PARAM_OUTPUT,       VARG_FLAG_OPTIONAL|VARG_FLAG_DEFAULTABLE|VARG_FLAG_RCDEFAULT, IDS_DEFAULT_OUTPUT )
    VARG_DATE ( IDS_PARAM_BEGIN,        VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DATE )
    VARG_DATE ( IDS_PARAM_END,          VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_DATE )
    VARG_INI  ( IDS_PARAM_SETTINGS,     VARG_FLAG_OPTIONAL, NULL )
    VARG_BOOL ( IDS_PARAM_QUERY,        VARG_FLAG_OPTIONAL, FALSE )
    VARG_BOOL ( IDS_PARAM_YES,          VARG_FLAG_OPTIONAL, FALSE )
VARG_DECLARE_NAMES
    eDebug,
    eHelp,
    eAppend,
    eCounters,
    eCounterFile,
    eFormat,
    eInput,
    eInterval,
    eOutput,
    eBegin,
    eEnd,
    eSettings,
    eQuery,
    eYes,
VARG_DECLARE_FORMAT
    VARG_EXHELP( eFormat,       IDS_EXAMPLE_FORMAT )
    VARG_EXHELP( eQuery,        IDS_EXAMPLE_QUERY )
    VARG_EXHELP( eCounterFile,  IDS_EXAMPLE_COUNTERFILE )
    VARG_EXHELP( eCounters,     IDS_EXAMPLE_COUNTERS )
VARG_DECLARE_END

int __cdecl _tmain( int argc, LPTSTR* argv )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    PDH_RELOG_INFO RelogInfo;
    DWORD dwOutputFormat;
    DWORD dwInputFormat;
    PDH_TIME_INFO InputTimeRange;
    LPTSTR strFile = NULL;

    ParseCmd( argc, argv );
    
    HLOG hLogIn = NULL;
    HQUERY hQuery = NULL;
    
    ZeroMemory( &RelogInfo, sizeof(PDH_RELOG_INFO) );

    DWORD dwNumEntries = 1;
    DWORD dwBufferSize = sizeof(PDH_TIME_INFO);
    int nBinary = 0;
    int nFiles = 0;

    if( Commands[eInput].strValue == NULL ){
        dwStatus = ERROR_OUTOFMEMORY;
        goto cleanup;
    }
 
    dwStatus = GetLogFormat( Commands[eFormat].strValue, &dwOutputFormat );
    CHECK_STATUS(dwStatus);
    
    strFile = Commands[eInput].strValue;
    PrintMessage( g_normal, IDS_MESSAGE_INPUT );
    PrintMessage( g_normal, IDS_MESSAGE_FILES );

    while( strFile != NULL && *strFile != _T('\0') ){
        pdhStatus = PdhGetLogFileType( strFile, &dwInputFormat );
        nFiles++;
        if( pdhStatus != ERROR_SUCCESS ){
            dwInputFormat = 0;
        }
        switch( dwInputFormat ){
        case PDH_LOG_TYPE_RETIRED_BIN_:
            PrintMessage( g_normal, IDS_MESSAGE_LOG_OLD_BIN, strFile );
            break;
        case PDH_LOG_TYPE_CSV:
            PrintMessage( g_normal, IDS_MESSAGE_LOG_CSV, strFile );
            break;
        case PDH_LOG_TYPE_TSV:
            PrintMessage( g_normal, IDS_MESSAGE_LOG_TSV, strFile );
            break;
        case PDH_LOG_TYPE_BINARY:
            nBinary++;
            PrintMessage( g_normal, IDS_MESSAGE_LOG_BINARY, strFile );
            break;
        case PDH_LOG_TYPE_PERFMON:
            PrintMessage( g_normal, IDS_MESSAGE_LOG_PERFMON, strFile );
            break;
        default:
            PrintMessage( g_normal, IDS_MESSAGE_LOG_UNKNOWN, strFile );
        }
        strFile += _tcslen(strFile)+1;
    }
    varg_printf( g_normal, _T("\n") );

    if( nFiles > 1 && nFiles > nBinary ){
        dwStatus = RELOG_ERROR_BADFILES;
        goto cleanup;
    }

    pdhStatus = PdhBindInputDataSource( &hLogIn, Commands[eInput].strValue );
    CHECK_STATUS( pdhStatus );
    
    pdhStatus = PdhOpenQueryH( hLogIn, NULL, &hQuery );
    CHECK_STATUS( pdhStatus );

    pdhStatus = PdhGetDataSourceTimeRangeH (
                hLogIn,
                &dwNumEntries,
                &InputTimeRange,
                &dwBufferSize
            );
    CHECK_STATUS( pdhStatus );
    
    SYSTEMTIME st;
    FileTimeToSystemTime( (FILETIME *)&InputTimeRange.StartTime, &st );
    PrintMessage( g_normal, IDS_MESSAGE_BEGIN );
    PrintDate( &st );
    FileTimeToSystemTime( (FILETIME *)&InputTimeRange.EndTime, &st );
    PrintMessage( g_normal, IDS_MESSAGE_END );
    PrintDate( &st );
    PrintMessage( g_normal, IDS_MESSAGE_SAMPLES, InputTimeRange.SampleCount );

    if( Commands[eQuery].bDefined ){
        FILE* f = NULL;
        if( Commands[eOutput].bDefined ){
            dwStatus = CheckFile( Commands[eOutput].strValue, 
                            Commands[eYes].bValue ? 
                            VARG_CF_OVERWRITE : 
                            (VARG_CF_PROMPT|VARG_CF_OVERWRITE) 
                        );
            CHECK_STATUS( dwStatus );

            f = _tfopen( Commands[eOutput].strValue, _T("w") );
            if( NULL == f ){
                dwStatus = GetLastError();
            }
        }
        pdhStatus = QueryLog( hLogIn, hQuery, f );
        if( NULL != f ){
            fclose(f);
        }

    }else if( (!Commands[eCounters].bDefined && !Commands[eCounterFile].bDefined) ){
        
        pdhStatus = QueryLog( hLogIn, hQuery, NULL );
        CHECK_STATUS( pdhStatus );
    }

    if( Commands[eCounters].bDefined ){
        pdhStatus = AddCounters( dwInputFormat, hLogIn, hQuery );
        CHECK_STATUS( pdhStatus );
    }

    if( Commands[eCounterFile].bDefined ){
        pdhStatus = GetCountersFromFile( 
                        (IsTextFormat( dwInputFormat ) || IsTextFormat(dwOutputFormat)), 
                        hLogIn, 
                        hQuery 
                    );
        CHECK_STATUS( pdhStatus );
    }

    if( Commands[eBegin].bDefined ){
        FILETIME   ft;
        SystemTimeToFileTime( &Commands[eBegin].stValue, &ft );
        RelogInfo.TimeInfo.StartTime = *(LONGLONG *)&ft;
        if( RelogInfo.TimeInfo.StartTime >= InputTimeRange.EndTime ){
            dwStatus = RELOG_ERROR_TIMERANGE;
        }
        CHECK_STATUS(dwStatus);
    }

    if( Commands[eEnd].bDefined ){
        FILETIME   ft;
        SystemTimeToFileTime( &Commands[eEnd].stValue, &ft );
        RelogInfo.TimeInfo.EndTime = *(LONGLONG *)&ft;
        if( RelogInfo.TimeInfo.EndTime <= InputTimeRange.StartTime ){
            dwStatus = RELOG_ERROR_TIMERANGE;
        }
        CHECK_STATUS(dwStatus);
    }

    if( Commands[eOutput].bDefined && !Commands[eQuery].bDefined ){
        TCHAR strFile[MAX_PATH];
        TCHAR drive[10];
        TCHAR path[MAXSTR];
        TCHAR file[MAXSTR];
        TCHAR ext[MAXSTR];
        RelogInfo.dwFileFormat = dwOutputFormat;
        _tsplitpath( Commands[eOutput].strValue, drive, path, file, ext );
        if( 0 == _tcslen( ext ) ){
            switch( RelogInfo.dwFileFormat ){
            case PDH_LOG_TYPE_TSV: _tcscpy( ext, _T("tsv") ); break;
            case PDH_LOG_TYPE_CSV: _tcscpy( ext, _T("csv") ); break;
            case PDH_LOG_TYPE_SQL: break;
            case PDH_LOG_TYPE_BINARY: 
                _tcscpy( ext, _T("blg") ); break;
            }
        }
        _tmakepath( strFile, drive, path, file, ext );
        
        if( PDH_LOG_TYPE_SQL != dwOutputFormat ){
            if( Commands[eAppend].bDefined ){
                dwStatus = CheckFile( strFile, 0 );
            }else{
                dwStatus = CheckFile( strFile, Commands[eYes].bValue ? VARG_CF_OVERWRITE : (VARG_CF_PROMPT|VARG_CF_OVERWRITE) );
            }
            CHECK_STATUS(dwStatus);
        }

        RelogInfo.dwFlags = PDH_LOG_WRITE_ACCESS | PDH_LOG_CREATE_ALWAYS;

        if( Commands[eAppend].bValue ){
            if( IsTextFormat( dwOutputFormat) ){
                if( PDH_LOG_TYPE_SQL != dwOutputFormat ){
                    dwStatus = RELOG_ERROR_BADAPPEND;
                    goto cleanup;
                }
            }else{
                pdhStatus = PdhGetLogFileType( Commands[eOutput].strValue, &dwOutputFormat );
                if( ERROR_SUCCESS == pdhStatus && PDH_LOG_TYPE_BINARY == dwOutputFormat ){
                    RelogInfo.dwFlags |= PDH_LOG_OPT_APPEND;
                }else{
                    if( ERROR_SUCCESS == pdhStatus ){
                        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                    }
                    goto cleanup;
                }
            }
        }

        RelogInfo.strLog = strFile;
        RelogInfo.TimeInfo.SampleCount = Commands[eInterval].nValue;
        
        pdhStatus = PdhRelog( hLogIn, &RelogInfo );
        CHECK_STATUS( pdhStatus );

        PrintMessage( g_normal, IDS_MESSAGE_OUTPUT );
        PrintMessage( g_normal, IDS_MESSAGE_FILE, RelogInfo.strLog );

        SYSTEMTIME st;
        FileTimeToSystemTime( (FILETIME *)&RelogInfo.TimeInfo.StartTime, &st );
        PrintMessage( g_normal, IDS_MESSAGE_BEGIN );
        PrintDate( &st );
        FileTimeToSystemTime( (FILETIME *)&RelogInfo.TimeInfo.EndTime, &st );
        PrintMessage( g_normal, IDS_MESSAGE_END );
        PrintDate( &st );
        PrintMessage( g_normal, IDS_MESSAGE_SAMPLES, RelogInfo.TimeInfo.SampleCount );

    }
    
cleanup:
    if( hLogIn != NULL ){
        PdhCloseLog( hLogIn, PDH_FLAGS_CLOSE_QUERY );
    }

    switch( dwStatus ){
    case RELOG_ERROR_TIMERANGE:
        PrintMessage( g_debug, IDS_MESSAGE_BADRANGE );
        break;
    case RELOG_ERROR_BADFORMAT:
        PrintMessage( g_debug, IDS_MESSAGE_BADFORMAT, Commands[eFormat].strValue );
        break;
    case RELOG_ERROR_BADAPPEND:
        PrintMessage( g_debug, IDS_MESSAGE_BADFORMAT, Commands[eFormat].strValue );
        break;
    case RELOG_ERROR_BADFILES:
        PrintMessage( g_debug, IDS_MESSAGE_BADFILES );
        break;
    case ERROR_SUCCESS:
        if( ERROR_SUCCESS == pdhStatus ){
            PrintMessage( g_normal, IDS_MESSAGE_SUCCESS );
        }else{
            PrintErrorEx( pdhStatus, _T("PDH.DLL") );
            dwStatus = pdhStatus;
        }
        break;
    default:
        PrintError( dwStatus );
    }

    FreeCmd();

    return dwStatus;
}

_inline BOOL IsTextFormat( DWORD dwFormat )
{
    switch( dwFormat ){
    case PDH_LOG_TYPE_CSV:
    case PDH_LOG_TYPE_TSV:
    case PDH_LOG_TYPE_SQL:
        return TRUE;
    default:
        return FALSE;
    }
}

DWORD
GetLogFormat( LPTSTR str, LPDWORD pdwFormat )
{
    DWORD dwFormat = PDH_LOG_TYPE_UNDEFINED;

    if( str != NULL ){
        if( !_tcsicmp( str, _T("TSV")) ){
            dwFormat = PDH_LOG_TYPE_TSV;
        }else if( !_tcsicmp( str, _T("CSV")) ){
            dwFormat = PDH_LOG_TYPE_CSV;
        }else if( !_tcsicmp( str, _T("SQL")) ){
            dwFormat = PDH_LOG_TYPE_SQL;
        }else if( !_tcsicmp( str, _T("BIN")) ){
            dwFormat = PDH_LOG_TYPE_BINARY;
        }else if( !_tcsicmp( str, _T("ETL")) ){
            dwFormat = PDH_LOG_TYPE_BINARY;
        }else if( !_tcsicmp( str, _T("BLG")) ){
            dwFormat = PDH_LOG_TYPE_BINARY;
        }
    }

    if( dwFormat == PDH_LOG_TYPE_UNDEFINED ){
        return RELOG_ERROR_BADFORMAT;
    }

    *pdwFormat = dwFormat;

    return ERROR_SUCCESS;
}

PDH_STATUS 
RelogGetMachines( HLOG hLog, LPTSTR* mszMachines )
{
    PDH_STATUS pdhStatus;
    DWORD dwSize = 0;

    pdhStatus = PdhEnumMachinesH( hLog, NULL, &dwSize );
    
    if( ERROR_SUCCESS == pdhStatus || 
        PDH_MORE_DATA == pdhStatus || 
        PDH_INSUFFICIENT_BUFFER == pdhStatus ){

        *mszMachines = (LPTSTR)VARG_ALLOC( sizeof(TCHAR)*dwSize );
        if( *mszMachines != NULL ){
            pdhStatus = PdhEnumMachinesH( hLog, *mszMachines, &dwSize );
        }else{
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }

    return pdhStatus;

}

PDH_STATUS 
RelogAddCounter( BOOL bExpand, HLOG hLog, HQUERY hQuery, LPTSTR strCounter, LPTSTR mszMachines )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HCOUNTER pCounter;

    if( hQuery == NULL || strCounter == NULL ){
        return ERROR_SUCCESS;
    }
    
    if( _tcslen( strCounter ) > 3 ){
        if( strCounter[1] == _T('\\') ){
            pdhStatus = PdhAddCounter(
                    hQuery,
                    strCounter,
                    0,
                    &pCounter
                );
        }else{
            TCHAR buffer[MAXSTR];
            LPTSTR strMachine = mszMachines;
            if( strMachine != NULL ){
                while( *strMachine != _T('\0') ){

                    _stprintf( buffer, _T("%s%s%s"), 
                        strMachine,
                        (*strCounter == _T('\\')) ? _T("") : _T("\\"),
                        strCounter );

                    if( bExpand ){

                        LPTSTR pBuffer = NULL;
                        DWORD dwBufferSize = 0;
                        do{
                            pdhStatus = PdhExpandWildCardPathH(
                                        hLog,
                                        buffer,
                                        pBuffer,
                                        &dwBufferSize,
                                        0
                                    );

                            if( PDH_MORE_DATA == pdhStatus ){
                                VARG_FREE( pBuffer );
                                pBuffer = (LPTSTR)VARG_ALLOC( ++dwBufferSize * sizeof(TCHAR) );
                                if( pBuffer == NULL ){
                                    break;
                                }
                            }
                        }while(PDH_MORE_DATA == pdhStatus);

                        if( ERROR_SUCCESS == pdhStatus && pBuffer != NULL ){
                        
                            LPTSTR szCounter = pBuffer;
                            while( *szCounter != _T('\0') ){
                                pdhStatus = PdhAddCounter(
                                        hQuery,
                                        szCounter,
                                        0,
                                        &pCounter
                                    );
                                szCounter += (_tcslen( szCounter) +1 );
                            }
                        }
                        
                        VARG_FREE( pBuffer );

                    }else{

                        pdhStatus = PdhAddCounter(
                                hQuery,
                                buffer,
                                0,
                                &pCounter
                            );
                    }
                    strMachine += (_tcslen( strMachine ) + 1);
                    
                }
            }

        }
    }

    return ERROR_SUCCESS;
}

PDH_STATUS
AddCounters( BOOL bExpand, HLOG hLog, HQUERY hQuery )
{
    PDH_STATUS pdhStatus;
    LPTSTR strPath = Commands[eCounters].strValue;
    LPTSTR mszMachines = NULL;
    RelogGetMachines( hLog, &mszMachines );
    if( strPath != NULL ){
        while( *strPath != _T('\0') ){
            pdhStatus = RelogAddCounter( bExpand, hLog, hQuery, strPath, mszMachines );    
            strPath += _tcslen( strPath )+1;
        }
    }

    VARG_FREE( mszMachines );
    return ERROR_SUCCESS;
}

PDH_STATUS 
GetCountersFromFile( BOOL bExpand, HLOG hLog, HQUERY hQuery )
{
    TCHAR buffer[MAXSTR];
    PDH_STATUS pdhStatus;
    LPTSTR strCounter = NULL;
    LPTSTR mszMachines = NULL;

    FILE* f = _tfopen( Commands[eCounterFile].strValue, _T("r") );

    if( !f ){
        DWORD dwStatus = GetLastError();
        return PDH_LOG_FILE_OPEN_ERROR;
    }

    RelogGetMachines( hLog, &mszMachines );

    while( NULL != _fgetts( buffer, MAXSTR, f ) ){

        if( buffer[0] == _T(';') || // comments
            buffer[0] == _T('#') ){
            continue;
        }

        Chomp(buffer);

        strCounter = _tcstok( buffer, _T("\"\n") );
        if( strCounter != NULL ){
            pdhStatus = RelogAddCounter( bExpand, hLog, hQuery, buffer, mszMachines );
        }
    }

    fclose( f );
    VARG_FREE( mszMachines );

    return ERROR_SUCCESS;
}

_inline BOOL IsSameInstance( LPTSTR strLastInstance, LPTSTR strInstance )
{
    if( strLastInstance == NULL || strInstance == NULL ){
        return FALSE;
    }

    return ( _tcscmp( strLastInstance, strInstance ) == 0 );
}

PDH_STATUS 
QueryLog( HLOG hLog, HQUERY hQuery, FILE* f )
{
    PDH_STATUS pdhStatus;

    LPTSTR mszMachines = NULL;
    LPTSTR strMachine = NULL;
    LPTSTR strFullCounterPath = NULL;
    DWORD  dwFullCounterPathSize = 0;
    DWORD  dwMachines = 0;
    HCOUNTER pCounter;

    pdhStatus = PdhEnumMachinesH( hLog, mszMachines, &dwMachines );
    
    if( ERROR_SUCCESS == pdhStatus || 
        PDH_MORE_DATA == pdhStatus || 
        PDH_INSUFFICIENT_BUFFER == pdhStatus ){

        mszMachines = (LPTSTR)VARG_ALLOC( dwMachines * sizeof(TCHAR) );
        if( mszMachines == NULL ){

            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto cleanup;
        }
        pdhStatus = PdhEnumMachinesH( hLog, mszMachines, &dwMachines );

        if( ERROR_SUCCESS == pdhStatus ){
            strMachine = mszMachines;
            while( NULL != strMachine && strMachine[0] != _T('\0') ){
               
                LPTSTR mszObjects = NULL;
                LPTSTR strObject = NULL;
                DWORD  dwObjects = 0;

                pdhStatus = PdhEnumObjectsH( 
                            hLog, 
                            strMachine, 
                            mszObjects, 
                            &dwObjects, 
                            PERF_DETAIL_WIZARD, 
                            FALSE 
                        );

                if( ERROR_SUCCESS == pdhStatus || 
                    PDH_MORE_DATA == pdhStatus || 
                    PDH_INSUFFICIENT_BUFFER == pdhStatus ){

                    mszObjects = (LPTSTR)VARG_ALLOC( dwObjects * sizeof(TCHAR));
                    if( mszObjects == NULL ){
                        VARG_FREE( mszMachines );
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto cleanup;
                    }
                    pdhStatus = PdhEnumObjectsH( 
                                hLog, 
                                strMachine, 
                                mszObjects, 
                                &dwObjects, 
                                PERF_DETAIL_WIZARD, 
                                FALSE 
                            );

                    strObject = mszObjects;
                    while( NULL != strObject && strObject[0] != _T('\0') ){

                        LPTSTR mszCounters = NULL;
                        LPTSTR strCounter = NULL;
                        LPTSTR mszInstances = NULL;
                        LPTSTR strInstance = NULL;
                        DWORD  dwCounters = 0;
                        DWORD  dwInstances = 0;

                        pdhStatus = PdhEnumObjectItemsH( 
                                    hLog, 
                                    strMachine, 
                                    strObject, 
                                    mszCounters, 
                                    &dwCounters, 
                                    mszInstances, 
                                    &dwInstances, 
                                    PERF_DETAIL_WIZARD, 
                                    0 
                                );

                        if( ERROR_SUCCESS == pdhStatus || 
                            PDH_MORE_DATA == pdhStatus || 
                            PDH_INSUFFICIENT_BUFFER == pdhStatus ){
                            
                            if( dwCounters > 0 ){
                                mszCounters = (LPTSTR)VARG_ALLOC( dwCounters * sizeof(TCHAR) );
                            }
                            if( dwInstances > 0 ){
                                mszInstances = (LPTSTR)VARG_ALLOC( dwInstances * sizeof(TCHAR) );
                            }
                            
                            if( (mszCounters == NULL && dwCounters > 0 ) || 
                                (mszInstances == NULL && dwInstances > 0) ){
                                
                                VARG_FREE( mszMachines );
                                VARG_FREE( mszObjects );
                                VARG_FREE( mszCounters );
                                VARG_FREE( mszInstances );
                                
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                goto cleanup;
                            }
                            
                            pdhStatus = PdhEnumObjectItemsH( 
                                        hLog, 
                                        strMachine, 
                                        strObject, 
                                        mszCounters, 
                                        &dwCounters, 
                                        mszInstances,
                                        &dwInstances, 
                                        PERF_DETAIL_WIZARD, 
                                        0 
                                    );

                            if( ERROR_SUCCESS == pdhStatus ){
                                strCounter = mszCounters;
                                while( NULL != strCounter && strCounter[0] != _T('\0') ){
                                    PDH_COUNTER_PATH_ELEMENTS_W pdhElements;
                                    ZeroMemory( &pdhElements, sizeof( PDH_COUNTER_PATH_ELEMENTS ) );

                                    pdhElements.szMachineName = strMachine;
                                    pdhElements.szObjectName = strObject;
                                    pdhElements.szCounterName = strCounter;
                                    strInstance = mszInstances;
                                    
                                    if( NULL != strInstance && strInstance[0] != _T('\0') ){
                                        LPTSTR strLastInstance = NULL;
                                        ULONG nInstance = 0;
                                        while( strInstance[0] != _T('\0') ){

                                            DWORD dwSize = dwFullCounterPathSize;
                                            pdhElements.szInstanceName = strInstance;
                                            
                                            if( ! IsSameInstance( strLastInstance, strInstance ) ){
                                                pdhElements.dwInstanceIndex = -1;
                                                nInstance = 0;
                                            }else{
                                                pdhElements.dwInstanceIndex = ++nInstance;
                                            }

                                            pdhStatus = PdhMakeCounterPath( &pdhElements, strFullCounterPath, &dwSize, 0 );
                                            if( PDH_INSUFFICIENT_BUFFER == pdhStatus || PDH_MORE_DATA == pdhStatus ){
                                                VARG_FREE( strFullCounterPath );
                                                strFullCounterPath = (LPTSTR)VARG_ALLOC( dwSize * sizeof(TCHAR) );
                                                if( NULL != strFullCounterPath ){
                                                    dwFullCounterPathSize = dwSize;
                                                    pdhStatus = PdhMakeCounterPath( &pdhElements, strFullCounterPath, &dwSize, 0 );
                                                }
                                            }

                                            strLastInstance = strInstance;
                                            strInstance += _tcslen( strInstance ) + 1;
                                            if( Commands[eQuery].bValue ){
                                                if( NULL != f ){
                                                    _ftprintf( f, _T("%s\n"), strFullCounterPath );
                                                }else{
                                                    varg_printf( g_normal, _T("%1!s!\n"), strFullCounterPath );
                                                }
                                            }

                                            if( Commands[eCounters].bDefined == FALSE && Commands[eOutput].bDefined ){

                                                pdhStatus = PdhAddCounter(
                                                        hQuery,
                                                        strFullCounterPath,
                                                        0,
                                                        &pCounter
                                                    );
                                            }
                                        }
                                    }else{
                                        DWORD dwSize = dwFullCounterPathSize;
                                        pdhStatus = PdhMakeCounterPath( &pdhElements, strFullCounterPath, &dwSize, 0 );
                                        if( PDH_INSUFFICIENT_BUFFER == pdhStatus || PDH_MORE_DATA == pdhStatus ){
                                            VARG_FREE( strFullCounterPath );
                                            strFullCounterPath = (LPTSTR)VARG_ALLOC( dwSize * sizeof(TCHAR) );
                                            if( NULL != strFullCounterPath ){
                                                dwFullCounterPathSize = dwSize;
                                                pdhStatus = PdhMakeCounterPath( &pdhElements, strFullCounterPath, &dwSize, 0 );
                                            }
                                        }
                                        
                                        if( Commands[eQuery].bValue ){
                                            if( NULL != f ){
                                                _ftprintf( f, _T("%s\n"), strFullCounterPath );
                                            }else{
                                                varg_printf( g_normal, _T("%1!s!\n"), strFullCounterPath );
                                            }
                                        }

                                        if( Commands[eCounters].bDefined == FALSE && Commands[eOutput].bDefined ){

                                            pdhStatus = PdhAddCounter(
                                                    hQuery,
                                                    strFullCounterPath,
                                                    0,
                                                    &pCounter
                                                );
                                        }
                                    }

                                    
                                    strCounter += _tcslen( strCounter ) + 1;
                                }
                            }

                            VARG_FREE( mszCounters );
                            VARG_FREE( mszInstances );

                        }


                        strObject += _tcslen( strObject ) + 1;
                    }
                    VARG_FREE( mszObjects );
                }
                
                
                strMachine += _tcslen( strMachine ) + 1;
            }
        }

        VARG_FREE( mszMachines );
    }

cleanup:
    
    VARG_FREE( strFullCounterPath );

    if( NULL == f ){
        if( ERROR_SUCCESS == pdhStatus && Commands[eQuery].bValue){
            varg_printf( g_normal, _T("\n") );
        }
    }

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\relog\win2000\resource.h ===
#define    IDS_PARAM_APPEND          110
#define    IDS_PARAM_FORMAT          113
#define    IDS_PARAM_INPUT           116
#define    IDS_PARAM_INTERVAL        119
#define    IDS_PARAM_OUTPUT          122
#define    IDS_PARAM_QUERY           125
#define    IDS_PARAM_BEGIN           131
#define    IDS_PARAM_END             134
#define    IDS_PARAM_COUNTERFILE     140
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\relog\win2000\relog.h ===
/*++

Module:

    relog.h

Abstract:

    definitions for relog.exe

Revision History:

    18-Dec-98 bobw (Bob Watson)    Created

--*/
#ifndef _RELOG_H_
#define _RELOG_H_

#define RELOG_VERSION_ID        "0.8"
#define RELOG_RESOURCE_STRING   "Performance Data Relogger (v0.8)"

#endif // _RELOG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\samples\hello\hello.c ===
#include <stdio.h>
#include <guiddef.h>
#include <windows.h>
#include <wmlum.h> // helper library to simplify WMI registration

//#define HELLO_C
//#include "_tracewpp.h"
#include "hello.c.tmh"

enum {
  one,two,three
};

int __cdecl main()
{
	int  i;
	char* s = __FILE__;

        WPP_INIT_TRACING_SIMPLE(L"HelloWorldApp");

	for(i = 0; i < 20; ++i) {
		SimpleTrace("Hello, world! %s %s", LOGNUMBER(i) LOGASTR(s));
		SimpleTrace("Hello, world!",NOARGS);
	}

	SimpleTrace("Hello, %d %s\n", LOGULONG(i) LOGASTR(s) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\relog\win2000\relog.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ReLog.c

Abstract:

    Program to test relogging to a log file

Author:

    Bob Watson (bobw) 2-apr-97

Revision History:

--*/
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pdh.h>
#include <pdhmsg.h>
#include "resource.h"
#include "varg.c"
#include "relog.h"
/*
    LPCTSTR cszInputSwitch = (LPCTSTR)TEXT("/input:");
    LPCTSTR cszOutputSwitch = (LPCTSTR)TEXT("/output:");
    LPCTSTR cszSettingsSwitch = (LPCTSTR)TEXT("/settings:");
    LPCTSTR cszLogtypeSwitch = (LPCTSTR)TEXT("/logtype:");
    LPCTSTR cszFilterSwitch = (LPCTSTR)TEXT("/filter:");
    LPCTSTR cszStartTime = (LPCTSTR)TEXT("/starttime:");
    LPCTSTR cszEndTime = (LPCTSTR)TEXT("/endtime:");
    LPCTSTR cszListSwitch = (LPCTSTR)TEXT("/list");
    LPCTSTR cszAppendSwitch = (LPCTSTR)TEXT("/append");
*/
VARG_RECORD Commands[] = {
    
    VARG_HELP( VARG_FLAG_OPTIONAL )
    VARG_BOOL( IDS_PARAM_APPEND, VARG_FLAG_OPTIONAL, FALSE )
    VARG_STR ( IDS_PARAM_COUNTERFILE, VARG_FLAG_OPTIONAL, _T("") )
    VARG_STR ( IDS_PARAM_FORMAT,VARG_FLAG_OPTIONAL,_T("BLG") )
    VARG_MSZ ( IDS_PARAM_INPUT, VARG_FLAG_REQUIRED|VARG_FLAG_NOFLAG, _T("") )
    VARG_INT ( IDS_PARAM_INTERVAL, VARG_FLAG_OPTIONAL, 0 )
    VARG_TIME( IDS_PARAM_BEGIN, VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_TIME )
    VARG_TIME( IDS_PARAM_END, VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_TIME )
    VARG_STR ( IDS_PARAM_OUTPUT, VARG_FLAG_OPTIONAL, _T("") )
    VARG_BOOL( IDS_PARAM_QUERY, VARG_FLAG_OPTIONAL, FALSE )

    VARG_TERMINATOR
};

enum _Commands {
    eHelp,
    eAppend,
    eCounters,
    eFormat,
    eInput,
    eInterval,
    eBegin,
    eEnd,
    eOutput,
    eQuery
};

LPCTSTR cszBinType = (LPCTSTR)TEXT("bin");
LPCTSTR cszBlgType = (LPCTSTR)TEXT("blg");
LPCTSTR cszCsvType = (LPCTSTR)TEXT("csv");
LPCTSTR cszTsvType = (LPCTSTR)TEXT("tsv");
LPCSTR  cszBinLogFileHeader = "\"(PDH-BIN 4.0)\"\n";
LPCSTR  cszTextRecordTerminator = "\n";

//LPCTSTR cszRelogVersionStr = (LPCWSTR)TEXT(RELOG_VERSION_ID);

#define TextRecordTerminatorSize    1   // size of the string above
FILE    *fSettingsFile = NULL;

#define DBG_SHOW_STATUS_PRINTS  1
#define DBG_NO_STATUS_PRINTS    0

DWORD   dwDbgPrintLevel = DBG_NO_STATUS_PRINTS;

#define ALLOW_REOPEN_OF_SETTINGS_FILE   FALSE

// assume string format of YYYY-MM-DD-hh:mm:ss
//                         0123456789012345678  
// value is index of the first char of that field
#define DATE_STRING_LENGTH      19
#define DATE_SECONDS_OFFSET     17
#define DATE_MINUTES_OFFSET     14
#define DATE_HOURS_OFFSET       11
#define DATE_DAYS_OFFSET        8
#define DATE_MONTH_OFFSET       5

#define NORMAL_MODE         1
#define LIST_MODE           2
#define SUMMARY_MODE        3
#define APPEND_MODE         4
#define HEADER_MODE         5

// structures lifted from pdh\log_bin.h

typedef struct _PDHI_BINARY_LOG_RECORD_HEADER {
    DWORD    dwType;
    DWORD   dwLength;
} PDHI_BINARY_LOG_RECORD_HEADER, *PPDHI_BINARY_LOG_RECORD_HEADER;

//
// the first data record after the log file type record is
// an information record followed by the list of counters contained in this
// log file. the record length is the size of the info header record and
// all the counter info blocks in bytes.
// note that this record can occur later in the log file if the query
// is changed or the log file is appended.
//
typedef struct _PDHI_BINARY_LOG_INFO {
    LONGLONG    FileLength;         // file space allocated (optional)
    DWORD       dwLogVersion;       // version stamp
    DWORD       dwFlags;            // option flags
    LONGLONG    StartTime;
    LONGLONG    EndTime;
    LONGLONG    CatalogOffset;      // offset in file to wild card catalog
    LONGLONG    CatalogChecksum;    // checksum of catalog header
    LONGLONG    CatalogDate;        // date/time catalog was updated
    LONGLONG    FirstRecordOffset;  // pointer to first record [to read] in log
    LONGLONG    LastRecordOffset;   // pointer to last record [to read] in log
    LONGLONG    NextRecordOffset;   // pointer to where next one goes
    LONGLONG    WrapOffset;         // pointer to last byte used in file
    LONGLONG    LastUpdateTime;     // date/time last record was written
    LONGLONG    FirstDataRecordOffset; // location of first data record in file
    // makes the info struct 256 bytes
    // and leaves room for future information
    DWORD       dwReserved[38];
} PDHI_BINARY_LOG_INFO, *PPDHI_BINARY_LOG_INFO;

typedef struct _PDHI_BINARY_LOG_HEADER_RECORD {
    PDHI_BINARY_LOG_RECORD_HEADER   RecHeader;
    PDHI_BINARY_LOG_INFO            Info;
} PDHI_BINARY_LOG_HEADER_RECORD, *PPDHI_BINARY_LOG_HEADER_RECORD;


// new but unexported pdh functions
// these will need to be moved to the PDH.H file
// in the final shipped version

#ifdef UNICODE
PDH_FUNCTION
PdhListLogFileHeaderW (
    IN  LPCWSTR     szFileName,
    IN  LPWSTR      mszHeaderList,
    IN  LPDWORD     pcchHeaderListSize
);
#define PdhListLogFileHeader PdhListLogFileHeaderW
#else   //ANSI

PDH_FUNCTION
PdhListLogFileHeaderA (
    IN  LPCSTR     szFileName,
    IN  LPSTR      mszHeaderList,
    IN  LPDWORD     pcchHeaderListSize
);
#define PdhListLogFileHeader PdhListLogFileHeaderA
#endif

DWORD
GetOutputLogType( LPTSTR str )
{
    DWORD   dwLogType = PDH_LOG_TYPE_CSV;

    if (_tcscmp(str, cszBinType) == 0) {
        dwLogType = PDH_LOG_TYPE_BINARY;
    } else if (_tcscmp(str, cszBlgType) == 0) {
        dwLogType = PDH_LOG_TYPE_BINARY;
    } else if (_tcscmp(str, cszCsvType) == 0) {
        dwLogType = PDH_LOG_TYPE_CSV;
    } else if (_tcscmp(str, cszTsvType) == 0) {
        dwLogType = PDH_LOG_TYPE_TSV;
    } else {
        // return unknown
        dwLogType = PDH_LOG_TYPE_UNDEFINED;
    }
    return dwLogType;
}

DWORD
DoListMode (
    LPCTSTR szInputFile,
    LPCTSTR szOutputFile
)
{
    // BUGBUG: note these should be dynamically allocated
    LPTSTR  szReturnBuffer;
    TCHAR   szMachineList[32768];
    TCHAR   szWildPath[32768];
    // end bugbug
    PDH_STATUS  pdhStatus;
    DWORD       dwBufSize;
    DWORD       dwMlSize;
    LPTSTR  szThisString;
    LPTSTR  szThisMachine;
    FILE    *fOut = NULL;
    DWORD   dwNumEntries;
    PDH_TIME_INFO  pInfo[2];
    DWORD   dwBufferSize = (sizeof(pInfo));    
    SYSTEMTIME  stLogTime;

    dwMlSize = sizeof(szMachineList) / sizeof(szMachineList[0]);
    pdhStatus = PdhEnumMachines (
        szInputFile,
        szMachineList,
        &dwMlSize);

    if ((pdhStatus == ERROR_SUCCESS) && (dwMlSize > 0)) {
        if (*szOutputFile == 0) {
            fOut = stdout;
        } else {
            fOut = _tfopen (szOutputFile, (LPCTSTR)TEXT("wt"));
        }
        pdhStatus = PdhGetDataSourceTimeRange (
            szInputFile,
            &dwNumEntries,
            &pInfo[0],
            &dwBufferSize);

        if (pdhStatus == ERROR_SUCCESS) {
            _ftprintf(fOut, (LPCTSTR)TEXT("\nLogfile: \"%s\" contains %d Records."), szInputFile, pInfo[0].SampleCount);
            // write time range out to file
            FileTimeToSystemTime ((FILETIME *)(&pInfo[0].StartTime), &stLogTime);
            _ftprintf(fOut, (LPCTSTR)TEXT("\n     Start Time: %4.4d-%2.2d-%2.2d-%2.2d:%2.2d:%2.2d"),
                stLogTime.wYear, stLogTime.wMonth, stLogTime.wDay,
                stLogTime.wHour, stLogTime.wMinute, stLogTime.wSecond);
            FileTimeToSystemTime ((FILETIME *)(&pInfo[0].EndTime), &stLogTime);
            _ftprintf(fOut, (LPCTSTR)TEXT("\n       End Time: %4.4d-%2.2d-%2.2d-%2.2d:%2.2d:%2.2d"),
                stLogTime.wYear, stLogTime.wMonth, stLogTime.wDay,
                stLogTime.wHour, stLogTime.wMinute, stLogTime.wSecond);
        }

        
        for (szThisMachine = szMachineList;
             *szThisMachine != 0;
             szThisMachine += _tcsclen(szThisMachine)) {

            if (*szThisMachine != _T('\\')) {
                _tcscpy (szWildPath, (LPCTSTR)TEXT("\\\\"));
                _tcscat (szWildPath, szThisMachine);
                _tcscat (szWildPath, (LPCTSTR)TEXT("\\*(*)\\*"));
            } else {
                _tcscpy (szWildPath, szThisMachine);
                _tcscat (szWildPath, (LPCTSTR)TEXT("\\*(*)\\*"));
            }

            dwBufSize = 512000;
            szReturnBuffer = HeapAlloc (GetProcessHeap(), 
                HEAP_ZERO_MEMORY, 
                dwBufSize * sizeof(TCHAR));

            if (szReturnBuffer != NULL) {

                pdhStatus = PdhExpandWildCardPath (
                    szInputFile,
                    szWildPath,
                    szReturnBuffer,
                    &dwBufSize,
                    0);

                if (dwBufSize != 0) {
                    if (fOut == stdout) {
                        _ftprintf (fOut, (LPCTSTR)TEXT("\nCounters contained in \"%s\":\n"), szInputFile);
                    }

                    for (szThisString = szReturnBuffer;
                         *szThisString != 0;
                         szThisString += _tcsclen(szThisString) + 1) {
                        _ftprintf (fOut, (LPCTSTR)TEXT("%s\n"), szThisString);
                    }
                } else {
                    _tprintf ((LPCTSTR)TEXT("\nError 0x%8.8x (%d) returned from enumeration of machine %s in %s"), 
                        pdhStatus, (DWORD)(pdhStatus & 0x0000FFFF),
                        szThisMachine,
                        szInputFile);
                }

                HeapFree (GetProcessHeap(), 0, szReturnBuffer);
            }

        }
    } else {
        // unable to list log file contents
        _tprintf ((LPCTSTR)TEXT("\nError 0x%8.8x (%d) returned from enumeration of %s"), 
            pdhStatus, (DWORD)(pdhStatus & 0x0000FFFF),
            szInputFile);
    }

    return ERROR_SUCCESS;
}

DWORD
DoHeaderListMode (
    LPCTSTR szInputFile,
    LPCTSTR szOutputFile
)
{
    // end bugbug
    PDH_STATUS  pdhStatus;
    LPTSTR  szThisString;
    FILE    *fOut = NULL;
    DWORD   dwType = 0L;
    HLOG    hLog = NULL;
    LPTSTR  mszHeaderList;
    DWORD   cchHeaderListSize = 0x80000;  // 512K
    DWORD   dwNumEntries;
    PDH_TIME_INFO  pInfo[2];
    DWORD   dwBufferSize = (sizeof(pInfo));    
    SYSTEMTIME  stLogTime;

    mszHeaderList = (LPTSTR)HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, cchHeaderListSize * sizeof(TCHAR));
    if (mszHeaderList != NULL) {
        pdhStatus = PdhListLogFileHeader (
            szInputFile,
            mszHeaderList,
            &cchHeaderListSize);

        if (pdhStatus == ERROR_SUCCESS) {
            if (*szOutputFile == 0) {
                fOut = stdout;
            } else {
                fOut = _tfopen (szOutputFile, (LPCTSTR)TEXT("wt"));
            }
        
            pdhStatus = PdhGetDataSourceTimeRange (
                szInputFile,
                &dwNumEntries,
                &pInfo[0],
                &dwBufferSize);

            if (pdhStatus == ERROR_SUCCESS) {
                _ftprintf(fOut, (LPCTSTR)TEXT("\nLogfile: \"%s\" contains %d Records."), szInputFile, pInfo[0].SampleCount);
                // write time range out to file
                FileTimeToSystemTime ((FILETIME *)(&pInfo[0].StartTime), &stLogTime);
                _ftprintf(fOut, (LPCTSTR)TEXT("\n     Start Time: %4.4d-%2.2d-%2.2d-%2.2d:%2.2d:%2.2d"),
                    stLogTime.wYear, stLogTime.wMonth, stLogTime.wDay,
                    stLogTime.wHour, stLogTime.wMinute, stLogTime.wSecond);
                FileTimeToSystemTime ((FILETIME *)(&pInfo[0].EndTime), &stLogTime);
                _ftprintf(fOut, (LPCTSTR)TEXT("\n       End Time: %4.4d-%2.2d-%2.2d-%2.2d:%2.2d:%2.2d"),
                    stLogTime.wYear, stLogTime.wMonth, stLogTime.wDay,
                    stLogTime.wHour, stLogTime.wMinute, stLogTime.wSecond);
            }

            if (fOut == stdout) {
                _ftprintf (fOut, (LPCTSTR)TEXT("\nCounters contained in %s\n"), szInputFile);
            }

            for (szThisString = mszHeaderList; 
                *szThisString != 0;
                szThisString += _tcsclen(szThisString) + 1) {
                _ftprintf (fOut, (LPCTSTR)TEXT("%s\n"), szThisString);
            }
        } else {
            // unable to list log file contents
            _tprintf ((LPCTSTR)TEXT("\nError 0x%8.8x (%d) returned from enumeration of %s"), 
                pdhStatus, (DWORD)(pdhStatus & 0x0000FFFF),
                szInputFile);
        }

        HeapFree (GetProcessHeap(), HEAP_ZERO_MEMORY, mszHeaderList);
    }

    return ERROR_SUCCESS;
}

HRESULT GetCountersFromFile( HQUERY hQuery )
{
    TCHAR buffer[MAXSTR];
    HCOUNTER pCounter;
    HRESULT hr;
    LPTSTR strCounter = NULL;

    FILE* f = _tfopen( Commands[eCounters].strValue, _T("r") );

    if( !f ){
        return GetLastError();
    }

    while( NULL != _fgetts( buffer, MAXSTR, f ) ){

        if( buffer[0] == ';' || // comments
            buffer[0] == '#' ){
            continue;
        }

        Chomp(buffer);

        strCounter = _tcstok( buffer, _T("\"\n") );
        if( strCounter != NULL ){
            hr = PdhAddCounter(
                    hQuery,
                    buffer,
                    0,
                    &pCounter
                );
        }
    }

    fclose( f );

    return ERROR_SUCCESS;
}

DWORD
DoNormalMode (
    LPCTSTR szInputFile,
    LPCTSTR szOutputFile,
    LPCTSTR szSettingsFile,
    DWORD   dwOutputLogType,
    PDH_TIME_INFO   pdhTimeInfo,
    DWORD   dwFilterCount
)
{
    DWORD   dwNumOutputCounters = 0;
    DWORD   dwRecCount = 0;
    DWORD   dwFiltered;
    LONG    Status = ERROR_SUCCESS;
	PDH_STATUS	PdhStatus;
    PDH_RAW_COUNTER RawValue;

    LPTSTR  szCounterPath = NULL;

	HQUERY	hQuery = NULL;
	HLOG	hOutLog = NULL;
    HLOG    hInLog = NULL;
    HCOUNTER hCounter = NULL;
    HCOUNTER hLastGoodCounter = NULL;
    DWORD   dwType;
    DWORD   dwOpenMode;

    LPTSTR  szReturnBuffer;
    TCHAR   szMachineList[32768];
    TCHAR   szWildPath[32768];
    // end bugbug
    PDH_STATUS  pdhStatus;
    DWORD       dwBufSize;
    DWORD       dwMlSize;
    LPTSTR  szThisString;
    LPTSTR  szThisMachine;
    FILE    *fOut = NULL;

    if (Status == ERROR_SUCCESS) {
 		_tprintf ((LPCTSTR)TEXT("\nRelogging: \"%s\" to \"%s\""), szInputFile, szOutputFile);

		PdhStatus = PdhOpenQuery (szInputFile, 0L, &hQuery);
        if (PdhStatus != ERROR_SUCCESS) {
            Status = PdhStatus;
    		_tprintf ((LPCTSTR)TEXT("\nPdhOpenQuery returned: 0x%8.8x (%d)"), PdhStatus, PdhStatus);
        }
    }

    if (Status == ERROR_SUCCESS) {
        if (*szSettingsFile == 0) {
            if (dwOutputLogType == PDH_LOG_TYPE_BINARY) {
                // load all counters from input file into query
                LPTSTR  mszHeaderList;
                DWORD   cchHeaderListSize = 0x80000;  // 512K

                mszHeaderList = (LPTSTR)HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, cchHeaderListSize * sizeof(TCHAR));
                if (mszHeaderList != NULL) {
                    PdhStatus = PdhListLogFileHeader (
                        szInputFile,
                        mszHeaderList,
                        &cchHeaderListSize);

                    if (PdhStatus == ERROR_SUCCESS) {
                        // we can recycle the hCounter value since we don't need it for anything after this.
                        for (szCounterPath = mszHeaderList;
                            *szCounterPath != 0;
                            szCounterPath += _tcsclen(szCounterPath) + 1) {
		                    PdhStatus = PdhAddCounter (hQuery, szCounterPath, 0L, &hCounter);
                            if (PdhStatus != ERROR_SUCCESS) {
                                _tprintf ((LPCTSTR)TEXT("\nUnable to add \"%s\", error: 0x%8.8x (%d)"), szCounterPath, PdhStatus, PdhStatus);
                            } else {
                                hLastGoodCounter = hCounter;
                                dwNumOutputCounters++;
                                if (dwDbgPrintLevel == DBG_SHOW_STATUS_PRINTS) {
                                    _tprintf ((LPCTSTR)TEXT("\nRelogging \"%s\""), szCounterPath);
                                }
                            }
                        }
                    }
                    HeapFree (GetProcessHeap(), 0, mszHeaderList);
                }
            } else {
                // enumerate each counter for all non-binary log types
                dwMlSize = sizeof(szMachineList) / sizeof(szMachineList[0]);
                pdhStatus = PdhEnumMachines (
                    szInputFile,
                    szMachineList,
                    &dwMlSize);

                if ((pdhStatus == ERROR_SUCCESS) && (dwMlSize > 0)) {
       
                    for (szThisMachine = szMachineList;
                         *szThisMachine != 0;
                         szThisMachine += _tcsclen(szThisMachine)) {

                        if (*szThisMachine != _T('\\')) {
                            _tcscpy (szWildPath, (LPCTSTR)TEXT("\\\\"));
                            _tcscat (szWildPath, szThisMachine);
                            _tcscat (szWildPath, (LPCTSTR)TEXT("\\*(*)\\*"));
                        } else {
                            _tcscpy (szWildPath, szThisMachine);
                            _tcscat (szWildPath, (LPCTSTR)TEXT("\\*(*)\\*"));
                        }

                        dwBufSize = 512000;
                        szReturnBuffer = HeapAlloc (GetProcessHeap(), 
                            HEAP_ZERO_MEMORY, 
                            dwBufSize * sizeof(TCHAR));

                        if (szReturnBuffer != NULL) {

                            pdhStatus = PdhExpandWildCardPath (
                                szInputFile,
                                szWildPath,
                                szReturnBuffer,
                                &dwBufSize,
                                0);

                            if (dwBufSize != 0) {
                                for (szThisString = szReturnBuffer;
                                     *szThisString != 0;
                                     szThisString += _tcsclen(szThisString) + 1) {
                                    PdhStatus = PdhAddCounter (hQuery, szThisString, 0L, &hCounter);
                                    if (PdhStatus != ERROR_SUCCESS) {
                                        _tprintf ((LPCTSTR)TEXT("\nUnable to add \"%s\", error: 0x%8.8x (%d)"), szThisString, PdhStatus, PdhStatus);
                                    } else {
                                        hLastGoodCounter = hCounter;
                                        dwNumOutputCounters++;
                                        if (dwDbgPrintLevel == DBG_SHOW_STATUS_PRINTS) {
                                            _tprintf ((LPCTSTR)TEXT("\nAdded \"%s\", error: 0x%8.8x (%d)"), szThisString, PdhStatus, PdhStatus);
                                        }
                                    }
                                }
                            }

                            HeapFree (GetProcessHeap(), 0, szReturnBuffer);
                        } else {
                            // unable to allocate memory
                            PdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        }
                     } // end for each machine in the log file
                } else {
                    // unable to list machines
                    // return PDH status
                }
            }
        } else {
            // we can recycle the hCounter value since we don't need it for anything after this.
            GetCountersFromFile( hQuery );
        }
    }
    
    if ((Status == ERROR_SUCCESS) && (dwNumOutputCounters > 0)) {
        dwOpenMode = PDH_LOG_WRITE_ACCESS | PDH_LOG_CREATE_ALWAYS;

        PdhStatus = PdhOpenLog (szOutputFile,
			dwOpenMode,
			&dwOutputLogType,
			hQuery,
			0L,
			NULL,
			&hOutLog);

        if (PdhStatus != ERROR_SUCCESS) {
            Status = PdhStatus;
		    _tprintf ((LPCTSTR)TEXT("\nUnable to open \"%s\" for output, error: 0x%8.8x (%d)"), szOutputFile, PdhStatus, PdhStatus);
        } else {
            // set query range
            PdhStatus = PdhSetQueryTimeRange (hQuery, &pdhTimeInfo);
		    // copy log data to output log
            PdhStatus = PdhUpdateLog (hOutLog, NULL);
            while (PdhStatus == ERROR_SUCCESS) {
                dwRecCount++;
                dwFiltered = 1; 
                while ((dwFiltered < dwFilterCount) && (PdhStatus == ERROR_SUCCESS)) {
                    PdhStatus = PdhCollectQueryData(hQuery);
                    if (PdhStatus == ERROR_SUCCESS) {
                        PdhStatus = PdhGetRawCounterValue  (
                            hLastGoodCounter,
                            &dwType,
                            &RawValue);
                        if (PdhStatus == ERROR_SUCCESS) {
                            // check for bogus timestamps as an inidcation we ran off the end of the file
                            if ((*(LONGLONG *)&RawValue.TimeStamp == 0) ||
                                (*(LONGLONG *)&RawValue.TimeStamp >= pdhTimeInfo.EndTime)){
                                PdhStatus = PDH_END_OF_LOG_FILE;
                            }
                        }
                    }
                    dwFiltered++;
                }
                if (PdhStatus == ERROR_SUCCESS) {
		            PdhStatus = PdhUpdateLog (hOutLog, NULL);
                }
            }

            // PdhStatus should be either PDH_END_OF_LOG_FILE or PDH_NO_MORE_DATA when 
            // the loop above exits, if that's the case then reset status to SUCCESS
            // otherwise display the error 
            if ((PdhStatus == PDH_END_OF_LOG_FILE) || (PdhStatus == PDH_NO_MORE_DATA)) {
                PdhStatus = ERROR_SUCCESS;
            } else {
		        printf ("\nPdhUpdateLog returned: 0x%8.8x (%d)", PdhStatus, PdhStatus);
            }

            // update log catalog while we're at it
            //
            // BUGBUG: For now this isn't working very well so this step
            // will be skipped until it works better (5.1 maybe?)
            /*
            if (dwOutputLogType == PDH_LOG_TYPE_BINARY) { 
		        PdhStatus = PdhUpdateLogFileCatalog (hOutLog);
		        if (PdhStatus != ERROR_SUCCESS) {
                    Status = PdhStatus;
                    _tprintf ((LPCTSTR)TEXT("\nPdhUpdateLogFileCatalog returned: 0x%8.8x (%d)"), PdhStatus, PdhStatus);
                }
            }
            */

            PdhStatus = PdhCloseLog (hOutLog, 0L);
            if (PdhStatus != ERROR_SUCCESS) {
                Status = PdhStatus;
	            printf ("\nPdhCloseLog returned: 0x%8.8x (%d)", PdhStatus, PdhStatus);
            } else {
                hOutLog = NULL;
            }
        } 
	}

    if (hQuery != NULL) {
		PdhStatus = PdhCloseQuery (hQuery);
        if (PdhStatus != ERROR_SUCCESS) {
            Status = PdhStatus;
            printf ("\nPdhCloseLog returned: 0x%8.8x (%d)", PdhStatus, PdhStatus);
        } else {
            hQuery = NULL;
            hCounter = NULL;
        }
    }

    if (Status == ERROR_SUCCESS) {
        _tprintf ((LPCTSTR)TEXT("\n%d records from %s have been relogged to %s"), dwRecCount, szInputFile, szOutputFile);
    }
    
    return Status;
}

DWORD
DoAppendFiles (
    IN LPCTSTR  szAppendFile,
    IN LPCTSTR  szBaseFile,
    IN DWORD    dwFilterCount

)
/*
    append data records from Append file to base file if they 
    contain the same counter data 
    (and hopefully append file starts after base file)
*/
{
    HANDLE  hTempFile;
    TCHAR   szTempFileName[MAX_PATH];
    TCHAR   szTempDirPath[MAX_PATH];

    DWORD   dwReturn = ERROR_SUCCESS;
    PDH_STATUS pdhStatus;
    DWORD   dwFiltered;

    DWORD   dwAppendLogType;
    DWORD   dwBaseLogType;

    HLOG    hAppendLogFile;
    HLOG    hBaseLogFile;

    LPTSTR  mszBaseFileHeader;
    DWORD   cchBaseFileHeaderSize;
    LPTSTR  mszAppendFileHeader;
    DWORD   cchAppendFileHeaderSize;

    PPDH_RAW_LOG_RECORD pRawRecord;
    DWORD   dwRecordBuffSize;
    DWORD   dwRecordSize;
    DWORD   dwRecordIdx;

    BOOL    bStatus;
    DWORD   dwBytesWritten;
    
    PPDHI_BINARY_LOG_HEADER_RECORD  pBinLogHead;

    FILETIME    ftValue;

    DWORD   dwLogRecType;
    BOOL    bIsDataRecord;

    // see if the file headers match
    // read headers of log files
    cchBaseFileHeaderSize = 0x80000;
    mszBaseFileHeader = (LPTSTR)HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, cchBaseFileHeaderSize * sizeof(TCHAR));
    if (mszBaseFileHeader  != NULL) {
        pdhStatus = PdhListLogFileHeader (
            szBaseFile,
            mszBaseFileHeader,
            &cchBaseFileHeaderSize);

        if (pdhStatus == ERROR_SUCCESS) {
            cchAppendFileHeaderSize = 0x80000;
            mszAppendFileHeader = (LPTSTR)HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, cchAppendFileHeaderSize * sizeof(TCHAR));
            if (mszAppendFileHeader  != NULL) {
                pdhStatus = PdhListLogFileHeader (
                    szAppendFile,
                    mszAppendFileHeader,
                    &cchAppendFileHeaderSize);
                if (pdhStatus == ERROR_SUCCESS) {
                    // compare buffers
                    if (cchAppendFileHeaderSize == cchBaseFileHeaderSize) {
                        if (memcmp(mszAppendFileHeader, mszBaseFileHeader, cchBaseFileHeaderSize) == 0) {
                            // same
                            pdhStatus = ERROR_SUCCESS;
                        } else {
                            // different
        		            _tprintf ((LPCTSTR)TEXT("\nInput file counter list is different from that of the output file."));
                            pdhStatus = ERROR_DATATYPE_MISMATCH;
                        }
                    } else {
      		            _tprintf ((LPCTSTR)TEXT("\nInput file counter list is different from that of the output file."));
                        // different sizes
                        pdhStatus = ERROR_DATATYPE_MISMATCH;
                    }
                } else {
                    // unable to read append file
   		            _tprintf ((LPCTSTR)TEXT("\nUnable to read the input file header."));
                }
                HeapFree (GetProcessHeap(), HEAP_ZERO_MEMORY, mszAppendFileHeader);
            } else {
   		        _tprintf ((LPCTSTR)TEXT("\nUnable to allocate an internal memory buffer."));
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        } else {
            // unable to read base file header
            _tprintf ((LPCTSTR)TEXT("\nUnable to read the output file header."));
        }
        HeapFree (GetProcessHeap(), HEAP_ZERO_MEMORY, mszBaseFileHeader);
    } else {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    } 

    if (pdhStatus == ERROR_SUCCESS) {
        // the files have matching headers so get ready to copy them
    
        // create temporary output file name
        GetTempPath (MAX_PATH, szTempDirPath);
        GetTempFileName (szTempDirPath, (LPCTSTR)TEXT("PDH"), 0, szTempFileName);

        hTempFile = CreateFile (
            szTempFileName,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,  // the file is created by GetTempFileName above (go figure)
            FILE_ATTRIBUTE_NORMAL,
            NULL);

            if (hTempFile != INVALID_HANDLE_VALUE) {

            // open log files
            pdhStatus = PdhOpenLog (
                szBaseFile,
                PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                &dwBaseLogType,
                NULL,
                0,
                NULL,
                &hBaseLogFile);

            if (pdhStatus == ERROR_SUCCESS) {
                pdhStatus = PdhOpenLog (
                    szAppendFile,
                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                    &dwAppendLogType,
                    NULL,
                    0,
                    NULL,
                    &hAppendLogFile);
                
                if (pdhStatus == ERROR_SUCCESS) {
                    dwRecordIdx = 1;
                    ftValue.dwHighDateTime = 0xFFFFFFFF;
                    ftValue.dwLowDateTime = dwRecordIdx;
    
                    dwRecordBuffSize = 0x80000;
                    pRawRecord = HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, dwRecordBuffSize);
                    
                    if (pRawRecord != NULL) {
                        dwFiltered = 1;
                        // write headers from first file to temp file
                        while (pdhStatus == ERROR_SUCCESS) {
                            ftValue.dwHighDateTime = 0xFFFFFFFF;
                            ftValue.dwLowDateTime = dwRecordIdx;
                            dwRecordSize = dwRecordBuffSize;
                            pdhStatus = PdhReadRawLogRecord (
                                hBaseLogFile,
                                ftValue,
                                pRawRecord,
                                &dwRecordSize);

                            if (pdhStatus == ERROR_SUCCESS) {
                                bIsDataRecord = TRUE;
                                if (dwRecordIdx == 1) {
                                    bIsDataRecord = FALSE;
                                } else if ((dwRecordIdx == 2) && (pRawRecord->dwRecordType == PDH_LOG_TYPE_BINARY)) {
                                    pBinLogHead = (PPDHI_BINARY_LOG_HEADER_RECORD)&pRawRecord->RawBytes[0];
                                    // only linear files can be appended
                                    if (pBinLogHead->Info.WrapOffset == 0) {
                                        // now fix up the fields in the header so they'll work
                                        // with the new combined file
                                        pBinLogHead->Info.FileLength = 0;         // file space allocated (optional)
                                        pBinLogHead->Info.CatalogOffset = 0;    // the catalog is removed
                                        pBinLogHead->Info.CatalogChecksum = 0;
                                        pBinLogHead->Info.CatalogDate = 0;        // date/time catalog was updated
                                        //pBinLogHead->Info.FirstRecordOffset = 0;  // pointer to first record [to read] in log
                                        pBinLogHead->Info.LastRecordOffset = 0;   // pointer to last record [to read] in log
                                        pBinLogHead->Info.NextRecordOffset = 0;   // pointer to where next one goes
                                        pBinLogHead->Info.WrapOffset = 0;         // pointer to last byte used in file
                                        pBinLogHead->Info.LastUpdateTime = 0;     // date/time last record was written
                                        pBinLogHead->Info.FirstDataRecordOffset = 0; // location of first data record in file
                                    } else {
                                        // file is circular so bail
                                        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                                    }
                                    bIsDataRecord = FALSE;
                                }

                                if (pdhStatus == ERROR_SUCCESS) {
                                    // write the first 2 records of the base file
                                    // then only the data records after that
                                    if ((dwRecordIdx > 2) && (pRawRecord->dwRecordType == PDH_LOG_TYPE_BINARY)) {
                                        // it must be a data record or else skip it
                                        dwLogRecType = *((LPDWORD)&pRawRecord->RawBytes[0]);
                                        if ((dwLogRecType & 0x00FF0000) != 0x00030000) {
                                            // then this is not a data record
                                            // so skip it and get next record
                                            dwRecordIdx++;
                                            continue;
                                        }
                                    }

                                    if ((!bIsDataRecord) || (dwFiltered == dwFilterCount)) {
                                          // write the record to the output file
                                          bStatus = WriteFile (
                                            hTempFile,
                                            &pRawRecord->RawBytes[0],
                                            pRawRecord->dwItems,
                                            &dwBytesWritten,
                                            NULL);
                                        if (!bStatus || (dwBytesWritten != pRawRecord->dwItems)) {
                                            pdhStatus = GetLastError();
                                        } else {
                                            // reset the count
                                            dwFiltered = 1;
                                        }
                                    } else {
                                        // skip this one
                                        if (bIsDataRecord) dwFiltered += 1;
                                    }

                                    // get next record
                                    dwRecordIdx++;
                                }
                            } else if (pdhStatus == PDH_INSUFFICIENT_BUFFER) {
                                    // BUGBUG: expand and retry
                            } else {
                                if ((pdhStatus == PDH_END_OF_LOG_FILE) || (pdhStatus == PDH_ENTRY_NOT_IN_LOG_FILE)) {
                                    // fix up return codes to continue
                                    pdhStatus = ERROR_SUCCESS;
                                } else {
                                    _tprintf ((LPCTSTR)TEXT("\n ReadRaw returned %d (0x%8.8x)"), pdhStatus, pdhStatus);
                                }
                                // bail
                                break;
                            }
                        }

                        // add records from new file
                        if (pdhStatus == ERROR_SUCCESS) {
                            dwRecordIdx = 1;
                            ftValue.dwHighDateTime = 0xFFFFFFFF;
                            ftValue.dwLowDateTime = dwRecordIdx;
    
                            if (pRawRecord != NULL) {
                                // write headers from first file to temp file
                                while (pdhStatus == ERROR_SUCCESS) {
                                    ftValue.dwHighDateTime = 0xFFFFFFFF;
                                    ftValue.dwLowDateTime = dwRecordIdx;
                                    dwRecordSize = dwRecordBuffSize;
                                    pdhStatus = PdhReadRawLogRecord (
                                        hAppendLogFile,
                                        ftValue,
                                        pRawRecord,
                                        &dwRecordSize);

                                    if (pdhStatus == ERROR_SUCCESS) {
                                        bIsDataRecord = TRUE;
                                        if (dwRecordIdx == 1) {
                                            bIsDataRecord = FALSE;
                                        } else if ((dwRecordIdx == 2) && (pRawRecord->dwRecordType == PDH_LOG_TYPE_BINARY)) {
                                            // write only the data records to the output file
                                            // if this isn't the first record, then it must be a data record or 
                                            // or else skip it
                                            dwLogRecType = *((LPDWORD)&pRawRecord->RawBytes[0]);
                                            if ((pRawRecord->dwRecordType == PDH_LOG_TYPE_BINARY) && 
                                                ((dwLogRecType & 0x00FF0000) != 0x00030000)) {
                                                // then this is not a data record
                                                // so skip it and get next record
                                                dwRecordIdx++;
                                                continue;
                                            }
                                        }

                                        if ((!bIsDataRecord) || (dwFiltered == dwFilterCount)) {
                                            bStatus = WriteFile (
                                                hTempFile,
                                                &pRawRecord->RawBytes[0],
                                                pRawRecord->dwItems,
                                                &dwBytesWritten,
                                                NULL);
                                            if (!bStatus || (dwBytesWritten != pRawRecord->dwItems)) {
                                                pdhStatus = GetLastError();
                                            } else {
                                                // reset the count
                                                dwFiltered = 1;
                                            }
                                        } else {
                                            // skip this one
                                            if (bIsDataRecord) dwFiltered += 1;
                                        }

                                        // get next record
                                        dwRecordIdx++;
                                    } else if (pdhStatus == PDH_INSUFFICIENT_BUFFER) {
                                            // BUGBUG: expand and retry
                                    } else {
                                        if ((pdhStatus == PDH_END_OF_LOG_FILE) || (pdhStatus == PDH_ENTRY_NOT_IN_LOG_FILE)) {
                                            // fix up return codes to continue
                                            pdhStatus = ERROR_SUCCESS;
                                        } else {
                                            _tprintf ((LPCTSTR)TEXT("\n ReadRaw returned %d (0x%8.8x)"), pdhStatus, pdhStatus);
                                        }
                                        // bail
                                        break;
                                    }
                                }
                            } else {
                                // no buffer
                            }
                        }
                        // clean up 
                        PdhCloseLog (hAppendLogFile,0);
                        PdhCloseLog (hBaseLogFile,0);
                        CloseHandle (hTempFile);
                        // shuffle the files around to make it look like it was appended
                        if (pdhStatus == ERROR_SUCCESS) {
                            if (CopyFile (szTempFileName, szBaseFile, FALSE)) {
                                DeleteFile (szTempFileName);
                            }
                        }
                    } else {
                        // alloc fail
                        _tprintf ((LPCTSTR)TEXT("\nUnable to allocate temporary memory buffer."));
                    }
                } else {
                    //unable to open new file for reading
                    _tprintf ((LPCTSTR)TEXT("\nUnable to open input file for reading."));
                    dwReturn = pdhStatus;
                    PdhCloseLog (hBaseLogFile,0);
                    CloseHandle (hTempFile);
                    DeleteFile (szTempFileName);
                }
            } else {
                //unable to open base file for reading
                _tprintf ((LPCTSTR)TEXT("\nUnable to open output file for reading."));
                dwReturn = pdhStatus;
                CloseHandle (hTempFile);
                DeleteFile (szTempFileName);
            }

        } else {
            // unable to create temp file
            _tprintf ((LPCTSTR)TEXT("\nUnable to create temporary file in temp dir."));
            dwReturn = GetLastError();
        }
    } else {
        dwReturn = pdhStatus;
    }
    
    return dwReturn;
}

int
__cdecl
wmain(
    int argc,
    _TCHAR *argv[]
    )
/*

	relog 
        /Input:<filename>
        /Output:<filename>
        /Settings:<settings filename>
        /Logtype:[BIN|BLG|TSV|CSV]
        /StartTime:yyyy-mm-dd-hh:mm:ss
        /EndTime;yyyy-mm-dd-hh:mm:ss
        /Filter:n
*/
{
    LONG    Status = ERROR_SUCCESS;
	
    DWORD   dwOutputLogType = PDH_LOG_TYPE_UNDEFINED;

    DWORD   dwFilterCount = 1;

    DWORD   dwMode = NORMAL_MODE;

    PDH_TIME_INFO   pdhTimeInfo;

    DWORD   dwPdhVersion = 0;

    ParseCmd( argc, argv );

    Status = PdhGetDllVersion (&dwPdhVersion);

    dwOutputLogType = GetOutputLogType( Commands[eFormat].strValue );

    pdhTimeInfo.StartTime = 0;
    pdhTimeInfo.EndTime = 0;
    if( Commands[eBegin].bDefined ){
        FILETIME   ft;
        SystemTimeToFileTime( &Commands[eBegin].stValue, &ft );
        pdhTimeInfo.StartTime = *(LONGLONG *)&ft;
    }

    if( Commands[eEnd].bDefined ){
        FILETIME   ft;
        SystemTimeToFileTime( &Commands[eEnd].stValue, &ft );
        pdhTimeInfo.EndTime = *(LONGLONG *)&ft;
    }
    pdhTimeInfo.SampleCount = 0;
    // szXXXFile cannot be NULL at this point!
    if ( Commands[eQuery].bValue ) {
        dwMode = LIST_MODE;
    } else if (Commands[eAppend].bValue ) {
        dwMode = APPEND_MODE;
    }

    if (Status == ERROR_SUCCESS) {
        switch (dwMode) {
        case HEADER_MODE:
            Status = DoHeaderListMode (
                Commands[eInput].strValue,
                Commands[eOutput].strValue);
            break;

        case LIST_MODE:
            Status = DoListMode (
                Commands[eInput].strValue,
                Commands[eOutput].strValue);
            break;

        case APPEND_MODE:
            Status = DoAppendFiles (
                Commands[eInput].strValue,
                Commands[eOutput].strValue,
                Commands[eInterval].nValue );
            break;

        case NORMAL_MODE:
        default:
            Status = DoNormalMode (
                Commands[eInput].strValue,
                Commands[eOutput].strValue,
                Commands[eCounters].strValue,
                dwOutputLogType,
                pdhTimeInfo,
                Commands[eInterval].nValue);
            break;

        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\samples\tracekmp\kmpioctl.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    kmpioctl.h

Abstract:

    Definitions of IOCTL codes and data structures exported by TRACEKMP.


Author:

    Jee Fung Pang (jeepang) 03-Dec-1997

Revision History:

--*/

#ifndef __TRACEKMP_IOCTL__
#define __TRACEKMP_IOCTL__

//
// IOCTL control codes
//
#define IOCTL_TRACEKMP_TRACE_EVENT          \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x801,   \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TRACEKMP_START                \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x802,   \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TRACEKMP_STOP                 \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x803,   \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TRACEKMP_QUERY                \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x804,   \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TRACEKMP_UPDATE               \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x805,   \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TRACEKMP_FLUSH                \
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x806,   \
        METHOD_BUFFERED, FILE_ANY_ACCESS )

#endif // __TRACEKMP_IOCTL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\samples\tracekmp\makefile.inc ===
MOF: tracekmp.bmf

tracekmp.bmf: tracekmp.mof
    mofcomp -B:tracekmp.bmf tracekmp.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\samples\tracedp\tracedp.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    tracedp.c

Abstract:

    Sample trace provider program.

// end_sdk
Author:

    Jee Fung Pang (jeepang) 03-Dec-1997

Revision History:

    Insung Park (insungp) 18-Jan-2001

      Modified tracedp so that when tracedp generates User Mof Events
    with some sample strings, integers, floats, and arrays.


// begin_sdk
--*/

#include <stdio.h> 
#include <stdlib.h>

#include <windows.h>
#include <shellapi.h>

#include <tchar.h>
#include <ntverp.h>
#include <fcntl.h>
#include <wmistr.h>

#include <guiddef.h>
#include <evntrace.h>

#define MAXEVENTS                       5000
#define MAXSTR                          1024
#define MAXTHREADS                      128

// sample string data
#define WIDE_DATA_STRING           L"Sample Wide String"
#define COUNTED_DATA_STRING        L"Sample Counted String"

TRACEHANDLE LoggerHandle;
#define ResourceName _T("MofResource")
TCHAR ImagePath[MAXSTR];

GUID TransactionGuid = 
    {0xce5b1020, 0x8ea9, 0x11d0, 0xa4, 0xec, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10};
GUID   ControlGuid[2]  =
{
    {0xd58c126f, 0xb309, 0x11d1, 0x96, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa5, 0xbc},
    {0x7c6a708a, 0xba1e, 0x11d2, 0x8b, 0xbf, 0x00, 0x00, 0xf8, 0x06, 0xef, 0xe0}
};

TRACE_GUID_REGISTRATION TraceGuidReg[] =
{
    { (LPGUID)&TransactionGuid,
      NULL
    }
};

typedef enum {
    TYPE_USER_EVENT,
    TYPE_INSTANCE_EVENT,
    TYPE_MOF_EVENT,
    TYPEPTR_GUID
} TypeEventType;

typedef struct _USER_EVENT {
    EVENT_TRACE_HEADER    Header;
    ULONG                 EventInfo;
} USER_EVENT, *PUSER_EVENT;

typedef struct _USER_INSTANCE_EVENT {
    EVENT_INSTANCE_HEADER    Header;
    ULONG                    mofData;
} USER_INSTANCE_EVENT, *PUSER_INSTANCE_EVENT;

// customized event to use sample data that follow
typedef struct _USER_MOF_EVENT {
    EVENT_TRACE_HEADER    Header;
    MOF_FIELD             mofData;
} USER_MOF_EVENT, *PUSER_MOF_EVENT;

// sample data structure
typedef struct _INTEGER_SAMPLE_EVENT {
    CHAR                  sc;
    UCHAR                 uc;
    SHORT                 sh;
    ULONG                 ul;
} INTEGER_SAMPLE_EVENT, *PINTEGER_SAMPLE_EVENT;

typedef struct _FLOAT_SAMPLE_EVENT {
    float                 fl;
    double                db;
} FLOAT_SAMPLE_EVENT, *PFLOAT_SAMPLE_EVENT;

typedef struct _ARRAY_SAMPLE_EVENT {
    CHAR                  ca[9];
} ARRAY_SAMPLE_EVENT, *PARRAY_SAMPLE_EVENT;

TypeEventType EventType = TYPE_USER_EVENT;
TRACEHANDLE RegistrationHandle[2];
BOOLEAN TraceOnFlag;
ULONG EnableLevel = 0;
ULONG EnableFlags = 0;
BOOLEAN bPersistData = FALSE;
ULONG nSleepTime = 0;
ULONG EventCount = 0;

BOOLEAN  bInstanceTrace=0, bUseGuidPtr=0, bUseMofPtr=0;
BOOLEAN  bIncorrect  = FALSE;
BOOLEAN  bUseNullPtr = FALSE;
BOOLEAN  bFirstTime = TRUE;

ULONG InitializeTrace(
    void
    );

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

LPTSTR
DecodeStatus(
    IN ULONG Status
    );


void
LogProc();

LPTSTR
GuidToString(
        LPTSTR s,
        LPGUID piid
        );

TCHAR ErrorMsg[MAXSTR];
ULONG    MaxEvents = MAXEVENTS;

ULONG  gnMultiReg=1;
BOOLEAN RegistrationSuccess;

void StringToGuid(
    TCHAR *str, 
    LPGUID guid
)
/*++

Routine Description:

    Converts a String into a GUID.

Arguments:

    str - String representing a GUID.
    guid - Pointer to a GUID for ourput

Return Value:

    None.

--*/
{
    TCHAR temp[10];
    int i, n;

    temp[8]=_T('\0');
    _tcsncpy(temp, str, 8);
    _stscanf(temp, _T("%x"), &(guid->Data1));

    temp[4]=_T('\0');
    _tcsncpy(temp, &str[9], 4);
    _stscanf(temp, _T("%x"), &(guid->Data2));

    _tcsncpy(temp, &str[14], 4);
    _stscanf(temp, _T("%x"), &(guid->Data3));

    temp[2]='\0';
    for(i=0;i<8;i++)
    {
        temp[0]=str[19+((i<2)?2*i:2*i+1)]; // to accomodate the minus sign after
        temp[1]=str[20+((i<2)?2*i:2*i+1)]; // the first two chars
        _stscanf(temp, _T("%x"), &n);      // if used more than byte alloc
        guid->Data4[i]=(unsigned char)n;   // causes overrun of memory
    }
}

__cdecl main(argc, argv)
    int argc;
    char **argv;
/*++

Routine Description:

    main() routine.

Arguments:

    Usage: TraceDp [options] [number of events]
                -UseEventTraceHeader        this is default.
                -UseEventInstanceHeader
                -UseMofPtrFlag
                -Thread [n]                 Sets the number of event-generating threads.
                -GuidPtr                    Use GUID pointer instead of GUID itself.
                -MofPtr                     Use MOF pointer for additional data.
                -GuidPtrMofPtr              User GUID pointer and MOF pointer.
                -InCorrectMofPtr            Use incorrect MOF pointer (Creates an error case).
                -NullMofPtr                 Use NULL MOF pointer (Creates an error case).
                -MultiReg                   Register multiple event GUIDS.
                -Sleep [n]                  Sets the sleep time before unregistering.
                [number of events] default is 5000

Return Value:

        Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS (== 0).

--*/
{
    ULONG status;
    ULONG   InstanceId;
    LPGUID  Guid = NULL;
    PWNODE_HEADER Wnode;
    TCHAR   strMofData[MAXSTR];
    DWORD ThreadId;
    HANDLE hThreadVector[MAXTHREADS];
    ULONG i;
    ULONG nThreads = 1;
    char s[MAXSTR];
    LPTSTR *targv;

    MaxEvents = MAXEVENTS;
    TraceOnFlag = FALSE;

#ifdef UNICODE
    if ((targv = CommandLineToArgvW(
                      GetCommandLineW(),    // pointer to a command-line string
                      &argc                 // receives the argument count
                      )) == NULL)
    {
        return(GetLastError());
    };
#else
    targv = argv;
#endif

    // process command line arguments to override defaults
    //
    while (--argc > 0)
    {
        targv ++;
        if (**targv == '-' || **targv == '/')
        {
            if(targv[0][0] == '/' ) targv[0][0] = '-';
            if (!_tcsicmp(targv[0],_T("-UseEventTraceHeader")))
            {
                EventType = TYPE_USER_EVENT;
            }
            else if (!_tcsicmp(targv[0],_T("-UseEventInstanceHeader")))
            {
                EventType = TYPE_INSTANCE_EVENT;
            }
            else if (!_tcsicmp(targv[0],_T("-UseMofPtrFlag")))
            {
                EventType = TYPE_MOF_EVENT;
            }
// end_sdk
            else if (!_tcsicmp(targv[0],_T("-Persist")))
            {
                bPersistData = TRUE;
            }
// begin_sdk
            else if (!_tcsicmp(targv[0],_T("-Thread")))
            {
                if (argc > 1) {
                    targv++; --argc;
                    nThreads = _ttoi(targv[0]);
                    if (nThreads > MAXTHREADS) 
                        nThreads = MAXTHREADS;
                }
            }
             else if (!_tcsicmp(targv[0],_T("-GuidPtr")))
            {
                bUseGuidPtr = TRUE;
            }
            else if (!_tcsicmp(targv[0],_T("-MofPtr")))
            {
                bUseMofPtr = TRUE;
            }
            else if (!_tcsicmp(targv[0],_T("-GuidPtrMofPtr")))
            {
                bUseGuidPtr = TRUE;
                bUseMofPtr  = TRUE;
            }
            else if (!_tcsicmp(targv[0],_T("-InCorrectMofPtr")))
            {
                bUseMofPtr  = TRUE;
                bIncorrect  = TRUE;
            }
            else if (!_tcsicmp(targv[0],_T("-NullMofPtr")))
            {
                bUseMofPtr  = TRUE;
                bUseNullPtr = TRUE;
                bIncorrect  = TRUE;;
            }
            else if (!_tcsicmp(targv[0],_T("-MultiReg")))
            {
                gnMultiReg = 2;
            }
            else if (!_tcsicmp(targv[0], _T("-guid"))) {
                if (argc > 1) {
                    if (targv[1][0] == _T('#')) {
                        StringToGuid(&targv[1][1], &ControlGuid[0]);
                        ++targv; --argc;
                    }
                }
            }
            else if (!_tcsicmp(targv[0],_T("-Sleep")))
            {
                if (argc > 1) {
                    targv++; --argc;
                    nSleepTime = _ttoi(targv[0]);
                }
            }
            else
            {
                printf("Usage: TraceDp [options] [number of events]\n");
                printf("\t-UseEventTraceHeader        this is default.\n");
                printf("\t-UseEventInstanceHeader\n");
                printf("\t-UseMofPtrFlag\n");
                printf("\t-Thread [n]\n");
                printf("\t-GuidPtr\n");
                printf("\t-MofPtr\n");
                printf("\t-GuidPtrMofPtr\n");
                printf("\t-InCorrectMofPtr\n");
                printf("\t-NullMofPtr\n");
                printf("\t-MultiReg\n");
                printf("\t-Sleep [n]\n");
                printf("\t[number of events] default is 5000\n");

                return 0;
            }
        }
        else if (** targv >= '0' && ** targv <= '9')
        {
            MaxEvents = _ttoi(targv[0]);
        }
    }

    status = InitializeTrace();
    if (status != ERROR_SUCCESS) {
       return 0;
    }

    _tprintf(_T("Testing Logger with %d events (%d,%d)\n"),
            MaxEvents, EventType, bPersistData);

    while (! TraceOnFlag)
        _sleep(1000);

    for (i=0; i < nThreads; i++) {
        hThreadVector[i] = CreateThread(NULL,
                    0,
                    (LPTHREAD_START_ROUTINE) LogProc,
                    NULL,
                    0,
                    (LPDWORD)&ThreadId);
    }

    WaitForMultipleObjects(nThreads, hThreadVector, TRUE, INFINITE);

    if (nSleepTime > 0) {
        _sleep(nSleepTime * 1000);
    }

    for (i=0; i<gnMultiReg; i++)  {
        UnregisterTraceGuids(RegistrationHandle[i]);
    }

    return status;
}

LPTSTR
DecodeStatus(
    IN ULONG Status
)
/*++

Routine Description:

    Decodes error status.

Arguments:

    Status - Return status of function calls to be decoded.

Return Value:

    Pointer to a decoded error message.

--*/
{
    memset( ErrorMsg, 0, MAXSTR );
    FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        Status,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) ErrorMsg,
        MAXSTR,
        NULL );
    return ErrorMsg;
}

ULONG InitializeTrace(
    void
)
/*++

Routine Description:

    Register traces.

Arguments:

Return Value:

    Error Status. ERROR_SUCCESS if successful.

--*/
{
    ULONG Status;
    ULONG i, j;

    Status = GetModuleFileName(NULL, &ImagePath[0], MAXSTR*sizeof(TCHAR));
    if (Status == 0) {
        return (ERROR_FILE_NOT_FOUND);
    }

    for (i=0; i<gnMultiReg; i++) {
        TCHAR str[MAXSTR];

        Status = RegisterTraceGuids(
                    (WMIDPREQUEST)ControlCallback,   //use same callback function
                    (PVOID)(INT_PTR)(0x12345678+i),  // RequestContext
                    (LPCGUID)&ControlGuid[i],
                    1,
                    &TraceGuidReg[i],
                    (LPCTSTR)&ImagePath[0],
                    (LPCTSTR)ResourceName,
                    &RegistrationHandle[i]
                 );

        if (Status != ERROR_SUCCESS) {
            _tprintf(_T("Trace registration failed\n"));
            RegistrationSuccess = FALSE;
            if( i > 0) {
                for (j=0; j<i; j++) {
                    UnregisterTraceGuids(RegistrationHandle[i]);
                }
            }
            _tprintf(_T("InitializeTrace failed. i=%d, status=%d, %s\n"), i, Status, DecodeStatus(Status));
            return(Status);
        }
        else {
            _tprintf(_T("Trace registered successfully\n"));
            RegistrationSuccess = TRUE;
        }
    }

    return(Status);
}

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
)
/*++

Routine Description:

    Callback function when enabled.

Arguments:

    RequestCode - Flag for either enable or disable.
    Context - User-defined context.
    InOutBufferSize - not used.
    Buffer - WNODE_HEADER for the logger session.

Return Value:

    Error Status. ERROR_SUCCESS if successful.

--*/
{
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            RetSize = 0;
            LoggerHandle = GetTraceLoggerHandle( Buffer );
            EnableLevel = GetTraceEnableLevel(LoggerHandle);
            EnableFlags = GetTraceEnableFlags(LoggerHandle);
            _tprintf(_T("Logging enabled to 0x%016I64x(%d,%d,%d)\n"),
                    LoggerHandle, RequestCode, EnableLevel, EnableFlags);
            TraceOnFlag = TRUE;
            break;
        }
        case WMI_DISABLE_EVENTS:
        {
            TraceOnFlag = FALSE;
            RetSize = 0;
            LoggerHandle = 0;
            _tprintf(_T("\nLogging Disabled\n"));
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = RetSize;
    return(Status);
}

void
LogProc()
/*++

Routine Description:

    Generates events. It is spawned as separate threads.
    Based on the options given by users, it generates different events.

Arguments:

Return Value:

    None.

--*/
{
    USER_EVENT          UserEvent;
    USER_INSTANCE_EVENT UserInstanceEvent;
    USER_MOF_EVENT      UserMofEvent;
    EVENT_INSTANCE_INFO InstInfo;
    PMOF_FIELD          mofField;
    ULONG i;
    PWNODE_HEADER Wnode;
    ULONG status;
    ULONG  InstanceId;
    LPGUID Guid = NULL;
    ULONG nTemp;
    USHORT nSize, nStrEventSize;
    WCHAR wstrTemp[MAXSTR];

    INTEGER_SAMPLE_EVENT ise;
    FLOAT_SAMPLE_EVENT fse;
    ARRAY_SAMPLE_EVENT ase;
    CHAR *sse, *ptr;

    // some arbitrary data for MOF structs
    ise.sc = 'x';
    ise.uc = 'y';
    ise.sh = (SHORT)rand();
    ise.ul = (ULONG)rand();

    nTemp = 0;
    while (nTemp == 0) {
        nTemp = rand();
    }

    fse.fl = ((float)rand() / (float)nTemp);
    fse.db = ((double)rand() / (double)nTemp);

    ase.ca[0] = 'M';
    ase.ca[1] = 'i';
    ase.ca[2] = 'c';
    ase.ca[3] = 'r';
    ase.ca[4] = 'o';
    ase.ca[5] = 's';
    ase.ca[6] = 'o';
    ase.ca[7] = 'f';
    ase.ca[8] = 't';

    nStrEventSize = ((wcslen(WIDE_DATA_STRING) + 1) * sizeof(WCHAR)) + sizeof(SHORT) + (wcslen(COUNTED_DATA_STRING) * sizeof(WCHAR));
    sse = (PCHAR) malloc(nStrEventSize);

    if (NULL != sse) {
        ptr = sse;
        wcscpy(wstrTemp, WIDE_DATA_STRING);
        wstrTemp[wcslen(WIDE_DATA_STRING)] = L'\0';
        memcpy(ptr, wstrTemp, (wcslen(WIDE_DATA_STRING) + 1) * sizeof(WCHAR));
        ptr += (wcslen(WIDE_DATA_STRING) + 1) * sizeof(WCHAR);
        nSize = (USHORT)(wcslen(COUNTED_DATA_STRING) * sizeof(WCHAR));
        memcpy(ptr, &nSize, sizeof(USHORT));
        ptr += sizeof(USHORT);
        wcscpy(wstrTemp, COUNTED_DATA_STRING);
        memcpy(ptr, wstrTemp, wcslen(COUNTED_DATA_STRING) * sizeof(WCHAR));
    }

    RtlZeroMemory(&UserEvent, sizeof(UserEvent));
    Wnode = (PWNODE_HEADER) &UserEvent;
    UserEvent.Header.Size  = sizeof(USER_EVENT);
    UserEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;
    UserEvent.Header.Guid  =  TransactionGuid;
    if (bPersistData)
        UserEvent.Header.Flags |= WNODE_FLAG_PERSIST_EVENT;

    RtlZeroMemory(&UserInstanceEvent, sizeof(UserInstanceEvent));
    UserInstanceEvent.Header.Size  = sizeof(UserInstanceEvent);
    UserInstanceEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;
    if (bPersistData)
        UserInstanceEvent.Header.Flags |= WNODE_FLAG_PERSIST_EVENT;

    RtlZeroMemory(&UserMofEvent, sizeof(UserMofEvent));
    Wnode = (PWNODE_HEADER) &UserMofEvent;
    UserMofEvent.Header.Size  = sizeof(UserMofEvent);
    UserMofEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;
    UserMofEvent.Header.Guid  = TransactionGuid;
// end_sdk
    if (bPersistData)
        UserMofEvent.Header.Flags |= WNODE_FLAG_PERSIST_EVENT;
// begin_sdk
    if (bUseGuidPtr) {
        UserEvent.Header.Flags  |= WNODE_FLAG_USE_GUID_PTR;
        UserEvent.Header.GuidPtr = (ULONGLONG)&TransactionGuid;
        UserMofEvent.Header.Flags  |= WNODE_FLAG_USE_GUID_PTR;
        UserMofEvent.Header.GuidPtr = (ULONGLONG)&TransactionGuid;
    }

    i = 0;
    while (TraceOnFlag) {
        if ((i % 4) == 0) {
            UserEvent.Header.Class.Type         = EVENT_TRACE_TYPE_START;
            UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_START;
            UserMofEvent.Header.Class.Type      = 1;
        }
        else if ((i % 4) == 1) {
            UserEvent.Header.Class.Type         = EVENT_TRACE_TYPE_END;
            UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_END;
            UserMofEvent.Header.Class.Type      = 2;
        }
        else if ((i % 4) == 2) {
            UserEvent.Header.Class.Type         = EVENT_TRACE_TYPE_START;
            UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_START;
            UserMofEvent.Header.Class.Type      = 3;
        }
        else {
            UserEvent.Header.Class.Type         = EVENT_TRACE_TYPE_END;
            UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_END;
            UserMofEvent.Header.Class.Type      = 4;
        }

        switch (EventType)
        {
        case TYPE_INSTANCE_EVENT:
            if (UserInstanceEvent.Header.Class.Type == EVENT_TRACE_TYPE_START) {
                status = CreateTraceInstanceId(
                                (PVOID) TraceGuidReg[0].RegHandle,
                                & InstInfo);

                if (status != ERROR_SUCCESS) {
                    fprintf(stderr, 
                             "CreatTraceInstanceId() status=%d, %s\n",
                              status, DecodeStatus(status)
                             );
                    return; 
                }
            }
            status = TraceEventInstance(
                        LoggerHandle, 
                        (PEVENT_INSTANCE_HEADER) & UserInstanceEvent,
                        & InstInfo,
                        NULL);
            break;

        case TYPE_USER_EVENT:
            UserEvent.EventInfo = InterlockedIncrement(&EventCount);
            status = TraceEvent(
                            LoggerHandle,
                            (PEVENT_TRACE_HEADER) & UserEvent);
            break;

        case TYPE_MOF_EVENT:
            UserMofEvent.Header.Flags |= WNODE_FLAG_USE_MOF_PTR;
            mofField          = (PMOF_FIELD) & UserMofEvent.mofData;
            if (UserMofEvent.Header.Class.Type == 2) {
                mofField->DataPtr = (ULONGLONG) (&ise);
                mofField->Length  = sizeof(INTEGER_SAMPLE_EVENT);
            }
            else if (UserMofEvent.Header.Class.Type == 3) {
                mofField->DataPtr = (ULONGLONG) (&fse);
                mofField->Length  = sizeof(FLOAT_SAMPLE_EVENT);
            }
            else if (UserMofEvent.Header.Class.Type == 4) {
                mofField->DataPtr = (ULONGLONG) (&ase);
                mofField->Length  = sizeof(ARRAY_SAMPLE_EVENT);
            }
            else {
                mofField->DataPtr = (ULONGLONG) (sse);
                mofField->Length  = nStrEventSize;
            }
            if (bUseNullPtr)
                mofField->DataPtr = (ULONGLONG) (NULL);
            if (bIncorrect)
                mofField->Length  += 1000;

            status = TraceEvent(
                            LoggerHandle,
                            (PEVENT_TRACE_HEADER) & UserMofEvent);
            if (status != ERROR_SUCCESS) {
                fprintf(stderr, "Error(%d) while writing event.\n", status);
            }
            break;

        default:
            status = ERROR_SUCCESS;
            break;
        }

        // logger buffers out of memory should not prevent provider from
        // generating events. This will only cause events lost.
        //
        if (status == ERROR_NOT_ENOUGH_MEMORY) {
            status = ERROR_SUCCESS;
        }

        if (status != ERROR_SUCCESS) {
            _ftprintf(stderr, _T("\nError %s while writing event\n"),
                      DecodeStatus(status));
            _ftprintf( stderr, _T("Use GUID to disable Logger\n"));
            _ftprintf( stderr, _T("Logging Terminated\n"));
            return;
        }

        i++;
        if (i >= MaxEvents)
            break;

        if (!(i % 100))
            _tprintf(_T("."));
        _sleep(1);
    }
}

LPTSTR
GuidToString(
        LPTSTR s,
        LPGUID piid
        )
/*++

Routine Description:

    Converts a GUID into a string.

Arguments:

    s - String that will have the converted GUID.
    piid - GUID

Return Value:

    None.

--*/
{
    _stprintf(s, _T("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"),
               piid->Data1,
               piid->Data2,
               piid->Data3,
               piid->Data4[0],
               piid->Data4[1],
               piid->Data4[2],
               piid->Data4[3],
               piid->Data4[4],
               piid->Data4[5],
               piid->Data4[6],
               piid->Data4[7]);
    return(s);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\samples\tracekmp\umioctl\umioctl.c ===
//++
// File Name:
//		test.c
//
// Contents:
//		Generic test program
//--

//
// Header files
//
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <nt.h>
#include <ntverp.h>
#include <fcntl.h>
#include <io.h>
#include <sys/stat.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wtypes.h>
#include <windows.h>
#include <winioctl.h>
#include <wmistr.h>
#include <evntrace.h>
#include <tchar.h>

#include "..\kmpioctl.h"

#define MAXSTR              1024

// begin_wmikm
typedef struct _WMI_LOGGER_INFORMATION {
    WNODE_HEADER Wnode;       // Had to do this since wmium.h comes later
//
// data provider by caller
    ULONG BufferSize;                   // buffer size for logging (in kbytes)
    ULONG MinimumBuffers;               // minimum to preallocate
    ULONG MaximumBuffers;               // maximum buffers allowed
    ULONG MaximumFileSize;              // maximum logfile size (in MBytes)
    ULONG LogFileMode;                  // sequential, circular
    ULONG FlushTimer;                   // buffer flush timer, in seconds
    ULONG EnableFlags;                  // trace enable flags
    LONG  AgeLimit;                     // aging decay time, in minutes
    union {
        HANDLE  LogFileHandle;          // handle to logfile
        ULONG64 LogFileHandle64;
    };

// data returned to caller
// end_wmikm
    union {
// begin_wmikm
        ULONG NumberOfBuffers;          // no of buffers in use
// end_wmikm
        ULONG InstanceCount;            // Number of Provider Instances
    };
    union {
// begin_wmikm
        ULONG FreeBuffers;              // no of buffers free
// end_wmikm
        ULONG InstanceId;               // Current Provider's Id for UmLogger
    };
    union {
// begin_wmikm
        ULONG EventsLost;               // event records lost
// end_wmikm
        ULONG NumberOfProcessors;       // Passed on to UmLogger
    };
// begin_wmikm
    ULONG BuffersWritten;               // no of buffers written to file
    ULONG LogBuffersLost;               // no of logfile write failures
    ULONG RealTimeBuffersLost;          // no of rt delivery failures
    union {
        HANDLE  LoggerThreadId;         // thread id of Logger
        ULONG64 LoggerThreadId64;       // thread is of Logger
    };
    union {
        UNICODE_STRING LogFileName;     // used only in WIN64
        UNICODE_STRING64 LogFileName64; // Logfile name: only in WIN32
    };

// mandatory data provided by caller
    union {
        UNICODE_STRING LoggerName;      // Logger instance name in WIN64
        UNICODE_STRING64 LoggerName64;  // Logger Instance name in WIN32
    };

// private
    union {
        PVOID   Checksum;
        ULONG64 Checksum64;
    };
    union {
        PVOID   LoggerExtension;
        ULONG64 LoggerExtension64;
    };
} WMI_LOGGER_INFORMATION, *PWMI_LOGGER_INFORMATION;

//
// Forward declarations of local functions...
//

static VOID
SendIoctl(
    ULONG ioctl,
    PVOID Buffer,
    ULONG Size
    );

static VOID
ErrorMessage( 
	LPTSTR lpOrigin, 
	DWORD dwMessageId
	);

static VOID
InitString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString
    );

void
PrintLoggerStatus(
    IN PWMI_LOGGER_INFORMATION LoggerInfo,
    IN ULONG Status
    );

//
// Main entry point...
//
VOID __cdecl
main(
    int argc,
    char **argv
	)
{
    ULONG ioctl = IOCTL_TRACEKMP_TRACE_EVENT;
    WMI_LOGGER_INFORMATION LoggerInfo;
    WCHAR LoggerName[MAXSTR];
    WCHAR LogFileName[MAXSTR];

    wcscpy(LoggerName, L"TraceKmp");
    wcscpy(LogFileName, L"C:\\tracekmp.etl");

    RtlZeroMemory(&LoggerInfo, sizeof(LoggerInfo));
    LoggerInfo.Wnode.BufferSize = sizeof(LoggerInfo);
    LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    InitString(&LoggerInfo.LoggerName, LoggerName);
    InitString(&LoggerInfo.LogFileName, LogFileName);

    while (--argc > 0) {
        ++argv;
        if (**argv == '-' || **argv == '/') {
            if (!strcmp(&argv[0][1], "start")) {
                ioctl = IOCTL_TRACEKMP_START;
            }
            else if (!strcmp(&argv[0][1], "stop")) {
                ioctl = IOCTL_TRACEKMP_STOP;
            }
            else if (!strcmp(&argv[0][1], "query")) {
                ioctl = IOCTL_TRACEKMP_QUERY;
            }
            else if (!strcmp(&argv[0][1], "update")) {
                ioctl = IOCTL_TRACEKMP_UPDATE;
            }
            else if (!strcmp(&argv[0][1], "flush")) {
                ioctl = IOCTL_TRACEKMP_FLUSH;
            }
        }
    }
    SendIoctl( ioctl, (PVOID) &LoggerInfo, sizeof(LoggerInfo) );
    ExitProcess( ERROR_SUCCESS );
}

static VOID
SendIoctl(
    ULONG ioctl,
    PVOID Buffer,
    ULONG Size
    )
{
	HANDLE hDevice;
	DWORD dwErrorCode = ERROR_SUCCESS;
	DWORD dwBytesReturned;

	hDevice = CreateFile(
				"\\\\.\\TRACEKMP",
				GENERIC_WRITE,
				0,
				NULL,
				OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL,
				NULL );
	if( hDevice == INVALID_HANDLE_VALUE )
	{
		dwErrorCode = GetLastError();
		ErrorMessage( "CreateFile", dwErrorCode );
		ExitProcess( dwErrorCode );
	}

    printf("Sending ioctl %X\n", ioctl);    
	if( !DeviceIoControl(
			hDevice,
			ioctl,
			Buffer,
			Size,
			Buffer,
			Size,
			&dwBytesReturned,
			NULL ))
	{
		dwErrorCode = GetLastError();
		ErrorMessage( "DeviceIoControl", dwErrorCode );
		ExitProcess( dwErrorCode );
	}

	PrintLoggerStatus(Buffer, dwErrorCode);

	CloseHandle( hDevice );
}


//
// This helper routine converts a system-service error
// code into a text message and prints it on StdOutput
//
static VOID
ErrorMessage( 
	LPTSTR lpOrigin,	// Indicates error location
	DWORD dwMessageId	// ERROR_XXX code value
	)
{
	LPTSTR msgBuffer;		// string returned from system
	DWORD cBytes;			// length of returned string

	cBytes = FormatMessage(
				FORMAT_MESSAGE_FROM_SYSTEM |
				FORMAT_MESSAGE_ALLOCATE_BUFFER,
				NULL,
				dwMessageId,
				MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
				(TCHAR *)&msgBuffer,
				500,
				NULL );
	if( msgBuffer )
	{
		msgBuffer[ cBytes ] = TEXT('\0');
		printf( "Error: %s -- %s\n", lpOrigin, msgBuffer );
		LocalFree( msgBuffer );
	}
	else
	{
		printf( "FormatMessage error: %d\n", GetLastError());
	}
}

static VOID
InitString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString
    )
{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if ( SourceString ) {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
}

void
PrintLoggerStatus(
    IN PWMI_LOGGER_INFORMATION LoggerInfo,
    IN ULONG Status
    )
{
    LPWSTR LoggerName, LogFileName;

    LoggerName = LoggerInfo->LoggerName.Buffer;
    LogFileName = LoggerInfo->LogFileName.Buffer;

    _tprintf(_T("Operation Status:       %uL\n"), Status);
//    _tprintf(_T("%s\n"), ErrorMessage("PrintLoggerStatus", Status));

    _tprintf(_T("Logger Name:            %ws\n"),
        (LoggerName == NULL) ?
            L" " : LoggerName);
    _tprintf(_T("Logger Id:              %I64x\n"), LoggerInfo->Wnode.HistoricalContext);
    _tprintf(_T("Logger Thread Id:       %d\n"), LoggerInfo->LoggerThreadId);
    if (Status != 0)
        return;

    _tprintf(_T("Buffer Size:            %d Kb\n"), LoggerInfo->BufferSize);
    _tprintf(_T("Maximum Buffers:        %d\n"), LoggerInfo->MaximumBuffers);
    _tprintf(_T("Minimum Buffers:        %d\n"), LoggerInfo->MinimumBuffers);
    _tprintf(_T("Number of Buffers:      %d\n"), LoggerInfo->NumberOfBuffers);
    _tprintf(_T("Free Buffers:           %d\n"), LoggerInfo->FreeBuffers);
    _tprintf(_T("Buffers Written:        %d\n"), LoggerInfo->BuffersWritten);
    _tprintf(_T("Events Lost:            %d\n"), LoggerInfo->EventsLost);
    _tprintf(_T("Log Buffers Lost:       %d\n"), LoggerInfo->LogBuffersLost);
    _tprintf(_T("Real Time Buffers Lost: %d\n"), LoggerInfo->RealTimeBuffersLost);

    if (LogFileName == NULL) {
        _tprintf(_T("Buffering Mode:         "));
    }
    else {
        _tprintf(_T("Log File Mode:          "));
    }
    if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
        _tprintf(_T("Circular\n"));
    }
    else if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
        _tprintf(_T("Sequential\n"));
    }
    else {
        _tprintf(_T("Sequential\n"));
    }
    if (LoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
        _tprintf(_T("Real Time mode enabled"));
        _tprintf(_T("\n"));
    }

    if (LoggerInfo->MaximumFileSize > 0)
        _tprintf(_T("Maximum File Size:      %d Mb\n"), LoggerInfo->MaximumFileSize);

    if (LoggerInfo->FlushTimer > 0)
        _tprintf(_T("Buffer Flush Timer:     %d secs\n"), LoggerInfo->FlushTimer);
/*
    if (LoggerInfo->EnableFlags != 0) {
        _tprintf(_T("Enabled tracing:        "));

        if ((LoggerName != NULL) && (!_tcscmp(LoggerName,NT_LOGGER))) {

            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_PROCESS)
                _tprintf(_T("Process "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_THREAD)
                _tprintf(_T("Thread "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
                _tprintf(_T("Disk "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
                _tprintf(_T("File "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
                _tprintf(_T("PageFaults "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
                _tprintf(_T("HardFaults "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
                _tprintf(_T("ImageLoad "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
                _tprintf(_T("TcpIp "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_REGISTRY)
                _tprintf(_T("Registry "));
        }else{
            _tprintf(_T("0x%08x"), LoggerInfo->EnableFlags );
        }
        _tprintf(_T("\n"));
    }
*/
    if (LogFileName != NULL) {
        _tprintf(_T("Log Filename:           %ws\n"), LogFileName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\samples\tracekmp\tracekmp.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    tracekmp.c

Abstract:

    Sample kernel mode trace provider/driver.

Author:

    Jee Fung Pang (jeepang) 03-Dec-1997

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <ntddk.h>
#include <wmistr.h>
#include <evntrace.h>
#include "kmpioctl.h"
#include <wmikm.h>

#define TRACEKMP_NT_DEVICE_NAME     L"\\Device\\TraceKmp"
#define TRACEKMP_WIN32_DEVICE_NAME  L"\\DosDevices\\TRACEKMP"
#define TRACEKMP_DRIVER_NAME            L"TRACEKMP"

typedef struct _DEVICE_EXTENSION {
    PDEVICE_OBJECT DeviceObject;

    ULONG IrpSequenceNumber;
    UCHAR IrpRetryCount;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Proc Ctrs Device Extension Object
//
//extern PDEVICE_OBJECT pTracekmpDeviceObject;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );
VOID
TraceEventLogger(
    IN PTRACEHANDLE pLoggerHandle
    );

NTSTATUS
TracekmpDispatchOpen(
	IN PDEVICE_OBJECT pDO,
	IN PIRP Irp
	);

NTSTATUS
TracekmpDispatchClose(
    IN PDEVICE_OBJECT pDO,
    IN PIRP Irp
    );

NTSTATUS
TracekmpDispatchDeviceControl(
    IN PDEVICE_OBJECT pDO,
    IN PIRP Irp
    );

NTSTATUS
PcWmiRegisterGuids(
    IN  PWMIREGINFO             WmiRegInfo,
    IN  ULONG                   wmiRegInfoSize,
    IN  PULONG                  pReturnSize
    );

#ifdef USE_CALLBACK
NTSTATUS
TracekmpControlCallback(
    IN ULONG ActionCode,
    IN PVOID DataPath,
    IN ULONG BufferSize,
    IN OUT PVOID Buffer,
    IN PVOID Context,
    OUT PULONG Size
    );
#else
NTSTATUS
PcWmiDispatch(
    IN PDEVICE_OBJECT pDO,
    IN PIRP Irp
    );
#endif

VOID
TracekmpDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( page, TracekmpDispatchOpen )
#pragma alloc_text( page, TracekmpDispatchClose )
#pragma alloc_text( page, TracekmpDispatchDeviceControl )
#ifdef USE_CALLBACK
#pragma alloc_text( page, TracekmpControlCallback )
#else
#pragma alloc_text( page, PcWmiDispatch )
#endif
#pragma alloc_text( init, DriverEntry )
#pragma alloc_text( page, TracekmpDriverUnload )
#endif // ALLOC_PRAGMA

#define PROC_REG_PATH   L"System\\CurrentControlSet\\Services\\TRACEKMP"

#define MAXEVENTS 100

GUID   TracekmpGuid  =
{0xd58c126f, 0xb309, 0x11d1, 0x96, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa5, 0xbc};

ULONG TracekmpEnable = 0;
TRACEHANDLE LoggerHandle;


PDEVICE_OBJECT pTracekmpDeviceObject;

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT DriverObject,
	IN PUNICODE_STRING RegistryPath
	)
/*++

Routine Description:

    This is the callback function when we call IoCreateDriver to create a
    WMI Driver Object.  In this function, we need to remember the
    DriverObject, create a device object and then create a Win32 visible
    symbolic link name so that the WMI user mode component can access us.

Arguments:
    DriverObject - pointer to the driver object
    RegistryPath - pointer to a unicode string representing the path
               to driver-specific key in the registry

Return Value:

   STATUS_SUCCESS if successful
   STATUS_UNSUCCESSFUL  otherwise

--*/
{
	NTSTATUS status = STATUS_SUCCESS;
    ULONG i;
	UNICODE_STRING deviceName;
    UNICODE_STRING linkName;

	//
	// Create Dispatch Entry Points.  
	//
 	DriverObject->DriverUnload = TracekmpDriverUnload;
	DriverObject->MajorFunction[ IRP_MJ_CREATE ] = TracekmpDispatchOpen;
	DriverObject->MajorFunction[ IRP_MJ_CLOSE ] = TracekmpDispatchClose;
	DriverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL ] = 
                                          TracekmpDispatchDeviceControl;	

    // 
    // Wire a function to start fielding WMI IRPS 
    //

#ifndef USE_CALLBACK
	DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] = PcWmiDispatch;
#endif

	RtlInitUnicodeString( &deviceName, TRACEKMP_NT_DEVICE_NAME );

    //
    // Create the Device object
    //
	status = IoCreateDevice(
				DriverObject,
				sizeof( DEVICE_EXTENSION ),
				&deviceName,
				FILE_DEVICE_UNKNOWN,
				0,
				FALSE,
				&pTracekmpDeviceObject);

	if( !NT_SUCCESS( status )) {
		return status;
    }

    RtlInitUnicodeString( &linkName, TRACEKMP_WIN32_DEVICE_NAME );
    status = IoCreateSymbolicLink( &linkName, &deviceName );

    if( !NT_SUCCESS( status )) {
        IoDeleteDevice( pTracekmpDeviceObject );
        return status;
    }


 	//
	// Choose a buffering mechanism
	//
	pTracekmpDeviceObject->Flags |= DO_BUFFERED_IO;

    //
    // Register with WMI here
    //
#ifdef USE_CALLBACK
    status = IoWMIRegistrationControl(
                (PDEVICE_OBJECT) TracekmpControlCallback,
                WMIREG_ACTION_REGISTER | WMIREG_FLAG_CALLBACK);
#else
    status = IoWMIRegistrationControl(pTracekmpDeviceObject,
                                      WMIREG_ACTION_REGISTER);
#endif
    if (!NT_SUCCESS(status))
    {
        DbgPrint("TRACEKMP: Failed to register for WMI support\n");
    }

	return STATUS_SUCCESS;
}

NTSTATUS
TracekmpDispatchOpen(
	IN PDEVICE_OBJECT pDO,
	IN PIRP Irp
	)
{
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest( Irp, IO_NO_INCREMENT );
	return STATUS_SUCCESS;
}

//++
// Function:
//		TracekmpDispatchClose
//
// Description:
//		This function dispatches CloseHandle
//		requests from Win32
//
// Arguments:
//		Pointer to Device object
//		Pointer to IRP for this request
//
// Return Value:
//		This function returns STATUS_XXX
//--
NTSTATUS
TracekmpDispatchClose(
	IN PDEVICE_OBJECT pDO,
	IN PIRP Irp
	)
{
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest( Irp, IO_NO_INCREMENT );
	return STATUS_SUCCESS;
}

//++
// Function:
//		TracekmpDispatchDeviceControl
//
// Description:
//		This function dispatches DeviceIoControl
//		requests from Win32
//
// Arguments:
//		Pointer to Device object
//		Pointer to IRP for this request
//
// Return Value:
//		This function returns STATUS_XXX
//--
NTSTATUS
TracekmpDispatchDeviceControl(
	IN PDEVICE_OBJECT pDO,
	IN PIRP Irp
	)
{
	NTSTATUS status;
    EVENT_TRACE_HEADER Header, *Wnode;
	PIO_STACK_LOCATION irpStack =
		IoGetCurrentIrpStackLocation( Irp );
    PVOID Buffer =  Irp->AssociatedIrp.SystemBuffer;
    ULONG InBufferLen = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    ULONG OutBufferLen= irpStack->Parameters.DeviceIoControl.OutputBufferLength;
//    WMI_LOGGER_INFORMATION LoggerInfo;

	ULONG ControlCode = 
		irpStack->Parameters.
			DeviceIoControl.IoControlCode;

//    RtlZeroMemory(&LoggerInfo, sizeof(LoggerInfo));
//    LoggerInfo.Wnode.BufferSize = sizeof(LoggerInfo);
//    LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID;
//    RtlInitUnicodeString(&LoggerInfo.LoggerName, L"TraceKmp");
//    RtlInitUnicodeString(&LoggerInfo.LogFileName, L"C:\\tracekmp.etl");

    Irp->IoStatus.Information = OutBufferLen;

	switch( ControlCode )
	{
		case IOCTL_TRACEKMP_TRACE_EVENT:

            //
            // Every time you get this IOCTL, we also log a trace event
            // to illustrate that the event can be caused by user-mode
            //

            if (TracekmpEnable) {
                Wnode = &Header;
                RtlZeroMemory(Wnode, sizeof(EVENT_TRACE_HEADER));
                Wnode->Size = sizeof(EVENT_TRACE_HEADER);
                Wnode->Flags |= WNODE_FLAG_TRACED_GUID;
                Wnode->Guid = TracekmpGuid;
                ((PWNODE_HEADER)Wnode)->HistoricalContext = LoggerHandle;
                status = IoWMIWriteEvent((PVOID)Wnode); 
            }
            else {
                status = STATUS_SUCCESS;
            }
			Irp->IoStatus.Information = 0;
			break;

        case IOCTL_TRACEKMP_START:
            status = WmiStartTrace(Buffer);
            DbgPrint("Start status = %X\n", status);
            break;

        case IOCTL_TRACEKMP_STOP:
            status = WmiStopTrace(Buffer);
            DbgPrint("Stop status = %X\n", status);
            break;

        case IOCTL_TRACEKMP_QUERY:
            status = WmiQueryTrace(Buffer);
            DbgPrint("Query status = %X\n", status);
            break;

        case IOCTL_TRACEKMP_UPDATE:
            status = WmiUpdateTrace(Buffer);
            DbgPrint("Update status = %X\n", status);
            break;

        case IOCTL_TRACEKMP_FLUSH:
            status = WmiFlushTrace(Buffer);
            DbgPrint("Flush status = %X\n", status);
            break;
		//
		// Not one we recognize. Error.
		//
		default:
			status = STATUS_INVALID_PARAMETER; 
 			Irp->IoStatus.Information = 0;
			break;
	}

	//
	// Get rid of this request
	//
	Irp->IoStatus.Status = status;
	IoCompleteRequest( Irp, IO_NO_INCREMENT );
	return status;
}

NTSTATUS
PcWmiRegisterGuids(
    IN  PWMIREGINFO             WmiRegInfo,
    IN  ULONG                   wmiRegInfoSize,
    IN  PULONG                  pReturnSize
    )
{
    //
    // Register a Control Guid as a Trace Guid. 
    //

    ULONG SizeNeeded;
    PWMIREGGUIDW WmiRegGuidPtr;
    ULONG Status;
    ULONG GuidCount;
    LPGUID ControlGuid;
    ULONG RegistryPathSize;
    PUCHAR ptmp;

    *pReturnSize = 0;
    GuidCount = 1;
    ControlGuid = &TracekmpGuid;

    //
    // Allocate WMIREGINFO for controlGuid + GuidCount.
    //
    RegistryPathSize = sizeof(PROC_REG_PATH) - sizeof(WCHAR) + sizeof(USHORT);
    SizeNeeded = sizeof(WMIREGINFOW) + GuidCount * sizeof(WMIREGGUIDW) +
                 RegistryPathSize;


    if (SizeNeeded  > wmiRegInfoSize) {
        *((PULONG)WmiRegInfo) = SizeNeeded;
        *pReturnSize = sizeof(ULONG);
        return STATUS_SUCCESS;
    }


    RtlZeroMemory(WmiRegInfo, SizeNeeded);
    WmiRegInfo->BufferSize = SizeNeeded;
    WmiRegInfo->GuidCount = GuidCount;
    WmiRegInfo->NextWmiRegInfo = 
    WmiRegInfo->RegistryPath = 
    WmiRegInfo->MofResourceName = 0;

    WmiRegGuidPtr = &WmiRegInfo->WmiRegGuid[0];
    WmiRegGuidPtr->Guid = *ControlGuid;
    WmiRegGuidPtr->Flags |= WMIREG_FLAG_TRACED_GUID;
    WmiRegGuidPtr->Flags |= WMIREG_FLAG_TRACE_CONTROL_GUID;
    WmiRegGuidPtr->InstanceCount = 0;
    WmiRegGuidPtr->InstanceInfo = 0;

    ptmp = (PUCHAR)&WmiRegInfo->WmiRegGuid[1];
    WmiRegInfo->RegistryPath = PtrToUlong((PVOID) (ptmp - (PUCHAR)WmiRegInfo));
    *((PUSHORT)ptmp) = sizeof(PROC_REG_PATH) - sizeof(WCHAR);

    ptmp += sizeof(USHORT);
    RtlCopyMemory(ptmp, PROC_REG_PATH, sizeof(PROC_REG_PATH) - sizeof(WCHAR));

    *pReturnSize =  SizeNeeded;
    return(STATUS_SUCCESS);


}

#ifndef USE_CALLBACK
NTSTATUS 
PcWmiDispatch(
    IN PDEVICE_OBJECT pDO,
    IN PIRP Irp
    )
{
    
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG BufferSize = irpSp->Parameters.WMI.BufferSize;
    PVOID Buffer = irpSp->Parameters.WMI.Buffer;
    ULONG ReturnSize = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    PWNODE_HEADER Wnode=NULL;
    HANDLE ThreadHandle;

    UNREFERENCED_PARAMETER(pDO);

    switch (irpSp->MinorFunction) {

    case IRP_MN_REGINFO:
#if DBG
        DbgPrint("IRP_MN_REG_INFO\n");
#endif
        Status = PcWmiRegisterGuids(  Buffer,
                                 BufferSize,
                                 &ReturnSize);
        break;

    case IRP_MN_ENABLE_EVENTS:

        InterlockedExchange(&TracekmpEnable, 1);

        Wnode = (PWNODE_HEADER)Buffer;
        if (BufferSize >= sizeof(WNODE_HEADER)) {
            LoggerHandle = Wnode->HistoricalContext;
#if DBG
            DbgPrint("LoggerHandle %I64u\n", Wnode->HistoricalContext);

            DbgPrint("BufferSize %d\n", Wnode->BufferSize);
            DbgPrint("Flags %x\n", Wnode->Flags);
            DbgPrint("Version %x\n", Wnode->Version);
#endif
        }

        //
        // After getting enabled, create a thread to log a few events
        // to test this out. 

        Status = PsCreateSystemThread(
                   &ThreadHandle,
                   THREAD_ALL_ACCESS,
                   NULL,
                   NULL,
                   NULL,
                   TraceEventLogger,
                   &LoggerHandle );

        if (NT_SUCCESS(Status)) {  // if SystemThread is started
            ZwClose (ThreadHandle);
        }


#if DBG
        DbgPrint("IRP_MN_ENABLE_EVENTS\n");
#endif
        break;

    case IRP_MN_DISABLE_EVENTS:
        InterlockedExchange(&TracekmpEnable, 0);
#if DBG
        DbgPrint(" IRP_MN_DISABLE_EVENTS\n");
#endif
        break;

    case IRP_MN_ENABLE_COLLECTION:

#if DBG
        DbgPrint("IRP_MN_ENABLE_COLLECTION\n");
#endif
        break;

    case IRP_MN_DISABLE_COLLECTION:
#if DBG
        DbgPrint("IRP_MN_DISABLE_COLLECTION\n");
#endif
        break;
    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = Status;
        Irp->IoStatus.Information = 0;
#if DBG
        DbgPrint("DEFAULT\n");
#endif
        return Status;
    }


    //
    // Before the packet goes back to the
    // I/O Manager, log a message.
    //

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = ReturnSize;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return Status;
}
#endif

VOID
TraceEventLogger(
    IN PTRACEHANDLE pLoggerHandle
    )
{
    NTSTATUS status;
    EVENT_TRACE_HEADER Header, *Wnode;
    PULONG TraceMarker;
    ULONG i = 0;
    TRACEHANDLE LoggerHandle = *pLoggerHandle;

    while (TracekmpEnable) {
        //
        // NOTE: For optimization, the set up of the HEADER should be done
        // one outside of this while loop. It is left here so that the caller
        // at least needs to be conscious of what is being sent
        //
        Wnode = &Header;
        RtlZeroMemory(Wnode, sizeof(EVENT_TRACE_HEADER));
        Wnode->Size = sizeof(EVENT_TRACE_HEADER);

        Wnode->Flags = WNODE_FLAG_TRACED_GUID;
        Wnode->Guid = TracekmpGuid;
        ((PWNODE_HEADER)Wnode)->HistoricalContext = LoggerHandle;

        //
        // Call TraceLogger to  write this event
        //

        status = IoWMIWriteEvent((PVOID)Wnode);

#ifdef DBG
        if ( !(i%100) ) {
            DbgPrint("Another Hundred Events Written \n");
            DbgPrint("Status %x LoggerHandle %I64X\n", status, LoggerHandle);
        }
#endif

        if (i++ > MAXEVENTS)
            break;

    }

    PsTerminateSystemThread(status);
    return;

}

VOID
TracekmpDriverUnload(
	IN PDRIVER_OBJECT DriverObject
	)
{
	PDEVICE_OBJECT pDevObj;
	
	UNICODE_STRING linkName;

#if DBG
    DbgPrint("Unloading the  Driver\n");
#endif

	//
	// Get pointer to Device object
	//	
	pDevObj = DriverObject->DeviceObject;

        //
    IoWMIRegistrationControl(pDevObj, WMIREG_ACTION_DEREGISTER);

	//
   	// Form the Win32 symbolic link name.
   	//
	RtlInitUnicodeString( 
		&linkName, 
		TRACEKMP_WIN32_DEVICE_NAME );
	    
	//        
	// Remove symbolic link from Object
	// namespace...
	//
	IoDeleteSymbolicLink( &linkName );


    //
    // Unload the callbacks from the kernel to this driver
    //
	IoDeleteDevice( pDevObj );

}

#ifdef USE_CALLBACK
NTSTATUS
TracekmpControlCallback(
    IN WMIACTIONCODE ActionCode,
    IN PVOID DataPath,
    IN ULONG BufferSize,
    IN OUT PVOID Buffer,
    IN PVOID Context,
    OUT PULONG Size
    )
//
// This callback routine is called to process enable/disable action codes
//
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG BufferSize = irpSp->Parameters.WMI.BufferSize;
    PVOID Buffer = irpSp->Parameters.WMI.Buffer;
    ULONG ReturnSize = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    PWNODE_HEADER Wnode=NULL;
    HANDLE ThreadHandle;

    UNREFERENCED_PARAMETER(pDO);

    switch (ActionCode) {

    case IRP_MN_REG_INFO :
#if DBG
        DbgPrint("IRP_MN_REG_INFO\n");
#endif
        Status = PcWmiRegisterGuids(  Buffer,
                                 BufferSize,
                                 &ReturnSize);
        break;

    case IRP_MN_ENABLE_EVENTS :

        InterlockedExchange(&TracekmpEnable, 1);

        Wnode = (PWNODE_HEADER)Buffer;
        if (BufferSize >= sizeof(WNODE_HEADER)) {
            LoggerHandle = Wnode->HistoricalContext;
#if DBG
            DbgPrint("LoggerHandle %I64u\n", Wnode->HistoricalContext);

            DbgPrint("BufferSize %d\n", Wnode->BufferSize);
            DbgPrint("Flags %x\n", Wnode->Flags);
            DbgPrint("Version %x\n", Wnode->Version);
#endif
        }

        //
        // After getting enabled, create a thread to log a few events
        // to test this out.

        Status = PsCreateSystemThread(
                   &ThreadHandle,
                   THREAD_ALL_ACCESS,
                   NULL,
                   NULL,
                   NULL,
                   TraceEventLogger,
                   &LoggerHandle );

        if (NT_SUCCESS(Status)) {  // if SystemThread is started
            ZwClose (ThreadHandle);
        }


#if DBG
        DbgPrint("IRP_MN_ENABLE_EVENTS\n");
#endif
        break;

    case IRP_MN_DISABLE_EVENTS :
        InterlockedExchange(&TracekmpEnable, 0);
#if DBG
        DbgPrint(" IRP_MN_DISABLE_EVENTS\n");
#endif
        break;

    case IRP_MN_ENABLE_COLLECTION :

#if DBG
        DbgPrint("IRP_MN_ENABLE_COLLECTION\n");
#endif
        break;

    case IRP_MN_DISABLE_COLLECTION :
#if DBG
        DbgPrint("IRP_MN_DISABLE_COLLECTION\n");
#endif
        break;
    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        ReturnSize = 0;
#if DBG
        DbgPrint("DEFAULT\n");
#endif
        return Status;
    }


    //
    // Before the packet goes back to the
    // I/O Manager, log a message.
    //

    if (Size)
        *Size = ReturnSize;
    return Status;
}
#endif // USE_CALLBACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\samples\wml\inc\wmlkm.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlkm.h

Abstract:

    Kernel mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

--*/
#ifndef WMLKM_H
#define WMLKM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _WML_CONTROL_GUID_REG {
    GUID        Guid;
    union {
        struct {
            ULONG EnableFlags;
            ULONG EnableLevel;
        };
        UINT64 EnableFlags64;
    };
    TRACEHANDLE LoggerHandle;
} WML_CONTROL_GUID_REG, *PWML_CONTROL_GUID_REG;

typedef struct _WML_TINY_INFO {
    PWML_CONTROL_GUID_REG    ControlGuids;
    ULONG                    GuidCount;
    PDEVICE_OBJECT           LowerDeviceObject;
    PUNICODE_STRING          DriverRegPath;
} WML_TINY_INFO, *PWML_TINY_INFO;


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Length, Address
    );

#ifdef __cplusplus
};
#endif

#endif // WMLKM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\samples\wml\um\wmlum.cpp ===
#define _UNICODE
#define UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>
#include <guiddef.h>

#include <rpc.h>
#include <rpcdce.h>

#define REG_TRACE_REGKEY            TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Tracing")

#define REG_TRACE_ENABLED           TEXT("EnableTracing")

#define REG_TRACE_LOG_FILE_NAME     TEXT("LogFileName")
#define REG_TRACE_LOG_SESSION_NAME  TEXT("LogSessionName")
#define REG_TRACE_LOG_BUFFER_SIZE   TEXT("BufferSize")
#define REG_TRACE_LOG_MIN_BUFFERS   TEXT("MinBuffers")
#define REG_TRACE_LOG_MAX_BUFFERS   TEXT("MaxBuffers")
#define REG_TRACE_LOG_MAX_FILESIZE  TEXT("MaxFileSize")
#define REG_TRACE_LOG_MAX_HISTORY   TEXT("MaxHistorySize")
#define REG_TRACE_LOG_MAX_BACKUPS   TEXT("MaxBackups")

#define REG_TRACE_ACTIVE            TEXT("Active")
#define REG_TRACE_CONTROL           TEXT("ControlFlags")
#define REG_TRACE_LEVEL             TEXT("Level")
#define REG_TRACE_GUID              TEXT("Guid")

#include "wmlum.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(*(x)))
#endif

VOID RegisterIfNecessary(LPWSTR KeyName, LPCGUID Guid);

WMLPRINTFUNC WmiLibPrint = 0;

#define NT_LOGGER L"NT Kernel Logger"

VOID
MyDbgPrint(
    UINT Level,
    PCHAR FormatString,
    ...
    )
/*++

 Routine Description:

     Prints a message to the debugger or console, as appropriate.

 Arguments:

     String - The initial message string to print.

     Any FormatMessage-compatible arguments to be inserted in the
     ErrorMessage before it is logged.

 Return Value:
     None.

--*/
{
    CHAR Buffer[256];
    DWORD Bytes;
    va_list ArgList;

    if (WmiLibPrint == NULL) {
        return;
    }

    va_start(ArgList, FormatString);

    Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_STRING,
                           FormatString,
                           0,
                           0,
                           Buffer,
                           sizeof(Buffer) / sizeof(CHAR),
                           &ArgList);


    va_end(ArgList);
    if (Bytes != 0) {
        (*WmiLibPrint)(Level, Buffer);
    }
}

UINT HexVal(int ch) { return isdigit(ch) ? ch - '0' : ch - 'a' + 10; }
UINT Hex(LPWSTR s, int n)
{
    UINT res = 0;
    while(n--) { res = res * 16 + HexVal(*s++); }
    return res;
}

VOID
GuidFromStr(
    IN LPWSTR str, 
    OUT LPGUID guid)
{
    guid->Data1 =            Hex(str +  0, 8);
    guid->Data2 =    (USHORT)Hex(str +  9, 4);
    guid->Data3 =    (USHORT)Hex(str + 14, 4);
    guid->Data4[0] = (UCHAR) Hex(str + 19, 2);
    guid->Data4[1] = (UCHAR) Hex(str + 21, 2);
    guid->Data4[2] = (UCHAR) Hex(str + 24, 2);
    guid->Data4[3] = (UCHAR) Hex(str + 26, 2);
    guid->Data4[4] = (UCHAR) Hex(str + 28, 2);
    guid->Data4[5] = (UCHAR) Hex(str + 30, 2);
    guid->Data4[6] = (UCHAR) Hex(str + 32, 2);
    guid->Data4[7] = (UCHAR) Hex(str + 34, 2);
}

typedef struct _INHERITED_DATA {
    BOOL Active;
    ULONG ControlFlags;
    ULONG LogLevel;
    ULONG Reserved;
    TRACEHANDLE Logger;
    GUID  Guid;
    BOOL  GuidDefined;
} INHERITED_DATA, *PINHERITED_DATA;

VOID
ReadCommonData(
    IN HKEY hk, 
    IN OUT PINHERITED_DATA data
    )
{
    ULONG ulTemp;
    ULONG dwSize;
    WCHAR szGuid[16 * 3 + 1];

    dwSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_ACTIVE, 
                             NULL, NULL, (BYTE *) &ulTemp, &dwSize))
    {
        data->Active = ulTemp;
    }

    dwSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_CONTROL, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwSize)) 
    {
        data->ControlFlags = ulTemp;
    }


    dwSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LEVEL, 
                                         NULL, NULL,
                                         (BYTE *) &ulTemp, 
                                         &dwSize)) 
    {
        data->LogLevel = ulTemp;
    }

    dwSize = sizeof(szGuid);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_GUID, 
                                         NULL, NULL,
                                         (BYTE *) &szGuid, 
                                         &dwSize)) 
    {
        GuidFromStr(szGuid, &data->Guid);
        data->GuidDefined = TRUE;
    }

    return;
}

typedef struct _FULL_LOGGER_INFO {
    EVENT_TRACE_PROPERTIES LoggerInfo;
    WCHAR logFileName[MAX_PATH + 512];
    WCHAR logSessionName[MAX_PATH + 512];
    ULONG MaxHistorySize;
    ULONG MaxBackups;
} FULL_LOGGER_INFO, *PFULL_LOGGER_INFO;

GUID MySystemTraceControlGuid = { /* 9e814aad-3204-11d2-9a82-006008a86939 */
    0x9e814aad,
    0x3204,
    0x11d2,
    {0x9a, 0x82, 0x00, 0x60, 0x08, 0xa8, 0x69, 0x39}
  };

#define ULONG_PTR_DIFF(bigger, smaller) \
    static_cast<ULONG>( (char*)(bigger) - (char*)(smaller) )


VOID 
ReadLoggerInfo(
    IN HKEY hk, 
    OUT PTRACEHANDLE Logger) 
{
    FULL_LOGGER_INFO x;
    WCHAR tmpName[MAX_PATH + 512];
    WCHAR tmpName2[MAX_PATH + 512];
    ULONG ulTemp;
    ULONG dwReadSize = sizeof(ulTemp);    
    ULONG status;
    SYSTEMTIME localTime;
    BOOL success;
    
    RtlZeroMemory(&x.LoggerInfo, sizeof(x));
    x.LoggerInfo.Wnode.BufferSize = sizeof(x);
    x.LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
    x.LoggerInfo.LogFileNameOffset = ULONG_PTR_DIFF(&x.logFileName, &x);
    x.LoggerInfo.LoggerNameOffset  = ULONG_PTR_DIFF(&x.logSessionName, &x);
    x.LoggerInfo.LogFileMode = EVENT_TRACE_FILE_MODE_CIRCULAR;

    //
    // If the key describes a logger,
    // it should have at least LOG_SESSION_NAME value
    //
    dwReadSize = sizeof(x.logSessionName);
    status = RegQueryValueEx(hk, REG_TRACE_LOG_SESSION_NAME, 
                             NULL, NULL, 
                             (BYTE *) &x.logSessionName, &dwReadSize);
    if (status != ERROR_SUCCESS) {
        return;
    }

    if ( wcscmp(x.logSessionName, NT_LOGGER) == 0) {
        MyDbgPrint(3,"[WML] Enabling system tracing\n", 
                   x.logSessionName,
                   x.LoggerInfo.Wnode.HistoricalContext);

        x.LoggerInfo.Wnode.Guid = MySystemTraceControlGuid;
        x.LoggerInfo.EnableFlags |= 
            EVENT_TRACE_FLAG_PROCESS |
            EVENT_TRACE_FLAG_THREAD |
            EVENT_TRACE_FLAG_DISK_IO |
            EVENT_TRACE_FLAG_NETWORK_TCPIP |
            EVENT_TRACE_FLAG_REGISTRY;
    }

    // Let's query, whether there is a logger with this name
    status = QueryTrace(0, x.logSessionName, &x.LoggerInfo);
    if (ERROR_SUCCESS == status) {
        MyDbgPrint(1,"[WML] Query successful Logger %1!ws! %2!08X!:%3!08X!\n", 
                   x.logSessionName,
                   x.LoggerInfo.Wnode.HistoricalContext);
        *Logger = x.LoggerInfo.Wnode.HistoricalContext;
        return;
    }

    if (ERROR_WMI_INSTANCE_NOT_FOUND != status) {
        MyDbgPrint(1,"[WML] Query of %1!ws! failed %2!d!\n", 
                   x.logSessionName, status);
    }

    // There is no logger runing

    // First, We will query logFileName value into tmpName variable
    // and then expand it into logFileName
    dwReadSize = sizeof(tmpName);
    status = RegQueryValueEx(hk, REG_TRACE_LOG_FILE_NAME, 
                             NULL, NULL, 
                             (BYTE *) &tmpName, &dwReadSize);
    if (status != ERROR_SUCCESS) {
        // If there is no logFileName, then this node doesn't describe
        // a logger. Bail out.
        MyDbgPrint(1,"[WML] Cannot read log file name, status %1!d!\n", status);
        return;
    }
    dwReadSize = ExpandEnvironmentStrings(tmpName, x.logFileName, ARRAYSIZE(x.logFileName) );
    if (dwReadSize == 0 || dwReadSize > ARRAYSIZE(x.logFileName)) {
        MyDbgPrint(1,"[WML] Expansion of %1!ws! failed, return value %2!d!\n", tmpName, dwReadSize);
        CopyMemory(x.logFileName, tmpName, sizeof(x.logFileName));
    }
    
    MyDbgPrint(3,"[WML] FileName %1!S!\n", x.logFileName);
    MyDbgPrint(3,"[WML] Session %1!S!\n", x.logSessionName);

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_BUFFER_SIZE, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize))
        x.LoggerInfo.BufferSize = ulTemp;

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MIN_BUFFERS, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize))
        x.LoggerInfo.MinimumBuffers = ulTemp;

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_BUFFERS, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize))
        x.LoggerInfo.MaximumBuffers = ulTemp;

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_FILESIZE, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize))
        x.LoggerInfo.MaximumFileSize = ulTemp;

	x.MaxHistorySize = 4 * x.LoggerInfo.MaximumFileSize;
    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_HISTORY, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize))
        x.MaxHistorySize = ulTemp;

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_BACKUPS, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize))
        x.MaxBackups = ulTemp;


	if (x.MaxBackups == 0) {
	 	// We need to check whether the file already exist and rename it //

	 	GetLocalTime(&localTime);
		_snwprintf(tmpName, ARRAYSIZE(tmpName), 
				   L"%1ws.%04d%02d%02d%02d%02d%02d",
				   x.logFileName,
				   localTime.wYear,localTime.wMonth,localTime.wDay,
				   localTime.wHour,localTime.wMinute,localTime.wSecond);

		success = MoveFile(x.logFileName, tmpName);
		if (!success) {
	    	status = GetLastError();
		} else {
			status = ERROR_SUCCESS;
		}
	    MyDbgPrint(3,"[WML] Rename %1!ws! => %2!ws!, status %3!d!\n", 
	    			x.logFileName, tmpName, status);
	} else {
		int i;
		for (i = x.MaxBackups; i >= 1; --i) {
			_snwprintf(tmpName2, ARRAYSIZE(tmpName), 
					   L"%1ws.%03d",
					   x.logFileName, i);
			if (i == 1) {
				wcscpy(tmpName, x.logFileName);
			} else {
				_snwprintf(tmpName, ARRAYSIZE(tmpName), 
						   L"%1ws.%03d",
						   x.logFileName, i-1);
			}
			success = MoveFileEx(tmpName, tmpName2, MOVEFILE_REPLACE_EXISTING);
			if (!success) {
		    	status = GetLastError();
			} else {
				status = ERROR_SUCCESS;
			}
		    MyDbgPrint(3,"[WML] Rename %1!ws! => %2!ws!, status %3!d!\n", 
		    			tmpName, tmpName2, status);
		}
	}

    status = StartTrace(Logger, x.logSessionName, &x.LoggerInfo);
    *Logger = x.LoggerInfo.Wnode.HistoricalContext;
    MyDbgPrint(1,"[WML] Logger %1!ws! started %3!08X!:%4!08X! %2!d!\n", 
               x.logSessionName, status, *Logger);
}

WCHAR szModuleName[MAX_PATH+500];

ULONG
InitWmiInternal(
    IN HKEY Dir OPTIONAL, // if 0, then current ...
    IN LPWSTR ProductName, 
    IN PINHERITED_DATA InheritedData OPTIONAL
    )
{
    ULONG status;
    INHERITED_DATA data;
    HKEY CloseMe = 0;
    HKEY hk      = 0;
    //ULONG ulTemp;
    //ULONG dwReadSize = sizeof(ulTemp);
    DWORD dwSizeOfModuleName;
    DWORD dwIndex;

    MyDbgPrint(2, "[WML] Init %1!ws!\n", ProductName);

    if (InheritedData) {
        data = *InheritedData;
    } else {
        ZeroMemory(&data, sizeof(data));
    }
    data.GuidDefined = FALSE;

    if (!Dir) {
        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                              REG_TRACE_REGKEY, 
                              0, 
                              KEY_READ, 
                              &CloseMe);
        if (status != ERROR_SUCCESS) {
            MyDbgPrint(1,"[WML] Failed to open Trace Key, %1!d!\n", status);
            goto exit_gracefully;
        }
        Dir = CloseMe;
    }

    status = RegOpenKeyEx(Dir, 
                          ProductName, 
                          0, 
                          KEY_READ, 
                          &hk);
    if (status != ERROR_SUCCESS) {
        MyDbgPrint(1,"[WML] Failed to open %1!ws! subkey, %2!d!\n", ProductName, status);
        goto exit_gracefully;
    }


    ReadLoggerInfo(hk, &data.Logger);
    ReadCommonData(hk, &data);

    if (!data.Active) {
        MyDbgPrint(1,"[WML] Tracing is not active for %1!ws!\n", ProductName);
    	goto exit_gracefully;
    }

    if (data.GuidDefined) {
        // First, try to find its in the map.            //
        // If it is there, we need to register this Guid //
        RegisterIfNecessary(ProductName, &data.Guid);

        // We can try to start tracing //
        if (data.Logger) {
            status = EnableTrace(data.Active, 
                                 data.ControlFlags, 
                                 data.LogLevel,
                                 &data.Guid,
                                 data.Logger);
            MyDbgPrint(1,"[WML] Enable=%1!d! %2!ws!, status %3!d!\n", data.
                       Active, ProductName, status);
        }
    }

    dwSizeOfModuleName = sizeof(szModuleName);
    dwIndex = 0;
    while (ERROR_SUCCESS == (status = RegEnumKeyEx(hk, dwIndex, 
                                                   szModuleName, 
                                                   &dwSizeOfModuleName,
                                                   NULL, NULL, NULL, NULL)))
    {
        InitWmiInternal(hk, szModuleName, &data);

        dwSizeOfModuleName = sizeof(szModuleName);
        ++dwIndex;
    }

    if (ERROR_NO_MORE_ITEMS == status) {
        status = ERROR_SUCCESS;
    }

exit_gracefully:
    if (CloseMe) {
        RegCloseKey(CloseMe);
    }
    if (hk) {
        RegCloseKey(hk);
    }
    return status;
}

ULONG
InitWmi(
    IN LPWSTR ProductName
    )
{
    MyDbgPrint(1, "[WML] Initialize %1!ws!\n", ProductName);
    return InitWmiInternal(0, ProductName, 0);
}

#pragma warning(disable: 4512) // error C4512: 'blah-blah-blah' : assignment operator could not be generated
#pragma warning(disable: 4100) // '_P' : unreferenced formal parameter
#include <xmemory>
#pragma warning(default: 4100)
#include <map>
//#include <xstring>

struct wless {
    bool operator() (LPCWSTR a, LPCWSTR b) const { return lstrcmpW(a,b) < 0; }
};

typedef std::map<LPCWSTR, PWML_REG_STRUCT, wless > WIDE_STRING_MAP;

WIDE_STRING_MAP* map;
PWML_REG_STRUCT head;

ULONG
WmilibControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    PWML_REG_STRUCT Ctx = (PWML_REG_STRUCT)Context;
    ULONG Status = ERROR_SUCCESS;

   	switch (RequestCode)
   	{
   	case WMI_ENABLE_EVENTS:
   	    {
   	    Ctx->LoggerHandle = GetTraceLoggerHandle( Buffer );
   	    Ctx->EnableLevel = GetTraceEnableLevel(Ctx->LoggerHandle);
   	    Ctx->EnableFlags = GetTraceEnableFlags(Ctx->LoggerHandle);
        MyDbgPrint(3, "[WML] WMI_ENABLE_EVENTS Ctx 0x%1!08X! Flags %2!X! Lev %3!d! Logger %4!08X!:%5!08X!\n", 
                   Ctx, Ctx->EnableFlags, Ctx->EnableLevel, Ctx->LoggerHandle);
    
        break;
   	    }

   	case WMI_DISABLE_EVENTS:
   	    {
        Ctx->LoggerHandle = 0;
        Ctx->EnableFlags = 0;
        Ctx->EnableLevel = 0;
        MyDbgPrint(3, "[WML] WMI_DISABLE_EVENTS Ctx 0x%1!08X!\n", Ctx);
   	    break;
    	}

   	default:
   	   {
   	       Status = ERROR_INVALID_PARAMETER;
   	       break;
   	   }
   	}
   	*InOutBufferSize = 0;
   	return(Status);
}



VOID RegisterIfNecessary(
    LPWSTR KeyName, 
    LPCGUID Guid)
{
    WIDE_STRING_MAP::iterator i = map->find(KeyName);
    if ( i == map->end() ) {
        MyDbgPrint(2, "[WML] map: %1!ws!, not found\n", KeyName);
        return; // Not found //
    }
    MyDbgPrint(3, "[WML] map[%1!ws!]=0x%2!08X!\n", i->first, i->second);

    TRACE_GUID_REGISTRATION Reg;

    Reg.Guid = Guid;
    Reg.RegHandle = 0;

    ULONG status = RegisterTraceGuids(
        WmilibControlCallback,
        i->second, // Context for the callback
        Guid,      // Control Guid
        1,         // # of dummies
        &Reg,      // dummy trace guid
        0, //ImagePath,
        0, //ResourceName,
        &i->second->RegistrationHandle
        );

    if (status == ERROR_SUCCESS) {
        i->second->Next = head;
        head = i->second;
    } else {
        MyDbgPrint(1, "[WML] Failed to register %1!ws!, status %2!d!\n", KeyName, status);
    }
}

WCHAR DefaultLoggerName[] = L"DefaultLogger";


ULONG
CreateAppKey(LPCWSTR ProductName)
{
    DWORD status;
    DWORD disposition;
    HKEY  TracingKey = 0;
    HKEY  ProductKey = 0;
    DWORD dwValue;
    
    status = RegCreateKeyEx(HKEY_LOCAL_MACHINE, 
                            REG_TRACE_REGKEY, 
                            0, 
                            NULL, // Class
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_CREATE_SUB_KEY, 
                            NULL, // Sec Attributes
                            &TracingKey,
                            &disposition
                            );
    if (status != ERROR_SUCCESS) {
        MyDbgPrint(1,"[WML] Failed to create Trace Key, %1!d!\n", status);
        goto exit_gracefully;
    }

    status = RegCreateKeyEx(TracingKey, 
                            ProductName, 
                            0, 
                            NULL, // Class
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE, 
                            NULL, // Sec Attributes
                            &ProductKey,
                            &disposition
                            );
    if (status != ERROR_SUCCESS) {
        MyDbgPrint(1,"[WML] Failed to create Trace Key, %1!d!\n", status);
        goto exit_gracefully;
    }

    status = RegSetValueEx(ProductKey,
                  REG_TRACE_LOG_SESSION_NAME,
                  0, // Reserved
                  REG_EXPAND_SZ,
                  (const BYTE*)DefaultLoggerName,
                  sizeof(DefaultLoggerName) );
    if (status != ERROR_SUCCESS) {
        MyDbgPrint(1,"[WML] Failed to create LogSession value, %1!d!\n", status);
        goto exit_gracefully;
    }

    dwValue = 1;
    status = RegSetValueEx(ProductKey,
                  REG_TRACE_ACTIVE,
                  0, // Reserved
                  REG_DWORD,
                  (const BYTE*)&dwValue,
                  sizeof(dwValue) );
    if (status != ERROR_SUCCESS) {
        MyDbgPrint(1,"[WML] Failed to create Active value, %1!d!\n", status);
        goto exit_gracefully;
    }
    dwValue = 1;
    status = RegSetValueEx(ProductKey,
                  REG_TRACE_LEVEL,
                  0, // Reserved
                  REG_DWORD,
                  (const BYTE*)&dwValue,
                  sizeof(dwValue) );
    if (status != ERROR_SUCCESS) {
        MyDbgPrint(1,"[WML] Failed to create Level value, %1!d!\n", status);
        goto exit_gracefully;
    }
    dwValue = 1;
    status = RegSetValueEx(ProductKey,
                  REG_TRACE_CONTROL,
                  0, // Reserved
                  REG_DWORD,
                  (const BYTE*)&dwValue,
                  sizeof(dwValue) );
    if (status != ERROR_SUCCESS) {
        MyDbgPrint(1,"[WML] Failed to create Control value, %1!d!\n", status);
        goto exit_gracefully;
    }

    {
    WIDE_STRING_MAP::iterator i = map->begin();
    for(; i != map->end(); ++i) {
        status = RegCreateKeyEx(ProductKey, 
                                i->first, 
                                0, 
                                NULL, // Class
                                REG_OPTION_NON_VOLATILE,
                                KEY_WRITE, 
                                NULL, // Sec Attributes
                                &ProductKey,
                                &disposition
                                );
        if (status != ERROR_SUCCESS) {
            MyDbgPrint(1,"[WML] Failed to create %S Key, %1!d!\n", i->first, status);
        } else {
            GUID guid;
            WCHAR guidBuf[32+6+1];
    
            RPC_STATUS status = UuidCreate( &guid );
            if ( status != RPC_S_OK ) {
                MyDbgPrint(1,"[WML] UuidCreate failed, %1!d!\n", status);
                continue;
            }
            swprintf(guidBuf,L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                    guid.Data1,guid.Data2,guid.Data3,
                    guid.Data4[0],guid.Data4[1],guid.Data4[2],guid.Data4[3],
                    guid.Data4[4],guid.Data4[5],guid.Data4[6],guid.Data4[7] );
            status = RegSetValueEx(ProductKey,
                          REG_TRACE_GUID,
                          0, // Reserved
                          REG_SZ,
                          (const BYTE*)guidBuf,
                          sizeof(guidBuf) );
            if (status != ERROR_SUCCESS) {
                MyDbgPrint(1,"[WML] Failed to create GUID value, %1!d!\n", status);
            }
        }
        
    }
    }
             
exit_gracefully:

    if (ProductKey) {
        RegCloseKey(ProductKey);
    }
    if (TracingKey) {
        RegCloseKey(TracingKey);
    }

    return status;
}


ULONG
WmlInitialize(
    IN LPWSTR              ProductName, 
    IN WMLPRINTFUNC     PrintFunc,
    OUT WML_REG_HANDLE* Head, 
    ... // Pairs: LPWSTR CtrlGuidName, Corresponding WML_REG_STRUCT 
    )
{
    WIDE_STRING_MAP map;
    LPWSTR str;
    va_list ap;

    WmiLibPrint = PrintFunc;

    *Head = 0;

    ::head = 0;
    ::map = &map;

    va_start(ap, Head);
    while(0 != (str = va_arg(ap, LPWSTR)) ) {
         map[ str ] = va_arg(ap, PWML_REG_STRUCT);
    }
    va_end(ap);
    ULONG status = InitWmiInternal(0, ProductName, 0);
    if (status == ERROR_FILE_NOT_FOUND) {
        status = CreateAppKey(ProductName);
        if (status == ERROR_SUCCESS) {
            status = InitWmiInternal(0, ProductName, 0);
        }
    }
    *Head = ::head;
    return status;
}

VOID
WmlUninitialize(
    IN PWML_REG_STRUCT head
    )
{
    while (head) {
        MyDbgPrint(3,"[WML] Unregister 0x%1!08X!\n", head);
        UnregisterTraceGuids(head->RegistrationHandle);
        head = head->Next;
    }
}

#define WML_USER_MODE

typedef struct _TRACE_BUFFER {
    union {
        EVENT_TRACE_HEADER Trace;
        WNODE_HEADER       Wnode;
    };
    MOF_FIELD MofFields[MAX_MOF_FIELDS + 1];
} TRACE_BUFFER, *PTRACE_BUFFER;


//////////////////////////////////////////////////////////////////////
//  0  | Size      | ProviderId  |   0  |Size.HT.Mk | Typ.Lev.Version|
//  2  | L o g g e r H a n d l e |   2  |    T h r e a d   I d       |
//  4  | T i m e  S t a m p      |   4  |    T i m e  S t a m p      |
//  6  |    G U I D    L o w     |   6  |    GUID Ptr / Guid L o w   |
//  8  |    G U I D    H I g h   |   8  |    G U I D    H i g h      |
// 10  | ClientCtx | Flags       |  10  |KernelTime | UserTime       |
//////////////////////////////////////////////////////////////////////

ULONG
WmlTrace(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    )
{
    TRACE_BUFFER TraceBuffer;

    ((PULONG)&TraceBuffer)[1] = Type;
    
#ifndef WML_USER_MODE
    TraceBuffer.Wnode.HistoricalContext = LoggerHandle;
#endif

    TraceBuffer.Trace.Guid = *TraceGuid;

    TraceBuffer.Wnode.Flags = 
        WNODE_FLAG_USE_MOF_PTR  | // MOF data are dereferenced
        WNODE_FLAG_TRACED_GUID;   // Trace Event, not a WMI event

    {
        PMOF_FIELD   ptr = TraceBuffer.MofFields;
        va_list      ap;

        va_start(ap, LoggerHandle);
        do {
            if ( 0 == (ptr->Length = (ULONG)va_arg (ap, size_t)) )  {
                break;
            }
            ptr->DataPtr = (ULONGLONG)va_arg(ap, PVOID);
        } while ( ++ptr < &TraceBuffer.MofFields[MAX_MOF_FIELDS] );
        va_end(ap);

        TraceBuffer.Wnode.BufferSize = (ULONG) ((ULONG_PTR)ptr - (ULONG_PTR)&TraceBuffer);
    }
    
#ifdef WML_USER_MODE
    ULONG status = TraceEvent( LoggerHandle, &TraceBuffer.Trace);
    if (status != ERROR_SUCCESS) {
    	// Need to count failures and report them during unintialize or ...//
    }
#else
    IoWMIWriteEvent(&TraceBuffer);
#endif
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\samples\wml\um\test\wmltest.cpp ===
#include <stdio.h>

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "wmlum.h"
//#include "wmlmacro.h"

WML_REG_STRUCT   ClRtlWmiReg;
GUID ClRtlTraceGuid = { /* a14414bc-22d9-11d3-ba8a-00c04f8eed00 */
    0xa14414bc,0x22d9,0x11d3,{0xba,0x8a,0x00,0xc0,0x4f,0x8e,0xed,0x00}};

void print(UINT level, LPCSTR str) {
    printf(str);
}

WML_DATA wml;

char a[] = "Gorik&Anzhela";

int __cdecl main(int argc, char** argv) {

    DWORD status;
    ULONG ProcessId = 123;
    STRING as;

    as.Buffer = a+6;
    as.Length = 7;
    

    LOADWML(status, wml);
    printf("LOADWML status, %d\n", status);
    if (status != ERROR_SUCCESS) {
        return -1;
    }

    
    wml.Initialize(L"Clustering Service", print, &wml.WmiRegHandle, 
                   L"ClusRtl", &ClRtlWmiReg,
                    0);
#if 0
    wml.Trace( 10, &ClRtlTraceGuid, ClRtlWmiReg.LoggerHandle,
                   LOG(UINT, ProcessId )
                   LOGCSTR(as) 0);
#endif

    UNLOADWML(wml);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\samples\wml\km\wmlkm.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cldskwmi.c

Abstract:

    km wmi tracing code. 
    
    Will be shared between our drivers.

Authors:

    GorN     10-Aug-1999

Environment:

    kernel mode only

Notes:

Revision History:

Comments:

	This code is a quick hack to enable WMI tracing in cluster drivers.
	It should eventually go away.

	WmlTinySystemControl will be replaced with WmilibSystemControl from wmilib.sys .

	WmlTrace or equivalent will be added to the kernel in addition to IoWMIWriteEvent(&TraceBuffer);

--*/
#include <wdm.h>
#include <stdarg.h> // to get va_list, etc

#include <wmistr.h>
#include <wmiumkm.h>
#include <evntrace.h>

#include "wmlkm.h"

BOOLEAN
WmlpFindGuid(
    IN PWML_CONTROL_GUID_REG GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex
    )
/*++

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid
        
Return Value:

    TRUE if guid is found else FALSE

--*/
{
    ULONG i;

    for (i = 0; i < GuidCount; i++)
    {
        if (IsEqualGUID(Guid, &GuidList[i].Guid))
        {
            *GuidIndex = i;
            return(TRUE);
        }
    }

    return(FALSE);
}


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL. This routine will process
    all wmi requests received, forwarding them if they are not for this
    driver or determining if the guid is valid and if so passing it to
    the driver specific function for handing wmi requests.

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

    status

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG bufferSize;
    PUCHAR buffer;
    NTSTATUS status;
    ULONG retSize;
    UCHAR minorFunction;
    ULONG guidIndex;
    ULONG instanceCount;
    ULONG instanceIndex;

    //
    // If the irp is not a WMI irp or it is not targetted at this device
    // or this device has not regstered with WMI then just forward it on.
    minorFunction = irpStack->MinorFunction;
    if ((minorFunction > IRP_MN_EXECUTE_METHOD) ||
        (irpStack->Parameters.WMI.ProviderId != (ULONG_PTR)DeviceObject) ||
        ((minorFunction != IRP_MN_REGINFO) &&
         (WmiLibInfo->GuidCount == 0) || (WmiLibInfo->ControlGuids == NULL) ))
    {
        //
        // IRP is not for us so forward if there is a lower device object
        if (WmiLibInfo->LowerDeviceObject != NULL)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            return(IoCallDriver(WmiLibInfo->LowerDeviceObject, Irp));
        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    if (minorFunction != IRP_MN_REGINFO)
    {
        //
        // For all requests other than query registration info we are passed
        // a guid. Determine if the guid is one that is supported by the
        // device.
        if (WmlpFindGuid(WmiLibInfo->ControlGuids,
                            WmiLibInfo->GuidCount,
                            (LPGUID)irpStack->Parameters.WMI.DataPath,
                            &guidIndex) )
        {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }

        if (!NT_SUCCESS(status))
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    switch(minorFunction)
    {
        case IRP_MN_REGINFO:
        {
            ULONG guidCount;
            PWML_CONTROL_GUID_REG guidList;
            PWMIREGINFOW wmiRegInfo;
            PWMIREGGUIDW wmiRegGuid;
            PDEVICE_OBJECT pdo;
            PUNICODE_STRING regPath;
            PWCHAR stringPtr;
            ULONG registryPathOffset;
            ULONG bufferNeeded;
            ULONG i;
            UNICODE_STRING nullRegistryPath;

            regPath = WmiLibInfo->DriverRegPath;
            guidList = WmiLibInfo->ControlGuids;
            guidCount = WmiLibInfo->GuidCount;

            if (regPath == NULL)
            {
                // No registry path specified. This is a bad thing for 
                // the device to do, but is not fatal
                nullRegistryPath.Buffer = NULL;
                nullRegistryPath.Length = 0;
                nullRegistryPath.MaximumLength = 0;
                regPath = &nullRegistryPath;
            }                
            
            registryPathOffset = FIELD_OFFSET(WMIREGINFOW, WmiRegGuid) +
                                  guidCount * sizeof(WMIREGGUIDW);

            bufferNeeded = registryPathOffset +
                regPath->Length + sizeof(USHORT);

            if (bufferNeeded <= bufferSize)
            {
                retSize = bufferNeeded;
                RtlZeroMemory(buffer, bufferNeeded);

                wmiRegInfo = (PWMIREGINFO)buffer;
                wmiRegInfo->BufferSize = bufferNeeded;
                // wmiRegInfo->NextWmiRegInfo = 0;
                // wmiRegInfo->MofResourceName = 0;
                wmiRegInfo->RegistryPath = registryPathOffset;
                wmiRegInfo->GuidCount = guidCount;

                for (i = 0; i < guidCount; i++)
                {
                    wmiRegGuid = &wmiRegInfo->WmiRegGuid[i];
                    wmiRegGuid->Guid = guidList[i].Guid;
                    wmiRegGuid->Flags = WMIREG_FLAG_TRACED_GUID | WMIREG_FLAG_TRACE_CONTROL_GUID;
                    // wmiRegGuid->InstanceInfo = 0;
                    // wmiRegGuid->InstanceCount = 0;
                }

                stringPtr = (PWCHAR)((PUCHAR)buffer + registryPathOffset);
                *stringPtr++ = regPath->Length;
                RtlCopyMemory(stringPtr,
                          regPath->Buffer,
                          regPath->Length);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
                *((PULONG)buffer) = bufferNeeded;
                retSize = sizeof(ULONG);
            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = retSize;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }

        case IRP_MN_ENABLE_EVENTS:
        case IRP_MN_DISABLE_EVENTS:
        {
            PWNODE_HEADER   Wnode = irpStack->Parameters.WMI.Buffer;
            PWML_CONTROL_GUID_REG Ctx = WmiLibInfo->ControlGuids + guidIndex;
            if (irpStack->Parameters.WMI.BufferSize >= sizeof(WNODE_HEADER)) {
                status = STATUS_SUCCESS;

                if (minorFunction == IRP_MN_DISABLE_EVENTS) {
                    Ctx->EnableFlags64 = 0;
                } else {
                    Ctx->LoggerHandle = (TRACEHANDLE)( Wnode->HistoricalContext );
                    
                    Ctx->EnableLevel = WmipGetLoggerEnableLevel(Ctx->LoggerHandle);
                    Ctx->EnableFlags = WmipGetLoggerEnableFlags(Ctx->LoggerHandle);
                }
            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            break;
        }

        case IRP_MN_ENABLE_COLLECTION:
        case IRP_MN_DISABLE_COLLECTION:
        {
            status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_QUERY_ALL_DATA:
        case IRP_MN_QUERY_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_ITEM:
        case IRP_MN_EXECUTE_METHOD:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    }
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
    return(status);
}

typedef struct _TRACE_BUFFER {
    union {
        EVENT_TRACE_HEADER Trace;
        WNODE_HEADER       Wnode;
    };
    MOF_FIELD MofFields[MAX_MOF_FIELDS + 1];
} TRACE_BUFFER, *PTRACE_BUFFER;


//////////////////////////////////////////////////////////////////////
//  0  | Size      | ProviderId  |   0  |Size.HT.Mk | Typ.Lev.Version|
//  2  | L o g g e r H a n d l e |   2  |    T h r e a d   I d       |
//  4  | T i m e  S t a m p      |   4  |    T i m e  S t a m p      |
//  6  |    G U I D    L o w     |   6  |    GUID Ptr / Guid L o w   |
//  8  |    G U I D    H I g h   |   8  |    G U I D    H i g h      |
// 10  | ClientCtx | Flags       |  10  |KernelTime | UserTime       |
//////////////////////////////////////////////////////////////////////

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Length, Address
    )
{
    TRACE_BUFFER TraceBuffer;

    ((PULONG)&TraceBuffer)[1] = Type;
    
    TraceBuffer.Wnode.HistoricalContext = LoggerHandle; // [KM]

    TraceBuffer.Trace.Guid = *TraceGuid;

    TraceBuffer.Wnode.Flags = 
        WNODE_FLAG_USE_MOF_PTR  | // MOF data are dereferenced
        WNODE_FLAG_TRACED_GUID;   // Trace Event, not a WMI event

    {
        PMOF_FIELD   ptr = TraceBuffer.MofFields;
        va_list      ap;

        va_start(ap, LoggerHandle);
        do {
            if ( 0 == (ptr->Length = (ULONG)va_arg (ap, size_t)) )  {
                break;
            }
            ptr->DataPtr = (ULONGLONG)va_arg(ap, PVOID);
        } while ( ++ptr < &TraceBuffer.MofFields[MAX_MOF_FIELDS] );
        va_end(ap);

        TraceBuffer.Wnode.BufferSize = (ULONG) ((ULONG_PTR)ptr - (ULONG_PTR)&TraceBuffer);
    }
    
    IoWMIWriteEvent(&TraceBuffer); // [KM]
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\samples\wml\inc\wmlum.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlum.h

Abstract:

    User mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:


--*/
#ifndef WMLUM_H
#define WMLUM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _WML_REG_STRUCT
{
    TRACEHANDLE LoggerHandle;
    ULONG EnableFlags; 
    ULONG EnableLevel;

    struct _WML_REG_STRUCT* Next;
    TRACEHANDLE RegistrationHandle;
} WML_REG_STRUCT, *PWML_REG_STRUCT;

typedef PWML_REG_STRUCT WML_REG_HANDLE;

typedef void (*WMLPRINTFUNC)(UINT Level, LPCSTR String);

ULONG
WmlInitialize(
    IN LPCWSTR ProductName, 
    IN WMLPRINTFUNC PrintFunc,
    OUT WML_REG_HANDLE*, 
    ... // Pairs: LPWSTR CtrlGuidName, Corresponding WML_REG_STRUCT 
    );
    
VOID
WmlUninitialize(
    IN WML_REG_HANDLE
    );

ULONG
WmlTrace(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    );

typedef 
ULONG
(*PWML_INITIALIZE)(
    IN LPCWSTR ProductName, 
    IN WMLPRINTFUNC PrintFunc,
    OUT WML_REG_HANDLE*, 
    ...
    );

typedef 
VOID 
(*PWML_UNINITIALIZE)(
    IN WML_REG_HANDLE);

typedef 
ULONG
(*PWML_TRACE)(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... 
    );

typedef 
struct _WML_DATA {

    PWML_TRACE        Trace;
    PWML_INITIALIZE   Initialize;
    PWML_UNINITIALIZE Uninitialize;
    
    WML_REG_HANDLE WmiRegHandle;
    HINSTANCE         WmlDllInstance;
    
} WML_DATA;


#define LOADWML(status, wml) \
    do \
    { \
        HINSTANCE hInst = LoadLibraryW(L"wmlum.dll"); \
        (wml).WmlDllInstance = hInst; \
        if (!hInst) { \
            status = GetLastError(); \
        } else { \
            (wml).Trace        =        (PWML_TRACE) GetProcAddress(hInst, "WmlTrace"); \
            (wml).Initialize   =   (PWML_INITIALIZE) GetProcAddress(hInst, "WmlInitialize"); \
            (wml).Uninitialize = (PWML_UNINITIALIZE) GetProcAddress(hInst, "WmlUninitialize"); \
    \
            if (!(wml).Trace || !(wml).Initialize || !(wml).Uninitialize) { \
                status = GetLastError(); \
            } else { \
                status = ERROR_SUCCESS; \
            } \
        } \
    } \
    while(0)

#define UNLOADWML(wml) \
    do \
    { \
        if ( (wml).Uninitialize ) { \
            (wml).Uninitialize( (wml).WmiRegHandle ); \
        } \
        if ( (wml).WmlDllInstance ) { \
            FreeLibrary( (wml).WmlDllInstance ); \
        } \
        RtlZeroMemory( &(wml) , sizeof(WML_DATA) ); \
    } \
    while(0)  

#ifdef __cplusplus
};
#endif

#endif // WMLUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\sdksamples\tracedmp\tracedmp.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    tracedmp.c

Abstract:

    Sample trace consumer program. Converts binary 
    Event Trace Log (ETL) to CSV format

--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <wbemidl.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>
#include <objidl.h>

#define MAXLOGFILES         16
#define MAXSTR              1024
#define MOFWSTR             16360
#define MOFSTR              32720
#define MAXTYPE             256
#define UC(x)               ( (UINT)((x) & 0xFF) )
#define NTOHS(x)            ( (UC(x) * 256) + UC((x) >> 8) )
// Maximum number of properties per WBEM class object: may need to be changed
#define MAXPROPS            256

#define DUMP_FILE_NAME          _T("DumpFile.csv")
#define SUMMARY_FILE_NAME       _T("Summary.txt")

#define DEFAULT_LOGFILE_NAME    _T("C:\\Logfile.Etl")
#define KERNEL_LOGGER_NAME      _T("NT Kernel Logger")

#define DEFAULT_NAMESPACE       _T("root\\wmi")

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))
#define CHECK_WBEM_HR( hr ) if( WBEM_NO_ERROR != hr ){ WbemError(hr); goto cleanup; }

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

#define GUID_TYPE_EVENTTRACE            _T("EventTrace")
#define GUID_TYPE_HEADER                _T("Header")
#define GUID_TYPE_UNKNOWN               _T("Unknown")
#define GUID_TYPE_DEFAULT               _T("Default")

#define EVENT_TYPE_DEFAULT              (-1)
#define EVENT_LEVEL_DEFAULT             (-1)
#define EVENT_VERSION_DEFAULT           (-1)

#define STR_ItemChar                    _T("ItemChar")
#define STR_ItemWChar                   _T("ItemWChar")
#define STR_ItemUChar                   _T("ItemUChar")
#define STR_ItemCharShort               _T("ItemCharShort")
#define STR_ItemShort                   _T("ItemShort")
#define STR_ItemUShort                  _T("ItemUShort")
#define STR_ItemLong                    _T("ItemLong")
#define STR_ItemULong                   _T("ItemULong")
#define STR_ItemULongX                  _T("ItemULongX")
#define STR_ItemLongLong                _T("ItemLongLong")
#define STR_ItemULongLong               _T("ItemULongLong")
#define STR_ItemFloat                   _T("ItemFloat");
#define STR_ItemDouble                  _T("ItemDouble");
#define STR_ItemString                  _T("ItemString")
#define STR_ItemWString                 _T("ItemWString")
#define STR_ItemPString                 _T("ItemPString")
#define STR_ItemPWString                _T("ItemPWString")
#define STR_ItemDSString                _T("ItemDSString")
#define STR_ItemDSWString               _T("ItemDSWString")
#define STR_ItemMLString                _T("ItemMLString")
#define STR_ItemSid                     _T("ItemSid")
#define STR_ItemIPAddr                  _T("ItemIPAddr")
#define STR_ItemPort                    _T("ItemPort")
#define STR_ItemNWString                _T("ItemNWString")
#define STR_ItemPtr                     _T("ItemPtr")
#define STR_ItemGuid                    _T("ItemGuid")
#define STR_ItemBool                    _T("ItemBool")

// Data types supported in this consumer.
typedef enum _ITEM_TYPE {
    ItemChar,
    ItemWChar,
    ItemUChar,
    ItemCharShort,
    ItemShort,
    ItemUShort,
    ItemLong,
    ItemULong,
    ItemULongX,
    ItemLongLong,
    ItemULongLong,
    ItemFloat,
    ItemDouble,
    ItemString,
    ItemWString,
    ItemPString,
    ItemPWString,
    ItemDSString,
    ItemDSWString,
    ItemSid,
    ItemIPAddr,
    ItemPort,
    ItemMLString,
    ItemNWString,        // Non-null terminated Wide Char String
    ItemPtr,
    ItemGuid,
    ItemBool,
    ItemUnknown
} ITEM_TYPE;

// Construct that represents an event layout
typedef struct _MOF_INFO {
    LIST_ENTRY   Entry;
    LPTSTR       strDescription;        // Class Name
    ULONG        EventCount;
    GUID         Guid;
    PLIST_ENTRY  ItemHeader;
    LPTSTR       strType;               // Type Name
    SHORT        TypeIndex;
    SHORT        Version;
    CHAR         Level;
}  MOF_INFO, *PMOF_INFO;

typedef struct _ITEM_DESC *PITEM_DESC;
// Construct that represents one data item
typedef struct _ITEM_DESC {
    LIST_ENTRY  Entry;
    LPTSTR      strDescription;
    ULONG       DataSize;
    ITEM_TYPE   ItemType;
    UINT        ArraySize;
} ITEM_DESC;

void
PrintHelpMessage();

PMOF_INFO
GetNewMofInfo( 
    GUID guid, 
    SHORT nType, 
    SHORT nVersion, 
    CHAR nLevel 
);

void
AddMofInfo(
    PLIST_ENTRY List,
    LPTSTR  strType,
    ITEM_TYPE   nType,
    UINT    ArraySize
);

HRESULT
WbemConnect( 
    IWbemServices** pWbemServices 
);

ULONG GetArraySize(
    IN IWbemQualifierSet *pQualSet
);

ITEM_TYPE
GetItemType(
    IN CIMTYPE_ENUMERATION CimType, 
    IN IWbemQualifierSet *pQualSet
);

PMOF_INFO
GetPropertiesFromWBEM(
    IWbemClassObject *pTraceSubClasses, 
    GUID Guid,
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType
);

PMOF_INFO
GetGuids( 
    GUID Guid, 
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType
);

ULONG 
ahextoi(
    TCHAR *s
);


PMOF_INFO
GetMofInfoHead(
    GUID Guid,
    SHORT  nType,
    SHORT nVersion,
    CHAR  nLevel
);

ULONG
CheckFile(
    LPTSTR fileName
);

void
CleanupEventList(
    VOID
);

ULONG
WINAPI
BufferCallback(
    PEVENT_TRACE_LOGFILE pLog
);

void
WINAPI
DumpEvent(
    PEVENT_TRACE pEvent
);

void
RemoveMofInfo(
    PLIST_ENTRY pMofInfo
);

void
GuidToString(
    PTCHAR s,
    LPGUID piid
);

HRESULT 
ParseTime( 
    LPTSTR strTime, 
    SYSTEMTIME* pstTime 
);

// output files
FILE* DumpFile = NULL;
FILE* SummaryFile = NULL;

static ULONG TotalBuffersRead = 0;
static ULONG TotalEventsLost = 0;
static ULONG TotalEventCount = 0;
static ULONG TimerResolution = 10;
static ULONGLONG StartTime   = 0;
static ULONGLONG EndTime     = 0;
static BOOL   fNoEndTime  = FALSE;
static __int64 ElapseTime;

PCHAR  MofData    = NULL;
size_t MofLength  = 0;
BOOLEAN fSummaryOnly  = FALSE;
BOOLEAN fDebugDisplay = FALSE;
BOOLEAN fRealTimeCircular = FALSE;
ULONG PointerSize = sizeof(PVOID) * 8;

// Global head for event layout linked list 
PLIST_ENTRY EventListHead = NULL;

// log files
PEVENT_TRACE_LOGFILE EvmFile[MAXLOGFILES];

ULONG LogFileCount = 0;
BOOL g_bUserMode = FALSE;
// cached Wbem pointer
IWbemServices *pWbemServices = NULL;

int __cdecl main (int argc, LPTSTR* argv)
/*++

Routine Description:

    It is the main function.

Arguments:
Usage: tracedmp [options]  <EtlFile1 EtlFile2 ...>| [-h | -? | -help]
        -o <file>          Output CSV file
        -rt [LoggerName]   Realtime tracedmp from the logger [LoggerName]
        -summary           Summary.txt only
        -begin HH:MM DD/MM/YY
        -end   HH:MM DD/MM/YY
        -h
        -help
        -?                 Display usage information

Return Value:

    Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS (== 0).

--*/
{
    TCHAR DumpFileName[MAXSTR];
    TCHAR SummaryFileName[MAXSTR];

    LPTSTR *targv;
    FILETIME ftStart;
    FILETIME ftEnd;
    SYSTEMTIME st;

#ifdef UNICODE
    LPTSTR *cmdargv;
#endif

    PEVENT_TRACE_LOGFILE pLogFile;
    ULONG Status = ERROR_SUCCESS;
    ULONG i, j;
    TRACEHANDLE HandleArray[MAXLOGFILES];

#ifdef UNICODE
    if ((cmdargv = CommandLineToArgvW(
                        GetCommandLineW(),  // pointer to a command-line string
                        &argc               // receives the argument count
                        )) == NULL)
    {
        return(GetLastError());
    };
    targv = cmdargv ;
#else
    targv = argv;
#endif

    RtlZeroMemory( &ftStart, sizeof(FILETIME) );
    RtlZeroMemory( &ftEnd, sizeof(FILETIME) );

    _tcscpy(DumpFileName, DUMP_FILE_NAME);
    _tcscpy(SummaryFileName, SUMMARY_FILE_NAME);

    while (--argc > 0) {
        ++targv;
        if (**targv == '-' || **targv == '/') {  // argument found
            if( **targv == '/' ){
                **targv = '-';
            }
            if ( !_tcsicmp(targv[0], _T("-begin") )) {
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        TCHAR buffer[MAXSTR];
                        _tcscpy( buffer, targv[1] );
                        _tcscat( buffer, _T(" ") );
                        ++targv; --argc;
                        if (targv[1][0] != '-' && targv[1][0] != '/'){
                            _tcscat( buffer, targv[1] );
                            ParseTime( buffer, &st );
                            SystemTimeToFileTime( &st, &ftStart );
                            ++targv; --argc;
                        }
                    }
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-end")) ) {
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        TCHAR buffer[MAXSTR];
                        _tcscpy( buffer, targv[1] );
                        _tcscat( buffer, _T(" ") );
                        ++targv; --argc;
                        if (targv[1][0] != '-' && targv[1][0] != '/'){
                            _tcscat( buffer, targv[1] );
                            ParseTime( buffer, &st );
                            SystemTimeToFileTime( &st, &ftEnd );
                            ++targv; --argc;
                        }
                    }
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-summary")) ) {
                fSummaryOnly = TRUE;
            }
            else if ( !_tcsicmp(targv[0], _T("-debug")) ) {
                fDebugDisplay = TRUE;
            }
            else if ( !_tcsicmp(targv[0], _T("-RealTimeCircular")) ) {
                fRealTimeCircular = TRUE;
            }
            else if (targv[0][1] == 'h' || targv[0][1] == 'H'
                                       || targv[0][1] == '?')
            {
                PrintHelpMessage();
                return 0;
            }
            else if ( !_tcsicmp(targv[0], _T("-rt")) ) {
                TCHAR LoggerName[MAXSTR];
                _tcscpy(LoggerName, KERNEL_LOGGER_NAME);
                if (argc > 1) {
                   if (targv[1][0] != '-' && targv[1][0] != '/') {
                       ++targv; --argc;
                       _tcscpy(LoggerName, targv[0]);
                   }
                }
               
                pLogFile = (PEVENT_TRACE_LOGFILE) malloc(sizeof(EVENT_TRACE_LOGFILE));
                if (pLogFile == NULL){
                    _tprintf(_T("Allocation Failure\n"));
                    Status = ERROR_OUTOFMEMORY;
                    goto cleanup;
                }
                RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
                EvmFile[LogFileCount] = pLogFile;
               
                EvmFile[LogFileCount]->LogFileName = NULL;
                EvmFile[LogFileCount]->LoggerName =
                    (LPTSTR) malloc(MAXSTR*sizeof(TCHAR));
               
                if ( EvmFile[LogFileCount]->LoggerName == NULL ) {
                    _tprintf(_T("Allocation Failure\n"));
                    Status = ERROR_OUTOFMEMORY;
                    goto cleanup;
                }
                _tcscpy(EvmFile[LogFileCount]->LoggerName, LoggerName);
               
                _tprintf(_T("Setting RealTime mode for  %s\n"),
                        EvmFile[LogFileCount]->LoggerName);
               
                EvmFile[LogFileCount]->Context = NULL;
                EvmFile[LogFileCount]->BufferCallback = BufferCallback;
                EvmFile[LogFileCount]->BuffersRead = 0;
                EvmFile[LogFileCount]->CurrentTime = 0;
                EvmFile[LogFileCount]->EventCallback = &DumpEvent;
                EvmFile[LogFileCount]->LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
                LogFileCount++;
            }
            else if ( !_tcsicmp(targv[0], _T("-o")) ) {
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        TCHAR drive[10];
                        TCHAR path[MAXSTR];
                        TCHAR file[MAXSTR];
                        TCHAR ext[MAXSTR];
                        ++targv; --argc;

                        _tfullpath(DumpFileName, targv[0], MAXSTR);
                        _tsplitpath( DumpFileName, drive, path, file, ext );
                        _tcscpy(ext,_T("csv"));
                        _tmakepath( DumpFileName, drive, path, file, ext );
                        _tcscpy(ext,_T("txt"));  
                        _tmakepath( SummaryFileName, drive, path, file, ext );
                    }
                }
            }
        }
        else {
            pLogFile = (PEVENT_TRACE_LOGFILE) malloc(sizeof(EVENT_TRACE_LOGFILE));
            if (pLogFile == NULL){ 
                _tprintf(_T("Allocation Failure\n"));
                Status = ERROR_OUTOFMEMORY;
                goto cleanup;
            }
            RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
            EvmFile[LogFileCount] = pLogFile;

            EvmFile[LogFileCount]->LoggerName = NULL;
            EvmFile[LogFileCount]->LogFileName = 
                (LPTSTR) malloc(MAXSTR*sizeof(TCHAR));
            if (EvmFile[LogFileCount]->LogFileName == NULL) {
                _tprintf(_T("Allocation Failure\n"));
                Status = ERROR_OUTOFMEMORY;
                goto cleanup;
            }
            
            _tfullpath(EvmFile[LogFileCount]->LogFileName, targv[0], MAXSTR);
            _tprintf(_T("Setting log file to: %s\n"),
                     EvmFile[LogFileCount]->LogFileName);
            // If one of the log files is not readable, exit.
            if (!CheckFile(EvmFile[LogFileCount]->LogFileName)) {
                _tprintf(_T("Cannot open logfile for reading\n"));
                Status = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            EvmFile[LogFileCount]->Context = NULL;
            EvmFile[LogFileCount]->BufferCallback = BufferCallback;
            EvmFile[LogFileCount]->BuffersRead = 0;
            EvmFile[LogFileCount]->CurrentTime = 0;
            EvmFile[LogFileCount]->EventCallback = &DumpEvent;
            LogFileCount++;
        }
    }

    if (LogFileCount <= 0) {
        PrintHelpMessage();
        return Status;
    }

    for (i = 0; i < LogFileCount; i++) {
        TRACEHANDLE x;

        if (fRealTimeCircular)
            EvmFile[i]->LogfileHeader.ReservedFlags |= 0x00000004;
        x = OpenTrace(EvmFile[i]);
        HandleArray[i] = x;
        if (HandleArray[i] == 0) {
            Status = GetLastError();
            _tprintf(_T("Error Opening Trace %d with status=%d\n"), 
                                                           i, Status);

            for (j = 0; j < i; j++)
                CloseTrace(HandleArray[j]);
            goto cleanup;
        }
    }

    if (!fSummaryOnly)
    {
        DumpFile = _tfopen(DumpFileName, _T("w"));
        if (DumpFile == NULL) {
            Status = ERROR_INVALID_PARAMETER;
            _tprintf(_T("DumpFile is NULL\n"));
            goto cleanup;
        }
    }
    SummaryFile = _tfopen(SummaryFileName, _T("w"));
    if (SummaryFile == NULL) {
        Status = ERROR_INVALID_PARAMETER;
        _tprintf(_T("SummaryFile is NULL\n"));
        goto cleanup;
    }

    if (!fSummaryOnly)
    {
        _ftprintf(DumpFile,
            _T("%12s, %10s,%7s,%21s,%11s,%11s, User Data\n"),
            _T("Event Name"), _T("Type"), _T("TID"), _T("Clock-Time"),
            _T("Kernel(ms)"), _T("User(ms)")
            );
    }

    Status = ProcessTrace(
            HandleArray,
            LogFileCount,
            &ftStart,
            &ftEnd
            );

    if (Status != ERROR_SUCCESS) {
        _tprintf(_T("Error processing with status=%dL (GetLastError=0x%x)\n"),
                Status, GetLastError());
    }

    for (j = 0; j < LogFileCount; j++){
        Status = CloseTrace(HandleArray[j]);
        if (Status != ERROR_SUCCESS) {
            _tprintf(_T("Error Closing Trace %d with status=%d\n"), j, Status);
        }
    }

    _ftprintf(SummaryFile,_T("Files Processed:\n"));
    for (i=0; i<LogFileCount; i++) {
        _ftprintf(SummaryFile,_T("\t%s\n"),EvmFile[i]->LogFileName);
    }

    ElapseTime = EndTime - StartTime;
    _ftprintf(SummaryFile,
              _T("Total Buffers Processed %d\n")
              _T("Total Events  Processed %d\n")
              _T("Total Events  Lost      %d\n")
              _T("Start Time              0x%016I64X\n")
              _T("End Time                0x%016I64X\n")
              _T("Elapsed Time            %I64d sec\n"), 
              TotalBuffersRead,
              TotalEventCount,
              TotalEventsLost,
              StartTime,
              EndTime,
              (ElapseTime / 10000000) );

    _ftprintf(SummaryFile,
       _T("+-------------------------------------------------------------------------------------+\n")
       _T("|%10s    %-20s %-10s  %-36s  |\n")
       _T("+-------------------------------------------------------------------------------------+\n"),
       _T("EventCount"),
       _T("EventName"),
       _T("EventType"),
       _T("Guid")
        );

    CleanupEventList();

    _ftprintf(SummaryFile,
           _T("+-------------------------------------------------------------------------------------+\n")
        );

cleanup:
    if (!fSummaryOnly && DumpFile != NULL)  {
        _tprintf(_T("Event traces dumped to %s\n"), DumpFileName);
        fclose(DumpFile);
    }

    if(SummaryFile != NULL){
        _tprintf(_T("Event Summary dumped to %s\n"), SummaryFileName);
        fclose(SummaryFile);
    }

    for (i = 0; i < LogFileCount; i ++)
    {
        if (EvmFile[i]->LoggerName != NULL)
        {
            free(EvmFile[i]->LoggerName);
            EvmFile[i]->LoggerName = NULL;
        }
        if (EvmFile[i]->LogFileName != NULL)
        {
            free(EvmFile[i]->LogFileName);
            EvmFile[i]->LogFileName = NULL;
        }
        free(EvmFile[i]);
    }
#ifdef UNICODE
    GlobalFree(cmdargv);
#endif

    SetLastError(Status);
    if(Status != ERROR_SUCCESS ){
        _tprintf(_T("Exit Status: %d\n"), Status);
    }

    if (MofData != NULL)
        free(MofData);

    return Status;
}

HRESULT 
ParseTime( 
    LPTSTR strTime, 
    SYSTEMTIME* pstTime 
)
/*++

Routine Description:

    Parse time given in a string into SYSTEMTIME.

Arguments:

    strTime - String that shows time.
    pstTime - Struct to contain the parsed time information. 

Return Value:

    Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS (== 0).

--*/
{
    TCHAR buffer[MAXSTR];
    LPTSTR str, str2;
    ZeroMemory( pstTime, sizeof( SYSTEMTIME ) );

    if( pstTime == NULL ){
        return ERROR_BAD_ARGUMENTS;
    }

    _tcscpy( buffer, strTime );
    str = _tcstok( buffer, _T(" \n\t") );
    str2 = _tcstok( NULL, _T(" \n\t") );
    while( str ){
        if( _tcsstr( str, _T(":") ) ){
            LPTSTR strHour = _tcstok( str, _T(":") );
            LPTSTR strMinute = _tcstok( NULL, _T(":") );

            if( NULL != strHour ){
                pstTime->wHour = (USHORT)_ttoi( strHour );
            }
            if( NULL != strMinute ){
                pstTime->wMinute = (USHORT)_ttoi( strMinute );
            }
        }
        if( _tcsstr( str, _T("/") ) || _tcsstr( str, _T("\\") ) ){
            LPTSTR strMonth = _tcstok( str, _T("/\\") );
            LPTSTR strDay = _tcstok( NULL, _T("/\\") );
            LPTSTR strYear = _tcstok( NULL, _T("/\\") );

            if( NULL != strMonth ){
                pstTime->wMonth = (USHORT)_ttoi( strMonth );
            }
            if( NULL != strDay ){
                pstTime->wDay = (USHORT)_ttoi( strDay );
            }
            if( NULL != strYear ){
                pstTime->wYear = (USHORT)_ttoi( strYear );
            }
        }
        str = str2;
        str2 = NULL;
    }

    return ERROR_SUCCESS;
}


ULONG
WINAPI
BufferCallback(
    PEVENT_TRACE_LOGFILE pLog
    )
/*++

Routine Description:

    Callback method for processing a buffer. Does not do anything but
    updating global counters.

Arguments:

    pLog - Pointer to a log file.

Return Value:

    Always TRUE.

--*/
{
    TotalBuffersRead++;
    TotalEventsLost += pLog->EventsLost;
    return (TRUE);
}

void
WINAPI
DumpEvent(
    PEVENT_TRACE pEvent
)
/*++

Routine Description:

    Callback method for processing an event. It obtains the layout
    information by calling GetMofInfoHead(), which returns the pointer
    to the PMOF_INFO corresponding to the event type. Then it writes
    to the output file.

    NOTE: Only character arrays are supported in this program.

Arguments:

    pEvent - Pointer to an event.

Return Value:

    None.

--*/
{
    PEVENT_TRACE_HEADER pHeader;
    ULONG   i;
    PITEM_DESC pItem;
    char str[MOFSTR];
    WCHAR wstr[MOFWSTR];
    PCHAR ptr;
    ULONG ulongword;
    LONG  longword;
    USHORT ushortword;
    SHORT  shortword;
    PMOF_INFO pMofInfo;
    PLIST_ENTRY Head, Next;
    char iChar;
    WCHAR iwChar;
    ULONG MofDataUsed;

    TotalEventCount++;

    if (pEvent == NULL) {
        _tprintf(_T("Warning: Null Event\n"));
        return;
    }

    pHeader = (PEVENT_TRACE_HEADER) &pEvent->Header;

    if( IsEqualGUID(&(pEvent->Header.Guid), &EventTraceGuid) && 
        pEvent->Header.Class.Type == EVENT_TRACE_TYPE_INFO ) {

        PTRACE_LOGFILE_HEADER head = (PTRACE_LOGFILE_HEADER)pEvent->MofData;
        if( NULL != head ){
            g_bUserMode = (head->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE);
 
            if(head->TimerResolution > 0){
                TimerResolution = head->TimerResolution / 10000;
            }
        
            StartTime  = head->StartTime.QuadPart;
            EndTime    = head->EndTime.QuadPart;
            fNoEndTime = (EndTime == 0);

            PointerSize =  head->PointerSize * 8;
            // Set pointer size
            if (PointerSize < 16){       // minimum is 16 bits
                PointerSize = 32;        // default is 32 bits
            }
        }
    }

    if (fNoEndTime && EndTime < (ULONGLONG) pHeader->TimeStamp.QuadPart) {
        EndTime = pHeader->TimeStamp.QuadPart;
    }

    if (MofData == NULL) {
        MofLength = pEvent->MofLength + sizeof(UNICODE_NULL);
        MofData = (PCHAR) malloc(MofLength);
    }
    else if ((pEvent->MofLength + sizeof(UNICODE_NULL)) > MofLength) {
        MofLength = pEvent->MofLength + sizeof(UNICODE_NULL);
        MofData = (PCHAR) realloc(MofData, MofLength);
    }

    if (MofData == NULL) {
        _tprintf(_T("Allocation Failure\n"));
        return;
    }

    if (NULL == pEvent->MofData && pEvent->MofLength != 0) {
        _tprintf(_T("Incorrect MOF size\n"));
        return;
    }

    if (NULL != (pEvent->MofData)) {
        memcpy(MofData, pEvent->MofData, pEvent->MofLength);
    }

    MofData[pEvent->MofLength] = 0;
    MofData[pEvent->MofLength+1] = 0;
    ptr = MofData;
    MofDataUsed = 0;
    // Find the MOF information for this event
    pMofInfo = GetMofInfoHead ( 
            pEvent->Header.Guid, 
            pEvent->Header.Class.Type, 
            pEvent->Header.Class.Version, 
            pEvent->Header.Class.Level 
        );
    
    if( NULL == pMofInfo ){
        return;
    }

    pMofInfo->EventCount++;

    if( fSummaryOnly == TRUE ){
        return;
    }

    if( pMofInfo->strDescription != NULL ){
        _ftprintf( DumpFile, _T("%12s, "), pMofInfo->strDescription );
    }else{
        TCHAR strGuid[MAXSTR];
        GuidToString( strGuid, &pMofInfo->Guid );
        _ftprintf( DumpFile, _T("%12s, "), strGuid );
    }

    if(pMofInfo->strType != NULL && _tcslen(pMofInfo->strType) ){
        _ftprintf( DumpFile, _T("%10s, "), pMofInfo->strType );
    }else{
        _ftprintf( DumpFile, _T("%10d, "), pEvent->Header.Class.Type );
    }

    // Thread ID
    _ftprintf( DumpFile, _T("0x%04X, "), pHeader->ThreadId );
    
    // System Time
    _ftprintf( DumpFile, _T("%20I64u, "), pHeader->TimeStamp.QuadPart);

    if( g_bUserMode == FALSE ){
        // Kernel Time
        _ftprintf(DumpFile, _T("%10lu, "), pHeader->KernelTime * TimerResolution);

        // User Time
        _ftprintf(DumpFile, _T("%10lu, "), pHeader->UserTime * TimerResolution);
    }else{
        // processor Time
        _ftprintf(DumpFile, _T("%I64u, "), pHeader->ProcessorTime);
    }

    Head = pMofInfo->ItemHeader;
    Next = Head->Flink;

    if ((Head == Next) && (pEvent->MofLength > 0)) {
         _ftprintf(DumpFile, _T("DataSize=%d, "), pEvent->MofLength);
    }

    while (Head != Next) {
        pItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        Next = Next->Flink;

        MofDataUsed = (ULONG) (ptr - MofData);
        
        if (MofDataUsed >= pEvent->MofLength){
            break;
        }

        switch (pItem->ItemType)
        {
        case ItemChar:
        case ItemUChar:
            for( i=0;i<pItem->ArraySize;i++){
                iChar = *((PCHAR) ptr);
                _ftprintf(DumpFile,   _T("%c"), iChar);
                ptr += sizeof(CHAR);
            }
            _ftprintf(DumpFile, _T(", "));
            break;

        case ItemWChar:
            for(i=0;i<pItem->ArraySize;i++){
                iwChar = *((PWCHAR) ptr);
                _ftprintf(DumpFile, _T(",%wc"), iwChar);
                ptr += sizeof(WCHAR);
            }
            _ftprintf(DumpFile, _T(", "));
            break;

        case ItemCharShort:
            iChar = *((PCHAR) ptr);
            _ftprintf(DumpFile, _T("%d, "), iChar);
            ptr += sizeof(CHAR);
            break;

        case ItemShort:
            shortword = * ((PSHORT) ptr);
            _ftprintf(DumpFile, _T("%6d, "), shortword);
            ptr += sizeof (SHORT);
            break;

        case ItemUShort:
            ushortword = *((PUSHORT) ptr);
            _ftprintf(DumpFile, _T("%6u, "), ushortword);
            ptr += sizeof (USHORT);
            break;

        case ItemLong:
            longword = *((PLONG) ptr);
            _ftprintf(DumpFile, _T("%8d, "), longword);
            ptr += sizeof (LONG);
            break;

        case ItemULong:
            ulongword = *((PULONG) ptr);
            _ftprintf(DumpFile, _T("%8lu, "), ulongword);
            ptr += sizeof (ULONG);
            break;

        case ItemULongX:
            ulongword = *((PULONG) ptr);
            _ftprintf(DumpFile, _T("0x%08X, "), ulongword);
            ptr += sizeof (ULONG);
            break;

        case ItemLongLong:
        {
            LONGLONG n64;
            n64 = *((LONGLONG*) ptr);
            ptr += sizeof(LONGLONG);
            _ftprintf(DumpFile, _T("%16I64d, "), n64);
            break;
        }

        case ItemULongLong:
        {
            ULONGLONG n64;
            n64 = *((ULONGLONG*) ptr);
            ptr += sizeof(ULONGLONG);
            _ftprintf(DumpFile, _T("%16I64u, "), n64);
            break;
        }

        case ItemFloat:
        {
            float f32;
            f32 = *((float*) ptr);
            ptr += sizeof(float);
            _ftprintf(DumpFile, _T("%f, "), f32);
            break;
        }

        case ItemDouble:
        {
            double f64;
            f64 = *((double*) ptr);
            ptr += sizeof(double);
            _ftprintf(DumpFile, _T("%f, "), f64);
            break;
        }

        case ItemPtr :
        {
            unsigned __int64 pointer;
            if (PointerSize == 64) {
                pointer = *((unsigned __int64 *) ptr);
                _ftprintf(DumpFile, _T("0x%X, "), pointer);
            }
            else {      // assumes 32 bit otherwise
                ulongword = *((PULONG) ptr);
                _ftprintf(DumpFile, _T("0x%08X, "), ulongword);
            }
            ptr += PointerSize / 8;
            //
            // If target source is Win64, then use Ptr, else use ulongword
            //
            break;
        }

        case ItemIPAddr:
        {
            ulongword = *((PULONG) ptr);

            // Convert it to readable form
            _ftprintf(DumpFile, _T("%03d.%03d.%03d.%03d, "),
                    (ulongword >>  0) & 0xff,
                    (ulongword >>  8) & 0xff,
                    (ulongword >> 16) & 0xff,
                    (ulongword >> 24) & 0xff);
            ptr += sizeof (ULONG);
            break;
        }

        case ItemPort:
        {
            _ftprintf(DumpFile, _T("%u, "), NTOHS((USHORT) *ptr));
            ptr += sizeof (USHORT);
            break;
        }

        case ItemString:
        {
            USHORT pLen = (USHORT)strlen((CHAR*) ptr);

            if (pLen > 0)
            {
                strcpy(str, ptr);
                for (i=pLen-1; i>0; i--) {
                    if (str[i] == 0xFF)
                        str[i] = 0;
                    else break;
                }
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                _ftprintf(DumpFile, _T("\"%ws\","), wstr);
#else
                _ftprintf(DumpFile, _T("\"%s\","), str);
#endif
            }
            ptr += (pLen + 1);
            break;
        }

        case ItemWString:
        {
            size_t  pLen = 0;
            size_t     i;

            if (*(WCHAR *) ptr)
            {
                pLen = ((wcslen((WCHAR*)ptr) + 1) * sizeof(WCHAR));
                memcpy(wstr, ptr, pLen);
                for (i = (pLen/2)-1; i > 0; i--)
                {
                    if (((USHORT) wstr[i] == (USHORT) 0xFFFF))
                    {
                        wstr[i] = (USHORT) 0;
                    }
                    else break;
                }

                wstr[pLen / 2] = wstr[(pLen / 2) + 1]= '\0';
                _ftprintf(DumpFile, _T("\"%ws\","), wstr);
            }
            ptr += pLen;

            break;
        }

        case ItemDSString:   // Counted String
        {
            USHORT pLen = (USHORT)(256 * ((USHORT) * ptr) + ((USHORT) * (ptr + 1)));
            ptr += sizeof(USHORT);
            if (pLen > (pEvent->MofLength - MofDataUsed - 1)) {
                pLen = (USHORT) (pEvent->MofLength - MofDataUsed - 1);
            }
            if (pLen > 0)
            {
                strcpy(str, ptr);
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                fwprintf(DumpFile, _T("\"%ws\","), wstr);
#else
                fprintf(DumpFile, _T("\"%s\","), str);
#endif
            }
            ptr += (pLen + 1);
            break;
        }

        case ItemPString:   // Counted String
        {
            USHORT pLen = * ((USHORT *) ptr);
            ptr += sizeof(USHORT);

            if (pLen > (pEvent->MofLength - MofDataUsed)) {
                pLen = (USHORT) (pEvent->MofLength - MofDataUsed);
            }

            if (pLen > MOFSTR * sizeof(CHAR)) {
                pLen = MOFSTR * sizeof(CHAR);
            }
            if (pLen > 0) {
                memcpy(str, ptr, pLen);
                str[pLen] = '\0';
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                _ftprintf(DumpFile, _T("\"%ws\","), wstr);
#else
                _ftprintf(DumpFile, _T("\"%s\","), str);
#endif
            }
            ptr += pLen;
            break;
        }

        case ItemDSWString:  // DS Counted Wide Strings
        case ItemPWString:   // Counted Wide Strings
        {
            USHORT pLen = (USHORT)(( pItem->ItemType == ItemDSWString)
                        ? (256 * ((USHORT) * ptr) + ((USHORT) * (ptr + 1)))
                        : (* ((USHORT *) ptr)));

            ptr += sizeof(USHORT);
            if (pLen > (pEvent->MofLength - MofDataUsed)) {
                pLen = (USHORT) (pEvent->MofLength - MofDataUsed);
            }

            if (pLen > MOFWSTR * sizeof(WCHAR)) {
                pLen = MOFWSTR * sizeof(WCHAR);
            }
            if (pLen > 0) {
                memcpy(wstr, ptr, pLen);
                wstr[pLen / sizeof(WCHAR)] = L'\0';
                _ftprintf(DumpFile, _T("\"%ws\","), wstr);
            }
            ptr += pLen;
            break;
        }

        case ItemNWString:   // Non Null Terminated String
        {
           USHORT Size;

           Size = (USHORT)(pEvent->MofLength - (ULONG)(ptr - MofData));
           if( Size > MOFSTR )
           {
               Size = MOFSTR;
           }
           if (Size > 0)
           {
               memcpy(wstr, ptr, Size);
               wstr[Size / 2] = '\0';
               _ftprintf(DumpFile, _T("\"%ws\","), wstr);
           }
           ptr += Size;
           break;
        }

        case ItemMLString:  // Multi Line String
        {
            USHORT   pLen;
            char   * src, * dest;
            BOOL     inQ       = FALSE;
            BOOL     skip      = FALSE;
            UINT     lineCount = 0;

            ptr += sizeof(UCHAR) * 2;
            pLen = (USHORT)strlen(ptr);
            if (pLen > 0)
            {
                src = ptr;
                dest = str;
                while (* src != '\0'){
                    if (* src == '\n'){
                        if (!lineCount){
                            * dest++ = ' ';
                        }
                        lineCount++;
                    }else if (* src == '\"'){ 
                        if (inQ){
                            char   strCount[32];
                            char * cpy;

                            sprintf(strCount, "{%dx}", lineCount);
                            cpy = & strCount[0];
                            while (* cpy != '\0'){
                                * dest ++ = * cpy ++;
                            }
                        }
                        inQ = !inQ;
                    }else if (!skip){
                        *dest++ = *src;
                    }
                    skip = (lineCount > 1 && inQ);
                    src++;
                }
                *dest = '\0';
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                _ftprintf(DumpFile, _T("\"%ws\","), wstr);
#else
                _ftprintf(DumpFile, _T("\"%s\","), str);
#endif
            }
            ptr += (pLen);
            break;
        }

        case ItemSid:
        {
            TCHAR        UserName[64];
            TCHAR        Domain[64];
            TCHAR        FullName[256];
            ULONG        asize = 0;
            ULONG        bsize = 0;
            ULONG        Sid[64];
            PULONG       pSid  = & Sid[0];
            SID_NAME_USE Se;
            ULONG        nSidLength;

            pSid = (PULONG) ptr;
            if (*pSid == 0){
                ptr += 4;
                _ftprintf(DumpFile, _T("%4d, "), *pSid);
            }
            else
            {
                ptr += 8;           // skip the TOKEN_USER structure
                nSidLength = 8 + (4*ptr[1]);

                asize = 64;
                bsize = 64;
                if (LookupAccountSid(
                                NULL,
                               (PSID) ptr,
                               (LPTSTR) & UserName[0],
                               & asize,
                               (LPTSTR) & Domain[0],
                               & bsize,
                               & Se))
                {
                    LPTSTR pFullName = &FullName[0];
                    _stprintf( pFullName,_T("\\\\%s\\%s"), Domain, UserName);
                    asize = (ULONG) _tcslen(pFullName);
                    if (asize > 0){
                        _ftprintf(DumpFile, _T("\"%s\", "), pFullName);
                    }
                }
                else
                {
                    _ftprintf(DumpFile, _T("\"System\", "));
                }
                SetLastError( ERROR_SUCCESS );
                ptr += nSidLength;
            }
            break;
        }

        case ItemGuid:
        {
            TCHAR s[64];
            GuidToString(s, (LPGUID)ptr);
            _ftprintf(DumpFile,   _T("%s, "), s);
            ptr += sizeof(GUID);
            break;
        }
        case ItemBool:
        {
            BOOL Flag = (BOOL)*ptr;
            _ftprintf(DumpFile, _T("%5s, "), (Flag) ? _T("TRUE") : _T("FALSE"));
            ptr += sizeof(BOOL);
            break;
        }

        default:
            ptr += sizeof (int);
        }
    }

    //Instance ID
    _ftprintf(DumpFile, _T("%d,"), pEvent->InstanceId);

    //Parent Instance ID
    _ftprintf(DumpFile, _T("%d\n"), pEvent->ParentInstanceId);
}

ULONG
CheckFile(
    LPTSTR fileName
)
/*++

Routine Description:

    Checks whether a file exists and is readable.

Arguments:

    fileName - File name.

Return Value:

    Non-zero if the file exists and is readable. Zero otherwise.

--*/
{
    HANDLE hFile;
    ULONG Status;

    hFile = CreateFile(
                fileName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
    Status = (hFile != INVALID_HANDLE_VALUE);
    CloseHandle(hFile);
    return Status;
}

PMOF_INFO
GetMofInfoHead(
    GUID    Guid,
    SHORT   nType,
    SHORT   nVersion,
    CHAR    nLevel
    )
/*++

Routine Description:

    Find a matching event layout in the global linked list. If it
    is not found in the list, it calls GetGuids() to examine the WBEM
    namespace.
    If the global list is empty, it first creates a header.

Arguments:

    Guid - GUID for the event under consideration.
    nType - Event Type
    nVersion - Event Version
    nLevel - Event Level (not supported in this program)

Return Value:

    Pointer to MOF_INFO for the current event. If the layout
    information is not found anywhere, GetMofInfoHead() creates
    a dummy and returns it.

--*/
{
    PLIST_ENTRY Head, Next;
    PMOF_INFO pMofInfo;
    PMOF_INFO pBestMatch = NULL;
    SHORT nMatchLevel = 0;
    SHORT nMatchCheck;

    // Search the eventList for this Guid and find the head

    if (EventListHead == NULL) {
        // Initialize the MOF List and add the global header guid to it
        EventListHead = (PLIST_ENTRY) malloc(sizeof(LIST_ENTRY));
        if (EventListHead == NULL)
            return NULL;
        InitializeListHead(EventListHead);

        pMofInfo = GetNewMofInfo( EventTraceGuid, EVENT_TYPE_DEFAULT, 0, 0 );
        if( pMofInfo != NULL ){
            InsertTailList( EventListHead, &pMofInfo->Entry );
            pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(GUID_TYPE_EVENTTRACE)+1)*sizeof(TCHAR));
            if( pMofInfo->strDescription != NULL ){
                _tcscpy( pMofInfo->strDescription, GUID_TYPE_EVENTTRACE );
            }
            pMofInfo->strType = (LPTSTR)malloc((_tcslen(GUID_TYPE_HEADER)+1)*sizeof(TCHAR));
            if( pMofInfo->strType != NULL ){
                _tcscpy( pMofInfo->strType, GUID_TYPE_HEADER );
            }
        }
    }

    // Traverse the list and look for the Mof info head for this Guid. 

    Head = EventListHead;
    Next = Head->Flink;

    while (Head != Next) {

        nMatchCheck = 0;

        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Next = Next->Flink;
        
        if( IsEqualGUID(&pMofInfo->Guid, &Guid) ){

            if( pMofInfo->TypeIndex == nType ){
                nMatchCheck++;
            }
            if( pMofInfo->Version == nVersion ){
                nMatchCheck++;
            }
            if( nMatchCheck == 2 ){ // Exact Match
                return  pMofInfo;
            }

            if( nMatchCheck > nMatchLevel ){ // Close Match
                nMatchLevel = nMatchCheck;
                pBestMatch = pMofInfo;
            }

            if( pMofInfo->TypeIndex == EVENT_TYPE_DEFAULT && // Total Guess
                pBestMatch == NULL ){
                pBestMatch = pMofInfo;
            }
        }

    } 

    if(pBestMatch != NULL){
        return pBestMatch;
    }

    // If one does not exist in the list, look it up in the file. 
    pMofInfo = GetGuids( Guid, nVersion, nLevel, nType );
    
    // If still not found, create a unknown place holder
    if( NULL == pMofInfo ){
        pMofInfo = GetNewMofInfo( Guid, nType, nVersion, nLevel );
        if( pMofInfo != NULL ){
            pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(GUID_TYPE_UNKNOWN)+1)*sizeof(TCHAR));
            if( pMofInfo->strDescription != NULL ){
                _tcscpy( pMofInfo->strDescription, GUID_TYPE_UNKNOWN );
            }
            InsertTailList( EventListHead, &pMofInfo->Entry );
        }
    }

    return pMofInfo;
}

void
RemoveMofInfo(
    PLIST_ENTRY pMofInfo
)
/*++

Routine Description:

    Removes and frees data item structs from a given list.

Arguments:

    pMofInfo - Pointer to the MOF_INFO to be purged of data item structs.

Return Value:

    None.

--*/
{
    PLIST_ENTRY Head, Next;
    PITEM_DESC pItem;

    Head = pMofInfo;
    Next = Head->Flink;
    while (Head != Next) {
        pItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        Next = Next->Flink;
        RemoveEntryList(&pItem->Entry);
        free(pItem);
    } 
}

void
CleanupEventList(
    VOID
)
/*++

Routine Description:

    Cleans up a global event list.

Arguments:

Return Value:

    None.

--*/
{
    PLIST_ENTRY Head, Next;
    PMOF_INFO pMofInfo;
    TCHAR s[256];
    TCHAR wstr[256];
    PTCHAR str;

    if (EventListHead == NULL) {
        return;
    }

    Head = EventListHead;
    Next = Head->Flink;
    while (Head != Next) {
        RtlZeroMemory(&wstr, 256);

        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);

        if (pMofInfo->EventCount > 0) {
            GuidToString(&s[0], &pMofInfo->Guid);
            str = s;
            if( pMofInfo->strDescription != NULL ){
                _tcscpy( wstr, pMofInfo->strDescription );
            }
            
            _ftprintf(SummaryFile,_T("|%10d    %-20s %-10s  %36s|\n"),
                      pMofInfo->EventCount, 
                      wstr, 
                      pMofInfo->strType ? pMofInfo->strType : GUID_TYPE_DEFAULT, 
                      str);
        }

        RemoveEntryList(&pMofInfo->Entry);
        RemoveMofInfo(pMofInfo->ItemHeader);
        free(pMofInfo->ItemHeader);

        if (pMofInfo->strDescription != NULL)
            free(pMofInfo->strDescription);
        if (pMofInfo->strType != NULL)
            free(pMofInfo->strType);

        Next = Next->Flink;
        free(pMofInfo);
    }

    free(EventListHead);
}

void
GuidToString(
    PTCHAR s,
    LPGUID piid
)
/*++

Routine Description:

    Converts a GUID into a string.

Arguments:

    s - String that will have the converted GUID.
    piid - GUID

Return Value:

    None.

--*/
{
    _stprintf(s, _T("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
               piid->Data1, piid->Data2,
               piid->Data3,
               piid->Data4[0], piid->Data4[1],
               piid->Data4[2], piid->Data4[3],
               piid->Data4[4], piid->Data4[5],
               piid->Data4[6], piid->Data4[7]);
    return;
}

void
AddMofInfo(
        PLIST_ENTRY List,
        LPTSTR  strType,
        ITEM_TYPE  nType,
        UINT   ArraySize
)
/*++

Routine Description:

    Creates a data item information struct (ITEM_DESC) and appends
    it to all MOF_INFOs in the given list.
    GetPropertiesFromWBEM() creates a list of MOF_INFOs for multiple
    types, stores them in a temporary list and calls this function for
    each data item information it encounters.

Arguments:

    List - List of MOF_INFOs.
    strType - Item description in string.
    nType - ITEM_TYPE defined at the beginning of this file.
    ArraySize - Size of array of this type of items, if applicable.

Return Value:

    None.

--*/
{
    PITEM_DESC pItem;
    PMOF_INFO pMofInfo;

    PLIST_ENTRY Head = List;
    PLIST_ENTRY Next = Head->Flink;
    while (Head != Next) {
        
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Next = Next->Flink;

        if( NULL != pMofInfo ){

            pItem = (PITEM_DESC) malloc(sizeof(ITEM_DESC));
            if( NULL == pItem ){
                return;
            }
            ZeroMemory( pItem, sizeof(ITEM_DESC) );            
            pItem->ItemType = nType;
            pItem->ArraySize = ArraySize;

            pItem->strDescription = (LPTSTR) malloc( (_tcslen(strType)+1)*sizeof(TCHAR));
            
            if( NULL == pItem->strDescription ){
                free( pItem );
                return;
            }
            _tcscpy(pItem->strDescription, strType);

            InsertTailList( (pMofInfo->ItemHeader), &pItem->Entry);
        }

    }
}


PMOF_INFO
GetNewMofInfo( 
    GUID guid, 
    SHORT nType, 
    SHORT nVersion, 
    CHAR nLevel 
)
/*++

Routine Description:

    Creates a new MOF_INFO with given data.

Arguments:

    guid - Event GUID.
    nType - Event type.
    nVersion - Event version.
    nLevel - Event level (not supported in this program).

Return Value:

    Pointer to the created MOF_INFO. NULL if malloc failed.

--*/
{
    PMOF_INFO pMofInfo;

    pMofInfo = (PMOF_INFO)malloc(sizeof(MOF_INFO));

    if( NULL == pMofInfo ){
        return NULL;
    }

    RtlZeroMemory(pMofInfo, sizeof(MOF_INFO));

    memcpy(&pMofInfo->Guid, &guid, sizeof(GUID) );
    
    pMofInfo->ItemHeader = (PLIST_ENTRY)malloc(sizeof(LIST_ENTRY));
    
    if( NULL == pMofInfo->ItemHeader ){
        free( pMofInfo );
        return NULL;
    }

    InitializeListHead(pMofInfo->ItemHeader);
    
    pMofInfo->TypeIndex = nType;
    pMofInfo->Level = nLevel;
    pMofInfo->Version = nVersion;

    return pMofInfo;
}

void
FlushMofList( 
    PLIST_ENTRY ListHead
)
/*++

Routine Description:

    Flushes MOF_INFOs in a temporary list into the global list.

Arguments:

    ListHead - Pointer to the head of a temporary list.

Return Value:

    None.

--*/
{
    PMOF_INFO pMofInfo;
    PLIST_ENTRY Head = ListHead;
    PLIST_ENTRY Next = Head->Flink;

    while( Head != Next ){
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Next = Next->Flink;
        
        RemoveEntryList(&pMofInfo->Entry);
        InsertTailList( EventListHead, &pMofInfo->Entry);
    }
}

HRESULT
WbemConnect( 
    IWbemServices** pWbemServices 
)
/*++

Routine Description:

    Connects to WBEM and returns a pointer to WbemServices.

Arguments:

    pWbemServices - Pointer to the connected WbemServices.

Return Value:

    ERROR_SUCCESS if successful. Error flag otherwise.

--*/
{
    IWbemLocator     *pLocator = NULL;

    BSTR bszNamespace = SysAllocString( L"root\\wmi" );

    HRESULT hr = CoInitialize(0);

    hr = CoCreateInstance(
                CLSID_WbemLocator, 
                0, 
                CLSCTX_INPROC_SERVER,
                IID_IWbemLocator, 
                (LPVOID *) &pLocator
            );
    if ( ERROR_SUCCESS != hr )
        goto cleanup;

    hr = pLocator->ConnectServer(
                bszNamespace,
                NULL, 
                NULL, 
                NULL, 
                0L,
                NULL,
                NULL,
                pWbemServices
            );
    if ( ERROR_SUCCESS != hr )
        goto cleanup;

    hr = CoSetProxyBlanket(
            *pWbemServices,
            RPC_C_AUTHN_WINNT,
            RPC_C_AUTHZ_NONE,
            NULL,
            RPC_C_AUTHN_LEVEL_PKT,
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, 
            EOAC_NONE
        );

cleanup:
    SysFreeString( bszNamespace );

    if( pLocator ){
        pLocator->Release(); 
        pLocator = NULL;
    }
    
    return hr;
}

ULONG GetArraySize(
    IN IWbemQualifierSet *pQualSet
)
/*++

Routine Description:

    Examines a given qualifier set and returns the array size.

    NOTE: WBEM stores the size of an array in "MAX" qualifier.

Arguments:

    pQualSet - Pointer to a qualifier set.

Return Value:

    The size of the array. The default is 1.

--*/
{
    ULONG ArraySize = 1;
    VARIANT pVal;
    BSTR bszMaxLen;
    HRESULT hRes;

    if (pQualSet == NULL){
        return ArraySize;
    }

    bszMaxLen = SysAllocString(L"MAX");
    VariantInit(&pVal);
    hRes = pQualSet->Get(bszMaxLen,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszMaxLen);
    if (ERROR_SUCCESS == hRes && pVal.vt == VT_I4 ){
        ArraySize = pVal.lVal;
    }
    VariantClear(&pVal);
    return ArraySize;
}

ITEM_TYPE
GetItemType(
    IN CIMTYPE_ENUMERATION CimType, 
    IN IWbemQualifierSet *pQualSet
)
/*++

Routine Description:

    Examines a given qualifier set for a property and returns the type.

Arguments:

    CimType - WBEM type (different from ITEM_TYPE) of a property.
    pQualSet - Pointer to a qualifier set for a property under consideration.

Return Value:

    The type (in ITEM_TYPE) of a property.

--*/
{
    ITEM_TYPE Type;
    VARIANT pVal;
    HRESULT hRes;
    BSTR bszQualName;
    WCHAR strFormat[10];
    WCHAR strTermination[30];
    WCHAR strTemp[30];
    BOOLEAN IsPointer = FALSE;

    strFormat[0] = '\0';
    strTermination[0] = '\0';
    strTemp[0] = '\0';

    if (pQualSet == NULL)
        return ItemUnknown;

    bszQualName = SysAllocString(L"format");
    VariantInit(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes && NULL != pVal.bstrVal)
        wcscpy(strFormat, pVal.bstrVal);

    bszQualName = SysAllocString(L"StringTermination");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes && NULL != pVal.bstrVal)
        wcscpy(strTermination, pVal.bstrVal);

    bszQualName = SysAllocString(L"pointer");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes)
        IsPointer = TRUE;
    // Major fix required to get rid of temp
    bszQualName = SysAllocString(L"extension");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes && NULL != pVal.bstrVal)
        wcscpy(strTemp, pVal.bstrVal);

    VariantClear(&pVal);

    CimType = (CIMTYPE_ENUMERATION)(CimType & (~CIM_FLAG_ARRAY));

    switch (CimType) {
        case CIM_EMPTY:
            Type = ItemUnknown;
            break;        
        case CIM_SINT8:
            Type = ItemCharShort;
            if (!_wcsicmp(strFormat, L"c")){
                Type = ItemChar;
            }
            break;
        case CIM_UINT8:
            Type = ItemUChar;
            break;
        case CIM_SINT16:
            Type = ItemShort;
            break;
        case CIM_UINT16:
            Type = ItemUShort;
            break;
        case CIM_SINT32:
            Type = ItemLong;
            break;
        case CIM_UINT32:
            Type = ItemULong;
            if (!_wcsicmp(strFormat, L"x")){
                Type = ItemULongX;
            }
            break;
        case CIM_SINT64: 
            Type = ItemLongLong;
            break;
        case CIM_UINT64:
            Type = ItemULongLong;
            break;
        case CIM_REAL32:
            Type = ItemFloat;
            break;
        case CIM_REAL64:
            Type = ItemDouble;
            break;
        case CIM_BOOLEAN:
            // ItemBool
            Type = ItemBool;
            break;
        case CIM_STRING:
            
            if (!_wcsicmp(strTermination, L"NullTerminated")) {
                if (!_wcsicmp(strFormat, L"w"))
                    Type = ItemWString;
                else
                    Type = ItemString;
            }
            else if (!_wcsicmp(strTermination, L"Counted")) {
                if (!_wcsicmp(strFormat, L"w"))
                    Type = ItemPWString;
                else
                    Type = ItemPString;
            }
            else if (!_wcsicmp(strTermination, L"ReverseCounted")) {
                if (!_wcsicmp(strFormat, L"w"))
                    Type = ItemDSWString;
                else
                    Type = ItemDSString;
            }
            else if (!_wcsicmp(strTermination, L"NotCounted")) {
                Type = ItemNWString;
            }else{
                Type = ItemString;
            }
            break;
        case CIM_CHAR16:
            // ItemWChar
            Type = ItemWChar;
            break;

        case CIM_OBJECT :
            if (!_wcsicmp(strTemp, L"Port"))
                Type = ItemPort;
            else if (!_wcsicmp(strTemp, L"IPAddr"))
                Type = ItemIPAddr;
            else if (!_wcsicmp(strTemp, L"Sid"))
                Type = ItemSid;
            else if (!_wcsicmp(strTemp, L"Guid"))
                Type = ItemGuid;
            break;

        case CIM_DATETIME:
        case CIM_REFERENCE:
        case CIM_ILLEGAL:
        default:
            Type = ItemUnknown;
            break;
    }

    if (IsPointer)
        Type = ItemPtr;
    return Type;
}

PMOF_INFO
GetPropertiesFromWBEM(
    IWbemClassObject *pTraceSubClasses, 
    GUID Guid,
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType
)
/*++

Routine Description:

    Constructs a linked list with the information read from the WBEM
    namespace, given the WBEM pointer to the version subtree. It enumerates
    through all type classes in WBEM, and constructs MOF_INFOs for all of
    them (for caching purpose). Meanwhile, it looks for the event layout
    that mathces the passed event, and returns the pointer to the matching 
    MOF_INFO at the end. 

Arguments:

    pTraceSubClasses - WBEM pointer to the version subtree.
    Guid - GUID of the passed event.
    nVersion - version of the passed event.
    nLevel - level of the passed event.
    nType - type of the passed event.

Return Value:

    Pointer to MOF_INFO corresponding to the passed event.
    If the right type is not found, it returns the pointer to
    the generic MOF_INFO for the event version.

--*/
{
    IEnumWbemClassObject    *pEnumTraceSubSubClasses = NULL;
    IWbemClassObject        *pTraceSubSubClasses = NULL; 
    IWbemQualifierSet       *pQualSet = NULL;

    PMOF_INFO pMofInfo = NULL, pMofLookup = NULL, pMofTemplate = NULL;

    BSTR bszClassName = NULL;
    BSTR bszSubClassName = NULL;
    BSTR bszWmiDataId = NULL;
    BSTR bszEventType = NULL; 
    BSTR bszEventTypeName = NULL; 
    BSTR bszFriendlyName = NULL;
    BSTR bszPropName = NULL;

    TCHAR strClassName[MAXSTR];
    TCHAR strType[MAXSTR];
#ifndef UNICODE
    CHAR TempString[MAXSTR];
#endif
    LONG pVarType;
    SHORT nEventType = EVENT_TYPE_DEFAULT; 

    LIST_ENTRY ListHead;
    HRESULT hRes;

    VARIANT pVal;
    VARIANT pTypeVal;
    VARIANT pTypeNameVal;
    VARIANT pClassName;
    ULONG lEventTypeWbem;
    ULONG HUGEP *pTypeData;
    BSTR HUGEP *pTypeNameData;

    SAFEARRAY *PropArray = NULL;
    SAFEARRAY *TypeArray = NULL;
    SAFEARRAY *TypeNameArray = NULL;

    long lLower, lUpper, lCount, IdIndex;
    long lTypeLower, lTypeUpper;
    long lTypeNameLower, lTypeNameUpper;

    ULONG ArraySize;

    ITEM_TYPE ItemType;

    InitializeListHead(&ListHead);

    VariantInit(&pVal);
    VariantInit(&pTypeVal);
    VariantInit(&pTypeNameVal);
    VariantInit(&pClassName);

    bszClassName = SysAllocString(L"__CLASS");
    bszWmiDataId = SysAllocString(L"WmiDataId");
    bszEventType = SysAllocString(L"EventType");
    bszEventTypeName = SysAllocString(L"EventTypeName");
    bszFriendlyName = SysAllocString(L"DisplayName");

    hRes = pTraceSubClasses->Get(bszClassName,          // property name 
                                        0L, 
                                        &pVal,          // output to this variant 
                                        NULL, 
                                        NULL);

    if (ERROR_SUCCESS == hRes){
        if (pQualSet) {
            pQualSet->Release();
            pQualSet = NULL;
        }
        // Get Qualifier Set to obtain the friendly name.
        pTraceSubClasses->GetQualifierSet(&pQualSet);
        hRes = pQualSet->Get(bszFriendlyName, 
                                0, 
                                &pClassName, 
                                0);
        if (ERROR_SUCCESS == hRes && pClassName.bstrVal != NULL) {
#ifdef UNICODE
            wcscpy(strClassName, pClassName.bstrVal);
#else
            WideCharToMultiByte(CP_ACP,
                                0,
                                pClassName.bstrVal,
                                wcslen(pClassName.bstrVal),
                                TempString,
                                (MAXSTR * sizeof(CHAR)),
                                NULL,
                                NULL
                                );
            strcpy(strClassName, TempString);
            strClassName[wcslen(pClassName.bstrVal)] = '\0';
#endif
        }
        else {
#ifdef UNICODE
            strClassName[0] = L'\0';
#else
            strClassName[0] = '\0';
#endif
        }
        // Put Event Header
        pMofInfo = GetNewMofInfo(Guid,
                                    EVENT_TYPE_DEFAULT,
                                    EVENT_VERSION_DEFAULT,
                                    EVENT_LEVEL_DEFAULT
                                    );
        if (pMofInfo != NULL) {
            pMofTemplate = pMofInfo;
            pMofLookup = pMofInfo;
            InsertTailList(&ListHead, &pMofInfo->Entry);
            pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(strClassName) + 1) * sizeof(TCHAR));
            if (NULL != pMofInfo->strDescription) {
                _tcscpy(pMofInfo->strDescription, strClassName);
            }
        }
        else{
            goto cleanup;
        }

        // Create an enumerator to find derived classes.
        bszSubClassName = SysAllocString(pVal.bstrVal);
        hRes = pWbemServices->CreateClassEnum ( 
                                    bszSubClassName,                                                // class name
                                    WBEM_FLAG_SHALLOW | WBEM_FLAG_USE_AMENDED_QUALIFIERS,           // shallow search
                                    NULL,
                                    &pEnumTraceSubSubClasses
                                    );
        SysFreeString ( bszSubClassName );
        if (ERROR_SUCCESS == hRes) {
            ULONG uReturnedSub = 1;

            while(uReturnedSub == 1){
                // For each event in the subclass
                pTraceSubSubClasses = NULL;
                hRes = pEnumTraceSubSubClasses->Next(5000,                  // timeout in five seconds
                                                    1,                      // return just one instance
                                                    &pTraceSubSubClasses,   // pointer to a Sub class
                                                    &uReturnedSub);         // number obtained: one 
                if (ERROR_SUCCESS == hRes && uReturnedSub == 1) {
                    if (pQualSet) {
                        pQualSet->Release();
                        pQualSet = NULL;
                    }
                    // Get Qualifier Set.
                    pTraceSubSubClasses->GetQualifierSet(&pQualSet);
                    // Get Type number among Qualifiers
                    VariantClear(&pTypeVal);
                    hRes = pQualSet->Get(bszEventType, 
                                            0, 
                                            &pTypeVal, 
                                            0);

                    if (ERROR_SUCCESS == hRes) {
                        TypeArray = NULL;
                        TypeNameArray = NULL;
                        if (pTypeVal.vt & VT_ARRAY) {   // EventType is an array
                            TypeArray = pTypeVal.parray;
                            VariantClear(&pTypeNameVal);
                            hRes = pQualSet->Get(bszEventTypeName, 
                                                    0, 
                                                    &pTypeNameVal, 
                                                    0);
                            if ((ERROR_SUCCESS == hRes) && (pTypeNameVal.vt & VT_ARRAY)) {
                                TypeNameArray = pTypeNameVal.parray;
                            }
                            if (TypeArray != NULL) {
                                hRes = SafeArrayGetLBound(TypeArray, 1, &lTypeLower);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                hRes = SafeArrayGetUBound(TypeArray, 1, &lTypeUpper);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                if (lTypeUpper < 0) {
                                    break;
                                }
                                SafeArrayAccessData(TypeArray, (void HUGEP **)&pTypeData );

                                if (TypeNameArray != NULL) {
                                    hRes = SafeArrayGetLBound(TypeNameArray, 1, &lTypeNameLower);
                                    if (ERROR_SUCCESS != hRes) {
                                        break;
                                    }
                                    hRes = SafeArrayGetUBound(TypeNameArray, 1, &lTypeNameUpper);
                                    if (ERROR_SUCCESS != hRes) {
                                        break;
                                    }
                                    if (lTypeNameUpper < 0) 
                                        break;
                                    SafeArrayAccessData(TypeNameArray, (void HUGEP **)&pTypeNameData );
                                }

                                for (lCount = lTypeLower; lCount <= lTypeUpper; lCount++) { 
                                    lEventTypeWbem = pTypeData[lCount];
                                    nEventType = (SHORT)lEventTypeWbem;
                                    pMofInfo = GetNewMofInfo(Guid, nEventType, nVersion, nLevel);
                                    if (pMofInfo != NULL) {
                                        InsertTailList(&ListHead, &pMofInfo->Entry);
                                        if (pMofTemplate != NULL && pMofTemplate->strDescription != NULL) {
                                            pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(pMofTemplate->strDescription) + 1) * sizeof(TCHAR));
                                            if (pMofInfo->strDescription != NULL) {
                                                _tcscpy(pMofInfo->strDescription, pMofTemplate->strDescription);
                                            }
                                        }
                                        if (nType == nEventType) {
                                            // Type matched
                                            pMofLookup = pMofInfo;
                                        }
                                        if (TypeNameArray != NULL) {
                                            if ((lCount >= lTypeNameLower) && (lCount <= lTypeNameUpper)) {
                                                pMofInfo->strType = (LPTSTR)malloc((wcslen((LPWSTR)pTypeNameData[lCount]) + 1) * sizeof(TCHAR));
                                                if (pMofInfo->strType != NULL){
#ifdef UNICODE
                                                    wcscpy(pMofInfo->strType, (LPWSTR)(pTypeNameData[lCount]));
#else
                                                    WideCharToMultiByte(CP_ACP,
                                                                        0,
                                                                        (LPWSTR)(pTypeNameData[lCount]),
                                                                        wcslen((LPWSTR)(pTypeNameData[lCount])),
                                                                        TempString,
                                                                        (MAXSTR * sizeof(CHAR)),
                                                                        NULL,
                                                                        NULL
                                                                        );
                                                    TempString[wcslen((LPWSTR)(pTypeNameData[lCount]))] = '\0';
                                                    strcpy(pMofInfo->strType, TempString);
#endif
                                                }
                                            }
                                        }
                                    }
                                }
                                SafeArrayUnaccessData(TypeArray);  
                                SafeArrayDestroy(TypeArray);
                                VariantInit(&pTypeVal);
                                if (TypeNameArray != NULL) {
                                    SafeArrayUnaccessData(TypeNameArray);
                                    SafeArrayDestroy(TypeNameArray);
                                    VariantInit(&pTypeNameVal);
                                }
                            }
                            else {
                                // If the Types are not found, then bail
                                break;
                            }
                        }
                        else {                          // EventType is scalar
                            hRes = VariantChangeType(&pTypeVal, &pTypeVal, 0, VT_I2);
                            if (ERROR_SUCCESS == hRes)
                                nEventType = (SHORT)V_I2(&pTypeVal);
                            else
                                nEventType = (SHORT)V_I4(&pTypeVal);

                            VariantClear(&pTypeNameVal);
                            hRes = pQualSet->Get(bszEventTypeName, 
                                                    0, 
                                                    &pTypeNameVal, 
                                                    0);
                            if (ERROR_SUCCESS == hRes) {
#ifdef UNICODE
                                wcscpy(strType, pTypeNameVal.bstrVal);
#else
                                WideCharToMultiByte(CP_ACP,
                                                    0,
                                                    pTypeNameVal.bstrVal,
                                                    wcslen(pTypeNameVal.bstrVal),
                                                    TempString,
                                                    (MAXSTR * sizeof(CHAR)),
                                                    NULL,
                                                    NULL
                                                    );
                                strcpy(strType, TempString);
                                strType[wcslen(pTypeNameVal.bstrVal)] = '\0';
#endif
                            }
                            else{
#ifdef UNICODE
                                strType[0] = L'\0';
#else
                                strType[0] = '\0';
#endif
                            }

                            pMofInfo = GetNewMofInfo(Guid, nEventType, nVersion, nLevel);
                            if (pMofInfo != NULL) {
                                InsertTailList(&ListHead, &pMofInfo->Entry);
                                if (pMofTemplate != NULL && pMofTemplate->strDescription != NULL) {
                                    pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(pMofTemplate->strDescription) + 1) * sizeof(TCHAR));
                                    if (pMofInfo->strDescription != NULL) {
                                        _tcscpy(pMofInfo->strDescription, pMofTemplate->strDescription);
                                    }
                                }
                                if (nType == nEventType) {
                                    // Type matched
                                    pMofLookup = pMofInfo;
                                }
                                pMofInfo->strType = (LPTSTR)malloc((_tcslen(strType) + 1) * sizeof(TCHAR));
                                if (pMofInfo->strType != NULL){
                                    _tcscpy(pMofInfo->strType, strType);
                                }
                            }
                        }

                        // Get event layout
                        VariantClear(&pVal);
                        IdIndex = 1;
                        V_VT(&pVal) = VT_I4;
                        V_I4(&pVal) = IdIndex; 
                        // For each property
                        PropArray = NULL;
                        while (pTraceSubSubClasses->GetNames(bszWmiDataId,                  // only properties with WmiDataId qualifier
                                                            WBEM_FLAG_ONLY_IF_IDENTICAL,
                                                            &pVal,                          // WmiDataId number starting from 1
                                                            &PropArray) == WBEM_NO_ERROR) {

                            hRes = SafeArrayGetLBound(PropArray, 1, &lLower);
                            if (ERROR_SUCCESS != hRes) {
                                break;
                            }
                            hRes = SafeArrayGetUBound(PropArray, 1, &lUpper);
                            if (ERROR_SUCCESS != hRes) {
                                break;
                            }
                            if (lUpper < 0) 
                                break;
                            // This loop will iterate just once.
                            for (lCount = lLower; lCount <= lUpper; lCount++) { 
                                hRes = SafeArrayGetElement(PropArray, &lCount, &bszPropName);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                hRes = pTraceSubSubClasses->Get(bszPropName,    // Property name
                                                                0L,
                                                                NULL,
                                                                &pVarType,      // CIMTYPE of the property
                                                                NULL);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }

                                // Get the Qualifier set for the property
                                if (pQualSet) {
                                    pQualSet->Release();
                                    pQualSet = NULL;
                                }
                                hRes = pTraceSubSubClasses->GetPropertyQualifierSet(bszPropName,
                                                                        &pQualSet);

                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                
                                ItemType = GetItemType((CIMTYPE_ENUMERATION)pVarType, pQualSet);
                                
                                if( pVarType & CIM_FLAG_ARRAY ){
                                    ArraySize = GetArraySize(pQualSet);
                                }else{
                                    ArraySize = 1;
                                }
#ifdef UNICODE
                                AddMofInfo(&ListHead, 
                                            bszPropName, 
                                            ItemType, 
                                            ArraySize);
#else
                                WideCharToMultiByte(CP_ACP,
                                                    0,
                                                    bszPropName,
                                                    wcslen(bszPropName),
                                                    TempString,
                                                    (MAXSTR * sizeof(CHAR)),
                                                    NULL,
                                                    NULL
                                                    );
                                TempString[wcslen(bszPropName)] = '\0';
                                AddMofInfo(&ListHead,
                                            TempString,
                                            ItemType, 
                                            ArraySize);
#endif
                            }
                            SafeArrayDestroy(PropArray);
                            PropArray = NULL;
                            V_I4(&pVal) = ++IdIndex;
                        }   // end enumerating through WmiDataId
                        FlushMofList(&ListHead);
                    }   // if getting event type was successful
                }   // if enumeration returned a subclass successfully
            }   // end enumerating subclasses
        }   // if enumeration was created successfully
    }   // if getting class name was successful
cleanup:
    VariantClear(&pVal);
    VariantClear(&pTypeVal);
    VariantClear(&pClassName);

    SysFreeString(bszClassName);
    SysFreeString(bszWmiDataId);
    SysFreeString(bszEventType);
    SysFreeString(bszEventTypeName);
    SysFreeString(bszFriendlyName);
    // Should not free bszPropName becuase it is already freed by SafeArrayDestroy

    FlushMofList(&ListHead);

    return pMofLookup;
}

PMOF_INFO
GetGuids (GUID Guid, 
        SHORT nVersion, 
        CHAR nLevel, 
        SHORT nType 
        )
/*++

Routine Description:

    Aceesses the MOF data information from WBEM, creates a linked list, 
    and returns a pointer that matches the passed event.
    This function finds the right subtree within the WBEM namespace,
    and calls GetPropertiesFromWBEM() to create the list.

Arguments:

    Guid - GUID of the passed event.
    nVersion - version of the passed event.
    nLevel - level of the passed event.
    nType - type of the passed event.

Return Value:

    PMOF_INFO to MOF_INFO structure that matches the passed event.
    NULL if no match is found.

--*/
{
    IEnumWbemClassObject    *pEnumTraceSubClasses = NULL, *pEnumTraceSubSubClasses = NULL;
    IWbemClassObject        *pTraceSubClasses = NULL, *pTraceSubSubClasses = NULL;
    IWbemQualifierSet       *pQualSet = NULL;

    BSTR bszInstance = NULL;
    BSTR bszPropertyName = NULL;
    BSTR bszSubClassName = NULL;
    BSTR bszGuid = NULL;
    BSTR bszVersion = NULL;

    WCHAR strGuid[MAXSTR], strTargetGuid[MAXSTR];
    
    HRESULT hRes;

    VARIANT pVal;
    VARIANT pGuidVal;
    VARIANT pVersionVal;

    UINT nCounter=0;
    BOOLEAN MatchFound;
    SHORT nEventVersion = EVENT_VERSION_DEFAULT;

    PMOF_INFO pMofLookup = NULL;

    VariantInit(&pVal);
    VariantInit(&pGuidVal);
    VariantInit(&pVersionVal);
    
    if (NULL == pWbemServices) {
        hRes = WbemConnect( &pWbemServices );
        if ( ERROR_SUCCESS != hRes ) {
            goto cleanup;
        }
    }

    // Convert traget GUID to string for later comparison
#ifdef UNICODE
    GuidToString(strTargetGuid, &Guid);
#else
    CHAR TempString[MAXSTR];
    GuidToString(TempString, &Guid);
    MultiByteToWideChar(CP_ACP, 0, TempString, -1, strTargetGuid, MAXSTR);
#endif

    bszInstance = SysAllocString(L"EventTrace");
    bszPropertyName = SysAllocString(L"__CLASS");
    bszGuid = SysAllocString(L"Guid");
    bszVersion = SysAllocString(L"EventVersion");
    pEnumTraceSubClasses = NULL;

    // Get an enumerator for all classes under "EventTace".
    hRes = pWbemServices->CreateClassEnum ( 
                bszInstance,
                WBEM_FLAG_SHALLOW | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                NULL,
                &pEnumTraceSubClasses );
    SysFreeString (bszInstance);

    if (ERROR_SUCCESS == hRes) {
        ULONG uReturned = 1;
        MatchFound = FALSE;
        while (uReturned == 1) {
            pTraceSubClasses = NULL;
            // Get the next ClassObject.
            hRes = pEnumTraceSubClasses->Next(5000,             // timeout in five seconds
                                            1,                  // return just one instance
                                            &pTraceSubClasses,  // pointer to Event Trace Sub Class
                                            &uReturned);        // number obtained: one or zero
            if (ERROR_SUCCESS == hRes && (uReturned == 1)) {
                // Get the class name
                hRes = pTraceSubClasses->Get(bszPropertyName,   // property name 
                                                0L, 
                                                &pVal,          // output to this variant 
                                                NULL, 
                                                NULL);
                if (ERROR_SUCCESS == hRes){
                    bszSubClassName = SysAllocString(pVal.bstrVal);
                    // Create an enumerator to find derived classes.
                    hRes = pWbemServices->CreateClassEnum ( 
                                            bszSubClassName,
                                            WBEM_FLAG_SHALLOW | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                            NULL,
                                            &pEnumTraceSubSubClasses 
                                            );
                    SysFreeString ( bszSubClassName );
                    bszSubClassName = NULL;
                    VariantClear(&pVal);

                    if (ERROR_SUCCESS == hRes) {
                                    
                        ULONG uReturnedSub = 1;
                        while(uReturnedSub == 1){

                            pTraceSubSubClasses = NULL;
                            // enumerate through the resultset.
                            hRes = pEnumTraceSubSubClasses->Next(5000,              // timeout in five seconds
                                                            1,                      // return just one instance
                                                            &pTraceSubSubClasses,   // pointer to a Sub class
                                                            &uReturnedSub);         // number obtained: one or zero
                            if (ERROR_SUCCESS == hRes && uReturnedSub == 1) {
                                // Get the subclass name            
                                hRes = pTraceSubSubClasses->Get(bszPropertyName,    // Class name 
                                                                0L, 
                                                                &pVal,              // output to this variant 
                                                                NULL, 
                                                                NULL);
                                VariantClear(&pVal);

                                if (ERROR_SUCCESS == hRes){
                                    // Get Qualifier Set.
                                    if (pQualSet) {
                                        pQualSet->Release();
                                        pQualSet = NULL;
                                    }
                                    pTraceSubSubClasses->GetQualifierSet (&pQualSet );

                                    // Get GUID among Qualifiers
                                    hRes = pQualSet->Get(bszGuid, 
                                                            0, 
                                                            &pGuidVal, 
                                                            0);
                                    if (ERROR_SUCCESS == hRes) {
                                        wcscpy(strGuid, (LPWSTR)V_BSTR(&pGuidVal));
                                        VariantClear ( &pGuidVal  );

                                        if (!wcsstr(strGuid, L"{"))
                                            swprintf(strGuid , L"{%s}", strGuid);

                                        if (!_wcsicmp(strTargetGuid, strGuid)) {
                                            hRes = pQualSet->Get(bszVersion, 
                                                                    0, 
                                                                    &pVersionVal, 
                                                                    0);
                                            if (ERROR_SUCCESS == hRes) {
                                                hRes = VariantChangeType(&pVersionVal, &pVersionVal, 0, VT_I2);
                                                if (ERROR_SUCCESS == hRes)
                                                    nEventVersion = (SHORT)V_I2(&pVersionVal);
                                                else
                                                    nEventVersion = (SHORT)V_I4(&pVersionVal);
                                                VariantClear(&pVersionVal);

                                                if (nVersion == nEventVersion) {
                                                    // Match is found. 
                                                    // Now put all events in this subtree into the list 
                                                    MatchFound = TRUE;
                                                    pMofLookup = GetPropertiesFromWBEM( pTraceSubSubClasses, 
                                                                                        Guid,
                                                                                        nVersion,
                                                                                        nLevel,
                                                                                        nType
                                                                                        );
                                                    break;
                                                }
                                            }
                                            else {
                                                // if there is no version number for this event,
                                                // the current one is the only one
                                                // Now put all events in this subtree into the list 
                                                MatchFound = TRUE;
                                                pMofLookup = GetPropertiesFromWBEM( pTraceSubSubClasses, 
                                                                                    Guid,
                                                                                    EVENT_VERSION_DEFAULT,
                                                                                    nLevel,
                                                                                    nType
                                                                                    );
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        } // end while enumerating sub classes
                        if (MatchFound) {
                            break;
                        }
                        if (pEnumTraceSubSubClasses) {
                            pEnumTraceSubSubClasses->Release();
                            pEnumTraceSubSubClasses = NULL;
                        }
                    }   // if creating enumeration was successful
                    else {
                        pEnumTraceSubSubClasses = NULL;
                    }
                }   // if getting class name was successful
            }
            nCounter++;
            // if match is found, break out of the top level search
            if (MatchFound)
                break;
        }   // end while enumerating top classes
        if( pEnumTraceSubClasses ){
            pEnumTraceSubClasses->Release();
            pEnumTraceSubClasses = NULL;
        }
    }   // if creating enumeration for top level is successful

cleanup:

    VariantClear(&pGuidVal);
    VariantClear(&pVersionVal);

    SysFreeString(bszGuid);
    SysFreeString(bszPropertyName);
    SysFreeString(bszVersion);

    if( pEnumTraceSubClasses ){
        pEnumTraceSubClasses->Release();
        pEnumTraceSubClasses = NULL;
    }
    if (pEnumTraceSubSubClasses){
        pEnumTraceSubSubClasses->Release();
        pEnumTraceSubSubClasses = NULL;
    }
    if (pQualSet) {
        pQualSet->Release();
        pQualSet = NULL;
    }

    return pMofLookup;
}

ULONG 
ahextoi(
    TCHAR *s
    )
/*++

Routine Description:

    Converts a hex number to an integer.

Arguments:

    s - Input string containing a hex number.

Return Value:

    ULONG denoted by the hex string s.

--*/
{
    long len;
    ULONG num, base, hex;

    if (s == NULL)
        return 0;
    if (*s == 0)
        return 0;
    len = (long) _tcslen(s);
    if (len == 0 || len >= MAXSTR )
        return 0;
    hex = 0; base = 1; num = 0;
    while (--len >= 0) {
        if ( (s[len] == 'x' || s[len] == 'X') &&
             (s[len-1] == '0') )
            break;
        if (s[len] >= '0' && s[len] <= '9')
            num = s[len] - '0';
        else if (s[len] >= 'a' && s[len] <= 'f')
            num = (s[len] - 'a') + 10;
        else if (s[len] >= 'A' && s[len] <= 'F')
            num = (s[len] - 'A') + 10;
        else
            continue;

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

void 
RemoveWhiteSpace(
    TCHAR *s
    ) 
/*++

Routine Description:

    Removes white space (' ', '\n', and '\t') from the given string.

Arguments:

    s - Input and output string.

Return Value:

    None

--*/
{
    UINT i = 0;
    UINT j = 0;
    TCHAR TempString[MAXSTR];
    if (s == NULL)
        return;
    _tcscpy(TempString, s);
    while (TempString[i] != '\0') {
        if (TempString[i] != ' ' && TempString[i] != '\t' && TempString[i] != '\n')
            s[j++] = TempString[i];
        ++i;
    }
    s[j] = '\0';
}
void 
PrintHelpMessage()
/*++

Routine Description:

    Prints out help messages.

Arguments:

    None

Return Value:

    None

--*/
{
    _tprintf(
        _T("Usage: tracedmp [options]  <EtlFile1 EtlFile2 ...>| [-h | -? | -help]\n")
        _T("\t-o <file>          Output CSV file\n")
        _T("\t-rt [LoggerName]   Realtime tracedmp from the logger [LoggerName]\n")
        _T("\t-summary           Summary.txt only\n")
        _T("\t-begin HH:MM DD/MM/YY\n")
        _T("\t-end   HH:MM DD/MM/YY\n")
        _T("\t-h\n")
        _T("\t-help\n")
        _T("\t-?                 Display usage information\n")
        _T("\n")
        _T("\tDefault Etl File is C:\\Logfile.etl\n")
        _T("\tDefault output file is dumpfile.csv\n")
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\sdksamples\tracelog\tracelog.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    tracelog.c

Abstract:

    Sample trace control program. Allows user to start, update, query, stop 
    event tracing, etc.


--*/
#ifndef UNICODE
#define UNICODE
#endif
#ifndef _UNICODE
#define _UNICODE
#endif

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <guiddef.h>
#include <evntrace.h>

#define MAXSTR                          1024
#define DEFAULT_LOGFILE_NAME            _T("C:\\LogFile.Etl")
#define NT_LOGGER                       _T("NT Kernel Logger")
#define MAXIMUM_LOGGERS                  32
#define MAXGUIDS                        128

#define ACTION_QUERY                    0
#define ACTION_START                    1
#define ACTION_STOP                     2
#define ACTION_UPDATE                   3
#define ACTION_LIST                     4
#define ACTION_ENABLE                   5
#define ACTION_HELP                     6
#define ACTION_FLUSH                    7
#define ACTION_ENUM_GUID                8
#define ACTION_UNDEFINED               10

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))
//
// Functions not implemented on Win2K need to be searched and loaded separately.
// To make further accesses easy, an array of function pointers will be used.
// The following list serves as indices to that array.
//
#define FUNC_FLUSH_TRACE        0
#define FUNC_ENUM_TRACE_GUIDS   1
// Funtion pointer array for unimplemented functions on Win2K.
// Note: This may not work if this code is ported to C++, because
// all the function pointers may be typedefed differently.
#define MAXFUNC                 10
FARPROC FuncArray[MAXFUNC];
HINSTANCE advapidll;

BOOLEAN XP;

void
PrintLoggerStatus(
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
    IN ULONG Status,
    IN BOOL PrintStatus
    );

#define PRINTSTATUS TRUE
#define NOPRINTSTATUS FALSE

LPTSTR
DecodeStatus(
    IN ULONG Status
    );

LONG
GetGuids(
    IN LPTSTR GuidFile, 
    OUT LPGUID *GuidArray
    );

ULONG 
ahextoi(
    IN TCHAR *s
    );

void 
StringToGuid(
    IN TCHAR *str,
    OUT LPGUID guid
    );

PTCHAR 
GuidToString(
    IN OUT PTCHAR s,
    IN LPGUID piid
    );

TCHAR ErrorMsg[MAXSTR];

void 
PrintHelpMessage();


//
//  main function
//
__cdecl main(argc, argv)
    int argc;
    char **argv;
/*++

Routine Description:

    It is the main function.

Arguments:
  
Return Value:

    Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS (== 0).


--*/{
    ULONG i, j;
    LONG GuidCount;
    USHORT Action = ACTION_UNDEFINED;
    ULONG Status = 0;
    LPTSTR LoggerName;
    LPTSTR LogFileName;
    TCHAR GuidFile[MAXSTR];
    PEVENT_TRACE_PROPERTIES pLoggerInfo;
    TRACEHANDLE LoggerHandle = 0;
    LPTSTR *targv, *utargv = NULL;
    LPGUID *GuidArray;
    char *Space;
    char *save;
    BOOL bKill = FALSE;
    BOOL bForceKill = FALSE ;
    BOOL bEnable = TRUE;
    ULONG iLevel = 0;
    ULONG iFlags = 0;
    ULONG SizeNeeded = 0;
    ULONG specialLogger = 0;
    ULONG GlobalLoggerStartValue = 0;
    PULONG pFlags = NULL;

    BOOL bProcess = TRUE;
    BOOL bThread  = TRUE;
    BOOL bDisk    = TRUE;
    BOOL bNetwork = TRUE;

    TCHAR tstrLogFileName[MAXSTR];

    OSVERSIONINFO OSVersion;

    OSVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    XP = FALSE;
    if (GetVersionEx(&OSVersion)) {
        XP = (OSVersion.dwMajorVersion > 5) ||
             ((OSVersion.dwMajorVersion == 5) && (OSVersion.dwMinorVersion > 0));
    }
    // Load functions that are not implemented on Win2K
    for (i = 0; i < MAXFUNC; ++i)
        FuncArray[i] = NULL;
    if (XP) {
        advapidll = LoadLibrary(_T("advapi32.dll"));
        if (advapidll != NULL) {
#ifdef UNICODE
            FuncArray[FUNC_FLUSH_TRACE] = GetProcAddress(advapidll, "FlushTraceW");
#else
            FuncArray[FUNC_FLUSH_TRACE] = GetProcAddress(advapidll, "FlushTraceA");
#endif
            FuncArray[FUNC_ENUM_TRACE_GUIDS] = GetProcAddress(advapidll, "EnumerateTraceGuids");
        }
    }

    // Initialize structure first
    SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAXSTR * sizeof(TCHAR);
    pLoggerInfo = (PEVENT_TRACE_PROPERTIES) malloc(SizeNeeded);
    if (pLoggerInfo == NULL) {
        if (advapidll != NULL)
            FreeLibrary(advapidll);
        return (ERROR_OUTOFMEMORY);
    }
    

    RtlZeroMemory(pLoggerInfo, SizeNeeded);

    pLoggerInfo->Wnode.BufferSize = SizeNeeded;
    pLoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
    pLoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    pLoggerInfo->LogFileNameOffset = pLoggerInfo->LoggerNameOffset + MAXSTR * sizeof(TCHAR);

    LoggerName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LoggerNameOffset);
    LogFileName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LogFileNameOffset);
    _tcscpy(LoggerName, NT_LOGGER);

    Space = (char*) malloc( (MAXGUIDS * sizeof(GuidArray)) +
                            (MAXGUIDS * sizeof(GUID) ));
    if (Space == NULL) {
        free(pLoggerInfo);
        if (advapidll != NULL)
            FreeLibrary(advapidll);
        return(ERROR_OUTOFMEMORY);
    }
    save = Space;
    GuidArray = (LPGUID *) Space;
    Space += MAXGUIDS * sizeof(GuidArray);

    for (GuidCount=0; GuidCount<MAXGUIDS; GuidCount++) {
        GuidArray[GuidCount] = (LPGUID) Space;
        Space += sizeof(GUID);
    }
    GuidCount = 0;

#ifdef UNICODE
    if ((targv = CommandLineToArgvW(
                      GetCommandLineW(),    // pointer to a command-line string
                      &argc                 // receives the argument count
                      )) == NULL) {
        free(pLoggerInfo);
        free(save);
        if (advapidll != NULL)
            FreeLibrary(advapidll);
        return (GetLastError());
    };
    utargv = targv;
#else
    targv = argv;
#endif

    pFlags = &pLoggerInfo->EnableFlags;
    //
    // Add default flags.
    //
    while (--argc > 0) {
        ++targv;
        if (**targv == '-' || **targv == '/') {  // argument found
            if(targv[0][0] == '/' ) targv[0][0] = '-';
            if (!_tcsicmp(targv[0], _T("-start"))) {
                Action = ACTION_START;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-enable"))) {
                Action = ACTION_ENABLE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-disable"))) {
                Action = ACTION_ENABLE;
                bEnable = FALSE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-stop"))) {
                Action = ACTION_STOP;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-update"))) {
                Action = ACTION_UPDATE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-q"))) {
                Action = ACTION_QUERY;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-flush"))) {
                Action = ACTION_FLUSH;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-enumguid"))) {
                Action = ACTION_ENUM_GUID;
            }
            else if (!_tcsicmp(targv[0], _T("-f"))) {
                if (argc > 1) {
                    _tcscpy(LogFileName, targv[1]);
                    _tcscpy(tstrLogFileName, targv[1]);
                    ++targv; --argc;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-append"))) {
                if (argc > 1) {
                    _tfullpath(LogFileName, targv[1], MAXSTR);
                    _tcscpy(tstrLogFileName, LogFileName);
                    ++targv; --argc;
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_APPEND;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-guid"))) {
                if (argc > 1) {
                    if (targv[1][0] == _T('#')) {
                        StringToGuid(&targv[1][1], GuidArray[0]);
                        ++targv; --argc;
                        GuidCount = 1;
                    }
                    else if (targv[1][0] != '-' && targv[1][0] != '/') {
                        _tfullpath(GuidFile, targv[1], MAXSTR);
                        ++targv; --argc;
                        GuidCount = GetGuids(GuidFile, GuidArray);
                        if (GuidCount < 0) {
                            _tprintf( _T("Error: %s does no exist\n"), GuidFile );
                            Status = ERROR_INVALID_PARAMETER;
                            goto CleanupExit;
                        }
                        else if (GuidCount == 0){
                            _tprintf( _T("Error: %s is invalid\n"), GuidFile );
                            Status = ERROR_INVALID_PARAMETER;
                            goto CleanupExit;
                        }
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-seq"))) {
                if (argc > 1) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_SEQUENTIAL;
                    pLoggerInfo->MaximumFileSize = _ttoi(targv[1]);
                    ++targv; --argc;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-newfile"))) {
                if (argc > 1) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_NEWFILE;
                    pLoggerInfo->MaximumFileSize = _ttoi(targv[1]);
                    ++targv; --argc;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-cir"))) {
                if (argc > 1) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_CIRCULAR;
                    pLoggerInfo->MaximumFileSize = _ttoi(targv[1]);
                    ++targv; --argc;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-b"))) {
                if (argc > 1) {
                    pLoggerInfo->BufferSize = _ttoi(targv[1]);
                    ++targv; --argc;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-flag")) || !_tcsicmp(targv[0], _T("-flags"))) {
                if (argc > 1) {
                    if (targv[1][1] == _T('x') || targv[1][1] == _T('X')) {
                        pLoggerInfo->EnableFlags |= ahextoi(targv[1]);
                    } else {
                        pLoggerInfo->EnableFlags |= _ttoi(targv[1]);
                    }
                    iFlags =  pLoggerInfo->EnableFlags ;   // Copy for EnableTrace
                    ++targv; --argc;
                    // Do not accept flags with MSB = 1.

                    if (0x80000000 & pLoggerInfo->EnableFlags) {
                        _tprintf(_T("Invalid Flags: 0x%0X(%d.)\n"),
                            pLoggerInfo->EnableFlags, pLoggerInfo->EnableFlags);
                        Status = ERROR_INVALID_PARAMETER;
                        goto CleanupExit;
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-min"))) {
                if (argc > 1) {
                    pLoggerInfo->MinimumBuffers = _ttoi(targv[1]);
                    ++targv; --argc;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-max"))) {
                if (argc > 1) {
                    pLoggerInfo->MaximumBuffers = _ttoi(targv[1]);
                    ++targv; --argc;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-level"))) {
                if (argc > 1) {
                    iLevel = _ttoi(targv[1]);
                    ++targv; --argc;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-ft"))) {
                if (argc > 1) {
                    pLoggerInfo->FlushTimer = _ttoi(targv[1]);
                    ++targv; --argc;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-um"))) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_PRIVATE_LOGGER_MODE;
            }
            else if (!_tcsicmp(targv[0], _T("-paged"))) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_USE_PAGED_MEMORY;
            }
            else if (!_tcsicmp(targv[0], _T("-rt"))) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_REAL_TIME_MODE;
            }
            else if (!_tcsicmp(targv[0], _T("-age"))) {
                if (argc > 1) {
                    pLoggerInfo->AgeLimit = _ttoi(targv[1]);
                    ++targv; --argc;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-l"))) {
                Action  = ACTION_LIST;
                bKill   = FALSE;
            }
            else if (!_tcsicmp(targv[0], _T("-x"))) {
                Action  = ACTION_LIST;
                bKill   = TRUE;
            }
            else if (!_tcsicmp(targv[0], _T("-xf"))) {
                Action  = ACTION_LIST;
                bKill   = TRUE;
                bForceKill = TRUE ;
            }
            else if (!_tcsicmp(targv[0], _T("-noprocess"))) {
                bProcess = FALSE;
            }
            else if (!_tcsicmp(targv[0], _T("-nothread"))) {
                bThread = FALSE;
            }
            else if (!_tcsicmp(targv[0], _T("-nodisk"))) {
                bDisk = FALSE;
            }
            else if (!_tcsicmp(targv[0], _T("-nonet"))) {
                bNetwork = FALSE;
            }
            else if (!_tcsicmp(targv[0], _T("-fio"))) {
                if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_DISK_FILE_IO;
                }
                else {
                    _tprintf(_T("Option -fio cannot be used with -eflags. Ignored\n"));
                }
            }
            else if (!_tcsicmp(targv[0], _T("-pf"))) {
                if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS;
                }
                else {
                    _tprintf(_T("Option -pf cannot be used with -eflags. Ignored\n"));
                }
            }
            else if (!_tcsicmp(targv[0], _T("-hf"))) {
                if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS;
                }
                else {
                    _tprintf(_T("Option -hf cannot be used with -eflags. Ignored\n"));
                }
            }
            else if (!_tcsicmp(targv[0], _T("-img"))) {
                if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_IMAGE_LOAD;
                }
                else {
                    _tprintf(_T("Option -img cannot be used with -eflags. Ignored\n"));
                }
            }
            else if (!_tcsicmp(targv[0], _T("-cm"))) {
                if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_REGISTRY;
                }
                else {
                    _tprintf(_T("Option -cm cannot be used with -eflags. Ignored\n"));
                }
            }
            else if ( targv[0][1] == 'h' || targv[0][1] == 'H' || targv[0][1] == '?'){
                Action = ACTION_HELP;
                PrintHelpMessage();
                goto CleanupExit;
            }
            else Action = ACTION_UNDEFINED;
        }
        else { 
            _tprintf(_T("Invalid option given: %s\n"), targv[0]);
            Status = ERROR_INVALID_PARAMETER;
            goto CleanupExit;
        }
    }
    if (!_tcscmp(LoggerName, NT_LOGGER)) {
        if (pFlags == &pLoggerInfo->EnableFlags) {
            if (bProcess)
                *pFlags |= EVENT_TRACE_FLAG_PROCESS;
            if (bThread)
                *pFlags |= EVENT_TRACE_FLAG_THREAD;
            if (bDisk)
                *pFlags |= EVENT_TRACE_FLAG_DISK_IO;
            if (bNetwork)
                *pFlags |= EVENT_TRACE_FLAG_NETWORK_TCPIP;
        }

        pLoggerInfo->Wnode.Guid = SystemTraceControlGuid; // defaults to OS
        specialLogger = 1;
    }
    if ( !(pLoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) ) {
        if (specialLogger != 3 && _tcslen(LogFileName) <= 0 && Action == ACTION_START) {
            _tcscpy(LogFileName, DEFAULT_LOGFILE_NAME); // for now...
            _tcscpy(tstrLogFileName, DEFAULT_LOGFILE_NAME);
        }
    }

    switch (Action) {
        case  ACTION_START:
        {

           if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
               if (GuidCount != 1) {
                   _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                   Status = ERROR_INVALID_PARAMETER;
                   break;
               }
               pLoggerInfo->Wnode.Guid = *GuidArray[0];
           }
            Status = StartTrace(&LoggerHandle, LoggerName, pLoggerInfo);

            if (Status != ERROR_SUCCESS) {
                _tprintf(_T("Could not start logger: %s\n") 
                         _T("Operation Status:       %uL\n")
                         _T("%s\n"),
                         LoggerName,
                         Status,
                         DecodeStatus(Status));

                break;
            }
            _tprintf(_T("Logger Started...\n"));

        case ACTION_ENABLE:

            if (Action == ACTION_ENABLE ){

                if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
                {
                    if (GuidCount != 1)
                    {
                        _tprintf(_T("Need one GUID for PRIVATE loggers\n"));
                        Status = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    pLoggerInfo->Wnode.Guid = *GuidArray[0];
                }

                Status = ControlTrace((TRACEHANDLE) 0, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
                if( Status != ERROR_SUCCESS ){
                    _tprintf( _T("ERROR: Logger not started\n")
                              _T("Operation Status:    %uL\n")
                              _T("%s\n"),
                              Status,
                              DecodeStatus(Status));
                    break;
                }
                LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;
            }

            if ( (GuidCount > 0) && (specialLogger == 0)) {
                _tprintf(_T("Enabling trace to logger %d\n"), LoggerHandle);
                for (i = 0; i < (ULONG)GuidCount; i++) {
                    Status = EnableTrace (
                                    bEnable,
                                    iFlags,
                                    iLevel,
                                    GuidArray[i], 
                                    LoggerHandle);

                    //
                    // If some of the Guids can not be enabled, consider it a benign 
                    // failure. Print a warning message and continue. 
                    //
                    if (Status == ERROR_INVALID_OPERATION) {
                       _tprintf(_T("WARNING: Could not enable some guids.\n")); 
                       _tprintf(_T("Check your Guids file\n")); 
                        Status = ERROR_SUCCESS;
                    }

                    if (Status != ERROR_SUCCESS) {
                        _tprintf(_T("ERROR: Failed to enable Guid [%d]...\n"), i);
                        _tprintf(_T("Operation Status:       %uL\n"), Status);
                        _tprintf(_T("%s\n"),DecodeStatus(Status));
                        break;
                    }
                }
            }
            else {
                if (GuidCount > 0) {
                    _tprintf(_T("ERROR: System Logger does not accept application guids...\n"));
                    Status = ERROR_INVALID_PARAMETER;
                }
            }
            break;
        }

        case ACTION_STOP :
            LoggerHandle = (TRACEHANDLE) 0;
            Status = ERROR_SUCCESS;
            if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                if (GuidCount != 1) {
                    _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                    Status = ERROR_INVALID_PARAMETER;
                    break;
                }
                pLoggerInfo->Wnode.Guid = *GuidArray[0];
            }
            if (specialLogger != 0) {
                if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                    Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
                    if (Status != ERROR_SUCCESS)
                        break;
                    LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;
                    Status = EnableTrace( FALSE,
                                          EVENT_TRACE_PRIVATE_LOGGER_MODE,
                                          0,
                                          GuidArray[0],
                                          LoggerHandle );
                }
                else {
                    Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
                    if (Status == ERROR_WMI_INSTANCE_NOT_FOUND)
                        break;
                    LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;

                    for (i = 0; i < (ULONG)GuidCount; i++) {
                    Status = EnableTrace( FALSE,
                                          0,
                                          0,
                                          GuidArray[i],
                                          LoggerHandle);
                    }

                }
            }

            Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_STOP);
            break;

        case ACTION_LIST :
        {
            ULONG i, returnCount ;
            ULONG SizeNeeded;
            PEVENT_TRACE_PROPERTIES pLoggerInfo[MAXIMUM_LOGGERS];
            PEVENT_TRACE_PROPERTIES pStorage;
            PVOID Storage;

            SizeNeeded = MAXIMUM_LOGGERS * (sizeof(EVENT_TRACE_PROPERTIES)
                                      + 2 * MAXSTR * sizeof(TCHAR));

            Storage =  malloc(SizeNeeded);
            if (Storage == NULL) {
                Status = ERROR_OUTOFMEMORY;
                break;
            }
            RtlZeroMemory(Storage, SizeNeeded);

            pStorage = (PEVENT_TRACE_PROPERTIES)Storage;
            for (i=0; i<MAXIMUM_LOGGERS; i++) {
                pStorage->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES)
                                         + 2 * MAXSTR * sizeof(TCHAR);
                pStorage->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES)
                                        + MAXSTR * sizeof(TCHAR);
                pStorage->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
                pLoggerInfo[i] = pStorage;
                pStorage = (PEVENT_TRACE_PROPERTIES) (
                                 (char*)pStorage + 
                                  pStorage->Wnode.BufferSize);
            }
        
            Status = QueryAllTraces(pLoggerInfo,
                                MAXIMUM_LOGGERS,
                                & returnCount);
    
            if (Status == ERROR_SUCCESS)
            {
                for (j= 0; j < returnCount; j++)
                {
                    LPTSTR LoggerName;
                    TCHAR asked = _T('?') ;
                    BOOL StatusPrint = FALSE ;
                    if (bKill)
                    {

                        LoggerName = (LPTSTR) ((char*)pLoggerInfo[j] + 
                                      pLoggerInfo[j]->LoggerNameOffset);
                        if (!bForceKill) {
                            while (!(asked == _T('y')) && !(asked == _T('n'))) {
                                _tprintf(_T("Do you want to kill Logger \"%s\" (Y or N)?"),LoggerName);
                                _tscanf(_T(" %c"),&asked);
                                if (asked == _T('Y')) {
                                    asked = _T('y') ;
                                } else if (asked == _T('N')) {
                                    asked = _T('n') ;
                                }
                            }
                        } else {
                            asked = _T('y');
                        }
                        if (asked == _T('y')) {
                            if (!IsEqualGUID(& pLoggerInfo[j]->Wnode.Guid,
                                         & SystemTraceControlGuid))
                            {
                                LoggerHandle = pLoggerInfo[j]->Wnode.HistoricalContext;
                                Status = EnableTrace(
                                          FALSE,
                                          (pLoggerInfo[j]->LogFileMode &
                                                  EVENT_TRACE_PRIVATE_LOGGER_MODE)
                                              ? (EVENT_TRACE_PRIVATE_LOGGER_MODE)
                                              : (0),
                                          0,
                                          & pLoggerInfo[j]->Wnode.Guid,
                                          LoggerHandle);
                            }
                            Status = ControlTrace((TRACEHANDLE) 0,
                                            LoggerName,
                                            pLoggerInfo[j],
                                            EVENT_TRACE_CONTROL_STOP);
                            _tprintf(_T("Logger \"%s\" has been killed\n"),LoggerName);
                            StatusPrint = TRUE ;
                        } else {
                            _tprintf(_T("Logger \"%s\" has not been killed, current Status is\n"),LoggerName);
                            StatusPrint = FALSE ;
                        }
                    }
                    PrintLoggerStatus(pLoggerInfo[j], 
                                        Status, 
                                        StatusPrint);
                    _tprintf(_T("\n"));
                }
            }

            i = 0;
            free(Storage);
            break;
        }

        case ACTION_UPDATE :
        case ACTION_FLUSH  :
        case ACTION_QUERY  :
            if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                if (GuidCount != 1) {
                    _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                    Status = ERROR_INVALID_PARAMETER;
                    break;
                }
                pLoggerInfo->Wnode.Guid = *GuidArray[0];
            }
            if (Action == ACTION_QUERY) {
                Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
            }

            else if (Action == ACTION_UPDATE) {
                Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_UPDATE);
            }
            else if (Action == ACTION_FLUSH) {
                // Since FlushTrace is not implemented on Win2K, use the function pointer
                // loaded from advapi32.dll separately.
                // Originally, this block had one line: 
                // Status = FlushTrace(LoggerHandle, LoggerName, pLoggerInfo);
                if (FuncArray[FUNC_FLUSH_TRACE] == NULL) {
                    _tprintf(_T("Flush Trace is not supported on this system\n"));
                    Status = ERROR_INVALID_PARAMETER;
                    break;
                }
                Status = (ULONG)(*FuncArray[FUNC_FLUSH_TRACE])(LoggerHandle, LoggerName, pLoggerInfo);
            }

            break;

        case ACTION_ENUM_GUID:
        {
            ULONG i;
            ULONG PropertyArrayCount=10;
            PTRACE_GUID_PROPERTIES  *GuidPropertiesArray;
            ULONG GuidCount;
            ULONG SizeStorage;
            PVOID StorageNeeded;
            PTRACE_GUID_PROPERTIES CleanStorage;
            TCHAR str[MAXSTR];

            // Since EnumTraceGuids is not implemented on Win2K, use the function pointer
            // loaded from advapi32.dll separately.
            if (FuncArray[FUNC_ENUM_TRACE_GUIDS] == NULL) {
                _tprintf(_T("Enumerating trace GUIDS is not supported on this system\n"));
                Status = ERROR_INVALID_PARAMETER;
                break;
            }

Retry:
            SizeStorage = PropertyArrayCount * (sizeof(TRACE_GUID_PROPERTIES) + sizeof(PTRACE_GUID_PROPERTIES));
            StorageNeeded =  malloc(SizeStorage);
            if (StorageNeeded== NULL) {
                Status = ERROR_OUTOFMEMORY;
                break;
            }
            RtlZeroMemory(StorageNeeded, SizeStorage);
            GuidPropertiesArray = (PTRACE_GUID_PROPERTIES *)StorageNeeded;
            CleanStorage = (PTRACE_GUID_PROPERTIES)((char*)StorageNeeded + PropertyArrayCount * sizeof(PTRACE_GUID_PROPERTIES));
            for (i=0; i < PropertyArrayCount; i++) {
                GuidPropertiesArray[i] = CleanStorage;
                CleanStorage = (PTRACE_GUID_PROPERTIES) (
                                    (char*)CleanStorage + sizeof(TRACE_GUID_PROPERTIES)
                                    );
            }
            // Use function pointer for EnumTraceGuids
            Status = (ULONG)(*FuncArray[FUNC_ENUM_TRACE_GUIDS])(GuidPropertiesArray,PropertyArrayCount,&GuidCount);
            if(Status == ERROR_MORE_DATA)
            {
                PropertyArrayCount=GuidCount;
                free(StorageNeeded);
                goto Retry;

            }

            //
            // print the GUID_PROPERTIES and Free Strorage
            //

            _tprintf(_T("    Guid                     Enabled  LoggerId Level Flags\n"));
            _tprintf(_T("------------------------------------------------------------\n"));
            for (i=0; i < GuidCount; i++) {
                _tprintf(_T("%s     %5s  %d    %d    %d\n"),
                                           GuidToString(&str[0],&GuidPropertiesArray[i]->Guid), 
                                           (GuidPropertiesArray[i]->IsEnable) ? _T("TRUE") : _T("FALSE"),
                                           GuidPropertiesArray[i]->LoggerId,
                                           GuidPropertiesArray[i]->EnableLevel,
                                           GuidPropertiesArray[i]->EnableFlags 
                                                               );
            }
            free(StorageNeeded);
        }
        break;

        case ACTION_HELP:
            PrintHelpMessage();
            break;
        default :
            _tprintf(_T("Error: no action specified\n"));
            PrintHelpMessage();
            break;
    }
    
    if ((Action != ACTION_HELP) && (Action != ACTION_ENUM_GUID) 
        && (Action != ACTION_UNDEFINED) && (Action != ACTION_LIST))
        PrintLoggerStatus(pLoggerInfo,
                            Status, 
                            PRINTSTATUS);
CleanupExit: 
    SetLastError(Status);
    if (utargv != NULL) {
        GlobalFree(utargv);
    }
    free(pLoggerInfo);
    free(save);
    if (advapidll != NULL)
        FreeLibrary(advapidll);
    return(Status);
}


void
PrintLoggerStatus(
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
    IN ULONG Status,
    IN BOOL PrintStatus
    )
/*++

Routine Description:

    Prints out the status of the specified logger.

Arguments:

    LoggerInfo - The pointer to the resident EVENT_TRACE_PROPERTIES that has
        the information about the current logger.
    Status - The returned status of the last executed command 
        or
        the operation status of the current logger.

    PrintStatus - Determines which type of status it is using.

Return Value:

    None

--*/
{
    LPTSTR LoggerName, LogFileName;
    
    if ((LoggerInfo->LoggerNameOffset > 0) &&
        (LoggerInfo->LoggerNameOffset  < LoggerInfo->Wnode.BufferSize)) {
        LoggerName = (LPTSTR) ((char*)LoggerInfo +
                                LoggerInfo->LoggerNameOffset);
    }
    else LoggerName = NULL;

    if ((LoggerInfo->LogFileNameOffset > 0) &&
        (LoggerInfo->LogFileNameOffset  < LoggerInfo->Wnode.BufferSize)) {
        LogFileName = (LPTSTR) ((char*)LoggerInfo +
                                LoggerInfo->LogFileNameOffset);
    }
    else LogFileName = NULL;

    if (PrintStatus) {
        _tprintf(_T("Operation Status:       %uL\t"), Status);
        _tprintf(_T("%s\n"), DecodeStatus(Status));
    }
    
    _tprintf(_T("Logger Name:            %s\n"),
            (LoggerName == NULL) ?
            _T(" ") : LoggerName);
        _tprintf(_T("Logger Id:              %I64x\n"), LoggerInfo->Wnode.HistoricalContext);
        _tprintf(_T("Logger Thread Id:       %d\n"), LoggerInfo->LoggerThreadId);
        if (Status != 0)
            return;

        _tprintf(_T("Buffer Size:            %d Kb"), LoggerInfo->BufferSize);
        if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_PAGED_MEMORY) {
            _tprintf(_T(" using paged memory\n"));
        }
        else {
            _tprintf(_T("\n"));
        }
        _tprintf(_T("Maximum Buffers:        %d\n"), LoggerInfo->MaximumBuffers);
        _tprintf(_T("Minimum Buffers:        %d\n"), LoggerInfo->MinimumBuffers);
        _tprintf(_T("Number of Buffers:      %d\n"), LoggerInfo->NumberOfBuffers);
        _tprintf(_T("Free Buffers:           %d\n"), LoggerInfo->FreeBuffers);
        _tprintf(_T("Buffers Written:        %d\n"), LoggerInfo->BuffersWritten);
        _tprintf(_T("Events Lost:            %d\n"), LoggerInfo->EventsLost);
        _tprintf(_T("Log Buffers Lost:       %d\n"), LoggerInfo->LogBuffersLost);
        _tprintf(_T("Real Time Buffers Lost: %d\n"), LoggerInfo->RealTimeBuffersLost);
        _tprintf(_T("AgeLimit:               %d\n"), LoggerInfo->AgeLimit);

        if (LogFileName == NULL) {
            _tprintf(_T("Buffering Mode:         "));
        }
        else {
            _tprintf(_T("Log File Mode:          "));
        }
        if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) {
            _tprintf(_T("Append  "));
        }
        if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
            _tprintf(_T("Circular\n"));
        }
        else if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
            _tprintf(_T("Sequential\n"));
        }
        else {
            _tprintf(_T("Sequential\n"));
        }
        if (LoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
            _tprintf(_T("Real Time mode enabled"));
            _tprintf(_T("\n"));
        }

        if (LoggerInfo->MaximumFileSize > 0)
            _tprintf(_T("Maximum File Size:      %d Mb\n"), LoggerInfo->MaximumFileSize);

        if (LoggerInfo->FlushTimer > 0)
            _tprintf(_T("Buffer Flush Timer:     %d secs\n"), LoggerInfo->FlushTimer);

        if (LoggerInfo->EnableFlags != 0) {
            _tprintf(_T("Enabled tracing:        "));

            if ((LoggerName != NULL) && (!_tcscmp(LoggerName,NT_LOGGER))) {

                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_PROCESS)
                    _tprintf(_T("Process "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_THREAD)
                    _tprintf(_T("Thread "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
                    _tprintf(_T("Disk "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
                    _tprintf(_T("File "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
                    _tprintf(_T("PageFaults "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
                    _tprintf(_T("HardFaults "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
                    _tprintf(_T("ImageLoad "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
                    _tprintf(_T("TcpIp "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_REGISTRY)
                    _tprintf(_T("Registry "));
            }else{
                _tprintf(_T("0x%08x"), LoggerInfo->EnableFlags );
            }
            _tprintf(_T("\n"));
        }
        if (LogFileName != NULL) {
            _tprintf(_T("Log Filename:           %s\n"), LogFileName);
        }

}

LPTSTR
DecodeStatus(
    IN ULONG Status
    )
/*++

Routine Description:

    Decodes WIN32 error into a string in the default language.

Arguments:

    Status - The error status from the last executed command 
        or
        the operation status of the current logger.

Return Value:

    LPTSTR - String containing the decoded message.


--*/
{
    memset( ErrorMsg, 0, MAXSTR );
    FormatMessage(     
        FORMAT_MESSAGE_FROM_SYSTEM |     
        FORMAT_MESSAGE_IGNORE_INSERTS,    
        NULL,
        Status,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) ErrorMsg,
        MAXSTR,
        NULL );

    return ErrorMsg;
}

LONG
GetGuids(
    IN LPTSTR GuidFile, 
    IN OUT LPGUID *GuidArray
)
/*++

Routine Description:

    Reads GUIDs from a file and stores them in an GUID array.

Arguments:

    GuidFile - The file containing GUIDs. 
    GuidArray - The GUID array that will have GUIDs read from the file.

Return Value:

    ULONG - The number of GUIDs processed.


--*/
{
    FILE *f;
    TCHAR line[MAXSTR], arg[MAXSTR];
    LPGUID Guid;
    int i, n;

    f = _tfopen((TCHAR*)GuidFile, _T("r"));

    if (f == NULL)
        return -1;

    n = 0;
    while ( _fgetts(line, MAXSTR, f) != NULL ) {
        if (_tcslen(line) < 36)
            continue;
        if (line[0] == ';'  || 
            line[0] == '\0' || 
            line[0] == '#' || 
            line[0] == '/')
            continue;
        Guid = (LPGUID) GuidArray[n];
        n ++;

        _tcsncpy(arg, line, 8);
        arg[8] = 0;
        Guid->Data1 = ahextoi(arg);
        _tcsncpy(arg, &line[9], 4);
        arg[4] = 0;
        Guid->Data2 = (USHORT) ahextoi(arg);
        _tcsncpy(arg, &line[14], 4);
        arg[4] = 0;
        Guid->Data3 = (USHORT) ahextoi(arg);

        for (i=0; i<2; i++) {
            _tcsncpy(arg, &line[19 + (i*2)], 2);
            arg[2] = 0;
            Guid->Data4[i] = (UCHAR) ahextoi(arg);
        }
        for (i=2; i<8; i++) {
            _tcsncpy(arg, &line[20 + (i*2)], 2);
            arg[2] = 0;
            Guid->Data4[i] = (UCHAR) ahextoi(arg);
        }
    }
    return (ULONG)n;
}

ULONG 
ahextoi(
    IN TCHAR *s
    )
/*++

Routine Description:

    Converts a hex string into a number.

Arguments:

    s - A hex string in TCHAR. 

Return Value:

    ULONG - The number in the string.


--*/
{
    int len;
    ULONG num, base, hex;

    len = _tcslen(s);
    hex = 0; base = 1; num = 0;
    while (--len >= 0) {
        if ( (s[len] == 'x' || s[len] == 'X') &&
             (s[len-1] == '0') )
            break;
        if (s[len] >= '0' && s[len] <= '9')
            num = s[len] - '0';
        else if (s[len] >= 'a' && s[len] <= 'f')
            num = (s[len] - 'a') + 10;
        else if (s[len] >= 'A' && s[len] <= 'F')
            num = (s[len] - 'A') + 10;
        else 
            continue;

        hex += num * base;
        base = base * 16;
    }
    return hex;
}


void 
StringToGuid(
    IN TCHAR *str, 
    IN OUT LPGUID guid
)
/*++

Routine Description:

    Converts a string into a GUID.

Arguments:

    str - A string in TCHAR.
    guid - The pointer to a GUID that will have the converted GUID.

Return Value:

    None.


--*/
{
    TCHAR temp[10];
    int i, n;

    temp[8]=_T('\0');
    _tcsncpy(temp, str, 8);
    _stscanf(temp, _T("%x"), &(guid->Data1));

    temp[4]=_T('\0');
    _tcsncpy(temp, &str[9], 4);
    _stscanf(temp, _T("%x"), &(guid->Data2));

    _tcsncpy(temp, &str[14], 4);
    _stscanf(temp, _T("%x"), &(guid->Data3));

    temp[2]='\0';
    for(i=0;i<8;i++)
    {
        temp[0]=str[19+((i<2)?2*i:2*i+1)]; // to accomodate the minus sign after
        temp[1]=str[20+((i<2)?2*i:2*i+1)]; // the first two chars
        _stscanf(temp, _T("%x"), &n);      // if used more than byte alloc
        guid->Data4[i]=(unsigned char)n;   // causes overrun of memory
    }
}

void PrintHelpMessage()
/*++

Routine Description:

    prints out a help message.

Arguments:

    None.

Return Value:

    None.


--*/
{
    _tprintf(_T("Usage: tracelog [actions] [options] | [-h | -help | -?]\n"));
    _tprintf(_T("\n    actions:\n"));
    _tprintf(_T("\t-start   [LoggerName] Starts up the [LoggerName] trace session\n"));
    _tprintf(_T("\t-stop    [LoggerName] Stops the [LoggerName] trace session\n"));
    _tprintf(_T("\t-update  [LoggerName] Updates the [LoggerName] trace session\n"));
    _tprintf(_T("\t-enable  [LoggerName] Enables providers for the [LoggerName] session\n"));
    _tprintf(_T("\t-disable [LoggerName] Disables providers for the [LoggerName] session\n"));
    if (XP) {
        _tprintf(_T("\t-flush   [LoggerName] Flushes the [LoggerName] active buffers\n"));
        _tprintf(_T("\t-enumguid             Enumerate Registered Trace Guids\n"));
    }
    _tprintf(_T("\t-q       [LoggerName] Query status of [LoggerName] trace session\n"));
    _tprintf(_T("\t-l                    List all trace sessions\n"));
    _tprintf(_T("\t-x                    Stops all active trace sessions\n"));

    _tprintf(_T("\n    options:\n"));
    _tprintf(_T("\t-b   <n>              Sets buffer size to <n> Kbytes\n"));
    _tprintf(_T("\t-min <n>              Sets minimum buffers\n"));
    _tprintf(_T("\t-max <n>              Sets maximum buffers\n"));
    _tprintf(_T("\t-f <name>             Log to file <name>\n"));
    if (XP) {
        _tprintf(_T("\t-append <name>        Append to file <name>\n"));
    }
    _tprintf(_T("\t-seq <n>              Sequential logfile of up to n Mbytes\n"));
    _tprintf(_T("\t-cir <n>              Circular logfile of n Mbytes\n"));
    if (XP) {
        _tprintf(_T("\t-newfile <n>          Log to a new file after every n Mbytes\n"));
    }
    _tprintf(_T("\t-ft <n>               Set flush timer to n seconds\n"));
    if (XP) {
        _tprintf(_T("\t-paged                Use pageable memory for buffers\n"));
    }
    _tprintf(_T("\t-noprocess            Disable Process Start/End tracing\n"));
    _tprintf(_T("\t-nothread             Disable Thread Start/End tracing\n"));
    _tprintf(_T("\t-nodisk               Disable Disk I/O tracing\n"));
    _tprintf(_T("\t-nonet                Disable Network TCP/IP tracing\n"));
    _tprintf(_T("\t-fio                  Enable file I/O tracing\n"));
    _tprintf(_T("\t-pf                   Enable page faults tracing\n"));
    _tprintf(_T("\t-hf                   Enable hard faults tracing\n"));
    _tprintf(_T("\t-img                  Enable image load tracing\n"));
    _tprintf(_T("\t-cm                   Enable registry calls tracing\n"));
    _tprintf(_T("\t-um                   Enable Process Private tracing\n"));
    _tprintf(_T("\t-guid <file>          Start tracing for providers in file\n"));
    _tprintf(_T("\t-rt                   Enable tracing in real time mode\n"));
    _tprintf(_T("\t-age <n>              Modify aging decay time to n minutes\n"));
    _tprintf(_T("\t-level <n>            Enable Level passed to the providers\n"));
    _tprintf(_T("\t-flag <n>             Enable Flags passed to the providers\n"));
    _tprintf(_T("\n"));
    _tprintf(_T("\t-h\n"));
    _tprintf(_T("\t-help\n"));
    _tprintf(_T("\t-?                    Display usage information\n"));
}


PTCHAR 
GuidToString(
    IN OUT PTCHAR s,
    LPGUID piid
    )
/*++

Routine Description:

    Converts a GUID into a string.

Arguments:

    s - A string in TCHAR that will have the converted GUID.
    piid - The pointer to a GUID.

Return Value:

    PTCHAR - The string containig the convereted GUID.


--*/
{
    _stprintf(s, _T("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"),
               piid->Data1, piid->Data2,
               piid->Data3,
               piid->Data4[0], piid->Data4[1],
               piid->Data4[2], piid->Data4[3],
               piid->Data4[4], piid->Data4[5],
               piid->Data4[6], piid->Data4[7]);
    return(s);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\sdksamples\tracedp\tracedp.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    tracedp.c

Abstract:

    Sample trace provider program.

--*/

#include <stdio.h> 
#include <stdlib.h>

#include <windows.h>
#include <shellapi.h>

#include <tchar.h>
#include <ntverp.h>
#include <fcntl.h>
#include <wmistr.h>

#include <guiddef.h>
#include <evntrace.h>

#define MAXEVENTS                       5000
#define MAXSTR                          1024
#define MAXTHREADS                      128

// sample string data
#define WIDE_DATA_STRING           L"Sample Wide String"
#define COUNTED_DATA_STRING        L"Sample Counted String"

TRACEHANDLE LoggerHandle;
#define ResourceName _T("MofResource")
TCHAR ImagePath[MAXSTR];

GUID TransactionGuid = 
    {0xce5b1020, 0x8ea9, 0x11d0, 0xa4, 0xec, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10};
GUID   ControlGuid[2]  =
{
    {0xd58c126f, 0xb309, 0x11d1, 0x96, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa5, 0xbc},
    {0x7c6a708a, 0xba1e, 0x11d2, 0x8b, 0xbf, 0x00, 0x00, 0xf8, 0x06, 0xef, 0xe0}
};

TRACE_GUID_REGISTRATION TraceGuidReg[] =
{
    { (LPGUID)&TransactionGuid,
      NULL
    }
};

typedef enum {
    TYPE_USER_EVENT,
    TYPE_INSTANCE_EVENT,
    TYPE_MOF_EVENT,
    TYPEPTR_GUID
} TypeEventType;

typedef struct _USER_EVENT {
    EVENT_TRACE_HEADER    Header;
    ULONG                 EventInfo;
} USER_EVENT, *PUSER_EVENT;

typedef struct _USER_INSTANCE_EVENT {
    EVENT_INSTANCE_HEADER    Header;
    ULONG                    mofData;
} USER_INSTANCE_EVENT, *PUSER_INSTANCE_EVENT;

// customized event to use sample data that follow
typedef struct _USER_MOF_EVENT {
    EVENT_TRACE_HEADER    Header;
    MOF_FIELD             mofData;
} USER_MOF_EVENT, *PUSER_MOF_EVENT;

// sample data structure
typedef struct _INTEGER_SAMPLE_EVENT {
    CHAR                  sc;
    UCHAR                 uc;
    SHORT                 sh;
    ULONG                 ul;
} INTEGER_SAMPLE_EVENT, *PINTEGER_SAMPLE_EVENT;

typedef struct _FLOAT_SAMPLE_EVENT {
    float                 fl;
    double                db;
} FLOAT_SAMPLE_EVENT, *PFLOAT_SAMPLE_EVENT;

typedef struct _ARRAY_SAMPLE_EVENT {
    CHAR                  ca[9];
} ARRAY_SAMPLE_EVENT, *PARRAY_SAMPLE_EVENT;

TypeEventType EventType = TYPE_USER_EVENT;
TRACEHANDLE RegistrationHandle[2];
BOOLEAN TraceOnFlag;
ULONG EnableLevel = 0;
ULONG EnableFlags = 0;
ULONG nSleepTime = 0;
ULONG EventCount = 0;

BOOLEAN  bInstanceTrace=0, bUseGuidPtr=0, bUseMofPtr=0;
BOOLEAN  bIncorrect  = FALSE;
BOOLEAN  bUseNullPtr = FALSE;
BOOLEAN  bFirstTime = TRUE;

ULONG InitializeTrace(
    void
    );

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

LPTSTR
DecodeStatus(
    IN ULONG Status
    );


void
LogProc();

LPTSTR
GuidToString(
        LPTSTR s,
        LPGUID piid
        );

TCHAR ErrorMsg[MAXSTR];
ULONG    MaxEvents = MAXEVENTS;

ULONG  gnMultiReg=1;
BOOLEAN RegistrationSuccess;

__inline
__int64
GetCycleCount()
{
#if defined(_X86_)
    __asm   _emit   0x0F
    __asm   _emit   0x31    /* rdtsc */
    // returns edx:eax
#elif defined(_AMD64_)
    return ReadTimeStampCounter();
#elif defined(_IA64_)
    return __getReg(CV_IA64_ApITC);
#else
#error  "no build target defined"
#endif
}

void StringToGuid(
    TCHAR *str, 
    LPGUID guid
)
/*++

Routine Description:

    Converts a String into a GUID.

Arguments:

    str - String representing a GUID.
    guid - Pointer to a GUID for ourput

Return Value:

    None.

--*/
{
    TCHAR temp[10];
    int i, n;

    temp[8]=_T('\0');
    _tcsncpy(temp, str, 8);
    _stscanf(temp, _T("%x"), &(guid->Data1));

    temp[4]=_T('\0');
    _tcsncpy(temp, &str[9], 4);
    _stscanf(temp, _T("%x"), &(guid->Data2));

    _tcsncpy(temp, &str[14], 4);
    _stscanf(temp, _T("%x"), &(guid->Data3));

    temp[2]='\0';
    for(i=0;i<8;i++)
    {
        temp[0]=str[19+((i<2)?2*i:2*i+1)]; // to accomodate the minus sign after
        temp[1]=str[20+((i<2)?2*i:2*i+1)]; // the first two chars
        _stscanf(temp, _T("%x"), &n);      // if used more than byte alloc
        guid->Data4[i]=(unsigned char)n;   // causes overrun of memory
    }
}

__cdecl main(argc, argv)
    int argc;
    char **argv;
/*++

Routine Description:

    main() routine.

Arguments:

    Usage: TraceDp [options] [number of events]
                -UseEventTraceHeader        this is default.
                -UseEventInstanceHeader
                -UseMofPtrFlag
                -Thread [n]                 Sets the number of event-generating threads.
                -GuidPtr                    Use GUID pointer instead of GUID itself.
                -MofPtr                     Use MOF pointer for additional data.
                -GuidPtrMofPtr              User GUID pointer and MOF pointer.
                -InCorrectMofPtr            Use incorrect MOF pointer (Creates an error case).
                -NullMofPtr                 Use NULL MOF pointer (Creates an error case).
                -MultiReg                   Register multiple event GUIDS.
                -Sleep [n]                  Sets the sleep time before unregistering.
                [number of events] default is 5000

Return Value:

        Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS (== 0).

--*/
{
    ULONG status;
    LPGUID  Guid = NULL;
    DWORD ThreadId;
    HANDLE hThreadVector[MAXTHREADS];
    ULONG i;
    ULONG nThreads = 1;
    LPTSTR *targv;

    MaxEvents = MAXEVENTS;
    TraceOnFlag = FALSE;

#ifdef UNICODE
    if ((targv = CommandLineToArgvW(
                      GetCommandLineW(),    // pointer to a command-line string
                      &argc                 // receives the argument count
                      )) == NULL)
    {
        return(GetLastError());
    };
#else
    targv = argv;
#endif

    // process command line arguments to override defaults
    //
    while (--argc > 0)
    {
        targv ++;
        if (**targv == '-' || **targv == '/')
        {
            if(targv[0][0] == '/' ) targv[0][0] = '-';
            if (!_tcsicmp(targv[0],_T("-UseEventTraceHeader")))
            {
                EventType = TYPE_USER_EVENT;
            }
            else if (!_tcsicmp(targv[0],_T("-UseEventInstanceHeader")))
            {
                EventType = TYPE_INSTANCE_EVENT;
            }
            else if (!_tcsicmp(targv[0],_T("-UseMofPtrFlag")))
            {
                EventType = TYPE_MOF_EVENT;
            }
            else if (!_tcsicmp(targv[0],_T("-Thread")))
            {
                if (argc > 1) {
                    targv++; --argc;
                    nThreads = _ttoi(targv[0]);
                    if (nThreads > MAXTHREADS) 
                        nThreads = MAXTHREADS;
                }
            }
             else if (!_tcsicmp(targv[0],_T("-GuidPtr")))
            {
                bUseGuidPtr = TRUE;
            }
            else if (!_tcsicmp(targv[0],_T("-MofPtr")))
            {
                bUseMofPtr = TRUE;
            }
            else if (!_tcsicmp(targv[0],_T("-GuidPtrMofPtr")))
            {
                bUseGuidPtr = TRUE;
                bUseMofPtr  = TRUE;
            }
            else if (!_tcsicmp(targv[0],_T("-InCorrectMofPtr")))
            {
                bUseMofPtr  = TRUE;
                bIncorrect  = TRUE;
            }
            else if (!_tcsicmp(targv[0],_T("-NullMofPtr")))
            {
                bUseMofPtr  = TRUE;
                bUseNullPtr = TRUE;
                bIncorrect  = TRUE;;
            }
            else if (!_tcsicmp(targv[0],_T("-MultiReg")))
            {
                gnMultiReg = 2;
            }
            else if (!_tcsicmp(targv[0], _T("-guid"))) {
                if (argc > 1) {
                    if (targv[1][0] == _T('#')) {
                        StringToGuid(&targv[1][1], &ControlGuid[0]);
                        ++targv; --argc;
                    }
                }
            }
            else if (!_tcsicmp(targv[0],_T("-Sleep")))
            {
                if (argc > 1) {
                    targv++; --argc;
                    nSleepTime = _ttoi(targv[0]);
                }
            }
            else
            {
                printf("Usage: TraceDp [options] [number of events]\n");
                printf("\t-UseEventTraceHeader        this is default.\n");
                printf("\t-UseEventInstanceHeader\n");
                printf("\t-UseMofPtrFlag\n");
                printf("\t-Thread [n]\n");
                printf("\t-GuidPtr\n");
                printf("\t-MofPtr\n");
                printf("\t-GuidPtrMofPtr\n");
                printf("\t-InCorrectMofPtr\n");
                printf("\t-NullMofPtr\n");
                printf("\t-MultiReg\n");
                printf("\t-Sleep [n]\n");
                printf("\t[number of events] default is 5000\n");

                return 0;
            }
        }
        else if (** targv >= '0' && ** targv <= '9')
        {
            MaxEvents = _ttoi(targv[0]);
        }
    }

    status = InitializeTrace();
    if (status != ERROR_SUCCESS) {
       return 0;
    }

    while (! TraceOnFlag)
        _sleep(1000);

    for (i=0; i < nThreads; i++) {
        hThreadVector[i] = CreateThread(NULL,
                    0,
                    (LPTHREAD_START_ROUTINE) LogProc,
                    NULL,
                    0,
                    (LPDWORD)&ThreadId);
    }

    WaitForMultipleObjects(nThreads, hThreadVector, TRUE, INFINITE);

    if (nSleepTime > 0) {
        _sleep(nSleepTime * 1000);
    }

    for (i=0; i<gnMultiReg; i++)  {
        UnregisterTraceGuids(RegistrationHandle[i]);
    }

    return status;
}

LPTSTR
DecodeStatus(
    IN ULONG Status
)
/*++

Routine Description:

    Decodes error status.

Arguments:

    Status - Return status of function calls to be decoded.

Return Value:

    Pointer to a decoded error message.

--*/
{
    memset( ErrorMsg, 0, MAXSTR );
    FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        Status,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) ErrorMsg,
        MAXSTR,
        NULL );
    return ErrorMsg;
}

ULONG InitializeTrace(
    void
)
/*++

Routine Description:

    Register traces.

Arguments:

Return Value:

    Error Status. ERROR_SUCCESS if successful.

--*/
{
    ULONG Status;
    ULONG i, j;

    Status = GetModuleFileName(NULL, &ImagePath[0], MAXSTR*sizeof(TCHAR));
    if (Status == 0) {
        return (ERROR_FILE_NOT_FOUND);
    }

    for (i=0; i<gnMultiReg; i++) {
        Status = RegisterTraceGuids(
                    (WMIDPREQUEST)ControlCallback,   //use same callback function
                    (PVOID)(INT_PTR)(0x12345678+i),  // RequestContext
                    (LPCGUID)&ControlGuid[i],
                    1,
                    &TraceGuidReg[i],
                    (LPCTSTR)&ImagePath[0],
                    (LPCTSTR)ResourceName,
                    &RegistrationHandle[i]
                 );

        if (Status != ERROR_SUCCESS) {
            _tprintf(_T("Trace registration failed\n"));
            RegistrationSuccess = FALSE;
            if( i > 0) {
                for (j=0; j<i; j++) {
                    UnregisterTraceGuids(RegistrationHandle[i]);
                }
            }
            _tprintf(_T("InitializeTrace failed. i=%d, status=%d, %s\n"), i, Status, DecodeStatus(Status));
            return(Status);
        }
        else {
            _tprintf(_T("Trace registered successfully\n"));
            RegistrationSuccess = TRUE;
        }
    }

    return(Status);
}

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
)
/*++

Routine Description:

    Callback function when enabled.

Arguments:

    RequestCode - Flag for either enable or disable.
    Context - User-defined context.
    InOutBufferSize - not used.
    Buffer - WNODE_HEADER for the logger session.

Return Value:

    Error Status. ERROR_SUCCESS if successful.

--*/
{
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            RetSize = 0;
            LoggerHandle = GetTraceLoggerHandle( Buffer );
            EnableLevel = GetTraceEnableLevel(LoggerHandle);
            EnableFlags = GetTraceEnableFlags(LoggerHandle);
            _tprintf(_T("Logging enabled to 0x%016I64x(%d,%d,%d)\n"),
                    LoggerHandle, RequestCode, EnableLevel, EnableFlags);
            TraceOnFlag = TRUE;
            break;
        }
        case WMI_DISABLE_EVENTS:
        {
            TraceOnFlag = FALSE;
            RetSize = 0;
            LoggerHandle = 0;
            _tprintf(_T("\nLogging Disabled\n"));
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = RetSize;
    return(Status);
}

void
LogProc()
/*++

Routine Description:

    Generates events. It is spawned as separate threads.
    Based on the options given by users, it generates different events.

Arguments:

Return Value:

    None.

--*/
{
    USER_EVENT          UserEvent;
    USER_INSTANCE_EVENT UserInstanceEvent;
    USER_MOF_EVENT      UserMofEvent;
    EVENT_INSTANCE_INFO InstInfo;
    PMOF_FIELD          mofField;
    ULONG i;
    PWNODE_HEADER Wnode;
    ULONG status;
    LPGUID Guid = NULL;
    ULONG nTemp;
    USHORT nSize, nStrEventSize;
    WCHAR wstrTemp[MAXSTR];

    INTEGER_SAMPLE_EVENT ise;
    FLOAT_SAMPLE_EVENT fse;
    ARRAY_SAMPLE_EVENT ase;
    CHAR *sse, *ptr;

	__int64 StartTime, EndTime;

    // some arbitrary data for MOF structs
    ise.sc = 'x';
    ise.uc = 'y';
    ise.sh = (SHORT)rand();
    ise.ul = (ULONG)rand();

    nTemp = 0;
    while (nTemp == 0) {
        nTemp = rand();
    }

    fse.fl = ((float)rand() / (float)nTemp);
    fse.db = ((double)rand() / (double)nTemp);

    ase.ca[0] = 'M';
    ase.ca[1] = 'i';
    ase.ca[2] = 'c';
    ase.ca[3] = 'r';
    ase.ca[4] = 'o';
    ase.ca[5] = 's';
    ase.ca[6] = 'o';
    ase.ca[7] = 'f';
    ase.ca[8] = 't';

    nStrEventSize = ((wcslen(WIDE_DATA_STRING) + 1) * sizeof(WCHAR)) + sizeof(SHORT) + (wcslen(COUNTED_DATA_STRING) * sizeof(WCHAR));
    sse = (PCHAR) malloc(nStrEventSize);

    if (NULL != sse) {
        ptr = sse;
        wcscpy(wstrTemp, WIDE_DATA_STRING);
        wstrTemp[wcslen(WIDE_DATA_STRING)] = L'\0';
        memcpy(ptr, wstrTemp, (wcslen(WIDE_DATA_STRING) + 1) * sizeof(WCHAR));
        ptr += (wcslen(WIDE_DATA_STRING) + 1) * sizeof(WCHAR);
        nSize = (USHORT)(wcslen(COUNTED_DATA_STRING) * sizeof(WCHAR));
        memcpy(ptr, &nSize, sizeof(USHORT));
        ptr += sizeof(USHORT);
        wcscpy(wstrTemp, COUNTED_DATA_STRING);
        memcpy(ptr, wstrTemp, wcslen(COUNTED_DATA_STRING) * sizeof(WCHAR));
    }

    RtlZeroMemory(&UserEvent, sizeof(UserEvent));
    Wnode = (PWNODE_HEADER) &UserEvent;
    UserEvent.Header.Size  = sizeof(USER_EVENT);
    UserEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;
    UserEvent.Header.Guid  =  TransactionGuid;

    RtlZeroMemory(&UserInstanceEvent, sizeof(UserInstanceEvent));
    UserInstanceEvent.Header.Size  = sizeof(UserInstanceEvent);
    UserInstanceEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;

    RtlZeroMemory(&UserMofEvent, sizeof(UserMofEvent));
    Wnode = (PWNODE_HEADER) &UserMofEvent;
    UserMofEvent.Header.Size  = sizeof(UserMofEvent);
    UserMofEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;
    UserMofEvent.Header.Guid  = TransactionGuid;
    if (bUseGuidPtr) {
        UserEvent.Header.Flags  |= WNODE_FLAG_USE_GUID_PTR;
        UserEvent.Header.GuidPtr = (ULONGLONG)&TransactionGuid;
        UserMofEvent.Header.Flags  |= WNODE_FLAG_USE_GUID_PTR;
        UserMofEvent.Header.GuidPtr = (ULONGLONG)&TransactionGuid;
    }

    i = 0;
    while (TraceOnFlag) {
        if ((i % 4) == 0) {
            UserEvent.Header.Class.Type         = EVENT_TRACE_TYPE_START;
            UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_START;
            UserMofEvent.Header.Class.Type      = 1;
        }
        else if ((i % 4) == 1) {
            UserEvent.Header.Class.Type         = EVENT_TRACE_TYPE_END;
            UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_END;
            UserMofEvent.Header.Class.Type      = 2;
        }
        else if ((i % 4) == 2) {
            UserEvent.Header.Class.Type         = EVENT_TRACE_TYPE_START;
            UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_START;
            UserMofEvent.Header.Class.Type      = 3;
        }
        else {
            UserEvent.Header.Class.Type         = EVENT_TRACE_TYPE_END;
            UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_END;
            UserMofEvent.Header.Class.Type      = 4;
        }

        switch (EventType)
        {
        case TYPE_INSTANCE_EVENT:
            if (UserInstanceEvent.Header.Class.Type == EVENT_TRACE_TYPE_START) {
                status = CreateTraceInstanceId(
                                (PVOID) TraceGuidReg[0].RegHandle,
                                & InstInfo);

                if (status != ERROR_SUCCESS) {
                    fprintf(stderr, 
                             "CreatTraceInstanceId() status=%d, %s\n",
                              status, DecodeStatus(status)
                             );
                    return; 
                }
            }
			StartTime = GetCycleCount();
            status = TraceEventInstance(
                        LoggerHandle, 
                        (PEVENT_INSTANCE_HEADER) & UserInstanceEvent,
                        & InstInfo,
                        NULL);
			EndTime = GetCycleCount();
			fprintf(stdout, "# of cycles: %d\n", EndTime - StartTime);
            break;

        case TYPE_USER_EVENT:
            UserEvent.EventInfo = InterlockedIncrement(&EventCount);
			StartTime = GetCycleCount();
            status = TraceEvent(
                            LoggerHandle,
                            (PEVENT_TRACE_HEADER) & UserEvent);
			EndTime = GetCycleCount();
			fprintf(stdout, "# of cycles: %d\n", EndTime - StartTime);
            break;

        case TYPE_MOF_EVENT:
            UserMofEvent.Header.Flags |= WNODE_FLAG_USE_MOF_PTR;
            mofField          = (PMOF_FIELD) & UserMofEvent.mofData;
            if (UserMofEvent.Header.Class.Type == 2) {
                mofField->DataPtr = (ULONGLONG) (&ise);
                mofField->Length  = sizeof(INTEGER_SAMPLE_EVENT);
            }
            else if (UserMofEvent.Header.Class.Type == 3) {
                mofField->DataPtr = (ULONGLONG) (&fse);
                mofField->Length  = sizeof(FLOAT_SAMPLE_EVENT);
            }
            else if (UserMofEvent.Header.Class.Type == 4) {
                mofField->DataPtr = (ULONGLONG) (&ase);
                mofField->Length  = sizeof(ARRAY_SAMPLE_EVENT);
            }
            else {
                mofField->DataPtr = (ULONGLONG) (sse);
                mofField->Length  = nStrEventSize;
            }
            if (bUseNullPtr)
                mofField->DataPtr = (ULONGLONG) (NULL);
            if (bIncorrect)
                mofField->Length  += 1000;
			// measuring
			StartTime = GetCycleCount();
            status = TraceEvent(
                            LoggerHandle,
                            (PEVENT_TRACE_HEADER) & UserMofEvent);
			EndTime = GetCycleCount();
            if (status != ERROR_SUCCESS) {
                fprintf(stderr, "Error(%d) while writing event.\n", status);
            }
			else {
				fprintf(stdout, "# of cycles: %d\n", EndTime - StartTime);
			}
            break;

        default:
            status = ERROR_SUCCESS;
            break;
        }

        // logger buffers out of memory should not prevent provider from
        // generating events. This will only cause events lost.
        //
        if (status == ERROR_NOT_ENOUGH_MEMORY) {
            status = ERROR_SUCCESS;
        }

        if (status != ERROR_SUCCESS) {
            _ftprintf(stderr, _T("\nError %s while writing event\n"),
                      DecodeStatus(status));
            _ftprintf( stderr, _T("Use GUID to disable Logger\n"));
            _ftprintf( stderr, _T("Logging Terminated\n"));
            return;
        }

        i++;
        if (i >= MaxEvents)
            break;

        if (!(i % 100))
            _tprintf(_T("."));
        _sleep(1);
    }
}

LPTSTR
GuidToString(
        LPTSTR s,
        LPGUID piid
        )
/*++

Routine Description:

    Converts a GUID into a string.

Arguments:

    s - String that will have the converted GUID.
    piid - GUID

Return Value:

    None.

--*/
{
    _stprintf(s, _T("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"),
               piid->Data1,
               piid->Data2,
               piid->Data3,
               piid->Data4[0],
               piid->Data4[1],
               piid->Data4[2],
               piid->Data4[3],
               piid->Data4[4],
               piid->Data4[5],
               piid->Data4[6],
               piid->Data4[7]);
    return(s);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracectr\api.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    api.c

Abstract:

    Manipulation routines for cpdata structures.

Author:

    Melur Raghuraman (mraghu) 03-Oct-1997

Environment:

Revision History:


--*/
#include <stdio.h>
#include "cpdata.h"
#include "tracectr.h"

extern PTRACE_CONTEXT_BLOCK TraceContext;

extern PWCHAR CpdiGuidToString(PWCHAR s, LPGUID piid);

HRESULT
CPDAPI
GetTempName( LPTSTR strFile, DWORD dwSize )
{
    HRESULT hr;
    GUID guid;
    UNICODE_STRING strGUID;
    WCHAR buffer[MAXSTR];

    hr = UuidCreate( &guid );
    if( !( hr == RPC_S_OK || hr == RPC_S_UUID_LOCAL_ONLY ) ){
        return hr;
    }

    hr = RtlStringFromGUID( &guid, &strGUID );
    if( ERROR_SUCCESS != hr ){
        return hr;
    }

    _stprintf( buffer, _T("%%temp%%\\%s"), strGUID.Buffer );

    if( ! ExpandEnvironmentStrings( buffer, strFile, dwSize ) ){
        hr = GetLastError();
    }

   RtlFreeUnicodeString( &strGUID );
   return hr;
}

ULONG
GetTraceTransactionInfo(
    OUT PVOID TraceInformation,
    IN ULONG  TraceInformationLength,
    OUT PULONG Length,
    IN ULONG   InstanceCount,
    IN LPCWSTR  *InstanceNames,
    IN ULONG TraceInformationClass,
    IN BOOLEAN bDrillDown
    );
ULONG
DrillDownDisk(
    IN  PTDISK_RECORD DiskRecord,
    IN  ULONG        TraceInformationClass,
    OUT PVOID        DiskInformation,
    IN  ULONG        DiskInformationLength,
    OUT PULONG       Length
    );

ULONG 
GetTraceProcessInfo (
    OUT PVOID ProcessInformation,
    IN ULONG  ProcessInformationLength,
    OUT PULONG Length,
    IN ULONG InstanceCount,
    IN LPCWSTR *InstanceNames,
    IN ULONG TraceInformationClass,
    IN BOOLEAN bDrillDown
    );

// Same for File information.
//
ULONG 
GetTraceFileInfo (
    OUT PVOID FileInformation,
    IN ULONG  FileInformationLength,
    OUT PULONG Length,
    IN ULONG InstanceCount,
    IN LPCWSTR *InstanceNames,
    IN ULONG TraceInformationClass,
    IN BOOLEAN bDrillDown
    );

ULONG 
GetTraceDiskInfo (
    OUT PVOID DiskInformation,
    IN ULONG  DiskInformationLength,
    OUT PULONG Length,
    IN ULONG InstanceCount,
    IN LPCWSTR *InstanceNames,
    IN ULONG TraceInformationClass,
    IN BOOLEAN bDrillDown
    );

ULONG 
GetTraceModuleInfo(
    OUT PVOID           ModuleInformation,
    IN  ULONG           ModuleInformationLength,
    OUT PULONG          Length,
    OUT PVOID         * ppModuleLast,
    IN  PPROCESS_RECORD pProcess,
    IN  PLIST_ENTRY     pModuleListHead,
    IN  ULONG           lOffset
    );

ULONG
GetTraceProcessFaultInfo(
    OUT PVOID   ProcessFaultInformation,
    IN  ULONG   ProcessFaultInformationLength,
    OUT PULONG  Length
    );

ULONG 
GetTraceProcessModuleInfo (
    OUT PVOID       ModuleInformation,
    IN  ULONG       ModuleInformationLength,
    OUT PULONG      Length,
    IN  ULONG       InstanceCount,
    IN  LPCWSTR    * InstanceNames
    );

static void 
CopyProcessInfo (
    OUT PTRACE_PROCESS_INFOW ProcessInfo, 
    IN  PPROCESS_RECORD     Process
    );

static void 
CopyDiskInfo (
    OUT PTRACE_DISK_INFOW DiskInfo,
    IN  PTDISK_RECORD DiskRecord
    );

static void 
CopyFileInfo (
    OUT PTRACE_FILE_INFOW FileInfo,
    IN  PFILE_RECORD FileRecord
    );

BOOLEAN
MatchInstance(
    IN LPCWSTR CurrentInstance,
    IN ULONG  InstanceCount,
    IN LPCWSTR *InstanceNames
    );

BOOLEAN
MatchDisk(
    IN ULONG CurrentInstance,
    IN ULONG InstanceCount,
    IN LPCSTR *InstanceNames
    );

ULONG 
CPDAPI
TraceSetTimer(
    IN ULONG FlushTimer
    )
{
    if (TraceContext != NULL) {
        TraceContext->LoggerInfo->FlushTimer = FlushTimer;
    }
    return ERROR_SUCCESS;
     
}

ULONG
CPDAPI
TraceQueryAllInstances(
    IN TRACEINFOCLASS TraceInformationClass,
    OUT PVOID TraceInformation,
    IN ULONG TraceInformationLength,
    OUT PULONG Length
    )
{
    ULONG              status      = ERROR_INVALID_PARAMETER;
    PTRACE_MODULE_INFO pModuleLast = NULL;

    if (TraceInformation != NULL && TraceInformationLength > 0) {
        switch (TraceInformationClass) {
        case TraceProcessInformation:
            status = GetTraceProcessInfo(TraceInformation,
                                         TraceInformationLength,
                                         Length,
                                         0, NULL, 0, FALSE);
            break;
        case TraceFileInformation:
            status = GetTraceFileInfo(TraceInformation,
                                      TraceInformationLength,
                                      Length, 0, NULL, 0, FALSE);
            break;

        case TraceDiskInformation:
            status = GetTraceDiskInfo(TraceInformation,
                                      TraceInformationLength,
                                      Length, 0, NULL, 0, FALSE);
            break;

        case TraceTransactionInformation:
            status = GetTraceTransactionInfo(TraceInformation,
                                             TraceInformationLength,
                                             Length, 0, NULL, 0, FALSE);
            break;
        case TraceProcessPageFaultInformation:
            status = GetTraceProcessFaultInfo(TraceInformation,
                                              TraceInformationLength,
                                              Length);
            break;

        case TraceModuleInformation:
            status = GetTraceModuleInfo(TraceInformation,
                                        TraceInformationLength,
                                        Length,
                                        (PVOID *) & pModuleLast,
                                        NULL,
                                      & CurrentSystem.GlobalModuleListHead,
                                        0);
            if (pModuleLast != NULL) {
                pModuleLast->NextEntryOffset = 0;
            }
            break;
        }
    }
    return status;
}


ULONG 
CPDAPI
TraceQueryInstanceW (
                IN TRACEINFOCLASS TraceInformationClass,
                IN ULONG InstanceCount,
                IN LPCWSTR *InstanceNames,
                OUT PVOID TraceInformation,
                IN  ULONG TraceInformationLength,
                OUT PULONG Length
                )
{
    if (TraceInformation == NULL || TraceInformationLength == 0)
        return ERROR_INVALID_PARAMETER;

    switch(TraceInformationClass) {
        case TraceProcessInformation:

                return GetTraceProcessInfo(TraceInformation,
                                           TraceInformationLength,
                                           Length,
                                           InstanceCount, 
                                           InstanceNames,
                                           0, FALSE);
                break;

        case TraceFileInformation:
                return GetTraceFileInfo(TraceInformation,
                                           TraceInformationLength,
                                           Length,
                                           InstanceCount, 
                                           InstanceNames,
                                           0, FALSE);
                break;

		case TraceDiskInformation:
				return GetTraceDiskInfo(TraceInformation,
                                           TraceInformationLength,
                                           Length,
                                           InstanceCount, 
                                           InstanceNames,
                                           0, FALSE);
                break;

        case TraceModuleInformation:
                return GetTraceProcessModuleInfo(TraceInformation,
                                                 TraceInformationLength,
                                                 Length,
                                                 InstanceCount,
                                                 InstanceNames);
                break;
    }
    return 0;
}

ULONG
DrillDownProcess(
    IN PPROCESS_RECORD ProcessRecord,
    IN ULONG TraceInformationClass,
    OUT PVOID DiskInformation,
    IN ULONG DiskInformationLength,
    OUT PULONG Length
    )
{
    PLIST_ENTRY         Next, Head;
    PTDISK_RECORD        DiskRecord      = NULL;
    PFILE_RECORD        pFile           = NULL;
    ULONG               TotalSize       = 0;
    ULONG               NextEntryOffset = 0;
    PTRACE_DISK_INFOW    DiskInfo        = NULL;
    PTRACE_FILE_INFOW   FileInfo        = NULL;
    ULONG               status          = 0;
    ULONG               EntrySize       = 0;
    ULONG               len             = 0;
    PVOID               s;
    char *              t;

    if (ProcessRecord == NULL)
        return ERROR_INVALID_PARAMETER;

    switch (TraceInformationClass)
    {
    case TraceDiskInformation:
        Head      = & ProcessRecord->DiskListHead;
        EntrySize = sizeof(TRACE_DISK_INFOW);
        break;

    case TraceFileInformation:
        Head      = & ProcessRecord->FileListHead;
        EntrySize = sizeof(TRACE_FILE_INFOW);
        break;

    default:
        return ERROR_INVALID_PARAMETER;
    }

    Next = Head->Flink;
    while (Next != Head)
    {
        // Return the data in the Appropriate structure
        //
        switch (TraceInformationClass)
        {
        case TraceDiskInformation:
            DiskRecord = CONTAINING_RECORD(Next, TDISK_RECORD, Entry);
            DiskInfo   = (PTRACE_DISK_INFOW)
                         ((PUCHAR) DiskInformation + TotalSize);
 
            len        = sizeof(TRACE_DISK_INFOW)
                       +  (lstrlenW(DiskRecord->DiskName) + 1) * sizeof(WCHAR);
            NextEntryOffset = len;
            TotalSize      += len; 
            if (TotalSize > DiskInformationLength)
            {
                 status  = ERROR_MORE_DATA;
                 *Length = 0;
                 return status;
            }
            CopyDiskInfo(DiskInfo, DiskRecord);

            t = s = (char *) DiskInfo + sizeof(TRACE_DISK_INFOW);
            wcscpy((PWCHAR) s, DiskRecord->DiskName);

            DiskInfo->DiskName = (PWCHAR) s;

            if (TraceContext->Flags & TRACE_ZERO_ON_QUERY)
            { // pseudo sort
                 DiskRecord->ReadCount  = 0;
                 DiskRecord->WriteCount = 0;
                 DiskRecord->ReadSize   = 0;
                 DiskRecord->WriteSize  = 0;
            }

            DiskInfo->NextEntryOffset = NextEntryOffset;
            break;

        case TraceFileInformation:
            {
                ULONG NameLen;

                pFile     = CONTAINING_RECORD(Next, FILE_RECORD, Entry);
                Next      = Next->Flink;
                if (pFile->ReadCount == 0 && pFile->WriteCount == 0)
                   continue;

                FileInfo  = (PTRACE_FILE_INFOW)
                            ((PUCHAR) DiskInformation + TotalSize);
                NameLen   = (lstrlenW(pFile->FileName) + 1) * sizeof(WCHAR);

                NextEntryOffset = sizeof(TRACE_FILE_INFOW) + NameLen;
                TotalSize      += sizeof(TRACE_FILE_INFOW) + NameLen;
                if (TotalSize > DiskInformationLength)
                {
                    LeaveTracelibCritSection();
                    * Length = 0;
                    return ERROR_MORE_DATA;
                }
                CopyFileInfo(FileInfo, pFile);
                if (TraceContext->Flags & TRACE_ZERO_ON_QUERY)
                {
                    pFile->ReadCount  =
                    pFile->WriteCount =
                    pFile->ReadSize   =
                    pFile->WriteSize  = 0;
                }
                FileInfo->NextEntryOffset = NextEntryOffset;
                break;
            }
        }
        Next = Next->Flink;
    }

    if (DiskInfo != NULL)
        DiskInfo->NextEntryOffset = 0;
    if (FileInfo != NULL)
        FileInfo->NextEntryOffset = 0;
    * Length = TotalSize;

    return status;
}

ULONG
GetTraceTransactionInfo(
    OUT PVOID TraceInformation,
    IN ULONG  TraceInformationLength,
    OUT PULONG Length,
    IN ULONG   InstanceCount,
    IN LPCWSTR  *InstanceNames,
    IN ULONG TraceInformationClass,
    IN BOOLEAN bDrillDown
    )
{
    PLIST_ENTRY Next, Head;
    PMOF_INFO pMofInfo;
    PLIST_ENTRY DNext, DHead;
    PMOF_DATA pMofData;
    ULONG TotalSize = 0;
    ULONG NextEntryOffset = 0;
    PTRACE_TRANSACTION_INFO TransInfo = NULL;
    ULONGLONG TotalResponse;
    ULONG status=0;
    ULONG nameLen;
    ULONG count;
    WCHAR strDescription[1024];

    UNREFERENCED_PARAMETER(InstanceCount);
    UNREFERENCED_PARAMETER(InstanceNames);
    UNREFERENCED_PARAMETER(TraceInformationClass);
    UNREFERENCED_PARAMETER(bDrillDown);

    EnterTracelibCritSection();

    Head = &CurrentSystem.EventListHead;
    Next = Head->Flink;

    while (Next != Head) {
        pMofInfo = CONTAINING_RECORD( Next, MOF_INFO, Entry );
        Next = Next->Flink;

        if (pMofInfo->strDescription != NULL)
            wcscpy(strDescription, pMofInfo->strDescription);
        else 
            CpdiGuidToString(strDescription, & pMofInfo->Guid);

        nameLen = (lstrlenW(strDescription) + 1) * sizeof(WCHAR);

        TransInfo = (PTRACE_TRANSACTION_INFO)
                      ( (PUCHAR)TraceInformation + TotalSize);
        RtlZeroMemory(TransInfo, (nameLen + sizeof(TRACE_TRANSACTION_INFO)));

        NextEntryOffset = sizeof(TRACE_TRANSACTION_INFO) + nameLen; 
        TotalSize += NextEntryOffset;
        if (TotalSize > TraceInformationLength) {
            status = ERROR_MORE_DATA;
            LeaveTracelibCritSection();
            goto failed;
        }

        TransInfo->NextEntryOffset = NextEntryOffset;
        DHead = &pMofInfo->DataListHead;
        DNext = DHead->Flink;
        count = 0;
        TotalResponse = 0;
        while( DNext != DHead ){
            pMofData = CONTAINING_RECORD( DNext, MOF_DATA, Entry );
            count += pMofData->CompleteCount;
            TotalResponse += pMofData->TotalResponseTime;
            if (TraceContext->Flags & TRACE_ZERO_ON_QUERY) {
                pMofData->CompleteCount = 0;
                pMofData->TotalResponseTime = 0;
            }

            // Fix Min and Max in Callbacks.
            //      
            DNext = DNext->Flink;
        }
        if (count > 0) {
            TransInfo->AverageResponseTime = (ULONG)TotalResponse / count;
        }
        TransInfo->TransactionCount = count;
        TransInfo->Name =
                (PWCHAR) ((PUCHAR) TransInfo + sizeof(TRACE_TRANSACTION_INFO));

        wcscpy(TransInfo->Name, strDescription);
    }

    LeaveTracelibCritSection();
failed:
    if (TransInfo != NULL)
       TransInfo->NextEntryOffset = 0;
   *Length = TotalSize;

    return 0;
}

BOOLEAN
MatchProcess(
    IN PPROCESS_RECORD Process,
    IN ULONG InstanceCount,
    IN LPCWSTR *InstanceNames
    )
{
    BOOLEAN status = FALSE;

    if (Process->UserName && Process->ImageName) {
        PCHAR  t   = NULL;
        PWCHAR s;
        ULONG  len = lstrlenW(Process->UserName) + lstrlenW(Process->ImageName) + 4;

        t   = malloc(len);
        if (t == NULL) {
            return FALSE;
        }
        s = malloc(len * sizeof(WCHAR));
        if (s == NULL) {
            free (t);
            return FALSE;
        }
        if (Process->UserName)
        {
            wcscpy(s, Process->UserName);
            wcscat(s, L" (");
            wcscat(s, Process->ImageName);
            wcscat(s, L")");
        }
        else
        {
            wcscpy(s, L"Unknown (");
            wcscat(s, Process->ImageName);
            wcscat(s, L")");
        }

        status = MatchInstance(s, InstanceCount, InstanceNames);

        if (!status)
        {
            sprintf(t, "%ws", Process->ImageName);
            wcscpy(s, Process->ImageName);
            status = MatchInstance(s, InstanceCount, InstanceNames);
        }

        free(t);
        free(s);

    }

    return status;
}

// APIs to get the real time data. 
//
ULONG 
GetTraceProcessInfo(
    OUT PVOID SystemInformation,
    IN ULONG  SystemInformationLength,
    OUT PULONG Length,
    IN ULONG InstanceCount,
    IN LPCWSTR *InstanceNames,
    IN ULONG TraceInformationClass,
    IN BOOLEAN bDrillDown
    )
{
    PLIST_ENTRY Next, Head;
    PPROCESS_RECORD Process;
    ULONG TotalSize = 0;
    ULONG NextEntryOffset = 0;
    PTRACE_PROCESS_INFOW ProcessInfo = (PTRACE_PROCESS_INFOW)SystemInformation;
    PTRACE_PROCESS_INFOW LastProcessInfo = NULL;
    ULONG status=0;
    ULONG UserNameLen = 0;
    ULONG ImageNameLen = 0;
    EnterTracelibCritSection();
    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;

    while (Next != Head) {
        Process = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        Next = Next->Flink;

        if ((Process->ReadIO+Process->WriteIO) == 0) 
            continue;
        

        if ((InstanceCount > 0) && 
           (!MatchProcess(Process, InstanceCount, InstanceNames))) {
            continue;
        }

        if (bDrillDown) {
            status = DrillDownProcess(Process,
                             TraceInformationClass,
                             SystemInformation,
                             SystemInformationLength,
                             Length
                             ); 
             LeaveTracelibCritSection();
             return status;
        }
        else {
                
            UserNameLen = (Process->UserName) ? (lstrlenW(Process->UserName) + 1)
                                  : 0; 
            UserNameLen = (UserNameLen+1) * sizeof(WCHAR);
            ImageNameLen = (Process->ImageName) ? 
                                  (lstrlenW(Process->ImageName) + 1)
                                  : 0; 
            ImageNameLen = (ImageNameLen + 1) * sizeof(WCHAR);
            NextEntryOffset = sizeof(TRACE_PROCESS_INFOW) + 
                              UserNameLen + ImageNameLen;
            TotalSize += NextEntryOffset;
            if (TotalSize > SystemInformationLength) {
                status = ERROR_MORE_DATA;
                continue;
                //LeaveTracelibCritSection();
                //goto failed;
            }
            CopyProcessInfo(ProcessInfo, Process);
            ProcessInfo->NextEntryOffset = NextEntryOffset;
            
            LastProcessInfo = ProcessInfo;

            ProcessInfo = (PTRACE_PROCESS_INFOW)
                          ( (PUCHAR)SystemInformation + TotalSize);

            if (TraceContext->Flags & TRACE_ZERO_ON_QUERY) { // don't like this!
                Process->ReadIO = Process->ReadIOSize
                        = Process->WriteIO     = Process->WriteIOSize
                        = Process->SendCount   = Process->SendSize
                        = Process->RecvCount   = Process->RecvSize
                        = Process->HPF         = Process->SPF
                        = Process->PrivateWSet = Process->GlobalWSet = 0;
            }
        }
    }
    LeaveTracelibCritSection();

    if( NULL != LastProcessInfo ){
        LastProcessInfo->NextEntryOffset = 0;
    }

    *Length = TotalSize;

    return status;

}

BOOLEAN
MatchInstance(
    IN LPCWSTR CurrentInstance,
    IN ULONG InstanceCount,
    IN LPCWSTR *InstanceNames
    )
{
    ULONG i;
    if (InstanceCount <= 0) // wild card match.
        return TRUE;

    for (i=0; i < InstanceCount; i++) {
        if (CurrentInstance == NULL ||
             InstanceNames[i] == NULL) 
            continue;
        if (!_wcsicmp(CurrentInstance, InstanceNames[i])) {
            return TRUE;
        }        
    }
    return FALSE;
}

BOOLEAN
MatchDisk(
    IN ULONG CurrentInstance,
    IN ULONG InstanceCount,
    IN LPCSTR *InstanceNames
    )
{
    ULONG i;
    ULONG DiskNumber;
    if (InstanceCount <= 0) // wild card match.
        return TRUE;

    for (i=0; i < InstanceCount; i++) {
        DiskNumber = atoi(InstanceNames[i]);
        if (DiskNumber == CurrentInstance) {
            return TRUE;
        }
    }
    return FALSE;
}

static void 
CopyProcessInfo(
    OUT PTRACE_PROCESS_INFOW ProcessInfo, 
    IN  PPROCESS_RECORD     Process
    )
{
    PWCHAR s;
    ULONG NameLength = 0;

    ProcessInfo->PID            = Process->PID;
    ProcessInfo->ReadCount      = Process->ReadIO; 
    ProcessInfo->WriteCount     = Process->WriteIO;
    ProcessInfo->HPF            = Process->HPF;
    ProcessInfo->SPF            = Process->SPF;
    ProcessInfo->PrivateWSet    = Process->PrivateWSet;
    ProcessInfo->GlobalWSet     = Process->GlobalWSet;
    ProcessInfo->ReadSize       = (Process->ReadIO > 0) ? 
                                   Process->ReadIOSize / Process->ReadIO :
                                   0;
    ProcessInfo->WriteSize      = (Process->WriteIO > 0) ?
                                  Process->WriteIOSize / Process->WriteIO :
                                  0;
    ProcessInfo->SendCount      = Process->SendCount;
    ProcessInfo->RecvCount      = Process->RecvCount;
    ProcessInfo->SendSize       = Process->SendCount > 0
                                ? Process->SendSize / Process->SendCount
                                : 0;
    ProcessInfo->RecvSize       = Process->RecvCount > 0
                                ? Process->RecvSize / Process->RecvCount
                                : 0;
    ProcessInfo->UserCPU        = CalculateProcessKCPU(Process);
    ProcessInfo->KernelCPU      = CalculateProcessUCPU(Process);
    ProcessInfo->TransCount     = 0;
    ProcessInfo->ResponseTime   = Process->ResponseTime;
    ProcessInfo->TxnStartTime   = Process->TxnStartTime;
    ProcessInfo->TxnEndTime     = Process->TxnEndTime;
    ProcessInfo->LifeTime       = CalculateProcessLifeTime(Process);

    if (Process->UserName) {
        s = (PWCHAR) ((char *) ProcessInfo + sizeof(TRACE_PROCESS_INFOW));
        wcscpy(s, Process->UserName);
        ((PTRACE_PROCESS_INFOW) ProcessInfo)->UserName = s;
        NameLength = (lstrlenW(Process->UserName) + 1) *  sizeof(WCHAR);
    }
    else
    {
        ProcessInfo->UserName = NULL;
    }

    if (Process->ImageName) {
        WCHAR strBuf[MAXSTR];

        if (Process->UserName)
        {
            wcscpy(strBuf, Process->UserName);
            wcscat(strBuf, L"(");
        }
        else
        {
            wcscpy(strBuf, L"Unknown (");
        }
        wcscat(strBuf, Process->ImageName);
        wcscat(strBuf, L")");
        
        s = (PWCHAR) ((char *) ProcessInfo + sizeof(TRACE_PROCESS_INFOW));
        wcscpy(s, strBuf);
        ((PTRACE_PROCESS_INFOW) ProcessInfo)->ImageName = s;
    }
    else {
        ProcessInfo->ImageName = NULL;
    }
}

ULONG 
GetTraceFileInfo(
    OUT PVOID FileInformation,
    IN ULONG FileInformationLength,
    OUT PULONG Length,
    IN ULONG InstanceCount,
    IN LPCWSTR *InstanceNames,
    IN ULONG TraceInformationClass,
    IN BOOLEAN bDrillDown
    )
{
    PLIST_ENTRY Next, Head;
    PFILE_RECORD    FileRecord;
    PPROTO_PROCESS_RECORD ProtoProcess;
    PPROCESS_RECORD Process;
    ULONG TotalSize = 0;
    ULONG NextEntryOffset = 0;
    PTRACE_FILE_INFOW FileInfo = NULL;
    ULONG status=ERROR_SUCCESS;
    ULONG Len;
    PTRACE_PROCESS_INFOW ProcessInfo = NULL;
    ULONG UserNameLen = 0;
    ULONG ImageNameLen = 0;
    PWCHAR s;

    EnterTracelibCritSection();

    Head = &CurrentSystem.HotFileListHead;
    Next = Head->Flink;

    while (Next != Head) {
        FileRecord = CONTAINING_RECORD( Next, FILE_RECORD, Entry );
        Next = Next->Flink;
        if ((InstanceCount >  0) && 
        (!MatchInstance(FileRecord->FileName, InstanceCount, InstanceNames))) {
            continue;
        }

        // Check to see if Instance Drilldown has been requested. 
        //
        if (bDrillDown) {
            switch (TraceInformationClass) {

                case TraceProcessInformation:
                {
                    Head = &FileRecord->ProtoProcessListHead;
                    Next = Head->Flink;
                    while (Next != Head) {
                        ProtoProcess = CONTAINING_RECORD( Next, 
                                                     PROTO_PROCESS_RECORD, 
                                                     Entry );
                        Next = Next->Flink;
                        Process = ProtoProcess->ProcessRecord;

                        if ((ProtoProcess->ReadCount +
                             ProtoProcess->WriteCount) == 0) continue;

                        UserNameLen = (Process->UserName) ? 
                                      (lstrlenW(Process->UserName) + 1)
                                      : 0;
                        ImageNameLen = (Process->ImageName) ?
                                       (lstrlenW(Process->ImageName) + 1)
                                       : 0;

                        UserNameLen = (UserNameLen+1) * sizeof(WCHAR);
                        ImageNameLen = (ImageNameLen+1) * sizeof(WCHAR);

                        ProcessInfo = (PTRACE_PROCESS_INFOW)
                                      ( (PUCHAR)FileInformation + TotalSize);
                        ProcessInfo->PID            = Process->PID;
                        ProcessInfo->ReadCount      = ProtoProcess->ReadCount;
                        ProcessInfo->WriteCount     = ProtoProcess->WriteCount;
                        ProcessInfo->HPF            = ProtoProcess->HPF;
                        ProcessInfo->ReadSize = (ProtoProcess->ReadCount > 0)
                                                  ? (ProtoProcess->ReadSize / 
                                                     ProtoProcess->ReadCount) :
                                                  0;
                        ProcessInfo->WriteSize = (ProtoProcess->WriteCount 
                                                    > 0) ? 
                                                    ProtoProcess->WriteSize 
                                                  / ProtoProcess->WriteCount :
                                                  0;


                        if (TraceContext->Flags & TRACE_ZERO_ON_QUERY) {
                            ProtoProcess->ReadCount = 0;
                            ProtoProcess->WriteCount = 0;
                            ProtoProcess->ReadSize = 0;
                            ProtoProcess->WriteSize = 0;
                        }

                        if (Process->ImageName) {
                            WCHAR strBuf[MAXSTR];

                            if (Process->UserName) {
                                wcscpy(strBuf, Process->UserName);
                                wcscat(strBuf, L" (");
                            } 
                            else 
                                wcscpy(strBuf, L"Unknown (");
                            wcscat(strBuf, Process->ImageName);
                            wcscat(strBuf, L")");

                            s = (PWCHAR) ((char *)ProcessInfo + 
                                         sizeof(TRACE_PROCESS_INFOW));
                            wcscpy(s, strBuf);
                            ((PTRACE_PROCESS_INFOW) ProcessInfo)->ImageName = s;
                        }
                        else {
                            ProcessInfo->ImageName = 0;
                        }

                        NextEntryOffset = sizeof(TRACE_PROCESS_INFOW) +
                                             UserNameLen+ImageNameLen;
                        ProcessInfo->NextEntryOffset = NextEntryOffset;

                        TotalSize += sizeof(TRACE_PROCESS_INFOW) + 
                                     UserNameLen + 
                                     ImageNameLen;

                        if (TotalSize > FileInformationLength) {
                            status = ERROR_MORE_DATA;
                            LeaveTracelibCritSection();
                            goto failed; 
                        }

                    }
                    break; 
                }
                case TraceFileInformation:
                LeaveTracelibCritSection();
                return ERROR_NO_DATA;
                        break;
                case TraceDiskInformation:
                LeaveTracelibCritSection();
                return ERROR_NO_DATA;
                        break;
            }
            LeaveTracelibCritSection();

            if (ProcessInfo != NULL)
                ProcessInfo->NextEntryOffset = 0;
            *Length = TotalSize;

            return status;
        }

        // Do not return files with no activity.
        //
        if (FileRecord->ReadCount == 0 && FileRecord->WriteCount == 0) {
            continue;
        }

        FileInfo = (PTRACE_FILE_INFOW)
                          ( (PUCHAR)FileInformation + TotalSize);
        Len = (lstrlenW(FileRecord->FileName) +1) * sizeof(WCHAR);

        NextEntryOffset = sizeof(TRACE_FILE_INFOW) + Len;
        TotalSize += sizeof(TRACE_FILE_INFOW) + Len;
        if (TotalSize > FileInformationLength) {
            status = ERROR_MORE_DATA;
            LeaveTracelibCritSection();
            goto failed;
        }
        CopyFileInfo(FileInfo, FileRecord);

        if (TraceContext->Flags & TRACE_ZERO_ON_QUERY) { // pseudo sort
            FileRecord->ReadCount = 
            FileRecord->WriteCount = 
            FileRecord->ReadSize = 
            FileRecord->WriteSize = 0; 
        }

        FileInfo->NextEntryOffset = NextEntryOffset;
        // Go to the next File
    }
        
    LeaveTracelibCritSection();

    if (FileInfo != NULL)
        FileInfo->NextEntryOffset = 0;
    *Length = TotalSize;

failed:
        return status;
}

static void 
CopyFileInfo(
    OUT PTRACE_FILE_INFOW FileInfo,
    IN  PFILE_RECORD FileRecord
    )
{
    PVOID s;
    char* t;
    FileInfo->DiskNumber = FileRecord->DiskNumber;
    FileInfo->ReadCount = FileRecord->ReadCount;
    FileInfo->WriteCount = FileRecord->WriteCount;
    FileInfo->ReadSize = (FileInfo->ReadCount > 0) ? 
                          FileRecord->ReadSize / FileRecord->ReadCount :
                          0;
    FileInfo->WriteSize = (FileRecord->WriteCount > 0) ? 
                           FileRecord->WriteSize / FileRecord->WriteCount :
                           0;
    t = s = (char*)FileInfo + sizeof(TRACE_FILE_INFOW);
    wcscpy((PWCHAR)s, FileRecord->FileName);

    FileInfo->FileName = (PWCHAR)s;
}

ULONG
DrillDownDisk(
    IN  PTDISK_RECORD DiskRecord,
    IN  ULONG        TraceInformationClass,
    OUT PVOID        DiskInformation,
    IN  ULONG        DiskInformationLength,
    OUT PULONG       Length
    )
{
    PLIST_ENTRY Next, Head;
    PPROCESS_RECORD     Process         = NULL;
    PFILE_RECORD        pFile           = NULL;
    ULONG               TotalSize       = 0;
    ULONG               NextEntryOffset = 0;
    PTRACE_DISK_INFOW    DiskInfo        = NULL;
    PTRACE_PROCESS_INFOW ProcessInfo     = NULL;
    PTRACE_FILE_INFOW   FileInfo        = NULL;
    ULONG               EntrySize       = 0;

    if (DiskRecord == NULL)
        return ERROR_INVALID_PARAMETER;

    switch (TraceInformationClass) {
        case TraceProcessInformation: 
            Head = &DiskRecord->ProcessListHead;
            EntrySize = sizeof(TRACE_PROCESS_INFOW);
            break;

/*        case TraceThreadInformation:
            Head = &DiskRecord->ThreadListHead;
            EntrySize = sizeof(TRACE_THREAD_INFO);
            break;
*/
        case TraceFileInformation:
            Head = & CurrentSystem.HotFileListHead;
            EntrySize = sizeof(TRACE_FILE_INFOW);
            break;

        default:
            return ERROR_INVALID_PARAMETER;
    }

    Next = Head->Flink;

    while (Next != Head) {

        // Return the data in the Appropriate structure
        //
        switch (TraceInformationClass) {

            case TraceProcessInformation:
            { 
                ULONG UserNameLen, ImageNameLen;
                Process = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry); 
                Next = Next->Flink;

                ProcessInfo = (PTRACE_PROCESS_INFOW)
                              ((PUCHAR) DiskInformation + TotalSize);

                UserNameLen = (Process->UserName) ? 
                              (lstrlenW(Process->UserName) + 1) : 0;
                UserNameLen = (UserNameLen+1) * sizeof(WCHAR);
                ImageNameLen = (Process->ImageName) ?
                                      (lstrlenW(Process->ImageName) + 1) : 0;
                ImageNameLen = (ImageNameLen + 1) * sizeof(WCHAR);
                NextEntryOffset = sizeof(TRACE_PROCESS_INFOW) +
                                  UserNameLen + ImageNameLen;
                TotalSize += NextEntryOffset;
                if (TotalSize > DiskInformationLength) {
                    LeaveTracelibCritSection();
                    *Length = 0;
                    return ERROR_MORE_DATA;
                }
                CopyProcessInfo(ProcessInfo, Process);
                if (TraceContext->Flags & TRACE_ZERO_ON_QUERY) {
                    Process->ReadIO = 0;
                    Process->WriteIO = 0;
                    Process->HPF = Process->SPF = 0;
                    Process->ReadIOSize = Process->WriteIOSize = 0;
                    Process->PrivateWSet = Process->GlobalWSet = 0;
                }
                ProcessInfo->NextEntryOffset = NextEntryOffset;
                break;
            }

            //case TraceThreadInformation:
            //    break;

            case TraceFileInformation:
            {
                ULONG NameLen;

                pFile     = CONTAINING_RECORD(Next, FILE_RECORD, Entry); 
                Next      = Next->Flink;

                if (pFile->DiskNumber != DiskRecord->DiskNumber)
                    continue;
                if (pFile->ReadCount == 0 && pFile->WriteCount == 0)
                    continue;

                FileInfo  = (PTRACE_FILE_INFOW)
                            ((PUCHAR) DiskInformation + TotalSize);
                NameLen   = (lstrlenW(pFile->FileName) + 1) * sizeof(WCHAR);

                NextEntryOffset = sizeof(TRACE_FILE_INFOW) + NameLen;
                TotalSize      += sizeof(TRACE_FILE_INFOW) + NameLen;
                if (TotalSize > DiskInformationLength)
                {
                    LeaveTracelibCritSection();
                    * Length = 0;
                    return ERROR_MORE_DATA;
                }
                CopyFileInfo(FileInfo, pFile);
                if (TraceContext->Flags & TRACE_ZERO_ON_QUERY)
                {
                    pFile->ReadCount  =
                    pFile->WriteCount =
                    pFile->ReadSize   =
                    pFile->WriteSize  = 0;
                }
                FileInfo->NextEntryOffset = NextEntryOffset;
                break;

            }

            default:
                return ERROR_INVALID_PARAMETER;
        }
    }
    if (ProcessInfo != NULL)
        ProcessInfo->NextEntryOffset = 0;
    if (FileInfo != NULL)
        FileInfo->NextEntryOffset = 0;
    if (DiskInfo != NULL)
        DiskInfo->NextEntryOffset = 0;
    *Length = TotalSize;
    return ERROR_SUCCESS;

}

ULONG 
GetTraceDiskInfo(
    OUT PVOID DiskInformation,
    IN ULONG DiskInformationLength,
    OUT PULONG Length,
    IN ULONG InstanceCount,
    IN LPCWSTR *InstanceNames,
    IN ULONG TraceInformationClass,
    IN BOOLEAN bDrillDown
    )
{
    PLIST_ENTRY Next, Head;
    PTDISK_RECORD    DiskRecord;
    ULONG TotalSize = 0;
    ULONG NextEntryOffset = 0;
    PTRACE_DISK_INFOW DiskInfo = NULL;
    ULONG status=0;
    ULONG len;
    PWCHAR s;

    EnterTracelibCritSection();

    Head = &CurrentSystem.GlobalDiskListHead;
    Next = Head->Flink;

    while (Next != Head) {
        DiskRecord = CONTAINING_RECORD( Next, TDISK_RECORD, Entry );
        Next = Next->Flink;

        if (   (InstanceCount > 0)
                && (!MatchInstance(DiskRecord->DiskName, 
                                    InstanceCount,
                                    InstanceNames)))
        {
            continue;
        }

        if ((DiskRecord->ReadCount+DiskRecord->WriteCount) == 0) 
            continue;

        if (bDrillDown) {
            status = DrillDownDisk(DiskRecord, 
                          TraceInformationClass,
                          DiskInformation,
                          DiskInformationLength,
                          Length);
            LeaveTracelibCritSection();
            return status;
        }

        // If it's not a drilldown request, then it must be for 
        // the Disk record. 
        //
        DiskInfo = (PTRACE_DISK_INFOW)
                          ( (PUCHAR)DiskInformation + TotalSize);
        len = sizeof(TRACE_DISK_INFOW) + (lstrlenW(DiskRecord->DiskName)+1) * sizeof(WCHAR);
        NextEntryOffset = len; // sizeof(TRACE_DISK_INFOW);
        TotalSize += len; // sizeof(TRACE_DISK_INFOW);
        if (TotalSize > DiskInformationLength) {
            status = ERROR_MORE_DATA;
            LeaveTracelibCritSection();
            goto failed;
        }
        CopyDiskInfo(DiskInfo, DiskRecord);

        s = (PWCHAR) ((char*) DiskInfo + sizeof(TRACE_DISK_INFOW));
        wcscpy(s, DiskRecord->DiskName);

        DiskInfo->DiskName = (PWCHAR)s;

        if (TraceContext->Flags & TRACE_ZERO_ON_QUERY) { // pseudo sort
            DiskRecord->ReadCount = 0;
            DiskRecord->WriteCount = 0;
            DiskRecord->ReadSize = 0;
            DiskRecord->WriteSize = 0;
        }

        DiskInfo->NextEntryOffset = NextEntryOffset;
    }

    LeaveTracelibCritSection();
    if (DiskInfo != NULL)
        DiskInfo->NextEntryOffset = 0;
    *Length = TotalSize;
failed:
        return status;

}

static void
CopyDiskInfo(
    OUT PTRACE_DISK_INFOW DiskInfo,
    IN  PTDISK_RECORD DiskRecord
    )
{
    DiskInfo->DiskNumber = DiskRecord->DiskNumber;
    DiskInfo->ReadCount = DiskRecord->ReadCount;
    DiskInfo->WriteCount = DiskRecord->WriteCount;
    DiskInfo->ReadSize = (DiskInfo->ReadCount > 0) ?
                          DiskRecord->ReadSize / DiskRecord->ReadCount :
                          0;
    DiskInfo->WriteSize = (DiskRecord->WriteCount > 0) ?
                           DiskRecord->WriteSize / DiskRecord->WriteCount :
                           0;
}

ULONG 
GetTraceModuleInfo(
    OUT PVOID           ModuleInformation,
    IN  ULONG           ModuleInformationLength,
    OUT PULONG          Length,
    OUT PVOID         * ppModuleLast,
    IN  PPROCESS_RECORD pProcess,
    IN  PLIST_ENTRY     pModuleListHead,
    IN  ULONG           lOffset
    )
{
    ULONG               status     = 0;
    PLIST_ENTRY         pNext      = pModuleListHead->Flink;
    ULONG               lTotalSize = lOffset;
    ULONG               lCurrentSize;
    ULONG               lModuleNameLength;
    ULONG               lImageNameLength;
    PMODULE_RECORD      pModule;
    PTRACE_MODULE_INFO  pModuleInfo;
    ULONG               ProcessID    = pProcess ? pProcess->PID       : 0;
    LPWSTR              strImageName = pProcess ? pProcess->ImageName : NULL;

    EnterTracelibCritSection();

    while (pNext != pModuleListHead)
    {
        pModule = CONTAINING_RECORD(pNext, MODULE_RECORD, Entry);
        pNext   = pNext->Flink;

        lModuleNameLength = lstrlenW(pModule->strModuleName) + 1;
        lImageNameLength  = (strImageName) ? (lstrlenW(strImageName) + 1) : (1);

        lCurrentSize = sizeof(TRACE_MODULE_INFO)
                     + sizeof(WCHAR) * lModuleNameLength
                     + sizeof(WCHAR) * lImageNameLength;
        pModuleInfo = (PTRACE_MODULE_INFO)
                     ((PUCHAR) ModuleInformation + lTotalSize);
        pModuleInfo->PID             = ProcessID;
        pModuleInfo->lBaseAddress    = pModule->lBaseAddress;
        pModuleInfo->lModuleSize     = pModule->lModuleSize;
        pModuleInfo->lDataFaultHF    = pModule->lDataFaultHF;
        pModuleInfo->lDataFaultTF    = pModule->lDataFaultTF;
        pModuleInfo->lDataFaultDZF   = pModule->lDataFaultDZF;
        pModuleInfo->lDataFaultCOW   = pModule->lDataFaultCOW;
        pModuleInfo->lCodeFaultHF    = pModule->lCodeFaultHF;
        pModuleInfo->lCodeFaultTF    = pModule->lCodeFaultTF;
        pModuleInfo->lCodeFaultDZF   = pModule->lCodeFaultDZF;
        pModuleInfo->lCodeFaultCOW   = pModule->lCodeFaultCOW;
        pModuleInfo->NextEntryOffset = lCurrentSize;

        pModuleInfo->strImageName = (PWCHAR) ((PUCHAR) pModuleInfo
                                             + sizeof(TRACE_MODULE_INFO));
        if (strImageName)
        {
            wcscpy(pModuleInfo->strImageName, strImageName);
        }
        pModuleInfo->strModuleName = (WCHAR *) ((PUCHAR) pModuleInfo
                                    + sizeof(TRACE_MODULE_INFO)
                                    + sizeof(WCHAR) * lImageNameLength);
        wcscpy(pModuleInfo->strModuleName, pModule->strModuleName);

        if (pNext == pModuleListHead)
        {
            * ppModuleLast = pModuleInfo;
        }

        lTotalSize += lCurrentSize;

        if (lTotalSize > ModuleInformationLength)
        {
            status = ERROR_MORE_DATA;
        }
    }

    * Length = lTotalSize;

    LeaveTracelibCritSection();
    return status;
}

ULONG 
GetTraceProcessModuleInfo (
    OUT PVOID       ModuleInformation,
    IN  ULONG       ModuleInformationLength,
    OUT PULONG      Length,
    IN  ULONG       InstanceCount,
    IN  LPCWSTR*    InstanceNames
    )
{
    ULONG           status     = 0;
    ULONG           lOffset    = 0;
    PPROCESS_RECORD pProcess;
    PLIST_ENTRY     pHead = & CurrentSystem.ProcessListHead;
    PLIST_ENTRY     pNext = pHead->Flink;
    PVOID           pModuleLast = NULL;

    while (status == 0 && pNext != pHead)
    {
        pProcess = CONTAINING_RECORD(pNext, PROCESS_RECORD, Entry);
        pNext    = pNext->Flink;

        if (   InstanceCount > 0
            && !MatchProcess(pProcess, InstanceCount, InstanceNames))
        {
            continue;
        }

        status = GetTraceModuleInfo(
                         ModuleInformation,
                         ModuleInformationLength,
                         Length,
                       & pModuleLast,
                         pProcess,
                       & pProcess->ModuleListHead,
                         lOffset);

        if (status == 0)
        {
            lOffset = * Length;
        }
    }

    * Length = lOffset;

    if (pModuleLast)
    {
        ((PTRACE_MODULE_INFO) pModuleLast)->NextEntryOffset = 0;
    }

    return status;
}

ULONG
GetTraceProcessFaultInfo(
    OUT PVOID  ProcessFaultInformation,
    IN  ULONG  ProcessFaultInformationLength,
    OUT PULONG Length
    )
{
    ULONG       status     = 0;
    PLIST_ENTRY pHead      = & CurrentSystem.ProcessListHead;
    PLIST_ENTRY pNext      = pHead->Flink;
    ULONG       TotalSize  = 0;
    ULONG       CurrentSize;
    ULONG       lenImgName;

    PPROCESS_RECORD           pProcess;
    PTRACE_PROCESS_FAULT_INFO pProcessInfo;

    UNREFERENCED_PARAMETER(Length);

    EnterTracelibCritSection();
    while (status == 0 && pNext != pHead)
    {
        pProcess     = CONTAINING_RECORD(pNext, PROCESS_RECORD, Entry);
        pNext        = pNext->Flink;
        lenImgName   = (pProcess->ImageName)
                     ? (lstrlenW(pProcess->ImageName) + 1)
                     : (1);
        CurrentSize  = sizeof(TRACE_PROCESS_FAULT_INFO)
                     + sizeof(WCHAR) * lenImgName;
        pProcessInfo = (PTRACE_PROCESS_FAULT_INFO)
                       ((PUCHAR) ProcessFaultInformation + TotalSize);

        pProcessInfo->PID             = pProcess->PID;
        pProcessInfo->lDataFaultHF    = pProcess->lDataFaultHF;
        pProcessInfo->lDataFaultTF    = pProcess->lDataFaultTF;
        pProcessInfo->lDataFaultDZF   = pProcess->lDataFaultDZF;
        pProcessInfo->lDataFaultCOW   = pProcess->lDataFaultCOW;
        pProcessInfo->lCodeFaultHF    = pProcess->lCodeFaultHF;
        pProcessInfo->lCodeFaultTF    = pProcess->lCodeFaultTF;
        pProcessInfo->lCodeFaultDZF   = pProcess->lCodeFaultDZF;
        pProcessInfo->lCodeFaultCOW   = pProcess->lCodeFaultCOW;
        pProcessInfo->NextEntryOffset = CurrentSize;

        pProcessInfo->ImageName =
            (PWCHAR)((PUCHAR) pProcessInfo + sizeof(TRACE_PROCESS_FAULT_INFO));
        if (pProcess->ImageName)
        {
            wcscpy(pProcessInfo->ImageName, pProcess->ImageName);
        }

        TotalSize += CurrentSize;
        if (TotalSize > ProcessFaultInformationLength)
        {
            status = ERROR_MORE_DATA;
        }
    }

    LeaveTracelibCritSection();
    return status;
}

ULONG
CPDAPI
TraceDrillDownW(
    IN TRACEINFOCLASS RootInformationClass,
    IN LPCWSTR InstanceName,
    IN TRACEINFOCLASS TraceInformationClass,
    OUT PVOID TraceInformation,
    IN ULONG TraceInformationLength,
    OUT PULONG Length
    )
{
    // Error Checking
    //
    if ( (InstanceName == NULL || TraceInformation == NULL) ||
         (TraceInformationLength == 0))
        return ERROR_INVALID_PARAMETER;

    switch(RootInformationClass) {
        case TraceProcessInformation:
        {
            ULONG Status;

            Status = GetTraceProcessInfo(TraceInformation,
                                         TraceInformationLength,
                                         Length,
                                         1,
                                         (LPCWSTR *) & InstanceName,
                                         TraceInformationClass,
                                         TRUE);
                return Status; 
        }
        case TraceFileInformation:
            return GetTraceFileInfo(TraceInformation,
                                    TraceInformationLength,
                                    Length,
                                    1,
                                    (LPCWSTR *) & InstanceName,
                                    TraceInformationClass, 
                                    TRUE);

        case TraceDiskInformation:
            return GetTraceDiskInfo(TraceInformation,
                                    TraceInformationLength,
                                    Length,
                                    1,
                                    (LPCWSTR *) & InstanceName,
                                    TraceInformationClass, 
                                    TRUE);
    }

    return (ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracectr\callbacks.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    callbacks.c

Abstract:

    Setting up and handling the callbacks for the events from the
    trace file.

Author:

    Melur Raghuraman (mraghu) 03-Oct-1997

Environment:

Revision History:

    Insung Park (insungp) 05-Jan-2001

    Updated DumpEvent() so that by default, it searches WBEM namespace 
    for the event data layout information. 
    Functions added/modified: GetArraySize, GetItemType,
        GetPropertiesFromWBEM, GetGuidsWbem, GetGuidsFile, and GetGuids.

    Insung Park (insungp) 16-Jan-2001

    Changes enabling tracerpt to handle an invalid type name array in the WBEM namespace.
    Bug fixes for memory corruption (GetPropertiesFromWBEM and GetGuidsWBEM).


--*/
#ifdef __cplusplus
extern "C"{
#endif

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "cpdata.h"
#include <wbemidl.h>
#include "tracectr.h"
#include "item.h"
#include "guids.h"

#define BUFFER_SIZE 64*1024
#define MAX_BUFFER_SIZE 10*1024*1024

#define MOFWSTR            16360
#define MOFSTR             32720
#define MAXTYPE             256
#define UC(x)               ( (UINT)((x) & 0xFF) )
#define NTOHS(x)            ( (UC(x) * 256) + UC((x) >> 8) )

//
// IRP Flags from ntos\inc\io.h for Io event processing.
//

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_ASSOCIATED_IRP              0x00000008
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040
#define IRP_CREATE_OPERATION            0x00000080
#define IRP_READ_OPERATION              0x00000100
#define IRP_WRITE_OPERATION             0x00000200
#define IRP_CLOSE_OPERATION             0x00000400
#define IRP_DEFER_IO_COMPLETION         0x00000800
#define IRP_OB_QUERY_NAME               0x00001000
#define IRP_HOLD_DEVICE_QUEUE           0x00002000

int   IdleEndCount   = 0;
ULONG PageFaultCount = 0;
ULONG EventCount     = 0;

#define EVENT_TRACE_TYPE_SPL_SPOOLJOB    EVENT_TRACE_TYPE_START
#define EVENT_TRACE_TYPE_SPL_PRINTJOB    EVENT_TRACE_TYPE_DEQUEUE
#define EVENT_TRACE_TYPE_SPL_DELETEJOB   EVENT_TRACE_TYPE_END
#define EVENT_TRACE_TYPE_SPL_TRACKTHREAD EVENT_TRACE_TYPE_CHECKPOINT
#define EVENT_TRACE_TYPE_SPL_ENDTRACKTHREAD 0x0A
#define EVENT_TRACE_TYPE_SPL_JOBRENDERED 0x0B
#define EVENT_TRACE_TYPE_SPL_PAUSE 0x0C
#define EVENT_TRACE_TYPE_SPL_RESUME 0x0D

extern PTRACE_CONTEXT_BLOCK TraceContext;
extern ULONG TotalBuffersRead;

ULONG HPFReadCount  = 0;
ULONG HPFWriteCount = 0;

ULONG TotalEventsLost = 0;
ULONG TotalEventCount = 0;
ULONG TimerResolution = 10;
ULONGLONG StartTime   = 0;
ULONGLONG EndTime     = 0;
BOOL   fNoEndTime  = FALSE;
__int64 ElapseTime;

PCHAR  MofData    = NULL;
size_t MofLength  = 0;
BOOLEAN fIgnorePerfClock = FALSE;
BOOLEAN fRealTimeCircular = FALSE;
ULONG PointerSize = sizeof(PVOID) * 8;

BOOL g_bUserMode = FALSE;

static ULONG NumProc = 0;
ULONGLONG BogusThreads[64];
ULONG BogusCount=0;
ULONG IdleThreadCount=0;
BOOLEAN bCaptureBogusThreads=TRUE;

IWbemServices *pWbemServices = NULL;

void AnsiToUnicode(PCHAR str, PWCHAR wstr);

ULONG
ahextoi( WCHAR *s);

PMOF_VERSION
GetGuids( GUID Guid, SHORT nVersion, CHAR nLevel, SHORT nType, BOOL bKernelEvent );

HRESULT
WbemConnect( IWbemServices** pWbemServices );

ULONG GetArraySize(
    IN IWbemQualifierSet *pQualSet
    );

ITEM_TYPE
GetItemType(
    IN CIMTYPE_ENUMERATION CimType, 
    IN IWbemQualifierSet *pQualSet
    );

PMOF_VERSION
GetPropertiesFromWBEM(
    IWbemClassObject *pTraceSubClasses, 
    GUID Guid,
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType,
    BOOL bKernelEvent
    );

PMOF_VERSION
GetGuidsWBEM ( 
    GUID Guid, 
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType, 
    BOOL bKernelEvent 
    );

PMOF_VERSION
GetGuidsFile( 
    GUID Guid, 
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType, 
    BOOL bKernelEvent 
    );

VOID
EventCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    );

VOID
AddMofInfo(
        PLIST_ENTRY List,
        LPWSTR  strType,
        SHORT   nType,
        UINT   ArraySize
);


VOID
UpdateThreadData(
    PJOB_RECORD pJob,
    PEVENT_TRACE_HEADER pHeader,
    PTHREAD_RECORD pThread
    );

VOID
PrintJobCallback(
    PEVENT_TRACE pEvent
    );

void
WINAPI
DumpEvent(
    PEVENT_TRACE pEvent
    );

void
DumpMofVersionItem(
    PMOF_VERSION pMofVersion
    );


extern PWCHAR CpdiGuidToString(PWCHAR s, LPGUID piid);


ULONG Interpolate(ULONGLONG timeStart, ULONG deltaStart,
                  ULONGLONG timeEnd,   ULONG deltaEnd,
                  ULONGLONG timeMiddle)
{
    return deltaStart
          + (deltaEnd - deltaStart) * ((ULONG) (timeMiddle - timeStart))
                                    / ((ULONG) (timeEnd - timeStart));
}

BOOLEAN
InTimeWindow(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PEVENT_TRACE_HEADER pHeader = (PEVENT_TRACE_HEADER) & pEvent->Header;
    BOOLEAN fResult = (pThread) ? (TRUE) : (FALSE);

    if (fResult && fDSOnly)
    {
        if (   ((ULONGLONG) pHeader->TimeStamp.QuadPart < DSStartTime)
            || ((ULONGLONG) pHeader->TimeStamp.QuadPart > DSEndTime))
        {
            fResult = FALSE;
        }
    }
    return fResult;
}

VOID
AdjustThreadTime(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PEVENT_TRACE_HEADER pHeader = (PEVENT_TRACE_HEADER) & pEvent->Header;

    if (IsEqualGUID(&pHeader->Guid, &EventTraceGuid))
    {
        return;
    }
    else if (!pThread || pThread->DeadFlag)
    {
        return;
    }
    else if (fDSOnly)
    {
        if (   ((ULONGLONG) pHeader->TimeStamp.QuadPart >= DSStartTime)
            && ((ULONGLONG) pHeader->TimeStamp.QuadPart <= DSEndTime))
        {
            if (pThread->TimeStart < DSStartTime)
            {
                pThread->TimeStart = DSStartTime;
                pThread->KCPUStart = Interpolate(
                        pThread->TimeEnd, pThread->KCPUStart,
                        pHeader->TimeStamp.QuadPart, pHeader->KernelTime,
                        DSStartTime);
                pThread->UCPUStart = Interpolate(
                        pThread->TimeEnd, pThread->UCPUStart,
                        pHeader->TimeStamp.QuadPart, pHeader->UserTime,
                        DSStartTime);
            }

            pThread->KCPUEnd = pHeader->KernelTime;
            pThread->UCPUEnd = pHeader->UserTime;
            pThread->TimeEnd = (ULONGLONG)pHeader->TimeStamp.QuadPart;
        }
        else if ((ULONGLONG) pHeader->TimeStamp.QuadPart < DSStartTime)
        {
            pThread->TimeStart = pThread->TimeEnd
                               = (ULONGLONG) pHeader->TimeStamp.QuadPart;
            pThread->KCPUStart = pThread->KCPUEnd = pHeader->KernelTime;
            pThread->UCPUStart = pThread->UCPUEnd = pHeader->UserTime;
        }
        else if ((ULONGLONG) pHeader->TimeStamp.QuadPart > DSEndTime)
        {
            if (pThread->TimeEnd < DSEndTime)
            {
                if (pThread->TimeEnd < DSStartTime)
                {
                    pThread->KCPUStart = Interpolate(
                            pThread->TimeEnd, pThread->KCPUStart,
                            pHeader->TimeStamp.QuadPart, pHeader->KernelTime,
                            DSStartTime);
                    pThread->UCPUStart = Interpolate(
                            pThread->TimeEnd, pThread->UCPUStart,
                            pHeader->TimeStamp.QuadPart, pHeader->UserTime,
                            DSStartTime);
                    pThread->TimeStart = DSStartTime;
                }
                pThread->KCPUEnd = Interpolate(
                        pThread->TimeEnd, pThread->KCPUEnd,
                        pHeader->TimeStamp.QuadPart, pHeader->KernelTime,
                        DSEndTime);
                pThread->UCPUEnd = Interpolate(
                        pThread->TimeEnd, pThread->UCPUEnd,
                        pHeader->TimeStamp.QuadPart, pHeader->UserTime,
                        DSEndTime);
                pThread->TimeEnd = DSEndTime;
            }
        }
    }
    else
    {
        pThread->TimeEnd  = pHeader->TimeStamp.QuadPart;
        if (pThread->KCPUEnd <= pHeader->KernelTime)
            pThread->KCPUEnd  = pHeader->KernelTime;
        if (pThread->UCPUEnd <= pHeader->UserTime)
            pThread->UCPUEnd  = pHeader->UserTime;
    }
}




//
// This routine allocates a new MOF_VERSION entry for
// the given type, version and Level.
//


PMOF_VERSION
GetNewMofVersion( SHORT nType, SHORT nVersion, CHAR nLevel )
{
    PMOF_VERSION pMofVersion = NULL;

    pMofVersion = (PMOF_VERSION)malloc(sizeof(MOF_VERSION));

    if( NULL == pMofVersion ){
        return NULL;
    }

    RtlZeroMemory(pMofVersion, sizeof(MOF_VERSION));

    InitializeListHead(&pMofVersion->ItemHeader);
    
    pMofVersion->TypeIndex = nType;
    pMofVersion->Level = nLevel;
    pMofVersion->Version = nVersion;

    return pMofVersion;
}

static void reduceA(char *Src)
{
    char *Start = Src;
    if (!Src)
        return;
    while (*Src)
    {
        if ('\t' == *Src)
            *Src = ' ';
        else if (',' == *Src)
            *Src = ' ';
        else if ('\n' == *Src)
            *Src = ',';
        else if ('\r' == *Src)
            *Src = ' ';
        ++Src;
    }
    --Src;
    while ((Start < Src) && ((' ' == *Src) || (',' == *Src)))
    {
        *Src = 0x00;
        --Src;
    }
}

static void reduceW(WCHAR *Src)
{
    WCHAR *Start = Src;
    if (!Src)
        return;
    while (*Src)
    {
        if (L'\t' == *Src)
            *Src = L' ';
        else if (L',' == *Src)
            *Src = L' ';
        else if (L'\n' == *Src)
            *Src = L',';
        else if (L'\r' == *Src)
            *Src = L' ';
        ++Src;
    }
    --Src;
    while ((Start < Src) && ((L' ' == *Src) || (L',' == *Src)))
    {
        *Src = 0x00;
        --Src;
    }
}


//
// Given a GUID, return a MOF_INFO
//

PMOF_INFO
GetMofInfoHead(
    LPCGUID pGuid
    )
{
    PLIST_ENTRY Head, Next;
    PMOF_INFO pMofInfo;
    PLIST_ENTRY  EventListHead;

    if (pGuid == NULL) 
        return NULL;

    // Search the eventList for this Guid and find the head
    //

    //
    // Traverse the list and look for the Mof info head for this Guid.

    EventListHead = &CurrentSystem.EventListHead;
    Head = EventListHead;
    Next = Head->Flink;

    while (Head  != Next) {
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        if (IsEqualGUID(&pMofInfo->Guid, pGuid)) {
            return  pMofInfo;
        }
        Next = Next->Flink;
    }

    //
    // If not found, add a new entry for this GUID
    //

    pMofInfo = (PMOF_INFO)malloc(sizeof(MOF_INFO));
    if (pMofInfo == NULL) {
        return NULL;
    }
    memset (pMofInfo, 0, sizeof(MOF_INFO));
    pMofInfo->Guid = *pGuid;
    InitializeListHead(&pMofInfo->VersionHeader);
    InitializeListHead(&pMofInfo->DataListHead);

    InsertTailList(EventListHead, &pMofInfo->Entry);
    return pMofInfo;
}


//
// Locate the mof version information for the given guid
//
PMOF_VERSION
GetMofVersion(
    PMOF_INFO pMofInfo,
    SHORT   nType,
    SHORT  nVersion,
    CHAR   nLevel

    )
{
    PLIST_ENTRY Head, Next;
    SHORT   nMatchLevel = 0;
    SHORT nMatchCheck = 0;
    PMOF_VERSION pMofVersion = NULL;
    PMOF_VERSION pBestMatch = NULL;
    

    if (pMofInfo == NULL)
        return NULL;
    //
    // Traverse the list and look for the Mof info head for this Guid.

    Head = &pMofInfo->VersionHeader;
    Next = Head->Flink;

    while (Head != Next) {

        nMatchCheck = 0;
        pMofVersion = CONTAINING_RECORD(Next, MOF_VERSION, Entry);
        Next = Next->Flink;

        if( pMofVersion->TypeIndex == nType ){
            nMatchCheck++;
        }
        if( pMofVersion->Level == nLevel ){
            nMatchCheck++;
        }
        if( pMofVersion->Version == nVersion ){
            nMatchCheck++;
        }

        if( nMatchCheck == 3 ){ // Exact Match
            return  pMofVersion;
        }

        if( nMatchCheck > nMatchLevel ){ // Close Match

            nMatchLevel = nMatchCheck;
            pBestMatch = pMofVersion;
        }

        if( pMofVersion->TypeIndex == EVENT_TYPE_DEFAULT && // Total Guess
            pBestMatch == NULL ){

            pBestMatch = pMofVersion;
        }

    }

    if (pBestMatch != NULL) {
        return pBestMatch;
    }
    //
    // If One does not exist, look it up in the file.
    //
    pMofVersion = GetGuids( pMofInfo->Guid, nVersion, nLevel, nType, 0 );

    // If still not found, create a unknown place holder
    if( NULL == pMofVersion ){
        pMofVersion = GetNewMofVersion( nType, nVersion, nLevel );
        if( pMofVersion != NULL ){
            InsertTailList( &pMofInfo->VersionHeader, &pMofVersion->Entry );
            
            if (nType == EVENT_TRACE_TYPE_INFO) {
                LPWSTR szHeader = L"Header";
                pMofVersion->strType = (PWCHAR)malloc((lstrlenW(szHeader)+1)*sizeof(WCHAR));
                if( pMofVersion->strType != NULL ){
                    wcscpy( pMofVersion->strType, szHeader);
                }
            }
        }
    }

    return pMofVersion;
}

//
// This routine adds a ITEM_DESC entry to all the MOF_VERSION 
// structures in the List
//


VOID
AddMofInfo(
        PLIST_ENTRY List,
        LPWSTR  strType,
        SHORT   nType,
        UINT   ArraySize
    )
{
    PITEM_DESC pItem;
    PMOF_VERSION pMofVersion;

    PLIST_ENTRY Head = List;
    PLIST_ENTRY Next = Head->Flink;


    //
    // Traverse through the list of MOF_VERSIONS
    //

    while (Head != Next) {
        
        pMofVersion = CONTAINING_RECORD(Next, MOF_VERSION, Entry);
        Next = Next->Flink;

        if( NULL != pMofVersion ){

            //
            // ALLOCATE a new ITEM_DESC for the given type
            //

            pItem = (PITEM_DESC) malloc(sizeof(ITEM_DESC));
            if( NULL == pItem ){
                return;
            }
            ZeroMemory( pItem, sizeof(ITEM_DESC) );
            pItem->ItemType = (ITEM_TYPE)nType;
            pItem->ArraySize = ArraySize;


            // All standard datatypes with fixed sizes will be filled here. 

            switch (nType) {
                case ItemChar       :
                case ItemUChar      : pItem->DataSize = sizeof (char); break;
                case ItemCharHidden : pItem->DataSize = sizeof (char); break;
                case ItemBool       : pItem->DataSize = sizeof (BOOL); break;
                case ItemWChar      : pItem->DataSize = sizeof (WCHAR); break;
                case ItemShort      :
                case ItemPort       : 
                case ItemUShort     : pItem->DataSize = sizeof (short); break;
                case ItemPtr        : pItem->DataSize = PointerSize / 8; break; // BUG when two files (Win64 & Win32) are used.
                case ItemLong       :
                case ItemIPAddr     :
                case ItemCPUTime    :
                case ItemULong      :
                case ItemULongX     : pItem->DataSize = sizeof (ULONG); break;
                case ItemGuid       : pItem->DataSize = sizeof(GUID); break;
                case ItemLongLong   :
                case ItemULongLong  : pItem->DataSize = sizeof (__int64); break;
                case ItemChar4      : pItem->DataSize = sizeof(char) * 4; break;
                case ItemOptArgs    :
                default             : pItem->DataSize = 0;
            }


            pItem->strDescription = (PWCHAR) malloc( ( lstrlenW(strType)+1)*sizeof(WCHAR));
            
            if( NULL == pItem->strDescription ){
                free( pItem );
                return;
            }
            wcscpy(pItem->strDescription, strType);

            //
            // Insert the new entry into the ItemHeader list for 
            // this Version, Type, Level combination
            //
         
            InsertTailList( &(pMofVersion->ItemHeader), &pItem->Entry);
        }
    }
}

VOID
DeclareKernelEvents()
{
    PMOF_VERSION pMofVersion;

    pMofVersion = GetGuids(FileIoGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(DiskIoGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(PageFaultGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(ProcessGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(ImageLoadGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(ThreadGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(TcpIpGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(UdpIpGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(EventTraceConfigGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(RegistryGuid, EVENT_TYPE_DEFAULT, EVENT_VERSION_DEFAULT, EVENT_LEVEL_DEFAULT, TRUE);
    pMofVersion = GetGuids(EventTraceGuid, 0, 0, EVENT_TRACE_TYPE_INFO, TRUE);

}

VOID
LogHeaderCallback(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER   pHeader;
    ULONG BuildNumber;
    PPROCESS_FILE_RECORD pFileRec;
    PTRACE_LOGFILE_HEADER pEvmInfo;

    if (pEvent == NULL)
        return;
    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;

    if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_GUIDMAP) {
        return;
    }

    BuildNumber = ((PTRACE_LOGFILE_HEADER)pEvent->MofData)->ProviderVersion;
    BuildNumber &= (0xFAFFFFFF);
    CurrentSystem.BuildNumber = BuildNumber;

    pEvmInfo = (PTRACE_LOGFILE_HEADER) pEvent->MofData;
    CurrentSystem.TimerResolution = pEvmInfo->TimerResolution /  10000;
    CurrentSystem.NumberOfProcessors = pEvmInfo->NumberOfProcessors;

    //
    // If Multiple files are given, use the values from the first file. 
    // 

    if (NumProc == 0) {
        NumProc = pEvmInfo->NumberOfProcessors;
        RtlZeroMemory(&BogusThreads, 64*sizeof(ULONG));
    }

    //
    // With Multiple LogFiles always take the largest time window
    //
    if ((CurrentSystem.StartTime == (ULONGLONG) 0) ||
        ((ULONGLONG)pHeader->TimeStamp.QuadPart < CurrentSystem.StartTime))
        CurrentSystem.StartTime = pHeader->TimeStamp.QuadPart;

    if (DSStartTime == 0)
        DSStartTime = CurrentSystem.StartTime;
    if (fDSOnly && CurrentSystem.StartTime < DSStartTime)
        CurrentSystem.StartTime = DSStartTime;

    if ((CurrentSystem.EndTime == (ULONGLONG)0) ||
        (CurrentSystem.EndTime < (ULONGLONG)pEvmInfo->EndTime.QuadPart))
        CurrentSystem.EndTime   = pEvmInfo->EndTime.QuadPart;
    if (CurrentSystem.EndTime == 0) {
        CurrentSystem.fNoEndTime = TRUE;
    }

    if (DSEndTime == 0)
        DSEndTime = CurrentSystem.EndTime;
    if (fDSOnly && CurrentSystem.EndTime > DSEndTime)
        CurrentSystem.EndTime = DSEndTime;

    pFileRec = (PPROCESS_FILE_RECORD)malloc(sizeof(PROCESS_FILE_RECORD));
    if( pFileRec != NULL ){
        // Temporary... WMI Should dereference ->LogFileName
        LPWSTR pName = (LPWSTR)pEvmInfo;
        pName = (LPWSTR)((PCHAR)pName + sizeof( TRACE_LOGFILE_HEADER ));
        pFileRec->TraceName = (LPWSTR)malloc( ( lstrlenW( pName )+1 )*sizeof(WCHAR) );
        if( pFileRec->TraceName != NULL ){
            wcscpy( pFileRec->TraceName, pName );
        }

        pName += lstrlenW( pName ) + 1;
        pFileRec->FileName = (LPWSTR)malloc( ( lstrlenW( pName )+1 )*sizeof(WCHAR) );
        if( pFileRec->FileName != NULL ){
            wcscpy( pFileRec->FileName, pName );
        }
        pFileRec->StartTime = pHeader->TimeStamp.QuadPart;
        pFileRec->EndTime = pEvmInfo->EndTime.QuadPart;
        InsertTailList( &CurrentSystem.ProcessFileListHead, &pFileRec->Entry );
    }
}

VOID
IoWriteCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PEVENT_TRACE_HEADER pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;
    ULONG DiskNumber= 0;
    ULONG BytesWrite=0;
    PTDISK_RECORD Disk;
    PPROCESS_RECORD pProcess, pDiskProcess;
    PPROTO_PROCESS_RECORD pProto;
    PFILE_OBJECT fileObj;
    PFILE_RECORD pProcFile;
    PVOID fDO = NULL;
    ULONG IrpFlags = 0;
    LONGLONG ByteOffset = 0;
    ULONG pFlag = FALSE;
    BOOLEAN fValidWrite = (BOOLEAN) (!fDSOnly ||
                    (  ((ULONGLONG) pHeader->TimeStamp.QuadPart >= DSStartTime)
                    && ((ULONGLONG) pHeader->TimeStamp.QuadPart <= DSEndTime)));


    GetMofData(pEvent, L"DiskNumber", &DiskNumber, sizeof(ULONG));
    GetMofData(pEvent, L"IrpFlags", &IrpFlags, sizeof(ULONG));
    GetMofData(pEvent, L"TransferSize", &BytesWrite, sizeof(ULONG));
    GetMofData(pEvent, L"FileObject", &fDO, sizeof(ULONG));
    GetMofData(pEvent, L"ByteOffset", &ByteOffset, sizeof(LONGLONG));

    if (((IrpFlags & IRP_PAGING_IO) != 0) ||
         ((IrpFlags & IRP_SYNCHRONOUS_PAGING_IO) != 0)) {
            pFlag = TRUE;
    }

    if ((Disk = FindGlobalDiskById(DiskNumber)) == NULL) {
        if ( !AddDisk(DiskNumber, &Disk) ) {
            return;
        }
    }
    BytesWrite /= 1024;   // Convert to Kbytes.

    if (fValidWrite)
    {
        Disk->WriteCount++;
        Disk->WriteSize += BytesWrite;
    }

    if (pThread == NULL) {

    //
    // Logger Thread Creation is MISSED by the collector.
    // Also, thread creation between process rundown code (UserMode) and
    // logger thread start (kernel mode) are missed.
    // So we must handle it here.
    //
        if (AddThread( pHeader->ThreadId, pEvent, &pThread )) {

/*
#if DBG
            DbgPrint("WARNING(%d): Thread %x added to charge IO Write event.\n",
                    EventCount, pHeader->ThreadId);
#endif
*/
            pThread->pProcess = FindProcessById(0, TRUE); // Charge it the system ???
            pThread->TimeStart = pHeader->TimeStamp.QuadPart;
            pThread->fOrphan   = TRUE;
        //
        // Note: All ThreadStart record at the start of  data collection
        // have the same TID in the header and in the  Aux Fields.
        // Real ThreadStart events will have the Parent threadId in the
        // header and the new ThreadId in the Aux Field.
        //
            pThread->KCPUStart = pHeader->KernelTime;
            pThread->UCPUStart = pHeader->UserTime;
            AdjustThreadTime(pEvent, pThread);
        }
        else {
/*
#if DBG
            DbgPrint("FATBUG(%d): Cannot add thread %x for IO Write Event.\n",
                   EventCount, pHeader->ThreadId);
#endif
*/
            return;
        }
    }
/*
#if DBG
    else if (pThread->fOrphan)
    {
        DbgPrint("INFO(%d): IO Write Event Thread %x Is Still Orphan.\n",
                EventCount, pHeader->ThreadId);
    }
    else if (pThread->DeadFlag)
    {
        DbgPrint("INFO(%d): IO Write Event Thread %x Is Already Dead.\n",
                EventCount, pHeader->ThreadId);
    }
#endif
*/
    if (fValidWrite)
    {
        if (pThread->pMofData != NULL) {
            ((PMOF_DATA)pThread->pMofData)->WriteCount++;
        }
        pThread->WriteIO++;
        pThread->WriteIOSize += BytesWrite;
    }

    // 2. Disk->Process
    //

    pDiskProcess = FindDiskProcessById(Disk, pThread->pProcess->PID);
    if (fValidWrite && pDiskProcess != NULL) {
       if (pFlag) {
           pDiskProcess->HPF++;
           pDiskProcess->HPFSize += BytesWrite;
       }
       else {
           pDiskProcess->WriteIO++;
           pDiskProcess->WriteIOSize += BytesWrite;
       }
    }

    // Add the I/O to the process that owns the causing thread.
    //
    pProcess = pThread->pProcess;
    if (fValidWrite && (pProcess != NULL ) ) {
        pProcess->WriteIO++;
        pProcess->WriteIOSize += BytesWrite;
        Disk = FindProcessDiskById(pProcess, DiskNumber);
        if (Disk != NULL) {

            Disk->WriteCount++;
            Disk->WriteSize += BytesWrite;
        }
    }

    //
    // Thread Local Disk.
    //
    Disk = FindLocalDiskById(&pThread->DiskListHead, DiskNumber);
    if (fValidWrite && Disk != NULL) {
        Disk->WriteCount++;
        Disk->WriteSize += BytesWrite;
    }

    //
    // Now add this I/O the file it came from
    //

    if (fValidWrite)
    {
        fileObj  = FindFileInTable(fDO);
        if (fileObj == NULL) {
            return;
        }
        if (fileObj->fileRec != NULL) {
            fileObj->fileRec->WriteCount++;
            fileObj->fileRec->WriteSize += BytesWrite;

            pProcFile = FindFileInProcess(pProcess, fileObj->fileRec->FileName);
            if (pProcFile != NULL) {
                pProcFile->WriteCount++;
                pProcFile->WriteSize += BytesWrite;
            }
            pProto = FindProtoProcessRecord(fileObj->fileRec, pProcess);
            if (pProto != NULL) {
                pProto->WriteCount++;
                pProto->WriteSize += BytesWrite;
            }
        }
        else {
            // APC has not happened yet. So Make a copy of the pEvent.
            // and Insert it in EventListHead;

            AddEvent(fileObj, DiskNumber,  BytesWrite, FALSE);
        }
    }

    if (pFlag || (IrpFlags & IRP_ASSOCIATED_IRP) != 0)
    {
        PHPF_FILE_RECORD pHPFFileRecord = NULL;

        HPFWriteCount ++;
        if (   fValidWrite
            && AddHPFFileRecord(& pHPFFileRecord, HPFWriteCount, IrpFlags,
                        DiskNumber, ByteOffset, BytesWrite, fDO))
        {
            EnterTracelibCritSection();
            InsertHeadList(& pThread->HPFWriteListHead,
                           & pHPFFileRecord->Entry);
            LeaveTracelibCritSection();
        }
    }
}

VOID
PsStartCallback(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER pHeader;
    ULONG ProcessId=0;
    ULONG ReadId = 0;
    PPROCESS_RECORD pProcess;
    char ImageName[16];
    ULONG returnLength = 16;
    CHAR  UserName[64];
    CHAR  Domain[64];
    CHAR FullName[256];
    ULONG RetLength;
    DWORD asize = 0;
    DWORD bsize = 0;
    ULONG Sid[64];
    PULONG pSid = &Sid[0];
    SID_NAME_USE Se;

    if (pEvent == NULL)
        return;
    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;

    RetLength = GetMofData(pEvent, L"ProcessId", &ReadId, sizeof(ULONG));
//    if (RetLength == 0) {
//        return;
//    }
    ProcessId = ReadId;
    if ( AddProcess(ProcessId, &pProcess) ) {
        //
        // If the Data Collection Start Time and the Process Start Time
        // match, then the PsStart was created by the ProcessRunDown
        // Code. So Keep the CPU Times to compute the difference at the
        // end. Otherwise, zero the starting CPU Times.
        //
        pProcess->PID       = ProcessId;
        RtlZeroMemory(&ImageName, 16 * sizeof(CHAR) );
        GetMofData(pEvent, L"ImageFileName", &ImageName, returnLength);
        asize = lstrlenA(ImageName);
        if (asize > 0) {
            pProcess->ImageName = (LPWSTR)malloc((asize + 1) * sizeof(WCHAR));
            if (pProcess->ImageName == NULL) {
                return;
            }
            //
            // Process hook has the image name as ASCII. So we need to
            // convert it to unicode here.
            //
            AnsiToUnicode(ImageName, pProcess->ImageName);
        }
        else {
            pProcess->ImageName = (LPWSTR)malloc(MAXSTR * sizeof(WCHAR));
            if (pProcess->ImageName == NULL) {
                return;
            }
            if (ProcessId == 0)
            {
                wcscpy(pProcess->ImageName, L"Idle");
            }
            else
            {
                wsprintfW(pProcess->ImageName,
                          L"Unknown(0x%08X)",
                          ProcessId);
            }
        }

        GetMofData(pEvent, L"UserSID", pSid, 64);

        asize = 64; bsize = 64;
        if  (LookupAccountSidA(NULL,
                               pSid,
                               &UserName[0],
                               &asize,
                               &Domain[0],
                               &bsize,
                               &Se)) {
            char* pFullName = &FullName[0];
            strcpy(pFullName, "\\\\");
            strcat(pFullName, Domain);
            strcat(pFullName, "\\");
            strcat(pFullName, UserName);
            asize = lstrlenA(pFullName);
            if (asize > 0) {
                pProcess->UserName = (LPWSTR)malloc((asize + 1) * sizeof(WCHAR));
                if (pProcess->UserName != NULL) {
                    AnsiToUnicode(pFullName, pProcess->UserName);
                }
            }
        }
        else
        {
            pProcess->UserName = (LPWSTR)malloc(7 * sizeof(WCHAR));
            if (pProcess->UserName != NULL) {
                wcscpy(pProcess->UserName, L"system");
            }
        }
    }
}

VOID
PsEndCallback(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER pHeader;
    ULONG    ProcessId;
    ULONG    ReadId = 0;
    PPROCESS_RECORD pProcess;
    char ImageName[16];
    ULONG returnLength = 16;
    CHAR UserName[64];
    CHAR Domain[64];
    CHAR FullName[256];
    DWORD asize = 0;
    DWORD bsize = 0;
    ULONG RetLength;

    ULONG Sid[64];
    PULONG pSid = &Sid[0];
    SID_NAME_USE Se;

    if (pEvent == NULL)
        return;

    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;

    RetLength = GetMofData(pEvent, L"ProcessId", &ReadId, sizeof(ULONG));
//    if (RetLength == 0) {
//        return;
//    }
    ProcessId = ReadId;

    if ( (pProcess = FindProcessById(ProcessId, TRUE)) != NULL )
    {
        if (pProcess->DeadFlag)
        {
/*
#if DBG
            DbgPrint("FATBUG(%d): End Process %x Dead Already!\n",
                   EventCount, ProcessId);
#endif
*/
            return;
        }

        pProcess->DeadFlag = TRUE;
        RtlZeroMemory(&ImageName,  16 * sizeof(CHAR) );
        GetMofData(pEvent, L"ImageFileName", &ImageName, returnLength);

        asize = lstrlenA(ImageName);
        if (asize > 0)
        {
            if (pProcess->ImageName != NULL) {
                free(pProcess->ImageName);
            }
            pProcess->ImageName = (LPWSTR)malloc((asize + 1) * sizeof(WCHAR));
            if (pProcess->ImageName != NULL) {
                AnsiToUnicode(ImageName, pProcess->ImageName);
            }
        }

        GetMofData(pEvent, L"UserSID", pSid, 64);

        asize = 64; bsize = 64;
        if (LookupAccountSidA(NULL,
                               pSid,
                               &UserName[0],
                               &asize,
                               &Domain[0],
                               &bsize,
                               &Se)) {
            char* pFullName = &FullName[0];
            strcpy(pFullName, "\\\\");
            strcat(pFullName, Domain);
            strcat(pFullName, "\\");
            strcat(pFullName, UserName);
            asize = lstrlenA(pFullName);
            if (asize > 0)
            {
                if (pProcess->UserName != NULL)
                {
                    free(pProcess->UserName);
                }
                pProcess->UserName = (LPWSTR)malloc((asize + 1) * sizeof(WCHAR));
                if (pProcess->UserName != NULL) {
                    AnsiToUnicode(pFullName, pProcess->UserName);
                }
            }
        }
        else
        {
            if (pProcess->UserName != NULL)
            {
                free(pProcess->UserName);
            }
            pProcess->UserName = (LPWSTR)malloc(7 * sizeof(WCHAR));
            if (pProcess->UserName != NULL) {
                wcscpy(pProcess->UserName, L"system");
            }
        }
    }
/*
#if DBG
    else {
        DbgPrint("WARNING(%d): PsEnd for Unknown process %x Ignored!\n",
               EventCount, ProcessId);
    }
#endif
*/
}

VOID
ThStartCallback(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER pHeader;
    ULONG ProcessorId = pEvent->ClientContext & 0x000000FF;
    ULONG ProcessId, ThreadId;
    PPROCESS_RECORD pProcess;
    PTHREAD_RECORD Thread;

    ULONG ReadId = 0;
    ULONG RetLength;

    if (pEvent == NULL)
    {
        return;
    }

    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;
    RetLength = GetMofData(pEvent, L"TThreadId", &ReadId, sizeof(ULONG));
//    if (RetLength == 0) {
 //       return;
 //   }
    ThreadId = ReadId;
    RetLength = GetMofData(pEvent, L"ProcessId", &ReadId, sizeof(ULONG));
//    if (RetLength == 0) {
//        return;
//    }
    ProcessId = ReadId;
    pProcess = FindProcessById(ProcessId, TRUE);
    if (pProcess == NULL)
    {
        // This should not Happen. The PS hooks are supposed to guarantee
        // that the process create happens before the thread creates
        // for that process.
        //
        if (!AddProcess(ProcessId, &pProcess))
        {
/*
#if DBG
            DbgPrint("FATBUG(%d): Can not find Process Start Record Th %x PID %x\n",
                   EventCount, ThreadId, ProcessId);
#endif
*/
            return;
        }
    }

    if (ThreadId == 0 && ProcessorId == 0)
    {
        pEvent->ClientContext += CurrentSystem.CurrentThread0 ++;
        //ASSERT(   CurrentSystem.CurrentThread0 <= CurrentSystem.NumberOfProcessors );
    }

    Thread = FindGlobalThreadById(ThreadId, pEvent);
    if (ThreadId != 0 && Thread != NULL && !Thread->DeadFlag)
    {
        if (Thread->fOrphan)
        {
            Thread->fOrphan = FALSE;
/*
#if DBG
            DbgPrint("INFO(%d): Attach orphan thread %x to process %x.\n",
                    EventCount, ThreadId, ProcessId);
#endif
*/
        }
        else
        {
            EVENT_TRACE event;

/*
#if DBG
            DbgPrint("WARNING(%d): Two active thread have the same TID %x.\n",
                    EventCount, ThreadId);
#endif
*/
            event.Header.TimeStamp.QuadPart = pHeader->TimeStamp.QuadPart;
            event.Header.Class.Type = EVENT_TRACE_TYPE_END;
            event.Header.ThreadId   = ThreadId;
            event.Header.UserTime   = Thread->UCPUEnd;
            event.Header.KernelTime = Thread->KCPUEnd;

            //
            // If a DCStart event with non-zero KCPU and UCPU is paired up with 
            // an end Event for the same ThreadId with less CPU Times, the delta
            // can come out negative. We correct it here. 
            //

            if (Thread->KCPUEnd < Thread->KCPUStart) 
                Thread->KCPUEnd = Thread->KCPUStart;
            if (Thread->UCPUEnd < Thread->UCPUStart)
                Thread->UCPUEnd = Thread->UCPUStart;

            ThEndCallback(&event);

            if (!AddThread(ThreadId, pEvent, &Thread))
            {

/*
#if DBG
                DbgPrint("FATBUG(%d): Cannot add global active thread TID %x.\n",
                        EventCount, ThreadId);
#endif
*/
                return;
            }
        }
    }
    else if (!AddThread(ThreadId, pEvent, &Thread))    {

/*
#if DBG
        DbgPrint("FATBUG(%d): Cannot add global active thread TID %x.\n",
                EventCount, ThreadId);
#endif
*/
        return;
    }

    Thread->pProcess = pProcess;
    Thread->TimeStart = pHeader->TimeStamp.QuadPart;

    // Note: All ThreadStart record at the start of  data collection
    // have the same TID in the header and in the  Aux Fields.
    // Real ThreadStart events will have the Parent threadId in the
    // header and the new ThreadId in the Aux Field.
    //

    if (   (ThreadId == pHeader->ThreadId)
        || (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_END))
    {
        Thread->KCPUStart = pHeader->KernelTime;
        Thread->UCPUStart = pHeader->UserTime;
    }
    else
    {
        Thread->KCPUStart = 0;
        Thread->UCPUStart = 0;
    }


    //
    // For DCStart type, the TID in the pEvent and the new thread
    // match. So we can adjust its ThreadTimes. 
    // 

    if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_START) {
        AdjustThreadTime(pEvent, Thread);
    }
    else {
        AdjustThreadTime(pEvent, NULL);
    }

    {
        Thread->KCPU_Trans     = 0;
        Thread->KCPU_NoTrans   = 0;
        Thread->UCPU_Trans     = 0;
        Thread->UCPU_NoTrans   = 0;
        Thread->TransLevel     = 0;
        Thread->KCPU_PrevTrans = Thread->KCPUStart;
        Thread->UCPU_PrevTrans = Thread->UCPUStart;
    }

    if (Thread->TID == 0 && CurrentSystem.BuildNumber <= 1877)
    {
        CurrentSystem.NumberOfProcessors++;
    }
}

VOID
ShutdownThreads()
{
    int i;
    EVENT_TRACE event;
    PLIST_ENTRY Head,Next;
    PTHREAD_RECORD Thread;

    RtlZeroMemory(&event, sizeof(EVENT_TRACE));
    event.Header.TimeStamp.QuadPart = CurrentSystem.EndTime;

    //
    // Move the Thread list from the HashTable to GlobalList
    //

    for (i=0; i < THREAD_HASH_TABLESIZE; i++) {
        Head = &CurrentSystem.ThreadHashList[i];
        Next = Head->Flink;
        while (Next != Head) {
            Thread = CONTAINING_RECORD( Next, THREAD_RECORD, Entry );
            Next = Next->Flink;

            if (!Thread->DeadFlag){
                event.Header.Class.Type = EVENT_TRACE_TYPE_DC_END;
                event.Header.ThreadId   = Thread->TID;
                event.Header.UserTime   = Thread->UCPUEnd;
                event.Header.KernelTime = Thread->KCPUEnd;
                ThEndCallback( &event );
            }
        }
    }
}

VOID
ShutdownProcesses()
{
    PLIST_ENTRY pHead = &CurrentSystem.ProcessListHead;
    PLIST_ENTRY pNext = pHead->Flink;
    PPROCESS_RECORD pProcess;

    while (pNext != pHead){
        pProcess = CONTAINING_RECORD(pNext, PROCESS_RECORD, Entry);
        pNext    = pNext->Flink;

        if (!pProcess->DeadFlag){
            pProcess->DeadFlag = TRUE;
        }
    }
}

BOOL
StopThreadTrans(
    PLIST_ENTRY Head,
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PTRANS_RECORD pTrans;
    PLIST_ENTRY Next = Head->Flink;
    while( Head != Next ){
        pTrans = CONTAINING_RECORD(Next, TRANS_RECORD, Entry);
        Next = Next->Flink;
        if( !StopThreadTrans( &pTrans->SubTransListHead, pEvent, pThread ) ){
            return FALSE;
        }
        if( !pTrans->bStarted ){
            continue;
        }
        memcpy( &pEvent->Header.Guid, pTrans->pGuid, sizeof(GUID));
        pEvent->Header.Class.Type = EVENT_TRACE_TYPE_END;
        EventCallback( pEvent, pThread );
        return FALSE; // stopping one will credit all running events
    }
    return TRUE;
}

VOID
ThEndCallback(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER pHeader;
    ULONG ThreadId;
    PTHREAD_RECORD Thread;

    if (pEvent == NULL)
    {
        return;
    }

    pHeader  = (PEVENT_TRACE_HEADER)&pEvent->Header;
    ThreadId = pHeader->ThreadId;

    if (ThreadId == 0)
    {
        ULONG ProcessorId = pEvent->ClientContext & 0x000000FF;
        if (ProcessorId == 0) {
            pEvent->ClientContext += (CurrentSystem.NumberOfProcessors
                                   - (CurrentSystem.CurrentThread0 --));
        }
    }
    Thread = FindGlobalThreadById(ThreadId, pEvent);

    if (Thread != NULL)
    {
        if (Thread->DeadFlag)
        {
/*
#if DBG
            DbgPrint("FATBUG(%d): Thread %x Dead Already\n",
                   EventCount, ThreadId);
#endif
*/
            return;
        }

        if (Thread->fOrphan)
        {
            ULONG           ReadId    = 0;
            ULONG           ProcessId = 0;
            PPROCESS_RECORD pProcess  = NULL;

            GetMofData(pEvent, L"ProcessId", &ReadId, sizeof(ULONG));
            ProcessId = ReadId;

            pProcess = FindProcessById(ProcessId, TRUE);
            if (pProcess != NULL)
            {
                Thread->fOrphan  = FALSE;
                Thread->pProcess = pProcess;
            }

/*
#if DBG
            DbgPrint("INFO(%d): ThEndCallback() attach orphan thread %X to process %X\n",
                    EventCount, ThreadId, ProcessId);
#endif
*/
        }
        //
        // Charge any unstopped transactions
        //
        if (   Thread != NULL
            && pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_END)
        {
            StopThreadTrans(&Thread->TransListHead, pEvent, Thread );
        }

        Thread->DeadFlag = TRUE;
        if (fDSOnly)
        {
            if ((ULONGLONG) pHeader->TimeStamp.QuadPart > DSEndTime)
            {
                Thread->TimeEnd = DSEndTime;
            }
            else
            {
                Thread->KCPUEnd = pHeader->KernelTime;
                Thread->UCPUEnd = pHeader->UserTime;
                Thread->TimeEnd = (ULONGLONG) pHeader->TimeStamp.QuadPart;
            }
        }
        else
        {
            if (Thread->UCPUEnd < pHeader->UserTime)
                Thread->UCPUEnd = pHeader->UserTime;
            if (Thread->KCPUEnd < pHeader->KernelTime)
                Thread->KCPUEnd = pHeader->KernelTime;
            Thread->TimeEnd = pHeader->TimeStamp.QuadPart;
        }

        if (Thread->TransLevel <= 0)
        {
            Thread->KCPU_NoTrans += Thread->KCPUEnd - Thread->KCPU_PrevTrans;
            Thread->UCPU_NoTrans += Thread->UCPUEnd - Thread->UCPU_PrevTrans;
        }
        else
        {
            Thread->KCPU_Trans += Thread->KCPUEnd - Thread->KCPU_PrevTrans;
            Thread->UCPU_Trans += Thread->UCPUEnd - Thread->UCPU_PrevTrans;
/*
#if DBG
            DbgPrint("WARNING(%d): Active Transactions in Dead Thread %x\n",
                    EventCount, ThreadId);
#endif
*/
        }
    }
    else
    {
/*
#if DBG
        DbgPrint("WARNING(%d): No Thread Start for ThreadId %x\n",
               EventCount, ThreadId);
#endif
*/
        if (AddThread(ThreadId, pEvent, &Thread))
        {
            Thread->pProcess  = FindProcessById(0, FALSE);
            Thread->DeadFlag  = TRUE;
            Thread->fOrphan   = TRUE;
            Thread->TimeStart = Thread->TimeEnd = pHeader->TimeStamp.QuadPart;
            Thread->KCPUStart = Thread->KCPUEnd = pHeader->KernelTime;
            Thread->UCPUStart = Thread->UCPUEnd = pHeader->UserTime;
            AdjustThreadTime(pEvent, Thread);
        }
        else
        {
/*
#if DBG
            DbgPrint("FATBUG(%d): Cannot add thread %x for ThreadEnd Event.\n",
                   EventCount, ThreadId);
#endif
*/
        }
    }
}

VOID
IoReadCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PEVENT_TRACE_HEADER pHeader = (EVENT_TRACE_HEADER*)&pEvent->Header;
    ULONG DiskNumber=0;
    ULONG BytesRead=0;
    ULONG IrpFlags=0;
    PTDISK_RECORD Disk;
    PPROCESS_RECORD pProcess;
    PPROTO_PROCESS_RECORD pProto;
    PFILE_OBJECT fileObj;
    PFILE_RECORD pProcFile;
    PVOID fDO;
    BOOLEAN pFlag = FALSE;
    PPROCESS_RECORD pDiskProcess;
    LONGLONG ByteOffset;
    BOOLEAN fValidRead = (BOOLEAN) (!fDSOnly ||
                    (  ((ULONGLONG) pHeader->TimeStamp.QuadPart >= DSStartTime)
                    && ((ULONGLONG) pHeader->TimeStamp.QuadPart <= DSEndTime)));

    GetMofData(pEvent, L"DiskNumber", &DiskNumber, sizeof(ULONG));
    GetMofData(pEvent, L"IrpFlags", &IrpFlags, sizeof(ULONG));
    GetMofData(pEvent, L"TransferSize", &BytesRead, sizeof(ULONG));
    GetMofData(pEvent, L"FileObject", &fDO, sizeof(ULONG));
    GetMofData(pEvent, L"ByteOffset", &ByteOffset, sizeof(ULONGLONG));

    BytesRead /= 1024;  // Convert to Kbytes

    if (((IrpFlags & IRP_PAGING_IO) != 0) ||
         ((IrpFlags & IRP_SYNCHRONOUS_PAGING_IO) != 0)) {
            pFlag = TRUE;
    }
//
// TODO: From DiskNumber and Offset get the Logical Disk
//       ie., DiskNumber = MapDisk(DiskIndex, Offset);
//

    //
    // Add the I/O to the DISK
    //

    if ((Disk = FindGlobalDiskById(DiskNumber)) == NULL) {
        if (!AddDisk(DiskNumber, &Disk) ) {
            return;
        }
    }

    if (fValidRead)
    {
        if (pFlag) {
            Disk->HPF++;
            Disk->HPFSize += BytesRead;
        }
        else {
            Disk->ReadCount++;
            Disk->ReadSize += BytesRead;
        }
    }

    //
    // Add the I/O to the THREAD
    //

    if ( pThread == NULL) {

    //
    // NOTE: Logger Thread Creation is MISSED by the collector.
    // Also, thread creation between process rundown code (UserMode) and
    // logger thread start (kernel mode) are missed.
    // So we must handle it here.
    //
        if (AddThread(pHeader->ThreadId, pEvent, &pThread )) {

/*
#if DBG
            DbgPrint("WARNING(%d): Thread %x added to charge IO Read event\n",
                   EventCount, pHeader->ThreadId);
#endif
*/
            pThread->pProcess = FindProcessById(0, TRUE); // Charge it the system ???
            pThread->TimeStart = pHeader->TimeStamp.QuadPart;
            pThread->fOrphan   = TRUE;
        //
        // Note: All ThreadStart record at the start of  data collection
        // have the same TID in the header and in the  Aux Fields.
        // Real ThreadStart events will have the Parent threadId in the
        // header and the new ThreadId in the Aux Field.
        //
            pThread->KCPUStart = pHeader->KernelTime;
            pThread->UCPUStart   = pHeader->UserTime;
            AdjustThreadTime(pEvent, pThread);
        }
        else {
/*
#if DBG
            DbgPrint("FATBUG(%d): Cannot add thread %x for IO Read Event.\n",
                    EventCount, pHeader->ThreadId);
#endif
*/
            return;
        }
    }
/*
#if DBG
    else if (pThread->fOrphan)
    {
        DbgPrint("INFO(%d): IO Read Event Thread %x Is Still Orphan.\n",
                EventCount, pHeader->ThreadId);
    }
    else if (pThread->DeadFlag)
    {
        DbgPrint("INFO(%d): IO Read Event Thread %x Is Already Dead.\n",
                EventCount, pHeader->ThreadId);
    }
#endif
*/
    ASSERT(pThread != NULL);

    if (fValidRead && pThread->pMofData != NULL) {
        ((PMOF_DATA)pThread->pMofData)->ReadCount++;
    }

    if (fValidRead)
    {
        if (pFlag) {
            pThread->HPF++;
            pThread->HPFSize += BytesRead;
        }
        else {
            pThread->ReadIO++;
            pThread->ReadIOSize += BytesRead;
        }
    }

    //
    // 2. Disk->Process
    //

    pDiskProcess = FindDiskProcessById(Disk, pThread->pProcess->PID);
    if (fValidRead && pDiskProcess != NULL) {
        if (pFlag) {
            pDiskProcess->HPF++;
            pDiskProcess->HPFSize += BytesRead;
        }
        else {
            pDiskProcess->ReadIO++;
            pDiskProcess->ReadIOSize += BytesRead;
        }
    }

    //
    // Add the I/O to the PROCESS
    //
    pProcess = pThread->pProcess;
    if (fValidRead && (pProcess != NULL )) {
        pProcess->ReadIO++;
        pProcess->ReadIOSize += BytesRead;

        Disk = FindProcessDiskById(pProcess, DiskNumber);
        if (Disk != NULL) {
            if (pFlag) {
                Disk->HPF++;
                Disk->HPFSize += BytesRead;
            }
            else {
                Disk->ReadCount++;
                Disk->ReadSize += BytesRead;
            }
        }
    }

    //
    // Add the I/O to the FILE
    //
    if (fValidRead)
    {
        fileObj  = FindFileInTable(fDO);
        if (fileObj == NULL) {
            return;
        }
        if (fileObj->fileRec) {
            fileObj->fileRec->ReadCount++;
            fileObj->fileRec->ReadSize += BytesRead;
            pProcFile = FindFileInProcess(pProcess, fileObj->fileRec->FileName);
            if (pProcFile != NULL) {
#if 0
                if (pFlag) {
                    pProcFile->HPF++;
                    pProcFile->HPFSize += BytesRead;
                }
                else {
#endif
                    pProcFile->ReadCount++;
                    pProcFile->ReadSize += BytesRead;
#if 0
                }
#endif
            }
            pProto = FindProtoProcessRecord(fileObj->fileRec, pProcess);
            if (pProto != NULL) {
#if 0
                if (pFlag) {
                    pProto->HPF++;
                    pProto->HPFSize += BytesRead;
                }
                else {
#endif
                    pProto->ReadCount++;
                    pProto->ReadSize += BytesRead;
#if 0
                }
#endif
            }
        }
        else {
            // APC has not happened yet. So Make a copy of the pEvent.
            // and Insert it in EventListHead;
            AddEvent(fileObj, DiskNumber,  BytesRead, TRUE);
        }
    }

    //
    // Do the Drill Down Calls Now. To Save on memory we need to be
    // selective about which ones to create.
    //


    // 2. Thread->Disk

    Disk = FindLocalDiskById(&pThread->DiskListHead, DiskNumber);
    if (fValidRead && Disk != NULL) {
        if (pFlag) {
            Disk->HPF++;
            Disk->HPFSize += BytesRead;
        }
        else {
            Disk->ReadCount++;
            Disk->ReadSize += BytesRead;
        }
    }

    if (pFlag || (IrpFlags & IRP_ASSOCIATED_IRP) != 0)
    {
        PHPF_FILE_RECORD pHPFFileRecord = NULL;

        HPFReadCount ++;
        if (   fValidRead
            && AddHPFFileRecord(& pHPFFileRecord, HPFReadCount, IrpFlags,
                        DiskNumber, ByteOffset, BytesRead, fDO))
        {
            EnterTracelibCritSection();
            InsertHeadList(& pThread->HPFReadListHead,
                           & pHPFFileRecord->Entry);
            LeaveTracelibCritSection();
        }
    }
}

VOID
HotFileCallback(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER pHeader;
    WCHAR FileName[MAXSTR];  // Not Sure if this is sufficient...
    PLIST_ENTRY Next, Head;
    PFILE_RECORD fileRec, pProcFile = NULL;
    PPROTO_FILE_RECORD protoFileRec;
    PFILE_OBJECT fileObj;
    PVOID fDO;
    PTHREAD_RECORD  pThread = NULL;
    PPROCESS_RECORD pProcess = NULL;
    PPROTO_PROCESS_RECORD pProto = NULL;
    ULONG RetLength;

    if (pEvent == NULL)
        return;
    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;

    RtlZeroMemory(&FileName, MAXSTR * sizeof(WCHAR));

    GetMofData(pEvent, L"FileObject", &fDO, sizeof(ULONG));
    RetLength = GetMofData(pEvent, L"FileName", &FileName, MAXSTR*sizeof(WCHAR));
    if (RetLength == 0) {
        return;
    }

    // Remember to Add the DISKNUMBER to the name
    //
    // When we get a FileName We need to find the FILE_RECORD
    //
        if ((fileRec = FindFileRecordByName(FileName)) == NULL) {
            AddFile(FileName, &fileRec);
        }

    //
    // Get the FileObject from the fileTable  and update the information.
    //

    fileObj = FindFileInTable(fDO);
    if (fileObj == NULL) {
        return;
    }

    if (fileObj->fileRec != NULL) {
/*
#if DBG
        DbgPrint("BUG: APC for known file %ws\n", FileName);
#endif
*/
    }

    if ((pThread = FindGlobalThreadById(pHeader->ThreadId, pEvent)) != NULL) {
        pProcess = pThread->pProcess;
        if (pProcess != NULL) {
            pProcFile = FindFileInProcess(pProcess, FileName);
            pProto = FindProtoProcessRecord(fileRec, pProcess);
        }
    }
    else {
        return;
    }

    fileObj->fileRec = fileRec;

    //
    // Walk through the EventList and add it to this file record
    //
    Head = &fileObj->ProtoFileRecordListHead;
    Next = Head->Flink;
    while (Next != Head) {
        protoFileRec = CONTAINING_RECORD( Next, PROTO_FILE_RECORD, Entry );
        fileRec->DiskNumber = protoFileRec->DiskNumber;
        if (protoFileRec->ReadFlag) {
            fileRec->ReadCount++;
            fileRec->ReadSize += protoFileRec->IoSize;
            if (pProcFile != NULL) {
                pProcFile->ReadCount++;
                pProcFile->ReadSize += protoFileRec->IoSize;
            }
            if (pProto != NULL) {
                pProto->ReadCount++;
                pProto->ReadSize += protoFileRec->IoSize;
            }
        }
        else {
            fileRec->WriteCount++;
            fileRec->WriteSize += protoFileRec->IoSize;
            if (pProcFile != NULL) {
                pProcFile->WriteCount++;
                pProcFile->WriteSize += protoFileRec->IoSize;
            }
            if (pProto != NULL) {
                pProto->WriteCount++;
                pProto->WriteSize += protoFileRec->IoSize;
            }
        }
        Next = Next->Flink;
        RemoveEntryList( &protoFileRec->Entry);
    }

    //
    // If DrillDown Records are appended, we need to handle those too
    //
}

VOID
ModuleLoadCallback(PEVENT_TRACE pEvent)
{
    PEVENT_TRACE_HEADER pHeader = (PEVENT_TRACE_HEADER) & pEvent->Header;
    ULONG lBaseAddress = 0;
    ULONG lModuleSize = 0;
    WCHAR strModulePath[256];
    WCHAR * strModuleName;
    ULONG rtnLength = sizeof(WCHAR) * 256;

    PLIST_ENTRY     pHead    = &CurrentSystem.GlobalModuleListHead;
    PLIST_ENTRY     pNext    = pHead->Flink;
    PMODULE_RECORD  pMatched = NULL;
    PMODULE_RECORD  pCurrent = NULL;
    PTHREAD_RECORD  pThread  = NULL;
    PPROCESS_RECORD pProcess = NULL;

    RtlZeroMemory(strModulePath, 256 * sizeof(WCHAR) );
    GetMofData(pEvent, L"ImageBase",    & lBaseAddress,  sizeof(ULONG));
    GetMofData(pEvent, L"ImageSize",     & lModuleSize,   sizeof(ULONG));
    GetMofData(pEvent, L"FileName",  & strModulePath, rtnLength);

    strModuleName = wcsrchr(strModulePath, L'\\');
    if (!strModuleName){
        strModuleName = strModulePath;
    }else{
        strModuleName ++;
    }

    // Check if loaded image is already in SYSTEM_RECORD::GlobalModuleListHead.
    // Otherwise, insert new MODULE_RECORD.
    //
    while (!pMatched && pNext != pHead){
        pMatched = CONTAINING_RECORD(pNext, MODULE_RECORD, Entry);
        if (_wcsicmp(strModuleName, pMatched->strModuleName)){
            pMatched = NULL;
            pNext    = pNext->Flink;
        }
    }

    if (!pMatched){
        if (AddModuleRecord(& pMatched, lBaseAddress, lModuleSize, strModuleName)){
            EnterTracelibCritSection();
            InsertHeadList(
                    & CurrentSystem.GlobalModuleListHead,
                    & pMatched->Entry);
            LeaveTracelibCritSection();
            pMatched->pProcess   = NULL;
            pMatched->pGlobalPtr = NULL;
        }else{
            return;
        }
    }

    ASSERT(pMatched);

    // Insert loaded image in PROCESS_RECORD::ModuleListHead
    //
    if (AddModuleRecord(& pCurrent, lBaseAddress, lModuleSize, strModuleName)){
        pCurrent->pGlobalPtr = pMatched;

        pThread = FindGlobalThreadById(pHeader->ThreadId, pEvent);
        ASSERT(pThread);
        if (!pThread){
            free( pCurrent );
            return;
        }

        pProcess = pThread->pProcess;
        ASSERT(pProcess);
        if (!pProcess){
            free( pCurrent );
            return;
        }

        EnterTracelibCritSection();
        pCurrent->pProcess = pProcess;
        InsertHeadList( & pProcess->ModuleListHead, & pCurrent->Entry);
        LeaveTracelibCritSection();
    }else{
        return;
    }
}

VOID
ProcessCallback(
   PEVENT_TRACE pEvent
    )
{
    if (pEvent == NULL){     
        return;
    }

    if ((pEvent->Header.Class.Type == EVENT_TRACE_TYPE_START) ||
        (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_START)) {
        PsStartCallback(pEvent);
    }
    else if ((pEvent->Header.Class.Type == EVENT_TRACE_TYPE_END) ||
             (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_END)) {
        PsEndCallback(pEvent);
    }
}

VOID
ThreadCallback(
    PEVENT_TRACE pEvent
    )
{
    if (pEvent == NULL){
        return;
    }

    if ((pEvent->Header.Class.Type == EVENT_TRACE_TYPE_START) ||
        (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_START)) {

        ThStartCallback(pEvent);
    } else if ((pEvent->Header.Class.Type == EVENT_TRACE_TYPE_END) ||
        (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_END)) {
        ThEndCallback(pEvent);
    }
}

PMODULE_RECORD
SearchModuleByAddr(
    PLIST_ENTRY pModuleListHead,
    ULONG       lAddress
    )
{
    PLIST_ENTRY    pNext   = pModuleListHead->Flink;
    PMODULE_RECORD pModule = NULL;
    PMODULE_RECORD pCurrent;

    while (pNext != pModuleListHead)
    {
        pCurrent = CONTAINING_RECORD(pNext, MODULE_RECORD, Entry);
        pNext    = pNext->Flink;
        if (   (lAddress >= pCurrent->lBaseAddress)
            && (lAddress <  pCurrent->lBaseAddress + pCurrent->lModuleSize))
        {
            pModule = pCurrent;
            break;
        }
    }
    return pModule;
}

void
UpdatePageFaultCount(
    PPROCESS_RECORD pProcess,
    PMODULE_RECORD  pModule,
    ULONG           lFaultAddr,
    UCHAR           FaultType)
{
    BOOLEAN fFaultInImage = (BOOLEAN) ((lFaultAddr >= pModule->lBaseAddress)
                         && (lFaultAddr <  pModule->lBaseAddress
                                         + pModule->lModuleSize));
    switch(FaultType)
    {
    case EVENT_TRACE_TYPE_MM_HPF :
        if (fFaultInImage)
        {
            pProcess->lCodeFaultHF ++;
            pModule->lCodeFaultHF ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lCodeFaultHF ++;
            }
        }
        else
        {
            pProcess->lDataFaultHF ++;
            pModule->lDataFaultHF ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lDataFaultHF ++;
            }
        }
        break;

    case EVENT_TRACE_TYPE_MM_TF :
        if (fFaultInImage)
        {
            pProcess->lCodeFaultTF ++;
            pModule->lCodeFaultTF ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lCodeFaultTF ++;
            }
        }
        else
        {
            pProcess->lDataFaultTF ++;
            pModule->lDataFaultTF ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lDataFaultTF ++;
            }
        }
        break;

    case EVENT_TRACE_TYPE_MM_DZF :
        if (fFaultInImage)
        {
            pProcess->lCodeFaultDZF ++;
            pModule->lCodeFaultDZF ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lCodeFaultDZF ++;
            }
        }
        else
        {
            pProcess->lDataFaultDZF ++;
            pModule->lDataFaultDZF ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lDataFaultDZF ++;
            }
        }
        break;

    case EVENT_TRACE_TYPE_MM_COW :
        if (fFaultInImage)
        {
            pProcess->lCodeFaultCOW ++;
            pModule->lCodeFaultCOW ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lCodeFaultCOW ++;
            }
        }
        else
        {
            pProcess->lDataFaultCOW ++;
            pModule->lDataFaultCOW ++;
            if (pModule->pGlobalPtr)
            {
                pModule->pGlobalPtr->lDataFaultCOW ++;
            }
        }
        break;

    default :
        break;
    }
}

PMODULE_RECORD
SearchSysModule(
    PPROCESS_RECORD pProcess,
    ULONG    lPC,
    BOOLEAN  fActive
    )
{
    PMODULE_RECORD  pModule     = NULL;
    PPROCESS_RECORD pSysProcess = FindProcessById(0, fActive);
    PMODULE_RECORD  pCurrent    =
                        SearchModuleByAddr(& pSysProcess->ModuleListHead, lPC);
    if (pCurrent)
    {
        if (AddModuleRecord(& pModule,
                            pCurrent->lBaseAddress,
                            pCurrent->lModuleSize,
                            pCurrent->strModuleName))
        {
            EnterTracelibCritSection();
            InsertHeadList(
                    & pProcess->ModuleListHead,
                    & pModule->Entry);
            LeaveTracelibCritSection();

            pModule->pProcess   = pProcess;
            pModule->pGlobalPtr = pCurrent->pGlobalPtr;
        }
    }

    return pModule;
}

VOID
PageFaultCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PEVENT_TRACE_HEADER pHeader;
    PPROCESS_RECORD     pProcess;
    PMOF_DATA           pMofData;
    ULONG               lFaultAddr = 0;
    ULONG               lPC = 0;
    PVOID               fDO = NULL;
    LONG                lByteCount = 0;
    LONGLONG            lByteOffset = 0;
    WCHAR               strHotFileName[1024];
    ULONG               rtnLength = sizeof(WCHAR) * 1024;
    BOOLEAN             fSpecialHPF = FALSE;
    BOOLEAN             fFound;

    if (pEvent == NULL)
        return;

    if (!InTimeWindow(pEvent, pThread))
        return;

    GetMofData(pEvent, L"VirtualAddress", &lFaultAddr, sizeof(ULONG));
    GetMofData(pEvent, L"ProgramCounter", &lPC, sizeof(ULONG));

    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;

    if (   pHeader->Class.Type == EVENT_TRACE_TYPE_MM_HPF
        && pEvent->MofLength > 2 * sizeof(ULONG))
    {
        fSpecialHPF = TRUE;
        GetMofData(pEvent, L"FileObject", &fDO, sizeof(ULONG));
        GetMofData(pEvent, L"ByteCount",  &lByteCount, sizeof(LONG));
        GetMofData(pEvent, L"ByteOffset", &lByteOffset, sizeof(LONGLONG));
        GetMofData(pEvent, L"FileName", &strHotFileName, rtnLength);
    }


    if (pThread == NULL)
    {
        if (AddThread(pHeader->ThreadId, pEvent, &pThread ))
        {

/*
#if DBG
            DbgPrint("WARNING(%d): Thread %x added to charge PageFault event\n",
                   EventCount, pHeader->ThreadId);
#endif
*/
            pThread->pProcess = FindProcessById(0, TRUE);
            pThread->TimeStart = pHeader->TimeStamp.QuadPart;
            pThread->fOrphan   = TRUE;

            pThread->KCPUStart = pHeader->KernelTime;
            pThread->UCPUStart   = pHeader->UserTime;
            AdjustThreadTime(pEvent, pThread);
        }
        else
        {
/*
#if DBG
            DbgPrint("FATBUG(%d): Cannot add thread %x for PageFault Event.\n",
                    EventCount, pHeader->ThreadId);
#endif
*/
            return;
        }
    }
/*
#if DBG
    else if (pThread->fOrphan)
    {
        DbgPrint("INFO(%d): PageFault Event Thread %x Is Still Orphan.\n",
                EventCount, pHeader->ThreadId);
    }
    else if (pThread->DeadFlag)
    {
        DbgPrint("INFO(%d): PageFault Event Thread %x Is Already Dead.\n",
                EventCount, pHeader->ThreadId);
    }
#endif
*/
    pMofData = (PMOF_DATA)pThread->pMofData;

    if (pMofData && !fSpecialHPF)
    {
        switch(pHeader->Class.Type)
        {
        case EVENT_TRACE_TYPE_MM_TF  : pMofData->MmTf++;  break;
        case EVENT_TRACE_TYPE_MM_DZF : pMofData->MmDzf++; break;
        case EVENT_TRACE_TYPE_MM_COW : pMofData->MmCow++; break;
        case EVENT_TRACE_TYPE_MM_GPF : pMofData->MmGpf++; break;
        }
    }

    // Update loaded image MODULE_RECORD::lFaultCount
    //
    pProcess = pThread->pProcess;

    if (pProcess != NULL)
    {
        PMODULE_RECORD pModule = SearchModuleByAddr(
                                         & pProcess->ModuleListHead,
                                         lPC);

        fFound = FALSE;
        if (fSpecialHPF)
        {
            PHPF_RECORD pHPFRecord = NULL;

            PageFaultCount ++;
            if (AddHPFRecord(& pHPFRecord, lFaultAddr,
                            fDO, lByteCount, lByteOffset))
            {
                PLIST_ENTRY pHead = & pThread->HPFReadListHead;
                PLIST_ENTRY pNext = pHead->Flink;
                PHPF_FILE_RECORD pHPFFileRecord;
                PHPF_FILE_RECORD pHPFThreadRead;
                LONG             lTotalByte = 0;
                BOOLEAN          fAssociatedIrp = TRUE;

                EnterTracelibCritSection();
                pHPFRecord->RecordID = PageFaultCount;
                InsertHeadList(& pProcess->HPFListHead, & pHPFRecord->Entry);
                while (fAssociatedIrp && pNext != pHead)
                {
                    pHPFThreadRead = CONTAINING_RECORD(pNext,
                                                       HPF_FILE_RECORD,
                                                       Entry);
                    pNext = pNext->Flink;
                    fAssociatedIrp = (BOOLEAN) ((pHPFThreadRead->IrpFlags
                                      & IRP_ASSOCIATED_IRP) != 0);

                    if (!fAssociatedIrp && fDO != pHPFThreadRead->fDO)
                    {
                        fAssociatedIrp = TRUE;
                        continue;
                    }

                     if (AddHPFFileRecord(& pHPFFileRecord,
                                            pHPFThreadRead->RecordID,
                                            pHPFThreadRead->IrpFlags,
                                            pHPFThreadRead->DiskNumber,
                                            pHPFThreadRead->ByteOffset,
                                            pHPFThreadRead->BytesCount,
                                            pHPFThreadRead->fDO))
                     {
                         lTotalByte += pHPFThreadRead->BytesCount;
                         InsertHeadList(& pHPFRecord->HPFReadListHead,
                                        & pHPFFileRecord->Entry);
                     }
                     RemoveEntryList(& pHPFThreadRead->Entry);
                     free(pHPFThreadRead);
                }
                LeaveTracelibCritSection();
            }

            goto Cleanup;
        }
        else if (pHeader->Class.Type == EVENT_TRACE_TYPE_MM_HPF)
        {
            PLIST_ENTRY pHead = & pProcess->HPFListHead;
            PLIST_ENTRY pNext = pHead->Flink;
            PHPF_RECORD pHPFRecord;

            while (pNext != pHead)
            {
                pHPFRecord = CONTAINING_RECORD(pNext, HPF_RECORD, Entry);
                pNext      = pNext->Flink;
                if (pHPFRecord->lFaultAddress == lFaultAddr)
                {
                    pHPFRecord->lProgramCounter = lPC;
                    break;
                }
            }
        }

        if (pModule)
        {
            UpdatePageFaultCount(
                    pProcess, pModule, lFaultAddr, pHeader->Class.Type);
            fFound = TRUE;
        }

        if (!fFound && pProcess->PID != 0)
        {
            PMODULE_RECORD pModule = SearchSysModule(pProcess, lPC, TRUE);
            if (pModule)
            {
                UpdatePageFaultCount(
                        pProcess, pModule, lFaultAddr, pHeader->Class.Type);
                fFound = TRUE;
            }
        }

        if (!fFound)
        {
            PLIST_ENTRY    pModuleHead = & pProcess->ModuleListHead;
            PLIST_ENTRY    pModuleNext = pModuleHead->Flink;
            PMODULE_RECORD pModule;

            while (pModuleNext != pModuleHead)
            {
                pModule = CONTAINING_RECORD(pModuleNext,
                                            MODULE_RECORD,
                                            Entry);
                pModuleNext = pModuleNext->Flink;
                if (!_wcsicmp(pModule->strModuleName, L"other"))
                {
                    if (   pModule->lBaseAddress == 0
                        && pModule->lModuleSize  == 0)
                    {
                        pModule->lBaseAddress = lPC;
                        pModule->lModuleSize  = 1;
                    }
                    else if (pModule->lBaseAddress > lPC)
                    {
                        pModule->lModuleSize += pModule->lBaseAddress - lPC;
                        pModule->lBaseAddress = lPC;
                    }
                    else if (  pModule->lModuleSize
                             < lPC - pModule->lBaseAddress + 1)
                    {
                        pModule->lModuleSize =
                                lPC - pModule->lBaseAddress + 1;
                    }
                    UpdatePageFaultCount(
                            pProcess,
                            pModule,
                            lFaultAddr,
                            pHeader->Class.Type);
                    break;
                }
            }
        }
    }
    else
    {
/*
#if DBG
        DbgPrint("ERROR - PageFaultCallback(0x%08I64x,0x%08I64x,0x%08x,0x%08x) cannot find process\n",
                pHeader->ThreadId,
                pThread->pProcess->PID,
                lPC,
                lFaultAddr);
#endif
*/
    }

Cleanup:
    return;
}

VOID
DiskIoCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    if (pEvent == NULL)
        return;

    if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_IO_READ) {
        IoReadCallback(pEvent, pThread);
    }
    else {
        IoWriteCallback(pEvent, pThread);
    }
}

VOID
TcpIpCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PEVENT_TRACE_HEADER pHeader;
    PPROCESS_RECORD     pProcess;
    ULONG size = 0;

    if (pEvent == NULL)
        return;
    pHeader = (EVENT_TRACE_HEADER*)&pEvent->Header;

    if (!InTimeWindow(pEvent, pThread))
        return;

    if (pThread == NULL)
    {
        if (AddThread(pHeader->ThreadId, pEvent, &pThread ))
        {

/*
#if DBG
            DbgPrint("WARNING(%d): Thread %x added to charge TCP/IP event\n",
                   EventCount, pHeader->ThreadId);
#endif
*/
            pThread->pProcess = FindProcessById(0, TRUE);
            pThread->TimeStart = pHeader->TimeStamp.QuadPart;
            pThread->fOrphan   = TRUE;

            pThread->KCPUStart = pHeader->KernelTime;
            pThread->UCPUStart   = pHeader->UserTime;
            AdjustThreadTime(pEvent, pThread);
        }
        else
        {
/*
#if DBG
            DbgPrint("FATBUG(%d): Cannot add thread %x for TCP/IP Event.\n",
                    EventCount, pHeader->ThreadId);
#endif
*/
            return;
        }
    }
/*
#if DBG
    else if (pThread->fOrphan)
    {
        DbgPrint("INFO(%d): TCP/IP Event Thread %x Is Still Orphan.\n",
                EventCount, pHeader->ThreadId);
    }
    else if (pThread->DeadFlag)
    {
        DbgPrint("INFO(%d): TCP/IP Event Thread %x Is Already Dead.\n",
                EventCount, pHeader->ThreadId);
    }
#endif
*/
    if (GetMofData(pEvent, L"size", &size, sizeof(ULONG)) > 0) {

        if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SEND ) {

            pThread->SendCount++;
            pThread->SendSize += size;

            if (pThread->pMofData != NULL) {
                ((PMOF_DATA)pThread->pMofData)->SendCount++;
            }

            if ( (pProcess = pThread->pProcess) != NULL ) {
                pProcess->SendCount++;
                pProcess->SendSize += size;
            }

        } else if( pEvent->Header.Class.Type == EVENT_TRACE_TYPE_RECEIVE ) {

            pThread->RecvCount++;
            pThread->RecvSize += size;

            if (pThread->pMofData != NULL) {
                ((PMOF_DATA)pThread->pMofData)->RecvCount++;
            }

            if ( (pProcess = pThread->pProcess) != NULL ) {
                pProcess->RecvCount++;
                pProcess->RecvSize += size;
            }
        }
    }
}

PFILE_OBJECT
FindFileInTable (
    IN PVOID fDO
    )
{
    PFILE_OBJECT thisFile, lastFile = NULL;
    PFILE_OBJECT *fileTable;
    UINT i;
    fileTable = CurrentSystem.FileTable;
    for (i = 0; i < MAX_FILE_TABLE_SIZE; i++) {
        thisFile = fileTable[i];
        fileTable[i] = lastFile;
        lastFile = thisFile;
        if ((thisFile != NULL) && (thisFile->fDO == fDO)) {
            fileTable[0] = thisFile;
            return thisFile;
        }
    }
    if (lastFile == NULL) {
        lastFile = (PFILE_OBJECT) malloc( sizeof(FILE_OBJECT));
        if (lastFile == NULL) {
            return NULL;
        }
    }
    fileTable[0] = lastFile;
    lastFile->fDO = fDO;
    lastFile->fileRec = NULL;
    InitializeListHead( &lastFile->ProtoFileRecordListHead );
    return lastFile;

}


//
// TODO: Redo the EventList as FILE_RECORDS with Unknown Filenames
//       The current implementation will create a proto record for
//       evenry I/O and if the  APC never arrives, it can choke the
//       system!
//

VOID
AddEvent(
    IN PFILE_OBJECT fileObject,
    IN ULONG DiskNumber,
    IN ULONG IoSize,
    IN BOOLEAN ReadFlag
    )
{
    PPROTO_FILE_RECORD protoFileRec;

    if (fileObject->fileRec != NULL) {
/*
#if DBG
        DbgPrint("BUG: FileObject  is NONNULL in AddEvent\n");
#endif
*/
    }

    protoFileRec = (PPROTO_FILE_RECORD) malloc(sizeof(PROTO_FILE_RECORD));
    if (protoFileRec == NULL) {
        return;
    }
    protoFileRec->ReadFlag = ReadFlag;
    protoFileRec->IoSize = IoSize;
    protoFileRec->DiskNumber = DiskNumber;

    InsertHeadList( &fileObject->ProtoFileRecordListHead, &protoFileRec->Entry);

    // Currently NOT Keeping track of the DrillDown data for the File
    // if APC has not happened yet. Some Events may be lost.
}


ULONG
GetMofData(
    PEVENT_TRACE pEvent,
    WCHAR *strName,
    PVOID ReturnValue,
    ULONG ReturnLength
    )
{
    PITEM_DESC pAuxInfo;
    PUCHAR pData = (PUCHAR) pEvent->MofData;
    ULONG RequiredLength = 0;
    BOOLEAN  AddNull = FALSE;
    PLIST_ENTRY Head, Next;
    PMOF_INFO pMofInfo;
    PMOF_VERSION pMofVersion;

    if (pEvent == NULL)
        return 0;

    if (strName == NULL)
        return 0;
    if (lstrlenW(strName) <= 0)
        return 0;

    pMofInfo = GetMofInfoHead(&pEvent->Header.Guid);
    if (pMofInfo == NULL)
        return 0;

    pMofVersion = GetMofVersion(pMofInfo,
                                pEvent->Header.Class.Type,
                                pEvent->Header.Class.Version,
                                pEvent->Header.Class.Level
                            );

    if (pMofVersion == NULL)
        return 0;

    Head = &pMofVersion->ItemHeader;
    Next = Head->Flink;
    while (Head != Next) {
        pAuxInfo = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        if ( (ULONG) (pData-(PUCHAR)pEvent->MofData) >= pEvent->MofLength)
            return 0;

        switch (pAuxInfo->ItemType) {
        case ItemShort:
        case ItemUShort:
            {
                RequiredLength = 2;
            }
            break;
        case ItemULong:
        case ItemULongX:
            {
                RequiredLength = 4;
            }
            break;
        case ItemLongLong:
        case ItemULongLong:
            {
                RequiredLength = 8;
            }
            break;
        case ItemPString :
            pData += sizeof(USHORT);
        case ItemString :
            RequiredLength = lstrlenA((PCHAR)pData) + 1;
            break;
        case ItemWString :

            //
            // FileNames etc are not NULL Terminated and only the buffer
            // is copied. To find its length, we can't use wcslen.
            // The Length is computed from the assumption that this string
            // is the last item for this event and the size of the event
            // should help determine the size of this string.

            RequiredLength =  pEvent->MofLength -
                              (ULONG) (pData - (PUCHAR) pEvent->MofData);

            AddNull = TRUE;

            break;

        case ItemSid :
                {
                    PULONG pSid;
                    pSid = (PULONG) pData;
                    if (*pSid == 0) {
                        RequiredLength = 4;
                    }
                    else {
                        pData += 8;         // skip the TOKEN_USER structure
                        RequiredLength = 8 + (4*pData[1]);

                    }
                }
            break;
        case ItemPtr :
        {
            RequiredLength = PointerSize / 8;
            if ( (RequiredLength != 4) && (RequiredLength != 8)  ) {
                RequiredLength = 4;
            }
            break;
        }
        default : RequiredLength = pAuxInfo->DataSize;
        }
        if (!wcscmp(pAuxInfo->strDescription, strName)) {
            if (RequiredLength == 0) return 0;
            //
            // Make Sure there is enough room to copy 
            //
            if (RequiredLength > ReturnLength) {
/*
#if DBG
                DbgPrint("RequiredLength %d Space Available %d\n", RequiredLength, ReturnLength);
#endif
*/
                return RequiredLength;
            }

            memcpy(ReturnValue, pData, RequiredLength);

            if (AddNull) {
                WCHAR* ws;
                ws = (WCHAR*) ReturnValue;
                ws[RequiredLength/2] = 0;
            }


            return 0;
        }
        else {

        }
        pData += RequiredLength;
        Next = Next->Flink;
    }
    return RequiredLength;
}


ULONG
GetDeltaWithTimeWindow(BOOLEAN fKCPU, PTHREAD_RECORD pThread,
                       ULONGLONG timeStart, ULONGLONG timeEnd,
                       ULONG DeltaStart, ULONG DeltaEnd)
{
    ULONG lResult = 0;
    ULONG lDeltaStart, lDeltaEnd;

    UNREFERENCED_PARAMETER(pThread);

    if (!fDSOnly)
    {
        lResult = (DeltaEnd > DeltaStart) ? (DeltaEnd - DeltaStart) : (0);
    }
    else if ((timeStart >= DSEndTime) || (timeEnd <= DSStartTime))
    {
        lResult = 0;
    }
    else if (fKCPU)
    {
        lDeltaStart = (timeStart < DSStartTime)
                    ? Interpolate(timeStart, DeltaStart,
                                  timeEnd, DeltaEnd,
                                  DSStartTime)
                    : DeltaStart;
        lDeltaEnd   = (timeEnd > DSEndTime)
                    ? Interpolate(timeStart, DeltaStart,
                                  timeEnd, DeltaEnd,
                                  DSEndTime)
                    : DeltaEnd;
        lResult = (lDeltaEnd > lDeltaStart) ? (lDeltaEnd - lDeltaStart) : (0);
    }
    else
    {
        lDeltaStart = (timeStart < DSStartTime)
                    ? Interpolate(timeStart, DeltaStart,
                                  timeEnd, DeltaEnd,
                                  DSStartTime)
                    : DeltaStart;
        lDeltaEnd   = (timeEnd > DSEndTime)
                    ? Interpolate(timeStart, DeltaStart,
                                  timeEnd, DeltaEnd,
                                  DSEndTime)
                    : DeltaEnd;
        lResult = (lDeltaEnd > lDeltaStart) ? (lDeltaEnd - lDeltaStart) : (0);
    }
    return lResult;
}

// Generic Event Callback. Get the Transaction Response Time.
//
VOID
EventCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    )
{
    PMOF_INFO pMofInfo;
    PMOF_DATA pMofData;
    PEVENT_TRACE_HEADER pHeader;
    PPROCESS_RECORD pProcess;
    PTRANS_RECORD pThreadTrans = NULL;
    ULONGLONG delta;

    if (pEvent == NULL)
        return;
    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;

    //
    // Ignore Process/Thread Start/End transactions. Only go after
    // User Defined  Transactions.
    //
    pMofInfo = GetMofInfoHead(&pHeader->Guid);
    if (pMofInfo == NULL){
         return;
    }

    if ( pMofInfo->bKernelEvent ){
        return;
    }

    if (IsEqualGUID( &pMofInfo->Guid, &EventTraceGuid ) ||
        pEvent->Header.Class.Type == EVENT_TRACE_TYPE_GUIDMAP) {
        return;
    }

    if (pThread == NULL) {
        if (AddThread( pHeader->ThreadId, pEvent, &pThread )) {

/*
#if DBG
            DbgPrint("WARNING(%d): Thread %x added to charge Event.\n",
                    EventCount, pHeader->ThreadId);
#endif
*/
            pThread->pProcess = FindProcessById(0, TRUE); // Charge it the system ???
            pThread->TimeStart = pHeader->TimeStamp.QuadPart;
            pThread->KCPUStart = pHeader->KernelTime;
            pThread->UCPUStart = pHeader->UserTime;
            pThread->fOrphan   = TRUE;
            AdjustThreadTime(pEvent, pThread);
        }
        else
        {
/*
#if DBG
            DbgPrint("FATBUG(%d): Cannot add thread %x for Event.\n",
                    EventCount, pHeader->ThreadId);
#endif
*/
            return;
        }
    }
/*
#if DBG
    else if (pThread->fOrphan)
    {
        DbgPrint("INFO(%d): Generic Event Thread %x Is Still Orphan.\n",
                EventCount, pHeader->ThreadId);
    }
    else if (pThread->DeadFlag)
    {
        DbgPrint("INFO(%d): Generic Event Thread %x Is Already Dead.\n",
                EventCount, pHeader->ThreadId);
    }
#endif
*/
    if (pMofInfo->strSortField == NULL){
        pMofData = FindMofData(pMofInfo, NULL);
    }
    else if (   (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_START)
             || (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_START)){
        WCHAR           strSortKey[MAXSTR];

        RtlZeroMemory(strSortKey, MAXSTR * sizeof(WCHAR) );

        GetMofData(pEvent, pMofInfo->strSortField, &strSortKey, MAXSTR);
        pMofData = FindMofData(pMofInfo, strSortKey );
        wcscpy(pThread->strSortKey, strSortKey );

    }else{
        pMofData = FindMofData( pMofInfo, pThread->strSortKey );
    }

    pProcess     = pThread->pProcess;
    if (   (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_START)
        || (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_START)){
        pThreadTrans = FindTransByList(& pThread->TransListHead,
                                       & pMofInfo->Guid, 
                                       pThread->TransLevel);
    }
    else
    {
        LONG i = pThread->TransLevel - 1;

        while (i >= 0)
        {
            if (IsEqualGUID(& pHeader->Guid,
                            pThread->TransStack[i]->pGuid))
            {
                pThreadTrans = pThread->TransStack[i];
                break;
            }
            i --;
        }
        if (i < 0)
        {
            pThreadTrans = FindTransByList(& pThread->TransListHead, 
                                           &pMofInfo->Guid, 
                    (pThread->TransLevel >= 0) ? (pThread->TransLevel) : (0));
            if (pThread->TransLevel < 0)
            {
                pThread->TransLevel = 0;
                pThread->TransStack[pThread->TransLevel] = pThreadTrans;
                pThread->TransLevel ++;
            }

        }
    }

    if (pMofData == NULL) {
        return;
    }

    if (pMofData->PrevClockTime == 0)
    {
        pMofData->PrevClockTime = pHeader->TimeStamp.QuadPart;
    }

    delta = (pHeader->TimeStamp.QuadPart - pMofData->PrevClockTime);
    pMofData->TotalResponseTime += (delta * pMofData->InProgressCount) / 10000;

    // Update the Clock
    pMofData->PrevClockTime = pHeader->TimeStamp.QuadPart;

    if (   (pHeader->Class.Type == EVENT_TRACE_TYPE_START)
        || (pHeader->Class.Type == EVENT_TRACE_TYPE_DC_START))
    {
        if (pThread->TransLevel < 0)
        {
            pThread->TransLevel = 0;
        }

        if (pThread->TransLevel == 0)
        {
            LONG lDelta;

            lDelta = pHeader->KernelTime - pThread->KCPU_PrevTrans;
            if (lDelta > 0)
            {
                pThread->KCPU_NoTrans  += lDelta;
                pThread->KCPU_PrevTrans = pHeader->KernelTime;
            }
            lDelta = pHeader->UserTime - pThread->UCPU_PrevTrans;
            if (lDelta > 0)
            {
                pThread->UCPU_NoTrans  += lDelta;
                pThread->UCPU_PrevTrans = pHeader->UserTime;
            }
        }
        else
        {
            PTRANS_RECORD pTransPrev   =
                              pThread->TransStack[pThread->TransLevel - 1];
            PMOF_INFO     pMofInfoPrev = GetMofInfoHead(pTransPrev->pGuid);
            PMOF_DATA     pMofDataPrev = NULL;
            ULONG         DeltaCPU;

            if (pMofInfoPrev != NULL)
            {
                pMofDataPrev = FindMofData(pMofInfoPrev, NULL);
            }

            if (pMofDataPrev)
            {
                DeltaCPU = GetDeltaWithTimeWindow(
                        TRUE,
                        pThread,
                        pThread->Time_PrevEvent,
                        (ULONGLONG) pHeader->TimeStamp.QuadPart,
                        pThread->KCPU_PrevEvent,
                        pHeader->KernelTime);
                DeltaCPU = DeltaCPU * CurrentSystem.TimerResolution;

                pTransPrev->KCpu        += DeltaCPU;
                pMofDataPrev->KernelCPU += DeltaCPU;
                if (pMofDataPrev->MaxKCpu < 0)
                {
                    pMofDataPrev->MaxKCpu = DeltaCPU;
                    pMofDataPrev->MinKCpu = DeltaCPU;
                }
                if (DeltaCPU > (ULONG) pMofDataPrev->MaxKCpu)
                {
                    pMofDataPrev->MaxKCpu = DeltaCPU;
                }
                if (DeltaCPU < (ULONG) pMofDataPrev->MinKCpu)
                {
                    pMofDataPrev->MinKCpu = DeltaCPU;
                }

                DeltaCPU = GetDeltaWithTimeWindow(
                        FALSE,
                        pThread,
                        pThread->Time_PrevEvent,
                        (ULONGLONG) pHeader->TimeStamp.QuadPart,
                        pThread->UCPU_PrevEvent,
                        pHeader->UserTime);
                DeltaCPU = DeltaCPU * CurrentSystem.TimerResolution;

                pTransPrev->UCpu        += DeltaCPU;
                pMofDataPrev->UserCPU += DeltaCPU;
                if (pMofDataPrev->MaxUCpu < 0)
                {
                    pMofDataPrev->MaxUCpu = DeltaCPU;
                    pMofDataPrev->MinUCpu = DeltaCPU;
                }
                if (DeltaCPU > (ULONG) pMofDataPrev->MaxUCpu)
                {
                    pMofDataPrev->MaxUCpu = DeltaCPU;
                }
                if (DeltaCPU < (ULONG) pMofDataPrev->MinUCpu)
                {
                    pMofDataPrev->MinUCpu = DeltaCPU;
                }
            }
        }

        if( pThreadTrans != NULL ){
            if( ! pThreadTrans->bStarted ){
                pThreadTrans->bStarted = TRUE;

                pMofData->InProgressCount ++;

                if (pHeader->Class.Type == EVENT_TRACE_TYPE_START) {
                    pThread->RefCount ++;
                    pThreadTrans->RefCount ++;
                }
                else {
                    pThreadTrans->RefCount1 ++;
                }

                pThread->pMofData = pMofData;

                pThread->TransStack[pThread->TransLevel] = pThreadTrans;
                pThread->TransLevel ++;
            }
        }
        pThread->Time_PrevEvent = (ULONGLONG) pHeader->TimeStamp.QuadPart;
        pThread->KCPU_PrevEvent = pHeader->KernelTime;
        pThread->UCPU_PrevEvent = pHeader->UserTime;

        pThread->DeltaReadIO  = pThread->ReadIO;
        pThread->DeltaWriteIO = pThread->WriteIO;

        pThread->DeltaSend    = pThread->SendCount;
        pThread->DeltaRecv    = pThread->RecvCount;
    }
    else if (   (pHeader->Class.Type == EVENT_TRACE_TYPE_END)
             || (pHeader->Class.Type == EVENT_TRACE_TYPE_DC_END))
    {
        ULONG DeltaCPU;
        BOOLEAN fSwitch = TRUE;
        if( pThreadTrans != NULL ){

            if (pThreadTrans->bStarted){

                PTRANS_RECORD pTransCurrent;
                PMOF_INFO     pMofInfoCurrent;
                PMOF_DATA     pMofDataCurrent;
                BOOLEAN       fCharged = FALSE;

                if (pThread->TransLevel <= 0)
                {
                    pThread->TransLevel = 0;
                }
                else {
                    do
                    {
                        pThread->TransLevel --;
                        pTransCurrent = pThread->TransStack[pThread->TransLevel];
                        if (pTransCurrent->bStarted)
                        {
                            pTransCurrent->bStarted = FALSE;
                        }

                        pMofInfoCurrent = GetMofInfoHead( pTransCurrent->pGuid );
                        pMofDataCurrent = NULL;

                        if (pMofInfoCurrent != NULL)
                        {
                            pMofDataCurrent = FindMofData(pMofInfoCurrent, NULL);
                        }

                        if (!pMofDataCurrent)
                            continue;

                        pMofDataCurrent->InProgressCount--;

                        if (pMofDataCurrent->InProgressCount < 0){
                            pMofDataCurrent->InProgressCount = 0;
                        }
                        pMofDataCurrent->CompleteCount++;

                        pMofDataCurrent->AverageResponseTime
                                = (pMofDataCurrent->CompleteCount > 0)
                                ? (  (LONG) pMofDataCurrent->TotalResponseTime
                                   / pMofDataCurrent->CompleteCount)
                                : 0;

                        if (fCharged)
                            continue;

                        DeltaCPU = GetDeltaWithTimeWindow(
                                    TRUE,
                                    pThread,
                                    pThread->Time_PrevEvent,
                                    (ULONGLONG) pHeader->TimeStamp.QuadPart,
                                    pThread->KCPU_PrevEvent,
                                    pHeader->KernelTime);
                        DeltaCPU = DeltaCPU * CurrentSystem.TimerResolution;

                        pTransCurrent->KCpu += DeltaCPU;
                        pMofDataCurrent->KernelCPU += DeltaCPU;
                        if (pMofDataCurrent->MaxKCpu < 0)
                        {
                            pMofDataCurrent->MaxKCpu = DeltaCPU;
                            pMofDataCurrent->MinKCpu = DeltaCPU;
                        }
                        if (DeltaCPU > (ULONG) pMofDataCurrent->MaxKCpu)
                        {
                            pMofDataCurrent->MaxKCpu = DeltaCPU;
                        }
                        if (DeltaCPU < (ULONG) pMofDataCurrent->MinKCpu)
                        {
                            pMofDataCurrent->MinKCpu = DeltaCPU;
                        }

                        DeltaCPU = GetDeltaWithTimeWindow(
                                    FALSE,
                                    pThread,
                                    pThread->Time_PrevEvent,
                                    (ULONGLONG) pHeader->TimeStamp.QuadPart,
                                    pThread->UCPU_PrevEvent,
                                    pHeader->UserTime);
                        DeltaCPU = DeltaCPU * CurrentSystem.TimerResolution;

                        pTransCurrent->UCpu += DeltaCPU;
                        pMofDataCurrent->UserCPU += DeltaCPU;
                        if(pMofDataCurrent->MaxUCpu < 0)
                        {
                            pMofDataCurrent->MaxUCpu = DeltaCPU;
                            pMofDataCurrent->MinUCpu = DeltaCPU;
                        }
                        if (DeltaCPU > (ULONG) pMofDataCurrent->MaxUCpu)
                        {
                            pMofDataCurrent->MaxUCpu = DeltaCPU;
                        }
                        fCharged = TRUE;
                    }while ( pThread->TransLevel > 0 && 
                            !IsEqualGUID(& pHeader->Guid, pTransCurrent->pGuid));
                }

                pThread->Time_PrevEvent = (ULONGLONG) pHeader->TimeStamp.QuadPart;
                pThread->KCPU_PrevEvent = pHeader->KernelTime;
                pThread->UCPU_PrevEvent = pHeader->UserTime;
            }
            else
            {
                DeltaCPU = GetDeltaWithTimeWindow(
                                TRUE,
                                pThread,
                                (ULONGLONG) pHeader->TimeStamp.QuadPart,
                                (ULONGLONG) pHeader->TimeStamp.QuadPart,
                                pHeader->KernelTime,
                                pHeader->KernelTime);
                DeltaCPU = DeltaCPU * CurrentSystem.TimerResolution;

                pThreadTrans->KCpu += DeltaCPU;
                pMofData->KernelCPU += DeltaCPU;
                if (pMofData->MaxKCpu < 0)
                {
                    pMofData->MaxKCpu = DeltaCPU;
                    pMofData->MinKCpu = DeltaCPU;
                }
                if (DeltaCPU > (ULONG) pMofData->MaxKCpu)
                {
                    pMofData->MaxKCpu = DeltaCPU;
                }
                if (DeltaCPU < (ULONG) pMofData->MinKCpu)
                {
                    pMofData->MinKCpu = DeltaCPU;
                }

                DeltaCPU = GetDeltaWithTimeWindow(
                                FALSE,
                                pThread,
                                (ULONGLONG) pHeader->TimeStamp.QuadPart,
                                (ULONGLONG) pHeader->TimeStamp.QuadPart,
                                pHeader->UserTime,
                                pHeader->UserTime);
                DeltaCPU = DeltaCPU * CurrentSystem.TimerResolution;

                pThreadTrans->UCpu += DeltaCPU;
                pMofData->UserCPU += DeltaCPU;
                if(pMofData->MaxUCpu < 0)
                {
                    pMofData->MaxUCpu = DeltaCPU;
                    pMofData->MinUCpu = DeltaCPU;
                }
                if (DeltaCPU > (ULONG) pMofData->MaxUCpu)
                {
                    pMofData->MaxUCpu = DeltaCPU;
                }
                if (DeltaCPU < (ULONG) pMofData->MinUCpu)
                {
                    pMofData->MinUCpu = DeltaCPU;
                }

                fSwitch = FALSE;
            }
        }

        pMofData->ReadCount  += (pThread->ReadIO    - pThread->DeltaReadIO);
        pMofData->WriteCount += (pThread->WriteIO   - pThread->DeltaWriteIO);
        pMofData->SendCount  += (pThread->SendCount - pThread->DeltaSend);
        pMofData->RecvCount  += (pThread->RecvCount - pThread->DeltaRecv);
        pThread->pMofData     = NULL;

        if (fSwitch && pThread->TransLevel <= 0)
        {
            LONG lDelta;

            if (pThread->TransLevel < 0)
            {
                pThread->TransLevel = 0;
            }
            lDelta = pHeader->KernelTime - pThread->KCPU_PrevTrans;
            if (lDelta > 0)
            {
                pThread->KCPU_Trans    += lDelta;
                pThread->KCPU_PrevTrans = pHeader->KernelTime;
            }
            lDelta = pHeader->UserTime - pThread->UCPU_PrevTrans;
            if (lDelta > 0)
            {
                pThread->UCPU_Trans    += lDelta;
                pThread->UCPU_PrevTrans = pHeader->UserTime;
            }
        }
    }
}

ULONG
ThreadRunDown(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo
    )
{
    PSYSTEM_THREAD_INFORMATION pThreadInfo;
    ULONG i;
    EVENT_TRACE Event;
    HANDLE EventInfo[2];
    PEVENT_TRACE_HEADER pWnode;
    ULONG TimerResolution = 1; // How do I get this??

    RtlZeroMemory(&Event, sizeof(EVENT_TRACE));

    pWnode = &Event.Header;
    pWnode->Size = sizeof(EVENT_TRACE_HEADER) + 2 * sizeof(HANDLE);
    pWnode->Class.Type          = EVENT_TRACE_TYPE_DC_START;
    Event.MofData = EventInfo;
    Event.MofLength = 2 * sizeof(HANDLE);
    GetSystemTimeAsFileTime((struct _FILETIME *)&pWnode->TimeStamp);
    RtlCopyMemory(&pWnode->Guid, &ThreadGuid, sizeof(GUID));


    pThreadInfo = (PSYSTEM_THREAD_INFORMATION) (pProcessInfo+1);

    for (i=0; i < pProcessInfo->NumberOfThreads; i++) {
        EventInfo[0]    = pThreadInfo->ClientId.UniqueThread;
        EventInfo[1]    = pThreadInfo->ClientId.UniqueProcess;
        pWnode->KernelTime = (ULONG) (pThreadInfo->KernelTime.QuadPart
                                / TimerResolution);
        pWnode->UserTime = (ULONG) (pThreadInfo->UserTime.QuadPart
                                / TimerResolution);

        ThreadCallback(&Event);

        pThreadInfo  += 1;
    }
    return ERROR_SUCCESS;
}

ULONG
ProcessRunDown(
    )
{
    PSYSTEM_PROCESS_INFORMATION  pProcessInfo;
    PSYSTEM_THREAD_INFORMATION   pThreadInfo;
    char* LargeBuffer1;
    NTSTATUS status;
    ULONG ReturnLength;
    ULONG CurrentBufferSize;
    ULONG TotalOffset = 0;
    OBJECT_ATTRIBUTES objectAttributes;
    EVENT_TRACE Event;
    ULONG_PTR AuxInfo[64];
    PEVENT_TRACE_HEADER pWnode;
    RtlZeroMemory(&Event, sizeof(EVENT_TRACE));
    pWnode = &Event.Header;
    pWnode->Size = sizeof(EVENT_TRACE_HEADER) + 2 * sizeof(HANDLE);
    pWnode->Class.Type          = EVENT_TRACE_TYPE_DC_START;
    Event.MofData = AuxInfo;
    Event.MofLength = 2 * sizeof(HANDLE);
    GetSystemTimeAsFileTime((struct _FILETIME *)&pWnode->TimeStamp);
    RtlCopyMemory(&pWnode->Guid, &ProcessGuid, sizeof(GUID));

    LargeBuffer1 = (LPSTR)VirtualAlloc (NULL,
                                 MAX_BUFFER_SIZE,
                                 MEM_RESERVE,
                                 PAGE_READWRITE);
    if (LargeBuffer1 == NULL) {
        return ERROR_MORE_DATA;
    }

    if (VirtualAlloc (LargeBuffer1,
                      BUFFER_SIZE,
                      MEM_COMMIT,
                      PAGE_READWRITE) == NULL) {
        return ERROR_MORE_DATA;
    }

    CurrentBufferSize = BUFFER_SIZE;
    retry:
    status = NtQuerySystemInformation(
                SystemProcessInformation,
                LargeBuffer1,
                CurrentBufferSize,
                &ReturnLength
                );

    if (status == STATUS_INFO_LENGTH_MISMATCH) {

        //
        // Increase buffer size.
        //

        CurrentBufferSize += 8192;

        if (VirtualAlloc (LargeBuffer1,
                          CurrentBufferSize,
                          MEM_COMMIT,
                          PAGE_READWRITE) == NULL) {
            return ERROR_MORE_DATA;
        }
        goto retry;
    }

    if (!NT_SUCCESS(status)) {
        return(status);
    }


    TotalOffset = 0;
    pProcessInfo = (SYSTEM_PROCESS_INFORMATION *) LargeBuffer1;
    while (pProcessInfo != NULL) {
        ULONG Size;
        ULONG Length = 0;
        ULONG SidLength = 0;
        PUCHAR AuxPtr;
        ANSI_STRING s;
        HANDLE Token;
        HANDLE pProcess;
        PCLIENT_ID Cid;
        ULONG TempInfo[128];

        s.Buffer = NULL;
        s.Length = 0;

        Size = sizeof(EVENT_TRACE_HEADER) + 2 * sizeof(ULONG_PTR);

        pThreadInfo = (PSYSTEM_THREAD_INFORMATION) (pProcessInfo+1);
        if (pProcessInfo->NumberOfThreads > 0) {
            Cid = (PCLIENT_ID) &pThreadInfo->ClientId;
        }
        else {
            Cid = NULL;
        }

        if ( pProcessInfo->ImageName.Buffer  &&
                 pProcessInfo->ImageName.Length > 0 ) {
            RtlUnicodeStringToAnsiString(
                                 &s,
                                 (PUNICODE_STRING)&pProcessInfo->ImageName,
                                 TRUE);
            Length = s.Length + 1;
        }
        else {
            Length = 1;
        }

        InitializeObjectAttributes(
                &objectAttributes, 0, 0, NULL, NULL);
        status = NtOpenProcess(
                              &pProcess,
                              PROCESS_QUERY_INFORMATION,
                              &objectAttributes,
                              Cid);
        if (NT_SUCCESS(status)) {
            status = NtOpenProcessToken(
                                  pProcess,
                                  TOKEN_READ,
                                  &Token);
            if (NT_SUCCESS(status)) {
                status = NtQueryInformationToken(
                                         Token,
                                         TokenUser,
                                         TempInfo,
                                         256,
                                         &SidLength);
                NtClose(Token);
            }
            NtClose(pProcess);
        }
        if ( (!NT_SUCCESS(status)) || SidLength <= 0) {
            TempInfo[0] = 0;
            SidLength = sizeof(ULONG);
        }

        Size += Length + SidLength;

        AuxInfo[0] = (ULONG_PTR) pProcessInfo->UniqueProcessId;
        AuxInfo[1] = (ULONG_PTR) pProcessInfo->InheritedFromUniqueProcessId;
        AuxPtr = (PUCHAR) &AuxInfo[2];

        RtlCopyMemory(AuxPtr, &TempInfo, SidLength);
        AuxPtr += SidLength;

        if ( Length > 1) {
            RtlCopyMemory(AuxPtr, s.Buffer, Length);
            AuxPtr += Length;
            RtlFreeAnsiString(&s);
        }
        *AuxPtr = '\0';
        AuxPtr++;

        Event.MofLength = Size - sizeof(EVENT_TRACE_HEADER);

        ProcessCallback(&Event);

        ThreadRunDown(pProcessInfo);

        if (pProcessInfo->NextEntryOffset == 0) {
            break;
        }
        TotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
    }
    VirtualFree(LargeBuffer1, 0, MEM_RELEASE);

    return status;
}



//
// This routine moves the temporary MOF_VERSION list 
// into the VersionHeader list for this GUID (MofInfo)
//


void
FlushMofVersionList( PMOF_INFO pMofInfo, PLIST_ENTRY ListHead )
{
    PMOF_VERSION pMofVersion;
    PLIST_ENTRY Head = ListHead;
    PLIST_ENTRY Next = Head->Flink;

    while( Head != Next ){
        pMofVersion = CONTAINING_RECORD(Next, MOF_VERSION, Entry);
        Next = Next->Flink;

        RemoveEntryList(&pMofVersion->Entry);
        if (pMofInfo != NULL) {
            InsertTailList( &pMofInfo->VersionHeader, &pMofVersion->Entry);
        }
        else  {
            free(pMofVersion);
        //
        // Really should not hit this case
        //
/*
#if DBG
            DbgPrint("TRACECTR: FlushMofVersionList. MofInfo ptr is NULL\n");
            ASSERT (pMofInfo != NULL);
#endif
*/
        }
    }
}


void
DumpMofVersionItem(
    PMOF_VERSION pMofVersion
    )
{
    PLIST_ENTRY Head = &pMofVersion->ItemHeader;
    PLIST_ENTRY Next = Head->Flink;
    PITEM_DESC pItem;

    DbgPrint("MOF_VERSION: Version %d Level %d Type %d strType %ws\n", 
                pMofVersion->Version,
                pMofVersion->Level,
                pMofVersion->TypeIndex,
                pMofVersion->strType);


    while( Head != Next ){
        pItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        Next = Next->Flink;


        DbgPrint("Name %ws Size %d ItemType %d\n", pItem->strDescription, pItem->DataSize, pItem->ItemType);

    }
    
}



void
DumpMofList()
{
    PMOF_INFO pMofInfo;
    PLIST_ENTRY Head = &CurrentSystem.EventListHead;
    PLIST_ENTRY Next = Head->Flink;

    while( Head != Next ){
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Next = Next->Flink;


        //
        // Count the MOF Fields for this Guid and Type
        //




        DbgPrint("Name %ws KernelEvent %d\n", pMofInfo->strDescription,
                    pMofInfo->bKernelEvent);

    }
}

PMOF_VERSION
GetGuids( GUID Guid, SHORT nVersion, CHAR nLevel, SHORT nType, BOOL bKernelEvent )
{
    if ( TraceContext->Flags & TRACE_USE_WBEM ){
        return GetGuidsWBEM( Guid, nVersion, nLevel, nType, bKernelEvent );
    }else{
        return GetGuidsFile( Guid, nVersion, nLevel, nType, bKernelEvent );
    }
}

HRESULT
WbemConnect( IWbemServices** pWbemServices )
{
    IWbemLocator     *pLocator = NULL;

    BSTR bszNamespace = SysAllocString( L"root\\wmi" );

    HRESULT hr = CoInitialize(0);

    hr = CoCreateInstance(
                CLSID_WbemLocator, 
                0, 
                CLSCTX_INPROC_SERVER,
                IID_IWbemLocator, 
                (LPVOID *) &pLocator
            );
    CHECK_HR( hr );

    hr = pLocator->ConnectServer(
                bszNamespace,
                NULL, 
                NULL, 
                NULL, 
                0L,
                NULL,
                NULL,
                pWbemServices
            );
    CHECK_HR( hr );

    hr = CoSetProxyBlanket(
            *pWbemServices,               
            RPC_C_AUTHN_WINNT,
            RPC_C_AUTHZ_NONE,
            NULL,
            RPC_C_AUTHN_LEVEL_PKT,
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, 
            EOAC_NONE
        );                     

   
cleanup:
    SysFreeString( bszNamespace );

    if( pLocator ){
        pLocator->Release(); 
        pLocator = NULL;
    }
    
    return hr;
}

ULONG GetArraySize(
    IN IWbemQualifierSet *pQualSet
    )
{
    ULONG ArraySize = 1;
    VARIANT pVal;
    BSTR bszMaxLen;
    HRESULT hRes;

    if (pQualSet == NULL){
        return ArraySize;
    }

    bszMaxLen = SysAllocString(L"MAX");
    VariantInit(&pVal);
    hRes = pQualSet->Get(bszMaxLen,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszMaxLen);
    if (ERROR_SUCCESS == hRes && pVal.vt == VT_I4 ){
        ArraySize = pVal.lVal;
    }
    VariantClear(&pVal);
    return ArraySize;
}

ITEM_TYPE
GetItemType(
    IN CIMTYPE_ENUMERATION CimType, 
    IN IWbemQualifierSet *pQualSet
    )
{
    ITEM_TYPE Type = ItemUnknown;;
    VARIANT pVal;
    HRESULT hRes;
    BSTR bszQualName;
    WCHAR strFormat[10];
    WCHAR strTermination[30];
    WCHAR strTemp[30];
    BOOLEAN IsPointer = FALSE;

    strFormat[0] = '\0';
    strTermination[0] = '\0';
    strTemp[0] = '\0';

    if (pQualSet == NULL)
        return ItemUnknown;

    bszQualName = SysAllocString(L"format");
    VariantInit(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes && NULL != pVal.bstrVal)
        wcscpy(strFormat, pVal.bstrVal);

    bszQualName = SysAllocString(L"StringTermination");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes && NULL != pVal.bstrVal)
        wcscpy(strTermination, pVal.bstrVal);

    bszQualName = SysAllocString(L"pointer");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes)
        IsPointer = TRUE;
    // Major fix required to get rid of temp
    bszQualName = SysAllocString(L"extension");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes && NULL != pVal.bstrVal)
        wcscpy(strTemp, pVal.bstrVal);

    VariantClear(&pVal);
    
    CimType = (CIMTYPE_ENUMERATION)(CimType & (~CIM_FLAG_ARRAY));

    switch (CimType) {
        case CIM_EMPTY:
            Type = ItemUnknown;
            break;        
        case CIM_SINT8:
            Type = ItemCharShort;
            if (!_wcsicmp(strFormat, L"c")){
                Type = ItemChar;
            }
            break;
        case CIM_UINT8:
            Type = ItemUChar;
            if (!_wcsicmp(strTemp, L"NoPrint")) {
                Type = ItemCharHidden;
            }
            break;
        case CIM_SINT16:
            Type = ItemShort;
            break;
        case CIM_UINT16:
            Type = ItemUShort;
            break;
        case CIM_SINT32:
            Type = ItemLong;
            break;
        case CIM_UINT32:
            Type = ItemULong;
            if (!_wcsicmp(strFormat, L"x")){
                Type = ItemULongX;
            }
            break;
        case CIM_SINT64: 
            Type = ItemLongLong;
            break;
        case CIM_UINT64:
            Type = ItemULongLong;
            break;
        case CIM_BOOLEAN:
            // ItemBool
            Type = ItemBool;
            break;
        case CIM_STRING:
            
            if (!_wcsicmp(strTermination, L"NullTerminated")) {
                if (!_wcsicmp(strFormat, L"w"))
                    Type = ItemWString;
                else
                    Type = ItemString;
            }
            else if (!_wcsicmp(strTermination, L"Counted")) {
                if (!_wcsicmp(strFormat, L"w"))
                    Type = ItemPWString;
                else
                    Type = ItemPString;
            }
            else if (!_wcsicmp(strTermination, L"ReverseCounted")) {
                if (!_wcsicmp(strFormat, L"w"))
                    Type = ItemDSWString;
                else
                    Type = ItemDSString;
            }
            else if (!_wcsicmp(strTermination, L"NotCounted")) {
                Type = ItemNWString;
            }else{
                Type = ItemString;
            }
            break;
        case CIM_CHAR16:
            // ItemWChar
            Type = ItemWChar;
            break;
        // Major fix required for executing methods from WBEM
        case CIM_OBJECT :
            if (!_wcsicmp(strTemp, L"Port"))
                Type = ItemPort;
            else if (!_wcsicmp(strTemp, L"RString"))
                Type = ItemRString;
            else if (!_wcsicmp(strTemp, L"RWString"))
                Type = ItemRWString;
            else if (!_wcsicmp(strTemp, L"IPAddr"))
                Type = ItemIPAddr;
            else if (!_wcsicmp(strTemp, L"Sid"))
                Type = ItemSid;
            else if (!_wcsicmp(strTemp, L"Guid"))
                Type = ItemGuid;
            else if (!_wcsicmp(strTemp, L"Variant"))
                Type = ItemVariant;
            else 
                Type = ItemUnknown;
            break;

        case CIM_REAL32:
        case CIM_REAL64:
        case CIM_DATETIME:
        case CIM_REFERENCE:
        case CIM_ILLEGAL:
        default:
            Type = ItemUnknown;
            break;
    }

    if (IsPointer)
        Type = ItemPtr;
    return Type;
}

PMOF_VERSION
GetPropertiesFromWBEM(
    // IWbemServices *pWbemServices,
    IWbemClassObject *pTraceSubClasses, 
    GUID Guid,
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType,
    BOOL bKernelEvent
)
{
    IEnumWbemClassObject    *pEnumTraceSubSubClasses = NULL;
    IWbemClassObject        *pTraceSubSubClasses = NULL; 
    IWbemQualifierSet       *pQualSet = NULL;

    PMOF_INFO pMofInfo = NULL;
    PMOF_VERSION pMofLookup = NULL, pMofVersion = NULL;

    BSTR bszClassName = NULL;
    BSTR bszSubClassName = NULL;
    BSTR bszWmiDataId = NULL;
    BSTR bszEventType = NULL; 
    BSTR bszEventTypeName = NULL; 
    BSTR bszFriendlyName = NULL;
    BSTR bszPropName = NULL;

    TCHAR strClassName[MAXSTR];
    TCHAR strType[MAXSTR];
    LONG pVarType;
    SHORT nEventType = EVENT_TYPE_DEFAULT; 

    LIST_ENTRY ListHead;
    HRESULT hRes;

    VARIANT pVal;
    VARIANT pTypeVal;
    VARIANT pTypeNameVal;
    VARIANT pClassName;
    ULONG lEventTypeWbem;           // when types are in an array.
    ULONG HUGEP *pTypeData;
    BSTR HUGEP *pTypeNameData;

    SAFEARRAY *PropArray = NULL;
    SAFEARRAY *TypeArray = NULL;
    SAFEARRAY *TypeNameArray = NULL;

    long lLower, lUpper, lCount, IdIndex;
    long lTypeLower, lTypeUpper;
    long lTypeNameLower, lTypeNameUpper;

    ULONG ArraySize;

    ITEM_TYPE ItemType;

    InitializeListHead(&ListHead);

    VariantInit(&pVal);
    VariantInit(&pTypeVal);
    VariantInit(&pTypeNameVal);
    VariantInit(&pClassName);

    pMofInfo = GetMofInfoHead( &Guid );
    if( NULL == pMofInfo ){
        return NULL;
    }
    pMofInfo->bKernelEvent = bKernelEvent;

    bszClassName = SysAllocString(L"__CLASS");
    bszWmiDataId = SysAllocString(L"WmiDataId");
    bszEventType = SysAllocString(L"EventType");
    bszEventTypeName = SysAllocString(L"EventTypeName");
    bszFriendlyName = SysAllocString(L"DisplayName");

    hRes = pTraceSubClasses->Get(bszClassName,          // property name 
                                        0L, 
                                        &pVal,          // output to this variant 
                                        NULL, 
                                        NULL);
    if (ERROR_SUCCESS == hRes){
        if (pQualSet) {
            pQualSet->Release();
            pQualSet = NULL;
        }
        // Get Qualifier Set to obtain the friendly name.
        pTraceSubClasses->GetQualifierSet(&pQualSet);
        hRes = pQualSet->Get(bszFriendlyName, 
                                0, 
                                &pClassName, 
                                0);
        if (ERROR_SUCCESS == hRes && pClassName.bstrVal != NULL) {
            wcscpy(strClassName, pClassName.bstrVal);
            pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(strClassName) + 1) * sizeof(TCHAR));
            if (NULL != pMofInfo->strDescription) {
                _tcscpy(pMofInfo->strDescription, strClassName);
            }
        }else{
            strClassName[0] = L'\0';
        }
    
        // Put Event Header
        pMofVersion = GetNewMofVersion(
                                    EVENT_TYPE_DEFAULT,
                                    EVENT_VERSION_DEFAULT,
                                    EVENT_LEVEL_DEFAULT
                                    );
        if (pMofVersion != NULL) {
            pMofLookup = pMofVersion;
            InsertTailList(&ListHead, &pMofVersion->Entry);
        }
        else{
            goto cleanup;
        }

        // Create an enumerator to find derived classes.
        bszSubClassName = SysAllocString(pVal.bstrVal);
        hRes = pWbemServices->CreateClassEnum ( 
                                    bszSubClassName,                                                // class name
                                    WBEM_FLAG_SHALLOW | WBEM_FLAG_USE_AMENDED_QUALIFIERS,           // shallow search
                                    NULL,
                                    &pEnumTraceSubSubClasses
                                    );
        SysFreeString ( bszSubClassName );
        if (ERROR_SUCCESS == hRes) {
            ULONG uReturnedSub = 1;

            while(uReturnedSub == 1){
                // For each event in the subclass
                pTraceSubSubClasses = NULL;
                hRes = pEnumTraceSubSubClasses->Next((-1),                  // timeout in infinite seconds
                                                    1,                      // return just one instance
                                                    &pTraceSubSubClasses,   // pointer to a Sub class
                                                    &uReturnedSub);         // number obtained: one or zero
                if (ERROR_SUCCESS == hRes && uReturnedSub == 1) {
                    if (pQualSet) {
                        pQualSet->Release();
                        pQualSet = NULL;
                    }
                    // Get Qualifier Set.
                    pTraceSubSubClasses->GetQualifierSet(&pQualSet);
                    // Get Type number among Qualifiers
                    VariantClear(&pTypeVal);
                    hRes = pQualSet->Get(bszEventType, 
                                            0, 
                                            &pTypeVal, 
                                            0);
                    if (ERROR_SUCCESS == hRes) {
                        TypeArray = NULL;
                        TypeNameArray = NULL;
                        if (pTypeVal.vt & VT_ARRAY) {   // EventType is an array
                            TypeArray = pTypeVal.parray;
                            VariantClear(&pTypeNameVal);
                            hRes = pQualSet->Get(bszEventTypeName, 
                                                    0, 
                                                    &pTypeNameVal, 
                                                    0);
                            if ((ERROR_SUCCESS == hRes) && (pTypeNameVal.vt & VT_ARRAY)) {
                                TypeNameArray = pTypeNameVal.parray;
                            }
                            if (TypeArray != NULL) {
                                hRes = SafeArrayGetLBound(TypeArray, 1, &lTypeLower);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                hRes = SafeArrayGetUBound(TypeArray, 1, &lTypeUpper);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                if (lTypeUpper < 0) {
                                    break;
                                }
                                SafeArrayAccessData(TypeArray, (void HUGEP **)&pTypeData );

                                if (TypeNameArray != NULL) {
                                    hRes = SafeArrayGetLBound(TypeNameArray, 1, &lTypeNameLower);
                                    if (ERROR_SUCCESS != hRes) {
                                        break;
                                    }
                                    hRes = SafeArrayGetUBound(TypeNameArray, 1, &lTypeNameUpper);
                                    if (ERROR_SUCCESS != hRes) {
                                        break;
                                    }
                                    if (lTypeNameUpper < 0) 
                                        break;
                                    SafeArrayAccessData(TypeNameArray, (void HUGEP **)&pTypeNameData );
                                }

                                for (lCount = lTypeLower; lCount <= lTypeUpper; lCount++) { 
                                    lEventTypeWbem = pTypeData[lCount];
                                    nEventType = (SHORT)lEventTypeWbem;
                                    pMofVersion = GetNewMofVersion(nEventType, nVersion, nLevel);
                                    if (pMofVersion != NULL) {
                                        InsertTailList(&ListHead, &pMofVersion->Entry);
                                        if (nType == nEventType) {
                                            // Type matched
                                            pMofLookup = pMofVersion;
                                        }
                                        if (TypeNameArray != NULL) {
                                            if ((lCount >= lTypeNameLower) && (lCount <= lTypeNameUpper)) {
                                                pMofVersion->strType = (LPTSTR)malloc((_tcslen(pTypeNameData[lCount]) + 1) * sizeof(TCHAR));
                                                if (pMofVersion->strType != NULL){
                                                    wcscpy(pMofVersion->strType, (LPWSTR)(pTypeNameData[lCount]));
                                                }
                                            }
                                        }
                                    }
                                }
                                SafeArrayUnaccessData(TypeArray);  
                                SafeArrayDestroy(TypeArray);
                                VariantInit(&pTypeVal);
                                if (TypeNameArray != NULL) {
                                    SafeArrayUnaccessData(TypeNameArray);
                                    SafeArrayDestroy(TypeNameArray);
                                    VariantInit(&pTypeNameVal);
                                }
                            }
                            else {
                                // 
                                // If the Types or TypeName is not found, then bail
                                //
                                break;
                            }
                        }                       
                        else {                          // EventType is scalar
                            hRes = VariantChangeType(&pTypeVal, &pTypeVal, 0, VT_I2);
                            if (ERROR_SUCCESS == hRes)
                                nEventType = (SHORT)V_I2(&pTypeVal);
                            else
                                nEventType = (SHORT)V_I4(&pTypeVal);

                            VariantClear(&pTypeNameVal);
                            hRes = pQualSet->Get(bszEventTypeName, 
                                                    0, 
                                                    &pTypeNameVal, 
                                                    0);
                            if (ERROR_SUCCESS == hRes) {
                                wcscpy(strType, pTypeNameVal.bstrVal);
                            }
                            else{
                                strType[0] = '\0';
                            }

                            pMofVersion = GetNewMofVersion(nEventType, nVersion, nLevel);
                            if (pMofVersion != NULL) {
                                InsertTailList(&ListHead, &pMofVersion->Entry);
                                if (nType == nEventType) {
                                    // Type matched
                                    pMofLookup = pMofVersion;
                                }
                                pMofVersion->strType = (LPTSTR)malloc((_tcslen(strType) + 1) * sizeof(TCHAR));
                                if (pMofVersion->strType != NULL){
                                    _tcscpy(pMofVersion->strType, strType);
                                }
                            }
                        }

                        // Get event layout
                        VariantClear(&pVal);
                        IdIndex = 1;
                        V_VT(&pVal) = VT_I4;
                        V_I4(&pVal) = IdIndex; 
                        // For each property
                        PropArray = NULL;
                        while (pTraceSubSubClasses->GetNames(bszWmiDataId,                  // only properties with WmiDataId qualifier
                                                            WBEM_FLAG_ONLY_IF_IDENTICAL,
                                                            &pVal,                          // WmiDataId number starting from 1
                                                            &PropArray) == WBEM_NO_ERROR) {

                            hRes = SafeArrayGetLBound(PropArray, 1, &lLower);
                            if (ERROR_SUCCESS != hRes) {
                                break;
                            }
                            hRes = SafeArrayGetUBound(PropArray, 1, &lUpper);
                            if (ERROR_SUCCESS != hRes) {
                                break;
                            }
                            if (lUpper < 0) 
                                break;
                            // This loop will iterate just once.
                            for (lCount = lLower; lCount <= lUpper; lCount++) { 
                                hRes = SafeArrayGetElement(PropArray, &lCount, &bszPropName);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                hRes = pTraceSubSubClasses->Get(bszPropName,    // Property name
                                                                0L,
                                                                NULL,
                                                                &pVarType,      // CIMTYPE of the property
                                                                NULL);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }

                                // Get the Qualifier set for the property
                                if (pQualSet) {
                                    pQualSet->Release();
                                    pQualSet = NULL;
                                }
                                hRes = pTraceSubSubClasses->GetPropertyQualifierSet(bszPropName,
                                                                        &pQualSet);

                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                
                                ItemType = GetItemType((CIMTYPE_ENUMERATION)pVarType, pQualSet);
                                
                                if( pVarType & CIM_FLAG_ARRAY ){
                                    ArraySize = GetArraySize(pQualSet);
                                }else{
                                    ArraySize = 1;
                                }
                                
                                AddMofInfo(&ListHead, 
                                            bszPropName, 
                                            ItemType, 
                                            ArraySize);
                            }
                            SafeArrayDestroy(PropArray);
                            PropArray = NULL;
                            V_I4(&pVal) = ++IdIndex;                        
                        }   // end enumerating through WmiDataId

                        FlushMofVersionList(pMofInfo, &ListHead);
                    }   // if getting event type was successful
                }   // if enumeration returned a subclass successfully
            }   // end enumerating subclasses
        }   // if enumeration was created successfully
    }   // if getting class name was successful
  
cleanup:
    VariantClear(&pVal);
    VariantClear(&pTypeVal);
    VariantClear(&pClassName);

    SysFreeString(bszClassName);
    SysFreeString(bszWmiDataId);
    SysFreeString(bszEventType);
    SysFreeString(bszEventTypeName);
    SysFreeString(bszFriendlyName);
    // Should not free bszPropName becuase it is already freed by SafeArrayDestroy

    FlushMofVersionList(pMofInfo, &ListHead);

    return pMofLookup;
}

PMOF_VERSION
GetGuidsWBEM ( GUID Guid, SHORT nVersion, CHAR nLevel, SHORT nType, BOOL bKernelEvent )
{
    IEnumWbemClassObject    *pEnumTraceSubClasses = NULL, *pEnumTraceSubSubClasses = NULL;
    IWbemClassObject        *pTraceSubClasses = NULL, *pTraceSubSubClasses = NULL;
    IWbemQualifierSet       *pQualSet = NULL;

    BSTR bszInstance = NULL;
    BSTR bszPropertyName = NULL;
    BSTR bszSubClassName = NULL;
    BSTR bszGuid = NULL;
    BSTR bszVersion = NULL;

    TCHAR strGuid[MAXSTR], strTargetGuid[MAXSTR];
    
    HRESULT hRes;

    VARIANT pVal;
    VARIANT pGuidVal;
    VARIANT pVersionVal;

    UINT nCounter=0;
    BOOLEAN MatchFound;
    SHORT nEventVersion = EVENT_VERSION_DEFAULT;

    PMOF_VERSION pMofLookup = NULL;

    VariantInit(&pVal);
    VariantInit(&pGuidVal);
    VariantInit(&pVersionVal);
    
    if (NULL == pWbemServices) {
        hRes = WbemConnect( &pWbemServices );
        CHECK_HR( hRes );
    }

    // Convert traget GUID to string for later comparison
    CpdiGuidToString(strTargetGuid, &Guid);
    
    bszInstance = SysAllocString(L"EventTrace");
    bszPropertyName = SysAllocString(L"__CLASS");
    bszGuid = SysAllocString(L"Guid");
    bszVersion = SysAllocString(L"EventVersion");
    pEnumTraceSubClasses = NULL;

    // Get an enumerator for all classes under "EventTace".
    hRes = pWbemServices->CreateClassEnum ( 
                bszInstance,
                WBEM_FLAG_SHALLOW | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                NULL,
                &pEnumTraceSubClasses );
    SysFreeString (bszInstance);

    if (ERROR_SUCCESS == hRes) {
        ULONG uReturned = 1;
        MatchFound = FALSE;
        while (uReturned == 1) {
            pTraceSubClasses = NULL;
            // Get the next ClassObject.
            hRes = pEnumTraceSubClasses->Next((-1),             // timeout in infinite seconds
                                            1,                  // return just one instance
                                            &pTraceSubClasses,  // pointer to Event Trace Sub Class
                                            &uReturned);        // number obtained: one or zero
            if (ERROR_SUCCESS == hRes && (uReturned == 1)) {
                // Get the class name
                hRes = pTraceSubClasses->Get(bszPropertyName,   // property name 
                                                0L, 
                                                &pVal,          // output to this variant 
                                                NULL, 
                                                NULL);

                if (ERROR_SUCCESS == hRes){

                    bszSubClassName = SysAllocString(pVal.bstrVal);
                    // Create an enumerator to find derived classes.
                    hRes = pWbemServices->CreateClassEnum ( 
                                            bszSubClassName,
                                            WBEM_FLAG_SHALLOW | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                            NULL,
                                            &pEnumTraceSubSubClasses 
                                            );
                    SysFreeString ( bszSubClassName );
                    VariantClear(&pVal);

                    if (ERROR_SUCCESS == hRes) {
                                    
                        ULONG uReturnedSub = 1;
                        MatchFound = FALSE;
                    
                        while(uReturnedSub == 1){

                            pTraceSubSubClasses = NULL;
                            // enumerate through the resultset.
                            hRes = pEnumTraceSubSubClasses->Next((-1),              // timeout in infinite seconds
                                                            1,                      // return just one instance
                                                            &pTraceSubSubClasses,   // pointer to a Sub class
                                                            &uReturnedSub);         // number obtained: one or zero
                            if (ERROR_SUCCESS == hRes && uReturnedSub == 1) {
                                // Get the subclass name            
                                hRes = pTraceSubSubClasses->Get(bszPropertyName,    // Class name 
                                                                0L, 
                                                                &pVal,              // output to this variant 
                                                                NULL, 
                                                                NULL);
                                VariantClear(&pVal);

                                if (ERROR_SUCCESS == hRes){

                                    // Get Qualifier Set.
                                    if (pQualSet) {
                                        pQualSet->Release();
                                        pQualSet = NULL;
                                    }
                                    pTraceSubSubClasses->GetQualifierSet (&pQualSet );

                                    // Get GUID among Qualifiers
                                    hRes = pQualSet->Get(bszGuid, 
                                                            0, 
                                                            &pGuidVal, 
                                                            0);

                                    if (ERROR_SUCCESS == hRes) {
                                        _tcscpy(strGuid, (LPTSTR)V_BSTR(&pGuidVal));
                                        VariantClear ( &pGuidVal  );
                                                    
                                        if (!_tcsstr(strGuid, _T("{")))
                                            _stprintf(strGuid , _T("{%s}"), strGuid);

                                        if (!_tcsicmp(strTargetGuid, strGuid)) {
                                            hRes = pQualSet->Get(bszVersion, 
                                                                    0, 
                                                                    &pVersionVal, 
                                                                    0);
                                            if (ERROR_SUCCESS == hRes) {
                                                hRes = VariantChangeType(&pVersionVal, &pVersionVal, 0, VT_I2);
                                                if (ERROR_SUCCESS == hRes)
                                                    nEventVersion = (SHORT)V_I2(&pVersionVal);
                                                else
                                                    nEventVersion = (SHORT)V_I4(&pVersionVal);
                                                VariantClear(&pVersionVal);

                                                if (nVersion == nEventVersion) {
                                                    //_tprintf(_T("Match Found: \t%s\t, version %d\n"), strGuid, nVersion);
                                                    // Match is found. 
                                                    // Now put all events in this subtree into the list 
                                                    MatchFound = TRUE;
                                                    pMofLookup = GetPropertiesFromWBEM( pTraceSubSubClasses, 
                                                                                        Guid,
                                                                                        nVersion,
                                                                                        nLevel,
                                                                                        nType,
                                                                                        bKernelEvent
                                                                                        );
                                                    break;
                                                }
                                            }
                                            else {

                                                // if there is no version number for this event
                                                MatchFound = TRUE;
                                                //_tprintf(_T("Close Match Found: \t%s\t, version %d\n"), strGuid, nEventVersion);
                                                pMofLookup = GetPropertiesFromWBEM( pTraceSubSubClasses, 
                                                                                    Guid,
                                                                                    EVENT_VERSION_DEFAULT,
                                                                                    nLevel,
                                                                                    nType,
                                                                                    bKernelEvent
                                                                                    );
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        } // end while enumerating sub classes
                        if (MatchFound) {
                            break;
                        }
                        if (pEnumTraceSubSubClasses) {
                            pEnumTraceSubSubClasses->Release();
                            pEnumTraceSubSubClasses = NULL;
                        }
                    }   // if creating enumeration was successful
                }   // if getting class name was successful
            }
            nCounter++;
            // if match is found, break out of the top level search
            if (MatchFound)
                break;
        }   // end while enumerating top classes
        if( pEnumTraceSubClasses ){
            pEnumTraceSubClasses->Release();
            pEnumTraceSubClasses = NULL;
        }
    }   // if creating enumeration for top level is successful

cleanup:

    VariantClear(&pGuidVal);
    VariantClear(&pVersionVal);

    SysFreeString(bszGuid);
    SysFreeString(bszPropertyName);  
    SysFreeString(bszVersion);  
 
    if (pEnumTraceSubClasses){  
        pEnumTraceSubClasses->Release();
        pEnumTraceSubClasses = NULL;
    }
    if (pEnumTraceSubSubClasses){
        pEnumTraceSubSubClasses->Release();
        pEnumTraceSubSubClasses = NULL;
    }
    if (pQualSet) {
        pQualSet->Release();
        pQualSet = NULL;
    }

    return pMofLookup;
}

PMOF_VERSION
GetGuidsFile( GUID Guid, SHORT nVersion, CHAR nLevel, SHORT nType, BOOL bKernelEvent )
{
    FILE *f = NULL;
    WCHAR line[MAXSTR];
    WCHAR buffer[MAXSTR];
    
    PMOF_INFO pMofInfo = NULL;
    PMOF_VERSION pMofLookup = NULL;
    PMOF_VERSION pMofVersion = NULL;
    
    UINT i;
    LPWSTR s;
    UINT typeCount = 0;
    BOOL bInInfo = FALSE;
    BOOL    bInGuid = FALSE;

    SHORT   nTypeIndex;
    CHAR    nLevelIndex = -1;
    SHORT   nVersionIndex = -1;
    SHORT   nMatchLevel = 0;

    GUID    guid;

    LIST_ENTRY ListHead;

    InitializeListHead( &ListHead );

    //
    // If MofFileName is given, use it. Otherwise, look for 
    // the default file mofdata.guid 
    //
    
    if (TraceContext->MofFileName != NULL) {
        f = _wfopen( TraceContext->MofFileName, L"r" );
        if( !f ){
            return NULL;
        }
    }else{
        return NULL;
    }

    while ( fgetws(line, MAXSTR, f) != NULL ) {
        UINT Index;
        if(line[0] == '/'){
            continue;
        }
        if(line[0] == '{' && bInGuid ){
            bInInfo = TRUE;
        } 
        else if ( line[0] == '}' && bInGuid ){
            bInInfo = FALSE;
            FlushMofVersionList( pMofInfo, &ListHead );
        }
        else if( bInInfo && bInGuid ){
            ITEM_TYPE type;
            LPWSTR strValue;

            Index = 1;
            strValue =  wcstok(line,  L"\n\t\r,");

            s =  wcstok( NULL,   L" \n\t\r,[");
            if(s != NULL && strValue != NULL ){
                PWCHAR t;

                while (*strValue == ' ') {  // skip leading blanks
                    strValue++;
                }
                t =  wcstok(NULL,   L"]" );

                if (t != NULL) {
                    Index = _wtoi(t);
                }

                if(! _wcsicmp(s,STR_ItemChar)) type = ItemChar;
                else if(! _wcsicmp(s,STR_ItemCharHidden)) type = ItemCharHidden;
                else if(! _wcsicmp(s,STR_ItemUChar)) type = ItemUChar;
                else if(! _wcsicmp(s,STR_ItemCharShort))type = ItemCharShort;
                else if(! _wcsicmp(s,STR_ItemCharSign)) type = ItemCharSign;
                else if(! _wcsicmp(s,STR_ItemShort)) type = ItemShort;
                else if(! _wcsicmp(s,STR_ItemUShort)) type = ItemUShort;
                else if(! _wcsicmp(s,STR_ItemLong)) type = ItemLong;
                else if(! _wcsicmp(s,STR_ItemULong)) type = ItemULong;
                else if(! _wcsicmp(s,STR_ItemULongX)) type = ItemULongX;
                else if(! _wcsicmp(s,STR_ItemLongLong)) type = ItemLongLong;
                else if(! _wcsicmp(s,STR_ItemULongLong)) type = ItemULongLong;
                else if(! _wcsicmp(s,STR_ItemString)) type = ItemString;
                else if(! _wcsicmp(s,STR_ItemWString)) type = ItemWString;
                else if(! _wcsicmp(s,STR_ItemRString)) type = ItemRString;
                else if(! _wcsicmp(s,STR_ItemRWString)) type = ItemRWString;
                else if(! _wcsicmp(s,STR_ItemPString)) type = ItemPString;
                else if(! _wcsicmp(s,STR_ItemMLString)) type = ItemMLString;
                else if(! _wcsicmp(s,STR_ItemNWString)) type = ItemNWString;
                else if(! _wcsicmp(s,STR_ItemPWString)) type = ItemPWString;
                else if(! _wcsicmp(s,STR_ItemDSString)) type = ItemDSString;
                else if(! _wcsicmp(s,STR_ItemDSWString)) type = ItemDSWString;
                else if(! _wcsicmp(s,STR_ItemSid)) type = ItemSid;
                else if(! _wcsicmp(s,STR_ItemChar4)) type = ItemChar4;
                else if(! _wcsicmp(s,STR_ItemIPAddr)) type = ItemIPAddr;
                else if(! _wcsicmp(s,STR_ItemPort)) type = ItemPort;
                else if(! _wcsicmp(s,STR_ItemPtr)) type = ItemPtr;
                else if(! _wcsicmp(s,STR_ItemGuid)) type = ItemGuid;
                else if(! _wcsicmp(s,STR_ItemOptArgs)) type = ItemOptArgs;
                else if(! _wcsicmp(s,STR_ItemCPUTime)) type = ItemCPUTime;
                else if(! _wcsicmp(s,STR_ItemVariant)) type = ItemVariant;
                else if(! _wcsicmp(s,STR_ItemBool)) type = ItemBool;
                else type = ItemUnknown;

                AddMofInfo( &ListHead, strValue, (SHORT)type, Index );
            }
        } 
        else if( line[0] == '#' && bInGuid ){
            LPWSTR strType;
            LPWSTR strValue;

            s =  wcstok( line,   L" \t");
            if( NULL == s ){
                continue;
            }

            if( line[1] == 'l' || line[1] == 'L' ){ // level
                
                strValue =  wcstok( NULL,  L" \t\n\r" );
                if( strValue != NULL ){
                    nLevelIndex = (CHAR)_wtoi( strValue );
                }

            }else if( line[1] == 'v' || line[1] == 'V' ){ // version

                strValue =  wcstok( NULL,  L" \t\n\r" );
                if( strValue != NULL ){
                    nVersionIndex = (SHORT)_wtoi( strValue );
                }
                typeCount = 0;

            }else if( line[1] == 't' || line[1] == 'T' ){ // type
            
                SHORT nMatchCheck = 0;

                strType =  wcstok( NULL,   L" \t\n\r" );
                strValue =  wcstok( NULL,   L"\"\n,\r" );

                if( strType && strValue ){
                    nTypeIndex = (SHORT)_wtoi( strValue );
                }else{
                    continue;
                }

                typeCount++;
                if(typeCount >= MAXTYPE){
                    //fwprintf(stderr,  L"Warning: Too many types defined\n");
                }

                pMofVersion = GetNewMofVersion( nTypeIndex, nVersionIndex, nLevelIndex );

                if( NULL != pMofVersion ){
                    InsertTailList( (&ListHead), &pMofVersion->Entry);
            
                    pMofVersion->strType = (LPWSTR)malloc( ( lstrlenW(strType)+1) * sizeof(WCHAR) );
            
                    if( NULL != pMofVersion->strType ){
                         wcscpy( pMofVersion->strType, strType );
                    }

                    if( nTypeIndex == nType ){
                        nMatchCheck = 1;
                        if( nLevelIndex == nLevel ){
                            nMatchCheck++;
                        }
                        if( nVersionIndex == nVersion ){
                            nMatchCheck++;
                        }
                    }


                    if( nMatchCheck > nMatchLevel ){
                        nMatchLevel = nMatchCheck;
                        pMofLookup = pMofVersion;
                    }
                }
            }
        }
        else if (   (line[0] >= '0' && line[0] <= '9')
                 || (line[0] >= 'a' && line[0] <= 'f')
                 || (line[0] >= 'A' && line[0] <= 'F')) {

            LPWSTR strName = NULL;
            bInGuid = FALSE;

            typeCount = 0;

            wcsncpy(buffer, line, 8);
            buffer[8] = 0;
            guid.Data1 = ahextoi(&buffer[0]);
            
            wcsncpy(buffer, &line[9], 4);
            buffer[4] = 0;
            guid.Data2 = (USHORT) ahextoi(&buffer[0]);
            
            wcsncpy(buffer, &line[14], 4);
            buffer[4] = 0;
            guid.Data3 = (USHORT) ahextoi(buffer);
            
            for (i=0; i<2; i++) {
                wcsncpy(buffer, &line[19 + (i*2)], 2);
                buffer[2] = 0;
                guid.Data4[i] = (UCHAR) ahextoi(buffer);
            }
            for (i=2; i<8; i++) {
                wcsncpy(buffer, &line[20 + (i*2)], 2);
                buffer[2] = 0;
                guid.Data4[i] = (UCHAR) ahextoi(buffer);
            }
            
            if( ! IsEqualGUID( &Guid, &guid ) ){
                continue;
            }

            s = &line[36];

            strName =  wcstok( s,   L" \n\t\r" );

            if( NULL == strName ){  // Must have a name for the Guid. 
                continue;
            }
            
            bInGuid = TRUE;
            FlushMofVersionList(pMofInfo,  &ListHead );

            pMofInfo = GetMofInfoHead( &Guid);
            if (pMofInfo == NULL)  {
                return NULL;
            }
            pMofInfo->bKernelEvent = bKernelEvent;
            pMofInfo->strDescription = (LPWSTR)malloc(( lstrlenW(strName)+1) * sizeof(WCHAR));
            if( NULL != pMofInfo->strDescription ){
                 wcscpy(pMofInfo->strDescription, strName);            
            }


            pMofVersion = GetNewMofVersion( 
                                           EVENT_TYPE_DEFAULT, 
                                           EVENT_VERSION_DEFAULT, 
                                           EVENT_LEVEL_DEFAULT 
                                          );

            if (pMofVersion == NULL) {
                return NULL;
            }

            pMofLookup = pMofVersion;
            InsertTailList( (&ListHead), &pMofVersion->Entry);
        }

    }

    FlushMofVersionList(pMofInfo,  &ListHead );
    fclose(f);
    return pMofLookup;
}


VOID
UpdateThreadData(
    PJOB_RECORD pJob,
    PEVENT_TRACE_HEADER pHeader,
    PTHREAD_RECORD pThread
    )
{
    unsigned long i = 0;
    BOOLEAN bFound = FALSE;

    if ( (pJob == NULL) || (pHeader == NULL) || (pThread == NULL) ) {
        return;
    }

    for (i = 0; i < pJob->NumberOfThreads; i++) {
        if (pJob->ThreadData[i].ThreadId == pHeader->ThreadId) {
            bFound = TRUE;
            break;
        }
    }
    if ((i < MAX_THREADS) && !bFound) {
        pJob->ThreadData[i].ThreadId = pHeader->ThreadId;
        pJob->NumberOfThreads++;
        bFound = TRUE;
    }

    if (bFound) {
            //
            // TODO: There is potential for double counting if the same thread
            // came back and did more work for this job after having done work for an other
            // job in between.
            //
            if (pJob->ThreadData[i].PrevKCPUTime > 0)
                pJob->ThreadData[i].KCPUTime += pHeader->KernelTime * CurrentSystem.TimerResolution - pJob->ThreadData[i].PrevKCPUTime;
            if (pJob->ThreadData[i].PrevUCPUTime > 0)
                pJob->ThreadData[i].UCPUTime += pHeader->UserTime * CurrentSystem.TimerResolution - pJob->ThreadData[i].PrevUCPUTime;
            if (pJob->ThreadData[i].PrevReadIO > 0)
                pJob->ThreadData[i].ReadIO   += pThread->ReadIO - pJob->ThreadData[i].PrevReadIO;
            if (pJob->ThreadData[i].PrevWriteIO > 0)
                pJob->ThreadData[i].WriteIO  += pThread->WriteIO - pJob->ThreadData[i].PrevWriteIO;

            pJob->ThreadData[i].PrevKCPUTime = pHeader->KernelTime * CurrentSystem.TimerResolution;
            pJob->ThreadData[i].PrevUCPUTime = pHeader->UserTime * CurrentSystem.TimerResolution;
            pJob->ThreadData[i].PrevReadIO   = pThread->ReadIO;
            pJob->ThreadData[i].PrevWriteIO  = pThread->WriteIO;
    }
}



VOID
PrintJobCallback(
    PEVENT_TRACE pEvent
    )
{
    PTHREAD_RECORD pThread;
    PEVENT_TRACE_HEADER pHeader;
    PMOF_INFO pMofInfo;
    ULONG JobId = 0;
    PJOB_RECORD pJob;

    if (pEvent == NULL)
        return;
    pHeader = (PEVENT_TRACE_HEADER)&pEvent->Header;

    //
    // Ignore Process/Thread Start/End transactions. Only go after
    // User Defined  Transactions.
    //
    pMofInfo = GetMofInfoHead( &pEvent->Header.Guid ); 
    if (pMofInfo == NULL){
         return;
    }

    if (!IsEqualGUID(&pEvent->Header.Guid, &ThreadGuid))
        GetMofData(pEvent, L"JobId", &JobId, sizeof(ULONG));

    pThread = FindGlobalThreadById(pHeader->ThreadId, pEvent);


    if (JobId == 0) {
        if (pThread == NULL) return;
        JobId = pThread->JobId; // if Current Job Id is 0, use the cached one.
    }
    else {
        if (pThread != NULL) {
            if (JobId != pThread->JobId) {
                pJob = FindJobRecord(pThread->JobId);
                UpdateThreadData(pJob, pHeader, pThread);
            }

            pThread->JobId = JobId;
        }
    }

    if (JobId == 0) return; // To filter all th termination without print jobs.


    pJob = FindJobRecord(JobId);
    if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_SPOOLJOB) {
        if (pJob) {
            // A job id is being reused before it was deleted from the last
            // use.  We must have missed a delete event, so just through the old
            // job away.
            EnterTracelibCritSection();
            RemoveEntryList( &pJob->Entry );
            LeaveTracelibCritSection();
            free (pJob);
        }
        pJob = AddJobRecord(JobId);
        if (pJob != NULL) {
            pJob->StartTime = pEvent->Header.TimeStamp.QuadPart;
        }
    }

    if (pJob == NULL)  // if a Start event is lost for this job, this could happen.
        return;

    UpdateThreadData(pJob, pHeader, pThread);

    // If you see any of these things then stop tracking resources on the
    // thread.
    if ((pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_ENDTRACKTHREAD) ||
        (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_DELETEJOB)      ||
        (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_PAUSE)          ||
        (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_RESUME)) {
        if (pThread != NULL)
            pThread->JobId = 0;
    }

    if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_PAUSE) {
        pJob->PauseStartTime = pEvent->Header.TimeStamp.QuadPart;
    }
    else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_RESUME) {
        pJob->PauseTime += (pEvent->Header.TimeStamp.QuadPart - pJob->PauseStartTime) / 10000;
        pJob->PauseStartTime = 0;
    }
    else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_PRINTJOB) {
        pJob->PrintJobTime = pEvent->Header.TimeStamp.QuadPart;
    }
    else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_DELETEJOB) {
        unsigned long i;
        pJob->EndTime = pEvent->Header.TimeStamp.QuadPart;
        pJob->ResponseTime += (pEvent->Header.TimeStamp.QuadPart - pJob->StartTime) / 10000; // in msec
        GetMofData(pEvent, L"JobSize", &pJob->JobSize, sizeof(ULONG));
        GetMofData(pEvent, L"DataType", &pJob->DataType, sizeof(ULONG));
        GetMofData(pEvent, L"Pages", &pJob->Pages, sizeof(ULONG));
        GetMofData(pEvent, L"PagesPerSide", &pJob->PagesPerSide, sizeof(ULONG));
        GetMofData(pEvent, L"FilesOpened", &pJob->FilesOpened, sizeof(SHORT));

        pJob->KCPUTime = 0;
        pJob->UCPUTime = 0;
        pJob->ReadIO = 0;
        pJob->WriteIO = 0;
        for (i=0; i < pJob->NumberOfThreads; i++) {
            pJob->KCPUTime += pJob->ThreadData[i].KCPUTime;
            pJob->UCPUTime += pJob->ThreadData[i].UCPUTime;
            pJob->ReadIO += pJob->ThreadData[i].ReadIO;
            pJob->WriteIO += pJob->ThreadData[i].WriteIO;

        }
        DeleteJobRecord(pJob, (TraceContext->Flags & TRACE_SPOOLER));
    }
    else if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_SPL_JOBRENDERED) {
        GetMofData(pEvent, L"GdiJobSize", &pJob->GdiJobSize, sizeof(ULONG));
        GetMofData(pEvent, L"ICMMethod", &pJob->ICMMethod, sizeof(ULONG));
        GetMofData(pEvent, L"Color", &pJob->Color, sizeof(SHORT));
        GetMofData(pEvent, L"XRes", &pJob->XRes, sizeof(SHORT));
        GetMofData(pEvent, L"YRes", &pJob->YRes, sizeof(SHORT));
        GetMofData(pEvent, L"Quality", &pJob->Quality, sizeof(SHORT));
        GetMofData(pEvent, L"Copies", &pJob->Copies, sizeof(SHORT));
        GetMofData(pEvent, L"TTOption", &pJob->TTOption, sizeof(SHORT));
    }
}


VOID
GeneralEventCallback(
    PEVENT_TRACE pEvent
    )
{
    PTHREAD_RECORD pThread;

    if ((pEvent == NULL) || (TraceContext == NULL))
        return;

    // If the ThreadId is -1 or the FieldTypeFlags in the event
    // shows there is no CPU Time, ignore the event. This can happen
    // when PERFINFO headers are found in kernel data. 
    //

    if ( (pEvent->Header.ThreadId == -1) || 
         (pEvent->Header.FieldTypeFlags & EVENT_TRACE_USE_NOCPUTIME) ) {
        if (TraceContext->Flags & (TRACE_DUMP|TRACE_SUMMARY)) {
            DumpEvent(pEvent);
        }
        return;
    }

    //
    // Notes: This code is here to fix up the Event Record for the 
    // Idle Threads. Since Idle threads are not guaranteed to have 
    // Cid initialized, we could end up with bogus thread Ids. 
    // 
    // Assumption: In DC_START records, the first process record must
    // be the idle process followed by idle threads. 
    // 

    if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_START) {
        if (bCaptureBogusThreads) {
            //
            // Here we will convert the next N threads into idle threads
            // N = Number of Processors. 

            if (IsEqualGUID(&pEvent->Header.Guid, &ThreadGuid)) {
                if (pEvent->Header.ThreadId != 0) {
                    PULONG Ptr;
                    BogusThreads[BogusCount++] = pEvent->Header.ThreadId;
                    pEvent->Header.ThreadId = 0;
                    //
                    // Assumption: The first two ULONGs are the
                    // ThreadId and ProcessId in this record. If that changes
                    // this will corrupt memory! 
                    //
                    Ptr = (PULONG)pEvent->MofData;
                    *Ptr = 0;
                    Ptr++;
                    *Ptr = 0; 
                }
            }
            //
            // Once all the idle threads are seen, no need to capture anymore
            //
            if (IdleThreadCount++ == NumProc) bCaptureBogusThreads = FALSE;
        }
    } else {
        //
        // This is the TimeConsuming Part. We need to do this only if 
        // we found bogus threads earlier. 
        // 
        if (BogusCount > 0) {
            ULONG i;
            for (i=0; i < BogusCount; i++) {
                if (pEvent->Header.ThreadId == BogusThreads[i]) {
                    pEvent->Header.ThreadId = 0;

                    //
                    // If DC_END records also fix up the Mof for Thread End
                    //

                    if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_DC_END) {
                        PULONG Ptr;

                        Ptr = (PULONG)pEvent->MofData;
                        *Ptr = 0;
                        Ptr++;
                        *Ptr = 0;
                    }
                }
            }
        }
    }
    //
    // After the above code we should not see any threadId's over 64K
    //
/*
#if DBG
    if (pEvent->Header.ThreadId > 65536)
        DbgPrint("%d: Bad ThreadId %x Found\n", EventCount+1, 
                                                pEvent->Header.ThreadId);
#endif
*/

    //
    // Dump the event in csv file, if required. 
    //
    if (TraceContext->Flags & (TRACE_DUMP|TRACE_SUMMARY)) {
            DumpEvent(pEvent);
    }
    else {
        PMOF_INFO pMofInfo;
        PMOF_VERSION pMofVersion = NULL;
        pMofInfo = GetMofInfoHead( &pEvent->Header.Guid );
        if (pMofInfo == NULL){
             return;
        }
        pMofInfo->EventCount++;

        pMofVersion = GetMofVersion(pMofInfo,
                                pEvent->Header.Class.Type,
                                pEvent->Header.Class.Version,
                                pEvent->Header.Class.Level
                                );
    }



    if ( (TraceContext->Flags & TRACE_REDUCE) == 0 ) {
        return;
    }
    
    // 
    // TODO: This may prevent DiskIO write events and TCP receive events to 
    // get ignored 
    //


    if (pEvent->Header.ThreadId == 0) {
        if (   (pEvent->Header.Class.Type != EVENT_TRACE_TYPE_START)
          && (pEvent->Header.Class.Type != EVENT_TRACE_TYPE_DC_START)
           && (pEvent->Header.Class.Type != EVENT_TRACE_TYPE_END)
           && (pEvent->Header.Class.Type != EVENT_TRACE_TYPE_DC_END)
           )
        {
            EventCount++;
            return;
        }
    }

    pThread = FindGlobalThreadById(pEvent->Header.ThreadId, pEvent);

    if (   CurrentSystem.fNoEndTime
        && CurrentSystem.EndTime < (ULONGLONG) pEvent->Header.TimeStamp.QuadPart)
    {
        CurrentSystem.EndTime = pEvent->Header.TimeStamp.QuadPart;
        if (fDSOnly && CurrentSystem.EndTime > DSEndTime)
            CurrentSystem.EndTime = DSEndTime;
    }

    EventCount ++;

    if (IsEqualGUID(&pEvent->Header.Guid, &EventTraceGuid))
    {
        AdjustThreadTime(pEvent, pThread);
        LogHeaderCallback(pEvent);
    }
    else if (IsEqualGUID(&pEvent->Header.Guid, &ProcessGuid))
    {
        AdjustThreadTime(pEvent, pThread);
        ProcessCallback(pEvent);
    }
    else if (IsEqualGUID(&pEvent->Header.Guid, &ThreadGuid))
    {
        if (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_START) 
        {
            AdjustThreadTime(pEvent, pThread);
        }
        ThreadCallback(pEvent);
    }
    else if (pEvent->Header.ThreadId != 0)
    {
        AdjustThreadTime(pEvent, pThread);
        if (IsEqualGUID(&pEvent->Header.Guid, &DiskIoGuid))
        {
            DiskIoCallback(pEvent, pThread);
        }
        else if (IsEqualGUID(&pEvent->Header.Guid, &FileIoGuid))
        {
            HotFileCallback(pEvent);
        }
        else if (IsEqualGUID(&pEvent->Header.Guid, &ImageLoadGuid))
        {
            ModuleLoadCallback(pEvent);
        }
        else if (IsEqualGUID(&pEvent->Header.Guid, &TcpIpGuid))
        {
            TcpIpCallback(pEvent, pThread);
        }
        else if (IsEqualGUID(&pEvent->Header.Guid, &UdpIpGuid))
        {
            TcpIpCallback(pEvent, pThread);
        }
        else if (IsEqualGUID(&pEvent->Header.Guid, &PageFaultGuid))
        {
            PageFaultCallback(pEvent, pThread);
        }
        else if (IsEqualGUID(&pEvent->Header.Guid, &EventTraceConfigGuid)) {
            // Ignore for now. 
            // We need to pick this up for a Hardwareconfig report. 
            //
        }
        else
        {
            //
            // This is a hack specific to Print Servers.
            // Need to come up with a general solution.  MKR.
            //

            if (IsEqualGUID(&pEvent->Header.Guid, &PrintJobGuid) ||
                IsEqualGUID(&pEvent->Header.Guid, &RenderedJobGuid)) {
                PrintJobCallback(pEvent);
            }

            EventCallback(pEvent, pThread);
        }
    }
}

ULONG ahextoi( WCHAR *s)
{
    int len;
    ULONG num, base, hex;

    len = lstrlenW(s);
    hex = 0; base = 1; num = 0;
    while (--len >= 0) {
        if ( (s[len] == 'x' || s[len] == 'X') &&
             (s[len-1] == '0') )
            break;
        if (s[len] >= '0' && s[len] <= '9')
            num = s[len] - '0';
        else if (s[len] >= 'a' && s[len] <= 'f')
            num = (s[len] - 'a') + 10;
        else if (s[len] >= 'A' && s[len] <= 'F')
            num = (s[len] - 'A') + 10;
        else
            continue;

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

void AnsiToUnicode(PCHAR str, PWCHAR wstr)
{
    int len, i;
    PUCHAR AnsiChar;

    if (str == NULL || wstr == NULL)
        return;

    len = strlen(str);
    for (i=0; i<len; i++)
    {
        AnsiChar = (PUCHAR) &str[i];
        wstr[i] = (WCHAR) RtlAnsiCharToUnicodeChar(&AnsiChar);
    }
    wstr[len] = 0;
}

void
WINAPI
DumpEvent(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER pHeader;
    ULONG   i;
    PITEM_DESC pItem;
    char str[MOFSTR];
    WCHAR wstr[MOFWSTR];
    PCHAR ptr;
    ULONG ulongword;
    LONG  longword;
    USHORT ushortword;
    SHORT  shortword;
    PMOF_INFO pMofInfo;
    PMOF_VERSION pMofVersion;
    PLIST_ENTRY Head, Next;
    char iChar;
    WCHAR iwChar;
    ULONG MofDataUsed;
    FILE* DumpFile = NULL;

    TotalEventCount++;

    if (pEvent == NULL) {
        return;
    }

    pHeader = (PEVENT_TRACE_HEADER) &pEvent->Header;

    if( IsEqualGUID(&pEvent->Header.Guid, &EventTraceGuid) && 
        pEvent->Header.Class.Type == EVENT_TRACE_TYPE_INFO ) {

        PTRACE_LOGFILE_HEADER head = (PTRACE_LOGFILE_HEADER)pEvent->MofData;
        if( NULL != head ){
            g_bUserMode = (head->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE);
 
            if(head->TimerResolution > 0){
                TimerResolution = head->TimerResolution / 10000;
            }
        
            StartTime  = head->StartTime.QuadPart;
            EndTime    = head->EndTime.QuadPart;
            fNoEndTime = (EndTime == 0);

            PointerSize =  head->PointerSize;
            if (PointerSize < 16){       // minimum is 16 bits
                PointerSize = 32;       // defaults = 32 bits
            }
        }
    }

    if (fNoEndTime && EndTime < (ULONGLONG) pHeader->TimeStamp.QuadPart) {
        EndTime = pHeader->TimeStamp.QuadPart;
    }

    if (MofData == NULL) {
        MofLength = pEvent->MofLength + sizeof(UNICODE_NULL);
        MofData = (LPSTR)malloc(MofLength);
    }
    else if ((pEvent->MofLength + sizeof(UNICODE_NULL)) > MofLength) {
        MofLength = pEvent->MofLength + sizeof(UNICODE_NULL);
        MofData = (LPSTR)realloc(MofData, MofLength);
    }

    if (MofData == NULL) {
        return;
    }
    if ((pEvent->MofData == NULL) && (0 != pEvent->MofLength)) {
        return;
    }

    if (pEvent->MofData != NULL) {
        memcpy(MofData, pEvent->MofData, pEvent->MofLength);
    }

    MofData[pEvent->MofLength] = 0;
    MofData[pEvent->MofLength+1] = 0;
    ptr = MofData;
    MofDataUsed = 0;

    pMofInfo = GetMofInfoHead(  &pEvent->Header.Guid );

    if (pMofInfo == NULL) {
        return;
    }
    pMofInfo->EventCount++;

    pMofVersion = GetMofVersion(pMofInfo, 
                                pEvent->Header.Class.Type,
                                pEvent->Header.Class.Version,
                                pEvent->Header.Class.Level
                            );



    if( NULL == pMofVersion ){
        return;
    }

    pMofVersion->EventCountByType++;

    if( !(TraceContext->Flags & TRACE_DUMP) ){
        return;
    }

    DumpFile =  TraceContext->hDumpFile;

    if( pMofInfo->strDescription != NULL ){
        fwprintf( DumpFile, L"%12s, ", pMofInfo->strDescription );
    }else{
        fwprintf( DumpFile, L"%12s, ", CpdiGuidToString( wstr, &pMofInfo->Guid ) );
    }

    if(pMofVersion->strType != NULL && wcslen(pMofVersion->strType) ){
        fwprintf( DumpFile, L"%10s, ", pMofVersion->strType );
    }else{
        fwprintf( DumpFile,   L"%10d, ", pEvent->Header.Class.Type );
    }

    if( TraceContext->Flags & TRACE_EXTENDED_FMT ){
        fwprintf( DumpFile, L"%8d,%8d,%8d, ", 
                pEvent->Header.Class.Type,
                pEvent->Header.Class.Level,
                pEvent->Header.Class.Version
            );
    }

    // Thread ID
     fwprintf( DumpFile,   L"0x%04X, ", pHeader->ThreadId );
    
    // System Time
     fwprintf( DumpFile,   L"%20I64u, ", pHeader->TimeStamp.QuadPart);

    if( g_bUserMode == FALSE ){
        // Kernel Time
         fwprintf(DumpFile,   L"%10lu, ", pHeader->KernelTime * TimerResolution);

        // User Time
         fwprintf(DumpFile,   L"%10lu, ", pHeader->UserTime * TimerResolution);
    }else{
        // processor Time
         fwprintf(DumpFile,   L"%I64u, ", pHeader->ProcessorTime);
    }

    Head = &pMofVersion->ItemHeader;
    Next = Head->Flink;

    if ((Head == Next) && (pEvent->MofLength > 0)) {
         fwprintf(DumpFile,   L"DataSize=%d, ", pEvent->MofLength);
    }

    while (Head != Next) {
        pItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        Next = Next->Flink;

        MofDataUsed = (ULONG) (ptr - MofData);
        
        if (MofDataUsed >= pEvent->MofLength){
            break;
        }

        switch (pItem->ItemType)
        {
        case ItemChar:
        case ItemUChar:
            for (i=0;i<pItem->ArraySize;i++){
                iChar = *((PCHAR) ptr);
                fwprintf(DumpFile,   L"%c", iChar);
                ptr += sizeof(CHAR);
            } 
            fwprintf(DumpFile, L", " );
            break;
        case ItemCharHidden:
            ptr += sizeof(CHAR) * pItem->ArraySize;
            break;
        case ItemWChar:
            for(i=0;i<pItem->ArraySize;i++){
                iwChar = *((PWCHAR) ptr);
                fwprintf(DumpFile,   L"%wc", iwChar);
                ptr += sizeof(WCHAR);
            }
            fwprintf(DumpFile, L", ");
            break;
        case ItemCharSign:
        {
            char sign[5];
            memcpy(&sign, ptr, sizeof(CHAR) * 2);
            sign[2] = '\0';
            strcpy(str, sign);
            MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
            fwprintf(DumpFile,   L"\"%ws\", ", wstr);
            ptr += sizeof(CHAR) * 2;
            break;
        }

        case ItemCharShort:
            iChar = *((PCHAR) ptr);
             fwprintf(DumpFile,   L"%d, ", iChar);
            ptr += sizeof(CHAR);
            break;

        case ItemShort:
            shortword = * ((PSHORT) ptr);
             fwprintf(DumpFile,   L"%6d, ", shortword);
            ptr += sizeof (SHORT);
            break;

        case ItemUShort:
            ushortword = *((PUSHORT) ptr);
             fwprintf(DumpFile,   L"%6u, ", ushortword);
            ptr += sizeof (USHORT);
            break;

        case ItemLong:
            longword = *((PLONG) ptr);
             fwprintf(DumpFile,   L"%8d, ", longword);
            ptr += sizeof (LONG);
            break;

        case ItemULong:
            ulongword = *((PULONG) ptr);
             fwprintf(DumpFile,   L"%8lu, ", ulongword);
            ptr += sizeof (ULONG);
            break;

        case ItemULongX:
            ulongword = *((PULONG) ptr);
            fwprintf(DumpFile,   L"0x%08X, ", ulongword);
            ptr += sizeof (ULONG);
            break;

        case ItemPtr :
        {
            unsigned __int64 pointer;
            if (PointerSize == 64) {
                pointer = *((unsigned __int64 *) ptr);
                 fwprintf(DumpFile,   L"0x%X, ", pointer);
            }
            else {      // assumes 32 bit otherwise
                ulongword = *((PULONG) ptr);
                 fwprintf(DumpFile,   L"0x%08X, ", ulongword);
            }
            ptr += PointerSize / 8;
            //
            // If target source is Win64, then use Ptr, else use ulongword
            //
            break;
        }

        case ItemIPAddr:
        {
            ulongword = *((PULONG) ptr);

            // Convert it to readable form
            //
             fwprintf(DumpFile,    L"%03d.%03d.%03d.%03d, ",
                    (ulongword >>  0) & 0xff,
                    (ulongword >>  8) & 0xff,
                    (ulongword >> 16) & 0xff,
                    (ulongword >> 24) & 0xff);
            ptr += sizeof (ULONG);
            break;
        }

        case ItemPort:
        {
            fwprintf(DumpFile,   L"%u, ", NTOHS((USHORT) *ptr));
            ptr += sizeof (USHORT);
            break;
        }

        case ItemLongLong:
        {
            LONGLONG n64;
            n64 = *((LONGLONG*) ptr);
            ptr += sizeof(LONGLONG);
            fwprintf(DumpFile,   L"%16I64d, ", n64);
            break;
        }

        case ItemULongLong:
        {
            ULONGLONG n64;
            n64 = *((ULONGLONG*) ptr);
            ptr += sizeof(ULONGLONG);
            fwprintf(DumpFile,   L"%16I64u, ", n64);
            break;
        }

        case ItemString:
        case ItemRString:
        {
            USHORT pLen = (USHORT)strlen((CHAR*) ptr);

            if (pLen > 0)
            {
                strcpy(str, ptr);
                if (pItem->ItemType == ItemRString)
                {
                    reduceA(str);
                }
                for (i=pLen-1; i>0; i--) {
                    if (str[i] == 0xFF)
                        str[i] = 0;
                    else break;
                }
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                fwprintf(DumpFile,   L"\"%ws\", ", wstr);
            }
            ptr += (pLen + 1);
            break;
        }
        case ItemRWString:
        case ItemWString:
        {
            size_t  pLen = 0;
            size_t     i;

            if (*(WCHAR *) ptr)
            {
                if (pItem->ItemType == ItemRWString)
                {
                    reduceW((WCHAR *) ptr);
                }
                pLen = ((lstrlenW((WCHAR*)ptr) + 1) * sizeof(WCHAR));
                memcpy(wstr, ptr, pLen);
                for (i = (pLen/2)-1; i > 0; i--)
                {
                    if (((USHORT) wstr[i] == (USHORT) 0xFFFF))
                    {
                        wstr[i] = (USHORT) 0;
                    }
                    else break;
                }

                wstr[pLen / 2] = wstr[(pLen / 2) + 1]= '\0';
                 fwprintf(DumpFile,   L"\"%ws\", ", wstr);
            }
            ptr += pLen;

            break;
        }

        case ItemDSString:   // Counted String
        {
            USHORT pLen = (USHORT)(256 * ((USHORT) * ptr) + ((USHORT) * (ptr + 1)));
            ptr += sizeof(USHORT);
            if (pLen > (pEvent->MofLength - MofDataUsed - 1)) {
                pLen = (USHORT) (pEvent->MofLength - MofDataUsed - 1);
            }
            if (pLen > 0)
            {
                strcpy(str, ptr);
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                fwprintf(DumpFile,   L"\"%ws\", ", wstr);
            }
            ptr += (pLen + 1);
            break;
        }

        case ItemPString:   // Counted String
        {
            USHORT pLen = * ((USHORT *) ptr);
            ptr += sizeof(USHORT);

            if (pLen > (pEvent->MofLength - MofDataUsed)) {
                pLen = (USHORT) (pEvent->MofLength - MofDataUsed);
            }

            if (pLen > MOFSTR * sizeof(CHAR)) {
                pLen = MOFSTR * sizeof(CHAR);
            }
            if (pLen > 0) {
                memcpy(str, ptr, pLen);
                str[pLen] = '\0';
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                fwprintf(DumpFile,   L"\"%ws\", ", wstr);
            }
            ptr += pLen;
            break;
        }

        case ItemDSWString:  // DS Counted Wide Strings
        case ItemPWString:  // Counted Wide Strings
        {
            USHORT pLen = (USHORT)(( pItem->ItemType == ItemDSWString)
                        ? (256 * ((USHORT) * ptr) + ((USHORT) * (ptr + 1)))
                        : (* ((USHORT *) ptr)));

            ptr += sizeof(USHORT);
            if (pLen > (pEvent->MofLength - MofDataUsed)) {
                pLen = (USHORT) (pEvent->MofLength - MofDataUsed);
            }

            if (pLen > MOFWSTR * sizeof(WCHAR)) {
                pLen = MOFWSTR * sizeof(WCHAR);
            }
            if (pLen > 0) {
                memcpy(wstr, ptr, pLen);
                wstr[pLen / sizeof(WCHAR)] = L'\0';
                 fwprintf(DumpFile,   L"\"%ws\", ", wstr);
            }
            ptr += pLen;
            break;
        }

        case ItemNWString:   // Non Null Terminated String
        {
           USHORT Size;

           Size = (USHORT)(pEvent->MofLength - (ULONG)(ptr - MofData));
           if( Size > MOFSTR )
           {
               Size = MOFSTR;
           }
           if (Size > 0)
           {
               memcpy(wstr, ptr, Size);
               wstr[Size / 2] = '\0';
                fwprintf(DumpFile,   L"\"%ws\", ", wstr);
           }
           ptr += Size;
           break;
        }

        case ItemMLString:  // Multi Line String
        {
            USHORT   pLen;
            char   * src, * dest;
            BOOL     inQ       = FALSE;
            BOOL     skip      = FALSE;
            UINT     lineCount = 0;

            ptr += sizeof(UCHAR) * 2;
            pLen = (USHORT)strlen(ptr);
            if (pLen > 0)
            {
                src = ptr;
                dest = str;
                while (* src != '\0'){
                    if (* src == '\n'){
                        if (!lineCount){
                            * dest++ = ' ';
                        }
                        lineCount++;
                    }else if (* src == '\"'){ 
                        if (inQ){
                            char   strCount[32];
                            char * cpy;

                            sprintf(strCount, "{%dx}", lineCount);
                            cpy = & strCount[0];
                            while (* cpy != '\0'){
                                * dest ++ = * cpy ++;
                            }
                        }
                        inQ = !inQ;
                    }else if (!skip){
                        *dest++ = *src;
                    }
                    skip = (lineCount > 1 && inQ);
                    src++;
                }
                *dest = '\0';
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                fwprintf(DumpFile,   L"\"%ws\", ", wstr);
            }
            ptr += (pLen);
            break;
        }

        case ItemSid:
        {
            WCHAR        UserName[64];
            WCHAR        Domain[64];
            WCHAR        FullName[256];
            ULONG        asize = 0;
            ULONG        bsize = 0;
            ULONG        Sid[64];
            PULONG       pSid  = & Sid[0];
            SID_NAME_USE Se;
            ULONG        nSidLength;

            pSid = (PULONG) ptr;
            if (*pSid == 0){
                ptr += 4;
                 fwprintf(DumpFile,   L"%4d, ", *pSid);
            }
            else
            {
                ptr += 8;           // skip the TOKEN_USER structure
                nSidLength = 8 + (4*ptr[1]);

                asize = 64;
                bsize = 64;
                if (LookupAccountSidW(
                                NULL,
                               (PSID) ptr,
                               (LPWSTR) & UserName[0],
                               & asize,
                               (LPWSTR) & Domain[0],
                               & bsize,
                               & Se))
                {
                    LPWSTR pFullName = &FullName[0];
                    swprintf( pFullName,  L"\\\\%s\\%s", Domain, UserName);
                    asize = (ULONG)  lstrlenW(pFullName);
                    if (asize > 0){
                         fwprintf(DumpFile,   L"\"%s\", ", pFullName);
                    }
                }
                else
                {
                     fwprintf(DumpFile,   L"\"System\", " );
                }
                SetLastError( ERROR_SUCCESS );
                ptr += nSidLength;
            }
            break;
        }

        case ItemChar4:
             fwprintf(DumpFile,
                        L"%c%c%c%c, ",
                      *ptr, ptr[1], ptr[2], ptr[3]);
            ptr += 4 * sizeof(CHAR);
            break;

        case ItemGuid:
        {
            WCHAR s[64];
            
             fwprintf(DumpFile,   L"%s, ", CpdiGuidToString(&s[0], (LPGUID)ptr));
            ptr += sizeof(GUID);
            break;
        }

        case ItemCPUTime:
        {
            ulongword = * ((PULONG) ptr);
            fwprintf(DumpFile, L"%8lu, ", ulongword * TimerResolution);
            ptr += sizeof (ULONG);
            break;
        }

        case ItemOptArgs:
        {
            DWORD    dwOptArgs = * ((PLONG) ptr);
            DWORD    dwMofLen  = pEvent->MofLength + sizeof(UNICODE_NULL);
            DWORD    dwMofUsed = MofDataUsed + sizeof(DWORD);
            DWORD    dwType;
            DWORD    i;
            LPWSTR   wszString;
            LPSTR    aszString;
            LONG     lValue32;
            LONGLONG lValue64;

            ptr += sizeof(LONG);
            for (i = 0; i < 8; i ++) {
                if (dwMofUsed > dwMofLen) {
                    break;
                }
                dwType = (dwOptArgs >> (i * 4)) & 0x0000000F;
                switch (dwType) {
                case 0: // LONG
                    dwMofUsed += sizeof(LONG);
                    if (dwMofUsed <= dwMofLen) {
                        lValue32   = * ((LONG *) ptr);
                        ptr       += sizeof(LONG);
                        fwprintf(DumpFile, L"%d,", lValue32);
                    }
                    break;

                case 1: // WSTR
                    wszString  = (LPWSTR) ptr;
                    dwMofUsed += sizeof(WCHAR) * (lstrlenW(wszString) + 1);
                    if (dwMofUsed <= dwMofLen) {
                        fwprintf(DumpFile, L"\"%ws\",", wszString);
                        ptr += sizeof(WCHAR) * (lstrlenW(wszString) + 1);
                    }
                    break;

                case 2: // STR
                    aszString  = (LPSTR) ptr;
                    dwMofUsed += sizeof(CHAR) * (lstrlenA(aszString) + 1);
                    if (dwMofUsed <= dwMofLen) {
                        fwprintf(DumpFile, L"\"%s\",", aszString);
                        ptr += sizeof(CHAR) * (lstrlenA(aszString) + 1);
                    }
                    break;

                case 3:  // LONG64
                    dwMofUsed += sizeof(LONGLONG);
                    if (dwMofUsed <= dwMofLen) {
                        lValue64   = * ((LONGLONG *) ptr);
                        ptr       += sizeof(LONGLONG);
                        fwprintf(DumpFile, L"%I64d,", lValue64);
                    }
                    break;
                }
            }
            break;
        }

        case ItemVariant:
        {
            //
            // Variable Size. First ULONG gives the sizee and the rest is blob
            //
            ulongword = *((PULONG) ptr); 
            ptr += sizeof(ULONG);

             fwprintf(DumpFile,   L"DataSize=%d, ", ulongword);

            // No need to dump the contents of the Blob itself. 

            ptr += ulongword; 
        
            break;
        }
        case ItemBool:
        {
            BOOL Flag = (BOOL)*ptr;
             fwprintf(DumpFile,   L"%5s, " , (Flag) ?   L"TRUE" :   L"FALSE" );
            ptr += sizeof(BOOL);
            break;
        }

        default:
            ptr += sizeof (int);
        }
    }

    //Instance ID, Parent Instance ID
     fwprintf(DumpFile,   L"%d, %d\n", pEvent->InstanceId, pEvent->ParentInstanceId );
}


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracectr\cpdata.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    cpdata.h 

Abstract:

    cp data internal data structures

Author:

    08-Apr-1998 mraghu

Revision History:

--*/

#ifndef __CPDATA__
#define __CPDATA__

#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#pragma warning (disable:4306)
#include <ntrtl.h>
#include <nturtl.h>
#pragma warning (default:4306)
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>
#include <wtypes.h>
#pragma warning (disable:4201)
#include <wmistr.h>
#include <tchar.h>
#include <objbase.h>
#include <initguid.h>
#include <wmium.h>
#include <ntwmi.h>
#include <wmiumkm.h>

#include <wmiguid.h>
#include <evntrace.h>
#pragma warning (default:4201)

#include "list.h"
#include "workload.h"

#define MAX_FILE_TABLE_SIZE     64      // Must match ntos\wmi\callout.c

#define MAX_TRANS_LEVEL         32

#ifndef IsEqualGUID
#define IsEqualGUID(guid1, guid2) \
                (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif
#define THREAD_HASH_TABLESIZE     29

#define MAXSTR 1024

#define CHECK_HR(hr)     if( ERROR_SUCCESS != hr ){ goto cleanup; }

typedef struct _TRACE_CONTEXT_BLOCK {
    PEVENT_TRACE_PROPERTIES LoggerInfo;
    ULONG     LogFileCount;
    ULONG     LoggerCount;
    LPWSTR    LogFileName[MAXLOGGERS];
    LPWSTR    LoggerName[MAXLOGGERS];
    LPCSTR    PdhFileName;  // ANSI ??
    LPWSTR    ProcFileName;
    LPWSTR    DumpFileName;
    LPWSTR    MofFileName;
    LPWSTR    MergeFileName;
    LPWSTR    SummaryFileName;
    LPWSTR    CompFileName;
    HANDLE    hEvent;
    FILE*     hDumpFile;
    ULONGLONG StartTime;    // If Sequential, start, End Times to window. 
    ULONGLONG EndTime;      //  
    ULONG     Flags;
    BOOLEAN   LoggerStartedHere;
    HANDLE    hThreadVector;
    TRACEHANDLE HandleArray[MAXLOGGERS];
    PVOID       pUserContext;
} TRACE_CONTEXT_BLOCK, *PTRACE_CONTEXT_BLOCK;

typedef struct _HPF_FILE_RECORD
{
    LIST_ENTRY Entry;
    ULONG      RecordID;
    ULONG      IrpFlags;
    ULONG      DiskNumber;
    ULONG      BytesCount;
    ULONGLONG  ByteOffset;
    PVOID      fDO;
} HPF_FILE_RECORD, *PHPF_FILE_RECORD;

typedef struct _HPF_RECORD
{
    LIST_ENTRY     Entry;
    ULONG          RecordID;
    ULONG          lProgramCounter;
    ULONG          lFaultAddress;
    PVOID          fDO;
    LONG           lByteCount;
    LONGLONG       lByteOffset;
    LIST_ENTRY     HPFReadListHead;
} HPF_RECORD, *PHPF_RECORD;

typedef struct _TDISK_RECORD
{
    LIST_ENTRY Entry;
    ULONG   DiskNumber;
    LPWSTR  DiskName;
    ULONG   ReadCount;
    ULONG   WriteCount;
    ULONG   ReadSize;
    ULONG   WriteSize;
    ULONG   HPF;
    ULONG   HPFSize; 
    LIST_ENTRY  FileListHead;
    LIST_ENTRY  ProcessListHead;
} TDISK_RECORD, *PTDISK_RECORD; 

typedef struct _FILE_RECORD
{
    LIST_ENTRY Entry;
    LIST_ENTRY ProtoProcessListHead; // List of Processes touching this file. 
    PWCHAR  FileName;
    ULONG   DiskNumber;
    ULONG   ReadCount;
    ULONG   HPF;
    ULONG   WriteCount;
    ULONG   ReadSize;
    ULONG   WriteSize;
    ULONG   HPFSize;
} FILE_RECORD, *PFILE_RECORD;

typedef struct _FILE_OBJECT 
{
    PVOID fDO;
    PFILE_RECORD fileRec;
    LIST_ENTRY   ProtoFileRecordListHead;
}FILE_OBJECT, *PFILE_OBJECT;

typedef struct _PROTO_FILE_RECORD
{
    LIST_ENTRY Entry;
    BOOLEAN    ReadFlag;
    ULONG      DiskNumber;
    ULONG      IoSize;
} PROTO_FILE_RECORD, *PPROTO_FILE_RECORD;

typedef struct _TRANS_RECORD
{
    LIST_ENTRY Entry;
    LIST_ENTRY SubTransListHead;
    LPGUID pGuid;
    BOOL    bStarted;
    ULONG   UCpu;
    ULONG   KCpu;
    ULONG   DeltaReadIO;
    ULONG   DeltaWriteIO;
    ULONG   RefCount;
    ULONG   RefCount1;
} TRANS_RECORD, *PTRANS_RECORD;

typedef struct _PROCESS_RECORD
{
    LIST_ENTRY Entry;
    LIST_ENTRY ThreadListHead;
    LIST_ENTRY DiskListHead;
    LIST_ENTRY FileListHead;    // All the Files this process touched. 
    LIST_ENTRY ModuleListHead;  // All the modules this process loaded.
    LIST_ENTRY HPFListHead;
    PWCHAR UserName;
    PWCHAR ImageName;
    ULONG PID;
    ULONG DeadFlag;
    ULONG ReadIO;
    ULONG WriteIO;
    ULONG SendCount;
    ULONG RecvCount;
    ULONG SendSize;
    ULONG RecvSize;
    ULONG HPF;
    ULONG HPFSize;
    ULONG SPF;
    ULONG PrivateWSet;
    ULONG GlobalWSet;
    ULONG ReadIOSize;
    ULONG WriteIOSize;
    ULONG lDataFaultHF;
    ULONG lDataFaultTF;
    ULONG lDataFaultDZF;
    ULONG lDataFaultCOW;
    ULONG lCodeFaultHF;
    ULONG lCodeFaultTF;
    ULONG lCodeFaultDZF;
    ULONG lCodeFaultCOW;
    ULONGLONG ResponseTime;
    ULONGLONG TxnStartTime;
    ULONGLONG TxnEndTime;
} PROCESS_RECORD, *PPROCESS_RECORD;

typedef struct _THREAD_RECORD
{
    LIST_ENTRY Entry;
    LIST_ENTRY DiskListHead;
    LIST_ENTRY TransListHead; // transactions list
    LIST_ENTRY HPFReadListHead;
    LIST_ENTRY HPFWriteListHead;
    WCHAR      strSortKey[MAXSTR];
    ULONG      TID;
    PPROCESS_RECORD pProcess;
    BOOLEAN         fOrphan;
    ULONG DeadFlag;
    ULONG ProcessorID;
    ULONG ClassNumber;    // Class to which this thread is assigned.
    ULONG ReadIO;
    ULONG WriteIO;
    ULONG SendCount;
    ULONG RecvCount;
    ULONG SendSize;
    ULONG RecvSize;
    ULONG HPF;
    ULONG SPF;
    ULONG ReadIOSize;
    ULONG WriteIOSize;
    ULONG HPFSize;

    ULONGLONG TimeStart;
    ULONGLONG TimeEnd;
    ULONG KCPUStart;
    ULONG KCPUEnd;
    ULONG UCPUStart;
    ULONG UCPUEnd;

    // The Following fields are used in getting the Delta  
    // CPU, I/O to charge on a transaction basis. 
    // The Current Transaction being executed by this thread is 
    // given by pMofInfo and when the trans is completed the Delta CPU, I/O
    // are charged to that transaction. 

    ULONG   DeltaReadIO;
    ULONG   DeltaWriteIO;
    ULONG   DeltaSend;
    ULONG   DeltaRecv;
    ULONG RefCount;
    ULONG JobId;    // Keeps track of the Current Job this thread is working on
    PVOID pMofData; // Keep Track of the  Current transaction Guid

    ULONG   KCPU_Trans;
    ULONG   UCPU_Trans;
    ULONG   KCPU_NoTrans;
    ULONG   UCPU_NoTrans;
    ULONG   KCPU_PrevTrans;
    ULONG   UCPU_PrevTrans;
    LONG    TransLevel;

    ULONG     KCPU_PrevEvent;
    ULONG     UCPU_PrevEvent;
    ULONGLONG Time_PrevEvent;

    PTRANS_RECORD TransStack[MAX_TRANS_LEVEL];

}THREAD_RECORD, *PTHREAD_RECORD;

typedef struct _MODULE_RECORD MODULE_RECORD, *PMODULE_RECORD;
struct _MODULE_RECORD
{
    LIST_ENTRY      Entry;
    PPROCESS_RECORD pProcess;
    ULONG           lBaseAddress;
    ULONG           lModuleSize;
    ULONG           lDataFaultHF;
    ULONG           lDataFaultTF;
    ULONG           lDataFaultDZF;
    ULONG           lDataFaultCOW;
    ULONG           lCodeFaultHF;
    ULONG           lCodeFaultTF;
    ULONG           lCodeFaultDZF;
    ULONG           lCodeFaultCOW;
    WCHAR         * strModuleName;
    PMODULE_RECORD  pGlobalPtr;
};

typedef struct _SYSTEM_RECORD {
    ULONGLONG   StartTime;
    ULONGLONG   EndTime;
    FILE*       TempFile;
    BOOLEAN     fNoEndTime;
    ULONG       CurrentThread0;
    ULONG       ElapseTime;
    ULONG       TimerResolution;
    ULONG       NumberOfEvents;
    ULONG       NumberOfProcessors;
    ULONG       NumberOfWorkloads;
    ULONG       BuildNumber;
    PFILE_OBJECT *FileTable;
    PLIST_ENTRY ThreadHashList;
    LIST_ENTRY  ProcessListHead;
    LIST_ENTRY  GlobalThreadListHead;
    LIST_ENTRY  GlobalDiskListHead;
    LIST_ENTRY  HotFileListHead;
    LIST_ENTRY  WorkloadListHead;
    LIST_ENTRY  InstanceListHead;
    LIST_ENTRY  EventListHead;
    LIST_ENTRY  GlobalModuleListHead;  // Global module list.
    LIST_ENTRY  ProcessFileListHead;
    LIST_ENTRY  JobListHead;
    HANDLE      hLoggerUpEvent;
} SYSTEM_RECORD, *PSYSTEM_RECORD;

typedef struct _PROCESS_FILE_RECORD {
    LIST_ENTRY  Entry;
    ULONGLONG   StartTime;
    ULONGLONG   EndTime;
    LPWSTR      FileName;
    LPWSTR      TraceName;
} PROCESS_FILE_RECORD, *PPROCESS_FILE_RECORD;

typedef struct _PROTO_PROCESS_RECORD
{
    LIST_ENTRY Entry;
    PPROCESS_RECORD ProcessRecord;
    ULONG ReadCount;
    ULONG WriteCount;
    ULONG HPF;
    ULONG ReadSize;
    ULONG WriteSize;
    ULONG HPFSize;
}PROTO_PROCESS_RECORD, *PPROTO_PROCESS_RECORD;


//
// MOF_INFO  structure maintains the global information for the GUID. 
// For each GUID, the event layouts are maintained by Version, Level and Type. 
// 

typedef struct _MOF_INFO {
    LIST_ENTRY   Entry;
    LIST_ENTRY   DataListHead;
    LPWSTR       strDescription;        // Class Name
    LPWSTR       strSortField;
    ULONG        EventCount;    
    GUID         Guid;
    LIST_ENTRY   VersionHeader;
    BOOL         bKernelEvent;
}  MOF_INFO, *PMOF_INFO;


//
// MOF_VERSION structure ic created one per Version, Level Type combination. 
//

typedef struct _MOF_VERSION {
    LIST_ENTRY Entry;
    LIST_ENTRY ItemHeader;     // Maintains the list of ITEM_DESC for this type. 
    LPWSTR  strType;
    SHORT   Version;
    SHORT   TypeIndex;
    CHAR    Level;
    ULONG   EventCountByType;    // Count of Events by this type for this Guid
} MOF_VERSION, *PMOF_VERSION;


typedef struct _MOF_DATA {
    LIST_ENTRY   Entry;
    PWCHAR       strSortKey;
    ULONG        CompleteCount;
    LONG         InProgressCount;
    LONGLONG    AverageResponseTime;
    LONGLONG    TotalResponseTime;
    ULONGLONG    PrevClockTime;
    ULONG        MmTf;
    ULONG        MmDzf;
    ULONG        MmCow;
    ULONG        MmGpf;
    ULONG        UserCPU;
    ULONG        KernelCPU;
    ULONG        EventCount;
    ULONG        ReadCount;
    ULONG        WriteCount;
    ULONG        SendCount;
    ULONG        RecvCount;
    LONG         MinKCpu;
    LONG         MaxKCpu;
    LONG         MinUCpu;
    LONG         MaxUCpu;
} MOF_DATA, *PMOF_DATA;

// A Job record is one that passses through several threads to complete.
// Jobs are identified by a Job Id, usually created during the Start
// event and recorded as an additional field in the mof data.
// Since there can be any number of jobs in the system over the data
// collection interval, we will flush the completed jobs to a temp file
// and reread it back at the end to print a report.
//  Note: Job_record needs to be Guid based. (ie., per type of transaction).
// Currently it is not.
//

#define MAX_THREADS 10  // Upto threads can be working on a Job.

typedef struct _THREAD_DATA {
    ULONG ThreadId;
    ULONG PrevKCPUTime;
    ULONG PrevUCPUTime;
    ULONG PrevReadIO;
    ULONG PrevWriteIO;
    ULONG KCPUTime;
    ULONG UCPUTime;
    ULONG ReadIO;
    ULONG WriteIO;
    ULONG Reserved;
} THREAD_DATA, *PTHREAD_DATA;

typedef struct _JOB_RECORD {
    LIST_ENTRY Entry;
    ULONG      JobId;
    ULONG      KCPUTime;
    ULONG      UCPUTime;
    ULONG      ReadIO;
    ULONG      WriteIO;
    ULONG      DataType;
    ULONG      JobSize;
    ULONG      Pages;
    ULONG      PagesPerSide;
    ULONG      ICMMethod;
    ULONG      GdiJobSize;
    ULONGLONG  StartTime;
    ULONGLONG  EndTime;
    ULONGLONG  ResponseTime;
    ULONGLONG  PauseTime;
    ULONGLONG  PauseStartTime;
    ULONGLONG  PrintJobTime;
    SHORT      FilesOpened;
    SHORT      Color;
    SHORT      XRes;
    SHORT      YRes;
    SHORT      Quality;
    SHORT      Copies;
    SHORT      TTOption;
    ULONG      NumberOfThreads; // Total Number of Threads worked on this Job
    THREAD_DATA   ThreadData[MAX_THREADS];
} JOB_RECORD, *PJOB_RECORD;

//
// Global that  holds everything about the current session
//
extern SYSTEM_RECORD CurrentSystem;
extern BOOLEAN       fDSOnly;
extern ULONGLONG     DSStartTime;
extern ULONGLONG     DSEndTime;

extern RTL_CRITICAL_SECTION TLCritSect;
#define EnterTracelibCritSection() RtlEnterCriticalSection(&TLCritSect)
#define LeaveTracelibCritSection() RtlLeaveCriticalSection(&TLCritSect)

//
// Initialization Routines. 
//

VOID 
InitDiskRecord(
    PTDISK_RECORD pDisk,
    ULONG DiskNumber
    );

VOID 
InitMofData(
    PMOF_DATA pMofData
    );

VOID 
InitThreadRecord(
    PTHREAD_RECORD pThread
    );

VOID
InitTransRecord(
    PTRANS_RECORD pThread
    );

VOID 
InitProcessRecord(
    PPROCESS_RECORD pProcess
    );

VOID 
InitFileRecord(
    PFILE_RECORD pFile
    );

//
// Add, Delete and Find routines

BOOLEAN
AddModuleRecord(
    PMODULE_RECORD * pModule,
    ULONG            lBaseAddress,
    ULONG            lModuleSize,
    WCHAR          * strModuleName
    );

BOOLEAN
AddHPFFileRecord(
    PHPF_FILE_RECORD * ppHPFFileRecord,
    ULONG              RecordID,
    ULONG              IrpFlags,
    ULONG              DiskNumber,
    ULONGLONG          ByteOffset,
    ULONG              BytesCount,
    PVOID              fDO
    );

BOOLEAN
AddHPFRecord(
    PHPF_RECORD * ppHPFRRecord,
    ULONG         lFaultAddress,
    PVOID         fDO,
    LONG          ByteCount,
    LONGLONG      ByteOffset
    );

void
DeleteHPFRecord(
    PHPF_RECORD pHPFRecord
    );

BOOLEAN 
AddProcess( 
    ULONG ProcessId, 
    PPROCESS_RECORD *Process 
    );

BOOLEAN
DeleteTrans(
    PTRANS_RECORD Trans
    );

BOOLEAN
DeleteTransList(
    PLIST_ENTRY Head,
    ULONG level
    );

PTRANS_RECORD
FindTransByList(
    PLIST_ENTRY Head,
    LPGUID pGuid,
    ULONG  level
    );

PMOF_DATA
FindMofData(
    PMOF_INFO pMofInfo,
    PWCHAR    strSortKey
    );

BOOLEAN 
DeleteProcess( 
    PPROCESS_RECORD Process 
    );

BOOLEAN 
AddThread( 
    ULONG            ThreadId,
    PEVENT_TRACE     pEvent,
    PTHREAD_RECORD * Thread
    );

BOOLEAN 
DeleteThread( 
    PTHREAD_RECORD Thread 
    );

BOOLEAN 
AddFile( 
    WCHAR* fileName, 
    PFILE_RECORD  *ReturnedFile 
    );

BOOLEAN 
DeleteFileRecord( 
    PFILE_RECORD fileRec 
    );

BOOLEAN 
DeleteFileObject( 
    PFILE_OBJECT fileObj 
    );

PPROCESS_RECORD 
FindProcessById( 
    ULONG    Id,
    BOOLEAN CheckAlive 
    );

PTDISK_RECORD
FindLocalDiskById(
    PLIST_ENTRY Head,
    ULONG DiskNumber
    );
PTDISK_RECORD
FindProcessDiskById(
    PPROCESS_RECORD pProcess,
    ULONG DiskNumber
    );

PFILE_RECORD 
FindFileInProcess( 
    PPROCESS_RECORD pProcess,
    WCHAR* Name 
    );
PPROTO_PROCESS_RECORD
FindProtoProcessRecord(
    PFILE_RECORD pFile,
    PPROCESS_RECORD pProcess
    );

PFILE_RECORD 
FindFileRecordByName( 
    WCHAR* Name 
    );

PTHREAD_RECORD 
FindGlobalThreadById( 
    ULONG         ThreadId,
    PEVENT_TRACE  pEvent
    );

PTDISK_RECORD 
FindGlobalDiskById( 
    ULONG Id 
    );

PPROCESS_RECORD 
FindDiskProcessById(
    PTDISK_RECORD Disk,
    ULONG    Id
    );

ULONGLONG CalculateProcessLifeTime(PPROCESS_RECORD pProcess);
ULONG CalculateProcessKCPU(PPROCESS_RECORD pProcess);
ULONG CalculateProcessUCPU(PPROCESS_RECORD pProcess);

VOID 
Cleanup();

BOOLEAN 
AddDisk( 
    ULONG DiskNumber, 
    PTDISK_RECORD *ReturnedDisk 
    );

BOOLEAN
DeleteDisk(
    PTDISK_RECORD Disk
    );

ULONG
DeleteJobRecord(
    PJOB_RECORD pJob,
    ULONG       bSave
    );
PJOB_RECORD
AddJobRecord(
    ULONG JobId
    );
PJOB_RECORD
FindJobRecord(
    ULONG JobId
    );

int EtwRelogEtl(
    PTRACE_CONTEXT_BLOCK TraceContext
    );

// 
// Trace Event Callbacks
//
VOID
ShutdownThreads(); // Shuts down the running threads before finishing
VOID
ShutdownProcesses(); // Shuts down the running processes before finishing

ULONG
GetMofData(
    PEVENT_TRACE pEvent,
    WCHAR *strName,
    PVOID ReturnValue,
    ULONG ReturnLength
    );

VOID GeneralEventCallback(PEVENT_TRACE pEvent);
VOID DeclareKernelEvents();

VOID 
ProcessCallback(
    PEVENT_TRACE pEvent
    );
VOID 
PsStartCallback(
    PEVENT_TRACE pEvent
    );
VOID 
PsEndCallback(
    PEVENT_TRACE pEvent
    );
VOID
ThreadCallback(
    PEVENT_TRACE pEvent
    );
VOID 
ThStartCallback(
    PEVENT_TRACE pEvent
    );
VOID 
ThEndCallback(
    PEVENT_TRACE pEvent
    );
VOID
DiskIoCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    );
VOID 
IoReadCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
   );
VOID 
IoWriteCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    );
VOID 
HotFileCallback(
    PEVENT_TRACE pEvent
    );
VOID 
LogHeaderCallback(
    PEVENT_TRACE pEvent
    );
VOID 
EventCallback(
    PEVENT_TRACE pEvent,
    PTHREAD_RECORD pThread
    );

VOID AddEvent(
        IN PFILE_OBJECT fileObject,
        IN ULONG DiskNumber,
        IN ULONG IoSize,
        IN BOOLEAN ReadFlag);

PFILE_OBJECT FindFileInTable (
                IN PVOID fDO
                );


//VOID
//ProcessPdh(
//    IN LPCSTR LogFileName,
//    IN ULONGLONG StartTime,
//    IN ULONGLONG EndTime
//    );

//
// Workload Classification Routines
//

VOID
Classify();

VOID
Aggregate();

VOID
InitClass();

VOID
AssignClass(
    IN PPROCESS_RECORD pProcess,
    IN PTHREAD_RECORD pThread
    );

ULONG
ProcessRunDown();

PMOF_INFO
GetMofInfoHead(
    LPCGUID  pGuid
    );

void
WriteSummary();

#define IsEmpty( string )  ((BOOL)( (NULL != string) && ( L'\0' != string[0]) ))

#define ASSIGN_STRING( dest, src )                                  \
if( NULL != src  ){                                                 \
    dest = (LPWSTR)malloc( (wcslen(src)+1)*sizeof(WCHAR) );         \
    if( NULL != dest ){                                             \
        wcscpy( dest, src );                                        \
    }                                                               \
}                                                                   \


#endif  // __CPDATA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracectr\item.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    item.h

Abstract:

    Item header file

Author:

    08-Apr-1998 mraghu

Revision History:

--*/

//
// Temporary structure used. Should be using MOF types
//

#define GUID_TYPE_HEADER                  L"Header" 
#define GUID_TYPE_UNKNOWN                 L"Unknown" 
#define GUID_TYPE_DEFAULT                 L"Default" 

#define EVENT_TYPE_DEFAULT              ((CHAR)(-1))
#define EVENT_LEVEL_DEFAULT             ((CHAR)(-1))
#define EVENT_VERSION_DEFAULT           ((SHORT)(-1))

#define STR_ItemChar                      L"ItemChar" 
#define STR_ItemCharHidden                L"ItemCharHidden"
#define STR_ItemWChar                     L"ItemWChar" 
#define STR_ItemUChar                     L"ItemUChar" 
#define STR_ItemCharShort                 L"ItemCharShort" 
#define STR_ItemCharSign                  L"ItemCharSign" 
#define STR_ItemShort                     L"ItemShort" 
#define STR_ItemUShort                    L"ItemUShort" 
#define STR_ItemLong                      L"ItemLong" 
#define STR_ItemULong                     L"ItemULong" 
#define STR_ItemULongX                    L"ItemULongX" 
#define STR_ItemLongLong                  L"ItemLongLong" 
#define STR_ItemULongLong                 L"ItemULongLong" 
#define STR_ItemString                    L"ItemString" 
#define STR_ItemWString                   L"ItemWString" 
#define STR_ItemRString                   L"ItemRString" 
#define STR_ItemRWString                  L"ItemRWString" 
#define STR_ItemPString                   L"ItemPString" 
#define STR_ItemPWString                  L"ItemPWString" 
#define STR_ItemDSString                  L"ItemDSString" 
#define STR_ItemDSWString                 L"ItemDSWString" 
#define STR_ItemMLString                  L"ItemMLString" 
#define STR_ItemSid                       L"ItemSid" 
#define STR_ItemChar4                     L"ItemChar4" 
#define STR_ItemIPAddr                    L"ItemIPAddr" 
#define STR_ItemPort                      L"ItemPort" 
#define STR_ItemNWString                  L"ItemNWString" 
#define STR_ItemPtr                       L"ItemPtr" 
#define STR_ItemGuid                      L"ItemGuid" 
#define STR_ItemVariant                   L"ItemVariant" 
#define STR_ItemBool                      L"ItemBool" 
#define STR_ItemOptArgs                   L"ItemOptArgs"
#define STR_ItemCPUTime                   L"ItemCPUTime"

//
// The following are the data types  supported by 
// WMI event trace parsing tools. New data types must be
// added to this file and the parsing code for that type
// must be added in the DumpEvent routine. 
//



typedef enum _ITEM_TYPE {
    ItemChar,
    ItemCharHidden,
    ItemWChar,
    ItemUChar,
    ItemCharShort,
    ItemCharSign,
    ItemShort,
    ItemUShort,
    ItemLong,
    ItemULong,
    ItemULongX,
    ItemLongLong,
    ItemULongLong,
    ItemString,
    ItemWString,
    ItemRString,
    ItemRWString,
    ItemPString,
    ItemPWString,
    ItemDSString,
    ItemDSWString,
    ItemSid,
    ItemChar4,
    ItemIPAddr,
    ItemPort,
    ItemMLString,
    ItemNWString,        // Non-null terminated Wide Char String
    ItemPtr,
    ItemGuid,
    ItemVariant,
    ItemBool,
    ItemOptArgs,
    ItemCPUTime,
    ItemUnknown
} ITEM_TYPE;

typedef struct _ITEM_DESC *PITEM_DESC;
typedef struct _ITEM_DESC {
    LIST_ENTRY  Entry;
    ULONG       DataSize;
    ULONG       ArraySize;
    ITEM_TYPE   ItemType;
    PWCHAR      strDescription;
} ITEM_DESC;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracectr\guids.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    guids.h

Abstract:

    guids header file

Author:

    08-Apr-1998 mraghu

Revision History:

--*/

// PrintJobsGuid needs to be removed once spoooler changes are checked in
//

GUID PrintJobGuid =
    {0x127eb555, 0x3b06, 0x46ea, 0xa0, 0x8b, 0x5d, 0xc2, 0xc3, 0xc5, 0x7c, 0xfd};

GUID RenderedJobGuid =
{0x1d32b239, 0x92a6, 0x485a, 0x96, 0xd2, 0xdc, 0x36, 0x59, 0xfb, 0x80, 0x3e};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracectr\list.h ===
//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOL
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracectr\main.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    main.c

Abstract:

    TRACELIB dll main file

Author:

    08-Apr-1998 mraghu

Revision History:

--*/

#include <stdio.h>
#include "cpdata.h"
#include "tracectr.h"

// Globals
extern ULONGLONG StartTime;
extern ULONGLONG EndTime;

SYSTEM_RECORD CurrentSystem;
static ULONG   lCachedFlushTimer = 1;
PTRACE_CONTEXT_BLOCK TraceContext = NULL;
RTL_CRITICAL_SECTION TLCritSect;

BOOLEAN fDSOnly       = FALSE;
ULONGLONG DSStartTime = 0;
ULONGLONG DSEndTime   = 0;
ULONG TotalBuffersRead = 0;
WCHAR TempFile[MAXSTR] = L"";

ULONG
WINAPI
TerminateOnBufferCallback(
    PEVENT_TRACE_LOGFILE pLog
);

extern WriteProc(
    LPWSTR filename,
    ULONG flags,
    PVOID pUserContext
);

HRESULT 
OnProcess(
    PTRACE_CONTEXT_BLOCK TraceContext
);        

ULONG GetMoreBuffers(
    PEVENT_TRACE_LOGFILE logfile 
);

void
ReorderThreadList()
{
    PLIST_ENTRY Head, Next;
    PTHREAD_RECORD Thread;
    int i;
    PPROCESS_RECORD Process;
    for (i=0; i < THREAD_HASH_TABLESIZE; i++) {

        Head = &CurrentSystem.ThreadHashList[i];
        Next = Head->Flink;
        while (Next != Head) {
            Thread = CONTAINING_RECORD( Next, THREAD_RECORD, Entry );
            Next = Next->Flink;
            RemoveEntryList( &Thread->Entry );
            Process = Thread->pProcess;
            if(Process != NULL){
                InsertTailList( &Process->ThreadListHead, &Thread->Entry );
            }
        }
    }
}
    
ULONG
CPDAPI
GetMaxLoggers()
{
    return MAXLOGGERS;
}

ULONG
CPDAPI
InitTraceContextW(
    PTRACE_BASIC_INFOW pUserInfo
    )
{
    UINT i, j;
    PFILE_OBJECT *fileTable;
    ULONG SizeNeeded, SizeIncrement;
    char * pStorage;
    HRESULT hr;
    BOOL bProcessing = FALSE;

    if (pUserInfo == NULL) {
        return ERROR_INVALID_DATA;
    }

    //
    // Must provide at least one logfile or a trace seassion to process
    //

    if ( (pUserInfo->LoggerCount == 0) && (pUserInfo->LogFileCount == 0) ) {
        return ERROR_INVALID_DATA;
    }

    //
    // Can not process both RealTime stream and a logfile at the same time
    //

    if ( (pUserInfo->LoggerCount > 0) && (pUserInfo->LogFileCount > 0) ) {
        return ERROR_INVALID_DATA;
    }

    //
    // Compute the Size Needed for allocation. 
    //

    SizeNeeded = sizeof(TRACE_CONTEXT_BLOCK);

    // Add LogFileName Strings

    for (i = 0; i < pUserInfo->LogFileCount; i++) {
        SizeNeeded +=  sizeof(WCHAR) * ( wcslen( pUserInfo->LogFileName[i] ) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    // Add LoggerName Strings

    for (i = 0; i < pUserInfo->LoggerCount; i++) {
        SizeNeeded += sizeof(WCHAR) * ( wcslen(pUserInfo->LoggerName[i]) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    //
    // Add ProcFile, MofFile, DumpFile, SummaryFile, TempFile name strings

    if (pUserInfo->ProcFileName != NULL) {
        SizeNeeded += sizeof(WCHAR) * (wcslen(pUserInfo->ProcFileName) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    if (pUserInfo->MofFileName != NULL) {
        SizeNeeded += sizeof(WCHAR) * (wcslen(pUserInfo->MofFileName) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    if (pUserInfo->DumpFileName != NULL) {
        SizeNeeded += sizeof(WCHAR) * (wcslen(pUserInfo->DumpFileName) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    if (pUserInfo->MergeFileName != NULL) {
        SizeNeeded += sizeof(WCHAR) * (wcslen(pUserInfo->MergeFileName) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    if (pUserInfo->CompFileName != NULL) {
        SizeNeeded += sizeof(WCHAR) * (wcslen(pUserInfo->CompFileName) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    if (pUserInfo->SummaryFileName != NULL) {
        SizeNeeded += sizeof(WCHAR) * (wcslen(pUserInfo->SummaryFileName) + 1);
        SizeNeeded = (SizeNeeded + 7) & ~7;
    }

    //
    // Add Room for the FileTable Caching
    //

    SizeNeeded += sizeof(PFILE_OBJECT) * MAX_FILE_TABLE_SIZE;


    //
    // Add Room for Thread Hash List 
    //

    SizeNeeded += sizeof(LIST_ENTRY) * THREAD_HASH_TABLESIZE;


    //
    // Allocate Memory for TraceContext 
    // 

    pStorage = malloc(SizeNeeded);
    if (pStorage == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    RtlZeroMemory(pStorage, SizeNeeded);

    TraceContext = (PTRACE_CONTEXT_BLOCK)pStorage;

    pStorage += sizeof(TRACE_CONTEXT_BLOCK);

    //
    // Initialize HandleArray
    //
   
    for (i=0; i < MAXLOGGERS; i++) {
        TraceContext->HandleArray[i] = (TRACEHANDLE)INVALID_HANDLE_VALUE;
    }

    //
    // Copy LogFileNames
    //

    for (i = 0; i < pUserInfo->LogFileCount; i++) {
        TraceContext->LogFileName[i] = (LPWSTR)pStorage; 
        wcscpy(TraceContext->LogFileName[i], pUserInfo->LogFileName[i]);
        SizeIncrement = (wcslen(TraceContext->LogFileName[i]) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    //
    // Copy LoggerNames
    //

    for (i = 0; i < pUserInfo->LoggerCount; i++) {
        j = i + pUserInfo->LogFileCount;
        TraceContext->LoggerName[j] =(LPWSTR) pStorage;
        wcscpy(TraceContext->LoggerName[j], pUserInfo->LoggerName[i]);
        SizeIncrement = (wcslen(TraceContext->LoggerName[j]) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }
    
    //
    // Copy Other File Names
    //

    if (pUserInfo->ProcFileName != NULL) {
        TraceContext->ProcFileName = (LPWSTR)pStorage;
        wcscpy( TraceContext->ProcFileName, pUserInfo->ProcFileName);
        SizeIncrement = (wcslen(TraceContext->ProcFileName) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    if (pUserInfo->DumpFileName != NULL) {
        TraceContext->DumpFileName = (LPWSTR)pStorage;
        wcscpy( TraceContext->DumpFileName, pUserInfo->DumpFileName);
        SizeIncrement = (wcslen(TraceContext->DumpFileName) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    if (pUserInfo->MofFileName != NULL) {
        TraceContext->MofFileName = (LPWSTR)pStorage;
        wcscpy( TraceContext->MofFileName, pUserInfo->MofFileName);
        SizeIncrement = (wcslen(TraceContext->MofFileName) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    if (pUserInfo->MergeFileName != NULL) {
        TraceContext->MergeFileName = (LPWSTR)pStorage;
        wcscpy( TraceContext->MergeFileName, pUserInfo->MergeFileName);
        SizeIncrement = (wcslen(TraceContext->MergeFileName) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    if (pUserInfo->CompFileName != NULL) {
        TraceContext->CompFileName = (LPWSTR)pStorage;
        wcscpy( TraceContext->CompFileName, pUserInfo->CompFileName);
        SizeIncrement = (wcslen(TraceContext->CompFileName) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    if (pUserInfo->SummaryFileName != NULL) {
        TraceContext->SummaryFileName = (LPWSTR)pStorage;
        wcscpy( TraceContext->SummaryFileName, pUserInfo->SummaryFileName);
        SizeIncrement = (wcslen(TraceContext->SummaryFileName) + 1) * sizeof(WCHAR);
        SizeIncrement = (SizeIncrement + 7) & ~7;
        pStorage += SizeIncrement;
    }

    TraceContext->LogFileCount = pUserInfo->LogFileCount;
    TraceContext->LoggerCount = pUserInfo->LoggerCount;
    TraceContext->StartTime = pUserInfo->StartTime;
    TraceContext->EndTime   = pUserInfo->EndTime;
    TraceContext->Flags     = pUserInfo->Flags;
    TraceContext->hEvent    = pUserInfo->hEvent;
    TraceContext->pUserContext = pUserInfo->pUserContext;

    RtlZeroMemory(&CurrentSystem, sizeof(SYSTEM_RECORD));
    InitializeListHead ( &CurrentSystem.ProcessListHead );
    InitializeListHead ( &CurrentSystem.GlobalThreadListHead );
    InitializeListHead ( &CurrentSystem.GlobalDiskListHead );
    InitializeListHead ( &CurrentSystem.HotFileListHead );
    InitializeListHead ( &CurrentSystem.WorkloadListHead );
    InitializeListHead ( &CurrentSystem.InstanceListHead );
    InitializeListHead ( &CurrentSystem.EventListHead );
    InitializeListHead ( &CurrentSystem.GlobalModuleListHead );
    InitializeListHead ( &CurrentSystem.ProcessFileListHead );
    InitializeListHead ( &CurrentSystem.JobListHead);

    CurrentSystem.FileTable = (PFILE_OBJECT *) pStorage; 
    pStorage +=  ( sizeof(PFILE_OBJECT) * MAX_FILE_TABLE_SIZE);

    CurrentSystem.ThreadHashList = (PLIST_ENTRY)pStorage; 
    pStorage += (sizeof(LIST_ENTRY) * THREAD_HASH_TABLESIZE);

    RtlZeroMemory(CurrentSystem.ThreadHashList, sizeof(LIST_ENTRY) * THREAD_HASH_TABLESIZE);

    for (i=0; i < THREAD_HASH_TABLESIZE; i++) { 
        InitializeListHead (&CurrentSystem.ThreadHashList[i]); 
    }

    if( (pUserInfo->Flags & TRACE_DUMP) && NULL != pUserInfo->DumpFileName ){
        TraceContext->Flags |= TRACE_DUMP;
    }

    if( (pUserInfo->Flags & TRACE_SUMMARY) && NULL != pUserInfo->SummaryFileName ){
        TraceContext->Flags |= TRACE_SUMMARY;
    }

    if( (pUserInfo->Flags & TRACE_INTERPRET) && NULL != pUserInfo->CompFileName ){
        TraceContext->Flags |= TRACE_INTERPRET;
    }
    
    hr = GetTempName( TempFile, MAXSTR );
    CHECK_HR(hr);

    CurrentSystem.TempFile = _wfopen( TempFile, L"w+");
    if( CurrentSystem.TempFile == NULL ){
        hr = GetLastError();
    }
    CHECK_HR(hr);
    
    CurrentSystem.fNoEndTime = FALSE;
    fileTable = CurrentSystem.FileTable;
    for ( i= 0; i<MAX_FILE_TABLE_SIZE; i++){ fileTable[i] = NULL; }

    //
    // Set the default Processing Flags to Dump
    //

    if( pUserInfo->Flags & TRACE_EXTENDED_FMT ){
        TraceContext->Flags |= TRACE_EXTENDED_FMT;
    }

    if( pUserInfo->Flags & TRACE_REDUCE ) {
        TraceContext->Flags |= TRACE_REDUCE;
        TraceContext->Flags |= TRACE_LOG_REPORT_BASIC;
    }

    if (TraceContext->Flags & TRACE_DS_ONLY)    {
        fDSOnly = TRUE;
        DSStartTime = pUserInfo->DSStartTime;
        DSEndTime   = pUserInfo->DSEndTime;
    }

    if( TraceContext->Flags & TRACE_MERGE_ETL ){
        hr = EtwRelogEtl( TraceContext );
        goto cleanup;
    }
       

    bProcessing = TRUE;

    RtlInitializeCriticalSection(&TLCritSect);

    //
    // Startup a Thread to update the counters. 
    // For Logfile replay we burn a thread and throttle it at the 
    // BufferCallbacks. 
    //

    hr = OnProcess(TraceContext);// Then process Trace Event Data. 

    ShutdownThreads();
    ShutdownProcesses();
    ReorderThreadList();

cleanup:
    if( ERROR_SUCCESS != hr ){
        __try{
            if( TraceContext->hDumpFile ){
                fclose( TraceContext->hDumpFile );
            }
            if( bProcessing ){
                Cleanup();
                RtlDeleteCriticalSection(&TLCritSect);
            }
            if( CurrentSystem.TempFile != NULL ){
                fclose( CurrentSystem.TempFile );
                DeleteFile( TempFile );
            }
            if( NULL != TraceContext ){
                free(TraceContext);
                TraceContext = NULL;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    return hr;
}

//  Buffer Callback. Used to send a flag to the logstream processing thread.
//
ULONG
GetMoreBuffers(
    PEVENT_TRACE_LOGFILE logfile 
    )
{
    TotalBuffersRead++;

    if (TraceContext->hEvent) {
        SetEvent(TraceContext->hEvent); 
    }
    //
    // While processing logfile playback, we can throttle the processing
    // of buffers by the FlushTimer value (in Seconds)
    //

    if (TraceContext->Flags & TRACE_LOG_REPLAY) {
        _sleep(TraceContext->LoggerInfo->FlushTimer * 1000);
    }
    if(logfile->EventsLost) {
#if DBG
        DbgPrint("(TRACECTR) GetMorBuffers(Lost: %9d   Filled: %9d\n",
                logfile->EventsLost, logfile->Filled );
#endif
    }
    return (TRUE);
}

ULONG 
CPDAPI
DeinitTraceContext(
    PTRACE_BASIC_INFOW pUserInfo
    )
{
    ULONG Status = ERROR_SUCCESS;
    ULONG LogFileCount, i;

    if (TraceContext == NULL) {
        return ERROR_INVALID_HANDLE;
    }

    LogFileCount = TraceContext->LogFileCount + TraceContext->LoggerCount;
    for (i=0; i < LogFileCount; i++) {
        if (TraceContext->HandleArray[i] != (TRACEHANDLE)INVALID_HANDLE_VALUE) {

            CloseTrace(TraceContext->HandleArray[i]);
            TraceContext->HandleArray[i] = (TRACEHANDLE)INVALID_HANDLE_VALUE;
        }
    }

    //
    // Write the Summary File
    //

    if (TraceContext->Flags & TRACE_SUMMARY) {
        WriteSummary();
    }
        
    if (TraceContext->Flags & TRACE_REDUCE) {
        if ((TraceContext->ProcFileName != NULL) && 
            (lstrlenW(TraceContext->ProcFileName) ) ){


            WriteProc(TraceContext->ProcFileName, 
                      TraceContext->Flags, 
                      TraceContext->pUserContext
                      );
        }
    }

    if( CurrentSystem.TempFile != NULL ){
        fclose(CurrentSystem.TempFile);
        DeleteFile( TempFile );
    }

    if (TraceContext->Flags & TRACE_DUMP) {
        if (TraceContext->hDumpFile != NULL) {
            fclose(TraceContext->hDumpFile);
        }
    }

    Cleanup();
    
    RtlDeleteCriticalSection(&TLCritSect);

    free (TraceContext);
    TraceContext = NULL;

    return (Status);
}

HRESULT 
OnProcess(
    PTRACE_CONTEXT_BLOCK TraceContext
    )
{
    ULONG LogFileCount;
    ULONG i;

    ULONG Status;
    PEVENT_TRACE_LOGFILE LogFile[MAXLOGGERS];
    BOOL bRealTime;
    SYSTEMTIME      stLocalTime;
    FILETIME        ftLocalTime;

    RtlZeroMemory( &LogFile[0], sizeof(PVOID) * MAXLOGGERS );

    if( TraceContext->LogFileCount > 0 ){
        LogFileCount = TraceContext->LogFileCount;
        bRealTime = FALSE;
    }else{
        LogFileCount = TraceContext->LoggerCount;
        bRealTime = TRUE;
    }

    for (i = 0; i < LogFileCount; i++) {
        LogFile[i] = malloc(sizeof(EVENT_TRACE_LOGFILE));
        if (LogFile[i] == NULL) {
            Status = ERROR_OUTOFMEMORY;
            goto cleanup;
        }

        RtlZeroMemory(LogFile[i], sizeof(EVENT_TRACE_LOGFILE));

        LogFile[i]->BufferCallback = (PEVENT_TRACE_BUFFER_CALLBACK)&TerminateOnBufferCallback;
        
        if( bRealTime ){
            LogFile[i]->LoggerName = TraceContext->LoggerName[i];
            LogFile[i]->LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
        }else{
            LogFile[i]->LogFileName = TraceContext->LogFileName[i];
        }
    }

    for (i = 0; i < LogFileCount; i++) {

        TraceContext->HandleArray[i] = OpenTrace(LogFile[i]);;
        
        if ((TRACEHANDLE)INVALID_HANDLE_VALUE == TraceContext->HandleArray[i] ) {
            Status = GetLastError();
            goto cleanup;
        }

        Status = ProcessTrace( &(TraceContext->HandleArray[i]), 1, NULL, NULL);
        if( ERROR_CANCELLED != Status && ERROR_SUCCESS != Status ){
            goto cleanup;
        }
    }
 
    for (i = 0; i < LogFileCount; i++){
        Status = CloseTrace(TraceContext->HandleArray[i]);
    }

    for (i=0; i<LogFileCount; i++) {
        
        LogFile[i]->BufferCallback = (PEVENT_TRACE_BUFFER_CALLBACK)&GetMoreBuffers;
        LogFile[i]->EventCallback = (PEVENT_CALLBACK)GeneralEventCallback;

        TraceContext->HandleArray[i] = OpenTrace( (PEVENT_TRACE_LOGFILE)LogFile[i]);

        if ( TraceContext->HandleArray[i] == (TRACEHANDLE)INVALID_HANDLE_VALUE) {
            Status =  GetLastError();
            goto cleanup;
        }
    }

    if( TraceContext->Flags & TRACE_DUMP ){
        FILE* f = _wfopen ( TraceContext->DumpFileName, L"w" );
        if( f == NULL) {
            Status = GetLastError();
            goto cleanup;
        }
        if( TraceContext->Flags & TRACE_EXTENDED_FMT ){
            _ftprintf( f,
                    _T("%12s, %10s, %8s,%8s,%8s,%7s,%21s,%11s,%11s, User Data\n"),
                    _T("Event Name"), _T("Type"), 
                    _T("Type"), _T("Level"), _T("Version"), 
                    _T("TID"), _T("Clock-Time"),
                    _T("Kernel(ms)"), _T("User(ms)")
                    );
        }else{
            _ftprintf( f,
                    _T("%12s, %10s,%7s,%21s,%11s,%11s, User Data\n"),
                    _T("Event Name"), _T("Type"), _T("TID"), _T("Clock-Time"),
                    _T("Kernel(ms)"), _T("User(ms)")
                    );
        }
        TraceContext->hDumpFile = f;
    }

    DeclareKernelEvents();

    GetLocalTime (&stLocalTime);
    SystemTimeToFileTime (&stLocalTime, &ftLocalTime);
                            
    StartTime = 
        (((ULONGLONG) ftLocalTime.dwHighDateTime) << 32) + 
        ftLocalTime.dwLowDateTime;

    Status = ProcessTrace(TraceContext->HandleArray,
                 LogFileCount,
                 NULL,
                 NULL);
    
    if( 0 == EndTime ){
        GetLocalTime (&stLocalTime);
        SystemTimeToFileTime (&stLocalTime, &ftLocalTime);
                            
        EndTime = 
            (((ULONGLONG) ftLocalTime.dwHighDateTime) << 32) + 
            ftLocalTime.dwLowDateTime;
    }

    if( bRealTime && (ERROR_WMI_INSTANCE_NOT_FOUND == Status) ){
        Status = ERROR_SUCCESS;
    }

    CurrentSystem.ElapseTime = (ULONG) (  CurrentSystem.EndTime
                                        - CurrentSystem.StartTime);

cleanup:
    for (i=0; i < LogFileCount; i++){
        
        if( (TRACEHANDLE)INVALID_HANDLE_VALUE != TraceContext->HandleArray[i] ){

            CloseTrace(TraceContext->HandleArray[i]);
            TraceContext->HandleArray[i] = (TRACEHANDLE)INVALID_HANDLE_VALUE;
        }
        
        if( NULL != LogFile[i] ){
            free(LogFile[i]);
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracectr\process.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    process.c

Abstract:

    Manipulation routines for cpdata structures.

Author:

    Melur Raghuraman (mraghu) 03-Oct-1997

Environment:

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include "cpdata.h"
#include "tracectr.h"
#include "item.h"

extern PTRACE_CONTEXT_BLOCK TraceContext;
extern PWCHAR CpdiGuidToString(PWCHAR s, LPGUID piid);

VOID
InitDiskRecord(
    PTDISK_RECORD pDisk,
    ULONG DiskNumber
    )
{
    PWCHAR name;
    if (pDisk == NULL){
        return;
    }
    memset(pDisk, 0, sizeof(TDISK_RECORD));
    InitializeListHead(&pDisk->ProcessListHead);
    InitializeListHead(&pDisk->FileListHead);
    pDisk->DiskNumber = DiskNumber;

    name = (PWCHAR)malloc(16 * sizeof(WCHAR));
    if (name != NULL) {
        wsprintfW(name, L"Disk%d", DiskNumber);
    }
    pDisk->DiskName = name;
}

VOID
InitFileRecord(
    PFILE_RECORD pFile
    )
{
    if (pFile == NULL){
        return;
    }
    memset(pFile, 0, sizeof(FILE_RECORD));
    InitializeListHead(&pFile->ProtoProcessListHead);
}

VOID
InitThreadRecord(
    PTHREAD_RECORD pThread
    )
{
    if (pThread == NULL)
        return;
    memset(pThread, 0, sizeof(THREAD_RECORD));
    InitializeListHead( &pThread->DiskListHead );
    InitializeListHead( &pThread->TransListHead );
    InitializeListHead( &pThread->HPFReadListHead );
    InitializeListHead( &pThread->HPFWriteListHead );
}

VOID
InitTransRecord(
    PTRANS_RECORD pTrans
    )
{
    if (pTrans == NULL)
        return;
    memset(pTrans, 0, sizeof(TRANS_RECORD));
    InitializeListHead(&pTrans->SubTransListHead);
}

VOID
InitMofData(
    PMOF_DATA pMofData
    )
{
    if (pMofData == NULL)
        return;
    memset(pMofData, 0, sizeof(MOF_DATA));
    pMofData->MaxKCpu = -1;
    pMofData->MinKCpu = -1;
    pMofData->MaxUCpu = -1;
    pMofData->MinUCpu = -1;
}

VOID
InitProcessRecord(
    PPROCESS_RECORD pProcess
    )
{
    if (pProcess == NULL)
        return;
    memset(pProcess, 0, sizeof(PROCESS_RECORD));
    InitializeListHead( &pProcess->ThreadListHead );
    InitializeListHead( &pProcess->DiskListHead );
    InitializeListHead( &pProcess->FileListHead );
    InitializeListHead( &pProcess->ModuleListHead );
    InitializeListHead( &pProcess->HPFListHead );
}

BOOLEAN AddModuleRecord(PMODULE_RECORD * ppModule,
                        ULONG            lBaseAddress,
                        ULONG            lModuleSize,
                        WCHAR          * strModuleName)
{
    PMODULE_RECORD pModule;

    if ( (ppModule == NULL) || (strModuleName == NULL) ) {
        return FALSE;
    }

    pModule = (PMODULE_RECORD)malloc(sizeof(MODULE_RECORD));

    if(NULL != pModule){
        memset(pModule, 0, sizeof(MODULE_RECORD));

        pModule->strModuleName =
                       malloc(sizeof(WCHAR) * (lstrlenW(strModuleName) + 1));

        if (pModule->strModuleName == NULL)
        {
            free(pModule);
            pModule = NULL;
        }
        else
        {
            wcscpy(pModule->strModuleName, strModuleName);

            pModule->lBaseAddress  = lBaseAddress;
            pModule->lModuleSize   = lModuleSize;
        }
    }

    * ppModule = pModule;

    return (BOOLEAN) (* ppModule != NULL);
}

BOOLEAN AddHPFFileRecord(
    PHPF_FILE_RECORD * ppHPFFileRecord,
    ULONG              RecordID,
    ULONG              IrpFlags,
    ULONG              DiskNumber,
    ULONGLONG          ByteOffset,
    ULONG              BytesCount,
    PVOID              fDO
    )
{
    PHPF_FILE_RECORD pHPFFileRecord = malloc(sizeof(HPF_FILE_RECORD));

    if (pHPFFileRecord)
    {
        pHPFFileRecord->RecordID   = RecordID;
        pHPFFileRecord->IrpFlags   = IrpFlags;
        pHPFFileRecord->DiskNumber = DiskNumber;
        pHPFFileRecord->ByteOffset = ByteOffset;
        pHPFFileRecord->BytesCount = BytesCount;
        pHPFFileRecord->fDO        = fDO;
    }

    * ppHPFFileRecord = pHPFFileRecord;
    return (BOOLEAN) (* ppHPFFileRecord != NULL);
}

BOOLEAN AddHPFRecord(
        PHPF_RECORD * ppHPFRecord,
        ULONG         lFaultAddress,
        PVOID         fDO,
        LONG          ByteCount,
        LONGLONG      ByteOffset
        )
{
    PHPF_RECORD pHPFRecord = malloc(sizeof(HPF_RECORD));

    if (pHPFRecord)
    {
        pHPFRecord->fDO           = fDO;
        pHPFRecord->lFaultAddress = lFaultAddress;
        pHPFRecord->lByteCount    = ByteCount;
        pHPFRecord->lByteOffset   = ByteOffset;
        InitializeListHead(& pHPFRecord->HPFReadListHead);
    }

    * ppHPFRecord = pHPFRecord;
    return (BOOLEAN) (* ppHPFRecord != NULL);
}

void DeleteHPFRecord(
        PHPF_RECORD pHPFRecord
        )
{
    PLIST_ENTRY      pHead;
    PLIST_ENTRY      pNext;
    PHPF_FILE_RECORD pHPFFileRecord;

    if (!pHPFRecord)
        return;

    RemoveEntryList(& pHPFRecord->Entry);
    pHead = & pHPFRecord->HPFReadListHead;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pHPFFileRecord = CONTAINING_RECORD(pNext, HPF_FILE_RECORD, Entry);
        pNext          = pNext->Flink;
        RemoveEntryList(& pHPFFileRecord->Entry);
        free(pHPFFileRecord);
    }
    free(pHPFRecord);
    return;
}

VOID
InitWorkloadRecord(
        PWORKLOAD_RECORD pWorkload
    )
{
    if (pWorkload == NULL)
        return;
    memset(pWorkload, 0, sizeof(WORKLOAD_RECORD));
    InitializeListHead( &pWorkload->DiskListHead );
}

VOID
DeleteWorkloadRecord(
    PWORKLOAD_RECORD pWorkload
    )
{
    if (pWorkload == NULL)
        return;

}

PPROTO_PROCESS_RECORD
AddProtoProcess(
    PFILE_RECORD pFile,
    PPROCESS_RECORD pProcess
    )
{
    PPROTO_PROCESS_RECORD pProto;

    if (pFile == NULL || pProcess == NULL)
        return NULL;

    pProto = malloc(sizeof(PROTO_PROCESS_RECORD));
    if (pProto == NULL) {
        return NULL;
    }
    memset(pProto, 0, sizeof(PROTO_PROCESS_RECORD));

    pProto->ProcessRecord = pProcess;
    InsertHeadList( &pFile->ProtoProcessListHead, &pProto->Entry );
    return pProto;
}

PPROTO_PROCESS_RECORD
FindProtoProcessRecord(
    PFILE_RECORD pFile,
    PPROCESS_RECORD pProcess
    )
{
    PLIST_ENTRY Next, Head;
    PPROTO_PROCESS_RECORD pProto;
    if (pFile == NULL || pProcess == NULL)
        return NULL;

    Head = &pFile->ProtoProcessListHead;
    Next = Head->Flink;
    while (Next  != Head) {
        pProto  = CONTAINING_RECORD(Next, PROTO_PROCESS_RECORD, Entry);
        if (pProcess == pProto->ProcessRecord)
            return pProto;
        Next = Next->Flink;
    }
    return (AddProtoProcess(pFile, pProcess));
}

BOOLEAN
AddProcess(
    ULONG    ProcessId,
    PPROCESS_RECORD *ReturnedProcess
    )
{
    PPROCESS_RECORD Process;
    PMODULE_RECORD  pModule = NULL;

    Process = malloc(sizeof(PROCESS_RECORD));
    if (Process == NULL) {
        return FALSE;
    }

    InitProcessRecord( Process );
    Process->PID = ProcessId;
    if (!AddModuleRecord(& pModule, 0, 0, L"other")) {
        free(Process);
        return FALSE;
    }

    pModule->pProcess = Process;

    EnterTracelibCritSection();
    InsertHeadList( &CurrentSystem.ProcessListHead, &Process->Entry );
    InsertHeadList(& Process->ModuleListHead, & pModule->Entry);
    LeaveTracelibCritSection();
    *ReturnedProcess = Process;

    return TRUE;
}

BOOLEAN
DeleteProcess(
    PPROCESS_RECORD Process
    )
{
    PLIST_ENTRY Next, Head;
    PTHREAD_RECORD Thread;
    PTDISK_RECORD Disk;
    PFILE_RECORD pFile;
    PMODULE_RECORD pModule;
    PHPF_RECORD    pHPFRecord;

    if (Process == NULL)
        return FALSE;

    EnterTracelibCritSection();
    RemoveEntryList( &Process->Entry );
    LeaveTracelibCritSection();

    Head = &Process->ThreadListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Thread = CONTAINING_RECORD( Next, THREAD_RECORD, Entry );
        Next = Next->Flink;
        DeleteThread( Thread );
    }

    Head = &Process->DiskListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Disk = CONTAINING_RECORD( Next, TDISK_RECORD, Entry );
        Next = Next->Flink;
        DeleteDisk( Disk );
    }

    Head = &Process->HPFListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pHPFRecord = CONTAINING_RECORD(Next, HPF_RECORD, Entry);
        Next = Next->Flink;
        DeleteHPFRecord(pHPFRecord);
    }

    Head = &Process->FileListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pFile = CONTAINING_RECORD( Next, FILE_RECORD, Entry );
        Next = Next->Flink;
        RemoveEntryList( &pFile->Entry );
        if (pFile->FileName != NULL)
            free(pFile->FileName);
        free(pFile);
    }

    Head = &Process->ModuleListHead;
    Next = Head->Flink;
    while (Next != Head)
    {
        pModule = CONTAINING_RECORD(Next, MODULE_RECORD, Entry);
        Next    = Next->Flink;
        RemoveEntryList(& pModule->Entry);
        if(pModule->strModuleName)
        {
            free(pModule->strModuleName);
        }
        free(pModule);
    }

    if (Process->ImageName != NULL)
        free(Process->ImageName);
    if (Process->UserName != NULL)
        free(Process->UserName);

    free( Process );
    return TRUE;
}

BOOLEAN
AddThread(
    ULONG                 ThreadId,
    PEVENT_TRACE          pEvent,
    PTHREAD_RECORD      * ResultThread
    )
{
    PTHREAD_RECORD Thread;
    PEVENT_TRACE_HEADER pHeader = (PEVENT_TRACE_HEADER) & pEvent->Header;
    int i;

    Thread = malloc(sizeof(THREAD_RECORD));

    if (Thread == NULL)
    {
        return FALSE;
    }

    InitThreadRecord(Thread);

    Thread->TimeStart   = Thread->TimeEnd
                        = (ULONGLONG) pHeader->TimeStamp.QuadPart;
    Thread->TID         = ThreadId;
    Thread->ProcessorID = pEvent->ClientContext & 0x000000FF;
    i = (int)Thread->TID;
    i = i % THREAD_HASH_TABLESIZE;
    InsertHeadList(&CurrentSystem.ThreadHashList[i], &Thread->Entry);
    *ResultThread     = Thread;

    return TRUE;
}

BOOLEAN
DeleteThread(
    PTHREAD_RECORD Thread
    )
{
    PLIST_ENTRY      pHead;
    PLIST_ENTRY      pNext;
    PHPF_FILE_RECORD pHPFFileRecord;

    if (Thread == NULL)
        return FALSE;
    RemoveEntryList( &Thread->Entry );
    DeleteTransList( &Thread->TransListHead, 0 );

    pHead = & Thread->HPFReadListHead;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pHPFFileRecord = CONTAINING_RECORD(pNext, HPF_FILE_RECORD, Entry);
        pNext          = pNext->Flink;
        RemoveEntryList(& pHPFFileRecord->Entry);
        free(pHPFFileRecord);
    }
    pHead = & Thread->HPFWriteListHead;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pHPFFileRecord = CONTAINING_RECORD(pNext, HPF_FILE_RECORD, Entry);
        pNext          = pNext->Flink;
        RemoveEntryList(& pHPFFileRecord->Entry);
        free(pHPFFileRecord);
    }

    free( Thread );
    return TRUE;
}

PTRANS_RECORD
FindTransByList(
    PLIST_ENTRY Head,
    LPGUID pGuid,
    ULONG  level
    )
{
    PLIST_ENTRY   Next;
    PTRANS_RECORD pTrans = NULL;

    // Recursively look for the list that does
    // not contain a running guid
    //
    if (level <= MAX_TRANS_LEVEL && Head != NULL)
    {
        Next = Head->Flink;
        while (Next != Head)
        {
            pTrans = CONTAINING_RECORD(Next, TRANS_RECORD, Entry);
            if (pTrans->bStarted)
            {
                if (   (level == 0 || level == 1)
                    && IsEqualGUID(pTrans->pGuid, pGuid))
                {
                    return pTrans;
                }
                else if (level > 0)
                {
                    return FindTransByList(& pTrans->SubTransListHead,
                                           pGuid,
                                           level - 1);
                }
            }
            Next = Next->Flink;
        }
    }

    // Found the correct list; now find
    // the matching transaction
    //
    if (level == 0 && Head != NULL)
    {
        Next = Head->Flink;
        while (Next != Head)
        {
            pTrans = CONTAINING_RECORD(Next, TRANS_RECORD, Entry);
            if (IsEqualGUID( pTrans->pGuid, pGuid))
            {
                return pTrans;
            }
            Next = Next->Flink;
        }

        // If not Found, go ahead and add it.
        //
        pTrans = malloc(sizeof(TRANS_RECORD));
        if (pTrans == NULL)
        {
            return NULL;
        }
        InitTransRecord(pTrans);
        pTrans->pGuid = pGuid;
        InsertHeadList( Head, &pTrans->Entry );
    }
    return pTrans;
}

PMOF_DATA
FindMofData(
    PMOF_INFO pMofInfo,
    PWCHAR    strSortKey
    )
{
    PLIST_ENTRY Next;
    PLIST_ENTRY Head;
    PMOF_DATA pMofData = NULL;

    if (pMofInfo == NULL) {
        return NULL;
    }

    Head = &pMofInfo->DataListHead;

    if (Head != NULL)
    {
        Next = Head->Flink;
        while (Next != Head)
        {
            pMofData = CONTAINING_RECORD(Next, MOF_DATA, Entry);
            if (strSortKey == NULL && pMofData->strSortKey == NULL)
            {
                return pMofData;
            }
            else if (   strSortKey != NULL
                     && pMofData->strSortKey != NULL
                     && !wcscmp(pMofData->strSortKey, strSortKey))
            {
                return pMofData;
            }
            Next = Next->Flink;
        }

        // If not Found, go ahead and add it.
        //
        pMofData = (PMOF_DATA)malloc(sizeof(MOF_DATA));
        if (pMofData == NULL)
        {
            return NULL;
        }
        InitMofData(pMofData);
        if (strSortKey != NULL)
        {
            pMofData->strSortKey =
                    (PWCHAR) malloc((lstrlenW(strSortKey) + 1) * sizeof(WCHAR));
            if (pMofData->strSortKey != NULL) {
                wcscpy(pMofData->strSortKey, strSortKey);
            }
        }
        InsertHeadList(Head, &pMofData->Entry);
    }
    return pMofData;
}

BOOLEAN
DeleteTrans(
    PTRANS_RECORD Trans
    )
{
    if (Trans ==  NULL)
        return FALSE;
    RemoveEntryList( &Trans->Entry );

    free( Trans );
    return TRUE;
}

BOOLEAN
DeleteTransList(
    PLIST_ENTRY Head,
    ULONG level
    )
{
    PLIST_ENTRY Next;
    PTRANS_RECORD pTrans;

    if( Head == NULL || level > MAX_TRANS_LEVEL )
        return FALSE;

    Next = Head->Flink;

    while(Next != Head){
        pTrans = CONTAINING_RECORD( Next, TRANS_RECORD, Entry );
        Next = Next->Flink;
        DeleteTransList( &pTrans->SubTransListHead, level+1);
        DeleteTrans( pTrans );
    }

    return TRUE;
}

PPROCESS_RECORD
FindProcessById(
    ULONG    Id,
    BOOLEAN CheckAlive
    )
{
    PLIST_ENTRY Next, Head;
    PPROCESS_RECORD Process=NULL;

    EnterTracelibCritSection();

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Process = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        if (Process->PID == Id) {
            LeaveTracelibCritSection();
            if ((Process->DeadFlag) && (CheckAlive))
                return NULL;
            else
                return Process;
        }

        Next = Next->Flink;
    }
    LeaveTracelibCritSection();
    return NULL;
}

PTHREAD_RECORD
FindGlobalThreadById(
    ULONG               ThreadId,
    PEVENT_TRACE        pEvent
    )
{
    PLIST_ENTRY    Next,
                   Head;
    PTHREAD_RECORD Thread;
    PEVENT_TRACE_HEADER pHeader = (PEVENT_TRACE_HEADER) & pEvent->Header;
    int i = (int)ThreadId;
    i = i % THREAD_HASH_TABLESIZE;

    Head = &CurrentSystem.ThreadHashList[i];
    Next = Head->Flink;
    while (Next != Head)
    {
        Thread = CONTAINING_RECORD(Next, THREAD_RECORD, Entry);
        Next   = Next->Flink;

        if (Thread->TID == ThreadId)
        {
            if (ThreadId == 0)
            {
                ULONG ProcessorId = pEvent->ClientContext & 0x000000FF;
                if (ProcessorId != Thread->ProcessorID)
                {
                    continue;
                }
            }
            if (!Thread->DeadFlag)
            {
                return Thread;
            }
            else if (   Thread->TimeEnd
                     == (ULONGLONG) pHeader->TimeStamp.QuadPart)
            {
                return Thread;
            }
            else
            {
                // The alive thead must be at the head of the list
                // otherwise bail
                //
                return NULL;
            }
        }
    }
    return NULL;
}

PWORKLOAD_RECORD
FindWorkloadById(
    ULONG   Id
    )
{
    PLIST_ENTRY Next, Head;
    PWORKLOAD_RECORD Workload = NULL;

    Head = &CurrentSystem.WorkloadListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Workload = CONTAINING_RECORD( Next, WORKLOAD_RECORD, Entry );
        if (Workload->ClassNumber == Id) {
            return Workload;
        }

        Next = Next->Flink;
    }
    return NULL;
}

BOOLEAN
AddDisk(
    ULONG DiskNumber,
    PTDISK_RECORD *ReturnedDisk
    )
{
    PTDISK_RECORD Disk;

    Disk = malloc(sizeof(TDISK_RECORD));
    if (Disk == NULL) {
        return FALSE;
    }
    InitDiskRecord(Disk, DiskNumber);
    Disk->DiskNumber = DiskNumber;

    InsertHeadList( &CurrentSystem.GlobalDiskListHead, &Disk->Entry );
    *ReturnedDisk = Disk;

    return TRUE;
}


BOOLEAN
DeleteDisk(
    PTDISK_RECORD Disk
    )
{
    PLIST_ENTRY Head, Next;
    PPROCESS_RECORD Process;
    PFILE_RECORD File;
    if (Disk == NULL)
        return FALSE;
    RemoveEntryList( &Disk->Entry );

    if (Disk->DiskName != NULL)
        free(Disk->DiskName);

    Head = &Disk->ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Process = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        Next = Next->Flink;
        DeleteProcess( Process );
    }
    Head = &Disk->FileListHead;
    Next = Head->Flink;
    while (Next != Head) {
        File = CONTAINING_RECORD( Next, FILE_RECORD, Entry );
        Next = Next->Flink;
        DeleteFileRecord( File );
    }

    free( Disk );
    return TRUE;
}

PTDISK_RECORD
FindLocalDiskById(
    PLIST_ENTRY Head,
    ULONG Id
    )
{
    PLIST_ENTRY Next;
    PTDISK_RECORD Disk = NULL;

    if (Head == NULL)
        return NULL;

    Next = Head->Flink;
    while (Next != Head) {
        Disk = CONTAINING_RECORD( Next, TDISK_RECORD, Entry );
        if (Disk->DiskNumber == Id) {
            return Disk;
        }
        Next = Next->Flink;
    }

    // If not Found, go ahead and add it.
    //
    Disk = malloc(sizeof(TDISK_RECORD));
    if (Disk == NULL) {
        return FALSE;
    }
    InitDiskRecord(Disk, Id);

    Disk->DiskNumber = Id;
    InsertHeadList( Head, &Disk->Entry );
    return Disk;
}

PTDISK_RECORD
FindProcessDiskById(
    PPROCESS_RECORD pProcess,
    ULONG Id
    )
{
    PLIST_ENTRY Next, Head;
    PTDISK_RECORD Disk = NULL;

    if (pProcess == NULL)
        return NULL;

    Head = &pProcess->DiskListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Disk = CONTAINING_RECORD( Next, TDISK_RECORD, Entry );
        if (Disk->DiskNumber == Id) {
            return Disk;
        }
        Next = Next->Flink;
    }

    // If not Found, go ahead and add it.
    //
    Disk = malloc(sizeof(TDISK_RECORD));
    if (Disk == NULL) {
        return FALSE;
    }
    InitDiskRecord(Disk, Id);

    Disk->DiskNumber = Id;
    InsertHeadList( &pProcess->DiskListHead, &Disk->Entry );
    return Disk;
}

PPROCESS_RECORD
FindDiskProcessById(
    PTDISK_RECORD pDisk,
    ULONG    Id
    )
{
    PLIST_ENTRY Next, Head;
    PPROCESS_RECORD Process = NULL;
    PPROCESS_RECORD gProcess = NULL;

    if (pDisk == NULL)
        return NULL;

    Head = &pDisk->ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Process = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        if (Process->PID == Id) {
            return Process;
        }
        Next = Next->Flink;
    }

    // If not Found, go ahead and add it.
    //
    Process = malloc(sizeof(PROCESS_RECORD));
    if (Process == NULL) {
        return FALSE;
    }
    InitProcessRecord(Process);

    Process->PID = Id;

    // Find the global Process Record and copy the UserName and Image.
    //
    gProcess = FindProcessById(Id, FALSE);
    if (gProcess != NULL) {
        if ( ! IsEmpty( gProcess->UserName ) ) {
            ASSIGN_STRING( Process->UserName, gProcess->UserName );
            if( NULL == Process->UserName ) {
                free(Process);
                return NULL;
            }
        }
        if (! IsEmpty( gProcess->ImageName ) ) {
            ASSIGN_STRING( Process->ImageName, gProcess->ImageName );
            if (Process->UserName == NULL) {
                free(Process);
                return NULL;
            }
        }
    }
    InsertHeadList( &pDisk->ProcessListHead, &Process->Entry );
    return Process;
}

PTDISK_RECORD
FindGlobalDiskById(
    ULONG Id
    )
{
    PLIST_ENTRY Next, Head;
    PTDISK_RECORD Disk = NULL;

    Head = &CurrentSystem.GlobalDiskListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Disk = CONTAINING_RECORD( Next, TDISK_RECORD, Entry );
        if (Disk->DiskNumber == Id) {
            return Disk;
        }
        Next = Next->Flink;
    }
    return NULL;
}




VOID
DeleteMofVersion(
    PMOF_VERSION pMofVersion,
    FILE* file
    )
{
    PLIST_ENTRY Next, Head;
    PITEM_DESC pMofItem;


    //
    // Traverse through the MOF_VERSION list and
    // delete each one
    //
    if (pMofVersion == NULL)
        return;
    if( NULL != file ){
        fwprintf(  file, L"   %s (Type:%d Level:%d Version:%d)\n", 
                pMofVersion->strType ? pMofVersion->strType : L"Default", 
                pMofVersion->TypeIndex, 
                pMofVersion->Level, 
                pMofVersion->Version 
            );
    }
    Head = &pMofVersion->ItemHeader;
    Next = Head->Flink;
    while (Head  != Next) {
        pMofItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        Next = Next->Flink;
        RemoveEntryList( &pMofItem->Entry );
        if (pMofItem->strDescription != NULL){
            if( NULL != file ){
                fwprintf( file, L"           %s\n", 
                        pMofItem->strDescription 
                    );
            }
            free (pMofItem->strDescription);
        }

        free (pMofItem);
    }
}


VOID
DeleteMofInfo(
    PMOF_INFO pMofInfo,
    FILE* f
    )
{
    PLIST_ENTRY Next, Head;
    PMOF_VERSION pMofVersion;

    //
    // Traverse through the MOF_VERSION list and 
    // delete each one
    //

    if (pMofInfo == NULL){
        return;
    }

    if( NULL != f ){
        WCHAR buffer[MAXSTR];
        fwprintf( f, L"%s\n", 
            pMofInfo->strDescription ? pMofInfo->strDescription : CpdiGuidToString( buffer, &pMofInfo->Guid ) );
    }
    
    Head = &pMofInfo->VersionHeader;
    Next = Head->Flink;
    while (Head  != Next) {
        pMofVersion = CONTAINING_RECORD(Next, MOF_VERSION, Entry);
        Next = Next->Flink;
        RemoveEntryList( &pMofVersion->Entry );

        DeleteMofVersion( pMofVersion, f );
    }

    //
    // Delete any strings allocated for this structure
    //
    if (pMofInfo->strDescription){
        free(pMofInfo->strDescription);
    }

    //
    // Finally delete the object
    //
    free(pMofInfo);
}

VOID
Cleanup()
{
    PTDISK_RECORD Disk;
    PTHREAD_RECORD Thread;
    PPROCESS_RECORD Process;
    PFILE_RECORD FileRec;
    PWORKLOAD_RECORD pWorkload;
    PMODULE_RECORD   pModule;
    PMOF_INFO pMofInfo;
    PJOB_RECORD pJob;

    PLIST_ENTRY Next, Head;
    PLIST_ENTRY EventListHead;
    FILE* f = NULL;

    // Clean up the Global Disk List for now.
    //
    EventListHead = &CurrentSystem.EventListHead;
    Head = EventListHead;
    Next = Head->Flink;

    if( (TraceContext->Flags & TRACE_INTERPRET) && NULL != TraceContext->CompFileName ){
        f = _wfopen( TraceContext->CompFileName, L"w" );
    }

    while (Head  != Next) {
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Next = Next->Flink;
        RemoveEntryList( &pMofInfo->Entry );
        DeleteMofInfo(pMofInfo, f);
    }

    if( NULL != f ){
        fclose( f );
        f = NULL;
    }

    Head = &CurrentSystem.GlobalDiskListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Disk = CONTAINING_RECORD( Next, TDISK_RECORD, Entry );
        Next = Next->Flink;
        DeleteDisk( Disk );
    }

    // Clean up the Global Thread List for now.
    //
    Head = &CurrentSystem.GlobalThreadListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Thread = CONTAINING_RECORD( Next, THREAD_RECORD, Entry );
        Next = Next->Flink;
        DeleteThread( Thread );
    }
    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Process = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        Next = Next->Flink;
        DeleteProcess( Process );
    }
    Head = &CurrentSystem.GlobalModuleListHead;
    Next = Head->Flink;
    while (Next != Head)
    {
        pModule = CONTAINING_RECORD(Next, MODULE_RECORD, Entry);
        Next = Next->Flink;
        RemoveEntryList(& pModule->Entry);
        if(pModule->strModuleName)
        {
            free(pModule->strModuleName);
        }
        free(pModule);
    }

    Head = &CurrentSystem.HotFileListHead;
    Next = Head->Flink;
    while (Next != Head) {
        FileRec = CONTAINING_RECORD( Next, FILE_RECORD, Entry );
        Next = Next->Flink;
        DeleteFileRecord( FileRec );
    }
    // Cleanup workload structures
    //
    Head = &CurrentSystem.WorkloadListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pWorkload = CONTAINING_RECORD( Next, WORKLOAD_RECORD, Entry );
        Next = Next->Flink;
        DeleteWorkloadRecord( pWorkload );
    }
    //
    // Cleanup the Job List structures
    //
    Head = &CurrentSystem.JobListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pJob = CONTAINING_RECORD( Next, JOB_RECORD, Entry );
        Next = Next->Flink;
        DeleteJobRecord (pJob, FALSE);
    }
}

BOOLEAN
AddFile(
    WCHAR* fileName,
    PFILE_RECORD *ReturnedFile
    )
{
    PFILE_RECORD fileRec;

    if (fileName == NULL)
        return FALSE;

    fileRec = malloc(sizeof(FILE_RECORD));
    if (fileRec == NULL) {
        return FALSE;
        }
    InitFileRecord( fileRec );
    fileRec->FileName = malloc( (lstrlenW(fileName)+ 1) * sizeof(WCHAR));
    if (fileRec->FileName != NULL) {
        wcscpy(fileRec->FileName, fileName);
    }
    EnterTracelibCritSection();
    InsertHeadList( &CurrentSystem.HotFileListHead, &fileRec->Entry );
    LeaveTracelibCritSection();
    *ReturnedFile = fileRec;

    return TRUE;
}

BOOLEAN
DeleteFileRecord(
    PFILE_RECORD fileRec
    )
{
    PLIST_ENTRY Next, Head;
    PPROTO_PROCESS_RECORD pProto;

    if (fileRec == NULL)
        return FALSE;

    EnterTracelibCritSection();
    RemoveEntryList( &fileRec->Entry );
    LeaveTracelibCritSection();

    if (fileRec->FileName != NULL)
        free(fileRec->FileName);

    Head = &fileRec->ProtoProcessListHead;
    Next = Head->Flink;
    while (Head != Next) {
        pProto = CONTAINING_RECORD( Next, PROTO_PROCESS_RECORD, Entry);
        Next = Next->Flink;
        RemoveEntryList( &pProto->Entry );
        free(pProto);
    }
    free( fileRec );
    return TRUE;
}

PFILE_RECORD
FindFileRecordByName(
    WCHAR* fileName
    )
{
    PLIST_ENTRY Next, Head;
    PFILE_RECORD fileRec = NULL;
    if (fileName == NULL)
        return NULL;
    EnterTracelibCritSection();
    Head = &CurrentSystem.HotFileListHead;
    Next = Head->Flink;
    while (Next != Head) {
        fileRec = CONTAINING_RECORD( Next, FILE_RECORD, Entry );
        if (!wcscmp(fileName, fileRec->FileName)) {
            LeaveTracelibCritSection();
            return fileRec;
        }
        Next = Next->Flink;
    }
    LeaveTracelibCritSection();
    return NULL;
}

PFILE_RECORD
FindFileInProcess(
    PPROCESS_RECORD pProcess,
    WCHAR* fileName
    )
{
    PLIST_ENTRY Next, Head;
    PFILE_RECORD fileRec = NULL;
    if (pProcess == NULL || fileName == NULL)
        return NULL;
    EnterTracelibCritSection();
    Head = &pProcess->FileListHead;
    Next = Head->Flink;
    while (Next != Head) {
        fileRec = CONTAINING_RECORD( Next, FILE_RECORD, Entry );
        if (!wcscmp(fileName, fileRec->FileName)) {
            //ReleaseMutex(CurrentSystem.HotFileListMutex);
            LeaveTracelibCritSection();
            return fileRec;
        }
        Next = Next->Flink;
    }
    LeaveTracelibCritSection();
    return NULL;
}

VOID
AssignClass(
    PPROCESS_RECORD pProcess,
    PTHREAD_RECORD  pThread
    )
{
    UNREFERENCED_PARAMETER(pProcess);

    pThread->ClassNumber = 1;   // For the Time being make it single class.
}

VOID
Classify()
{
    //  Assign Class to each Thread or Process.
    //
    PLIST_ENTRY Head, Next;
    PTHREAD_RECORD pThread;

    Head = &CurrentSystem.GlobalThreadListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pThread = CONTAINING_RECORD( Next, THREAD_RECORD, Entry );

        AssignClass(NULL, pThread);

        Aggregate(pThread);

        Next = Next->Flink;
    }
}

// Given the number of classes this routine
// creates and initializes the workload object
//
VOID
InitClass()
{
    PWORKLOAD_RECORD pWorkload;
    ULONG nclass;
    ULONG i;

    //  Create the Class records here.
    //
    nclass = 1;
    CurrentSystem.NumberOfWorkloads = 1;
    for (i = 1; i <= nclass; i++) {

        pWorkload = malloc(sizeof(WORKLOAD_RECORD));
        if (pWorkload == NULL) {
            return;
        }
        InitWorkloadRecord( pWorkload );
        pWorkload->ClassNumber = i;
        InsertHeadList( &CurrentSystem.WorkloadListHead, &pWorkload->Entry );
    }
}

PTDISK_RECORD
FindDiskInList(
    IN PLIST_ENTRY Head,
    IN ULONG Id
    )
{
    PLIST_ENTRY Next;
    PTDISK_RECORD pDisk = NULL;

    if (Head != NULL) {

        Next = Head->Flink;

        while (Next != Head) {
            pDisk = CONTAINING_RECORD ( Next, TDISK_RECORD, Entry );
            if (pDisk->DiskNumber == Id) {
                return pDisk;
            }
            Next = Next->Flink;
        }

        pDisk = malloc(sizeof(TDISK_RECORD));
        if (pDisk == NULL) {
            return NULL;
        }
        InitDiskRecord( pDisk, Id );

        InsertHeadList( Head, &pDisk->Entry );
    }
    return pDisk;
}

VOID
Aggregate(
    IN PTHREAD_RECORD pThread
    )
{
    PWORKLOAD_RECORD pWorkload;
    PTDISK_RECORD pDisk, pClassDisk;
    PLIST_ENTRY Next, Head;

    // Aggregate the metrics over each class.
    //
    if ((pWorkload = FindWorkloadById(pThread->ClassNumber)) != NULL) {
        pWorkload->UserCPU += (pThread->UCPUEnd - pThread->UCPUStart)
                            * CurrentSystem.TimerResolution;
        pWorkload->KernelCPU += (pThread->KCPUEnd - pThread->KCPUStart)
                            * CurrentSystem.TimerResolution;
        //
        // Walk through the Thread Disk records and aggregate them
        // to the class

        Head = &pThread->DiskListHead;
        Next = Head->Flink;
        while (Next != Head) {
            pDisk = CONTAINING_RECORD( Next, TDISK_RECORD, Entry );
            Next = Next->Flink;

            pClassDisk = FindDiskInList(&pWorkload->DiskListHead,
                                         pDisk->DiskNumber) ;
            if (pClassDisk != NULL) {
                pClassDisk->ReadCount += pDisk->ReadCount;
                pClassDisk->WriteCount += pDisk->WriteCount;
                pClassDisk->ReadSize += (pDisk->ReadCount * pDisk->ReadSize);
                pClassDisk->WriteSize += (pDisk->WriteCount * pDisk->WriteSize);

                pWorkload->ReadCount += pDisk->ReadCount;
            }
        }
    }
}
ULONGLONG
CalculateProcessLifeTime(
        PPROCESS_RECORD pProcess
    )
{
    BOOLEAN     fFirst    = TRUE;
    ULONGLONG   TimeStart = 0;
    ULONGLONG   TimeEnd   = 0;
    PLIST_ENTRY pHead     = &pProcess->ThreadListHead;
    PLIST_ENTRY pNext     = pHead->Flink;
    PTHREAD_RECORD pThread;

    while (pNext != pHead)
    {
        pThread = CONTAINING_RECORD(pNext, THREAD_RECORD, Entry);
        pNext   = pNext->Flink;

        if (fFirst)
        {
            TimeStart = pThread->TimeStart;
            TimeEnd   = pThread->TimeEnd;
            fFirst    = FALSE;
        }
        else if (pThread->TimeStart < TimeStart)
        {
            TimeStart = pThread->TimeStart;
        }
        else if (pThread->TimeEnd > TimeEnd)
        {
            TimeEnd = pThread->TimeEnd;
        }
    }
    return (TimeEnd - TimeStart);
}

ULONG
CalculateProcessKCPU(
        PPROCESS_RECORD pProcess
    )
{
    ULONG       KCPUTotal = 0;
    ULONG       KCPUMissing = 0;
    PLIST_ENTRY pHead     = &pProcess->ThreadListHead;
    PLIST_ENTRY pNext     = pHead->Flink;
    PTHREAD_RECORD pThread;

    while (pNext != pHead)
    {
        pThread = CONTAINING_RECORD(pNext, THREAD_RECORD, Entry);
        pNext   = pNext->Flink;

        if (pThread->KCPUEnd > pThread->KCPUStart)
        {

            if ((pProcess->PID != 0) || 
                ((pProcess->PID == 0) && (pThread->TID == 0)) ){

                KCPUTotal += pThread->KCPUEnd - pThread->KCPUStart;
            }
            else {
                KCPUMissing += pThread->KCPUEnd - pThread->KCPUStart;
            }
        }
    }
    return (ULONG) (KCPUTotal * CurrentSystem.TimerResolution);
}

ULONG
CalculateProcessUCPU(
        PPROCESS_RECORD pProcess
    )
{
    ULONG       UCPUTotal = 0;
    ULONG       UCPUMissing = 0;
    PLIST_ENTRY pHead     = &pProcess->ThreadListHead;
    PLIST_ENTRY pNext     = pHead->Flink;
    PTHREAD_RECORD pThread;


    while (pNext != pHead)
    {
        pThread = CONTAINING_RECORD(pNext, THREAD_RECORD, Entry);
        pNext   = pNext->Flink;

        if (pThread->UCPUEnd > pThread->UCPUStart)
        {
            if ((pProcess->PID != 0) ||
                ((pProcess->PID == 0) && (pThread->TID == 0)) ) {
                UCPUTotal += pThread->UCPUEnd - pThread->UCPUStart;
            }
            else {
                UCPUMissing += pThread->UCPUEnd - pThread->UCPUStart;
            }
        }
    }
    return (ULONG) (UCPUTotal * CurrentSystem.TimerResolution);
}

PJOB_RECORD FindJobRecord(
    ULONG JobId
    )
{
    PLIST_ENTRY Head, Next;
    PJOB_RECORD pJob;

    EnterTracelibCritSection();
    Head = &CurrentSystem.JobListHead;

    Next = Head->Flink;

    while (Next != Head) {
        pJob = CONTAINING_RECORD ( Next, JOB_RECORD, Entry );
        if (pJob->JobId == JobId) {
            LeaveTracelibCritSection();
            return pJob;
        }
        Next = Next->Flink;
    }
    LeaveTracelibCritSection();

    return NULL;
}


//
// A New Job with a JobId has been found. This routine will create a
// new job record to track it through various threads in the system
//

PJOB_RECORD
AddJobRecord(
    ULONG JobId
    )
{
    PJOB_RECORD pJob;
    pJob = malloc(sizeof(JOB_RECORD));
    if (pJob == NULL) {
        SetLastError( ERROR_OUTOFMEMORY);
        return NULL;
    }

    RtlZeroMemory(pJob, sizeof(JOB_RECORD));
    pJob->JobId = JobId;

    EnterTracelibCritSection();
    InsertHeadList( &CurrentSystem.JobListHead, &pJob->Entry );
    LeaveTracelibCritSection();

    return pJob;
}

//
// Deletes a Job record with the JobId. Before deleting the contents
// of the job record is dumped to a temp file for later reporting.
//

ULONG
DeleteJobRecord(
   PJOB_RECORD pJob, 
    ULONG bSave
    )
{
    if (pJob == NULL)
        return ERROR_INVALID_PARAMETER;

    //
    // Print the Contents of pJob to file.
    //

    // If the -spooler option isn't given to the reducer this fprintf causes the
    // program to crash.  Maybe TRACE_SPOOLER should alway be set.

    if (CurrentSystem.TempFile != NULL) {

        fprintf(CurrentSystem.TempFile, "%d,  %d, %d, %d, %I64u, %I64u, %I64u, %I64u, %d, %d, %d, %d, %d, %hd, %d, %hd, %hd, %hd, %hd, %hd, %hd, %d\n",
             pJob->JobId, pJob->KCPUTime, pJob->UCPUTime, pJob->ReadIO, pJob->StartTime, pJob->EndTime,
             (pJob->ResponseTime - pJob->PauseTime), pJob->PrintJobTime, pJob->WriteIO,
             pJob->DataType, pJob->JobSize, pJob->Pages, pJob->PagesPerSide,
            pJob->FilesOpened, pJob->GdiJobSize, pJob->Color, pJob->XRes, pJob->YRes,
            pJob->Quality, pJob->Copies, pJob->TTOption,
            pJob->NumberOfThreads);
    }

    EnterTracelibCritSection();
    RemoveEntryList( &pJob->Entry );
    LeaveTracelibCritSection();
    free (pJob);
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracectr\report.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    report.c

Abstract:

    Manipulation routines for cpdata structures.

Author:

    Melur Raghuraman (mraghu) 03-Oct-1997

Environment:

Revision History:


--*/
#include <stdlib.h>
#include <stdio.h>
#include "cpdata.h"
#include "tracectr.h"
#include <ntverp.h>
#include "item.h"

#define BREAK_LINE "+-----------------------------------------------------------------------------------------------------------------------------------+\n"

extern PTRACE_CONTEXT_BLOCK TraceContext;
extern ULONG TotalEventsLost;
extern ULONG TotalEventCount;
extern ULONG TimerResolution;
extern ULONGLONG StartTime;
extern ULONGLONG EndTime;
extern __int64 ElapseTime;
extern ULONG TotalBuffersRead;

static FILE* procFile;
static void  PrintDiskTotals();
static void PrintProcessCpuTime();
static void PrintProcessData();
static void PrintPerThreadPerDiskTable();
static void WriteTransactionStatistics();
static void WriteTransactionCPUTime();
static void PrintProcessSubDataInclusive();
static void PrintProcessSubDataExclusive();
void TransInclusive( 
    PLIST_ENTRY TrHead,
    ULONG level
    );

static void ReportPageFaultInfo(PCPD_USER_CONTEXT_MM pUserContext);
static void ReportHardFaultInfo(void);
static void ReportHotFileInfo(ULONG NumEntry);
static void ReportJobInfo(void);
extern GUID PrintJobGuid;
PWCHAR CpdiGuidToString(
    PWCHAR s,
    LPGUID piid
    );

char* Month[] = { "", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
char* Day[] = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };

ULONG ReportFlags = 0;

void CollapseTree(
    PLIST_ENTRY OldTree,
    PLIST_ENTRY NewTree,
    BOOL flat
    )
{
    PLIST_ENTRY OldNext;
    PTRANS_RECORD pTrans;
    PTRANS_RECORD pNewTrans;

    OldNext = OldTree->Flink;

    while (OldNext != OldTree)
    {
        pTrans = CONTAINING_RECORD(OldNext, TRANS_RECORD, Entry);
        OldNext = OldNext->Flink;
        pNewTrans = FindTransByList(NewTree, pTrans->pGuid, 0);
        if( NULL != pNewTrans ){
            pNewTrans->KCpu += pTrans->KCpu;
            pNewTrans->UCpu += pTrans->UCpu;
            pNewTrans->RefCount += pTrans->RefCount;
            pNewTrans->RefCount1 += pTrans->RefCount1;

            if (flat)
            {
                CollapseTree(&pTrans->SubTransListHead, NewTree, TRUE );
            }
            else
            {
                CollapseTree(& pTrans->SubTransListHead,
                             & pNewTrans->SubTransListHead,
                             FALSE);
            }
        }else{
//            fprintf(stderr, "(PDH.DLL) Memory Commit Failure.\n");
        }
    }
}

#define BARLEN          70

char*
TimeWindowBar(
    char* buffer,
    ULONGLONG min,
    ULONGLONG max
    )
{
    double unit;
    ULONGLONG duration;
    int pre, bar, count;

    if(buffer == NULL){
        return NULL;
    }
    duration = ((CurrentSystem.EndTime - CurrentSystem.StartTime) / 10000000);
    unit = (double)BARLEN/(ULONG)duration;
    pre = (int)((ULONG)((min - CurrentSystem.StartTime)/10000000) * unit);
    bar = (int)((ULONG)((max - min)/10000000) * unit);
    strcpy( buffer, "" );
    count = 0;
    while(count++ < pre){ strcat(buffer, " "); }
    strcat( buffer, "|" );
    count = 0;
    while(count++ < bar){ strcat(buffer, "_"); }
    strcat(buffer, "|" );
    return buffer;
}


void 
WriteProc(
    LPWSTR ProcFileName,
    ULONG  flags,
    PVOID  pUserContext
    )
{
    ULONGLONG duration;
    FILETIME  StTm, EndTm, StlTm, EndlTm;
    LARGE_INTEGER LargeTmp;
    SYSTEMTIME tmf;
    PLIST_ENTRY Next, Head;
    PPROCESS_FILE_RECORD pFileRec;
    char buffer[MAXSTR];
    BOOL bResult;

    ReportFlags = flags;

    procFile = _wfopen(ProcFileName, L"w");
    if (procFile == NULL)
        return;

    LargeTmp.QuadPart = CurrentSystem.StartTime;
    StTm.dwHighDateTime = LargeTmp.HighPart;
    StTm.dwLowDateTime = LargeTmp.LowPart;
    FileTimeToLocalFileTime(&StTm, &StlTm);


    bResult = FileTimeToSystemTime (
        &StlTm,
        &tmf
        );

    if( ! bResult || tmf.wMonth > 12 ){
        ZeroMemory( &tmf, sizeof(SYSTEMTIME) );
    }

    fprintf(procFile, 
            BREAK_LINE
            "| Windows Event Trace Session Report              %83s\n"
            "| Version   : %4d                                 %82s\n"
            "| Type      : %-20s                               %68s\n"
            BREAK_LINE
            "|                                                         %75s\n"
            "| Build     :  %-8d                               %79s\n"
            "| Processors:  %-8d                               %79s\n"
            "| Start Time:  %2d %3s %4d    %2d:%02d:%02d.%03d       %-80s   |\n", 
            "|",
            VER_PRODUCTBUILD, "|", 
            ( ReportFlags & TRACE_LOG_REPORT_TOTALS ) ? "Total" : "Default", "|",
            "|",
            CurrentSystem.BuildNumber, "|",
            CurrentSystem.NumberOfProcessors, "|",
            tmf.wDay, 
            Month[tmf.wMonth],
            tmf.wYear, 
            tmf.wHour, tmf.wMinute, tmf.wSecond, tmf.wMilliseconds, 
            "|______________________________________________________________________|"
        );

    LargeTmp.QuadPart = CurrentSystem.EndTime;
    EndTm.dwHighDateTime = LargeTmp.HighPart;
    EndTm.dwLowDateTime = LargeTmp.LowPart;
    FileTimeToLocalFileTime(&EndTm, &EndlTm);

    FileTimeToSystemTime (
        &EndlTm,
        &tmf
        );

    fprintf(procFile, 
            "| End Time  :  %2d %3s %4d    %2d:%02d:%02d.%03d    %87s\n", 
            tmf.wDay,
            Month[tmf.wMonth],
            tmf.wYear, 
            tmf.wHour, tmf.wMinute, tmf.wSecond, tmf.wMilliseconds, "|");

    duration = (CurrentSystem.EndTime - CurrentSystem.StartTime) / 10000000;
    fprintf(procFile, 
            "| Duration  :  %-15I64u sec                             %70s\n"
            "|                                                       %77s\n",
            duration, 
            "|", "|"
        );

    Head = &CurrentSystem.ProcessFileListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pFileRec = CONTAINING_RECORD( Next, PROCESS_FILE_RECORD, Entry );
        Next = Next->Flink;

        fprintf(procFile, 
                "| Trace Name:  %-43ws               %60s\n"
                "| File Name :  %-101ws               %2s\n",
                pFileRec->TraceName ? pFileRec->TraceName : L"-", "|",
                pFileRec->FileName ? pFileRec->FileName : L"-", "|"
            );

        if (pFileRec->StartTime == 0)
            pFileRec->StartTime = CurrentSystem.StartTime;
        if (pFileRec->EndTime == 0)
            pFileRec->EndTime = CurrentSystem.EndTime;

        LargeTmp.QuadPart = pFileRec->StartTime;
        EndTm.dwHighDateTime = LargeTmp.HighPart;
        EndTm.dwLowDateTime = LargeTmp.LowPart;
        FileTimeToLocalFileTime(&EndTm, &EndlTm);
        
        FileTimeToSystemTime (
            &EndlTm,
            &tmf
            );

        fprintf(procFile, 
                "| Start Time:  %2d %3s %4d    %2d:%02d:%02d.%03d       %-80s   |\n", 
                tmf.wDay,
                Month[tmf.wMonth],
                tmf.wYear, 
                tmf.wHour, tmf.wMinute, tmf.wSecond, tmf.wMilliseconds,
                TimeWindowBar(buffer, pFileRec->StartTime, pFileRec->EndTime)
            );
        
        LargeTmp.QuadPart = pFileRec->EndTime;
        EndTm.dwHighDateTime = LargeTmp.HighPart;
        EndTm.dwLowDateTime = LargeTmp.LowPart;
        FileTimeToLocalFileTime(&EndTm, &EndlTm);
        
        FileTimeToSystemTime (
            &EndlTm,
            &tmf
            );
 
        duration = (pFileRec->EndTime - pFileRec->StartTime) / 10000000;
        fprintf(procFile, 
                "| End Time  :  %2d %3s %4d    %2d:%02d:%02d.%03d          %81s\n"
                "| Duration  :  %-15I64u sec                               %68s\n"
                "|                                                         %75s\n",
                tmf.wDay,
                Month[tmf.wMonth],
                tmf.wYear, 
                tmf.wHour, tmf.wMinute, tmf.wSecond, tmf.wMilliseconds, "|",
                duration, 
                "|","|"
            );

    }

    fprintf(procFile, BREAK_LINE "\n\n" ); 

    if (flags & (TRACE_LOG_REPORT_BASIC|TRACE_LOG_REPORT_TOTALS)){
        PMOF_INFO pMofInfo;
        WriteTransactionStatistics();
        WriteTransactionCPUTime();

        pMofInfo = GetMofInfoHead ((LPCGUID)&PrintJobGuid);
        if( pMofInfo != NULL ){
            if (pMofInfo->EventCount > 0) {
                ReportJobInfo();
           }
        }

        // PrintProcessData() must be run before others to set the process
        // time from the added thread times
        PrintProcessData(); 

        PrintProcessSubDataExclusive();
        PrintProcessSubDataInclusive();

//        PrintProcessCpuTime();
        PrintDiskTotals();
        PrintPerThreadPerDiskTable();
    }
    if (flags & TRACE_LOG_REPORT_MEMORY)    {
        ReportPageFaultInfo((PCPD_USER_CONTEXT_MM) pUserContext);
    }
    if (flags & TRACE_LOG_REPORT_HARDFAULT ){
//        ReportHardFaultInfo();
    }
    if (flags & TRACE_LOG_REPORT_FILE)
    {
//        ReportHotFileInfo(PtrToUlong(pUserContext));
    }

    fclose(procFile);
}

static void 
PrintDiskTotals()
{
    // Print the Disk Table. 

    PTDISK_RECORD pDisk;
    PLIST_ENTRY Next, Head;
    ULONG rio, wio;

    Head = &CurrentSystem.GlobalDiskListHead;
    Next = Head->Flink;
    if( Next == Head ){
        return; 
    }

    fprintf(procFile, 
           BREAK_LINE
           "| Disk Totals     %115s\n" 
           BREAK_LINE
           "| Disk Name        Reads          Kb           Writes             Kb   %62s\n"
           BREAK_LINE, "|", "|" );

    Head = &CurrentSystem.GlobalDiskListHead;
    Next = Head->Flink;
    
    while (Next != Head) {
        pDisk = CONTAINING_RECORD( Next, TDISK_RECORD, Entry );
        rio = pDisk->ReadCount + pDisk->HPF;
        wio = pDisk->WriteCount;

        fprintf(procFile, 
               "| %6d         %6d       %6d          %6d          %6d    %61s\n", 
                pDisk->DiskNumber,
                rio,
                (rio == 0) ? 0 : (pDisk->ReadSize + pDisk->HPFSize) / rio,
                wio,
                (wio == 0) ? 0 : pDisk->WriteSize / wio,
                "|"
            );
        Next = Next->Flink;
   }
   fprintf(procFile,  BREAK_LINE "\n\n" );

}

void TotalTransChildren( 
    PLIST_ENTRY Head,
    ULONG *Kernel,
    ULONG *User,
    LONG level )
{
    PTRANS_RECORD pTrans;
    PLIST_ENTRY Next;
    
    Next = Head->Flink;
    while( Next != Head ){
        pTrans = CONTAINING_RECORD( Next, TRANS_RECORD, Entry );
        Next = Next->Flink;
        TotalTransChildren( &pTrans->SubTransListHead, Kernel, User, level+1 );
        *Kernel += pTrans->KCpu;
        *User += pTrans->UCpu;
    }
}

void PrintTransList( PLIST_ENTRY TrHead, LONG level )
{
    PTRANS_RECORD pTrans;
    PMOF_INFO pMofInfo;
    ULONG Kernel;
    ULONG User;
    WCHAR str[1024];
    WCHAR buffer[MAXSTR];
    PLIST_ENTRY TrNext = TrHead->Flink;
    
    while( TrNext != TrHead ){
        int count = 0;
        pTrans = CONTAINING_RECORD( TrNext, TRANS_RECORD, Entry );
        TrNext = TrNext->Flink;
        Kernel = pTrans->KCpu;
        User = pTrans->UCpu;
        pMofInfo = GetMofInfoHead( pTrans->pGuid);
        if (pMofInfo == NULL) {
            return;
        }
        wcscpy(buffer,L"");
        while( (count++ < level) && (lstrlenW(buffer) < MAXSTR)){
            wcscat(buffer, L"  ");
        }
        wcscat( buffer, 
                ( pMofInfo->strDescription ? 
                  pMofInfo->strDescription : 
                  CpdiGuidToString( str, &pMofInfo->Guid ) ));
        TotalTransChildren( &pTrans->SubTransListHead, &Kernel, &User, 0 );
        fprintf( procFile, 
                 "|       %-17S  %6d  %7d  %7d  %5s  %5s  %5s   %5s  %5s     %5s  %5s     %5s     %6s  %6s\n",
                 buffer,
                 pTrans->RefCount,
                 Kernel,
                 User,
                 "-",
                 "-",
                 "-",
                 "-",
                 "-",
                 "-",
                 "-",
                 "-",
                 "-", "|"
            );
        if( level <= MAX_TRANS_LEVEL ){
            PrintTransList( &pTrans->SubTransListHead, level+1 );
        }
    }
}

static void PrintProcessCpuTime()
{
    PTHREAD_RECORD  pThread;
    PPROCESS_RECORD pProcess; 
    ULONGLONG     lLifeTime;
    ULONG TotalUserTime = 0;
    ULONG TotalKernelTime = 0;
    ULONG TotalCPUTime = 0;
    PLIST_ENTRY Next, Head;
    PLIST_ENTRY ThNext, ThHead;
    BOOL titled;
    ULONG usedThreadCount;
    ULONG ThreadCount;
    ULONG ProcessUTime;
    ULONG ProcessKTime;
    ULONG ThreadKCPU;
    ULONG ThreadUCPU;

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    if( Head == Next ){
        return;
    }

    // Walk through the Process List and Print the report. 
    fprintf(procFile, 
            BREAK_LINE
            "| Process/Thread CPU Time Statistics    %93s\n"
            BREAK_LINE
            "| Image Name        ID        Trans   Inclusive CPU(ms)        Disk Total                     Tcp Total             Duration        |\n"
            "|                                       Kernel  User   Reads  Kb/Op  Writes  Kb/Op  Send     Kb/Op   Recv   Kb/Op                   |\n"
            BREAK_LINE, "|"
        );

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
    
        lLifeTime = CalculateProcessLifeTime(pProcess);

        fprintf(procFile, 
                "| %-15ws  0x%04X  %6s  %7d  %7d  %5d  %5.2f  %5d   %5.2f  %5d  %8.2f  %5d  %8.2f     %6I64u  %6s\n",
                (pProcess->ImageName) ? pProcess->ImageName : L"Idle",
                pProcess->PID,
                "-",
                CalculateProcessKCPU(pProcess),
                CalculateProcessUCPU(pProcess),
                pProcess->ReadIO + pProcess->HPF,
                (pProcess->ReadIO + pProcess->HPF) ?
                (double)(pProcess->ReadIOSize + pProcess->HPFSize)/
                (double)(pProcess->ReadIO + pProcess->HPF) : 0,
                pProcess->WriteIO,
                pProcess->WriteIO ? (double)pProcess->WriteIOSize/(double)pProcess->WriteIO : 0,
                pProcess->SendCount,
                pProcess->SendCount ? 
                (double)(pProcess->SendSize / 1024)/(double)pProcess->SendCount : 0,
                pProcess->RecvCount,
                pProcess->RecvCount ?
                (double)(pProcess->RecvSize / 1024) / (double)pProcess->RecvCount : 0,
                (lLifeTime / 10000000 ), "|"
            );

        ThHead = &pProcess->ThreadListHead; 
        ThNext = ThHead->Flink;
        titled = FALSE;
        usedThreadCount = 0;
        ThreadCount = 0;
        ProcessUTime = 0;
        ProcessKTime = 0;
        while (ThNext != ThHead) {
            pThread = CONTAINING_RECORD( ThNext, THREAD_RECORD, Entry );
            ThreadKCPU = (pThread->KCPUEnd - pThread->KCPUStart)
                       * CurrentSystem.TimerResolution;
            ThreadUCPU = (pThread->UCPUEnd - pThread->UCPUStart)
                       * CurrentSystem.TimerResolution;
            if(   pThread->ReadIO
               || pThread->WriteIO
               || ThreadKCPU
               || ThreadUCPU
               || pThread->SendCount
               || pThread->RecvCount
               || pThread->HPF ){
                fprintf(procFile, 
                        "|     0x%04I64X  %13s %5s  %7d  %7d  %5d  %5.2f  %5d   %5.2f  %5d  %8.2f  %5d  %8.2f     %6I64u  %6s\n",
                        pThread->TID,
                        " ",
                        "-",
                        ThreadKCPU,
                        ThreadUCPU,
                        pThread->ReadIO + pThread->HPF,
                        pThread->ReadIO + pThread->HPF ? 
                        (double)(pThread->ReadIOSize + pThread->HPFSize)/
                        (double)(pThread->ReadIO + pThread->HPF) : 0,
                        pThread->WriteIO,
                        pThread->WriteIO ? (double)pThread->WriteIOSize/
                        (double)pThread->WriteIO : 0,
                        pThread->SendCount,
                        pThread->SendCount ?
                        (double)(pThread->SendSize / 1024)/(double)pThread->SendCount : 0,
                        pThread->RecvCount,
                        pThread->RecvCount ?
                        (double)(pThread->RecvSize / 1024)/(double)pThread->RecvCount : 0,
                        ((pThread->TimeEnd - pThread->TimeStart) / 10000000), "|"
                    );
            }

            PrintTransList( &pThread->TransListHead, 0 );
            TotalUserTime += ThreadUCPU;
            TotalKernelTime += ThreadKCPU;
            TotalCPUTime += ThreadKCPU + ThreadUCPU;
            ThNext = ThNext->Flink;
        }

        Next = Next->Flink;
    }
    fprintf(procFile, BREAK_LINE "\n\n" );

}

static void PrintProcessData()
{
    PTHREAD_RECORD  pThread;
    PPROCESS_RECORD pProcess; 
    PTRANS_RECORD pTrans;

    PLIST_ENTRY Next, Head;
    PLIST_ENTRY ThNext, ThHead;
    PLIST_ENTRY TrNext, TrHead;
   
    ULONG usedThreadCount;
    ULONG ThreadCount;
    ULONG TotalusedThreadCount = 0;
    ULONG TotalThreadCount = 0;

    ULONG ThreadUTime;
    ULONG ThreadKTime;
    ULONG ThreadUTimeTrans;
    ULONG ThreadKTimeTrans;
    ULONG ThreadUTimeNoTrans;
    ULONG ThreadKTimeNoTrans;

    ULONG  CountThreadNoTrans;
    ULONG  TotalKCPUThreadNoTrans;
    ULONG  TotalUCPUThreadNoTrans;
    double PercentThreadNoTrans;

    ULONG  CountThreadTrans;
    ULONG  TotalKCPUThreadTrans;
    ULONG  TotalUCPUThreadTrans;
    double PercentThreadTrans;

    ULONG TransUTime;
    ULONG TransKTime;
    ULONG Processors;

    ULONG TotalKThread = 0;
    ULONG TotalUThread = 0;

    ULONG TotalKTrans = 0;
    ULONG TotalUTrans = 0;
    
    double PerTotal = 0.0;
    double IdlePercent = 0.0;
    double percent;
    double percentTrans;
    double lDuration;

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    if( Head == Next ){
        return;
    }

    Processors = CurrentSystem.NumberOfProcessors ? CurrentSystem.NumberOfProcessors : 1;
    lDuration = ((double)((LONGLONG)(CurrentSystem.EndTime - CurrentSystem.StartTime)))
              / 10000000.00;

    // Walk through the Process List and Print the report. 
    fprintf(procFile, 
            BREAK_LINE
            "| Image Statistics    %111s\n"
            BREAK_LINE
            "| Image Name          PID       Threads    Threads        Process             Transaction                CPU%%  %22s\n"
            "|                               Launched    Used     KCPU(ms)  UCPU(ms)    KCPU(ms)   UCPU(ms)           %28s\n"
            BREAK_LINE,
            "|",
            "|",
            "|"
        );


    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );

        ThHead = &pProcess->ThreadListHead; 
        ThNext = ThHead->Flink;

        usedThreadCount = 0;
        ThreadCount = 0;
        ThreadUTime = 0;
        ThreadKTime = 0;
        ThreadUTimeTrans = 0;
        ThreadKTimeTrans = 0;
        ThreadUTimeNoTrans = 0;
        ThreadKTimeNoTrans = 0;
        TransKTime = 0;
        TransUTime = 0;
        percent = 0;

        CountThreadNoTrans = 0;
        TotalKCPUThreadNoTrans = 0;
        TotalUCPUThreadNoTrans = 0;

        CountThreadTrans = 0;
        TotalKCPUThreadTrans = 0;
        TotalUCPUThreadTrans = 0;

        while (ThNext != ThHead) {
            LIST_ENTRY NewTransList;

            pThread = CONTAINING_RECORD( ThNext, THREAD_RECORD, Entry );
            if(   pThread->ReadIO
               || pThread->WriteIO
               || pThread->KCPUEnd > pThread->KCPUStart
               || pThread->UCPUEnd > pThread->UCPUStart
               || pThread->SendCount
               || pThread->RecvCount
               || pThread->HPF )
            {
                usedThreadCount++;
                TotalusedThreadCount++;
            }
            ThreadCount++;
            TotalThreadCount++;

            ThreadUTime += (pThread->UCPUEnd - pThread->UCPUStart)
                         * CurrentSystem.TimerResolution;
            ThreadKTime += (pThread->KCPUEnd - pThread->KCPUStart)
                         * CurrentSystem.TimerResolution;
            ThreadKTimeTrans += pThread->KCPU_Trans
                                * CurrentSystem.TimerResolution;
            ThreadUTimeTrans += pThread->UCPU_Trans
                                * CurrentSystem.TimerResolution;
            ThreadKTimeNoTrans += pThread->KCPU_NoTrans
                                * CurrentSystem.TimerResolution;
            ThreadUTimeNoTrans += pThread->UCPU_NoTrans
                                * CurrentSystem.TimerResolution;

            if (pThread->KCPU_Trans + pThread->UCPU_Trans == 0)
            {
                CountThreadNoTrans ++;
                TotalKCPUThreadNoTrans += pThread->KCPU_NoTrans
                                        * CurrentSystem.TimerResolution;
                TotalUCPUThreadNoTrans += pThread->UCPU_NoTrans
                                        * CurrentSystem.TimerResolution;
            }
            else
            {
                CountThreadTrans ++;
                TotalKCPUThreadTrans += (  pThread->KCPU_Trans
                                         + pThread->KCPU_NoTrans)
                                      * CurrentSystem.TimerResolution;
                TotalUCPUThreadTrans += (  pThread->UCPU_Trans
                                         + pThread->UCPU_NoTrans)
                                      * CurrentSystem.TimerResolution;
            }

            InitializeListHead(& NewTransList);
            CollapseTree(& pThread->TransListHead, & NewTransList, TRUE);
            TrHead = & NewTransList;
            TrNext = TrHead->Flink;
            while( TrNext != TrHead ){
                pTrans = CONTAINING_RECORD( TrNext, TRANS_RECORD, Entry );
                TransUTime += pTrans->UCpu;
                TransKTime += pTrans->KCpu;
                TrNext = TrNext->Flink;
            }
            DeleteTransList(& NewTransList, 0);

            ThNext = ThNext->Flink;
        }

        TotalKThread += ThreadKTime;
        TotalUThread += ThreadUTime;
        
        TotalKTrans += TransKTime;
        TotalUTrans += TransUTime;
        percent = (((ThreadKTime + ThreadUTime + 0.0)/lDuration)/1000.0) * 100.0;

        if (ThreadKTime + ThreadUTime == 0)
        {
            percentTrans = 0.0;
            PercentThreadTrans = 0.0;
            PercentThreadNoTrans = 0.0;
        }
        else
        {
            percentTrans = (  (ThreadKTimeTrans + ThreadUTimeTrans + 0.0)
                            / (ThreadKTime + ThreadUTime + 0.0))
                         * 100.00;
            PercentThreadTrans = ((TotalKCPUThreadTrans + TotalUCPUThreadTrans + 0.0)
                               / (ThreadKTime + ThreadUTime + 0.0)) * 100.00;
            PercentThreadNoTrans = ((TotalKCPUThreadNoTrans + TotalUCPUThreadNoTrans + 0.0)
                               / (ThreadKTime + ThreadUTime + 0.0)) * 100.00;
        }
        PerTotal += percent;
        fprintf(procFile, 
                "| %-15ws  0x%08X    %7d  %7d  %9d  %9d  %9d  %9d         %7.2f  %22s\n",
                (pProcess->ImageName) ? pProcess->ImageName : L"Idle",
                pProcess->PID,
                ThreadCount,
                usedThreadCount,
                ThreadKTime,
                ThreadUTime,
                ThreadKTimeTrans,
                ThreadUTimeTrans,
                (percent / Processors),
                /*percentTrans,*/
                "|"
            );
#if 0
        fprintf(procFile,
                "|                    %6d(%10d,%10d)%7.2f%%          %6d(%10d,%10d)%7.2f%%                           |\n",
                CountThreadTrans,
                TotalKCPUThreadTrans,
                TotalUCPUThreadTrans,
                PercentThreadTrans,
                CountThreadNoTrans,
                TotalKCPUThreadNoTrans,
                TotalUCPUThreadNoTrans,
                PercentThreadNoTrans);
#endif
        if(pProcess->PID == 0){
            IdlePercent += (percent / Processors );
        }
        Next = Next->Flink;
    }

    fprintf(procFile, 
            BREAK_LINE
            "| %-15s    %8s    %7d  %7d  %9d  %9d  %9d  %9d   Total:%7.2f%%                      |\n",
            " ",
            " ",
            TotalThreadCount,
            TotalusedThreadCount,
            TotalKThread,
            TotalUThread,
            TotalKTrans,
            TotalUTrans,
            (PerTotal/Processors)
        );
    fprintf(procFile,   BREAK_LINE "\n\n" );            
            
}

void TransInclusive( 
    PLIST_ENTRY TrHead,
    ULONG level
    )
{
    ULONG Kernel, User;
    PLIST_ENTRY TrNext = TrHead->Flink;
    PMOF_INFO pMofInfo;
    PTRANS_RECORD pTrans;
    WCHAR buffer[MAXSTR];
    WCHAR str[MAXSTR];

    while( TrNext != TrHead ){
        ULONG count = 0;
        pTrans = CONTAINING_RECORD( TrNext, TRANS_RECORD, Entry );
        TrNext = TrNext->Flink;
        pMofInfo = GetMofInfoHead( pTrans->pGuid);
        if (pMofInfo == NULL) {
            return;
        }
        Kernel = pTrans->KCpu;
        User = pTrans->UCpu;
        TotalTransChildren( &pTrans->SubTransListHead, &Kernel, &User, 0 );
        wcscpy(buffer,L"");
        while( (count++ < level) && (lstrlenW(buffer) < MAXSTR)){
            wcscat(buffer, L"  ");
        }
        wcscat( buffer, 
                ( pMofInfo->strDescription ? 
                  pMofInfo->strDescription : 
                  CpdiGuidToString( str, &pMofInfo->Guid ) ));

        fprintf(procFile, 
                "|       %-30ws      %5d    %8d    %8d   %57s\n",
                buffer,
                pTrans->RefCount,
                Kernel,
                User,
                "|"
            );
        TransInclusive( &pTrans->SubTransListHead, level+1 );
    }
}

static void PrintProcessSubDataInclusive()
{
    PPROCESS_RECORD pProcess; 
    PTHREAD_RECORD pThread;
    PLIST_ENTRY Next, Head;
    PLIST_ENTRY TrNext;
    PLIST_ENTRY ThNext, ThHead;
    LIST_ENTRY NewHead;
    BOOL bTable = FALSE;

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head && !bTable ) {
        pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        Next = Next->Flink;
        if( pProcess->PID == 0 ){
           continue;
        }

        // Total up all the threads into one list
        InitializeListHead( &NewHead );
        ThHead = &pProcess->ThreadListHead;
        ThNext = ThHead->Flink;
        while( ThNext != ThHead ){
            pThread = CONTAINING_RECORD( ThNext, THREAD_RECORD, Entry );
            ThNext = ThNext->Flink;
            CollapseTree(&pThread->TransListHead, &NewHead, FALSE );
        }

        TrNext = NewHead.Flink;

        if( TrNext != &NewHead ){
            bTable = TRUE;
        }
        DeleteTransList( &NewHead, 0 );
    }
    if( !bTable ){
        return;
    }

    // Walk through the Process List and Print the report. 
    fprintf(procFile, 
            BREAK_LINE
            "| Inclusive Transactions Per Process %96s\n"
            BREAK_LINE
            "|                                                            Inclusive                        %39s\n" 
            "| Name                            PID       Count      KCPU(ms)      UCPU(ms)     %51s\n"
            BREAK_LINE, 
            "|",
            "|",
            "|"
        );

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        Next = Next->Flink;
        if( pProcess->PID == 0 ){
           continue;
        }

        // Total up all the threads into one list
        InitializeListHead( &NewHead );
        ThHead = &pProcess->ThreadListHead;
        ThNext = ThHead->Flink;
        while( ThNext != ThHead ){
            pThread = CONTAINING_RECORD( ThNext, THREAD_RECORD, Entry );
            ThNext = ThNext->Flink;
            CollapseTree(&pThread->TransListHead, &NewHead, FALSE );
        }

        TrNext = NewHead.Flink;

        if( TrNext != &NewHead ){
            fprintf(procFile, 
                    "| %-30ws  0x%04X   %90s\n",
                    (pProcess->ImageName) ? pProcess->ImageName : L"Idle",
                    pProcess->PID,
                    "|"
                );
            TransInclusive( &NewHead, 0 );
        }
        DeleteTransList( &NewHead, 0 );
    }
    fprintf(procFile, BREAK_LINE "\n\n" );
}

static void PrintProcessSubDataExclusive()
{
    PPROCESS_RECORD pProcess; 
    PTRANS_RECORD pTrans;
    PTHREAD_RECORD pThread;
    PLIST_ENTRY ThNext, ThHead;
    PMOF_INFO pMofInfo;
    PLIST_ENTRY Next, Head;
    PLIST_ENTRY TrNext;
    LIST_ENTRY NewHead;
    double percent, percentCPU, totalPerCPU;
    double processPart;
    double transPart;
    double totalPercent;
    double trans, KCPU, UCPU;
    WCHAR str[1024];
    double duration = ((double)((LONGLONG)(CurrentSystem.EndTime - CurrentSystem.StartTime))) / 10000000.00;
    BOOL bTable = FALSE;

    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head && !bTable ) {
        pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        Next = Next->Flink;
        if( pProcess->PID == 0 ){
           continue;
        }
        InitializeListHead( &NewHead );
        ThHead = &pProcess->ThreadListHead;
        ThNext = ThHead->Flink;
        while( ThNext != ThHead ){
            pThread = CONTAINING_RECORD( ThNext, THREAD_RECORD, Entry );
            ThNext = ThNext->Flink;
            CollapseTree(&pThread->TransListHead, &NewHead, TRUE );
        }

        TrNext = NewHead.Flink;
        if( TrNext != &NewHead ){
            bTable = TRUE;
        }
        DeleteTransList( &NewHead, 0 );        
    }

    if( !bTable ){
        return;
    }

    // Walk through the Process List and Print the report. 
    if( ReportFlags & TRACE_LOG_REPORT_TOTALS ){
        fprintf(procFile, 
                BREAK_LINE
                "| Exclusive Transactions Per Process %96s\n"
                BREAK_LINE
                "|                                                      Exclusive               %54s\n" 
                "| Name             PID                      Trans   Trans/sec    KCPU(ms)      UCPU(ms)   Process CPU%%      CPU%%  %20s\n"
                BREAK_LINE, 
                "|",
                "|",
                "|"
        );
    }else{
        fprintf(procFile, 
                BREAK_LINE
                "| Exclusive Transactions Per Process %96s\n"
                BREAK_LINE  
                "|                                                   Exclusive/Trans            %54s\n" 
                "| Name             PID                      Trans   Trans/sec    KCPU(ms)      UCPU(ms)   Process CPU%%     CPU%%  %20s\n"
                BREAK_LINE, 
                "|",
                "|",
                "|"
        );
    }


    Head = &CurrentSystem.ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        BOOL titled = FALSE;
        pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
        Next = Next->Flink;
        if( pProcess->PID == 0 ){
           continue;
        }
        InitializeListHead( &NewHead );
        ThHead = &pProcess->ThreadListHead;
        ThNext = ThHead->Flink;
        while( ThNext != ThHead ){
            pThread = CONTAINING_RECORD( ThNext, THREAD_RECORD, Entry );
            ThNext = ThNext->Flink;
            CollapseTree(&pThread->TransListHead, &NewHead, TRUE );
        }

        TrNext = NewHead.Flink;
        totalPercent = 0.0;
        totalPerCPU = 0.0;
        while( TrNext != &NewHead ){
            if(!titled){
                fprintf(procFile, 
                        "| %-15ws  0x%04X   %105s\n",
                        (pProcess->ImageName) ? pProcess->ImageName : L"Idle",
                        pProcess->PID,
                        "|"
                    );
                titled = TRUE;
            }
            pTrans = CONTAINING_RECORD( TrNext, TRANS_RECORD, Entry );
            TrNext = TrNext->Flink;
            pMofInfo = GetMofInfoHead( pTrans->pGuid);
            if (pMofInfo == NULL) {
                return;
            }
            transPart = pTrans->UCpu + pTrans->KCpu;
            processPart = CalculateProcessKCPU(pProcess)
                        + CalculateProcessUCPU(pProcess);
            percentCPU = ((((double)pTrans->KCpu + (double)pTrans->UCpu ) / 10.0 ) / duration) / ((double) CurrentSystem.NumberOfProcessors);
            totalPerCPU += percentCPU;
            if(processPart)
                percent = (transPart/processPart) * 100.0;
            else
                percent = 0;
            totalPercent += percent;
            if (!(ReportFlags & TRACE_LOG_REPORT_TOTALS) ){
                if (pTrans->RefCount == 0 && pTrans->RefCount1 == 0)
                    KCPU = UCPU = 0.0;
                else if (pTrans->RefCount == 0) {
                    KCPU = (double) pTrans->KCpu;
                    UCPU = (double) pTrans->UCpu;
                }
                else {
                    KCPU = (double) pTrans->KCpu / (double) pTrans->RefCount;
                    UCPU = (double) pTrans->UCpu / (double) pTrans->RefCount;
                }
            }
            else{
                KCPU = (double)pTrans->KCpu;
                UCPU = (double)pTrans->UCpu;
            }

            trans = (double)pTrans->RefCount / duration;
            fprintf(procFile, 
                    "|       %-30ws      %5d   %7.2f    %8.0f    %8.0f      %7.2f         %7.2f  %19s\n",
                    (pMofInfo->strDescription != NULL) ? pMofInfo->strDescription : CpdiGuidToString( str, &pMofInfo->Guid ),
                    pTrans->RefCount,
                    trans,
                    KCPU,
                    UCPU,
                    percent, 
                    percentCPU,
                    "|"
                );
        }
        if( titled ){
            fprintf( procFile, 
                     "| %84s   -------          ------ %20s\n"
                     "| %84s  %7.2f%%        %7.2f%%  %19s\n",
                     " ", "|",
                     " ",
                     totalPercent,
                     totalPerCPU,
                     "|"
                );
        }
        DeleteTransList( &NewHead, 0 );
        
    }
    fprintf(procFile, BREAK_LINE "\n\n" );
}


static void PrintPerThreadPerDiskTable( )
{
    PPROCESS_RECORD pProcess; 
    PTDISK_RECORD pDisk;
    PLIST_ENTRY Next, Head;
    PLIST_ENTRY GNext, GHead;
    PLIST_ENTRY DiNext, DiHead;
    ULONG rio, wio, DiskNumber;
    BOOL bTable = FALSE;

    // Walk through the Process List and Print the report. 
    GHead = &CurrentSystem.GlobalDiskListHead;
    GNext = GHead->Flink;
    while (GNext != GHead && !bTable) {

        pDisk = CONTAINING_RECORD( GNext, TDISK_RECORD, Entry);
        DiskNumber =  pDisk->DiskNumber;

        Head = &CurrentSystem.ProcessListHead;
        Next = Head->Flink;
        while (Next != Head) {
            pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );
            DiHead = &pProcess->DiskListHead;
            DiNext = DiHead->Flink;
            while (DiNext != DiHead && !bTable) {
                pDisk = CONTAINING_RECORD( DiNext, TDISK_RECORD, Entry );

                if (DiskNumber != pDisk->DiskNumber) {
                    DiNext =  DiNext->Flink;
                    continue;
                }else{
                    bTable = TRUE;
                    break;
                }

            }
        
            Next = Next->Flink;
        
        }
        GNext = GNext->Flink;
    }

    if( !bTable ){
        return;
    }

    GHead = &CurrentSystem.GlobalDiskListHead;
    GNext = GHead->Flink;
    while (GNext != GHead) {

        pDisk = CONTAINING_RECORD( GNext, TDISK_RECORD, Entry);
        DiskNumber =  pDisk->DiskNumber;
        fprintf(procFile,
                BREAK_LINE
                "| Disk %3d       %116s\n"
                BREAK_LINE
                "| Authority                PID    Image Name         Read      Kb  Write     Kb     %50s\n"
                "|                                                    Count         Count            %50s\n"
                BREAK_LINE,
                DiskNumber, "|", "|", "|"
            );


        Head = &CurrentSystem.ProcessListHead;
        Next = Head->Flink;
        while (Next != Head) {
            pProcess = CONTAINING_RECORD( Next, PROCESS_RECORD, Entry );


            DiHead = &pProcess->DiskListHead;
            DiNext = DiHead->Flink;
            while (DiNext != DiHead) {
                pDisk = CONTAINING_RECORD( DiNext, TDISK_RECORD, Entry );

                if (DiskNumber != pDisk->DiskNumber) {
                    DiNext =  DiNext->Flink;
                    continue;
                }
                rio = pDisk->ReadCount + pDisk->HPF;
                wio = pDisk->WriteCount;
                fprintf(procFile, 
                        "| %-22ws   0x%04X   %-16ws",
                        (pProcess->UserName) ? pProcess->UserName : L"-",
                        pProcess->PID,
                        pProcess->ImageName ? pProcess->ImageName : L"-"
                    );
                
                fprintf(procFile,
                   "%6d %6d %6d %6d  %52s\n",
                    rio,
                    (rio == 0) ? 0 : (pDisk->ReadSize + pDisk->HPFSize) / rio,
                    wio,
                    (wio == 0) ? 0 : pDisk->WriteSize / wio, "|");
                DiNext = DiNext->Flink;
            }
        
            Next = Next->Flink;
        
        }
        fprintf(procFile, BREAK_LINE "\n\n" );
        GNext = GNext->Flink;
    }
}

static void WriteTransactionStatistics()
{
    PLIST_ENTRY Head, Next;
    PLIST_ENTRY Dhead, DNext;
    ULONG trans;
    double KCPU, UCPU, PerCpu;
    double RIO, WIO, Send, Recv;
    PMOF_INFO pMofInfo;
    PMOF_DATA pMofData;
    double AvgRT;
    double TransRate;
    WCHAR str[1024];
    double duration = ((double)((LONGLONG)(CurrentSystem.EndTime - CurrentSystem.StartTime)))
                   / 10000000.00;
    BOOL bTable = FALSE;

    Head = &CurrentSystem.EventListHead;
    Next = Head->Flink;

    while (Head  != Next && !bTable ) {
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Dhead = &pMofInfo->DataListHead;
        DNext = Dhead->Flink;
        while(DNext!=Dhead){
            pMofData = CONTAINING_RECORD(DNext, MOF_DATA, Entry);
            trans = pMofData->CompleteCount;
            if (trans > 0) {
                bTable = TRUE;
                break;
            }
            DNext = DNext->Flink;
        }
        Next = Next->Flink;
    }
    
    if( !bTable ){
        return;
    }

    if( ReportFlags & TRACE_LOG_REPORT_TOTALS ){
        fprintf( procFile,
                 BREAK_LINE
                 "|  Transaction Statistics     %103s\n"
                 BREAK_LINE
                 "|  Transaction                  Trans      Response    Transaction     CPU %%     Disk Total           Tcp Total %20s\n"
                 "|                                          Time(ms)     Rate/sec               Reads     Writes     Sends     Recieves %16s\n"
                 BREAK_LINE,
                 "|",
                 "|",
                 "|"
            );
    }else{
        fprintf( procFile,
                 BREAK_LINE
                 "|  Transaction Statistics     %103s\n"
                 BREAK_LINE
                 "|  Transaction                  Trans      Response    Transaction   CPU %%       Disk/Trans          Tcp/Trans %22s\n"
                 "|                                          Time(ms)     Rate/sec              Reads     Writes   Sends     Recieves %17s\n"
                 BREAK_LINE,
                 "|",
                 "|",
                 "|"
            );
    }

    Head = &CurrentSystem.EventListHead;
    Next = Head->Flink;

    while (Head  != Next) {
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Dhead = &pMofInfo->DataListHead;
        DNext = Dhead->Flink;
        while(DNext!=Dhead){
            pMofData = CONTAINING_RECORD(DNext, MOF_DATA, Entry);
            trans = pMofData->CompleteCount;
            if (trans > 0) {
                UCPU = pMofData->UserCPU;
                KCPU = pMofData->KernelCPU;
                PerCpu = (((UCPU + KCPU)/1000.0)/duration) * 100.0;
                UCPU /= trans;
                KCPU /=  trans;
                if(CurrentSystem.NumberOfProcessors)
                    PerCpu/=CurrentSystem.NumberOfProcessors;
                if( ReportFlags & TRACE_LOG_REPORT_TOTALS ){
                    RIO  = pMofData->ReadCount;
                    WIO  = pMofData->WriteCount;
                    Send  = pMofData->SendCount;
                    Recv  = pMofData->RecvCount;
                }else{
                    RIO  = pMofData->ReadCount / trans;
                    WIO  = pMofData->WriteCount / trans;
                    Send  = pMofData->SendCount / trans;
                    Recv  = pMofData->RecvCount / trans;
                }
                AvgRT = (double)pMofData->TotalResponseTime;
                AvgRT /= trans;
                TransRate = ( (float)trans / duration );
                fprintf(procFile, 
                        "| %-28ws  %7d   %7.0f  ",
                        (pMofInfo->strDescription) ? pMofInfo->strDescription : CpdiGuidToString( str, &pMofInfo->Guid ),
                        pMofData->CompleteCount,
                        AvgRT
                    );
                
                fprintf(procFile,
                        "   %7.2f     %7.2f   %7.2f   %7.2f   %7.2f %7.2f %21s\n",
                        TransRate,
                        PerCpu, 
                        RIO, 
                        WIO,
                        Send,
                        Recv,
                        "|"
                    );
                
            }
            DNext = DNext->Flink;
        }
        Next = Next->Flink;
    }
    fprintf(procFile, BREAK_LINE "\n\n" );

}
static void WriteTransactionCPUTime()
{
    PLIST_ENTRY Head, Next;
    PLIST_ENTRY Dhead, DNext;
    double KCPU, UCPU;
    PMOF_INFO pMofInfo;
    PMOF_DATA pMofData;
    double trans;
    double PerCpu;
    WCHAR str[1024];
    double duration = ((double)((LONGLONG)(CurrentSystem.EndTime - CurrentSystem.StartTime))) / 10000000.00;
    BOOL bTable = FALSE;
    
    Head = &CurrentSystem.EventListHead;
    Next = Head->Flink;

    while (Head  != Next && !bTable ) {
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Dhead = &pMofInfo->DataListHead;
        DNext = Dhead->Flink;
        while(DNext!=Dhead){
            pMofData = CONTAINING_RECORD(DNext, MOF_DATA, Entry);
            trans = (double)pMofData->CompleteCount;
            if (trans > 0) {
                bTable = TRUE;
                break;
            }
            DNext = DNext->Flink;
        }
        Next = Next->Flink;
    }
    
    if( !bTable ){
        return;
    }

    if( !(ReportFlags & TRACE_LOG_REPORT_TOTALS) ){
        fprintf( procFile,
                 BREAK_LINE
                 "| Transaction CPU Utilization                                                                                                       |\n"
                 BREAK_LINE
                 "|  Transaction                  Trans/sec       Minimum            Maximum          Per Transaction         Total             CPU%%  |\n"
                 "|                                          KCPU(ms) UCPU(ms)   KCPU(ms) UCPU(ms)   KCPU(ms) UCPU(ms)   KCPU(ms) UCPU(ms)            |\n"
                 BREAK_LINE
            );
    }else{
        fprintf( procFile,
                 BREAK_LINE
                 "| Transaction CPU Utilization                                                                                                       |\n"
                 BREAK_LINE
                 "|  Transaction                  Trans           Minimum            Maximum          Per Transaction         Total             CPU%%  |\n"
                 "|                                          KCPU(ms) UCPU(ms)   KCPU(ms) UCPU(ms)   KCPU(ms) UCPU(ms)   KCPU(ms) UCPU(ms)            |\n"
                 BREAK_LINE
            );
    }

    Head = &CurrentSystem.EventListHead;
    Next = Head->Flink;

    while (Head  != Next) {
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Dhead = &pMofInfo->DataListHead;
        DNext = Dhead->Flink;
        while(DNext!=Dhead){
            pMofData = CONTAINING_RECORD(DNext, MOF_DATA, Entry);
            trans = (double)pMofData->CompleteCount;
            if (trans > 0) {
                UCPU = pMofData->UserCPU;
                UCPU /= trans;
                KCPU = pMofData->KernelCPU;
                KCPU /=  trans;
                PerCpu = (((pMofData->UserCPU + pMofData->KernelCPU + 0.0)/1000.0)/duration) * 100.0;
                if( !(ReportFlags & TRACE_LOG_REPORT_TOTALS) ){
                    trans /= duration;
                }
                if(CurrentSystem.NumberOfProcessors)
                    PerCpu/=CurrentSystem.NumberOfProcessors;
                fprintf(procFile,
                        "| %-28ws %7.2f   %7d   %7d   %7d   %7d   %7.0f   %7.0f   %7d   %7d      %6.2f  |\n",
                        (pMofInfo->strDescription) ? pMofInfo->strDescription : CpdiGuidToString( str, &pMofInfo->Guid ),
                        trans,
                        pMofData->MinKCpu,
                        pMofData->MinUCpu,
                        pMofData->MaxKCpu,
                        pMofData->MaxUCpu,
                        KCPU,
                        UCPU, 
                        pMofData->KernelCPU,
                        pMofData->UserCPU,
                       PerCpu
                    );
                
            }
            DNext = DNext->Flink;
        }
        Next = Next->Flink;
    }
    fprintf(procFile, BREAK_LINE "\n\n" );
}

PWCHAR CpdiGuidToString(
    PWCHAR s,
    LPGUID piid
    )
{
    swprintf(s, L"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
            piid->Data1, piid->Data2,
            piid->Data3,
            piid->Data4[0], piid->Data4[1],
            piid->Data4[2], piid->Data4[3],
            piid->Data4[4], piid->Data4[5],
            piid->Data4[6], piid->Data4[7]);

    return(s);
}

/*=============================================================================
*/

#define MAX_RECORDS 65536
#define MAX_LOGS    1024 * 1024

typedef struct _PTR_RECORD
{
    PVOID ptrRecord;
    ULONG keySort;
} PTR_RECORD, * PPTR_RECORD;

static PPTR_RECORD PtrBuffer = NULL;
static ULONG       PtrMax    = MAX_LOGS;
static ULONG       PtrTotal  = 0;
static ULONG       PtrIndex;

static PPROCESS_RECORD * ProcessList = NULL;
static WCHAR          ** ModuleList  = NULL;
static ULONG             lCurrentMax = MAX_RECORDS;
static ULONG             lTotal = 0;

void OutputTitle(
        MM_REPORT_TYPE     reportNow,
        MM_REPORT_SORT_KEY sortNow,
        PWCHAR             strImgName
    )
{
    switch (reportNow)
    {
    case REPORT_SUMMARY_PROCESS:
        fprintf(procFile, "Page Fault Summary for Processes, ");
        break;

    case REPORT_SUMMARY_MODULE:
        fprintf(procFile, "Page Fault Summary for Loaded Modules, ");
        break;

    case REPORT_LIST_PROCESS:
        fprintf(procFile, "Page Fault Rundown for ");
        if (strImgName)
        {
            fprintf(procFile, "process '%ws', ", strImgName);
        }
        else
        {
            fprintf(procFile, "all processes, ");
        }
        break;

    case REPORT_LIST_MODULE:
        fprintf(procFile, "Page Fault rundown for ");
        if (strImgName)
        {
            fprintf(procFile, "loaded module '%ws', ", strImgName);
        }
        else
        {
            fprintf(procFile, "all loaded modules, ");
        }
        break;
    }

    switch (sortNow)
    {
    case REPORT_SORT_ALL:
        fprintf(procFile, "sorted by all page faults total.");
        break;

    case REPORT_SORT_HPF:
        fprintf(procFile, "sorted by HardPageFault total.");
        break;

    case REPORT_SORT_TF:
        fprintf(procFile, "sorted by TransitionFault total.");
        break;

    case REPORT_SORT_DZF:
        fprintf(procFile, "sorted by DemandZeroFault total.");
        break;

    case REPORT_SORT_COW:
        fprintf(procFile, "sorted by CopyOnWrite total.");
        break;
    }
    fprintf(procFile, "\n");
}

void OutputModuleHeader()
{
    fprintf(procFile, "=======================================================================================\n");
    fprintf(procFile, " Module Name     Base     Module      Fault Outside Image         Fault Inside Image \n");
    fprintf(procFile, "                Address    Size    HPF     TF    DZF    COW    HPF     TF    DZF    COW\n");
    fprintf(procFile, "=======================================================================================\n");
}

void OutputModuleRecord(PMODULE_RECORD pModule)
{
    fprintf(procFile, "%-12ws 0x%08x%8d %6d %6d %6d %6d %6d %6d %6d %6d\n",
            pModule->strModuleName,
            pModule->lBaseAddress,
            pModule->lModuleSize,
            pModule->lDataFaultHF,
            pModule->lDataFaultTF,
            pModule->lDataFaultDZF,
            pModule->lDataFaultCOW,
            pModule->lCodeFaultHF,
            pModule->lCodeFaultTF,
            pModule->lCodeFaultDZF,
            pModule->lCodeFaultCOW);
}

void OutputTotal(
        BOOLEAN fIsModule,
        ULONG   totalDataFaultHF,
        ULONG   totalDataFaultTF,
        ULONG   totalDataFaultDZF,
        ULONG   totalDataFaultCOW,
        ULONG   totalCodeFaultHF,
        ULONG   totalCodeFaultTF,
        ULONG   totalCodeFaultDZF,
        ULONG   totalCodeFaultCOW
    )
{
    if (fIsModule)
    {
        fprintf(procFile, "=======================================================================================\n");
        fprintf(procFile, "Total                           %6d %6d %6d %6d %6d %6d %6d %6d\n",
                     totalDataFaultHF,
                     totalDataFaultTF,
                     totalDataFaultDZF,
                     totalDataFaultCOW,
                     totalCodeFaultHF,
                     totalCodeFaultTF,
                     totalCodeFaultDZF,
                     totalCodeFaultCOW);
        fprintf(procFile, "=======================================================================================\n");
    }
    else
    {
        fprintf(procFile, "=============================================================================\n");
        fprintf(procFile, "Total                 %6d %6d %6d %6d %6d %6d %6d %6d\n",
                     totalDataFaultHF,
                     totalDataFaultTF,
                     totalDataFaultDZF,
                     totalDataFaultCOW,
                     totalCodeFaultHF,
                     totalCodeFaultTF,
                     totalCodeFaultDZF,
                     totalCodeFaultCOW);
        fprintf(procFile, "=============================================================================\n");
    }
}

void OutputProcessHeader()
{
    fprintf(procFile, "=============================================================================\n");
    fprintf(procFile, " Process Image Name        Fault Outside Image         Fault Inside Image \n");
    fprintf(procFile, "   ID                    HPF     TF    DZF    COW    HPF     TF    DZF    COW\n");
    fprintf(procFile, "=============================================================================\n");
}

void OutputProcessRecord(PPROCESS_RECORD pProcess)
{
    fprintf(procFile, "0x%06x %-12ws %6d %6d %6d %6d %6d %6d %6d %6d\n",
            pProcess->PID,
            pProcess->ImageName,
            pProcess->lDataFaultHF,
            pProcess->lDataFaultTF,
            pProcess->lDataFaultDZF,
            pProcess->lDataFaultCOW,
            pProcess->lCodeFaultHF,
            pProcess->lCodeFaultTF,
            pProcess->lCodeFaultDZF,
            pProcess->lCodeFaultCOW);
}

void OutputModuleProcessRecord(PPROCESS_RECORD pProcess, PMODULE_RECORD pModule)
{
    fprintf(procFile, "0x%06x %-12ws %6d %6d %6d %6d %6d %6d %6d %6d\n",
            pProcess->PID,
            pProcess->ImageName,
            pModule->lDataFaultHF,
            pModule->lDataFaultTF,
            pModule->lDataFaultDZF,
            pModule->lDataFaultCOW,
            pModule->lCodeFaultHF,
            pModule->lCodeFaultTF,
            pModule->lCodeFaultDZF,
            pModule->lCodeFaultCOW);
}

BOOLEAN ModuleHasPageFault(PMODULE_RECORD pModule)
{
    return  (BOOLEAN) (pModule->lDataFaultHF
            + pModule->lDataFaultTF
            + pModule->lDataFaultDZF
            + pModule->lDataFaultCOW
            + pModule->lCodeFaultHF
            + pModule->lCodeFaultTF
            + pModule->lCodeFaultDZF
            + pModule->lCodeFaultCOW
           != 0);
}

BOOLEAN ProcessHasPageFault(PPROCESS_RECORD pProcess)
{
    return  (BOOLEAN) (pProcess->lDataFaultHF
            + pProcess->lDataFaultTF
            + pProcess->lDataFaultDZF
            + pProcess->lDataFaultCOW
            + pProcess->lCodeFaultHF
            + pProcess->lCodeFaultTF
            + pProcess->lCodeFaultDZF
            + pProcess->lCodeFaultCOW
           != 0);
}

ULONG GetModuleSortKey(PMODULE_RECORD pModule, MM_REPORT_SORT_KEY keySort)
{
    ULONG keyValue = 0;

    switch (keySort)
    {
    case REPORT_SORT_ALL:
        keyValue = pModule->lDataFaultHF  + pModule->lCodeFaultHF
                 + pModule->lDataFaultTF  + pModule->lCodeFaultTF
                 + pModule->lDataFaultDZF + pModule->lCodeFaultDZF
                 + pModule->lDataFaultCOW + pModule->lCodeFaultCOW;
        break;

    case REPORT_SORT_HPF:
        keyValue = pModule->lDataFaultHF + pModule->lCodeFaultHF;
        break;

    case REPORT_SORT_TF:
        keyValue = pModule->lDataFaultTF + pModule->lCodeFaultTF;
        break;

    case REPORT_SORT_DZF:
        keyValue = pModule->lDataFaultDZF + pModule->lCodeFaultDZF;
        break;

    case REPORT_SORT_COW:
        keyValue = pModule->lDataFaultCOW + pModule->lCodeFaultCOW;
        break;
    }

    return keyValue;
}

ULONG GetProcessSortKey(PPROCESS_RECORD pProcess, MM_REPORT_SORT_KEY keySort)
{
    ULONG keyValue = 0;

    switch (keySort)
    {
    case REPORT_SORT_ALL:
        keyValue = pProcess->lDataFaultHF  + pProcess->lCodeFaultHF
                 + pProcess->lDataFaultTF  + pProcess->lCodeFaultTF
                 + pProcess->lDataFaultDZF + pProcess->lCodeFaultDZF
                 + pProcess->lDataFaultCOW + pProcess->lCodeFaultCOW;
        break;

    case REPORT_SORT_HPF:
        keyValue = pProcess->lDataFaultHF + pProcess->lCodeFaultHF;
        break;

    case REPORT_SORT_TF:
        keyValue = pProcess->lDataFaultTF + pProcess->lCodeFaultTF;
        break;

    case REPORT_SORT_DZF:
        keyValue = pProcess->lDataFaultDZF + pProcess->lCodeFaultDZF;
        break;

    case REPORT_SORT_COW:
        keyValue = pProcess->lDataFaultCOW + pProcess->lCodeFaultCOW;
        break;
    }

    return keyValue;
}

ULONG GetModuleListIndex(PWCHAR strModuleName)
{
    ULONG lIndex;

    for (lIndex = 0; lIndex < lTotal; lIndex ++)
    {
        if (_wcsicmp(ModuleList[lIndex], strModuleName) == 0)
        {
            break;
        }
    }
    return (lIndex);
}

ULONG GetProcessListIndex(PPROCESS_RECORD pProcess)
{
    ULONG lIndex;

    for (lIndex = 0; lIndex < lTotal; lIndex ++)
    {
        if (ProcessList[lIndex] == pProcess)
        {
            break;
        }
    }
    return (lIndex);
}

int __cdecl CompareModuleRecord(const void * p1, const void * p2)
{
    PPTR_RECORD    pp1      = (PPTR_RECORD) p1;
    PPTR_RECORD    pp2      = (PPTR_RECORD) p2;
    PMODULE_RECORD pModule1 = pp1->ptrRecord;
    PMODULE_RECORD pModule2 = pp2->ptrRecord;

    LONG diffFault = pp2->keySort - pp1->keySort;

    if (diffFault == 0)
    {
        diffFault = wcscmp(pModule1->strModuleName, pModule2->strModuleName);
    }
    return diffFault;
}

int __cdecl CompareProcessRecord(const void * p1, const void * p2)
{
    PPTR_RECORD     pp1       = (PPTR_RECORD) p1;
    PPTR_RECORD     pp2       = (PPTR_RECORD) p2;
    PPROCESS_RECORD pProcess1 = pp1->ptrRecord;
    PPROCESS_RECORD pProcess2 = pp2->ptrRecord;

    LONG diffFault = pp2->keySort - pp1->keySort;

    if (diffFault == 0)
    {
        diffFault = _wcsicmp(pProcess1->ImageName, pProcess2->ImageName);
    }
    return diffFault;
}

int __cdecl CompareProcessModuleRecord(const void * p1, const void * p2)
{
    PPTR_RECORD     pp1      = (PPTR_RECORD) p1;
    PPTR_RECORD     pp2      = (PPTR_RECORD) p2;
    PMODULE_RECORD  pModule1 = pp1->ptrRecord;
    PMODULE_RECORD  pModule2 = pp2->ptrRecord;

    LONG diffFault = GetProcessListIndex(pModule1->pProcess)
                   - GetProcessListIndex(pModule2->pProcess);
    if (diffFault == 0)
    {
        diffFault = pp2->keySort - pp1->keySort;
        if (diffFault == 0)
        {
            diffFault = wcscmp(pModule1->strModuleName,
                               pModule2->strModuleName);
        }
    }

    return diffFault;
}

int __cdecl CompareModuleProcessRecord(const void * p1, const void * p2)
{
    PPTR_RECORD     pp1      = (PPTR_RECORD) p1;
    PPTR_RECORD     pp2      = (PPTR_RECORD) p2;
    PMODULE_RECORD  pModule1 = pp1->ptrRecord;
    PMODULE_RECORD  pModule2 = pp2->ptrRecord;

    LONG diffFault = GetModuleListIndex(pModule1->strModuleName)
                   - GetModuleListIndex(pModule2->strModuleName);
    if (diffFault == 0)
    {
        diffFault = pp2->keySort - pp1->keySort;
        if (diffFault == 0)
        {
            if (pModule1->pProcess && pModule2->pProcess)
            {
                diffFault = (int) (  pModule1->pProcess->PID
                                   - pModule2->pProcess->PID);
            }
            else if (pModule1->pProcess)
            {
                diffFault = -1;
            }
            else if (pModule2->pProcess)
            {
                diffFault = 1;
            }
            else
            {
                diffFault = 0;
            }
        }
    }

    return diffFault;
}

BOOLEAN GetModuleSummary(WCHAR * strModuleName, MM_REPORT_SORT_KEY sortNow)
{
    PLIST_ENTRY    pHead = & CurrentSystem.GlobalModuleListHead;
    PLIST_ENTRY    pNext = pHead->Flink;
    PMODULE_RECORD pModule;
    BOOLEAN        fDone = FALSE;

    while (!fDone)
    {
        for (PtrTotal = 0, fDone = TRUE;
             pNext != pHead;
             pNext  = pNext->Flink)
        {
            if (PtrTotal == PtrMax)
            {
                fDone = FALSE;
                break;
            }

            pModule = CONTAINING_RECORD(pNext, MODULE_RECORD, Entry);
            if (   (!strModuleName || (pModule->strModuleName &&
                             !_wcsicmp(strModuleName, pModule->strModuleName)))
                && (ModuleHasPageFault(pModule)))
            {
                PtrBuffer[PtrTotal].ptrRecord = (PVOID) pModule;
                PtrBuffer[PtrTotal].keySort   =
                                    GetModuleSortKey(pModule, sortNow);
                PtrTotal ++;
            }
        }

        if (!fDone)
        {
            VirtualFree(PtrBuffer, 0, MEM_RELEASE);
            PtrMax += MAX_LOGS;
            PtrBuffer = (PPTR_RECORD) VirtualAlloc(
                                      NULL,
                                      sizeof(PTR_RECORD) * PtrMax,
                                      MEM_COMMIT,
                                      PAGE_READWRITE);
            if (PtrBuffer == NULL)
            {
//                fprintf(stderr, "(PDH.DLL) Memory Commit Failure.\n");
                goto Cleanup;
            }
        }
    }

    if (PtrTotal > 1)
    {
        qsort((void *) PtrBuffer,
              (size_t) PtrTotal,
              (size_t) sizeof(PTR_RECORD),
              CompareModuleRecord);
    }

Cleanup:
    return fDone;
}

BOOLEAN GetProcessSummary(WCHAR * strImgName, MM_REPORT_SORT_KEY sortNow)
{
    PLIST_ENTRY     pHead = & CurrentSystem.ProcessListHead;
    PLIST_ENTRY     pNext = pHead->Flink;
    PPROCESS_RECORD pProcess;
    BOOLEAN         fDone = FALSE;

    while (!fDone)
    {
        for (fDone = TRUE, PtrTotal = 0;
             pNext != pHead;
             pNext = pNext->Flink)
        {
            if (PtrTotal == PtrMax)
            {
                fDone = FALSE;
                break;
            }

            pProcess = CONTAINING_RECORD(pNext, PROCESS_RECORD, Entry);

            if (   (!strImgName || (pProcess->ImageName &&
                                !_wcsicmp(strImgName, pProcess->ImageName)))
                && (ProcessHasPageFault(pProcess)))
            {
                PtrBuffer[PtrTotal].ptrRecord = (PVOID) pProcess;
                PtrBuffer[PtrTotal].keySort   =
                                    GetProcessSortKey(pProcess, sortNow);
                PtrTotal ++;
            }
        }

        if (!fDone)
        {
            VirtualFree(PtrBuffer, 0, MEM_RELEASE);
            PtrMax += MAX_LOGS;
            PtrBuffer = (PPTR_RECORD) VirtualAlloc(
                                      NULL,
                                      sizeof(PTR_RECORD) * PtrMax,
                                      MEM_COMMIT,
                                      PAGE_READWRITE);
            if (PtrBuffer == NULL)
            {
//                fprintf(stderr, "(PDH.DLL) Memory Commit Failure.\n");
                goto Cleanup;
            }
        }
    }

    if (PtrTotal > 1)
    {
        qsort((void *) PtrBuffer,
              (size_t) PtrTotal,
              (size_t) sizeof(PTR_RECORD),
              CompareProcessRecord);
    }

Cleanup:
    return fDone;
}

BOOLEAN GoThroughAllProcessModule(
        BOOLEAN            fProcessList,
        MM_REPORT_SORT_KEY sortNow
        )
{
    BOOLEAN         fDone        = FALSE;
    PLIST_ENTRY     pProcessHead = & CurrentSystem.ProcessListHead;
    PLIST_ENTRY     pProcessNext = pProcessHead->Flink;
    PLIST_ENTRY     pModuleHead;
    PLIST_ENTRY     pModuleNext;
    PPROCESS_RECORD pProcess;
    PMODULE_RECORD  pModule;

    while (!fDone)
    {
        for (PtrTotal = 0, fDone = TRUE;
             fDone && pProcessNext != pProcessHead;
             pProcessNext = pProcessNext->Flink)
        {
            pProcess = CONTAINING_RECORD(pProcessNext, PROCESS_RECORD, Entry);
            if (fProcessList && GetProcessListIndex(pProcess) == lTotal)
            {
                continue;
            }

            pModuleHead = & pProcess->ModuleListHead;
            for (pModuleNext = pModuleHead->Flink;
                 pModuleNext != pModuleHead;
                 pModuleNext = pModuleNext->Flink)
            {
                if (PtrTotal == PtrMax)
                {
                    fDone = FALSE;
                    break;
                }

                pModule = CONTAINING_RECORD(pModuleNext,
                                            MODULE_RECORD,
                                            Entry);
                if (   !fProcessList
                    && GetModuleListIndex(pModule->strModuleName) == lTotal)
                {
                    continue;
                }

                if (ModuleHasPageFault(pModule))
                {
                    PtrBuffer[PtrTotal].ptrRecord = (PVOID) pModule;
                    PtrBuffer[PtrTotal].keySort   =
                                        GetModuleSortKey(pModule, sortNow);
                    PtrTotal ++;
                }
            }
        }

        if (!fDone)
        {
            VirtualFree(PtrBuffer, 0, MEM_RELEASE);
            PtrMax += MAX_LOGS;
            PtrBuffer = (PPTR_RECORD) VirtualAlloc(
                                      NULL,
                                      sizeof(PTR_RECORD) * PtrMax,
                                      MEM_COMMIT,
                                      PAGE_READWRITE);
            if (PtrBuffer == NULL)
            {
//                fprintf(stderr, "(PDH.DLL) Memory Commit Failure.\n");
                goto Cleanup;
            }
        }
    }

Cleanup:
    return fDone;
}

BOOLEAN GetModuleList(WCHAR * strImgName, MM_REPORT_SORT_KEY sortNow)
{
    PMODULE_RECORD pModule;
    BOOLEAN        fResult = GetModuleSummary(strImgName, sortNow);
    ULONG          lAllocSize = sizeof(ULONG) * lCurrentMax;
    ULONG          lIndex;

    if (!fResult)
    {
        goto Cleanup;
    }

    // collect information from ModuleSummary and store in ModuleList array
    //
    ASSERT(!ModuleList);
    ModuleList = (PWCHAR *) VirtualAlloc(
                            NULL, lAllocSize, MEM_COMMIT, PAGE_READWRITE);
    if (ModuleList == NULL)
    {
        fResult = FALSE;
        goto Cleanup;
    }

    for (fResult = FALSE; !fResult;)
    {
        for (fResult = TRUE, lTotal = 0, PtrIndex = 0;
             PtrIndex < PtrTotal;
             PtrIndex ++, lTotal ++)
        {
            if (lTotal == MAX_RECORDS)
            {
                fResult = FALSE;
                break;
            }

            pModule = (PMODULE_RECORD) PtrBuffer[PtrIndex].ptrRecord;

            ModuleList[lTotal] = (PWCHAR) VirtualAlloc(
                          NULL,
                          sizeof(WCHAR) * (lstrlenW(pModule->strModuleName) + 1),
                          MEM_COMMIT,
                          PAGE_READWRITE);
            if (ModuleList[lTotal] == NULL) {
                fResult = FALSE;
                break;
            }
            wcscpy(ModuleList[lTotal], pModule->strModuleName);
        }

        if (!fResult)
        {
            for (lIndex = 0; lIndex < lTotal; lIndex ++)
            {
                VirtualFree(ModuleList[lIndex], 0, MEM_RELEASE);
            }
            VirtualFree(ModuleList, 0, MEM_RELEASE);
            lCurrentMax += MAX_RECORDS;
            lAllocSize   = sizeof(ULONG) * lCurrentMax;
            ModuleList  =
                    VirtualAlloc(NULL, lAllocSize, MEM_COMMIT, PAGE_READWRITE);
            if (ModuleList == NULL)
            {
//                fprintf(stderr, "(PDH.DLL) Memory Commit Failure.\n");
                goto Cleanup;
            }
        }
    }

    // go through ModuleList of each PROCESS_RECORD based on the information
    // from ModuleList array
    //
    fResult = GoThroughAllProcessModule(FALSE, sortNow);

    if (fResult && PtrTotal > 1)
    {
        qsort((void *) PtrBuffer,
              (size_t) PtrTotal,
              (size_t) sizeof(PTR_RECORD),
              CompareModuleProcessRecord);
    }
Cleanup:
    if (ModuleList)
    {
        for (lIndex = 0; lIndex < lTotal; lIndex ++)
        {
            VirtualFree(ModuleList[lIndex], 0, MEM_RELEASE);
        }

        VirtualFree(ModuleList, 0, MEM_RELEASE);
        ModuleList = NULL;
    }
    return fResult;
}

BOOLEAN GetProcessList(WCHAR * strImgName, MM_REPORT_SORT_KEY sortNow)
{
    PPROCESS_RECORD pProcess;
    BOOLEAN         fResult    = GetProcessSummary(strImgName, sortNow);
    ULONG           lAllocSize = sizeof(PPROCESS_RECORD) * lCurrentMax;

    if (!fResult)
    {
        goto Cleanup;
    }

    // collect information from ProcessSummary and store in ProcessList array
    //
    ASSERT(!ProcessList);
    ProcessList = (PPROCESS_RECORD *) VirtualAlloc(
                            NULL, lAllocSize, MEM_COMMIT, PAGE_READWRITE);
    if (ProcessList == NULL)
    {
        fResult = FALSE;
        goto Cleanup;
    }

    for (fResult = FALSE; !fResult;)
    {
        for (fResult = TRUE, lTotal = 0, PtrIndex = 0;
             PtrIndex < PtrTotal;
             PtrIndex ++, lTotal ++)
        {
            if (lTotal == MAX_RECORDS)
            {
                fResult = FALSE;
                break;
            }

            pProcess = (PPROCESS_RECORD) PtrBuffer[PtrIndex].ptrRecord;
            ProcessList[lTotal] = pProcess;
        }

        if (!fResult)
        {
            VirtualFree(ProcessList, 0, MEM_RELEASE);
            lCurrentMax += MAX_RECORDS;
            lAllocSize   = sizeof(ULONG) * lCurrentMax;
            ProcessList  =
                    VirtualAlloc(NULL, lAllocSize, MEM_COMMIT, PAGE_READWRITE);
            if (ProcessList == NULL)
            {
//                fprintf(stderr, "(PDH.DLL) Memory Commit Failure.\n");
                goto Cleanup;
            }
        }
    }

    // go through ModuleList of each PROCESS_RECORD based on the information
    // from ProcessList
    //
    fResult = GoThroughAllProcessModule(TRUE, sortNow);

    if (fResult && PtrTotal > 1)
    {
        qsort((void *) PtrBuffer,
              (size_t) PtrTotal,
              (size_t) sizeof(PTR_RECORD),
              CompareProcessModuleRecord);
    }
Cleanup:
    if (ProcessList)
    {
        VirtualFree(ProcessList, 0, MEM_RELEASE);
        ProcessList = NULL;
    }

    return fResult;
}

void ReportPageFaultInfo(PCPD_USER_CONTEXT_MM pUserContext)
{
    PPROCESS_RECORD    pProcessPrev = NULL;
    WCHAR    Module_Prev[256];

    MM_REPORT_TYPE     reportNow    = REPORT_SUMMARY_PROCESS;
    MM_REPORT_SORT_KEY sortNow      = REPORT_SORT_ALL;
    PWCHAR             strImgName   = NULL;

    ULONG totalDataFaultHF   = 0;
    ULONG totalDataFaultTF   = 0;
    ULONG totalDataFaultDZF  = 0;
    ULONG totalDataFaultCOW  = 0;
    ULONG totalCodeFaultHF   = 0;
    ULONG totalCodeFaultTF   = 0;
    ULONG totalCodeFaultDZF  = 0;
    ULONG totalCodeFaultCOW  = 0;

    PPROCESS_RECORD pProcess;
    PMODULE_RECORD  pModule;
    
    return;

    ASSERT(!PtrBuffer);
    PtrBuffer = (PPTR_RECORD) VirtualAlloc(
                              NULL,
                              sizeof(PTR_RECORD) * PtrMax,
                              MEM_COMMIT,
                              PAGE_READWRITE);
    if (PtrBuffer == NULL)
    {
        goto Cleanup;
    }

    if (pUserContext)
    {
        reportNow  = pUserContext->reportNow;
        sortNow    = pUserContext->sortNow;
        strImgName = pUserContext->strImgName;
    }

    OutputTitle(reportNow, sortNow, strImgName);

    switch (reportNow)
    {
    case REPORT_SUMMARY_MODULE:
        if( FALSE == GetModuleSummary(NULL, sortNow) ){
            break;
        }
        OutputModuleHeader();
        totalDataFaultHF  = totalDataFaultTF  = totalDataFaultDZF
                          = totalDataFaultCOW = totalCodeFaultHF
                          = totalCodeFaultTF  = totalCodeFaultDZF
                          = totalCodeFaultCOW = 0;
        for (PtrIndex = 0; PtrIndex < PtrTotal; PtrIndex ++)
        {
            pModule = (PMODULE_RECORD) PtrBuffer[PtrIndex].ptrRecord;
            OutputModuleRecord(pModule);

            totalDataFaultHF  += pModule->lDataFaultHF;
            totalDataFaultTF  += pModule->lDataFaultTF;
            totalDataFaultDZF += pModule->lDataFaultDZF;
            totalDataFaultCOW += pModule->lDataFaultCOW;
            totalCodeFaultHF  += pModule->lCodeFaultHF;
            totalCodeFaultTF  += pModule->lCodeFaultTF;
            totalCodeFaultDZF += pModule->lCodeFaultDZF;
            totalCodeFaultCOW += pModule->lCodeFaultCOW;
        }
        OutputTotal(TRUE,
                totalDataFaultHF,
                totalDataFaultTF,
                totalDataFaultDZF,
                totalDataFaultCOW,
                totalCodeFaultHF,
                totalCodeFaultTF,
                totalCodeFaultDZF,
                totalCodeFaultCOW);
        break;

    case REPORT_SUMMARY_PROCESS:
        if( FALSE == GetProcessSummary(NULL, sortNow) ){
            break;
        }
        OutputProcessHeader();
        totalDataFaultHF  = totalDataFaultTF  = totalDataFaultDZF
                          = totalDataFaultCOW = totalCodeFaultHF
                          = totalCodeFaultTF  = totalCodeFaultDZF
                          = totalCodeFaultCOW = 0;
        for (PtrIndex = 0; PtrIndex < PtrTotal; PtrIndex ++)
        {
            pProcess = (PPROCESS_RECORD) PtrBuffer[PtrIndex].ptrRecord;
            OutputProcessRecord(pProcess);

            totalDataFaultHF  += pProcess->lDataFaultHF;
            totalDataFaultTF  += pProcess->lDataFaultTF;
            totalDataFaultDZF += pProcess->lDataFaultDZF;
            totalDataFaultCOW += pProcess->lDataFaultCOW;
            totalCodeFaultHF  += pProcess->lCodeFaultHF;
            totalCodeFaultTF  += pProcess->lCodeFaultTF;
            totalCodeFaultDZF += pProcess->lCodeFaultDZF;
            totalCodeFaultCOW += pProcess->lCodeFaultCOW;
        }
        OutputTotal(FALSE,
                totalDataFaultHF,
                totalDataFaultTF,
                totalDataFaultDZF,
                totalDataFaultCOW,
                totalCodeFaultHF,
                totalCodeFaultTF,
                totalCodeFaultDZF,
                totalCodeFaultCOW);
        break;

    case REPORT_LIST_PROCESS:
        if( FALSE == GetProcessList(strImgName, sortNow) ){
            break;
        }
        if (PtrTotal > 0)
        {
            for (PtrIndex = 0; PtrIndex < PtrTotal; PtrIndex ++)
            {
                pModule  = (PMODULE_RECORD) PtrBuffer[PtrIndex].ptrRecord;
                pProcess = pModule->pProcess;
                ASSERT(pProcess);

                if (PtrIndex == 0 || pProcessPrev != pProcess)
                {
                    if (PtrIndex != 0)
                    {
                        OutputTotal(TRUE,
                                totalDataFaultHF,
                                totalDataFaultTF,
                                totalDataFaultDZF,
                                totalDataFaultCOW,
                                totalCodeFaultHF,
                                totalCodeFaultTF,
                                totalCodeFaultDZF,
                                totalCodeFaultCOW);
                    }
                    totalDataFaultHF  = totalDataFaultTF  = totalDataFaultDZF
                                      = totalDataFaultCOW = totalCodeFaultHF
                                      = totalCodeFaultTF  = totalCodeFaultDZF
                                      = totalCodeFaultCOW = 0;
                    pProcessPrev = pModule->pProcess;
                    fprintf(procFile,
                            "\nProcess 0x%08x          Image: %-20ws\n",
                            pProcess->PID, pProcess->ImageName);
                    OutputModuleHeader();
                }

                OutputModuleRecord(pModule);
                totalDataFaultHF  += pModule->lDataFaultHF;
                totalDataFaultTF  += pModule->lDataFaultTF;
                totalDataFaultDZF += pModule->lDataFaultDZF;
                totalDataFaultCOW += pModule->lDataFaultCOW;
                totalCodeFaultHF  += pModule->lCodeFaultHF;
                totalCodeFaultTF  += pModule->lCodeFaultTF;
                totalCodeFaultDZF += pModule->lCodeFaultDZF;
                totalCodeFaultCOW += pModule->lCodeFaultCOW;
            }
            OutputTotal(TRUE,
                    totalDataFaultHF,
                    totalDataFaultTF,
                    totalDataFaultDZF,
                    totalDataFaultCOW,
                    totalCodeFaultHF,
                    totalCodeFaultTF,
                    totalCodeFaultDZF,
                    totalCodeFaultCOW);
        }
        break;

    case REPORT_LIST_MODULE:
        if( FALSE == GetModuleList(strImgName, sortNow) ){
            break;
        }
        if (PtrTotal > 0)
        {
            for (PtrIndex = 0; PtrIndex < PtrTotal; PtrIndex ++)
            {
                pModule  = (PMODULE_RECORD) PtrBuffer[PtrIndex].ptrRecord;
                if( pModule == NULL ){
                    break;
                }
                pProcess = pModule->pProcess;
                ASSERT(pProcess);

                if (   PtrIndex == 0
                    || _wcsicmp(Module_Prev, pModule->strModuleName))
                {
                    if (PtrIndex != 0)
                    {
                        OutputTotal(FALSE,
                                totalDataFaultHF,
                                totalDataFaultTF,
                                totalDataFaultDZF,
                                totalDataFaultCOW,
                                totalCodeFaultHF,
                                totalCodeFaultTF,
                                totalCodeFaultDZF,
                                totalCodeFaultCOW);
                    }
                    totalDataFaultHF  = totalDataFaultTF  = totalDataFaultDZF
                                      = totalDataFaultCOW = totalCodeFaultHF
                                      = totalCodeFaultTF  = totalCodeFaultDZF
                                      = totalCodeFaultCOW = 0;
                    wcscpy(Module_Prev, pModule->strModuleName);
                    fprintf(procFile,
                            "\nModule Name: %-20ws, BaseAddress: 0x%08x, Size:%10d\n",
                            pModule->strModuleName,
                            pModule->lBaseAddress,
                            pModule->lModuleSize);
                    OutputProcessHeader();
                }

                OutputModuleProcessRecord(pProcess, pModule);
                totalDataFaultHF  += pModule->lDataFaultHF;
                totalDataFaultTF  += pModule->lDataFaultTF;
                totalDataFaultDZF += pModule->lDataFaultDZF;
                totalDataFaultCOW += pModule->lDataFaultCOW;
                totalCodeFaultHF  += pModule->lCodeFaultHF;
                totalCodeFaultTF  += pModule->lCodeFaultTF;
                totalCodeFaultDZF += pModule->lCodeFaultDZF;
                totalCodeFaultCOW += pModule->lCodeFaultCOW;
            }
            OutputTotal(FALSE,
                    totalDataFaultHF,
                    totalDataFaultTF,
                    totalDataFaultDZF,
                    totalDataFaultCOW,
                    totalCodeFaultHF,
                    totalCodeFaultTF,
                    totalCodeFaultDZF,
                    totalCodeFaultCOW);
        }
        break;
    }

Cleanup:
    if (PtrBuffer)
    {
        VirtualFree(PtrBuffer, 0, MEM_RELEASE);
    }
    ASSERT(!ProcessList && !ModuleList);
}

/*=============================================================================
*/

extern PMODULE_RECORD SearchModuleByAddr(
                                PLIST_ENTRY pModuleListHead,
                                ULONG       lAddress);
extern PMODULE_RECORD SearchSysModule(
                                PPROCESS_RECORD pProcess,
                                ULONG           lAddress,
                                BOOLEAN         fActive);

BOOLEAN
RundownHPFFileList(
        BOOLEAN     fRead,
        PLIST_ENTRY pHPFFileListHead
                )
{
    PLIST_ENTRY      pNext = pHPFFileListHead->Flink;
    PHPF_FILE_RECORD pHPFFileRecord;
    PFILE_OBJECT     pFileObj;
    PTDISK_RECORD     pDiskRecord;
    BOOLEAN          fResult = (BOOLEAN)(pNext != pHPFFileListHead);

    while (pNext != pHPFFileListHead)
    {
        pHPFFileRecord = CONTAINING_RECORD(pNext, HPF_FILE_RECORD, Entry);
        pNext          = pNext->Flink;

        pDiskRecord = FindGlobalDiskById(pHPFFileRecord->DiskNumber);
        pFileObj    = FindFileInTable(pHPFFileRecord->fDO);
        if (pDiskRecord != NULL) {
            fprintf(procFile, "\t\t%c%04d,%03d,%-8ws,0x%012I64x,%6d,0x%08p\n",
                        (fRead) ? ('R') : ('W'),
                        pHPFFileRecord->RecordID,
                        pHPFFileRecord->DiskNumber,
                        pDiskRecord->DiskName,
                        pHPFFileRecord->ByteOffset,
                        pHPFFileRecord->BytesCount,
                        pHPFFileRecord->fDO);
        }
        if (pFileObj && pFileObj->fileRec)
        {
            fprintf(procFile, "\t\t\t%ws\n", pFileObj->fileRec->FileName);
        }
        //else
        //{
        //    fprintf(procFile,"\n");
        //}
    }

    return fResult;
}

void ReportHardFaultInfo()
{
    PLIST_ENTRY     pProcessHead = & CurrentSystem.ProcessListHead;
    PLIST_ENTRY     pProcessNext = pProcessHead->Flink;
    PPROCESS_RECORD pProcess;

    PLIST_ENTRY     pHPFHead;
    PLIST_ENTRY     pHPFNext;
    PHPF_RECORD     pHPF;
    PMODULE_RECORD  pModule;

    PLIST_ENTRY     pThreadHead;
    PLIST_ENTRY     pThreadNext;
    PTHREAD_RECORD  pThread;

    BOOLEAN         fRecord;

    fprintf(procFile, "\nHardPageFault Rundown Report\n");

    while (pProcessNext != pProcessHead)
    {
        pProcess     = CONTAINING_RECORD(pProcessNext, PROCESS_RECORD, Entry);
        pProcessNext = pProcessNext->Flink;

        fprintf(procFile, "-------------------------------------------------------------------------------\n");
        fprintf(procFile, "Process 0x%08x          Image: %-20ws\n",
                pProcess->PID, pProcess->ImageName);

        pHPFHead = & pProcess->HPFListHead;
        pHPFNext = pHPFHead->Flink;
        while (pHPFNext != pHPFHead)
        {
            pHPF     = CONTAINING_RECORD(pHPFNext, HPF_RECORD, Entry);
            pHPFNext = pHPFNext->Flink;

            fprintf(procFile, "\t%04d,0x%08x,",
                    pHPF->RecordID,
                    pHPF->lProgramCounter);
            pModule  = SearchModuleByAddr(
                            & pProcess->ModuleListHead,
                              pHPF->lProgramCounter);
            if (pModule)
            {
                fprintf(procFile, "%-16ws,0x%08x,%010d\n",
                        pModule->strModuleName,
                        pModule->lBaseAddress,
                        pModule->lModuleSize);
            }
            else
            {
                fprintf(procFile, "None\n");
            }
            fprintf(procFile, "\t0x%08x,0x%08p,0x%010I64x,",
                    pHPF->lFaultAddress,
                    pHPF->fDO,
                    pHPF->lByteOffset);
            pModule  = SearchModuleByAddr(
                            & pProcess->ModuleListHead,
                              pHPF->lFaultAddress);
            if (!pModule)
            {
                pModule  = SearchSysModule(
                                pProcess, pHPF->lFaultAddress, FALSE);
            }
            if (pModule)
            {
                fprintf(procFile, "%-16ws,0x%08x,%010d\n",
                        pModule->strModuleName,
                        pModule->lBaseAddress,
                        pModule->lModuleSize);
            }
            else
            {
                fprintf(procFile, "None\n");
            }
            RundownHPFFileList(TRUE, & pHPF->HPFReadListHead);

            fprintf(procFile, "\n");
        }

        pThreadHead = & CurrentSystem.GlobalThreadListHead;
        pThreadNext = pThreadHead->Flink;
        fprintf(procFile, "\tDisk I/O Wite Page Records:\n");
        fRecord = FALSE;
        while (pThreadNext != pThreadHead)
        {
            pThread     = CONTAINING_RECORD(pThreadNext, THREAD_RECORD, Entry);
            pThreadNext = pThreadNext->Flink;

            if (pThread->pProcess == pProcess)
            {
                if (RundownHPFFileList(FALSE, & pThread->HPFWriteListHead))
                {
                    fRecord = TRUE;
                }
            }
        }
        if (!fRecord)
        {
            fprintf(procFile, "\t\tNone\n");
        }

        pThreadHead = & CurrentSystem.GlobalThreadListHead;
        pThreadNext = pThreadHead->Flink;
        fprintf(procFile, "\tUnresolved Disk I/O Read Page Records:\n");
        fRecord = FALSE;
        while (pThreadNext != pThreadHead)
        {
            pThread     = CONTAINING_RECORD(pThreadNext, THREAD_RECORD, Entry);
            pThreadNext = pThreadNext->Flink;

            if (pThread->pProcess == pProcess)
            {
                if (RundownHPFFileList(TRUE,  & pThread->HPFReadListHead))
                {
                    fRecord = TRUE;
                }
            }
        }
        if (!fRecord)
        {
            fprintf(procFile, "\t\tNone\n");
        }
    }

        fprintf(procFile, "-------------------------------------------------------------------------------\n");
}

int __cdecl
CompareFileRecord(const void * p1, const void * p2)
{
    PPTR_RECORD   pp1      = (PPTR_RECORD) p1;
    PPTR_RECORD   pp2      = (PPTR_RECORD) p2;
    PFILE_RECORD  pFile1   = (PFILE_RECORD) pp1->ptrRecord;
    PFILE_RECORD  pFile2   = (PFILE_RECORD) pp2->ptrRecord;

    LONG diffFault = pp2->keySort - pp1->keySort;
    if (diffFault == 0)
    {
        diffFault = pFile1->DiskNumber - pFile2->DiskNumber;
        if (diffFault == 0)
        {
            diffFault = wcscmp(pFile1->FileName, pFile2->FileName);
        }
    }

    return diffFault;
}

void
ReportHotFileInfo(ULONG NumEntry)
{
    PLIST_ENTRY  pHead = & CurrentSystem.HotFileListHead;
    PLIST_ENTRY  pNext = pHead->Flink;
    PFILE_RECORD pFile;
    BOOLEAN      fDone = FALSE;

    ASSERT(!PtrBuffer);
    PtrBuffer = (PPTR_RECORD) VirtualAlloc(
                              NULL,
                              sizeof(PTR_RECORD) * PtrMax,
                              MEM_COMMIT,
                              PAGE_READWRITE);
    
    if( NULL == PtrBuffer ){
        goto Cleanup;
    }

    while (!fDone)
    {
        for (PtrTotal = 0, fDone = TRUE;
             pNext != pHead;
             pNext  = pNext->Flink)
        {
            if (PtrTotal == PtrMax)
            {
                fDone = FALSE;
                break;
            }

            pFile = CONTAINING_RECORD(pNext, FILE_RECORD, Entry);

            if (pFile->ReadCount + pFile->WriteCount > 0)
            {
                PtrBuffer[PtrTotal].ptrRecord = (PVOID) pFile;
                PtrBuffer[PtrTotal].keySort   =
                                        pFile->ReadCount + pFile->WriteCount;
                PtrTotal ++;
            }
        }

        if (!fDone)
        {
            VirtualFree(PtrBuffer, 0, MEM_RELEASE);
            PtrMax += MAX_LOGS;
            PtrBuffer = (PPTR_RECORD) VirtualAlloc(
                                      NULL,
                                      sizeof(PTR_RECORD) * PtrMax,
                                      MEM_COMMIT,
                                      PAGE_READWRITE);
            if (PtrBuffer == NULL)
            {
//                fprintf(stderr, "(PDH.DLL) Memory Commit Failure.\n");
                goto Cleanup;
            }
        }
    }

    if (PtrTotal > 1)
    {
        qsort((void *) PtrBuffer,
              (size_t) PtrTotal,
              (size_t) sizeof(PTR_RECORD),
              CompareFileRecord);
    }

    // output HotFile report title
    //
    fprintf(procFile,
        "File  Name                                                                                        Read    Read    Write  Write\n");
    fprintf(procFile,
        "          Process Information                                                                     Count   Size    Count   Size\n");
    fprintf(procFile,
        "================================================================================================================================\n");

    PtrTotal = (PtrTotal > NumEntry) ? (NumEntry) : (PtrTotal);
    for (PtrIndex = 0; PtrIndex < PtrTotal; PtrIndex ++)
    {
        PLIST_ENTRY           pProtoHead;
        PLIST_ENTRY           pProtoNext;
        PPROTO_PROCESS_RECORD pProto;

        pFile = (PFILE_RECORD) PtrBuffer[PtrIndex].ptrRecord;

        fprintf(procFile, "(%04d)%-90ws  %5d %8d  %5d %8d\n",
                pFile->DiskNumber,
                pFile->FileName,
                pFile->ReadCount,
                pFile->ReadSize,
                pFile->WriteCount,
                pFile->WriteSize);

        pProtoHead = & pFile->ProtoProcessListHead;
        pProtoNext = pProtoHead->Flink;

        while (pProtoNext != pProtoHead)
        {
            pProto = CONTAINING_RECORD(pProtoNext, PROTO_PROCESS_RECORD, Entry);
            pProtoNext = pProtoNext->Flink;

            if (pProto->ReadCount + pProto->WriteCount > 0)
            {
                fprintf(procFile,
                        "          0x%08X  %-74ws  %5d %8d  %5d %8d\n",
                        pProto->ProcessRecord->PID,
                        pProto->ProcessRecord->ImageName,
                        pProto->ReadCount,
                        pProto->ReadSize,
                        pProto->WriteCount,
                        pProto->WriteSize);
            }
        }
        fprintf(procFile, "\n");
    }

    fprintf(procFile,
        "================================================================================================================================\n");

Cleanup:
    if (PtrBuffer)
    {
        VirtualFree(PtrBuffer, 0, MEM_RELEASE);
    }
}

#define CHECKTOK( x )   if( NULL == x ) { continue; }

static void ReportJobInfo2(void)
{
    JOB_RECORD Job, *pJob;
    char* s; 
    char line[MAXSTR];

    ULONG TotalCount = 0;
    ULONGLONG TotalRT = 0;
    ULONG     TotalCPUTime = 0;

    pJob = &Job;

    if( NULL == CurrentSystem.TempFile ){
        return;
    }

    rewind( CurrentSystem.TempFile );

    while ( fgets(line, MAXSTR, CurrentSystem.TempFile) != NULL ) {
        s = strtok( line, (","));
        CHECKTOK( s );
        pJob->JobId = atol(s);
        if (pJob == NULL){
            return;
        }
    }

    fprintf(procFile, BREAK_LINE );
    fprintf(procFile, 
       "| Spooler Transaction Instance (Job) Data                                                                                           |\n"); 
    
    fprintf(procFile, BREAK_LINE ); 
    fprintf(procFile,
    "| Job Id        Type   JobSize   Pages    PPS   Files  GdiSize  Color  XRes YRes Qlty   Copy  TTOpt Threads                         |\n");



    fprintf(procFile, BREAK_LINE );
    RtlZeroMemory(pJob, sizeof(JOB_RECORD));
    RtlZeroMemory(line,    MAXSTR * sizeof(char));

    rewind( CurrentSystem.TempFile );

    while ( fgets(line, MAXSTR, CurrentSystem.TempFile) != NULL ) {
        s = strtok( line, (","));
        CHECKTOK( s );
        pJob->JobId = atol(s);
        if (pJob == NULL){
            continue;
        }

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->KCPUTime = atol(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->UCPUTime = atol(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->ReadIO = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->StartTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->EndTime = _atoi64(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->ResponseTime = _atoi64(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->PrintJobTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->WriteIO = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->DataType = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->JobSize = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Pages = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->PagesPerSide = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->FilesOpened = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->GdiJobSize = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Color = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->XRes = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->YRes = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Quality = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Copies = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->TTOption = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->NumberOfThreads = atol(s);


        fprintf(procFile,
       "| %6d    %8d  %8d  %4d  %6d   %6hd %8d  %5hd  %4hd %4hd %4hd %6hd %5hd %5d  %27s\n",

            pJob->JobId,
            pJob->DataType,
            pJob->JobSize,
            pJob->Pages,
            pJob->PagesPerSide,
            pJob->FilesOpened,
            pJob->GdiJobSize,
            pJob->Color,
            pJob->XRes,
            pJob->YRes,
            pJob->Quality,
            pJob->Copies,
            pJob->TTOption,
            pJob->NumberOfThreads,
            "|"
            );

    }

    fprintf(procFile, BREAK_LINE "\n\n" );
}




static void ReportJobInfo(void)
{
    JOB_RECORD Job, *pJob;
    char* s; 
    char line[MAXSTR];

    FILETIME  StTm, StlTm;
    LARGE_INTEGER LargeTmp;
    SYSTEMTIME stStart, stEnd, stDequeue;

    ULONG TotalCount = 0;
    ULONGLONG TotalRT = 0;
    ULONG     TotalCPUTime = 0;

    if( NULL == CurrentSystem.TempFile ){
        return;
    }

    pJob = &Job;
    rewind( CurrentSystem.TempFile );

    while ( fgets(line, MAXSTR, CurrentSystem.TempFile) != NULL ) {
        s = strtok( line, (","));
        CHECKTOK( s );
        pJob->JobId = atol(s);
        if (pJob == NULL){
            return;
        }
    }

    fprintf(procFile, BREAK_LINE );
    fprintf(procFile, 
       "| Transaction Instance (Job) Statistics                                                                                             |\n");
    
    fprintf(procFile, BREAK_LINE ); 
    fprintf(procFile,
    "| Job Id      StartTime    DequeueTime     EndTime    RespTime   CPUTime %60s \n", "|");


    fprintf(procFile, BREAK_LINE );
    RtlZeroMemory(pJob, sizeof(JOB_RECORD));
    RtlZeroMemory(line,    MAXSTR * sizeof(char));

    rewind( CurrentSystem.TempFile );

    while ( fgets(line, MAXSTR, CurrentSystem.TempFile) != NULL ) {
        s = strtok( line, (","));
        CHECKTOK( s );
        pJob->JobId = atol(s);
        if (pJob == NULL){
            continue;
        }

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->KCPUTime = atol(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->UCPUTime = atol(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->ReadIO = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->StartTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->EndTime = _atoi64(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->ResponseTime = _atoi64(s);
        
        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->PrintJobTime = _atoi64(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->WriteIO = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->DataType = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->JobSize = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Pages = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->PagesPerSide = atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->FilesOpened = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->GdiJobSize = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Color = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->XRes = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->YRes = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Quality = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->Copies = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->TTOption = (SHORT) atol(s);

        s = strtok( NULL, (","));
        CHECKTOK( s );
        pJob->NumberOfThreads = atol(s);


        LargeTmp.QuadPart = pJob->StartTime;
        StTm.dwHighDateTime = LargeTmp.HighPart;
        StTm.dwLowDateTime = LargeTmp.LowPart;
        FileTimeToLocalFileTime(&StTm, &StlTm);


        FileTimeToSystemTime (
            &StlTm,
            &stStart
            );

        LargeTmp.QuadPart = pJob->EndTime;
        StTm.dwHighDateTime = LargeTmp.HighPart;
        StTm.dwLowDateTime = LargeTmp.LowPart;
        FileTimeToLocalFileTime(&StTm, &StlTm);


        FileTimeToSystemTime (
            &StlTm,
            &stEnd
            );

        LargeTmp.QuadPart = pJob->PrintJobTime;
        StTm.dwHighDateTime = LargeTmp.HighPart;
        StTm.dwLowDateTime = LargeTmp.LowPart;
        FileTimeToLocalFileTime(&StTm, &StlTm);


        FileTimeToSystemTime (
            &StlTm,
            &stDequeue
            );


        fprintf(procFile,
            "| %4d      %2d:%02d:%02d.%03d   %2d:%02d:%02d.%03d  %2d:%02d:%02d.%03d  %6I64u   %5d %63s\n",

            pJob->JobId,
            stStart.wHour, stStart.wMinute, stStart.wSecond, stStart.wMilliseconds, 
            stDequeue.wHour, stDequeue.wMinute, stDequeue.wSecond, stDequeue.wMilliseconds, 
            stEnd.wHour, stEnd.wMinute, stEnd.wSecond, stEnd.wMilliseconds, 
            pJob->ResponseTime,
            pJob->KCPUTime + pJob->UCPUTime,
            "|"
            );
            TotalCount++;
            TotalRT += pJob->ResponseTime;
            TotalCPUTime += (pJob->KCPUTime + pJob->UCPUTime);
    }

    if (TotalCount > 0) {
        TotalRT /= TotalCount;
        TotalCPUTime /= TotalCount;
    }

    fprintf(procFile, BREAK_LINE );
    fprintf(procFile, 
    "| %4d                                                 %6I64u   %5d %63s\n", 
        TotalCount, TotalRT, TotalCPUTime, "|");
    
    fprintf(procFile, BREAK_LINE "\n\n" );

    ReportJobInfo2();
}

void
WriteSummary()
{
    FILE* SummaryFile;
    PLIST_ENTRY Head, Next;
    PMOF_INFO pMofInfo;
    ULONG i;


    FILETIME  StTm, StlTm;
    LARGE_INTEGER LargeTmp;
    SYSTEMTIME tmf, emf;
    BOOL bResult;

    if( NULL == TraceContext->SummaryFileName ){
        return;
    }

    if( 0 == TotalEventCount ){
        return;
    }

    SummaryFile = _wfopen( TraceContext->SummaryFileName, L"w" );
    if (SummaryFile == NULL){
        return;
    }

    fwprintf(SummaryFile,L"Files Processed:\n");
    for (i=0; i<TraceContext->LogFileCount; i++) {
        fwprintf(SummaryFile,L"\t%s\n",TraceContext->LogFileName[i]);
    }

    LargeTmp.QuadPart = StartTime;
    StTm.dwHighDateTime = LargeTmp.HighPart;
    StTm.dwLowDateTime = LargeTmp.LowPart;
    FileTimeToLocalFileTime(&StTm, &StlTm);


    bResult = FileTimeToSystemTime (
        &StlTm,
        &tmf
        );

    if ( !bResult || tmf.wMonth > 12) {
        ZeroMemory( &tmf, sizeof(SYSTEMTIME) );
    }


    LargeTmp.QuadPart = EndTime;
    StTm.dwHighDateTime = LargeTmp.HighPart;
    StTm.dwLowDateTime = LargeTmp.LowPart;
    FileTimeToLocalFileTime(&StTm, &StlTm);

    bResult = FileTimeToSystemTime (
        &StlTm,
        &emf
        );

    if ( !bResult ) {
        ZeroMemory( &emf, sizeof(SYSTEMTIME) );
    }

    ElapseTime = EndTime - StartTime;
    fwprintf(SummaryFile,
                L"Total Buffers Processed %d\n"
                L"Total Events  Processed %d\n"
                L"Total Events  Lost      %d\n"
                L"Start Time              %2d  %3S %4d    %2d:%02d:%02d.%03d\n" 
                L"End Time                %2d  %3S %4d    %2d:%02d:%02d.%03d\n" 
                L"Elapsed Time            %I64d sec\n",
              TotalBuffersRead,
              TotalEventCount,
              TotalEventsLost,
              tmf.wDay,  Month[tmf.wMonth], tmf.wYear, tmf.wHour, tmf.wMinute, tmf.wSecond, tmf.wMilliseconds,
              emf.wDay, Month[emf.wMonth], emf.wYear,emf.wHour, emf.wMinute, emf.wSecond, emf.wMilliseconds,
              (ElapseTime / 10000000) );



    fwprintf(SummaryFile,
         L"+-------------------------------------------------------------------------------------+\n"
         L"|%10s   %-20s %-10s  %-38s|\n"
         L"+-------------------------------------------------------------------------------------+\n",
         L"Event Count",
         L"Event Name",
         L"Event Type",
         L"Guid"
        );

    Head = &CurrentSystem.EventListHead;
    Next = Head->Flink;
    while (Head != Next) {
        WCHAR wstr[MAXSTR];
        PWCHAR str;
        WCHAR s[64];
        PLIST_ENTRY vHead, vNext;
        PMOF_VERSION pMofVersion;

        RtlZeroMemory(&wstr, MAXSTR);

        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Next = Next->Flink;

        if (pMofInfo->EventCount > 0) {
            str = CpdiGuidToString(&s[0], (LPGUID)&pMofInfo->Guid);

            if( pMofInfo->strDescription != NULL ){
                wcscpy( wstr, pMofInfo->strDescription );
            }

            //
            // Get event count by type from MOF_VERSION structure
            //

            vHead = &pMofInfo->VersionHeader;
            vNext = vHead->Flink;

            while (vHead != vNext) {

                pMofVersion = CONTAINING_RECORD(vNext, MOF_VERSION, Entry);
                vNext = vNext->Flink;

                if (pMofVersion->EventCountByType != 0) {

                fwprintf(SummaryFile,L"| %10d   %-20s %-10s  %38s|\n",
                      pMofVersion->EventCountByType,
                      wstr,
                      pMofVersion->strType ? pMofVersion->strType : GUID_TYPE_DEFAULT,
                      str);
                }
            }
        }
    }


    fwprintf(SummaryFile,
           L"+-------------------------------------------------------------------------------------+\n"
        );
    
    fclose( SummaryFile );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracectr\workload.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    workload.h

Abstract:

    Workload Header file

Author:

    08-Apr-1998 mraghu

Revision History:

--*/


typedef struct _METRICS {
    double Thruput;
    double Response;
    double Queue;
    double Wait;
} METRICS, *PMETRICS;

typedef struct _WORKLOAD_RECORD {
    LIST_ENTRY Entry;   

    METRICS Metrics;

    ULONG   ClassNumber;
    PVOID   ClassFilter;
    LIST_ENTRY DiskListHead;    // Per class disk list; 

    double  TransCount;
    double  UserCPU;
    double  KernelCPU;
    double  CpuPerTrans;
    double  ReadCount;
    double  WriteCount;
    double  IoPerTrans;
    double  Wset;
} WORKLOAD_RECORD, *PWORKLOAD_RECORD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracectr\mergetl.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    mergetl.c

Abstract:

    Converts multiple ETL files into a single ordered ETL files. 

Author:

    Melur Raghuraman (Mraghu)  9-Dec-2000   

Revision History:


--*/

#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <wmium.h>
#include <ntwmi.h>
#include <wmiumkm.h>
#include <evntrace.h>
#include "cpdata.h"
#include "tracectr.h"


#define MAXSTR              1024
#define LOGGER_NAME         _T("{28ad2447-105b-4fe2-9599-e59b2aa9a634}")

#define MAX_RETRY_COUNT      10

#define ETW_PROC_MISMATCH       0x00000001
#define ETW_MACHINE_MISMATCH    0x00000002 
#define ETW_CLOCK_MISMATCH      0x00000004
#define ETW_BOOTTIME_MISMATCH   0x00000008
#define ETW_VERSION_MISMATCH    0x00000010

TRACEHANDLE LoggerHandle;
ULONG TotalRelogBuffersRead = 0;
ULONG TotalRelogEventsRead = 0;
ULONG FailedEvents=0;

GUID TransactionGuid =
    {0xab8bb8a1, 0x3d98, 0x430c, 0x92, 0xb0, 0x78, 0x8f, 0x1d, 0x3f, 0x6e, 0x94};
GUID   ControlGuid[2]  =
{
    {0x42ae6427, 0xb741, 0x4e69, 0xb3, 0x95, 0x38, 0x33, 0x9b, 0xb9, 0x91, 0x80},
    {0xb9e2c2d6, 0x95fb, 0x4841, 0xa3, 0x73, 0xad, 0x67, 0x2b, 0x67, 0xb6, 0xc1}
};

typedef struct _USER_MOF_EVENT {
    EVENT_TRACE_HEADER    Header;
    MOF_FIELD             mofData;
} USER_MOF_EVENT, *PUSER_MOF_EVENT;

typedef struct _ETW_RELOG_PROPERTIES {
    LONGLONG  BootTime;
    LONGLONG  PerfFreq;
    LONGLONG  StartTime;
    LONGLONG  StartPerfClock;
    LONGLONG EndTime;
    ULONG     HeaderMisMatch;
    ULONG     BuldNumber;
    ULONG     MaxBufferSize;
    ULONG     NumberOfProcessors;
    ULONG     ClockType; 
    ULONG     TimerResolution;
    ULONG     CpuspeedInMHz;
    ULONG     ProviderVersion;
    ULONG     TotalEventsLost;
    ULONG     TotalBuffersLost;
} ETW_RELOG_PROPERTIES, *PETW_RELOG_PROPERTIES;

TRACE_GUID_REGISTRATION TraceGuidReg[] =
{
    { (LPGUID)&TransactionGuid,
      NULL
    }
};


TRACEHANDLE RegistrationHandle[2];


ULONG InitializeTrace(
    IN LPTSTR ExePath
    );

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

void
WINAPI
EtwDumpEvent(
    PEVENT_TRACE pEvent
);

void
WINAPI
EtwProcessLogHeader(
    PEVENT_TRACE pEvent
    );

ULONG
WINAPI
TerminateOnBufferCallback(
    PEVENT_TRACE_LOGFILE pLog
);

ULONG
WINAPI
BufferCallback(
    PEVENT_TRACE_LOGFILE pLog
    );


USER_MOF_EVENT      UserMofEvent;

BOOLEAN bLoggerStarted = FALSE;
PEVENT_TRACE_LOGFILE pLogFile=NULL;

PEVENT_TRACE_LOGFILE EvmFile[MAXLOGGERS];

ULONG LogFileCount = 0;
PEVENT_TRACE_PROPERTIES pLoggerInfo = NULL;
ULONG LoggerInfoSize = 0;

ETW_RELOG_PROPERTIES EtwRelogProp;


int EtwRelogEtl(
    PTRACE_CONTEXT_BLOCK TraceContext
    )
{
    ULONG Status=ERROR_SUCCESS;
    ULONG i, j;
    TRACEHANDLE HandleArray[MAXLOGGERS];
    ULONG SizeNeeded = 0;
    LPTSTR LoggerName;
    LPTSTR LogFileName;
    TCHAR tstrLogFileName[MAXSTR];
    
    RtlZeroMemory(&EtwRelogProp, sizeof(ETW_RELOG_PROPERTIES) );

    RtlZeroMemory(tstrLogFileName, MAXSTR * sizeof(TCHAR));

    for (i = 0; i < TraceContext->LogFileCount; i++) {
        pLogFile = malloc(sizeof(EVENT_TRACE_LOGFILE));
        if (pLogFile == NULL) {
            Status = ERROR_OUTOFMEMORY;
            goto cleanup;
        }
        RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
        EvmFile[i] =  pLogFile;
        pLogFile->LogFileName = TraceContext->LogFileName[i];
        EvmFile[i]->EventCallback = (PEVENT_CALLBACK) &EtwProcessLogHeader;
        EvmFile[i]->BufferCallback = TerminateOnBufferCallback;
        LogFileCount++;
    }

    if (LogFileCount == 0) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Initialize Trace
    //

    Status = InitializeTrace(_T("tracerpt.exe"));
    if (Status != ERROR_SUCCESS) {
       return Status;
    }
    //
    // Set up the Relog Event
    //

    RtlZeroMemory(&UserMofEvent, sizeof(UserMofEvent));
    UserMofEvent.Header.Size  = sizeof(UserMofEvent);
    UserMofEvent.Header.Flags = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR; 


    for (i = 0; i < LogFileCount; i++) {
        TRACEHANDLE x;

        EvmFile[i]->LogfileHeader.ReservedFlags |= EVENT_TRACE_GET_RAWEVENT; 

        x = OpenTrace(EvmFile[i]);
        HandleArray[i] = x;
        if (HandleArray[i] == (TRACEHANDLE)INVALID_HANDLE_VALUE) {
            Status = GetLastError();
            for (j = 0; j < i; j++)
                CloseTrace(HandleArray[j]);
            goto cleanup;
        }
        Status = ProcessTrace(&x, 1, NULL, NULL);
    }
 
    for (j = 0; j < LogFileCount; j++){
        Status = CloseTrace(HandleArray[j]);
    }


    if (EtwRelogProp.HeaderMisMatch) {
        if (EtwRelogProp.HeaderMisMatch & ETW_CLOCK_MISMATCH) 
            Status = ERROR_INVALID_TIME;
        else if (EtwRelogProp.HeaderMisMatch & ETW_PROC_MISMATCH) 
            Status = ERROR_INVALID_DATA;
    
        goto cleanup;
    }

    if ( (EtwRelogProp.MaxBufferSize == 0) ||
         (EtwRelogProp.NumberOfProcessors == 0) ) {
        goto cleanup;
    }


    //
    // We are past the Error checks. Go ahead and Allocate
    // Storage to Start a logger
    //

    SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAXSTR * sizeof(TCHAR) + LoggerInfoSize;
    pLoggerInfo = (PEVENT_TRACE_PROPERTIES) malloc(SizeNeeded);
    if (pLoggerInfo == NULL) {
        return(ERROR_OUTOFMEMORY);
    }


    RtlZeroMemory(pLoggerInfo, SizeNeeded);

    pLoggerInfo->Wnode.BufferSize = SizeNeeded;
    pLoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    //
    // The relogged file contains a standard time stamp format. 
    //
    pLoggerInfo->Wnode.ClientContext = EtwRelogProp.ClockType;
    pLoggerInfo->Wnode.ProviderId = EtwRelogProp.NumberOfProcessors;
    pLoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + LoggerInfoSize;
    pLoggerInfo->LogFileNameOffset = pLoggerInfo->LoggerNameOffset + MAXSTR * sizeof(TCHAR);
    pLoggerInfo->LogFileMode =  (EVENT_TRACE_PRIVATE_LOGGER_MODE | 
                                 EVENT_TRACE_RELOG_MODE | 
                                 EVENT_TRACE_FILE_MODE_SEQUENTIAL
                                );
    pLoggerInfo->BufferSize = EtwRelogProp.MaxBufferSize / 1024;
    pLoggerInfo->MinimumBuffers = 2; 
    pLoggerInfo->MaximumBuffers = 50;

    LoggerName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LoggerNameOffset);
    LogFileName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LogFileNameOffset);
    _tcscpy(LoggerName, LOGGER_NAME );
    pLoggerInfo->Wnode.Guid = ControlGuid[0];

    if (_tcslen(TraceContext->MergeFileName) ) {
        _tcscpy(LogFileName, TraceContext->MergeFileName);
    }

    //
    // We are Past the Error Checks. Go ahead and redo ProcessTrace
    //

    for (i = 0; i < TraceContext->LogFileCount; i++) {
        TRACEHANDLE x;
        EvmFile[i]->EventCallback = (PEVENT_CALLBACK) &EtwDumpEvent;
        EvmFile[i]->BufferCallback = BufferCallback;

        EvmFile[i]->LogfileHeader.ReservedFlags |= EVENT_TRACE_GET_RAWEVENT;

        x = OpenTrace(EvmFile[i]);
        HandleArray[i] = x;
        if (HandleArray[i] == 0) {
            Status = GetLastError();
            for (j = 0; j < i; j++)
                CloseTrace(HandleArray[j]);
            goto cleanup;
        }
    }

    Status = ProcessTrace(
                          HandleArray,
                          LogFileCount,
                          NULL, 
                          NULL
                         );

    for (j = 0; j < LogFileCount; j++){
        Status = CloseTrace(HandleArray[j]);
    }

    //
    // Need to Stop Trace
    //
    if (bLoggerStarted)
        RtlZeroMemory(pLoggerInfo, SizeNeeded);
        pLoggerInfo->Wnode.BufferSize =  sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAXSTR * sizeof(TCHAR);
        pLoggerInfo->Wnode.Guid = ControlGuid[0];
        pLoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
        pLoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES); 
        pLoggerInfo->LogFileNameOffset = pLoggerInfo->LoggerNameOffset + MAXSTR * sizeof(TCHAR);
        pLoggerInfo->LogFileMode =  (EVENT_TRACE_PRIVATE_LOGGER_MODE | 
                                     EVENT_TRACE_RELOG_MODE | 
                                     EVENT_TRACE_FILE_MODE_SEQUENTIAL
                                    );        
        Status = StopTrace(LoggerHandle, LoggerName, pLoggerInfo);

cleanup:
    for (i = 0; i < LogFileCount; i ++){
        free(EvmFile[i]);
    }

    RtlZeroMemory( &EtwRelogProp, sizeof(ETW_RELOG_PROPERTIES) );
    return Status;
}


void
WINAPI
EtwProcessLogHeader(
    PEVENT_TRACE pEvent
    )
/*++

Routine Description:

    This routine checks to see if the pEvent is a LOGFILE_HEADER
    and if so captures the information on the logfile for validation. 
    
    The following checks are performed. 
    1. Files must be from the same machine. (Verified using machine name)
    2. If different buffersizes are used, largest  buffer size is 
       selected for relogging.
    3. The StartTime and StopTime are the outer most from the files.
    4. The CPUClock type must be the same for all files. If different 
       clock types are used, then the files will be rejected. 

    The routine assumes that the first Event Callback from each file is the
    LogFileHeader callback. 

    Other Issues that could result in a not so useful merged logfile are:
    1. Multiple RunDown records when kernel logfiles are merged. 
    2. Multiple HWConfig records when kernel logfiles are merged
    3. Multiple and conflicting GUidMap records when Application logfiles are merged.
    4. ReLogging 32 bit data in 64 bit system
    

Arguments:


Return Value:

    None. 
--*/
{
    ULONG NumProc;

    if( IsEqualGUID(&pEvent->Header.Guid, &EventTraceGuid) &&
       pEvent->Header.Class.Type == EVENT_TRACE_TYPE_INFO ) {

       PSYSTEM_TRACE_HEADER pSysHeader;
       PTRACE_LOGFILE_HEADER head = (PTRACE_LOGFILE_HEADER)((PUCHAR)pEvent->MofData + sizeof(SYSTEM_TRACE_HEADER) );
       ULONG BufferSize = head->BufferSize;
       pSysHeader = (PSYSTEM_TRACE_HEADER) pEvent->MofData;
       //
       // Pick up the First LogFileHeader's size 
       //
       if (LoggerInfoSize == 0) {
            LPWSTR loggerName;
            LoggerInfoSize = pSysHeader->Packet.Size;
            loggerName = (LPWSTR) ( (char*)pEvent->MofData + sizeof(SYSTEM_TRACE_HEADER) +
                                    sizeof(TRACE_LOGFILE_HEADER) );

       }
       if (LoggerInfoSize < pSysHeader->Packet.Size) {
            LoggerInfoSize = pSysHeader->Packet.Size;
       }

       //
       // Pick up the Largest BufferSize
       //

       if  (BufferSize > EtwRelogProp.MaxBufferSize) {
            EtwRelogProp.MaxBufferSize = BufferSize;
       }

       //
       // Verify the NumberOfProcessors
       //

       NumProc = head->NumberOfProcessors;
       if (EtwRelogProp.NumberOfProcessors) {
            if (EtwRelogProp.NumberOfProcessors != NumProc) {
                EtwRelogProp.HeaderMisMatch |= ETW_PROC_MISMATCH;
            }
       }
       else {
            EtwRelogProp.NumberOfProcessors = NumProc;
       }
       // 
       // Pick up the Earliest StartTime
       //
       if (EtwRelogProp.StartTime) {
           if (head->StartTime.QuadPart < EtwRelogProp.StartTime) {
                EtwRelogProp.StartTime = head->StartTime.QuadPart;
           }
       }
       else {
            EtwRelogProp.StartTime = head->StartTime.QuadPart;
       }

       //
       // Pick up the latest EndTime
       //
       if (EtwRelogProp.EndTime) {
           if (head->EndTime.QuadPart > EtwRelogProp.EndTime) {
                EtwRelogProp.EndTime = head->EndTime.QuadPart;
           }
       }
       else {
            EtwRelogProp.EndTime = head->EndTime.QuadPart;
       }




       if (EtwRelogProp.StartPerfClock) {
            PSYSTEM_TRACE_HEADER pSysHeader = (PSYSTEM_TRACE_HEADER) ((PUCHAR)pEvent->MofData);
            if (pSysHeader->SystemTime.QuadPart < EtwRelogProp.StartPerfClock) {
                EtwRelogProp.StartPerfClock = pSysHeader->SystemTime.QuadPart;
            }
       }
       else {
            PSYSTEM_TRACE_HEADER pSysHeader = (PSYSTEM_TRACE_HEADER) ((PUCHAR)pEvent->MofData);
            EtwRelogProp.StartPerfClock = pSysHeader->SystemTime.QuadPart;
       }

       //
       // Verify the Clock Type
       //

       if (EtwRelogProp.ClockType) {
            if (head->ReservedFlags != EtwRelogProp.ClockType) {
                EtwRelogProp.HeaderMisMatch |= ETW_CLOCK_MISMATCH;
            }
       }
       else {
            EtwRelogProp.ClockType = head->ReservedFlags;
       }

       if (EtwRelogProp.PerfFreq) { 
            if (EtwRelogProp.PerfFreq != head->PerfFreq.QuadPart) {
                EtwRelogProp.HeaderMisMatch |= ETW_MACHINE_MISMATCH;
            }
       }
       else {
            EtwRelogProp.PerfFreq = head->PerfFreq.QuadPart;
       }

       //
       // Verify Machine Name
       //

       // CPU Name is in the CPU Configuration record 
       // which can be version dependent and found only on Kernel Logger

       // 
       // Verify Build Number
       //
      if (EtwRelogProp.ProviderVersion) {
        if (EtwRelogProp.ProviderVersion != head->ProviderVersion) {
            EtwRelogProp.HeaderMisMatch |= ETW_VERSION_MISMATCH;
            }
       }
       else {
            EtwRelogProp.ProviderVersion = head->ProviderVersion;
       } 

       //
       // Boot Time Verification?
       //
       if (EtwRelogProp.BootTime) {
            if (EtwRelogProp.BootTime != head->BootTime.QuadPart) {
                EtwRelogProp.HeaderMisMatch |= ETW_BOOTTIME_MISMATCH;
            }
       }
       else {
            EtwRelogProp.BootTime = head->BootTime.QuadPart;
       }

       //
       // Sum up Events Lost from each file
       //

       EtwRelogProp.TotalEventsLost += head->EventsLost;
       EtwRelogProp.TotalBuffersLost += head->BuffersLost;

    }
}

void
WINAPI
EtwDumpEvent(
    PEVENT_TRACE pEvent
    )
{
    PEVENT_TRACE_HEADER pHeader;
    ULONG Status = ERROR_SUCCESS;
    ULONG CachedFlags;
    USHORT CachedSize;
    ULONG RetryCount = 0;

    if (pEvent == NULL) {
        return;
    }
    
    TotalRelogEventsRead++;

    if (!bLoggerStarted) {
        PSYSTEM_TRACE_HEADER pSysHeader;
        ULONG CachedBufferSize = 0;
        PSYSTEM_TRACE_HEADER pTarget;
        PTRACE_LOGFILE_HEADER pLogFileHeader;
        LPWSTR loggerName;

        // Assume that this first Event is the LogFileHeader and validate its size
        pSysHeader = (PSYSTEM_TRACE_HEADER) pEvent->MofData;
        pTarget  = (PSYSTEM_TRACE_HEADER) ((PUCHAR)pLoggerInfo + 
                                            sizeof(EVENT_TRACE_PROPERTIES) ); 
        pLogFileHeader = (PTRACE_LOGFILE_HEADER) ((PUCHAR)pTarget + 
                                            sizeof(SYSTEM_TRACE_HEADER) );
        loggerName = (LPWSTR) ( (char*)pEvent->MofData + sizeof(SYSTEM_TRACE_HEADER) +
                                sizeof(TRACE_LOGFILE_HEADER) );

        if (LoggerInfoSize < pSysHeader->Packet.Size) {
            exit(-1);
        }

        CachedBufferSize = pLogFileHeader->BufferSize;
        pLogFileHeader->BufferSize = EtwRelogProp.MaxBufferSize;
        pLogFileHeader->EventsLost = EtwRelogProp.TotalEventsLost;
        pLogFileHeader->BuffersLost = EtwRelogProp.TotalBuffersLost;

        pLogFileHeader->EndTime.QuadPart = EtwRelogProp.EndTime;
        pLogFileHeader->StartTime.QuadPart = EtwRelogProp.StartTime;

        RtlCopyMemory(pTarget, pSysHeader, LoggerInfoSize);


        Status = StartTrace(&LoggerHandle, LOGGER_NAME, pLoggerInfo);

        pLogFileHeader->BufferSize = CachedBufferSize;

        if (Status != ERROR_SUCCESS) {
           return;
        }
        bLoggerStarted = TRUE;

        return;
    }

    pHeader = (PEVENT_TRACE_HEADER)pEvent->MofData;

    CachedSize = pEvent->Header.Size;
    CachedFlags = pEvent->Header.Flags;

    pEvent->Header.Size = sizeof(EVENT_TRACE);
    pEvent->Header.Flags |= (WNODE_FLAG_TRACED_GUID | WNODE_FLAG_NO_HEADER);

    do {
        Status = TraceEvent(LoggerHandle, (PEVENT_TRACE_HEADER)pEvent );
        if ( ( Status == ERROR_OUTOFMEMORY) && (RetryCount++ < MAX_RETRY_COUNT) ) {
            _sleep(500);    // Sleep for half a second. 
        }
        else {
            break;
        }   
    } while (TRUE);
    

    if (Status != ERROR_SUCCESS) {
        FailedEvents++;
    }

    //
    // Restore Cached values
    //
    pEvent->Header.Size = CachedSize;
    pEvent->Header.Flags = CachedFlags;
}


ULONG InitializeTrace(
    IN LPTSTR ExePath
    )
{
    ULONG Status;

    Status = RegisterTraceGuids(
                    (WMIDPREQUEST)ControlCallback,
                    NULL,
                    (LPCGUID)&ControlGuid[0],
                    1,
                    &TraceGuidReg[0],
                    NULL,
                    NULL, 
                    &RegistrationHandle[0]
                 );

    return(Status);
}

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{

    return ERROR_SUCCESS;

}



ULONG
WINAPI
TerminateOnBufferCallback(
    PEVENT_TRACE_LOGFILE pLog
    )
{
    return (FALSE); // Terminate ProcessTrace on First BufferCallback
}

ULONG
WINAPI
BufferCallback(
    PEVENT_TRACE_LOGFILE pLog
    )
{
    TotalRelogBuffersRead++;
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracectr\tracectr.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pdhp.h

Abstract:

    PDH private APIs. Converts WMI event trace data to perf counters

Author:

    Melur Raghuraman (mraghu) 03-Oct-1997

Environment:

Revision History:


--*/

#ifndef __TRACECTR__01042001_
#define __TRACECTR__01042001_

#include <wchar.h>
#include <pdh.h>

#ifdef __cplusplus
extern "C" {
#endif

/*****************************************************************************\
    Trace Section
\*****************************************************************************/

#define CPDAPI  __stdcall

#define TRACE_LOGGER_START_IF 0x00000001
#define TRACE_LOGGER_EXISTING 0x00000002

#define TRACE_ZERO_ON_QUERY   0x00000004
#define TRACE_REDUCE          0x00000008
#define TRACE_LOG_REPLAY      0x00000010
#define TRACE_DS_ONLY         0x00000020
#define TRACE_SPOOLER         0x00000040
#define TRACE_DUMP            0x00000080
#define TRACE_USE_WBEM        0x00000100
#define TRACE_EXTENDED_FMT    0x00000200
#define TRACE_SUMMARY         0x00000400
#define TRACE_MERGE_ETL       0x00000800
#define TRACE_INTERPRET       0x00001000

#define TRACE_LOG_REPORT_MEMORY    0x00000100
#define TRACE_LOG_REPORT_HARDFAULT 0x00000200
#define TRACE_LOG_REPORT_BASIC     0x00000400
#define TRACE_LOG_REPORT_TOTALS    0x00000800
#define TRACE_LOG_REPORT_FILE      0x00001000

#define DEFAULT_FILE_REPORT_SIZE   50

typedef enum _TRACEINFOCLASS {
    TraceProcessInformation,
    TraceFileInformation,
    TraceThreadInformation,
    TraceDiskInformation,
    TraceTransactionInformation,
    TraceModuleInformation,
    TraceProcessPageFaultInformation
} TRACEINFOCLASS;

typedef enum _MM_REPORT_TYPE
{
    REPORT_SUMMARY_PROCESS,
    REPORT_SUMMARY_MODULE,
    REPORT_LIST_PROCESS,
    REPORT_LIST_MODULE
} MM_REPORT_TYPE;

typedef enum _MM_REPORT_SORT_KEY
{
    REPORT_SORT_ALL,
    REPORT_SORT_HPF,
    REPORT_SORT_TF,
    REPORT_SORT_DZF,
    REPORT_SORT_COW
} MM_REPORT_SORT_KEY;

typedef struct _USER_CONTEXT_MM
{
    MM_REPORT_TYPE     reportNow;
    MM_REPORT_SORT_KEY sortNow;
    PWCHAR             strImgName;
} CPD_USER_CONTEXT_MM, * PCPD_USER_CONTEXT_MM;

typedef struct _TRACE_MODULE_INFO
{
    ULONG       PID;
    ULONG       lBaseAddress;
    ULONG       lModuleSize;
    ULONG       lDataFaultHF;
    ULONG       lDataFaultTF;
    ULONG       lDataFaultDZF;
    ULONG       lDataFaultCOW;
    ULONG       lCodeFaultHF;
    ULONG       lCodeFaultTF;
    ULONG       lCodeFaultDZF;
    ULONG       lCodeFaultCOW;
    ULONG       NextEntryOffset;    // From the Current; Not from the top. 
    LPWSTR      strModuleName;
    LPWSTR      strImageName;
} TRACE_MODULE_INFO, * PTRACE_MODULE_INFO;

typedef struct _TRACE_PROCESS_FAULT_INFO {
    ULONG    PID;
    ULONG    lDataFaultHF;
    ULONG    lDataFaultTF;
    ULONG    lDataFaultDZF;
    ULONG    lDataFaultCOW;
    ULONG    lCodeFaultHF;
    ULONG    lCodeFaultTF;
    ULONG    lCodeFaultDZF;
    ULONG    lCodeFaultCOW;
    ULONG    NextEntryOffset;
    LPWSTR   ImageName;
} TRACE_PROCESS_FAULT_INFO, *PTRACE_PROCESS_FAULT_INFO;

typedef struct _TRACE_TRANSACTION_INFO {
    ULONG   TransactionCount;
    ULONG   AverageResponseTime;    // in milliseconds
    ULONG   MaxResponseTime;
    ULONG   MinResponseTime;
    ULONG   NextEntryOffset;
    LPWSTR  Name;
} TRACE_TRANSACTION_INFO, *PTRACE_TRANSACTION_INFO;

typedef struct _TRACE_FILE_INFOW {
    ULONG   ReadCount;
    ULONG   WriteCount;
    ULONG   ReadSize;
    ULONG   WriteSize;
    ULONG   NextEntryOffset;    // From the Current; Not from the top. 
    LPWSTR  FileName;  // The string immediatealy follows this structure. 
    ULONG   DiskNumber;
} TRACE_FILE_INFOW, *PTRACE_FILE_INFOW;

typedef struct _TRACE_PROCESS_INFOW {
    ULONG    ReadCount;
    ULONG    WriteCount;
    ULONG    ReadSize;
    ULONG    WriteSize;
    ULONG    SendCount;
    ULONG    RecvCount;
    ULONG    SendSize;
    ULONG    RecvSize;
    ULONG    NextEntryOffset;
    LPWSTR   ImageName;
    ULONG    PID;
    ULONG    DeadFlag; 
    ULONG    HPF;
    ULONG    SPF;
    ULONG    PrivateWSet;
    ULONG    GlobalWSet;
    ULONG   UserCPU;
    ULONG   KernelCPU;
    ULONG   TransCount;
    ULONGLONG   LifeTime;
    ULONGLONG   ResponseTime;
    ULONGLONG   TxnStartTime;
    ULONGLONG   TxnEndTime; 
    LPWSTR      UserName;
} TRACE_PROCESS_INFOW, *PTRACE_PROCESS_INFOW;

typedef struct _TRACE_THREAD_INFO {
    ULONG     ThreadId;
} TRACE_THREAD_INFO, *PTRACE_THREAD_INFO;

typedef struct _TRACE_DISK_INFOW {
    ULONG   ReadCount;
    ULONG   WriteCount;
    ULONG   ReadSize;
    ULONG   WriteSize;
    ULONG   NextEntryOffset;
    LPWSTR  DiskName;
    ULONG   DiskNumber;
} TRACE_DISK_INFOW, *PTRACE_DISK_INFOW;

//
// tracelib will not start up a logger anymore. It is external to the dll
// You can provide either Logfiles or LoggerNames (RealTime) as data feed
//
typedef struct _TRACE_BASIC_INFOW {
    ULONG     FlushTimer;
    HANDLE    hEvent;
    ULONG     LogFileCount;
    ULONG     LoggerCount;
    LPCWSTR    *LogFileName;
    LPCWSTR    *LoggerName;
    LPCWSTR     MergeFileName;
    LPCWSTR     ProcFileName;
    LPCWSTR     SummaryFileName;
    LPCWSTR     DumpFileName;
    LPCWSTR     MofFileName;
    LPCWSTR     CompFileName;
    ULONGLONG StartTime;
    ULONGLONG EndTime;
    ULONGLONG DSStartTime;
    ULONGLONG DSEndTime;
    ULONG Flags;
    PVOID     pUserContext;
} TRACE_BASIC_INFOW, *PTRACE_BASIC_INFOW;

#define TRACE_FILE_INFO TRACE_FILE_INFOW
#define PTRACE_FILE_INFO PTRACE_FILE_INFOW
#define TRACE_PROCESS_INFO  TRACE_PROCESS_INFOW
#define PTRACE_PROCESS_INFO PTRACE_PROCESS_INFOW
#define TRACE_DISK_INFO TRACE_DISK_INFOW
#define PTRACE_DISK_INFO PTRACE_DISK_INFOW
#define TRACE_BASIC_INFO   TRACE_BASIC_INFOW
#define PTRACE_BASIC_INFO  PTRACE_BASIC_INFOW

//
// APIs 
//

HRESULT 
CPDAPI
GetTempName( LPTSTR strFile, DWORD dwSize );

BOOLEAN
CPDAPI
TraceCtrDllInitialize (
    HINSTANCE hinstDll,
    DWORD fdwReason,
    LPVOID fImpLoad
    );


ULONG 
CPDAPI
InitTraceContextW(
    IN OUT PTRACE_BASIC_INFOW pTraceBasic
    );

ULONG
CPDAPI
DeinitTraceContext(
    IN OUT PTRACE_BASIC_INFO pTraceBasic
    );


//
// Gets all instances of the Trace information. Caller provides 
// storage and frees it. If the information does not fit, returns 
// as much will go in the buffer provided and returns the Length
// of data stuffed. 
//

ULONG
CPDAPI
GetMaxLoggers();

ULONG 
CPDAPI
TraceQueryAllInstances (
    IN TRACEINFOCLASS  TraceInformationClass,
    OUT PVOID TraceInformation,
    IN ULONG TraceInformationLength,
    OUT PULONG Length
    );

ULONG
CPDAPI
TraceDrillDownW(
    IN TRACEINFOCLASS RootInformationClass,
    IN LPCWSTR InstanceName,
    IN TRACEINFOCLASS TraceInformationClass,
    OUT PVOID TraceInformation,
    IN ULONG TraceInforamationLength,
    OUT PULONG Length
    );

ULONG 
CPDAPI
TraceSetTimer (
    IN ULONG FlushTimer
    );

#define TraceDrillDown      TraceDrillDownW
#define InitTraceContext    InitTraceContextW



#ifdef __cplusplus
}
#endif

#endif // __TRACECTR__01042001_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracedmp\tracedmp.cpp ===
// begin_sdk
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    tracedmp.c

Abstract:

    Sample trace consumer program. Converts binary 
    Event Trace Log (ETL) to CSV format

// end_sdk
Author:

    Jee Fung Pang (jeepang) 03-Dec-1997

Revision History:
    Corey Morgan (coreym) 24-May-2000   Added MOF version support

    Insung Park (insungp) 16-Jan-2001

    tracedmp no longer uses MOF data file. All the layout information 
    comes from the WBEM namespace. Also added support for float numbers.
    Also added comments for all the functions.

// begin_sdk
--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <wbemidl.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>
#include <objidl.h>

#define MAXLOGFILES         16
#define MAXSTR              1024
#define MOFWSTR             16360
#define MOFSTR              32720
#define MAXTYPE             256
#define UC(x)               ( (UINT)((x) & 0xFF) )
#define NTOHS(x)            ( (UC(x) * 256) + UC((x) >> 8) )
// Maximum number of properties per WBEM class object: may need to be changed
#define MAXPROPS            256

#define DUMP_FILE_NAME          _T("DumpFile.csv")
#define SUMMARY_FILE_NAME       _T("Summary.txt")

#define DEFAULT_LOGFILE_NAME    _T("C:\\Logfile.Etl")

#define DEFAULT_NAMESPACE       _T("root\\wmi")

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))
#define CHECK_WBEM_HR( hr ) if( WBEM_NO_ERROR != hr ){ WbemError(hr); goto cleanup; }

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

#define GUID_TYPE_EVENTTRACE            _T("EventTrace")
#define GUID_TYPE_HEADER                _T("Header")
#define GUID_TYPE_UNKNOWN               _T("Unknown")
#define GUID_TYPE_DEFAULT               _T("Default")

#define EVENT_TYPE_DEFAULT              (-1)
#define EVENT_LEVEL_DEFAULT             (-1)
#define EVENT_VERSION_DEFAULT           (-1)

#define STR_ItemChar                    _T("ItemChar")
#define STR_ItemWChar                   _T("ItemWChar")
#define STR_ItemUChar                   _T("ItemUChar")
#define STR_ItemCharShort               _T("ItemCharShort")
#define STR_ItemShort                   _T("ItemShort")
#define STR_ItemUShort                  _T("ItemUShort")
#define STR_ItemLong                    _T("ItemLong")
#define STR_ItemULong                   _T("ItemULong")
#define STR_ItemULongX                  _T("ItemULongX")
#define STR_ItemLongLong                _T("ItemLongLong")
#define STR_ItemULongLong               _T("ItemULongLong")
#define STR_ItemFloat                   _T("ItemFloat");
#define STR_ItemDouble                  _T("ItemDouble");
#define STR_ItemString                  _T("ItemString")
#define STR_ItemWString                 _T("ItemWString")
// end_sdk
#define STR_ItemRString                 _T("ItemRString")
#define STR_ItemRWString                _T("ItemRWString")
// begin_sdk
#define STR_ItemPString                 _T("ItemPString")
#define STR_ItemPWString                _T("ItemPWString")
#define STR_ItemDSString                _T("ItemDSString")
#define STR_ItemDSWString               _T("ItemDSWString")
#define STR_ItemMLString                _T("ItemMLString")
#define STR_ItemSid                     _T("ItemSid")
#define STR_ItemIPAddr                  _T("ItemIPAddr")
#define STR_ItemPort                    _T("ItemPort")
#define STR_ItemNWString                _T("ItemNWString")
#define STR_ItemPtr                     _T("ItemPtr")
#define STR_ItemGuid                    _T("ItemGuid")
// end_sdk
#define STR_ItemVariant                 _T("ItemVariant")
// begin_sdk
#define STR_ItemBool                    _T("ItemBool")
// end_sdk
#define STR_ItemCPUTime                 _T("ItemCPUTime")
#define STR_ItemOptArgs                 _T("ItemOptArgs")
// begin_sdk

// Data types supported in this consumer.
typedef enum _ITEM_TYPE {
// end_sdk
    ItemCPUTime,
    ItemOptArgs,
// begin_sdk
    ItemChar,
    ItemWChar,
    ItemUChar,
    ItemCharShort,
    ItemShort,
    ItemUShort,
    ItemLong,
    ItemULong,
    ItemULongX,
    ItemLongLong,
    ItemULongLong,
    ItemFloat,
    ItemDouble,
    ItemString,
    ItemWString,
// end_sdk
    ItemRString,
    ItemRWString,
// begin_sdk
    ItemPString,
    ItemPWString,
    ItemDSString,
    ItemDSWString,
    ItemSid,
    ItemIPAddr,
    ItemPort,
    ItemMLString,
    ItemNWString,        // Non-null terminated Wide Char String
    ItemPtr,
    ItemGuid,
// end_sdk
    ItemVariant,
// begin_sdk
    ItemBool,
    ItemUnknown
} ITEM_TYPE;

// Construct that represents an event layout
typedef struct _MOF_INFO {
    LIST_ENTRY   Entry;
    LPTSTR       strDescription;        // Class Name
    ULONG        EventCount;
    GUID         Guid;
    PLIST_ENTRY  ItemHeader;
    LPTSTR       strType;               // Type Name
    SHORT        TypeIndex;
    SHORT        Version;
    CHAR         Level;
}  MOF_INFO, *PMOF_INFO;

typedef struct _ITEM_DESC *PITEM_DESC;
// Construct that represents one data item
typedef struct _ITEM_DESC {
    LIST_ENTRY  Entry;
    LPTSTR      strDescription;
    ULONG       DataSize;
    ITEM_TYPE   ItemType;
    UINT        ArraySize;
} ITEM_DESC;

void
PrintHelpMessage();

PMOF_INFO
GetNewMofInfo( 
    GUID guid, 
    SHORT nType, 
    SHORT nVersion, 
    CHAR nLevel 
);

void
AddMofInfo(
    PLIST_ENTRY List,
    LPTSTR  strType,
    ITEM_TYPE   nType,
    UINT    ArraySize
);

HRESULT
WbemConnect( 
    IWbemServices** pWbemServices 
);

ULONG GetArraySize(
    IN IWbemQualifierSet *pQualSet
);

ITEM_TYPE
GetItemType(
    IN CIMTYPE_ENUMERATION CimType, 
    IN IWbemQualifierSet *pQualSet
);

PMOF_INFO
GetPropertiesFromWBEM(
    IWbemClassObject *pTraceSubClasses, 
    GUID Guid,
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType
);

PMOF_INFO
GetGuids( 
    GUID Guid, 
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType
);

ULONG 
ahextoi(
    TCHAR *s
);

// end_sdk
static 
void 
reduceW(
    WCHAR *Src
);

static 
void 
reduceA(
    char *Src
);
// begin_sdk

PMOF_INFO
GetMofInfoHead(
    GUID Guid,
    SHORT  nType,
    SHORT nVersion,
    CHAR  nLevel
);

ULONG
CheckFile(
    LPTSTR fileName
);

void
CleanupEventList(
    VOID
);

ULONG
WINAPI
BufferCallback(
    PEVENT_TRACE_LOGFILE pLog
);

void
WINAPI
DumpEvent(
    PEVENT_TRACE pEvent
);

void
RemoveMofInfo(
    PLIST_ENTRY pMofInfo
);

void
GuidToString(
    PTCHAR s,
    LPGUID piid
);

HRESULT 
ParseTime( 
    LPTSTR strTime, 
    SYSTEMTIME* pstTime 
);

// output files
FILE* DumpFile = NULL;
FILE* SummaryFile = NULL;

static ULONG TotalBuffersRead = 0;
static ULONG TotalEventsLost = 0;
static ULONG TotalEventCount = 0;
static ULONG TimerResolution = 10;
// end_sdk
static ULONG SysTimerResolution = 100000;
// begin_sdk
static ULONGLONG StartTime   = 0;
static ULONGLONG EndTime     = 0;
static BOOL   fNoEndTime  = FALSE;
static __int64 ElapseTime;

PCHAR  MofData    = NULL;
size_t MofLength  = 0;
BOOLEAN fSummaryOnly  = FALSE;
BOOLEAN fDebugDisplay = FALSE;
// end_sdk
BOOLEAN fIgnorePerfClock = FALSE;
// begin_sdk
BOOLEAN fRealTimeCircular = FALSE;
ULONG PointerSize = sizeof(PVOID) * 8;

// Global head for event layout linked list 
PLIST_ENTRY EventListHead = NULL;

// log files
PEVENT_TRACE_LOGFILE EvmFile[MAXLOGFILES];

ULONG LogFileCount = 0;
BOOL g_bUserMode = FALSE;
// end_sdk
TCHAR ComputerName[MAXSTR];
DWORD ComputerNameLength = 0;
// begin_sdk
// cached Wbem pointer
IWbemServices *pWbemServices = NULL;

int __cdecl main (int argc, LPTSTR* argv)
/*++

Routine Description:

    It is the main function.

Arguments:
Usage: tracedmp [options]  <EtlFile1 EtlFile2 ...>| [-h | -? | -help]
        -o <file>          Output CSV file
        -rt [LoggerName]   Realtime tracedmp from the logger [LoggerName]
        -summary           Summary.txt only
        -begin HH:MM DD/MM/YY
        -end   HH:MM DD/MM/YY
        -h
        -help
        -?                 Display usage information

Return Value:

    Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS (== 0).

--*/
{
    TCHAR DumpFileName[MAXSTR];
    TCHAR SummaryFileName[MAXSTR];

    LPTSTR *targv;
    FILETIME ftStart;
    FILETIME ftEnd;
    SYSTEMTIME st;

#ifdef UNICODE
    LPTSTR *cmdargv;
#endif

    PEVENT_TRACE_LOGFILE pLogFile;
    ULONG Status = ERROR_SUCCESS;
    ULONG i, j;
    TRACEHANDLE HandleArray[MAXLOGFILES];

#ifdef UNICODE
    if ((cmdargv = CommandLineToArgvW(
                        GetCommandLineW(),  // pointer to a command-line string
                        &argc               // receives the argument count
                        )) == NULL)
    {
        return(GetLastError());
    };
    targv = cmdargv ;
#else
    targv = argv;
#endif

    RtlZeroMemory( &ftStart, sizeof(FILETIME) );
    RtlZeroMemory( &ftEnd, sizeof(FILETIME) );

    _tcscpy(DumpFileName, DUMP_FILE_NAME);
    _tcscpy(SummaryFileName, SUMMARY_FILE_NAME);

    while (--argc > 0) {
        ++targv;
        if (**targv == '-' || **targv == '/') {  // argument found
            if( **targv == '/' ){
                **targv = '-';
            }
            if ( !_tcsicmp(targv[0], _T("-begin") )) {
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        TCHAR buffer[MAXSTR];
                        _tcscpy( buffer, targv[1] );
                        _tcscat( buffer, _T(" ") );
                        ++targv; --argc;
                        if (targv[1][0] != '-' && targv[1][0] != '/'){
                            _tcscat( buffer, targv[1] );
                            ParseTime( buffer, &st );
                            SystemTimeToFileTime( &st, &ftStart );
                            ++targv; --argc;
                        }
                    }
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-end")) ) {
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        TCHAR buffer[MAXSTR];
                        _tcscpy( buffer, targv[1] );
                        _tcscat( buffer, _T(" ") );
                        ++targv; --argc;
                        if (targv[1][0] != '-' && targv[1][0] != '/'){
                            _tcscat( buffer, targv[1] );
                            ParseTime( buffer, &st );
                            SystemTimeToFileTime( &st, &ftEnd );
                            ++targv; --argc;
                        }
                    }
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-summary")) ) {
                fSummaryOnly = TRUE;
            }
            else if ( !_tcsicmp(targv[0], _T("-debug")) ) {
                fDebugDisplay = TRUE;
            }
// end_sdk
            else if ( !_tcsicmp(targv[0], _T("-IgnorePerfClock")) ) {
                fIgnorePerfClock = TRUE;
            }
// begin_sdk
            else if ( !_tcsicmp(targv[0], _T("-RealTimeCircular")) ) {
                fRealTimeCircular = TRUE;
            }
            else if (targv[0][1] == 'h' || targv[0][1] == 'H'
                                       || targv[0][1] == '?')
            {
                PrintHelpMessage();
                return 0;
            }
            else if ( !_tcsicmp(targv[0], _T("-rt")) ) {
                TCHAR LoggerName[MAXSTR];
                _tcscpy(LoggerName, KERNEL_LOGGER_NAME);
                if (argc > 1) {
                   if (targv[1][0] != '-' && targv[1][0] != '/') {
                       ++targv; --argc;
                       _tcscpy(LoggerName, targv[0]);
                   }
                }
               
                pLogFile = (PEVENT_TRACE_LOGFILE) malloc(sizeof(EVENT_TRACE_LOGFILE));
                if (pLogFile == NULL){
                    _tprintf(_T("Allocation Failure\n"));
                    Status = ERROR_OUTOFMEMORY;
                    goto cleanup;
                }
                RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
                EvmFile[LogFileCount] = pLogFile;
               
                EvmFile[LogFileCount]->LogFileName = NULL;
                EvmFile[LogFileCount]->LoggerName =
                    (LPTSTR) malloc(MAXSTR*sizeof(TCHAR));
               
                if ( EvmFile[LogFileCount]->LoggerName == NULL ) {
                    _tprintf(_T("Allocation Failure\n"));
                    Status = ERROR_OUTOFMEMORY;
                    goto cleanup;
                }
                _tcscpy(EvmFile[LogFileCount]->LoggerName, LoggerName);
               
                _tprintf(_T("Setting RealTime mode for  %s\n"),
                        EvmFile[LogFileCount]->LoggerName);
               
                EvmFile[LogFileCount]->Context = NULL;
                EvmFile[LogFileCount]->BufferCallback = BufferCallback;
                EvmFile[LogFileCount]->BuffersRead = 0;
                EvmFile[LogFileCount]->CurrentTime = 0;
                EvmFile[LogFileCount]->EventCallback = &DumpEvent;
                EvmFile[LogFileCount]->LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
                LogFileCount++;
            }
            else if ( !_tcsicmp(targv[0], _T("-o")) ) {
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        TCHAR drive[10];
                        TCHAR path[MAXSTR];
                        TCHAR file[MAXSTR];
                        TCHAR ext[MAXSTR];
                        ++targv; --argc;

                        _tfullpath(DumpFileName, targv[0], MAXSTR);
                        _tsplitpath( DumpFileName, drive, path, file, ext );
                        _tcscpy(ext,_T("csv"));
                        _tmakepath( DumpFileName, drive, path, file, ext );
                        _tcscpy(ext,_T("txt"));  
                        _tmakepath( SummaryFileName, drive, path, file, ext );
                    }
                }
            }
        }
        else {
            pLogFile = (PEVENT_TRACE_LOGFILE) malloc(sizeof(EVENT_TRACE_LOGFILE));
            if (pLogFile == NULL){ 
                _tprintf(_T("Allocation Failure\n"));
                Status = ERROR_OUTOFMEMORY;
                goto cleanup;
            }
            RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
            EvmFile[LogFileCount] = pLogFile;

            EvmFile[LogFileCount]->LoggerName = NULL;
            EvmFile[LogFileCount]->LogFileName = 
                (LPTSTR) malloc(MAXSTR*sizeof(TCHAR));
            if (EvmFile[LogFileCount]->LogFileName == NULL) {
                _tprintf(_T("Allocation Failure\n"));
                Status = ERROR_OUTOFMEMORY;
                goto cleanup;
            }
            
            _tfullpath(EvmFile[LogFileCount]->LogFileName, targv[0], MAXSTR);
            _tprintf(_T("Setting log file to: %s\n"),
                     EvmFile[LogFileCount]->LogFileName);
            // If one of the log files is not readable, exit.
            if (!CheckFile(EvmFile[LogFileCount]->LogFileName)) {
                _tprintf(_T("Cannot open logfile for reading\n"));
                Status = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            EvmFile[LogFileCount]->Context = NULL;
            EvmFile[LogFileCount]->BufferCallback = BufferCallback;
            EvmFile[LogFileCount]->BuffersRead = 0;
            EvmFile[LogFileCount]->CurrentTime = 0;
            EvmFile[LogFileCount]->EventCallback = &DumpEvent;
            LogFileCount++;
        }
    }

    if (LogFileCount <= 0) {
        PrintHelpMessage();
        return Status;
    }

    for (i = 0; i < LogFileCount; i++) {
        TRACEHANDLE x;

// end_sdk
        if (fIgnorePerfClock)
            EvmFile[i]->LogfileHeader.ReservedFlags |= 0x00000002;
// begin_sdk
        if (fRealTimeCircular)
            EvmFile[i]->LogfileHeader.ReservedFlags |= 0x00000004;
        x = OpenTrace(EvmFile[i]);
        HandleArray[i] = x;
        if (HandleArray[i] == 0) {
            Status = GetLastError();
            _tprintf(_T("Error Opening Trace %d with status=%d\n"), 
                                                           i, Status);

            for (j = 0; j < i; j++)
                CloseTrace(HandleArray[j]);
            goto cleanup;
        }
    }

    if (!fSummaryOnly)
    {
        DumpFile = _tfopen(DumpFileName, _T("w"));
        if (DumpFile == NULL) {
            Status = ERROR_INVALID_PARAMETER;
            _tprintf(_T("DumpFile is NULL\n"));
            goto cleanup;
        }
    }
    SummaryFile = _tfopen(SummaryFileName, _T("w"));
    if (SummaryFile == NULL) {
        Status = ERROR_INVALID_PARAMETER;
        _tprintf(_T("SummaryFile is NULL\n"));
        goto cleanup;
    }

    if (!fSummaryOnly)
    {
        _ftprintf(DumpFile,
            _T("%12s, %10s,%7s,%21s,%11s,%11s, User Data\n"),
            _T("Event Name"), _T("Type"), _T("TID"), _T("Clock-Time"),
            _T("Kernel(ms)"), _T("User(ms)")
            );
    }

    Status = ProcessTrace(
            HandleArray,
            LogFileCount,
            &ftStart,
            &ftEnd
            );

    if (Status != ERROR_SUCCESS) {
        _tprintf(_T("Error processing with status=%dL (GetLastError=0x%x)\n"),
                Status, GetLastError());
    }

    for (j = 0; j < LogFileCount; j++){
        Status = CloseTrace(HandleArray[j]);
        if (Status != ERROR_SUCCESS) {
            _tprintf(_T("Error Closing Trace %d with status=%d\n"), j, Status);
        }
    }

    _ftprintf(SummaryFile,_T("Files Processed:\n"));
    for (i=0; i<LogFileCount; i++) {
        _ftprintf(SummaryFile,_T("\t%s\n"),EvmFile[i]->LogFileName);
    }

    ElapseTime = EndTime - StartTime;
    _ftprintf(SummaryFile,
              _T("Total Buffers Processed %d\n")
              _T("Total Events  Processed %d\n")
              _T("Total Events  Lost      %d\n")
              _T("Start Time              0x%016I64X\n")
              _T("End Time                0x%016I64X\n")
              _T("Elapsed Time            %I64d sec\n"), 
              TotalBuffersRead,
              TotalEventCount,
              TotalEventsLost,
              StartTime,
              EndTime,
              (ElapseTime / 10000000) );

    _ftprintf(SummaryFile,
       _T("+-------------------------------------------------------------------------------------+\n")
       _T("|%10s    %-20s %-10s  %-36s  |\n")
       _T("+-------------------------------------------------------------------------------------+\n"),
       _T("EventCount"),
       _T("EventName"),
       _T("EventType"),
       _T("Guid")
        );

    CleanupEventList();

    _ftprintf(SummaryFile,
           _T("+-------------------------------------------------------------------------------------+\n")
        );

cleanup:
    if (!fSummaryOnly && DumpFile != NULL)  {
        _tprintf(_T("Event traces dumped to %s\n"), DumpFileName);
        fclose(DumpFile);
    }

    if(SummaryFile != NULL){
        _tprintf(_T("Event Summary dumped to %s\n"), SummaryFileName);
        fclose(SummaryFile);
    }

    for (i = 0; i < LogFileCount; i ++)
    {
        if (EvmFile[i]->LoggerName != NULL)
        {
            free(EvmFile[i]->LoggerName);
            EvmFile[i]->LoggerName = NULL;
        }
        if (EvmFile[i]->LogFileName != NULL)
        {
            free(EvmFile[i]->LogFileName);
            EvmFile[i]->LogFileName = NULL;
        }
        free(EvmFile[i]);
    }
#ifdef UNICODE
    GlobalFree(cmdargv);
#endif

    SetLastError(Status);
    if(Status != ERROR_SUCCESS ){
        _tprintf(_T("Exit Status: %d\n"), Status);
    }

    if (MofData != NULL)
        free(MofData);

    return Status;
}

HRESULT 
ParseTime( 
    LPTSTR strTime, 
    SYSTEMTIME* pstTime 
)
/*++

Routine Description:

    Parse time given in a string into SYSTEMTIME.

Arguments:

    strTime - String that shows time.
    pstTime - Struct to contain the parsed time information. 

Return Value:

    Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS (== 0).

--*/
{
    TCHAR buffer[MAXSTR];
    LPTSTR str, str2;
    ZeroMemory( pstTime, sizeof( SYSTEMTIME ) );

    if( pstTime == NULL ){
        return ERROR_BAD_ARGUMENTS;
    }

    _tcscpy( buffer, strTime );
    str = _tcstok( buffer, _T(" \n\t") );
    str2 = _tcstok( NULL, _T(" \n\t") );
    while( str ){
        if( _tcsstr( str, _T(":") ) ){
            LPTSTR strHour = _tcstok( str, _T(":") );
            LPTSTR strMinute = _tcstok( NULL, _T(":") );

            if( NULL != strHour ){
                pstTime->wHour = (USHORT)_ttoi( strHour );
            }
            if( NULL != strMinute ){
                pstTime->wMinute = (USHORT)_ttoi( strMinute );
            }
        }
        if( _tcsstr( str, _T("/") ) || _tcsstr( str, _T("\\") ) ){
            LPTSTR strMonth = _tcstok( str, _T("/\\") );
            LPTSTR strDay = _tcstok( NULL, _T("/\\") );
            LPTSTR strYear = _tcstok( NULL, _T("/\\") );

            if( NULL != strMonth ){
                pstTime->wMonth = (USHORT)_ttoi( strMonth );
            }
            if( NULL != strDay ){
                pstTime->wDay = (USHORT)_ttoi( strDay );
            }
            if( NULL != strYear ){
                pstTime->wYear = (USHORT)_ttoi( strYear );
            }
        }
        str = str2;
        str2 = NULL;
    }

    return ERROR_SUCCESS;
}

// end_sdk
static 
void 
reduceA(
    char *Src
)
/*++

Routine Description:

    Reduces an ANSI string. Used only for ItemRString.

Arguments:

    Src - String to be reduced.

Return Value:

    None.

--*/
{
    char *Start = Src;
    if (!Src)
        return;
    while (*Src)
    {
        if ('\t' == *Src)
            *Src = ' ';
        else if (',' == *Src)
            *Src = ' ';
        else if ('\n' == *Src)
            *Src = ',';	// maybe a bug
        else if ('\r' == *Src)
            *Src = ' ';
        ++Src;
    }
    --Src;
    while ((Start < Src) && ((' ' == *Src) || (',' == *Src)))
    {
        *Src = 0x00;
        --Src;
    }
}

static 
void 
reduceW(
    WCHAR *Src
)
/*++

Routine Description:

    Reduces a wide string. Used only for ItemRWString.

Arguments:

    Src - Wide string to be reduced.

Return Value:

    None.

--*/
{
    WCHAR *Start = Src;
    if (!Src)
        return;
    while (*Src)
    {
        if (L'\t' == *Src)
            *Src = L' ';
        else if (L',' == *Src)
            *Src = L' ';
        else if (L'\n' == *Src)
            *Src = L',';
        else if (L'\r' == *Src)
            *Src = L' ';
        ++Src;
    }
    --Src;
    while ((Start < Src) && ((L' ' == *Src) || (L',' == *Src)))
    {
        *Src = 0x00;
        --Src;
    }
}
// begin_sdk

ULONG
WINAPI
BufferCallback(
    PEVENT_TRACE_LOGFILE pLog
    )
/*++

Routine Description:

    Callback method for processing a buffer. Does not do anything but
    updating global counters.

Arguments:

    pLog - Pointer to a log file.

Return Value:

    Always TRUE.

--*/
{
    TotalBuffersRead++;
    TotalEventsLost += pLog->EventsLost;
    return (TRUE);
}

void
WINAPI
DumpEvent(
    PEVENT_TRACE pEvent
)
/*++

Routine Description:

    Callback method for processing an event. It obtains the layout
    information by calling GetMofInfoHead(), which returns the pointer
    to the PMOF_INFO corresponding to the event type. Then it writes
    to the output file.

    NOTE: Only character arrays are supported in this program.

Arguments:

    pEvent - Pointer to an event.

Return Value:

    None.

--*/
{
    PEVENT_TRACE_HEADER pHeader;
    ULONG   i;
    PITEM_DESC pItem;
    char str[MOFSTR];
    WCHAR wstr[MOFWSTR];
    PCHAR ptr;
    ULONG ulongword;
    LONG  longword;
    USHORT ushortword;
    SHORT  shortword;
    PMOF_INFO pMofInfo;
    PLIST_ENTRY Head, Next;
    char iChar;
    WCHAR iwChar;
    ULONG MofDataUsed;

    TotalEventCount++;

    if (pEvent == NULL) {
        _tprintf(_T("Warning: Null Event\n"));
        return;
    }

    pHeader = (PEVENT_TRACE_HEADER) &pEvent->Header;

    if( IsEqualGUID(&(pEvent->Header.Guid), &EventTraceGuid) && 
        pEvent->Header.Class.Type == EVENT_TRACE_TYPE_INFO ) {

        PTRACE_LOGFILE_HEADER head = (PTRACE_LOGFILE_HEADER)pEvent->MofData;
        if( NULL != head ){
            g_bUserMode = (head->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE);
 
            if(head->TimerResolution > 0){
// end_sdk
                SysTimerResolution = head->TimerResolution;
// begin_sdk
                TimerResolution = head->TimerResolution / 10000;
            }
        
            StartTime  = head->StartTime.QuadPart;
            EndTime    = head->EndTime.QuadPart;
            fNoEndTime = (EndTime == 0);

            PointerSize =  head->PointerSize * 8;
            // Set pointer size
            if (PointerSize < 16){       // minimum is 16 bits
                PointerSize = 32;        // default is 32 bits
            }
        }
    }

    if (fNoEndTime && EndTime < (ULONGLONG) pHeader->TimeStamp.QuadPart) {
        EndTime = pHeader->TimeStamp.QuadPart;
    }

    if (MofData == NULL) {
        MofLength = pEvent->MofLength + sizeof(UNICODE_NULL);
        MofData = (PCHAR) malloc(MofLength);
    }
    else if ((pEvent->MofLength + sizeof(UNICODE_NULL)) > MofLength) {
        MofLength = pEvent->MofLength + sizeof(UNICODE_NULL);
        MofData = (PCHAR) realloc(MofData, MofLength);
    }

    if (MofData == NULL) {
        _tprintf(_T("Allocation Failure\n"));
        return;
    }

    if (NULL == pEvent->MofData && pEvent->MofLength != 0) {
        _tprintf(_T("Incorrect MOF size\n"));
        return;
    }

    if (NULL != (pEvent->MofData)) {
        memcpy(MofData, pEvent->MofData, pEvent->MofLength);
    }

    MofData[pEvent->MofLength] = 0;
    MofData[pEvent->MofLength+1] = 0;
    ptr = MofData;
    MofDataUsed = 0;
    // Find the MOF information for this event
    pMofInfo = GetMofInfoHead ( 
            pEvent->Header.Guid, 
            pEvent->Header.Class.Type, 
            pEvent->Header.Class.Version, 
            pEvent->Header.Class.Level 
        );
    
    if( NULL == pMofInfo ){
        return;
    }

    pMofInfo->EventCount++;

    if( fSummaryOnly == TRUE ){
        return;
    }

    if( pMofInfo->strDescription != NULL ){
        _ftprintf( DumpFile, _T("%12s, "), pMofInfo->strDescription );
    }else{
        TCHAR strGuid[MAXSTR];
        GuidToString( strGuid, &pMofInfo->Guid );
        _ftprintf( DumpFile, _T("%12s, "), strGuid );
    }

    if(pMofInfo->strType != NULL && wcslen(pMofInfo->strType) ){
        _ftprintf( DumpFile, _T("%10s, "), pMofInfo->strType );
    }else{
        _ftprintf( DumpFile, _T("%10d, "), pEvent->Header.Class.Type );
    }

    // Thread ID
    _ftprintf( DumpFile, _T("0x%04X, "), pHeader->ThreadId );
    
    // System Time
    _ftprintf( DumpFile, _T("%20I64u, "), pHeader->TimeStamp.QuadPart);

    if( g_bUserMode == FALSE ){
        // Kernel Time
        _ftprintf(DumpFile, _T("%10lu, "), pHeader->KernelTime * TimerResolution);

        // User Time
        _ftprintf(DumpFile, _T("%10lu, "), pHeader->UserTime * TimerResolution);
    }else{
        // processor Time
        _ftprintf(DumpFile, _T("%I64u, "), pHeader->ProcessorTime);
    }

    Head = pMofInfo->ItemHeader;
    Next = Head->Flink;

    if ((Head == Next) && (pEvent->MofLength > 0)) {
         _ftprintf(DumpFile, _T("DataSize=%d, "), pEvent->MofLength);
    }

    while (Head != Next) {
        pItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        Next = Next->Flink;

        MofDataUsed = (ULONG) (ptr - MofData);
        
        if (MofDataUsed >= pEvent->MofLength){
            break;
        }

        switch (pItem->ItemType)
        {
        case ItemChar:
        case ItemUChar:
            for( i=0;i<pItem->ArraySize;i++){
                iChar = *((PCHAR) ptr);
                _ftprintf(DumpFile,   _T("%c"), iChar);
                ptr += sizeof(CHAR);
            }
            _ftprintf(DumpFile, _T(", "));
            break;

        case ItemWChar:
            for(i=0;i<pItem->ArraySize;i++){
                iwChar = *((PWCHAR) ptr);
                _ftprintf(DumpFile, _T(",%wc"), iwChar);
                ptr += sizeof(WCHAR);
            }
            _ftprintf(DumpFile, _T(", "));
            break;

        case ItemCharShort:
            iChar = *((PCHAR) ptr);
            _ftprintf(DumpFile, _T("%d, "), iChar);
            ptr += sizeof(CHAR);
            break;

        case ItemShort:
            shortword = * ((PSHORT) ptr);
            _ftprintf(DumpFile, _T("%6d, "), shortword);
            ptr += sizeof (SHORT);
            break;

        case ItemUShort:
            ushortword = *((PUSHORT) ptr);
            _ftprintf(DumpFile, _T("%6u, "), ushortword);
            ptr += sizeof (USHORT);
            break;

        case ItemLong:
            longword = *((PLONG) ptr);
            _ftprintf(DumpFile, _T("%8d, "), longword);
            ptr += sizeof (LONG);
            break;

        case ItemULong:
            ulongword = *((PULONG) ptr);
            _ftprintf(DumpFile, _T("%8lu, "), ulongword);
            ptr += sizeof (ULONG);
            break;

        case ItemULongX:
            ulongword = *((PULONG) ptr);
            _ftprintf(DumpFile, _T("0x%08X, "), ulongword);
            ptr += sizeof (ULONG);
            break;

        case ItemLongLong:
        {
            LONGLONG n64;
            n64 = *((LONGLONG*) ptr);
            ptr += sizeof(LONGLONG);
            _ftprintf(DumpFile, _T("%16I64d, "), n64);
            break;
        }

        case ItemULongLong:
        {
            ULONGLONG n64;
            n64 = *((ULONGLONG*) ptr);
            ptr += sizeof(ULONGLONG);
            _ftprintf(DumpFile, _T("%16I64u, "), n64);
            break;
        }

        case ItemFloat:
        {
            float f32;
            f32 = *((float*) ptr);
            ptr += sizeof(float);
            _ftprintf(DumpFile, _T("%f, "), f32);
            break;
        }

        case ItemDouble:
        {
            double f64;
            f64 = *((double*) ptr);
            ptr += sizeof(double);
            _ftprintf(DumpFile, _T("%f, "), f64);
            break;
        }

        case ItemPtr :
        {
            unsigned __int64 pointer;
            if (PointerSize == 64) {
                pointer = *((unsigned __int64 *) ptr);
                _ftprintf(DumpFile, _T("0x%X, "), pointer);
            }
            else {      // assumes 32 bit otherwise
                ulongword = *((PULONG) ptr);
                _ftprintf(DumpFile, _T("0x%08X, "), ulongword);
            }
            ptr += PointerSize / 8;
            //
            // If target source is Win64, then use Ptr, else use ulongword
            //
            break;
        }

        case ItemIPAddr:
        {
            ulongword = *((PULONG) ptr);

            // Convert it to readable form
            _ftprintf(DumpFile, _T("%03d.%03d.%03d.%03d, "),
                    (ulongword >>  0) & 0xff,
                    (ulongword >>  8) & 0xff,
                    (ulongword >> 16) & 0xff,
                    (ulongword >> 24) & 0xff);
            ptr += sizeof (ULONG);
            break;
        }

        case ItemPort:
        {
            _ftprintf(DumpFile, _T("%u, "), NTOHS((USHORT) *ptr));
            ptr += sizeof (USHORT);
            break;
        }

        case ItemString:
// end_sdk
        case ItemRString:
// begin_sdk
        {
            USHORT pLen = (USHORT)strlen((CHAR*) ptr);

            if (pLen > 0)
            {
                strcpy(str, ptr);
// end_sdk
                if (pItem->ItemType == ItemRString)
                {
                    reduceA(str);
                }
// begin_sdk
                for (i=pLen-1; i>0; i--) {
                    if (str[i] == 0xFF)
                        str[i] = 0;
                    else break;
                }
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                _ftprintf(DumpFile, _T("\"%ws\","), wstr);
#else
                _ftprintf(DumpFile, _T("\"%s\","), str);
#endif
            }
            ptr += (pLen + 1);
            break;
        }

        case ItemWString:
// end_sdk
        case ItemRWString:
// begin_sdk
        {
            size_t  pLen = 0;
            size_t     i;

            if (*(WCHAR *) ptr)
            {
// end_sdk
                if (pItem->ItemType == ItemRWString)
                {
                    reduceW((WCHAR *) ptr);
                }
// begin_sdk
                pLen = ((wcslen((WCHAR*)ptr) + 1) * sizeof(WCHAR));
                memcpy(wstr, ptr, pLen);
                for (i = (pLen/2)-1; i > 0; i--)
                {
                    if (((USHORT) wstr[i] == (USHORT) 0xFFFF))
                    {
                        wstr[i] = (USHORT) 0;
                    }
                    else break;
                }

                wstr[pLen / 2] = wstr[(pLen / 2) + 1]= '\0';
                _ftprintf(DumpFile, _T("\"%ws\","), wstr);
            }
            ptr += pLen;

            break;
        }

        case ItemDSString:   // Counted String
        {
            USHORT pLen = (USHORT)(256 * ((USHORT) * ptr) + ((USHORT) * (ptr + 1)));
            ptr += sizeof(USHORT);
            if (pLen > (pEvent->MofLength - MofDataUsed - 1)) {
                pLen = (USHORT) (pEvent->MofLength - MofDataUsed - 1);
            }
            if (pLen > 0)
            {
                strcpy(str, ptr);
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                fwprintf(DumpFile, _T("\"%ws\","), wstr);
#else
                fprintf(DumpFile, _T("\"%s\","), str);
#endif
            }
            ptr += (pLen + 1);
            break;
        }

        case ItemPString:   // Counted String
        {
            USHORT pLen = * ((USHORT *) ptr);
            ptr += sizeof(USHORT);

            if (pLen > (pEvent->MofLength - MofDataUsed)) {
                pLen = (USHORT) (pEvent->MofLength - MofDataUsed);
            }

            if (pLen > MOFSTR * sizeof(CHAR)) {
                pLen = MOFSTR * sizeof(CHAR);
            }
            if (pLen > 0) {
                memcpy(str, ptr, pLen);
                str[pLen] = '\0';
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                _ftprintf(DumpFile, _T("\"%ws\","), wstr);
#else
                _ftprintf(DumpFile, _T("\"%s\","), str);
#endif
            }
            ptr += pLen;
            break;
        }

        case ItemDSWString:  // DS Counted Wide Strings
        case ItemPWString:   // Counted Wide Strings
        {
            USHORT pLen = (USHORT)(( pItem->ItemType == ItemDSWString)
                        ? (256 * ((USHORT) * ptr) + ((USHORT) * (ptr + 1)))
                        : (* ((USHORT *) ptr)));

            ptr += sizeof(USHORT);
            if (pLen > (pEvent->MofLength - MofDataUsed)) {
                pLen = (USHORT) (pEvent->MofLength - MofDataUsed);
            }

            if (pLen > MOFWSTR * sizeof(WCHAR)) {
                pLen = MOFWSTR * sizeof(WCHAR);
            }
            if (pLen > 0) {
                memcpy(wstr, ptr, pLen);
                wstr[pLen / sizeof(WCHAR)] = L'\0';
                _ftprintf(DumpFile, _T("\"%ws\","), wstr);
            }
            ptr += pLen;
            break;
        }

        case ItemNWString:   // Non Null Terminated String
        {
           USHORT Size;

           Size = (USHORT)(pEvent->MofLength - (ULONG)(ptr - MofData));
           if( Size > MOFSTR )
           {
               Size = MOFSTR;
           }
           if (Size > 0)
           {
               memcpy(wstr, ptr, Size);
               wstr[Size / 2] = '\0';
               _ftprintf(DumpFile, _T("\"%ws\","), wstr);
           }
           ptr += Size;
           break;
        }

        case ItemMLString:  // Multi Line String
        {
            USHORT   pLen;
            char   * src, * dest;
            BOOL     inQ       = FALSE;
            BOOL     skip      = FALSE;
            UINT     lineCount = 0;

            ptr += sizeof(UCHAR) * 2;
            pLen = (USHORT)strlen(ptr);
            if (pLen > 0)
            {
                src = ptr;
                dest = str;
                while (* src != '\0'){
                    if (* src == '\n'){
                        if (!lineCount){
                            * dest++ = ' ';
                        }
                        lineCount++;
                    }else if (* src == '\"'){ 
                        if (inQ){
                            char   strCount[32];
                            char * cpy;

                            sprintf(strCount, "{%dx}", lineCount);
                            cpy = & strCount[0];
                            while (* cpy != '\0'){
                                * dest ++ = * cpy ++;
                            }
                        }
                        inQ = !inQ;
                    }else if (!skip){
                        *dest++ = *src;
                    }
                    skip = (lineCount > 1 && inQ);
                    src++;
                }
                *dest = '\0';
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MOFWSTR);
                _ftprintf(DumpFile, _T("\"%ws\","), wstr);
#else
                _ftprintf(DumpFile, _T("\"%s\","), str);
#endif
            }
            ptr += (pLen);
            break;
        }

        case ItemSid:
        {
            TCHAR        UserName[64];
            TCHAR        Domain[64];
            TCHAR        FullName[256];
            ULONG        asize = 0;
            ULONG        bsize = 0;
            ULONG        Sid[64];
            PULONG       pSid  = & Sid[0];
            SID_NAME_USE Se;
            ULONG        nSidLength;

            pSid = (PULONG) ptr;
            if (*pSid == 0){
                ptr += 4;
                _ftprintf(DumpFile, _T("%4d, "), *pSid);
            }
            else
            {
                ptr += 8;           // skip the TOKEN_USER structure
                nSidLength = 8 + (4*ptr[1]);

                asize = 64;
                bsize = 64;
                if (LookupAccountSidW(
                                NULL,
                               (PSID) ptr,
                               (LPTSTR) & UserName[0],
                               & asize,
                               (LPTSTR) & Domain[0],
                               & bsize,
                               & Se))
                {
                    LPTSTR pFullName = &FullName[0];
                    _stprintf( pFullName,_T("\\\\%s\\%s"), Domain, UserName);
                    asize = (ULONG) _tcslen(pFullName);
                    if (asize > 0){
                        _ftprintf(DumpFile, _T("\"%s\", "), pFullName);
                    }
                }
                else
                {
                    _ftprintf(DumpFile, _T("\"System\", "));
                }
                SetLastError( ERROR_SUCCESS );
                ptr += nSidLength;
            }
            break;
        }

        case ItemGuid:
        {
            TCHAR s[64];
            GuidToString(s, (LPGUID)ptr);
            _ftprintf(DumpFile,   _T("%s, "), s);
            ptr += sizeof(GUID);
            break;
        }
// end_sdk
        case ItemVariant:
        {
            //
            // Variable Size. First ULONG gives the sizee and the rest is blob
            //
            ulongword = *((PULONG) ptr); 
            ptr += sizeof(ULONG);

            _ftprintf(DumpFile, _T("DataSize=%d, "), ulongword);

            // No need to dump the contents of the Blob itself. 

            ptr += ulongword; 
        
            break;
        }
// begin_sdk
        case ItemBool:
        {
            BOOL Flag = (BOOL)*ptr;
            _ftprintf(DumpFile, _T("%5s, "), (Flag) ? _T("TRUE") : _T("FALSE"));
            ptr += sizeof(BOOL);
            break;
        }

        default:
            ptr += sizeof (int);
        }
    }

    //Instance ID
    _ftprintf(DumpFile, _T("%d,"), pEvent->InstanceId);

    //Parent Instance ID
    _ftprintf(DumpFile, _T("%d\n"), pEvent->ParentInstanceId);
}

ULONG
CheckFile(
    LPTSTR fileName
)
/*++

Routine Description:

    Checks whether a file exists and is readable.

Arguments:

    fileName - File name.

Return Value:

    Non-zero if the file exists and is readable. Zero otherwise.

--*/
{
    HANDLE hFile;
    ULONG Status;

    hFile = CreateFile(
                fileName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
    Status = (hFile != INVALID_HANDLE_VALUE);
    CloseHandle(hFile);
    return Status;
}

PMOF_INFO
GetMofInfoHead(
    GUID    Guid,
    SHORT   nType,
    SHORT   nVersion,
    CHAR    nLevel
    )
/*++

Routine Description:

    Find a matching event layout in the global linked list. If it
    is not found in the list, it calls GetGuids() to examine the WBEM
    namespace.
    If the global list is empty, it first creates a header.

Arguments:

    Guid - GUID for the event under consideration.
    nType - Event Type
    nVersion - Event Version
    nLevel - Event Level (not supported in this program)

Return Value:

    Pointer to MOF_INFO for the current event. If the layout
    information is not found anywhere, GetMofInfoHead() creates
    a dummy and returns it.

--*/
{
    PLIST_ENTRY Head, Next;
    PMOF_INFO pMofInfo;
    PMOF_INFO pBestMatch = NULL;
    SHORT nMatchLevel = 0;
    SHORT nMatchCheck;

    // Search the eventList for this Guid and find the head

    if (EventListHead == NULL) {
        // Initialize the MOF List and add the global header guid to it
        EventListHead = (PLIST_ENTRY) malloc(sizeof(LIST_ENTRY));
        if (EventListHead == NULL)
            return NULL;
        InitializeListHead(EventListHead);

        pMofInfo = GetNewMofInfo( EventTraceGuid, EVENT_TYPE_DEFAULT, 0, 0 );
        if( pMofInfo != NULL ){
            InsertTailList( EventListHead, &pMofInfo->Entry );
            pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(GUID_TYPE_EVENTTRACE)+1)*sizeof(TCHAR));
            if( pMofInfo->strDescription != NULL ){
                _tcscpy( pMofInfo->strDescription, GUID_TYPE_EVENTTRACE );
            }
            pMofInfo->strType = (LPTSTR)malloc((_tcslen(GUID_TYPE_HEADER)+1)*sizeof(TCHAR));
            if( pMofInfo->strType != NULL ){
                _tcscpy( pMofInfo->strType, GUID_TYPE_HEADER );
            }
        }
    }

    // Traverse the list and look for the Mof info head for this Guid. 

    Head = EventListHead;
    Next = Head->Flink;

    while (Head != Next) {

        nMatchCheck = 0;

        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Next = Next->Flink;
        
        if( IsEqualGUID(&pMofInfo->Guid, &Guid) ){

            if( pMofInfo->TypeIndex == nType ){
                nMatchCheck++;
            }
            if( pMofInfo->Version == nVersion ){
                nMatchCheck++;
            }
            if( nMatchCheck == 2 ){ // Exact Match
                return  pMofInfo;
            }

            if( nMatchCheck > nMatchLevel ){ // Close Match
                nMatchLevel = nMatchCheck;
                pBestMatch = pMofInfo;
            }

            if( pMofInfo->TypeIndex == EVENT_TYPE_DEFAULT && // Total Guess
                pBestMatch == NULL ){
                pBestMatch = pMofInfo;
            }
        }

    } 

    if(pBestMatch != NULL){
        return pBestMatch;
    }

    // If one does not exist in the list, look it up in the file. 
    pMofInfo = GetGuids( Guid, nVersion, nLevel, nType );
    
    // If still not found, create a unknown place holder
    if( NULL == pMofInfo ){
        pMofInfo = GetNewMofInfo( Guid, nType, nVersion, nLevel );
        if( pMofInfo != NULL ){
            pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(GUID_TYPE_UNKNOWN)+1)*sizeof(TCHAR));
            if( pMofInfo->strDescription != NULL ){
                _tcscpy( pMofInfo->strDescription, GUID_TYPE_UNKNOWN );
            }
            InsertTailList( EventListHead, &pMofInfo->Entry );
        }
    }

    return pMofInfo;
}

void
RemoveMofInfo(
    PLIST_ENTRY pMofInfo
)
/*++

Routine Description:

    Removes and frees data item structs from a given list.

Arguments:

    pMofInfo - Pointer to the MOF_INFO to be purged of data item structs.

Return Value:

    None.

--*/
{
    PLIST_ENTRY Head, Next;
    PITEM_DESC pItem;

    Head = pMofInfo;
    Next = Head->Flink;
    while (Head != Next) {
        pItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        Next = Next->Flink;
        RemoveEntryList(&pItem->Entry);
        free(pItem);
    } 
}

void
CleanupEventList(
    VOID
)
/*++

Routine Description:

    Cleans up a global event list.

Arguments:

Return Value:

    None.

--*/
{
    PLIST_ENTRY Head, Next;
    PMOF_INFO pMofInfo;
    TCHAR s[256];
    TCHAR wstr[256];
    PTCHAR str;

    if (EventListHead == NULL) {
        return;
    }

    Head = EventListHead;
    Next = Head->Flink;
    while (Head != Next) {
        RtlZeroMemory(&wstr, 256);

        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);

        if (pMofInfo->EventCount > 0) {
            GuidToString(&s[0], &pMofInfo->Guid);
            str = s;
            if( pMofInfo->strDescription != NULL ){
                _tcscpy( wstr, pMofInfo->strDescription );
            }
            
            _ftprintf(SummaryFile,_T("|%10d    %-20s %-10s  %36s|\n"),
                      pMofInfo->EventCount, 
                      wstr, 
                      pMofInfo->strType ? pMofInfo->strType : GUID_TYPE_DEFAULT, 
                      str);
        }

        RemoveEntryList(&pMofInfo->Entry);
        RemoveMofInfo(pMofInfo->ItemHeader);
        free(pMofInfo->ItemHeader);

        if (pMofInfo->strDescription != NULL)
            free(pMofInfo->strDescription);
        if (pMofInfo->strType != NULL)
            free(pMofInfo->strType);

        Next = Next->Flink;
        free(pMofInfo);
    }

    free(EventListHead);
}

void
GuidToString(
    PTCHAR s,
    LPGUID piid
)
/*++

Routine Description:

    Converts a GUID into a string.

Arguments:

    s - String that will have the converted GUID.
    piid - GUID

Return Value:

    None.

--*/
{
    _stprintf(s, _T("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
               piid->Data1, piid->Data2,
               piid->Data3,
               piid->Data4[0], piid->Data4[1],
               piid->Data4[2], piid->Data4[3],
               piid->Data4[4], piid->Data4[5],
               piid->Data4[6], piid->Data4[7]);
    return;
}

void
AddMofInfo(
        PLIST_ENTRY List,
        LPTSTR  strType,
        ITEM_TYPE  nType,
        UINT   ArraySize
)
/*++

Routine Description:

    Creates a data item information struct (ITEM_DESC) and appends
    it to all MOF_INFOs in the given list.
    GetPropertiesFromWBEM() creates a list of MOF_INFOs for multiple
    types, stores them in a temporary list and calls this function for
    each data item information it encounters.

Arguments:

    List - List of MOF_INFOs.
    strType - Item description in string.
    nType - ITEM_TYPE defined at the beginning of this file.
    ArraySize - Size of array of this type of items, if applicable.

Return Value:

    None.

--*/
{
    PITEM_DESC pItem;
    PMOF_INFO pMofInfo;

    PLIST_ENTRY Head = List;
    PLIST_ENTRY Next = Head->Flink;
    while (Head != Next) {
        
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Next = Next->Flink;

        if( NULL != pMofInfo ){

            pItem = (PITEM_DESC) malloc(sizeof(ITEM_DESC));
            if( NULL == pItem ){
                return;
            }
            ZeroMemory( pItem, sizeof(ITEM_DESC) );            
            pItem->ItemType = nType;
            pItem->ArraySize = ArraySize;

            pItem->strDescription = (LPTSTR) malloc( (_tcslen(strType)+1)*sizeof(TCHAR));
            
            if( NULL == pItem->strDescription ){
                free( pItem );
                return;
            }
            _tcscpy(pItem->strDescription, strType);

            InsertTailList( (pMofInfo->ItemHeader), &pItem->Entry);
        }

    }
}


PMOF_INFO
GetNewMofInfo( 
    GUID guid, 
    SHORT nType, 
    SHORT nVersion, 
    CHAR nLevel 
)
/*++

Routine Description:

    Creates a new MOF_INFO with given data.

Arguments:

    guid - Event GUID.
    nType - Event type.
    nVersion - Event version.
    nLevel - Event level (not supported in this program).

Return Value:

    Pointer to the created MOF_INFO. NULL if malloc failed.

--*/
{
    PMOF_INFO pMofInfo;

    pMofInfo = (PMOF_INFO)malloc(sizeof(MOF_INFO));

    if( NULL == pMofInfo ){
        return NULL;
    }

    RtlZeroMemory(pMofInfo, sizeof(MOF_INFO));

    memcpy(&pMofInfo->Guid, &guid, sizeof(GUID) );
    
    pMofInfo->ItemHeader = (PLIST_ENTRY)malloc(sizeof(LIST_ENTRY));
    
    if( NULL == pMofInfo->ItemHeader ){
        free( pMofInfo );
        return NULL;
    }

    InitializeListHead(pMofInfo->ItemHeader);
    
    pMofInfo->TypeIndex = nType;
    pMofInfo->Level = nLevel;
    pMofInfo->Version = nVersion;

    return pMofInfo;
}

void
FlushMofList( 
    PLIST_ENTRY ListHead
)
/*++

Routine Description:

    Flushes MOF_INFOs in a temporary list into the global list.

Arguments:

    ListHead - Pointer to the head of a temporary list.

Return Value:

    None.

--*/
{
    PMOF_INFO pMofInfo;
    PLIST_ENTRY Head = ListHead;
    PLIST_ENTRY Next = Head->Flink;

    while( Head != Next ){
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        Next = Next->Flink;
        
        RemoveEntryList(&pMofInfo->Entry);
        InsertTailList( EventListHead, &pMofInfo->Entry);
    }
}

HRESULT
WbemConnect( 
    IWbemServices** pWbemServices 
)
/*++

Routine Description:

    Connects to WBEM and returns a pointer to WbemServices.

Arguments:

    pWbemServices - Pointer to the connected WbemServices.

Return Value:

    ERROR_SUCCESS if successful. Error flag otherwise.

--*/
{
    IWbemLocator     *pLocator = NULL;

    BSTR bszNamespace = SysAllocString( L"root\\wmi" );

    HRESULT hr = CoInitialize(0);

    hr = CoCreateInstance(
                CLSID_WbemLocator, 
                0, 
                CLSCTX_INPROC_SERVER,
                IID_IWbemLocator, 
                (LPVOID *) &pLocator
            );
    if ( ERROR_SUCCESS != hr )
        goto cleanup;

    hr = pLocator->ConnectServer(
                bszNamespace,
                NULL, 
                NULL, 
                NULL, 
                0L,
                NULL,
                NULL,
                pWbemServices
            );
    if ( ERROR_SUCCESS != hr )
        goto cleanup;

    hr = CoSetProxyBlanket(
            *pWbemServices,
            RPC_C_AUTHN_WINNT,
            RPC_C_AUTHZ_NONE,
            NULL,
            RPC_C_AUTHN_LEVEL_PKT,
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, 
            EOAC_NONE
        );

cleanup:
    SysFreeString( bszNamespace );

    if( pLocator ){
        pLocator->Release(); 
        pLocator = NULL;
    }
    
    return hr;
}

ULONG GetArraySize(
    IN IWbemQualifierSet *pQualSet
)
/*++

Routine Description:

    Examines a given qualifier set and returns the array size.

    NOTE: WBEM stores the size of an array in "MAX" qualifier.

Arguments:

    pQualSet - Pointer to a qualifier set.

Return Value:

    The size of the array. The default is 1.

--*/
{
    ULONG ArraySize = 1;
    VARIANT pVal;
    BSTR bszMaxLen;
    HRESULT hRes;

    if (pQualSet == NULL){
        return ArraySize;
    }

    bszMaxLen = SysAllocString(L"MAX");
    VariantInit(&pVal);
    hRes = pQualSet->Get(bszMaxLen,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszMaxLen);
    if (ERROR_SUCCESS == hRes && pVal.vt == VT_I4 ){
        ArraySize = pVal.lVal;
    }
    VariantClear(&pVal);
    return ArraySize;
}

ITEM_TYPE
GetItemType(
    IN CIMTYPE_ENUMERATION CimType, 
    IN IWbemQualifierSet *pQualSet
)
/*++

Routine Description:

    Examines a given qualifier set for a property and returns the type.

Arguments:

    CimType - WBEM type (different from ITEM_TYPE) of a property.
    pQualSet - Pointer to a qualifier set for a property under consideration.

Return Value:

    The type (in ITEM_TYPE) of a property.

--*/
{
    ITEM_TYPE Type;
    VARIANT pVal;
    HRESULT hRes;
    BSTR bszQualName;
    WCHAR strFormat[10];
    WCHAR strTermination[30];
    WCHAR strTemp[30];
    BOOLEAN IsPointer = FALSE;

    strFormat[0] = '\0';
    strTermination[0] = '\0';
    strTemp[0] = '\0';

    if (pQualSet == NULL)
        return ItemUnknown;

    bszQualName = SysAllocString(L"format");
    VariantInit(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes && NULL != pVal.bstrVal)
        wcscpy(strFormat, pVal.bstrVal);

    bszQualName = SysAllocString(L"StringTermination");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes && NULL != pVal.bstrVal)
        wcscpy(strTermination, pVal.bstrVal);

    bszQualName = SysAllocString(L"pointer");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes)
        IsPointer = TRUE;
    // Major fix required to get rid of temp
    bszQualName = SysAllocString(L"extension");
    VariantClear(&pVal);
    hRes = pQualSet->Get(bszQualName,
                            0,
                            &pVal,
                            0);
    SysFreeString(bszQualName);
    if (ERROR_SUCCESS == hRes && NULL != pVal.bstrVal)
        wcscpy(strTemp, pVal.bstrVal);

    VariantClear(&pVal);

    CimType = (CIMTYPE_ENUMERATION)(CimType & (~CIM_FLAG_ARRAY));

    switch (CimType) {
        case CIM_EMPTY:
            Type = ItemUnknown;
            break;        
        case CIM_SINT8:
            Type = ItemCharShort;
            if (!_wcsicmp(strFormat, L"c")){
                Type = ItemChar;
            }
            break;
        case CIM_UINT8:
            Type = ItemUChar;
            break;
        case CIM_SINT16:
            Type = ItemShort;
            break;
        case CIM_UINT16:
            Type = ItemUShort;
            break;
        case CIM_SINT32:
            Type = ItemLong;
            break;
        case CIM_UINT32:
            Type = ItemULong;
            if (!_wcsicmp(strFormat, L"x")){
                Type = ItemULongX;
            }
            break;
        case CIM_SINT64: 
            Type = ItemLongLong;
            break;
        case CIM_UINT64:
            Type = ItemULongLong;
            break;
        case CIM_REAL32:
            Type = ItemFloat;
            break;
        case CIM_REAL64:
            Type = ItemDouble;
            break;
        case CIM_BOOLEAN:
            // ItemBool
            Type = ItemBool;
            break;
        case CIM_STRING:
            
            if (!_wcsicmp(strTermination, L"NullTerminated")) {
                if (!_wcsicmp(strFormat, L"w"))
                    Type = ItemWString;
                else
                    Type = ItemString;
            }
            else if (!_wcsicmp(strTermination, L"Counted")) {
                if (!_wcsicmp(strFormat, L"w"))
                    Type = ItemPWString;
                else
                    Type = ItemPString;
            }
            else if (!_wcsicmp(strTermination, L"ReverseCounted")) {
                if (!_wcsicmp(strFormat, L"w"))
                    Type = ItemDSWString;
                else
                    Type = ItemDSString;
            }
            else if (!_wcsicmp(strTermination, L"NotCounted")) {
                Type = ItemNWString;
            }else{
                Type = ItemString;
            }
            break;
        case CIM_CHAR16:
            // ItemWChar
            Type = ItemWChar;
            break;

        case CIM_OBJECT :
            if (!_wcsicmp(strTemp, L"Port"))
                Type = ItemPort;
// end_sdk
            else if (!_wcsicmp(strTemp, L"RString"))
                Type = ItemRString;
            else if (!_wcsicmp(strTemp, L"RWString"))
                Type = ItemRWString;
// begin_sdk
            else if (!_wcsicmp(strTemp, L"IPAddr"))
                Type = ItemIPAddr;
            else if (!_wcsicmp(strTemp, L"Sid"))
                Type = ItemSid;
            else if (!_wcsicmp(strTemp, L"Guid"))
                Type = ItemGuid;
// end_sdk
            else if (!_wcsicmp(strTemp, L"Variant"))
                Type = ItemVariant;
// begin_sdk
            break;

        case CIM_DATETIME:
        case CIM_REFERENCE:
        case CIM_ILLEGAL:
        default:
            Type = ItemUnknown;
            break;
    }

    if (IsPointer)
        Type = ItemPtr;
    return Type;
}

PMOF_INFO
GetPropertiesFromWBEM(
    IWbemClassObject *pTraceSubClasses, 
    GUID Guid,
    SHORT nVersion, 
    CHAR nLevel, 
    SHORT nType
)
/*++

Routine Description:

    Constructs a linked list with the information read from the WBEM
    namespace, given the WBEM pointer to the version subtree. It enumerates
    through all type classes in WBEM, and constructs MOF_INFOs for all of
    them (for caching purpose). Meanwhile, it looks for the event layout
    that mathces the passed event, and returns the pointer to the matching 
    MOF_INFO at the end. 

Arguments:

    pTraceSubClasses - WBEM pointer to the version subtree.
    Guid - GUID of the passed event.
    nVersion - version of the passed event.
    nLevel - level of the passed event.
    nType - type of the passed event.

Return Value:

    Pointer to MOF_INFO corresponding to the passed event.
    If the right type is not found, it returns the pointer to
    the generic MOF_INFO for the event version.

--*/
{
    IEnumWbemClassObject    *pEnumTraceSubSubClasses = NULL;
    IWbemClassObject        *pTraceSubSubClasses = NULL; 
    IWbemQualifierSet       *pQualSet = NULL;

    PMOF_INFO pMofInfo = NULL, pMofLookup = NULL, pMofTemplate = NULL;

    BSTR bszClassName = NULL;
    BSTR bszSubClassName = NULL;
    BSTR bszWmiDataId = NULL;
    BSTR bszEventType = NULL; 
    BSTR bszEventTypeName = NULL; 
    BSTR bszFriendlyName = NULL;
    BSTR bszPropName = NULL;

    TCHAR strClassName[MAXSTR];
    TCHAR strType[MAXSTR];
#ifndef UNICODE
    CHAR TempString[MAXSTR];
#endif
    LONG pVarType;
    SHORT nEventType = EVENT_TYPE_DEFAULT; 

    LIST_ENTRY ListHead;
    HRESULT hRes;

    VARIANT pVal;
    VARIANT pTypeVal;
    VARIANT pTypeNameVal;
    VARIANT pClassName;
    ULONG lEventTypeWbem;
    ULONG HUGEP *pTypeData;
    BSTR HUGEP *pTypeNameData;

    SAFEARRAY *PropArray = NULL;
    SAFEARRAY *TypeArray = NULL;
    SAFEARRAY *TypeNameArray = NULL;

    long lLower, lUpper, lCount, IdIndex;
    long lTypeLower, lTypeUpper;
    long lTypeNameLower, lTypeNameUpper;

    ULONG ArraySize;

    ITEM_TYPE ItemType;

    InitializeListHead(&ListHead);

    VariantInit(&pVal);
    VariantInit(&pTypeVal);
    VariantInit(&pTypeNameVal);
    VariantInit(&pClassName);

    bszClassName = SysAllocString(L"__CLASS");
    bszWmiDataId = SysAllocString(L"WmiDataId");
    bszEventType = SysAllocString(L"EventType");
    bszEventTypeName = SysAllocString(L"EventTypeName");
    bszFriendlyName = SysAllocString(L"DisplayName");

    hRes = pTraceSubClasses->Get(bszClassName,          // property name 
                                        0L, 
                                        &pVal,          // output to this variant 
                                        NULL, 
                                        NULL);

    if (ERROR_SUCCESS == hRes){
        if (pQualSet) {
            pQualSet->Release();
            pQualSet = NULL;
        }
        // Get Qualifier Set to obtain the friendly name.
        pTraceSubClasses->GetQualifierSet(&pQualSet);
        hRes = pQualSet->Get(bszFriendlyName, 
                                0, 
                                &pClassName, 
                                0);
        if (ERROR_SUCCESS == hRes && pClassName.bstrVal != NULL) {
#ifdef UNICODE
            wcscpy(strClassName, pClassName.bstrVal);
#else
            WideCharToMultiByte(CP_ACP,
                                0,
                                pClassName.bstrVal,
                                wcslen(pClassName.bstrVal),
                                TempString,
                                (MAXSTR * sizeof(CHAR)),
                                NULL,
                                NULL
                                );
            strcpy(strClassName, TempString);
            strClassName[wcslen(pClassName.bstrVal)] = '\0';
#endif
        }
        else {
#ifdef UNICODE
            strClassName[0] = L'\0';
#else
            strClassName[0] = '\0';
#endif
        }
        // Put Event Header
        pMofInfo = GetNewMofInfo(Guid,
                                    EVENT_TYPE_DEFAULT,
                                    EVENT_VERSION_DEFAULT,
                                    EVENT_LEVEL_DEFAULT
                                    );
        if (pMofInfo != NULL) {
            pMofTemplate = pMofInfo;
            pMofLookup = pMofInfo;
            InsertTailList(&ListHead, &pMofInfo->Entry);
            pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(strClassName) + 1) * sizeof(TCHAR));
            if (NULL != pMofInfo->strDescription) {
                _tcscpy(pMofInfo->strDescription, strClassName);
            }
        }
        else{
            goto cleanup;
        }

        // Create an enumerator to find derived classes.
        bszSubClassName = SysAllocString(pVal.bstrVal);
        hRes = pWbemServices->CreateClassEnum ( 
                                    bszSubClassName,                                                // class name
                                    WBEM_FLAG_SHALLOW | WBEM_FLAG_USE_AMENDED_QUALIFIERS,           // shallow search
                                    NULL,
                                    &pEnumTraceSubSubClasses
                                    );
        SysFreeString ( bszSubClassName );
        if (ERROR_SUCCESS == hRes) {
            ULONG uReturnedSub = 1;

            while(uReturnedSub == 1){
                // For each event in the subclass
                pTraceSubSubClasses = NULL;
                hRes = pEnumTraceSubSubClasses->Next(5000,                  // timeout in five seconds
                                                    1,                      // return just one instance
                                                    &pTraceSubSubClasses,   // pointer to a Sub class
                                                    &uReturnedSub);         // number obtained: one 
                if (ERROR_SUCCESS == hRes && uReturnedSub == 1) {
                    if (pQualSet) {
                        pQualSet->Release();
                        pQualSet = NULL;
                    }
                    // Get Qualifier Set.
                    pTraceSubSubClasses->GetQualifierSet(&pQualSet);
                    // Get Type number among Qualifiers
                    VariantClear(&pTypeVal);
                    hRes = pQualSet->Get(bszEventType, 
                                            0, 
                                            &pTypeVal, 
                                            0);

                    if (ERROR_SUCCESS == hRes) {
                        TypeArray = NULL;
                        TypeNameArray = NULL;
                        if (pTypeVal.vt & VT_ARRAY) {   // EventType is an array
                            TypeArray = pTypeVal.parray;
                            VariantClear(&pTypeNameVal);
                            hRes = pQualSet->Get(bszEventTypeName, 
                                                    0, 
                                                    &pTypeNameVal, 
                                                    0);
                            if ((ERROR_SUCCESS == hRes) && (pTypeNameVal.vt & VT_ARRAY)) {
                                TypeNameArray = pTypeNameVal.parray;
                            }
                            if (TypeArray != NULL) {
                                hRes = SafeArrayGetLBound(TypeArray, 1, &lTypeLower);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                hRes = SafeArrayGetUBound(TypeArray, 1, &lTypeUpper);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                if (lTypeUpper < 0) {
                                    break;
                                }
                                SafeArrayAccessData(TypeArray, (void HUGEP **)&pTypeData );

                                if (TypeNameArray != NULL) {
                                    hRes = SafeArrayGetLBound(TypeNameArray, 1, &lTypeNameLower);
                                    if (ERROR_SUCCESS != hRes) {
                                        break;
                                    }
                                    hRes = SafeArrayGetUBound(TypeNameArray, 1, &lTypeNameUpper);
                                    if (ERROR_SUCCESS != hRes) {
                                        break;
                                    }
                                    if (lTypeNameUpper < 0) 
                                        break;
                                    SafeArrayAccessData(TypeNameArray, (void HUGEP **)&pTypeNameData );
                                }

                                for (lCount = lTypeLower; lCount <= lTypeUpper; lCount++) { 
                                    lEventTypeWbem = pTypeData[lCount];
                                    nEventType = (SHORT)lEventTypeWbem;
                                    pMofInfo = GetNewMofInfo(Guid, nEventType, nVersion, nLevel);
                                    if (pMofInfo != NULL) {
                                        InsertTailList(&ListHead, &pMofInfo->Entry);
                                        if (pMofTemplate != NULL && pMofTemplate->strDescription != NULL) {
                                            pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(pMofTemplate->strDescription) + 1) * sizeof(TCHAR));
                                            if (pMofInfo->strDescription != NULL) {
                                                _tcscpy(pMofInfo->strDescription, pMofTemplate->strDescription);
                                            }
                                        }
                                        if (nType == nEventType) {
                                            // Type matched
                                            pMofLookup = pMofInfo;
                                        }
                                        if (TypeNameArray != NULL) {
                                            if ((lCount >= lTypeNameLower) && (lCount <= lTypeNameUpper)) {
                                                pMofInfo->strType = (LPTSTR)malloc((wcslen((LPWSTR)pTypeNameData[lCount]) + 1) * sizeof(TCHAR));
                                                if (pMofInfo->strType != NULL){
#ifdef UNICODE
                                                    wcscpy(pMofInfo->strType, (LPWSTR)(pTypeNameData[lCount]));
#else
                                                    WideCharToMultiByte(CP_ACP,
                                                                        0,
                                                                        (LPWSTR)(pTypeNameData[lCount]),
                                                                        wcslen((LPWSTR)(pTypeNameData[lCount])),
                                                                        TempString,
                                                                        (MAXSTR * sizeof(CHAR)),
                                                                        NULL,
                                                                        NULL
                                                                        );
                                                    TempString[wcslen((LPWSTR)(pTypeNameData[lCount]))] = '\0';
                                                    strcpy(pMofInfo->strType, TempString);
#endif
                                                }
                                            }
                                        }
                                    }
                                }
                                SafeArrayUnaccessData(TypeArray);  
                                SafeArrayDestroy(TypeArray);
                                VariantInit(&pTypeVal);
                                if (TypeNameArray != NULL) {
                                    SafeArrayUnaccessData(TypeNameArray);
                                    SafeArrayDestroy(TypeNameArray);
                                    VariantInit(&pTypeNameVal);
                                }
                            }
                            else {
                                // If the Types are not found, then bail
                                break;
                            }
                        }
                        else {                          // EventType is scalar
                            hRes = VariantChangeType(&pTypeVal, &pTypeVal, 0, VT_I2);
                            if (ERROR_SUCCESS == hRes)
                                nEventType = (SHORT)V_I2(&pTypeVal);
                            else
                                nEventType = (SHORT)V_I4(&pTypeVal);

                            VariantClear(&pTypeNameVal);
                            hRes = pQualSet->Get(bszEventTypeName, 
                                                    0, 
                                                    &pTypeNameVal, 
                                                    0);
                            if (ERROR_SUCCESS == hRes) {
#ifdef UNICODE
                                wcscpy(strType, pTypeNameVal.bstrVal);
#else
                                WideCharToMultiByte(CP_ACP,
                                                    0,
                                                    pTypeNameVal.bstrVal,
                                                    wcslen(pTypeNameVal.bstrVal),
                                                    TempString,
                                                    (MAXSTR * sizeof(CHAR)),
                                                    NULL,
                                                    NULL
                                                    );
                                strcpy(strType, TempString);
                                strType[wcslen(pTypeNameVal.bstrVal)] = '\0';
#endif
                            }
                            else{
#ifdef UNICODE
                                strType[0] = L'\0';
#else
                                strType[0] = '\0';
#endif
                            }

                            pMofInfo = GetNewMofInfo(Guid, nEventType, nVersion, nLevel);
                            if (pMofInfo != NULL) {
                                InsertTailList(&ListHead, &pMofInfo->Entry);
                                if (pMofTemplate != NULL && pMofTemplate->strDescription != NULL) {
                                    pMofInfo->strDescription = (LPTSTR)malloc((_tcslen(pMofTemplate->strDescription) + 1) * sizeof(TCHAR));
                                    if (pMofInfo->strDescription != NULL) {
                                        _tcscpy(pMofInfo->strDescription, pMofTemplate->strDescription);
                                    }
                                }
                                if (nType == nEventType) {
                                    // Type matched
                                    pMofLookup = pMofInfo;
                                }
                                pMofInfo->strType = (LPTSTR)malloc((_tcslen(strType) + 1) * sizeof(TCHAR));
                                if (pMofInfo->strType != NULL){
                                    _tcscpy(pMofInfo->strType, strType);
                                }
                            }
                        }

                        // Get event layout
                        VariantClear(&pVal);
                        IdIndex = 1;
                        V_VT(&pVal) = VT_I4;
                        V_I4(&pVal) = IdIndex; 
                        // For each property
                        PropArray = NULL;
                        while (pTraceSubSubClasses->GetNames(bszWmiDataId,                  // only properties with WmiDataId qualifier
                                                            WBEM_FLAG_ONLY_IF_IDENTICAL,
                                                            &pVal,                          // WmiDataId number starting from 1
                                                            &PropArray) == WBEM_NO_ERROR) {

                            hRes = SafeArrayGetLBound(PropArray, 1, &lLower);
                            if (ERROR_SUCCESS != hRes) {
                                break;
                            }
                            hRes = SafeArrayGetUBound(PropArray, 1, &lUpper);
                            if (ERROR_SUCCESS != hRes) {
                                break;
                            }
                            if (lUpper < 0) 
                                break;
                            // This loop will iterate just once.
                            for (lCount = lLower; lCount <= lUpper; lCount++) { 
                                hRes = SafeArrayGetElement(PropArray, &lCount, &bszPropName);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                hRes = pTraceSubSubClasses->Get(bszPropName,    // Property name
                                                                0L,
                                                                NULL,
                                                                &pVarType,      // CIMTYPE of the property
                                                                NULL);
                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }

                                // Get the Qualifier set for the property
                                if (pQualSet) {
                                    pQualSet->Release();
                                    pQualSet = NULL;
                                }
                                hRes = pTraceSubSubClasses->GetPropertyQualifierSet(bszPropName,
                                                                        &pQualSet);

                                if (ERROR_SUCCESS != hRes) {
                                    break;
                                }
                                
                                ItemType = GetItemType((CIMTYPE_ENUMERATION)pVarType, pQualSet);
                                
                                if( pVarType & CIM_FLAG_ARRAY ){
                                    ArraySize = GetArraySize(pQualSet);
                                }else{
                                    ArraySize = 1;
                                }
#ifdef UNICODE
                                AddMofInfo(&ListHead, 
                                            bszPropName, 
                                            ItemType, 
                                            ArraySize);
#else
                                WideCharToMultiByte(CP_ACP,
                                                    0,
                                                    bszPropName,
                                                    wcslen(bszPropName),
                                                    TempString,
                                                    (MAXSTR * sizeof(CHAR)),
                                                    NULL,
                                                    NULL
                                                    );
                                TempString[wcslen(bszPropName)] = '\0';
                                AddMofInfo(&ListHead,
                                            TempString,
                                            ItemType, 
                                            ArraySize);
#endif
                            }
                            SafeArrayDestroy(PropArray);
                            PropArray = NULL;
                            V_I4(&pVal) = ++IdIndex;
                        }   // end enumerating through WmiDataId
                        FlushMofList(&ListHead);
                    }   // if getting event type was successful
                }   // if enumeration returned a subclass successfully
            }   // end enumerating subclasses
        }   // if enumeration was created successfully
    }   // if getting class name was successful
cleanup:
    VariantClear(&pVal);
    VariantClear(&pTypeVal);
    VariantClear(&pClassName);

    SysFreeString(bszClassName);
    SysFreeString(bszWmiDataId);
    SysFreeString(bszEventType);
    SysFreeString(bszEventTypeName);
    SysFreeString(bszFriendlyName);
    // Should not free bszPropName becuase it is already freed by SafeArrayDestroy

    FlushMofList(&ListHead);

    return pMofLookup;
}

PMOF_INFO
GetGuids (GUID Guid, 
        SHORT nVersion, 
        CHAR nLevel, 
        SHORT nType 
        )
/*++

Routine Description:

    Aceesses the MOF data information from WBEM, creates a linked list, 
    and returns a pointer that matches the passed event.
    This function finds the right subtree within the WBEM namespace,
    and calls GetPropertiesFromWBEM() to create the list.

Arguments:

    Guid - GUID of the passed event.
    nVersion - version of the passed event.
    nLevel - level of the passed event.
    nType - type of the passed event.

Return Value:

    PMOF_INFO to MOF_INFO structure that matches the passed event.
    NULL if no match is found.

--*/
{
    IEnumWbemClassObject    *pEnumTraceSubClasses = NULL, *pEnumTraceSubSubClasses = NULL;
    IWbemClassObject        *pTraceSubClasses = NULL, *pTraceSubSubClasses = NULL;
    IWbemQualifierSet       *pQualSet = NULL;

    BSTR bszInstance = NULL;
    BSTR bszPropertyName = NULL;
    BSTR bszSubClassName = NULL;
    BSTR bszGuid = NULL;
    BSTR bszVersion = NULL;

    WCHAR strGuid[MAXSTR], strTargetGuid[MAXSTR];
    
    HRESULT hRes;

    VARIANT pVal;
    VARIANT pGuidVal;
    VARIANT pVersionVal;

    UINT nCounter=0;
    BOOLEAN MatchFound;
    SHORT nEventVersion = EVENT_VERSION_DEFAULT;

    PMOF_INFO pMofLookup = NULL;

    VariantInit(&pVal);
    VariantInit(&pGuidVal);
    VariantInit(&pVersionVal);
    
    if (NULL == pWbemServices) {
        hRes = WbemConnect( &pWbemServices );
        if ( ERROR_SUCCESS != hRes ) {
            goto cleanup;
        }
    }

    // Convert traget GUID to string for later comparison
#ifdef UNICODE
    GuidToString(strTargetGuid, &Guid);
#else
    CHAR TempString[MAXSTR];
    GuidToString(TempString, &Guid);
    MultiByteToWideChar(CP_ACP, 0, TempString, -1, strTargetGuid, MAXSTR);
#endif

    bszInstance = SysAllocString(L"EventTrace");
    bszPropertyName = SysAllocString(L"__CLASS");
    bszGuid = SysAllocString(L"Guid");
    bszVersion = SysAllocString(L"EventVersion");
    pEnumTraceSubClasses = NULL;

    // Get an enumerator for all classes under "EventTace".
    hRes = pWbemServices->CreateClassEnum ( 
                bszInstance,
                WBEM_FLAG_SHALLOW | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                NULL,
                &pEnumTraceSubClasses );
    SysFreeString (bszInstance);

    if (ERROR_SUCCESS == hRes) {
        ULONG uReturned = 1;
        MatchFound = FALSE;
        while (uReturned == 1) {
            pTraceSubClasses = NULL;
            // Get the next ClassObject.
            hRes = pEnumTraceSubClasses->Next(5000,             // timeout in five seconds
                                            1,                  // return just one instance
                                            &pTraceSubClasses,  // pointer to Event Trace Sub Class
                                            &uReturned);        // number obtained: one or zero
            if (ERROR_SUCCESS == hRes && (uReturned == 1)) {
                // Get the class name
                hRes = pTraceSubClasses->Get(bszPropertyName,   // property name 
                                                0L, 
                                                &pVal,          // output to this variant 
                                                NULL, 
                                                NULL);
                if (ERROR_SUCCESS == hRes){
                    bszSubClassName = SysAllocString(pVal.bstrVal);
                    // Create an enumerator to find derived classes.
                    hRes = pWbemServices->CreateClassEnum ( 
                                            bszSubClassName,
                                            WBEM_FLAG_SHALLOW | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                            NULL,
                                            &pEnumTraceSubSubClasses 
                                            );
                    SysFreeString ( bszSubClassName );
                    bszSubClassName = NULL;
                    VariantClear(&pVal);

                    if (ERROR_SUCCESS == hRes) {
                                    
                        ULONG uReturnedSub = 1;
                        while(uReturnedSub == 1){

                            pTraceSubSubClasses = NULL;
                            // enumerate through the resultset.
                            hRes = pEnumTraceSubSubClasses->Next(5000,              // timeout in five seconds
                                                            1,                      // return just one instance
                                                            &pTraceSubSubClasses,   // pointer to a Sub class
                                                            &uReturnedSub);         // number obtained: one or zero
                            if (ERROR_SUCCESS == hRes && uReturnedSub == 1) {
                                // Get the subclass name            
                                hRes = pTraceSubSubClasses->Get(bszPropertyName,    // Class name 
                                                                0L, 
                                                                &pVal,              // output to this variant 
                                                                NULL, 
                                                                NULL);
                                VariantClear(&pVal);

                                if (ERROR_SUCCESS == hRes){
                                    // Get Qualifier Set.
                                    if (pQualSet) {
                                        pQualSet->Release();
                                        pQualSet = NULL;
                                    }
                                    pTraceSubSubClasses->GetQualifierSet (&pQualSet );

                                    // Get GUID among Qualifiers
                                    hRes = pQualSet->Get(bszGuid, 
                                                            0, 
                                                            &pGuidVal, 
                                                            0);
                                    if (ERROR_SUCCESS == hRes) {
                                        wcscpy(strGuid, (LPWSTR)V_BSTR(&pGuidVal));
                                        VariantClear ( &pGuidVal  );

                                        if (!wcsstr(strGuid, L"{"))
                                            swprintf(strGuid , L"{%s}", strGuid);

                                        if (!_wcsicmp(strTargetGuid, strGuid)) {
                                            hRes = pQualSet->Get(bszVersion, 
                                                                    0, 
                                                                    &pVersionVal, 
                                                                    0);
                                            if (ERROR_SUCCESS == hRes) {
                                                hRes = VariantChangeType(&pVersionVal, &pVersionVal, 0, VT_I2);
                                                if (ERROR_SUCCESS == hRes)
                                                    nEventVersion = (SHORT)V_I2(&pVersionVal);
                                                else
                                                    nEventVersion = (SHORT)V_I4(&pVersionVal);
                                                VariantClear(&pVersionVal);

                                                if (nVersion == nEventVersion) {
                                                    // Match is found. 
                                                    // Now put all events in this subtree into the list 
                                                    MatchFound = TRUE;
                                                    pMofLookup = GetPropertiesFromWBEM( pTraceSubSubClasses, 
                                                                                        Guid,
                                                                                        nVersion,
                                                                                        nLevel,
                                                                                        nType
                                                                                        );
                                                    break;
                                                }
                                            }
                                            else {
                                                // if there is no version number for this event,
                                                // the current one is the only one
                                                // Now put all events in this subtree into the list 
                                                MatchFound = TRUE;
                                                pMofLookup = GetPropertiesFromWBEM( pTraceSubSubClasses, 
                                                                                    Guid,
                                                                                    EVENT_VERSION_DEFAULT,
                                                                                    nLevel,
                                                                                    nType
                                                                                    );
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        } // end while enumerating sub classes
                        if (MatchFound) {
                            break;
                        }
                        if (pEnumTraceSubSubClasses) {
                            pEnumTraceSubSubClasses->Release();
                            pEnumTraceSubSubClasses = NULL;
                        }
                    }   // if creating enumeration was successful
                    else {
                        pEnumTraceSubSubClasses = NULL;
                    }
                }   // if getting class name was successful
            }
            nCounter++;
            // if match is found, break out of the top level search
            if (MatchFound)
                break;
        }   // end while enumerating top classes
        if( pEnumTraceSubClasses ){
            pEnumTraceSubClasses->Release();
            pEnumTraceSubClasses = NULL;
        }
    }   // if creating enumeration for top level is successful

cleanup:

    VariantClear(&pGuidVal);
    VariantClear(&pVersionVal);

    SysFreeString(bszGuid);
    SysFreeString(bszPropertyName);
    SysFreeString(bszVersion);

    if( pEnumTraceSubClasses ){
        pEnumTraceSubClasses->Release();
        pEnumTraceSubClasses = NULL;
    }
    if (pEnumTraceSubSubClasses){
        pEnumTraceSubSubClasses->Release();
        pEnumTraceSubSubClasses = NULL;
    }
    if (pQualSet) {
        pQualSet->Release();
        pQualSet = NULL;
    }

    return pMofLookup;
}

ULONG 
ahextoi(
    TCHAR *s
    )
/*++

Routine Description:

    Converts a hex number to an integer.

Arguments:

    s - Input string containing a hex number.

Return Value:

    ULONG denoted by the hex string s.

--*/
{
    long len;
    ULONG num, base, hex;

    if (s == NULL)
        return 0;
    if (*s == 0)
        return 0;
    len = (long) _tcslen(s);
    if (len == 0 || len >= MAXSTR )
        return 0;
    hex = 0; base = 1; num = 0;
    while (--len >= 0) {
        if ( (s[len] == 'x' || s[len] == 'X') &&
             (s[len-1] == '0') )
            break;
        if (s[len] >= '0' && s[len] <= '9')
            num = s[len] - '0';
        else if (s[len] >= 'a' && s[len] <= 'f')
            num = (s[len] - 'a') + 10;
        else if (s[len] >= 'A' && s[len] <= 'F')
            num = (s[len] - 'A') + 10;
        else
            continue;

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

void 
RemoveWhiteSpace(
    TCHAR *s
    ) 
/*++

Routine Description:

    Removes white space (' ', '\n', and '\t') from the given string.

Arguments:

    s - Input and output string.

Return Value:

    None

--*/
{
    UINT i = 0;
    UINT j = 0;
    TCHAR TempString[MAXSTR];
    if (s == NULL)
        return;
    _tcscpy(TempString, s);
    while (TempString[i] != '\0') {
        if (TempString[i] != ' ' && TempString[i] != '\t' && TempString[i] != '\n')
            s[j++] = TempString[i];
        ++i;
    }
    s[j] = '\0';
}
// end_sdk
void 
DisplayVersionInfo()
/*++

Routine Description:

    prints out a version information.

Arguments:

    None.

Return Value:

    None.


--*/
{
    TCHAR buffer[512];
    TCHAR strProgram[MAXSTR];
    DWORD dw;
    BYTE* pVersionInfo;
    LPTSTR pVersion = NULL;
    LPTSTR pProduct = NULL;
    LPTSTR pCopyRight = NULL;

    dw = GetModuleFileName(NULL, strProgram, MAXSTR);

    if( dw>0 ){

        dw = GetFileVersionInfoSize( strProgram, &dw );
        if( dw > 0 ){

            pVersionInfo = (BYTE*)malloc(dw);
            if( NULL != pVersionInfo ){
                if(GetFileVersionInfo( strProgram, 0, dw, pVersionInfo )){
                    LPDWORD lptr = NULL;
                    VerQueryValue( pVersionInfo, _T("\\VarFileInfo\\Translation"), (void**)&lptr, (UINT*)&dw );
                    if( lptr != NULL ){
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("ProductVersion") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pVersion, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("OriginalFilename") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pProduct, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("LegalCopyright") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pCopyRight, (UINT*)&dw );
                    }
                
                    if( pProduct != NULL && pVersion != NULL && pCopyRight != NULL ){
                        _tprintf( _T("\nMicrosoft (R) %s (%s)\n%s\n\n"), pProduct, pVersion, pCopyRight );
                    }
                }
                free( pVersionInfo );
            }
        }
    }
}
// begin_sdk
void 
PrintHelpMessage()
/*++

Routine Description:

    Prints out help messages.

Arguments:

    None

Return Value:

    None

--*/
{
// end_sdk
    DisplayVersionInfo();
// begin_sdk
    _tprintf(
        _T("Usage: tracedmp [options]  <EtlFile1 EtlFile2 ...>| [-h | -? | -help]\n")
        _T("\t-o <file>          Output CSV file\n")
        _T("\t-rt [LoggerName]   Realtime tracedmp from the logger [LoggerName]\n")
        _T("\t-summary           Summary.txt only\n")
        _T("\t-begin HH:MM DD/MM/YY\n")
        _T("\t-end   HH:MM DD/MM/YY\n")
        _T("\t-h\n")
        _T("\t-help\n")
        _T("\t-?                 Display usage information\n")
        _T("\n")
        _T("\tDefault Etl File is C:\\Logfile.etl\n")
        _T("\tDefault output file is dumpfile.csv\n")
    );
}

// end_sdk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracefmt\tracefmt.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    traceformat.c

Abstract:

    Formats trace entries into messages based on the original sample trace
    consumer program (tracedmp).

Author:

    Jee Fung Pang (jeepang) 03-Dec-1997

Revision History:

    Ian Service (ianserv) 1999 - converted to message formatting

--*/

#ifdef __cplusplus
extern "C"{
#endif 
#define UNICODE
#define _UNICODE
#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <evntrace.h>
#define POBJECT_ATTRIBUTES PVOID
#include <ntwmi.h>
#include "traceprt.h"

#define DUMP_FILE_NAME          _T("FmtFile.txt")
#define SUMMARY_FILE_NAME       _T("FmtSum.txt")
#define DEFAULT_LOGFILE_NAME    _T("C:\\Logfile.Etl")

FILE* DumpFile = NULL;
FILE* SummaryFile = NULL;

BOOL fDebugDisplay = FALSE ;
BOOL fDisplayOnly  = FALSE ;
BOOL fSummaryOnly  = FALSE ;
BOOL fNoSummary    = FALSE ;
BOOL fVerbose	   = FALSE ;
BOOL fFixUp		   = FALSE ;
BOOL fODSOutput    = FALSE ;
BOOL fTMFSpecified = FALSE ;

#define SIZESUMMARYBLOCK 16384
TCHAR SummaryBlock[SIZESUMMARYBLOCK];

static FILETIME      lastTime ;

static ULONG TotalBuffersRead = 0;
static ULONG TotalEventsLost = 0;
static ULONG TotalEventCount = 0;
static ULONG TimerResolution = 10;
static ULONG BufferWrap = 0 ;
__int64 ElapseTime;

PLIST_ENTRY EventListHead = NULL;

void 
DumpMofList();

void
PrintMofInfo();

BOOL
CheckFile(
    LPTSTR fileName
    );

ULONG
BufferCallback(
    PEVENT_TRACE_LOGFILE pLog
    );

void 
AddMofFromWbem(
    LPTSTR EventGuid,
    LPTSTR PropName,
    DWORD  PropType
    );

void
DumpEvent(
    PEVENT_TRACE pEvent
    );

PEVENT_TRACE_LOGFILE EvmFile[MAXLOGFILES];
ULONG LogFileCount = 0;
ULONG UserMode = FALSE; // TODO: Pick this up from the stream itself.
TCHAR * szTraceMask = NULL;
void DisplayVersionInfo();

int
 __cdecl main (argc, argv)
    int argc;
    char **argv;
{
    TCHAR GuidFileName[MAXSTR];
    TCHAR DumpFileName[MAXSTR];
    TCHAR SummaryFileName[MAXSTR];
    LPTSTR *commandLine;
    LPTSTR *targv,  *cmdargv;
    PEVENT_TRACE_LOGFILE pLogFile;
    ULONG Action = 0;
    ULONG Status;
    ULONG GuidCount = 0;
    ULONG i, j;
    int targc;
    TRACEHANDLE HandleArray[MAXLOGFILES];

    if ((cmdargv = CommandLineToArgvW(
                        GetCommandLineW(),
                        &argc
                        )) == NULL)
    {
        return (GetLastError());
    } 
    targv = cmdargv;

    _tcscpy(DumpFileName, DUMP_FILE_NAME);
    _tcscpy(SummaryFileName, SUMMARY_FILE_NAME);

    // By default look for Define.guid in the image location

    Status = GetModuleFileName(NULL, GuidFileName, MAXSTR);

    if( Status != 0 ){
        TCHAR drive[10];
        TCHAR path[MAXSTR];
        TCHAR file[MAXSTR];
        TCHAR ext[MAXSTR];

        _tsplitpath( GuidFileName, drive, path, file, ext );
        _tcscpy(ext, GUID_EXT );
        _tcscpy(file, GUID_FILE );
        _tmakepath( GuidFileName, drive, path, file, ext );
    }else{
        _tcscpy( GuidFileName, GUID_FILE );
        _tcscat( GuidFileName, _T(".") );
        _tcscat( GuidFileName, GUID_EXT );
    }

    while (--argc > 0) {
        ++targv;
        if (**targv == '-' || **targv == '/') {  // argument found
            if( **targv == '/' ){
                **targv = '-';
            }

           if (targv[0][1] == 'h' || targv[0][1] == 'H'
                                       || targv[0][1] == '?')
           {
               DisplayVersionInfo();

               _tprintf(
                   _T("Usage: traceformat [options]  <evmfile>| [-h | -?]\n")
                   _T("\t-o <file>    Output file\n")
                   _T("\t-tmf <file> Format definition file\n")
                   _T("\t-rt          Realtime formatting\n")
                   _T("\t-h           Display this information\n")
                   _T("\t-display     Display output\n")
                   _T("\t-displayonly Display output. Don't write to the file\n")
                   _T("\t-nosummary   Don't create the summary file\n")
                   _T("\t-ods         do Display output using OutputDebugString\n")
                   _T("\t-summaryonly Don't create the listing file.\n")
		           _T("\t-v           Verbose Display\n")
                   _T("\t-?           Display this information\n")
                   _T("\n")
                   _T("\tDefault evmfile is    ") DEFAULT_LOGFILE_NAME _T("\n")
                   _T("\tDefault outputfile is ") DUMP_FILE_NAME _T("\n")
                   _T("\tDefault TMF file is   ") GUID_FILE _T(".") GUID_EXT _T("\n")
                   _T("\n")
                   _T("\tTMF file search path is read from environment variable\n")
                   _T("\t\tTRACE_FORMAT_SEARCH_PATH\n")
                   );
               return 0;
           }
           else if (!_tcsicmp(targv[0], _T("-debug"))) {
               fDebugDisplay = TRUE;
           }
           else if (!_tcsicmp(targv[0], _T("-display"))) {
               fDebugDisplay = TRUE ;
           }
           else if (!_tcsicmp(targv[0], _T("-displayonly"))) {
               fDisplayOnly = TRUE ;
           }
           else if (!_tcsicmp(targv[0], _T("-fixup"))) {
               fFixUp = TRUE;
           }
           else if (!_tcsicmp(targv[0], _T("-summary"))) {
               fSummaryOnly = TRUE;
           }
           else if (!_tcsicmp(targv[0], _T("-seq"))) {
               SetTraceFormatParameter(ParameterSEQUENCE, ULongToPtr(1));
           }
           else if (!_tcsicmp(targv[0], _T("-gmt"))) {
               SetTraceFormatParameter(ParameterGMT, ULongToPtr(1));
           }
           else if (!_tcsicmp(targv[0], _T("-nosummary"))) {
               fNoSummary = TRUE;
           }
           else if (!_tcsicmp(targv[0], _T("-rt"))) {
               TCHAR LoggerName[MAXSTR];
               _tcscpy(LoggerName, KERNEL_LOGGER_NAME);
               if (argc > 1) {
                   if (targv[1][0] != '-' && targv[1][0] != '/') {
                       ++targv; --argc;
                       _tcscpy(LoggerName, targv[0]);
                   }
               }
               
               pLogFile = malloc(sizeof(EVENT_TRACE_LOGFILE));
               if (pLogFile == NULL){
                   _tprintf(_T("Allocation Failure\n"));
                   
                   goto cleanup;
               }
               RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
               EvmFile[LogFileCount] = pLogFile;
               
               EvmFile[LogFileCount]->LogFileName = NULL;
               EvmFile[LogFileCount]->LoggerName =
                   (LPTSTR) malloc(MAXSTR*sizeof(TCHAR));
               
               if ( EvmFile[LogFileCount]->LoggerName == NULL ) {
                   _tprintf(_T("Allocation Failure\n"));
                   goto cleanup;
               }
               _tcscpy(EvmFile[LogFileCount]->LoggerName, LoggerName);
               
               _tprintf(_T("Setting RealTime mode for  %s\n"),
                        EvmFile[LogFileCount]->LoggerName);
               
               EvmFile[LogFileCount]->Context = NULL;
               EvmFile[LogFileCount]->BufferCallback = (PEVENT_TRACE_BUFFER_CALLBACKW)BufferCallback;
               EvmFile[LogFileCount]->BuffersRead = 0;
               EvmFile[LogFileCount]->CurrentTime = 0;
               EvmFile[LogFileCount]->EventCallback = (PEVENT_CALLBACK)&DumpEvent;
               EvmFile[LogFileCount]->LogFileMode =
                   EVENT_TRACE_REAL_TIME_MODE;
               LogFileCount++;
            }
            else if ( !_tcsicmp(targv[0], _T("-guid")) ) {    // maintain for compatabillity
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        _tcscpy(GuidFileName, targv[1]);
                        ++targv; --argc;
                        fTMFSpecified = TRUE ;
                    }
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-tmf")) ) { 
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        _tcscpy(GuidFileName, targv[1]);
                        ++targv; --argc;
                        fTMFSpecified = TRUE ;
                    }
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-v")) ) {
					fVerbose = TRUE ;
            }
            else if ( !_tcsicmp(targv[0], _T("-ods")) ) {
					fODSOutput = TRUE ;
            }
			else if ( !_tcsicmp(targv[0], _T("-onlyshow")) ) {
                if (argc > 1) {
                    szTraceMask = malloc((_tcslen(targv[1])+1) * sizeof(TCHAR));
                    _tcscpy(szTraceMask,targv[1]);
                    ++targv; --argc;
                }
            }
            else if ( !_tcsicmp(targv[0], _T("-o")) ) {
                if (argc > 1) {

                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        TCHAR drive[10];
                        TCHAR path[MAXSTR];
                        TCHAR file[MAXSTR];
                        TCHAR ext[MAXSTR];
                        ++targv; --argc;

                        _tfullpath(DumpFileName, targv[0], MAXSTR);
                        _tsplitpath( DumpFileName, drive, path, file, ext );
                        _tcscat(ext,_T(".sum"));  
                        _tmakepath( SummaryFileName, drive, path, file, ext );

                    }
                }
            }
        }
        else {
            pLogFile = malloc(sizeof(EVENT_TRACE_LOGFILE));
            if (pLogFile == NULL){ 
                _tprintf(_T("Allocation Failure(EVENT_TRACE_LOGFILE)\n")); // Need to cleanup better. 
                goto cleanup;
            }
            RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
            EvmFile[LogFileCount] = pLogFile;

            EvmFile[LogFileCount]->LoggerName = NULL;
            EvmFile[LogFileCount]->LogFileName = 
                (LPTSTR) malloc(MAXSTR*sizeof(TCHAR));
            if (EvmFile[LogFileCount]->LogFileName == NULL) {
                _tprintf(_T("Allocation Failure (LogFileName)\n"));
                goto cleanup;
            }
            
            _tfullpath(EvmFile[LogFileCount]->LogFileName, targv[0], MAXSTR);
            _tprintf(_T("Setting log file to: %s\n"),
                     EvmFile[LogFileCount]->LogFileName);
			            
            if (!CheckFile(EvmFile[LogFileCount]->LogFileName)) {
                _tprintf(_T("Cannot open logfile for reading\n"));
                goto cleanup;
            }
            EvmFile[LogFileCount]->Context = NULL;
            EvmFile[LogFileCount]->BufferCallback = (PEVENT_TRACE_BUFFER_CALLBACKW)BufferCallback;
            EvmFile[LogFileCount]->BuffersRead = 0;
            EvmFile[LogFileCount]->CurrentTime = 0;
            EvmFile[LogFileCount]->EventCallback = (PEVENT_CALLBACK)&DumpEvent;
            LogFileCount++;
        }
    }

    if( _tcslen( GuidFileName ) ){
        TCHAR str[MAXSTR];
        _tfullpath( str, GuidFileName, MAXSTR);
        _tcscpy( GuidFileName, str );
        _tprintf(_T("Getting guids from %s\n"), GuidFileName);
        GuidCount = GetTraceGuids(GuidFileName, (PLIST_ENTRY *) &EventListHead);
        if ((GuidCount <= 0) && fTMFSpecified)
        {
            _tprintf(_T("GetTraceGuids returned %d, GetLastError=%d, for %s\n"),
                        GuidCount,
                        GetLastError(),
                        GuidFileName);
        }
    }

    if (LogFileCount <= 0) {
        pLogFile = malloc(sizeof(EVENT_TRACE_LOGFILE));
        if (pLogFile == NULL){ 
            _tprintf(_T("Allocation Failure\n")); // Need to cleanup better. 
            goto cleanup;
        }
        RtlZeroMemory(pLogFile, sizeof(EVENT_TRACE_LOGFILE));
        EvmFile[0] = pLogFile;
        EvmFile[0]->LoggerName = NULL;
        LogFileCount = 1;
        EvmFile[0]->LogFileName = (LPTSTR) malloc(MAXSTR*sizeof(TCHAR));
        if (EvmFile[0]->LogFileName == NULL) {
            _tprintf(_T("Allocation Failure\n"));
            goto cleanup;
        }
        _tcscpy(EvmFile[0]->LogFileName, DEFAULT_LOGFILE_NAME);
        EvmFile[0]->EventCallback = (PEVENT_CALLBACK)&DumpEvent;
    }

    for (i = 0; i < LogFileCount; i++) {
        TRACEHANDLE x;
        x = OpenTrace(EvmFile[i]);
        HandleArray[i] = x;
        if (HandleArray[i] == 0) {
            _tprintf(_T("Error Opening Trace %d with status=%d\n"), 
                                                           i, GetLastError());

            for (j = 0; j < i; j++)
                CloseTrace(HandleArray[j]);
            goto cleanup;
        }
    }
    if (!fDisplayOnly) {
        DumpFile = _tfopen(DumpFileName, _T("w"));
        if (DumpFile == NULL) {
            _tprintf(_T("Format File \"%s\" Could not be opened for writing 0X%X\n"),
                        DumpFileName,GetLastError());
            goto cleanup;
        }
        SummaryFile = NULL ;
        if (!fNoSummary) {
            SummaryFile = _tfopen(SummaryFileName, _T("w"));
            if (SummaryFile == NULL) {
                _tprintf(_T("Summary File \"%s\" could not be opened for writing 0X%X\n"),
                            SummaryFileName,GetLastError());
                goto cleanup;
            }
        }
    } else {
        DumpFile = stdout;
        SummaryFile = stdout;
    }

    Status = ProcessTrace(HandleArray,
                 LogFileCount,
                 NULL, NULL);
    if (Status != ERROR_SUCCESS) {
        _tprintf(_T("Error processing trace entry with status=0x%x (GetLastError=0x%x)\n"),
                Status, GetLastError());
    }

    for (j = 0; j < LogFileCount; j++){
        Status = CloseTrace(HandleArray[j]);
        if (Status != ERROR_SUCCESS) {
            _tprintf(_T("Error Closing Trace %d with status=%d\n"), j, Status);
        }
    }


    if (!fNoSummary) {
        _ftprintf(SummaryFile,_T("Files Processed:\n"));
        for (i=0; i<LogFileCount; i++) {
            _ftprintf(SummaryFile,_T("\t%s\n"),EvmFile[i]->LogFileName);
        }
    
        GetTraceElapseTime(&ElapseTime);
    
        _ftprintf(SummaryFile,
                  _T("Total Buffers Processed %d\n")
                  _T("Total Events  Processed %d\n")
                  _T("Total Events  Lost      %d\n")
                  _T("Elapsed Time            %I64d sec\n"), 
                  TotalBuffersRead,
                  TotalEventCount,
                  TotalEventsLost,
                  (ElapseTime / 10000000) );
    
        _ftprintf(SummaryFile,
           _T("+-----------------------------------------------------------------------------------+\n")
           _T("|%10s    %-20s %-10s  %-36s|\n")
           _T("+-----------------------------------------------------------------------------------+\n"),
           _T("EventCount"),
           _T("EventName"),
           _T("EventType"),
           _T("Guid")
            );
    
        SummaryTraceEventList(SummaryBlock, SIZESUMMARYBLOCK, EventListHead);
        _ftprintf(SummaryFile,
               _T("%s+-----------------------------------------------------------------------------------+\n"),
               SummaryBlock);
    }

cleanup:
	
    CleanupTraceEventList(EventListHead);
    if (fVerbose) {
        _tprintf(_T("\n"));  // need a newline after the block updates
    }
    if (DumpFile != NULL)  {
        _tprintf(_T("Event traces dumped to %s\n"), DumpFileName);
        fclose(DumpFile);
    }

    if(SummaryFile != NULL){
        _tprintf(_T("Event Summary dumped to %s\n"), SummaryFileName);
        fclose(SummaryFile);
    }

    for (i = 0; i < LogFileCount; i ++)
    {
        if (EvmFile[i]->LoggerName != NULL)
        {
            free(EvmFile[i]->LoggerName);
            EvmFile[i]->LoggerName = NULL;
        }
        if (EvmFile[i]->LogFileName != NULL)
        {
            free(EvmFile[i]->LogFileName);
            EvmFile[i]->LogFileName = NULL;
        }
        free(EvmFile[i]);
    }

    GlobalFree(cmdargv);
    Status = GetLastError();
    if(Status != ERROR_SUCCESS ){
        _tprintf(_T("Exit Status: %d\n"), Status );
    }
    return 0;
}

void DisplayVersionInfo()
{
    TCHAR buffer[512];
    TCHAR strProgram[MAXSTR];
    DWORD dw;
    BYTE* pVersionInfo;
    LPTSTR pVersion = NULL;
    LPTSTR pProduct = NULL;
    LPTSTR pCopyRight = NULL;

    dw = GetModuleFileName(NULL, strProgram, MAXSTR);

    if( dw>0 ){

        dw = GetFileVersionInfoSize( strProgram, &dw );
        if( dw > 0 ){
     
            pVersionInfo = (BYTE*)malloc(dw);
            if( NULL != pVersionInfo ){
                if(GetFileVersionInfo( strProgram, 0, dw, pVersionInfo )){
                    LPDWORD lptr = NULL;
                    VerQueryValue( pVersionInfo, _T("\\VarFileInfo\\Translation"), (void**)&lptr, (UINT*)&dw );
                    if( lptr != NULL ){
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("ProductVersion") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pVersion, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("OriginalFilename") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pProduct, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("LegalCopyright") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pCopyRight, (UINT*)&dw );
                    }
                
                    if( pProduct != NULL && pVersion != NULL && pCopyRight != NULL ){
                        _tprintf( _T("\nMicrosoft (R) %s (%s)\n%s\n\n"), pProduct, pVersion, pCopyRight );
                    }
                }
                free( pVersionInfo );
            }
        }
    }
}

ULONG
BufferCallback(
    PEVENT_TRACE_LOGFILE pLog
    )
{
    ULONG i;
    ULONG Status;
    EVENT_TRACE_PROPERTIES LoggerProp;

    TotalBuffersRead++;
    TotalEventsLost += pLog->EventsLost;

	if (fVerbose) {

       FILETIME      stdTime, localTime;
       SYSTEMTIME    sysTime;

       RtlCopyMemory(&stdTime , &pLog->CurrentTime, sizeof(FILETIME));

       FileTimeToSystemTime(&stdTime, &sysTime);

       _tprintf(_T("%02d/%02d/%04d-%02d:%02d:%02d.%03d :: %8d: Filled=%8d, Lost=%3d"),
                    sysTime.wMonth,
                    sysTime.wDay,
                    sysTime.wYear,
                    sysTime.wHour,
                    sysTime.wMinute,
                    sysTime.wSecond,
                    sysTime.wMilliseconds,
					TotalBuffersRead,
					pLog->Filled,
					pLog->EventsLost);
	   _tprintf(_T(" TotalLost= %d\r"), TotalEventsLost);

	   if (CompareFileTime(&lastTime,&stdTime) == 1) {
		   _tprintf(_T("\nWARNING: time appears to have wrapped here (Block = %d)!\n"),TotalBuffersRead);
           BufferWrap = TotalBuffersRead;
	   }
	   lastTime = stdTime ;
	}

    return (TRUE);
}
#define DEFAULT_LOG_BUFFER_SIZE	1024

BOOL
CheckFile(
    LPTSTR fileName
    )
{
    HANDLE hFile;
	BYTE   LogHeaderBuffer[DEFAULT_LOG_BUFFER_SIZE];
	ULONG  nBytesRead ;
	ULONG  hResult ;
	PEVENT_TRACE pEvent;
	PTRACE_LOGFILE_HEADER logfileHeader ;
	LARGE_INTEGER lFileSize ;
	LARGE_INTEGER lFileSizeMB ;
	DWORD dwDesiredAccess , dwShareMode ;
	FILETIME      stdTime, localTime, endlocalTime, endTime;
	SYSTEMTIME    sysTime, endsysTime;
	PEVENT_TRACE_LOGFILE	pLogBuffer ;

	if (fFixUp) {
		dwShareMode = 0 ;
		dwDesiredAccess = GENERIC_READ | GENERIC_WRITE ;
	} else {
		dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE ;
		dwDesiredAccess = GENERIC_READ ;
	}
    hFile = CreateFile(
                fileName,
                dwDesiredAccess,
                dwShareMode,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
    if (hFile == INVALID_HANDLE_VALUE) {
		if (fFixUp) {
			_tprintf(_T("ERROR: Fixup could not open file, Error = 0x%X\n"),GetLastError());
			exit(GetLastError());
		}
		return(FALSE);
    }

	// While we are here we will look to see if the file is ok and fix up
	// Circular buffer anomolies
	if (((hResult = ReadFile(hFile,
					  (LPVOID)&LogHeaderBuffer,
						DEFAULT_LOG_BUFFER_SIZE,
						&nBytesRead,
						NULL)) == 0) || nBytesRead < DEFAULT_LOG_BUFFER_SIZE) {
        _tprintf(_T("ERROR: Fixup could not read file, Error = 0x%X, bytes read = %d(of %d)\n"),
                 GetLastError(),nBytesRead,DEFAULT_LOG_BUFFER_SIZE);
        exit(ERROR_BAD_ARGUMENTS);
    }
	pEvent = (PEVENT_TRACE)&LogHeaderBuffer ;
	logfileHeader = (PTRACE_LOGFILE_HEADER)&LogHeaderBuffer[sizeof(WMI_BUFFER_HEADER) + 
															sizeof(SYSTEM_TRACE_HEADER)];
	if (fVerbose) {

		_tprintf(_T("Dumping Logfile Header\n"));
        RtlCopyMemory(&stdTime , &(logfileHeader->StartTime), sizeof(FILETIME));
	    FileTimeToLocalFileTime(&stdTime, &localTime);
	    FileTimeToSystemTime(&localTime, &sysTime);

        RtlCopyMemory(&endTime , &(logfileHeader->EndTime), sizeof(FILETIME));
	    FileTimeToLocalFileTime(&endTime, &endlocalTime);
	    FileTimeToSystemTime(&endlocalTime, &endsysTime);

	    _tprintf(_T("\tStart Time	%02d/%02d/%04d-%02d:%02d:%02d.%03d\n"),
					sysTime.wMonth,
					sysTime.wDay,
					sysTime.wYear,
					sysTime.wHour,
					sysTime.wMinute,
					sysTime.wSecond,
					sysTime.wMilliseconds);
		_tprintf(_T("\tBufferSize           %d\n"), 
						logfileHeader->BufferSize);
		_tprintf(_T("\tVersion              %d\n"), 
						logfileHeader->Version);
		_tprintf(_T("\tProviderVersion      %d\n"), 
						logfileHeader->ProviderVersion);
		_tprintf(_T("\tEnd Time	%02d/%02d/%04d-%02d:%02d:%02d.%03d\n"),
					endsysTime.wMonth,
					endsysTime.wDay,
					endsysTime.wYear,
					endsysTime.wHour,
					endsysTime.wMinute,
					endsysTime.wSecond,
					endsysTime.wMilliseconds);
		_tprintf(_T("\tTimer Resolution     %d\n"), 
						logfileHeader->TimerResolution);
		_tprintf(_T("\tMaximum File Size    %d\n"), 
						logfileHeader->MaximumFileSize);
		_tprintf(_T("\tBuffers  Written     %d\n"), 
						logfileHeader->BuffersWritten);

/*
		_tprintf(_T("\tLogger Name          %ls\n"), 
						logfileHeader->LoggerName);
		_tprintf(_T("\tLogfile Name         %ls\n"), 
						logfileHeader->LogFileName);
*/
		_tprintf(_T("\tTimezone is %s (Bias is %dmins)\n"),
				logfileHeader->TimeZone.StandardName,logfileHeader->TimeZone.Bias);
        _tprintf(_T("\tLogfile Mode         %X "), 
						logfileHeader->LogFileMode);
		if (logfileHeader->LogFileMode == EVENT_TRACE_FILE_MODE_NONE) {
			_tprintf(_T("Logfile is off(?)\n"));
		} else if (logfileHeader->LogFileMode == EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
			_tprintf(_T("Logfile is sequential\n"));
		} else if (logfileHeader->LogFileMode == EVENT_TRACE_FILE_MODE_CIRCULAR) {
			_tprintf(_T("Logfile is circular\n"));
		}
		_tprintf(_T("\tProcessorCount        %d\n"), 
						logfileHeader->NumberOfProcessors);
	}

	if (GetFileSizeEx(hFile, &lFileSize) == 0) {
		_tprintf(_T("WARNING: Could not get file size, continuing\n"));
	} else {
		lFileSizeMB.QuadPart = lFileSize.QuadPart / (1024*1024) ;
		if (lFileSizeMB.QuadPart > logfileHeader->MaximumFileSize) {
			_tprintf(_T("WARNING: File size given as %dMB, should be %dMB\n"),
				logfileHeader->MaximumFileSize,lFileSizeMB.QuadPart);
			if (lFileSize.HighPart != 0) {
				_tprintf(_T("WARNING: Log file is TOO big"));
			}
			if (fFixUp) {
				logfileHeader->MaximumFileSize = lFileSizeMB.LowPart + 1 ;
			}
		}
	}

	if ((logfileHeader->LogFileMode == EVENT_TRACE_FILE_MODE_CIRCULAR) &&
		(logfileHeader->BuffersWritten== 0 )) {
		_tprintf(_T("WARNING: Circular Trace File did not have 'wrap' address\n"));
		if (fFixUp) {
			// Figure out the wrap address
			INT LowBuff = 1, HighBuff, CurrentBuff, MaxBuff ;
			FILETIME LowTime, HighTime, CurrentTime, MaxTime ;
			if (lFileSize.HighPart != 0) {
				_tprintf(_T("ERROR: File TOO big\n"));
				exit(-1);
			}
			MaxBuff = (LONG)(lFileSize.QuadPart / logfileHeader->BufferSize) - 1 ;
            _tprintf(_T("MaxBuff=%d\n"),MaxBuff);
			pLogBuffer = malloc(logfileHeader->BufferSize);
			if (SetFilePointer(hFile,0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
				_tprintf(_T("ERROR: Could not reset file to beginning for FixUp, Error = 0x%X"),
						GetLastError());
				exit(GetLastError());
			}
			for (CurrentBuff = 1 ; CurrentBuff <= MaxBuff; CurrentBuff++) {
				if (SetFilePointer(hFile,logfileHeader->BufferSize, NULL, FILE_CURRENT) == INVALID_SET_FILE_POINTER) {
					_tprintf(_T("ERROR: Could not set file to next buffer for FixUp, Error = 0x%X"),
							GetLastError());
					exit(GetLastError());
				}
				hResult = ReadFile(hFile,
								   (LPVOID)pLogBuffer,
									logfileHeader->BufferSize,
									&nBytesRead,
									NULL);
				BufferCallback((PEVENT_TRACE_LOGFILE)pLogBuffer);
			}
		}
	}
	if (fFixUp) {
		if (SetFilePointer(hFile,0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
			_tprintf(_T("ERROR: Could not reset file to beginning for FixUp, Error = 0x%X"),
					GetLastError());
			exit(GetLastError());
		}

        logfileHeader->BuffersWritten= BufferWrap ;

		if (!WriteFile(hFile,(LPVOID)LogHeaderBuffer,DEFAULT_LOG_BUFFER_SIZE,&nBytesRead, NULL)) {
			_tprintf(_T("ERROR: Could not Write file for FixUp, Error = 0x%X"),
					GetLastError());
			exit(GetLastError());
		}
        _tprintf(_T("INFO: Buffer Wrap reset to %d\n"),BufferWrap);
	}
	

    CloseHandle(hFile);

    return (TRUE);
}

#define SIZEEVENTBUF 8192
TCHAR EventBuf[SIZEEVENTBUF];
void
DumpEvent(
    PEVENT_TRACE pEvent
    )
{

    TotalEventCount++;

    if (pEvent == NULL) {
        _tprintf(_T("pEvent is NULL\n"));
        return;
    }
    // DumpEvent() is only a wrapper, it calls FormatTraceEvent() in TracePrt.
    //
    if (FormatTraceEvent(EventListHead,pEvent,EventBuf,SIZEEVENTBUF,NULL) > 0)
    {
        if (!fSummaryOnly && !fDisplayOnly) {
            _ftprintf(DumpFile, _T("%s\n"),EventBuf);
        }
        if (fDebugDisplay || fDisplayOnly) {
            if (fODSOutput) {
                OutputDebugString(EventBuf);
                OutputDebugString(_T("\n"));
            } else {
                _tprintf(_T("%s\n"),EventBuf);
            }
        }
    }
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\traceprt\traceprt.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    traceprt.h

Abstract:

    Trace formatting external definitions.

Revision History:

--*/
#ifdef __cplusplus
extern "C"{
#endif
#ifndef _TRACEPRT_
#define _TRACEPRT_

#define MAXLOGFILES       16
#define MAXSTR          1024

#define GUID_FILE       _T("default")
#define GUID_EXT        _T("tmf")

//
// Now the routines we export
//

#ifndef TRACE_API
#ifdef TRACE_EXPORTS
#define TRACE_API __declspec(dllexport)
#else
#define TRACE_API __declspec(dllimport)
#endif
#endif

#ifdef UNICODE
#define FormatTraceEvent        FormatTraceEventW
#define GetTraceGuids           GetTraceGuidsW
#define SummaryTraceEventList   SummaryTraceEventListW
#else
#define FormatTraceEvent        FormatTraceEventA
#define GetTraceGuids           GetTraceGuidsA
#define SummaryTraceEventList   SummaryTraceEventListA
#endif

TRACE_API SIZE_T
WINAPI
FormatTraceEventA(
        PLIST_ENTRY  HeadEventList,
        PEVENT_TRACE pEvent,
        CHAR       * EventBuf,
        ULONG        SizeEventBuf,
        CHAR       * pszMask
        );

TRACE_API ULONG 
WINAPI
GetTraceGuidsA(
        CHAR        * GuidFile, 
        PLIST_ENTRY * EventListHeader
        );

TRACE_API void
WINAPI
SummaryTraceEventListA(
        CHAR      * SummaryBlock ,
        ULONG       SizeSummaryBlock ,
        PLIST_ENTRY EventListhead
        );

TRACE_API SIZE_T
WINAPI
FormatTraceEventW(
        PLIST_ENTRY    HeadEventList,
        PEVENT_TRACE   pEvent,
        TCHAR        * EventBuf,
        ULONG          SizeEventBuf,
        TCHAR        * pszMask
        );

TRACE_API ULONG 
WINAPI
GetTraceGuidsW(
        LPTSTR        GuidFile, 
        PLIST_ENTRY * EventListHeader
        );

TRACE_API void
WINAPI
SummaryTraceEventListW(
        TCHAR     * SummaryBlock,
        ULONG       SizeSummaryBlock,
        PLIST_ENTRY EventListhead
        );

TRACE_API void
WINAPI
CleanupTraceEventList(
        PLIST_ENTRY EventListHead
        );

TRACE_API void
WINAPI
GetTraceElapseTime(
        __int64 * pElpaseTime
        );

typedef enum _PARAM_TYPE
{
    ParameterINDENT,
    ParameterSEQUENCE,
    ParameterGMT,
    ParameterTraceFormatSearchPath
} PARAMETER_TYPE ;


TRACE_API ULONG
WINAPI
SetTraceFormatParameter(
        PARAMETER_TYPE  Parameter ,
        PVOID           ParameterValue 
        );

TRACE_API ULONG
WINAPI
GetTraceFormatParameter(
        PARAMETER_TYPE  Parameter ,
        PVOID           ParameterValue 
        );

#endif  // #ifndef _TRACEPRT_

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\traceprt\traceprt.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    traceprt.c

Abstract:

    Trace formatting library. Converts binary trace file to CSV format,
    and other formattted string formats.

Author:

    Jee Fung Pang (jeepang) 03-Dec-1997

Revision History:

    GorN: 10/09/2000: ItemHRESULT added

--*/
#ifdef __cplusplus
extern "C"{
#endif
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <evntrace.h>
#include <ntwmi.h>
#include <netevent.h>
#include <netevent.dbg>
#include <winerror.dbg>
#pragma warning( disable : 4005)  // Disable warning message 4005
#include <ntstatus.h>
#include <ntstatus.dbg>
#pragma warning( default : 4005)  // Enable warning message 4005
#define TRACE_EXPORTS 1
#include "traceint.h"
#undef TRACE_API
#define TRACE_API
#include "traceprt.h"

#include <sddl.h> // for ConvertStringSidToSid //

// %1                   GUID Friendly Name                      string
// %2                   GUID SubType Name                       string
// %3                   Thread ID                               ULONG_PTR
// %4                   System Time                             String
// %5                   Kernel Time     or User Time            String
// %6                   User Time       or NULL                 String
// %7                   Sequence Number                         LONG
// %8                   Unused                                  String
// %9                   CPU Number                              LONG
// %128                 Indent                                  String

ULONG TimerResolution = 10;
__int64 ElapseTime;

ULONG UserMode = FALSE ; // TODO: Pick this up from the stream itself.

#define MAXBUFS    4096
#define MAXCHARS    MAXBUFS/sizeof(TCHAR)
#define MAXBUFS2    2 * MAXBUFS
#define MAXCHARS2   MAXBUFS2/sizeof(TCHAR)
#define MAXITEMS    256
#define MAXINDENT   256
#define MAXNAMEARG  256

TCHAR   ItemBuf[MAXBUFS];      // Temporary String Item buffer
TCHAR   ItemBBuf[MAXBUFS2];     // Item String Buffer
TCHAR * pItemBuf[MAXITEMS];    // Pointer to items in the String Item Buffer.
BYTE    ItemRBuf[MAXBUFS];     // Item Raw Byte Buffer
ULONG_PTR * pItemRBuf[MAXITEMS];   // Pointer to Raw Byte Items
SIZE_T  ItemRSize;             // Size of Item in Raw Buffer.
BOOL	bItemIsString = FALSE ;	// And type of item
int     iItemCount, i;
LONG    ItemsInBuf = 0;
LONG    ItemsInRBuf = 0;
ULONG PointerSize = sizeof(PVOID) ;
BYTE  Event[4096];
HANDLE hLibrary ;
TCHAR   StdPrefix[MAXSTR];
TCHAR   IndentBuf[MAXINDENT + 1];
INT     Indent;

#define TRACE_FORMAT_SEARCH_PATH L"TRACE_FORMAT_SEARCH_PATH"
#define TRACE_FORMAT_PREFIX      L"TRACE_FORMAT_PREFIX"
//#define STD_PREFIX               L"[%!CPU!]%!PID!.%!TID!::%!NOW! [%!FILE!] "
#define STD_PREFIX_NOSEQ         L"[%9!d!]%8!04X!.%3!04X!::%4!s! [%1!s!]"
#define STD_PREFIX_SEQ           L"[%9!d!]%8!04X!.%3!04X!::%4!s! %7!08x! [%1!s!]"

TCHAR *STD_PREFIX = STD_PREFIX_NOSEQ;
BOOL   bSequence = FALSE;
BOOL   bGmt = FALSE;
BOOL   bIndent = FALSE;

TCHAR *pNoValueString = _T("<NoValue>");

void ReplaceStringUnsafe(TCHAR* buf, TCHAR* find, TCHAR* replace)
{
    TCHAR source[MAXCHARS], *src, *dst;
    int nf = _tcslen(find);
    int nr = _tcslen(replace);

    src = source;
    dst = buf;

    _tcsncpy(source, buf, MAXCHARS );

    for(;;) {
        TCHAR* p = src;
        for(;;) {
            p = _tcsstr(p, find);
            if (!p) goto exit_outer_loop;
            // special kludge not to replace
            // %!Someting! when it is actually %%!Something!
            if (p == source || p[0] != '%' || p[-1] != '%') {
                break;
            }
            p += nf;
        }
        memcpy(dst, src, (p-src) * sizeof(TCHAR) );
        dst += p-src;
        src = p + nf;
        _tcsncpy(dst, replace,(MAXCHARS - (p-source)));
        dst += nr;
    }
exit_outer_loop:
    _tcscpy(dst, src);
}

TCHAR* FindValue(TCHAR* buf, TCHAR* ValueName) 
{
    static TCHAR valueBuf[256]; // largest identifier in PDB
    TCHAR *p = _tcsstr(buf, ValueName); 
    TCHAR *q = p;   
    if (p) {
         p += _tcslen(ValueName);
         q = p;
         while ( *p && !isspace(*p) ) ++p;
         memcpy(valueBuf, q, (p-q) * sizeof(TCHAR) );
    }
    valueBuf[p-q] = 0;
    return valueBuf;
}

int FindIntValue(TCHAR* buf, TCHAR* ValueName)
{
    TCHAR* v = FindValue(buf, ValueName), *end;
    int sgn = 1;
    
    if (v[0] == '+') {
       ++v;
    } else if (v[0] == '-') {
       sgn = -1;
       ++v;
    } 
    return sgn * _tcstol(v, &end, 10);
}


PMOF_INFO
GetMofInfoHead(
        OUT PLIST_ENTRY * EventListhead,
        IN  LPGUID        pGuid,
        IN  LPTSTR        strType,
        IN  LONG          TypeIndex,
        IN  ULONG         TypeOfType,
        IN  LPTSTR        TypeFormat,
        IN  BOOL          bBestMatch
    );

void   RemoveMofInfo(PLIST_ENTRY pMofInfo);
ULONG  ahextoi(TCHAR *s);
PTCHAR GuidToString(PTCHAR s, LPGUID piid);


ULONG
WINAPI
GetTraceGuidsW(
        TCHAR       * GuidFile,
        PLIST_ENTRY * HeadEventList
        );



static
void
reduce(
        PCHAR Src
        )
{
    char *Start = Src;
    if (!Src)
        return;
    while (*Src)
    {
        if ('\t' == *Src)
            *Src = ' ';
        else if (',' == *Src)
            *Src = ' ';
        else if ('\n' == *Src)
            *Src = ',';
        else if ('\r' == *Src)
            *Src = ' ';
        ++Src;
    }
    --Src;
    while ((Start < Src) && ((' ' == *Src) || (',' == *Src)))
    {
        *Src = 0x00;
        --Src;
    }
}

static void reduceW(WCHAR *Src)
{
    WCHAR *Start = Src;
    if (!Src)
        return;
    while (*Src)
    {
        if (L'\t' == *Src)
            *Src = L' ';
        else if (L',' == *Src)
            *Src = L' ';
        else if (L'\n' == *Src)
            *Src = L',';
        else if (L'\r' == *Src)
            *Src = L' ';
        ++Src;
    }
    --Src;
    while ((Start < Src) && ((L' ' == *Src) || (L',' == *Src)))
    {
        *Src = 0x00;
        --Src;
    }
}

#ifdef UNICODE
# define _stnprintf _snwprintf
#else
# define _stnprintf _snprintf
#endif

int FormatTimeDelta(TCHAR *buffer, size_t count, LONGLONG time)
{
	SYSTEMTIME st;
	int s = 0, result;
	ZeroMemory(&st, sizeof(st) );

	if (count == 0)
		return -1;

	if (time < 0) {
		*buffer++ = '-'; 
		--count;
		time = -time;
		s = 1;
	}

	// Get rid of the nano and micro seconds

	time /= 10000;

	st.wMilliseconds = (USHORT)(time % 1000);
	time /= 1000;

	if (time == 0) {
		result = _stnprintf(buffer,count,L"%dms",st.wMilliseconds); 
		goto end;
	}

	st.wSecond = (USHORT)(time % 60);

	time /= 60;

	st.wMinute = (USHORT)(time % 60);

	time /= 60;

	if (time == 0) {
		if (st.wMinute <= 10) {
			result = _stnprintf(buffer,count,L"%d.%03ds",st.wMinute * 60 + st.wSecond, st.wMilliseconds); 
		} else {
			result = _stnprintf(buffer,count,L"%d:%d.%03ds",st.wMinute, st.wSecond, st.wMilliseconds); 
		}
		goto end;
	}
	st.wHour = (USHORT)(time % 24);

	time /= 24;
	if (time == 0) {
		result = _stnprintf(buffer,count,L"%d:%d:%d.%03ds",st.wHour, st.wMinute, st.wSecond, st.wMilliseconds); 
		goto end;
	}
	st.wDay = (USHORT)time;

	result = _stnprintf(buffer,count,L"%d~%d:%d:%d.%03ds",st.wDay,st.wHour, st.wMinute, st.wSecond, st.wMilliseconds); 
end:
	if (result >= 0)
		result += s;
	return result;
}

typedef struct _ERROR_MAP{
    NTSTATUS MessageId;
    char *SymbolicName;
} ERROR_MAP;

SIZE_T
WINAPI
FormatTraceEventW(
        PLIST_ENTRY HeadEventList,
        PEVENT_TRACE pInEvent,
        TCHAR *EventBuf,
        ULONG SizeEventBuf,
        TCHAR * pszMask
    )
{
    PEVENT_TRACE_HEADER pHeader;
    PEVENT_TRACE        pEvent = NULL;
    ULONG               TraceMarker, TraceType;
    TCHAR               tstrName[MAXSTR];
    TCHAR               tstrType[MAXSTR];
    ULONG               tstrTypeOfType = 0;
    TCHAR             * tstrFormat;
    int                 iItemCount, i;
    SIZE_T              ItemsInBuf = 0;
    ULONG_PTR           MessageSequence = -1 ;
    USHORT              MessageNumber = 0 ;
    USHORT              MessageFlags = 0 ;
    char              * pMessageData ;
    ULONG               MessageLength ;


    if (pInEvent == NULL)
    {
        return (0);
    }

    pEvent = pInEvent ;
    // Make a copy of the PTR and length as we may adjust these depending
    // on the header
    pMessageData = pEvent->MofData ;
    MessageLength = pEvent->MofLength ;


    TraceMarker =  ((PSYSTEM_TRACE_HEADER)pInEvent)->Marker;

    if ((TraceMarker & TRACE_MESSAGE)== TRACE_MESSAGE ) {

        // This handles the TRACE_MESSAGE type.

        TraceType = TRACE_HEADER_TYPE_MESSAGE ;             // This one has special processing

        //
        // Now Process the header options
        //

        MessageNumber =  ((PMESSAGE_TRACE_HEADER)pEvent)->Packet.MessageNumber ;    // Message Number
        MessageFlags =   ((PMESSAGE_TRACE_HEADER)pEvent)->Packet.OptionFlags ;

        // Note that the order in which these are added is critical New entries must
        // be added at the end!
        //
        // [First Entry] Sequence Number
        if (MessageFlags&TRACE_MESSAGE_SEQUENCE) {
            RtlCopyMemory(&MessageSequence, pMessageData, sizeof(ULONG)) ;
            pMessageData += sizeof(ULONG) ;
            MessageLength -= sizeof(ULONG);
        }

        // [Second Entry] GUID ? or CompnentID ?
        if (MessageFlags&TRACE_MESSAGE_COMPONENTID) {
            RtlCopyMemory(&pEvent->Header.Guid,pMessageData,sizeof(ULONG)) ;
            pMessageData += sizeof(ULONG) ;
            MessageLength -= sizeof(ULONG) ;
        } else if (MessageFlags&TRACE_MESSAGE_GUID) { // Can't have both
            RtlCopyMemory(&pEvent->Header.Guid,pMessageData, sizeof(GUID));
            pMessageData += sizeof(GUID) ;
            MessageLength -= sizeof(GUID);
        }

        // [Third Entry] Timestamp?
        if (MessageFlags&TRACE_MESSAGE_TIMESTAMP) {
            RtlCopyMemory(&pEvent->Header.TimeStamp,pMessageData,sizeof(LARGE_INTEGER));
            pMessageData += sizeof(LARGE_INTEGER);
            MessageLength -= sizeof(LARGE_INTEGER);
        }

        // [Fourth Entry] System Information?
        if (MessageFlags&TRACE_MESSAGE_SYSTEMINFO) {
            pHeader = (PEVENT_TRACE_HEADER) &pEvent->Header;
            RtlCopyMemory(&pHeader->ThreadId, pMessageData, sizeof(ULONG)) ;
            pMessageData += sizeof(ULONG);
            MessageLength -=sizeof(ULONG);
            RtlCopyMemory(&pHeader->ProcessId,pMessageData, sizeof(ULONG)) ;
            pMessageData += sizeof(ULONG);
            MessageLength -=sizeof(ULONG);
        }
        //
        // Add New Header Entries immediately before this comment!
        //
    }
    else
    {
        // Must be WNODE_HEADER
        //
        TraceType = 0;
        pEvent = pInEvent ;

        MessageNumber = pEvent->Header.Class.Type ;
        if (MessageNumber == 0xFF) {   // W2K Compatability escape code
            if (pEvent->MofLength >= sizeof(USHORT)) {
                // The real Message Number is in the first USHORT
                memcpy(&MessageNumber,pEvent->MofData,sizeof(USHORT)) ;
                pMessageData += sizeof(USHORT);
                MessageLength -= sizeof(USHORT);
            }
        }
    }
    // Reset the Pointer and length if they have been adjusted
    pEvent->MofData = pMessageData ;
    pEvent->MofLength = MessageLength ;


    pHeader = (PEVENT_TRACE_HEADER) &pEvent->Header;
    MapGuidToName(
            &HeadEventList,
            & pEvent->Header.Guid,
            MessageNumber,
            tstrName);

    if (   IsEqualGUID(&pEvent->Header.Guid, &EventTraceGuid)
        && pEvent->Header.Class.Type == EVENT_TRACE_TYPE_INFO)
    {
        PTRACE_LOGFILE_HEADER head = (PTRACE_LOGFILE_HEADER)pEvent->MofData;
        if (head->TimerResolution > 0)
        {
            TimerResolution = head->TimerResolution / 10000;
        }
        ElapseTime = head->EndTime.QuadPart -
                        pEvent->Header.TimeStamp.QuadPart;
        PointerSize =  head->PointerSize;
        if (PointerSize < 2 )       // minimum is 16 bits
            PointerSize = 4 ;       // defaults = 32 bits
    }

    if (pEvent != NULL)
    {
        PITEM_DESC  pItem;
        char        str[MAXSTR];
#ifdef    UNICODE
        TCHAR       wstr[MAXSTR];
#endif    /* #ifdef UNICODE */
        PCHAR       ptr     = NULL;
        PCHAR       iMofPtr = NULL;
        ULONG       ulongword;
        PMOF_INFO   pMofInfo = NULL;
        PLIST_ENTRY Head, Next;
        int         i;

        pMofInfo = GetMofInfoHead(
                (PLIST_ENTRY *) HeadEventList,
                &pEvent->Header.Guid,
                NULL,
                MessageNumber,
                0,
                NULL,
                TRUE);

        if((pMofInfo != NULL) && (pMofInfo->strType != NULL))
        {
         TCHAR* p ;
            _sntprintf(tstrType,MAXSTR,_T("%s"),pMofInfo->strType);
            tstrFormat     = pMofInfo->TypeFormat; //  Pointer to the format string
            tstrTypeOfType = pMofInfo->TypeOfType; // And the type of Format
            p = tstrFormat;
            if(p) {
                while (*p != 0) {
                    if(*p == 'Z' && p > tstrFormat && p[-1] == '!' && p[1] == '!') {
                        *p = 's';
                    }
                ++p;
                }
            }
        }
        else
        {
            _sntprintf(tstrType,MAXSTR,_T("%3d"),MessageNumber);
            tstrFormat = NULL ;
            tstrTypeOfType = 0 ;
        }
 
        // From here on we start processing the parameters, we actually do
        // two versions. One is built for original #type format statements,
        // and everything is converted to being an ASCII string.
        // The other is built for #type2 format statements and everything is
        // converted into a string of raw bytes aliggned on a 64-bit boundary.

        iItemCount = 0 ;                    // How many Items we process
        for (i = 0; i < MAXITEMS; i++)      // Clean up the pointers
        {
            pItemBuf[i]  = pNoValueString;
			pItemRBuf[i] = 0 ;
        }

        RtlZeroMemory(ItemBuf,  MAXBUFS      * sizeof(TCHAR));
        RtlZeroMemory(ItemBBuf, (2*MAXBUFS)      * sizeof(TCHAR));
        RtlZeroMemory(ItemRBuf, MAXBUFS      * sizeof(BYTE));
        RtlZeroMemory(EventBuf, SizeEventBuf * sizeof(TCHAR));

        pItemBuf[iItemCount] = ItemBBuf;       // Where they go (Strings)


        // Make Parameter %1 Type Name

        _sntprintf(pItemBuf[iItemCount],
                   MAXBUFS2-ItemsInBuf, 
                   _T("%s"), 
                   tstrName);
        pItemBuf[iItemCount + 1] =
                    pItemBuf[iItemCount] + _tcslen(tstrName) + 1;
        ItemsInBuf = ItemsInBuf + _tcslen(tstrName) + 1;
        pItemRBuf[iItemCount] = (ULONG_PTR *) pItemBuf[iItemCount]; // just use the same for Raw bytes
        iItemCount ++;

        // Make Parameter %2 Type sub Type

        _sntprintf(pItemBuf[iItemCount], 
                   MAXBUFS2-ItemsInBuf,
                   _T("%s"), 
                   tstrType);
        pItemBuf[iItemCount + 1] =
                    pItemBuf[iItemCount] + _tcslen(tstrType) + 1;
        ItemsInBuf = ItemsInBuf + _tcslen(tstrType) + 1;
        pItemRBuf[iItemCount] = (ULONG_PTR *)pItemBuf[iItemCount]; // just use the same for raw bytes
        iItemCount ++;

        // Make Parameter %3 ThreadId
        RtlCopyMemory(&pItemRBuf[iItemCount] , &pHeader->ThreadId, sizeof(ULONG)) ;
        _sntprintf(ItemBuf,
                   MAXBUFS,
                   _T("0x%04X"),
                   pItemRBuf[iItemCount]);
        _sntprintf(pItemBuf[iItemCount], 
                   MAXBUFS2-ItemsInBuf,
                   _T("0x%04X"), 
                   pHeader->ThreadId);
        pItemBuf[iItemCount + 1] =
                    pItemBuf[iItemCount] + _tcslen(ItemBuf) + 1;
        ItemsInBuf = ItemsInBuf + _tcslen(ItemBuf) + 1;
        iItemCount++;

        // Make Parameter %4 System Time
        if (tstrFormat != NULL)
        {

            FILETIME      stdTime, localTime;
            SYSTEMTIME    sysTime;
            
            stdTime.dwHighDateTime = pEvent->Header.TimeStamp.HighPart;
            stdTime.dwLowDateTime  = pEvent->Header.TimeStamp.LowPart;
            if (bGmt) {
                FileTimeToSystemTime(&stdTime, &sysTime);
            } else {
                FileTimeToLocalFileTime(&stdTime, &localTime);
                FileTimeToSystemTime(&localTime, &sysTime);
            }

            _sntprintf(ItemBuf, 
                       MAXBUFS,
                       _T("%02d/%02d/%04d-%02d:%02d:%02d.%03d"),
                       sysTime.wMonth,
                       sysTime.wDay,
                       sysTime.wYear,
                       sysTime.wHour,
                       sysTime.wMinute,
                       sysTime.wSecond,
                       sysTime.wMilliseconds);
        }
        else
        {
            _sntprintf(ItemBuf, MAXBUFS, _T("%20I64u"), pHeader->TimeStamp.QuadPart);
        }
        _sntprintf(pItemBuf[iItemCount], 
                   MAXBUFS2-ItemsInBuf,
                   _T("%s"), 
                   ItemBuf);
        pItemBuf[iItemCount + 1] =
                    pItemBuf[iItemCount] + _tcslen(ItemBuf) + 1;
        ItemsInBuf = ItemsInBuf + _tcslen(ItemBuf) + 1;
        pItemRBuf[iItemCount] = (ULONG_PTR *)pItemBuf[iItemCount]; // just use the same
        iItemCount ++;

        if (!UserMode)
        {
            // Make Parameter %5 Kernel Time
            _sntprintf(ItemBuf, 
                       MAXBUFS, 
                       _T("%8lu"),
                       pHeader->KernelTime * TimerResolution);
            _sntprintf(pItemBuf[iItemCount], 
                       MAXBUFS2-ItemsInBuf,
                       _T("%s"), 
                       ItemBuf);
            pItemBuf[iItemCount + 1] =
                        pItemBuf[iItemCount] + _tcslen(ItemBuf) + 1;
            ItemsInBuf = ItemsInBuf + _tcslen(ItemBuf) + 1;
            pItemRBuf[iItemCount] = (ULONG_PTR *) pItemBuf[iItemCount]; // just use the same
            iItemCount ++;

            // Make Parameter %6 User Time
            _sntprintf(ItemBuf, 
                       MAXBUFS,
                       _T("%8lu"),
                       pHeader->UserTime * TimerResolution);

            _sntprintf(pItemBuf[iItemCount], 
                       MAXBUFS2-ItemsInBuf,
                       _T("%s"), 
                       ItemBuf);
            pItemBuf[iItemCount + 1] =
                        pItemBuf[iItemCount] + _tcslen(ItemBuf) + 1;
            ItemsInBuf = ItemsInBuf + _tcslen(ItemBuf) + 1;
            pItemRBuf[iItemCount] = (ULONG_PTR *) pItemBuf[iItemCount]; // just use the same
            iItemCount ++;
        }
        else
        {
            // Make Parameter %5 processor Time
            _sntprintf(ItemBuf, MAXBUFS,_T("%I64u"), pHeader->ProcessorTime);
            _sntprintf(pItemBuf[iItemCount], MAXBUFS2-ItemsInBuf,_T("%s"), ItemBuf);
            pItemBuf[iItemCount + 1] =
                        pItemBuf[iItemCount] + _tcslen(ItemBuf) + 1;
            ItemsInBuf = ItemsInBuf + _tcslen(ItemBuf) + 1;
            pItemRBuf[iItemCount] = (ULONG_PTR *) pItemBuf[iItemCount]; // just use the same
            iItemCount ++;

            // Make Parameter %6 NULL
            _sntprintf(ItemBuf, MAXBUFS, _T("%s"), NULL);
            _sntprintf(pItemBuf[iItemCount], MAXBUFS2-ItemsInBuf,_T("%s"), ItemBuf);
            pItemBuf[iItemCount + 1] =
                        pItemBuf[iItemCount] + _tcslen(ItemBuf) + 1;
            ItemsInBuf = ItemsInBuf + _tcslen(ItemBuf) + 1;
            pItemRBuf[iItemCount] = (ULONG_PTR *) pItemBuf[iItemCount]; // just use the same
            iItemCount ++;
        }

        // Make Parameter %7  Sequence Number
        _sntprintf(ItemBuf, MAXBUFS, _T("%d"), MessageSequence);
        _sntprintf(pItemBuf[iItemCount], MAXBUFS2-ItemsInBuf, _T("%s"), ItemBuf);
        pItemBuf[iItemCount + 1] =
                    pItemBuf[iItemCount] + _tcslen(ItemBuf) + 1;
        ItemsInBuf = ItemsInBuf + _tcslen(ItemBuf) + 1;
        pItemRBuf[iItemCount] = (ULONG_PTR *) MessageSequence ; // Raw just point at the value
        iItemCount ++;

        // Make Parameter %8 ProcessId
        RtlCopyMemory(&pItemRBuf[iItemCount],&pHeader->ProcessId,sizeof(ULONG));
        _sntprintf(ItemBuf,MAXBUFS,_T("0x%04X"),pItemRBuf[iItemCount]);
        _sntprintf(pItemBuf[iItemCount], MAXBUFS2-ItemsInBuf, _T("%s"), ItemBuf);
        pItemBuf[iItemCount + 1] =
                    pItemBuf[iItemCount] + _tcslen(ItemBuf) + 1;
        ItemsInBuf = ItemsInBuf + _tcslen(ItemBuf) + 1;
        iItemCount ++;

        // Make Parameter %9 CPU Number
        _sntprintf(ItemBuf, 
                   MAXBUFS,
                   _T("%d"),
                   ((PWMI_CLIENT_CONTEXT)&(pEvent->ClientContext))->ProcessorNumber);
        _sntprintf(pItemBuf[iItemCount], MAXBUFS2-ItemsInBuf, _T("%s"), ItemBuf);
        pItemBuf[iItemCount + 1] =
                    pItemBuf[iItemCount] + _tcslen(ItemBuf) + 1;
        ItemsInBuf = ItemsInBuf + _tcslen(ItemBuf) + 1;
        pItemRBuf[iItemCount] = (ULONG_PTR *) (((PWMI_CLIENT_CONTEXT)&(pEvent->ClientContext))->ProcessorNumber) ;
        iItemCount ++;

        // Done processing Parameters

        if (pMofInfo != NULL) {
            Head = pMofInfo->ItemHeader;
            pMofInfo->EventCount ++;
            Next = Head->Flink;
        } else {
            Head = Next = NULL ;
        }

        __try {
            iMofPtr = (char *) malloc(pEvent->MofLength + sizeof(UNICODE_NULL));

			if(iMofPtr == NULL)
				return -1;

            RtlZeroMemory(iMofPtr, pEvent->MofLength + sizeof(UNICODE_NULL));
            RtlCopyMemory(iMofPtr, pEvent->MofData, pEvent->MofLength);
            ptr = iMofPtr;
			while (Head != Next)
			{
				ULONG     * ULongPtr     = (ULONG *)     & ItemRBuf[0];
				USHORT    * UShortPtr    = (USHORT *)    & ItemRBuf[0];
				LONGLONG  * LongLongPtr  = (LONGLONG *)  & ItemRBuf[0];
				ULONGLONG * ULongLongPtr = (ULONGLONG *) & ItemRBuf[0];
				double    * DoublePtr    = (double *)    & ItemRBuf[0];

                TCHAR * PtrFmt1, * PtrFmt2 ;

				pItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);

				if ((ULONG) (ptr - iMofPtr) >= pEvent->MofLength)
				{
					break;
				}

				RtlZeroMemory(ItemBuf,  MAXBUFS * sizeof(TCHAR));
				RtlZeroMemory(ItemRBuf, MAXBUFS * sizeof(BYTE));
				
				bItemIsString = FALSE ; // Assume its a RAW value
				ItemRSize = 0 ;			// Raw length of zero

				switch (pItem->ItemType)
				{
				case ItemChar:
				case ItemUChar:
					ItemRSize = sizeof(CHAR);
					RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
					_sntprintf(ItemBuf, MAXBUFS, _T("%c"), ItemRBuf);
					ptr += ItemRSize;
					break;

				case ItemCharSign:
					ItemRSize = sizeof(CHAR) * 2;
					RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
					ItemRBuf[2] = '\0';
					_sntprintf(ItemBuf, MAXBUFS,_T("\"%s\""), ItemRBuf);
					ptr += ItemRSize;
					break;

				case ItemCharShort:
					ItemRSize = sizeof(CHAR);
					RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
					_sntprintf(ItemBuf, MAXBUFS, _T("%d"), * ItemRBuf);
					ptr += ItemRSize;
					break;

				case ItemShort:
					ItemRSize = sizeof(USHORT);
					RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
					_sntprintf(ItemBuf,MAXBUFS, _T("%6d"), * UShortPtr);
					ptr += ItemRSize;
					break;

                case ItemDouble:
                    ItemRSize = sizeof(double);
					RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
					_sntprintf(ItemBuf,MAXBUFS, _T("%g"), * DoublePtr);
					ptr += ItemRSize;
					ItemRSize = 0; // FormatMessage cannot print 8 byte stuff properly on x86
					break;

				case ItemUShort:
					ItemRSize = sizeof(USHORT);
					RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
					_sntprintf(ItemBuf,MAXBUFS, _T("%6u"), * UShortPtr);
					ptr += ItemRSize;
					break;

				case ItemLong:
					ItemRSize = sizeof(LONG);
					RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
					_sntprintf(ItemBuf,MAXBUFS, _T("%8l"), (LONG) * ULongPtr);
					ptr += ItemRSize;
					break;

				case ItemULong:
					ItemRSize = sizeof(ULONG);
					RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
					_sntprintf(ItemBuf,MAXBUFS, _T("%8lu"), * ULongPtr);
					ptr += ItemRSize;
					break;

				case ItemULongX:
					ItemRSize = sizeof(ULONG);
					RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
					_sntprintf(ItemBuf,MAXBUFS, _T("0x%08X"), * ULongPtr);
					ptr += ItemRSize;
					break;

                case ItemPtr :
                    PtrFmt2 = _T("%08X%08X") ;
                    PtrFmt1 = _T("%08X") ;
                    // goto ItemPtrCommon ;
                    //ItemPtrCommon:
                    {
                        ULONG ulongword2;
                        if (PointerSize == 8) {     // 64 bits 
                            RtlCopyMemory(&ulongword,ptr,4);
                            RtlCopyMemory(&ulongword2,ptr+4,4);
                            _sntprintf(ItemBuf,MAXBUFS, PtrFmt2 , ulongword2,ulongword);
                            }
					    else {      // assumes 32 bit otherwise
						    RtlCopyMemory(&ulongword,ptr,PointerSize);
						    _sntprintf(ItemBuf,MAXBUFS, PtrFmt1 , ulongword);                  
					    }               
                        ItemRSize = 0 ;             // Pointers are always co-erced to be strings
					    ptr += PointerSize;
                    }
					break;

				case ItemIPAddr:
					ItemRSize = 0; // Only String form exists
					memcpy(&ulongword, ptr, sizeof(ULONG));

					// Convert it to readable form
					//
					_sntprintf(
							ItemBuf, MAXBUFS,
							_T("%03d.%03d.%03d.%03d"),
							(ulongword >>  0) & 0xff,
							(ulongword >>  8) & 0xff,
							(ulongword >> 16) & 0xff,
							(ulongword >> 24) & 0xff);
					ptr += sizeof (ULONG);
					break;

				case ItemPort:
					ItemRSize = 0; // Only String form exists
					_sntprintf(ItemBuf,MAXBUFS, _T("%u"), (UCHAR)ptr[0] * 256 + (UCHAR)ptr[1] * 1);
					ptr += sizeof (USHORT);
					break;

				case ItemLongLong:
					ItemRSize = sizeof(LONGLONG);
					RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
					_sntprintf(ItemBuf,MAXBUFS, _T("%16I64x"), *LongLongPtr);
					ptr += sizeof(LONGLONG);
					ItemRSize = 0; // FormatMessage cannot print 8 byte stuff properly on x86
					break;

				case ItemULongLong:
					ItemRSize = sizeof(ULONGLONG);
					RtlCopyMemory(ItemRBuf, ptr, ItemRSize);
					_sntprintf(ItemBuf,MAXBUFS, _T("%16I64x"), *ULongLongPtr);
					ptr += sizeof(ULONGLONG);
					ItemRSize = 0; // FormatMessage cannot print 8 byte stuff properly on x86
					break;

				case ItemString:
				case ItemRString:
				{
					SIZE_T pLen = strlen((CHAR *) ptr);
					if (pLen > 0)
					{
						strcpy(str, ptr);
						if (pItem->ItemType == ItemRString)
						{
							reduce(str);
						}
	#ifdef UNICODE
						MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MAXSTR);
						_sntprintf(ItemBuf,MAXBUFS, _T("\"%ws\""), wstr);
						_sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%ws"), wstr);
	#else
						_sntprintf(ItemBuf,MAXBUFS, _T("\"%s\""), str);
						_stprintf((TCHAR *)ItemRBuf, MAXCHARS,_T("%s"), str);
	#endif    /* #ifdef UNICODE */
					} else {
						_sntprintf(ItemBuf,MAXBUFS,_T("<NULL>"));
						_sntprintf((TCHAR *)ItemRBuf,MAXCHARS,_T("<NULL>"));
					}
					ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR);
					bItemIsString = TRUE;
					ptr += (pLen + 1);
					break;
				}
				case ItemRWString:
				case ItemWString:
				{
					size_t  pLen = 0;
					size_t     i;

					if (*(WCHAR *) ptr)
					{
						if (pItem->ItemType == ItemRWString)
						{
							reduceW((WCHAR *) ptr);
						}
						pLen = ((wcslen((WCHAR*)ptr) + 1) * sizeof(WCHAR));
						memcpy(wstr, ptr, pLen);
						for (i = 0; i < pLen / 2; i++)
						{
							if (((USHORT) wstr[i] == (USHORT) 0xFFFF))
							{
								wstr[i] = (USHORT) 0;
							}
						}

						wstr[pLen / 2] = wstr[(pLen / 2) + 1]= '\0';
						_sntprintf(ItemBuf,MAXBUFS, _T("\"%ws\""), wstr);
						_sntprintf((TCHAR *)ItemRBuf, MAXCHARS,_T("%ws"), wstr);
       					ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR);
						bItemIsString = TRUE;
					}
					ptr += pLen; // + sizeof(ULONG);

					break;
			}

				case ItemDSString:   // Counted String
				{
					USHORT pLen = 256 * ((USHORT) * ptr) + ((USHORT) * (ptr + 1));
					ptr += sizeof(USHORT);
					if (pLen > 0)
					{
						strcpy(str, ptr);
	#ifdef UNICODE
						MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MAXSTR);
						_sntprintf(ItemBuf,MAXBUFS, _T("\"%ws\""), wstr);
						_sntprintf((TCHAR *)ItemRBuf, MAXCHARS,_T("%ws"), wstr);
	#else
						_sntprintf(ItemBuf,MAXBUFS, _T("\"%s\""), str);
						_sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%s"), str);
	#endif
					}
					ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR);
					bItemIsString = TRUE;
					ptr += (pLen + 1);
					break;
				}

			case ItemPString:   // Counted String
				{
					USHORT pLen = 256 * ((USHORT) * ptr) + ((USHORT) * (ptr + 1));
					ptr += sizeof(USHORT);
					if (pLen > 0)
					{
						strcpy(str, ptr);
	#ifdef UNICODE
						MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MAXSTR);
						_sntprintf(ItemBuf,MAXBUFS, _T("\"%ws\""), wstr);
						_sntprintf((TCHAR *)ItemRBuf, MAXCHARS,_T("%ws"), wstr);
	#else
						_sntprintf(ItemBuf,MAXBUFS, _T("\"%s\""), str);
						_sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%s"), str);
	#endif    /* #ifdef UNICODE */
					} else {
						_sntprintf(ItemBuf,MAXBUFS, _T("<NULL>"));
						_sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("<NULL>"));
					}
					ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR);
					bItemIsString = TRUE;
					ptr += (pLen + 1);
					break;
				}

			   case ItemDSWString:  // DS Counted Wide Strings
				case ItemPWString:  // Counted Wide Strings
				{
					USHORT pLen = ( pItem->ItemType == ItemDSWString)
								? (256 * ((USHORT) * ptr) + ((USHORT) * (ptr + 1)))
								: (* ((USHORT *) ptr));

					ptr += sizeof(USHORT);
					if (pLen > MAXSTR * sizeof(WCHAR))
					{
						pLen = MAXSTR * sizeof(WCHAR);
					}
					if (pLen > 0)
					{
						memcpy(wstr, ptr, pLen);
						wstr[pLen / sizeof(WCHAR)] = L'\0';
						_sntprintf(ItemBuf,MAXBUFS, _T("\"%ws\""), wstr);
						_sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%ws"), wstr);
					ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR) ;
					bItemIsString = TRUE;
					}
					ptr += pLen;
					break;
				}

				case ItemNWString:   // Non Null Terminated String
				{
				   USHORT Size;

				   Size = (USHORT) (pEvent->MofLength -
						   (ULONG) (ptr - iMofPtr));
				   if (Size > MAXSTR )
				   {
					   Size = MAXSTR;
				   }
				   if (Size > 0)
				   {
					   memcpy(wstr, ptr, Size);
					   wstr[Size / 2] = '\0';
					   _sntprintf(ItemBuf,MAXBUFS, _T("\"%ws\""), wstr);
					   _sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%ws"), wstr);
						ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR) ;
						bItemIsString = TRUE;
				   }
				   ptr += Size;
				   break;
				}

				case ItemMLString:  // Multi Line String
				{
					SIZE_T   pLen;
					char   * src, * dest;
					BOOL     inQ       = FALSE;
					BOOL     skip      = FALSE;
					UINT     lineCount = 0;

					ptr += sizeof(UCHAR) * 2;
					pLen = strlen(ptr);
					if (pLen > 0)
					{
						src  = ptr;
						dest = str;
						while (*src != '\0')
						{
							if (*src == '\n')
							{
								if (!lineCount)
								{
									* dest ++ = ' ';
								}
								lineCount ++;
							}
							else if (*src == '\"')
							{
								if (inQ)
								{
									char   strCount[32];
									char * cpy;

									sprintf(strCount, "{%dx}", lineCount);
									cpy = &strCount[0];
									while (*cpy != '\0')
									{
										* dest ++ = * cpy ++;
									}
								}
								inQ = !inQ;
							}
							else if (!skip)
							{
								*dest++ = *src;
							}
							skip = (lineCount > 1 && inQ);
							src++;
						}
						*dest = '\0';
	#ifdef UNICODE
						MultiByteToWideChar(CP_ACP, 0, str, -1, wstr, MAXSTR);
						_sntprintf(ItemBuf,MAXBUFS, _T("\"%ws\""), wstr);
						_sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%ws"), wstr);
	#else
						_sntprintf(ItemBuf,MAXBUFS, _T("\"%s\""), str);
						_sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%s"), str);
	#endif    /* #ifdef UNICODE */
						ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR) ;
						bItemIsString = TRUE;
					}
					ptr += (pLen);
					break;
				}

				case ItemSid:
				{
					TCHAR        UserName[64];
					TCHAR        Domain[64];
					TCHAR        FullName[256];
					ULONG        asize = 0;
					ULONG        bsize = 0;
					ULONG        Sid[64];
					PULONG       pSid = &Sid[0];
					SID_NAME_USE Se;
					ULONG        nSidLength;
					pSid = (PULONG) ptr;
					if (* pSid == 0)
					{
						ptr += 4;
						_sntprintf(ItemBuf,MAXBUFS, _T("<NULL>"));
						_sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("<NULL>"));
						ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR) ;
						bItemIsString = TRUE ;
					}
					else
					{
						ptr       += 8;       // skip the TOKEN_USER structure
						nSidLength = 8 + (4 * ptr[1]);
						asize      = 64;
						bsize      = 64;

	// LookupAccountSid cannot accept asize, bsize as size_t
						if (LookupAccountSid(
								NULL,
								(PSID) ptr,
								(LPTSTR) & UserName[0],
								&asize,
								(LPTSTR) & Domain[0],
								& bsize,
								& Se))
						{
							LPTSTR pFullName = & FullName[0];

							_tcscpy(pFullName, _T("\\\\"));
							_tcscat(pFullName, Domain);
							_tcscat(pFullName, _T("\\"));
							_tcscat(pFullName, UserName);
							asize = (ULONG) _tcslen(pFullName); // Truncate here
							if (asize > 0)
							{
								_sntprintf(ItemBuf,MAXBUFS, _T("\"%s\""), pFullName);
								_sntprintf((TCHAR *)ItemRBuf, MAXCHARS, _T("%s"), pFullName);
							}
						}
						else
						{
						    LPTSTR sidStr;
						    if ( ConvertSidToStringSid(pSid, &sidStr) ) {
    							_sntprintf(ItemBuf,MAXBUFS, _T("\"%s\""), sidStr); // BUGBUG check size
    							_sntprintf((TCHAR *)ItemRBuf, MAXCHARS,_T("%s"), sidStr);
    				        } else {
    							_sntprintf(ItemBuf,MAXBUFS, _T("\"%s(%d)\""), _T("System"), GetLastError() );
    							_sntprintf((TCHAR *)ItemRBuf, MAXCHARS,_T("%s(%d)"), _T("System"), GetLastError() );
    					    }
						}
						SetLastError(ERROR_SUCCESS);
						ItemRSize = _tcslen((TCHAR *)ItemRBuf) * sizeof(TCHAR);
						bItemIsString = TRUE;
						ptr += nSidLength;
					}
					break;
				}

				case ItemChar4:
					ItemRSize = 4 * sizeof(TCHAR);
					_sntprintf(ItemBuf,MAXBUFS,
							  _T("%c%c%c%c"),
							  ptr[0], ptr[1], ptr[2], ptr[3]);
					ptr += ItemRSize ;
					_tcscpy((LPTSTR)ItemRBuf, ItemBuf);
    				bItemIsString = TRUE;
					break;

                case ItemCharHidden:
                    ItemRSize = 0 ;
                    _stscanf(pItem->ItemList,_T("%d"),&ItemRSize);
                    if (ItemRSize > MAXBUFS) {
                        ItemRSize = MAXBUFS ;
                    }
                    _tprintf(_T("size is %d\n"),ItemRSize);
                    RtlCopyMemory(ItemBuf,ptr,ItemRSize);
                    ptr += ItemRSize ;
                    bItemIsString = TRUE ;
                    break;

				case ItemSetByte:
					ItemRSize = sizeof(BYTE);
					goto ItemSetCommon;

				case ItemSetShort:
					ItemRSize = sizeof(USHORT);
					goto ItemSetCommon;

				case ItemSetLong:
					ItemRSize = sizeof(ULONG);
					// goto ItemSetCommon;
					
	ItemSetCommon:
					{
						TCHAR * name;
						ULONG   Countr    = 0;
						ULONG   ItemMask = 0;
						TCHAR   iList[MAXBUFS];
						BOOL first = TRUE;

						RtlCopyMemory(&ItemMask, ptr, ItemRSize);
						ptr += ItemRSize;

						_tcscpy(ItemBuf, _T("["));
						_sntprintf(iList, MAXBUFS,_T("%s"), pItem->ItemList);
						name = _tcstok(iList, _T(","));
						while( name != NULL )
						{
							// While there are tokens in "string"
							//
							if (ItemMask & (1 << Countr) )
							{
							    if (!first) _tcscat(ItemBuf, _T(","));
								_tcscat(ItemBuf, name); first = FALSE;
							}
							// Get next token:
							//
							name = _tcstok( NULL, _T(","));
							Countr++;
						}
						while (Countr < ItemRSize * 8) {
							if (ItemMask & (1 << Countr) )
							{
							    TCHAR smallBuf[20];
        						_sntprintf(smallBuf, 20, _T("%d"),Countr);
							    if (!first) _tcscat(ItemBuf, _T(","));
								_tcscat(ItemBuf, smallBuf); first = FALSE;
							}
							Countr++;
						}
						_tcscat(ItemBuf, _T("]") );
						ItemRSize = 0; // Strings will be the same Raw and otherwise
					}
					break;

				case ItemListByte:
					ItemRSize = sizeof(BYTE);
					goto ItemListCommon;

				case ItemListShort:
					ItemRSize = sizeof(USHORT);
					goto ItemListCommon;

				case ItemListLong:
					ItemRSize = sizeof(ULONG);
					// goto ItemListCommon;

	ItemListCommon:
					{
						TCHAR * name;
						ULONG   Countr    = 0;
						ULONG   ItemIndex = 0;
						TCHAR   iList[MAXBUFS];

						RtlCopyMemory(&ItemIndex, ptr, ItemRSize);
						ptr += ItemRSize;
						ItemRSize = 0; // Strings will be the same Raw and otherwise

						_sntprintf(ItemBuf,MAXBUFS, _T("!%X!"),ItemIndex);
						_sntprintf(iList, MAXBUFS, _T("%s"), pItem->ItemList);
						name = _tcstok(iList, _T(","));
						while( name != NULL )
						{
							// While there are tokens in "string"
							//
							if (ItemIndex == Countr ++)
							{
								_sntprintf(ItemBuf,MAXBUFS, _T("%s"), name);
								break;
							}
							// Get next token:
							//
							name = _tcstok( NULL, _T(","));
						}
					}
					break;

				case ItemNTerror:
					ItemRSize = 0; // Only string form exists
					RtlCopyMemory(ItemRBuf, ptr, sizeof(ULONG));
					ptr += sizeof(ULONG);
					// Translate the NT Error Message
					if ((FormatMessage(
						FORMAT_MESSAGE_FROM_SYSTEM |
						FORMAT_MESSAGE_IGNORE_INSERTS,
						NULL,
						*ULongPtr,
						MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
						ItemBuf,
						MAXBUFS,
						NULL )) == 0) {
						
						_sntprintf(ItemBuf,MAXBUFS,_T("!NT Error %d unrecognised!"),*ULongPtr);
					}
					break;

				case ItemMerror:
					ItemRSize = 0; // Only string form exists
					RtlCopyMemory(ItemRBuf, ptr, sizeof(ULONG));
					ptr += sizeof(ULONG);
					// Translate the Module Message
					if (pItem->ItemList == NULL) {
						_sntprintf(ItemBuf,MAXBUFS,_T("! Error %d No Module Name!"),*ULongPtr);
					} else {
						if ((hLibrary = LoadLibraryEx(
										pItem->ItemList,	// file name of module
										NULL,				// reserved, must be NULL
										LOAD_LIBRARY_AS_DATAFILE // entry-point execution flag
										)) == NULL) {
							_sntprintf(ItemBuf,MAXBUFS,_T("!ItemMerror %d : LoadLibrary of %s failed %d!"),
										*ULongPtr,
										pItem->ItemList,
										GetLastError());
						} else {
							if ((FormatMessage(
								FORMAT_MESSAGE_FROM_HMODULE |
								FORMAT_MESSAGE_FROM_SYSTEM |
								FORMAT_MESSAGE_IGNORE_INSERTS,
								hLibrary,
								*ULongPtr,
								MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
								ItemBuf,
								MAXBUFS,
								NULL )) == 0) {
								_sntprintf(ItemBuf,MAXBUFS,_T("!Module Error %d unrecognised!"),*ULongPtr);
							}
							if (!FreeLibrary(hLibrary)) {
								_sntprintf(ItemBuf,MAXBUFS,_T("Failed to free library (%s) handle, err = %d"),
									pItem->ItemList, GetLastError());
							}
						}
					}
					break;

			    case ItemHRESULT:
					{
						NTSTATUS TempNTSTATUS, Error ;
						ItemRSize = 0 ;
						RtlCopyMemory(&TempNTSTATUS, ptr, sizeof(NTSTATUS));
						ptr += sizeof(ULONG);
						Error = TempNTSTATUS;
                        if (TempNTSTATUS == 0) { // Special case STATUS_SUCCESS just like everyone else!
                            _sntprintf(ItemBuf,MAXBUFS,_T("S_OK"));
                        } else {
                            const ERROR_MAP* map = (ERROR_MAP*)winerrorSymbolicNames;

                            _sntprintf(ItemBuf,MAXBUFS,_T("HRESULT=%8X"),TempNTSTATUS);
                            if( FACILITY_NT_BIT & TempNTSTATUS ) {
                                map =  (ERROR_MAP*)ntstatusSymbolicNames;
                                Error &= ~FACILITY_NT_BIT;
                            } else if (HRESULT_FACILITY(Error) == FACILITY_WIN32) {
                                Error &= 0xFFFF;
                            }
						    while (map->MessageId != 0xFFFFFFFF) {
							    if (map->MessageId == Error) {
							        _sntprintf(ItemBuf,MAXBUFS,_T("0x%08x(%S)"), TempNTSTATUS, map->SymbolicName);
								    break;
							    }
							    ++map;
						    }
                        }
					}
					break;

				case ItemNTSTATUS:
					{
						int i = 0 ;
						NTSTATUS TempNTSTATUS ;
						ItemRSize = 0 ;
						RtlCopyMemory(&TempNTSTATUS, ptr, sizeof(NTSTATUS));
						ptr += sizeof(ULONG);
                        if (TempNTSTATUS == 0) { // Special case STATUS_SUCCESS just like everyone else!
                            _sntprintf(ItemBuf,MAXBUFS,_T("STATUS_SUCCESS"));
                        } else {
                            _sntprintf(ItemBuf,MAXBUFS,_T("NTSTATUS=%8X"),TempNTSTATUS);
						    while (ntstatusSymbolicNames[i].MessageId != 0xFFFFFFFF) {
							    if (ntstatusSymbolicNames[i].MessageId == TempNTSTATUS) {
								    _sntprintf(ItemBuf,MAXBUFS,_T("0x%08x(%S)"), TempNTSTATUS, ntstatusSymbolicNames[i].SymbolicName);
								    break;
							    }
							    i++ ;
						    }
                        }
					}
					break;

				case ItemWINERROR:
					{
						int i = 0 ;
						DWORD TempWINERROR ;
						ItemRSize = 0 ;
						RtlCopyMemory(&TempWINERROR, ptr, sizeof(DWORD));
						ptr += sizeof(ULONG);
						_sntprintf(ItemBuf,MAXBUFS,_T("WINERROR=%8X"),TempWINERROR);
						while (winerrorSymbolicNames[i].MessageId != 0xFFFFFFFF) {
							if (winerrorSymbolicNames[i].MessageId == TempWINERROR) {
								_sntprintf(ItemBuf,MAXBUFS,_T("%d(%S)"), TempWINERROR, winerrorSymbolicNames[i].SymbolicName);
								break;
							}
							i++ ;
						}
					}
					break;

								
				case ItemNETEVENT:
					{
						int i = 0 ;
						DWORD TempNETEVENT ;
						ItemRSize = 0 ;
						RtlCopyMemory(&TempNETEVENT, ptr, sizeof(DWORD));
						ptr += sizeof(ULONG);
						_sntprintf(ItemBuf,MAXBUFS,_T("NETEVENT=%8X"),TempNETEVENT);
						while (neteventSymbolicNames[i].MessageId != 0xFFFFFFFF) {
							if (neteventSymbolicNames[i].MessageId == TempNETEVENT) {
								_sntprintf(ItemBuf,MAXBUFS,_T("%S"), neteventSymbolicNames[i].SymbolicName);
								break;
							}
							i++ ;
						}
					}
					break;

				case ItemGuid:
					GuidToString(ItemBuf, (LPGUID) ptr);
					ItemRSize = 0; // Only string form exists
					ptr += sizeof(GUID);
					break;

                case ItemTimeDelta:
                    {
    					LONGLONG time;
    					RtlCopyMemory(&time, ptr, sizeof(time));
    					
    					FormatTimeDelta(ItemBuf, MAXBUFS, time);

    					ItemRSize = 0; // Only string form exists
    					ptr += sizeof(LONGLONG);
                    }
					break;

                case ItemWaitTime:
					{
    					LONGLONG time;
    					RtlCopyMemory(&time, ptr, sizeof(time));

    					if (time <= 0) {
    						time = -time;
    						ItemBuf[0]='+';
    						FormatTimeDelta(ItemBuf+1, MAXBUFS-1, time);
    						ItemRSize = 0; // Only string form exists
    						ptr += sizeof(LONGLONG);
    						break;
    					}
    					// Fall thru
					}
				case ItemTimestamp:
					{
					LARGE_INTEGER LargeTmp;
					FILETIME      stdTime, localTime;
					SYSTEMTIME    sysTime;

						RtlCopyMemory(&LargeTmp, ptr, sizeof(ULONGLONG));
						stdTime.dwHighDateTime = LargeTmp.HighPart;
						stdTime.dwLowDateTime  = LargeTmp.LowPart;
						if (!FileTimeToLocalFileTime(&stdTime, &localTime)) {
							_sntprintf(ItemBuf,MAXBUFS,_T("FileTimeToLocalFileTime error 0x%8X\n"),GetLastError());
							break;
						}
						if (!FileTimeToSystemTime(&localTime, &sysTime)){
							_sntprintf(ItemBuf,MAXBUFS,_T("FileTimeToSystemTime error 0x%8X\n"),GetLastError());
							break;
						}

						_sntprintf(ItemBuf,MAXBUFS, _T("%02d/%02d/%04d-%02d:%02d:%02d.%03d"),
								sysTime.wMonth,
								sysTime.wDay,
								sysTime.wYear,
								sysTime.wHour,
								sysTime.wMinute,
								sysTime.wSecond,
								sysTime.wMilliseconds);
					}
					ItemRSize = 0; // Only string form exists
					ptr += sizeof(ULONGLONG);

					break;

				default:
					ptr += sizeof (int);
				}

    			_sntprintf(pItemBuf[iItemCount], 
                           MAXBUFS2-ItemsInBuf,
                           _T("%s"), 
                           ItemBuf);
	    		pItemBuf[iItemCount + 1] =
							pItemBuf[iItemCount] + _tcslen(ItemBuf) + sizeof(TCHAR);
		    	ItemsInBuf = ItemsInBuf + _tcslen(ItemBuf) + sizeof(TCHAR);

			    if (ItemRSize == 0) {
				   // Raw and String are the same
                   pItemRBuf[iItemCount] = (ULONG_PTR *) pItemBuf[iItemCount];
				}
				  else
				{
                   if (ItemRSize > MAXBUFS) {
                     ItemRSize = MAXBUFS ;
                   }
				   pItemRBuf[iItemCount] =pItemRBuf[iItemCount+1] = 0 ;
			       if (!bItemIsString) {
                        RtlCopyMemory(&pItemRBuf[iItemCount],ItemRBuf,ItemRSize);
			       } else {
				        // Share scratch buffer
                        if ((LONG)(ItemsInBuf+ItemRSize+sizeof(TCHAR)) < (LONG)sizeof(ItemBBuf)) {
                            (TCHAR *)pItemRBuf[iItemCount] = pItemBuf[iItemCount+1] ;
				            RtlCopyMemory(pItemRBuf[iItemCount],ItemRBuf,ItemRSize);
				            pItemBuf[iItemCount+1] =(TCHAR *)pItemRBuf[iItemCount] + ItemRSize + sizeof(TCHAR) ;
				            ItemsInBuf = ItemsInBuf + ItemRSize + sizeof(TCHAR) ;
				        } else {
				            pItemRBuf[iItemCount] = (ULONG_PTR *) pItemBuf[iItemCount];
				        }
					}
				}
                iItemCount ++;
				Next = Next->Flink;

			}
			// Ok we are finished with the MofData
			//
			free(iMofPtr);
		}
        __except(EXCEPTION_EXECUTE_HANDLER)
		{
			_sntprintf(EventBuf, 
                      SizeEventBuf,
                      _T("\n*****FormatMessage %s of %s, parameter %d raised an exception*****\n"),
				      tstrName,
				      tstrFormat,
				      iItemCount);
			return( (SIZE_T)_tcslen(EventBuf));
		}
	}

    // All argument processing is complete
    // No prepare the final formatting.

    if ((tstrFormat == NULL) || (tstrFormat[0] == 0))
    {
        TCHAR GuidString[32] ;
        // Build a helpful format

        RtlZeroMemory(EventBuf, SizeEventBuf);

        if (!IsEqualGUID(&pEvent->Header.Guid, &EventTraceGuid) ) {
            GuidToString(GuidString, (LPGUID) &pEvent->Header.Guid);
            _sntprintf(EventBuf, 
                      SizeEventBuf,
                      _T("%s(%s): GUID=%s (No Format Information found)."),
                      pItemBuf[0],      // name if any 
                      pItemBuf[1],      // sub name or number
                      GuidString       // GUID
                     );
        } else {
            // Display nothing for a header for now
            // Might be a good place to display some general info ?
        }
    }
    else
    {
        DWORD dwResult;

        if (tstrTypeOfType == 1)
        {
            __try
            {
                dwResult = FormatMessage(
                    FORMAT_MESSAGE_FROM_STRING + FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                          // source and processing options
                    (LPCVOID) tstrFormat, // pointer to  message source
                    0,                    // requested message identifier
                    0,                    // language identifier
                    (LPTSTR) EventBuf,    // pointer to message buffer
                    SizeEventBuf,         // maximum size of message buffer
                    (va_list *) pItemBuf);  // pointer to array of message inserts
                if (dwResult == 0)
                {
                    _sntprintf(
                           EventBuf, SizeEventBuf,
                           _T("FormatMessage (Type 1) Failed 0x%X (%s/%s) (\n"),
                           GetLastError(),
                           pItemBuf[0],
                           pItemBuf[1]);
                    return(GetLastError());
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                _sntprintf(EventBuf, 
                           SizeEventBuf,
                           _T("\n*****FormatMessage (#Type) of %s, raised an exception*****\n"), 
                           tstrFormat);
                return( (SIZE_T)_tcslen(EventBuf));
            }
        }
        else if (tstrTypeOfType == 2)
        {
            __try
            {
#if !defined(STRINGFIXUP)
                dwResult = FormatMessage(
                    FORMAT_MESSAGE_FROM_STRING + FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                          // source and processing options
                    (LPCVOID) tstrFormat, // pointer to  message source
                    0,                    // requested message identifier
                    0,                    // language identifier
                    (LPTSTR) EventBuf,    // pointer to message buffer
                    SizeEventBuf,         // maximum size of message buffer
                    (va_list *) pItemRBuf); // pointer to array of message inserts
                if (dwResult == 0)
                {
                    _sntprintf(
                                EventBuf,
                                SizeEventBuf,
                                _T("FormatMessage (#Typev) Failed 0x%X (%s/%s) (\n"),
                                GetLastError(),
                                pItemBuf[0],
                                pItemBuf[1]);
                    return(GetLastError());
                }

#else  // if !defined(STRINGFIXUP)
                ULONG ReturnLength ;
                dwResult = (DWORD)TraceFormatMessage(
                    tstrFormat,             // message format
                    0,
                    FALSE,                   // Don't ignore inserts,
#if defined(UNICODE)
                    FALSE,                   // Arguments Are not Ansi,
#else // #if defined(UNICODE)
                    TRUE,                    // Arguments are Ansi
#endif // #if defined(UNICODE)
                    TRUE,                    // Arguments Are An Array,
                    (va_list *) pItemRBuf,   // Arguments,
                    EventBuf,                // Buffer,
                    SizeEventBuf,           // maximum size of message buffer
                    &ReturnLength            // Coutnof Data Returned
                    );
                if (ReturnLength == 0)
                {
                    _sntprintf(
                           EventBuf,
                           SizeEventBuf,
                           _T("FormatMessage (#Typev) Failed 0x%X (%s/%s) (\n"),
                           dwResult,
                           pItemBuf[0],
                           pItemBuf[1]);
                    return(dwResult);
                }

#endif // if !defined(STRINGFIXUP)
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                _sntprintf( EventBuf, 
                            SizeEventBuf,
                            _T("\n*****FormatMessage (#Typev) raised an exception (Format = %s) ****\n**** [Check for missing \"!\" Formats]*****\n"), tstrFormat);
                return((SIZE_T)_tcslen(EventBuf));
            }
        }
        else
        {
            return (-12);
        }
    }

    if (pszMask != NULL)
    {
        // Has he imposed a Filter?
        //
        if (_tcsstr(_tcslwr(pszMask), _tcslwr(tstrName)) !=0)
        {
            return( (SIZE_T)_tcslen(EventBuf));
        }
        else
        {
            return(0);
        }
    }

    return ( (SIZE_T)_tcslen(EventBuf));
}

PMOF_INFO
GetMofInfoHead(
        PLIST_ENTRY * HeadEventList,
        LPGUID        pGuid,
        LPTSTR        strType,
        LONG          TypeIndex,
        ULONG         TypeOfType,
        LPTSTR        TypeFormat,
        BOOL          bBestMatch
        )
{
    PLIST_ENTRY Head, Next;
    PMOF_INFO   pMofInfo;

    // Search the eventList for this Guid and find the head
    //
    if (HeadEventList == NULL) {
        return NULL ;
    } 
    if (*HeadEventList == NULL)
    {
        if( (*HeadEventList = (PLIST_ENTRY) malloc(sizeof(LIST_ENTRY))) == NULL) 
			return NULL;
		
        RtlZeroMemory(*HeadEventList, sizeof(LIST_ENTRY));
        InitializeListHead(*HeadEventList);
    }

    // Traverse the list and look for the Mof info head for this Guid.
    //
    Head = *HeadEventList;
    Next = Head->Flink;
    if (bBestMatch)
    {
        PMOF_INFO pBestMatch = NULL;

        while (Head != Next)
        {
            pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
            if (IsEqualGUID(&pMofInfo->Guid, pGuid))
            {
                if (pMofInfo->TypeIndex == TypeIndex)
                {
                    return  pMofInfo;
                }
                else if (pMofInfo->strType == NULL)
                {
                    pBestMatch = pMofInfo;
                }
            }
            Next = Next->Flink;
        }
        if(pBestMatch != NULL)
        {
            return pBestMatch;
        }
    }
    else
    {
        while (Head != Next)
        {
            pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);

            if (   (strType != NULL)
                && (pMofInfo->strType != NULL)
                && (IsEqualGUID(&pMofInfo->Guid, pGuid))
                && (!(_tcscmp(strType, pMofInfo->strType))))
            {
                return  pMofInfo;
            }
            else if (   (strType == NULL)
                     && (pMofInfo->strType == NULL)
                     && (IsEqualGUID(&pMofInfo->Guid, pGuid)))
            {
                return  pMofInfo;
            }
            Next = Next->Flink;
        }
    }

    // If One does not exist, create one.
    //
    if( (pMofInfo = (PMOF_INFO) malloc(sizeof(MOF_INFO))) == NULL)
		return NULL;
	RtlZeroMemory(pMofInfo, sizeof(MOF_INFO));
    memcpy(&pMofInfo->Guid, pGuid, sizeof(GUID));
    pMofInfo->ItemHeader = (PLIST_ENTRY) malloc(sizeof(LIST_ENTRY));
	if( pMofInfo->ItemHeader == NULL){
	   	free(pMofInfo);
		return NULL;
	}
    RtlZeroMemory(pMofInfo->ItemHeader, sizeof(LIST_ENTRY));
    if (strType != NULL)
    {
        if ((pMofInfo->strType = (LPTSTR) malloc((_tcslen(strType) + 1) * sizeof(TCHAR))) == NULL ) {
            free(pMofInfo);
            return NULL ;
        }
        _tcscpy(pMofInfo->strType,strType);
    }
    if (TypeOfType != 0)
    {
           pMofInfo->TypeOfType = TypeOfType;
    }
    if (TypeFormat != NULL)
    {
        if ((pMofInfo->TypeFormat =
                (LPTSTR) malloc((_tcslen(TypeFormat) + 1) * sizeof(TCHAR)))== NULL) {
            free(pMofInfo->strType);
            free(pMofInfo);
            return NULL ;
        }
        _tcscpy(pMofInfo->TypeFormat,TypeFormat);

    }
    pMofInfo->TypeIndex = bBestMatch ? -1 : TypeIndex;
    InitializeListHead(pMofInfo->ItemHeader);
    InsertTailList(*HeadEventList, &pMofInfo->Entry);
    return pMofInfo;
}

void
MapGuidToName(
        OUT PLIST_ENTRY *HeadEventList,
        IN  LPGUID      pGuid,
        IN  ULONG       nType,
        OUT LPTSTR      wstr
        )
{
    if (IsEqualGUID(pGuid, &EventTraceGuid))
    {
        _tcscpy(wstr, GUID_TYPE_HEADER);
    }
    else if (!UserDefinedGuid(*HeadEventList,pGuid, wstr))
    {
        TCHAR filename[MAX_PATH], filepath[MAX_PATH];
        LPTSTR lpFilePart ;
        LPTSTR lppath = NULL;           // Path for finding TMF files
        INT len, waslen = 0 ;
            
        while (((len = GetEnvironmentVariable(TRACE_FORMAT_SEARCH_PATH, lppath, waslen )) - waslen) > 0) {
            if (len - waslen > 0 ) {
                if (lppath != NULL) {
                    free(lppath);
                }
                lppath = malloc((len+1) * sizeof(TCHAR)) ;
                waslen = len ;
            }
        }
        if (lppath != NULL) {
            // Try to find it on the path //
            swprintf(filename,L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x.tmf",
            pGuid->Data1,pGuid->Data2,pGuid->Data3,
            pGuid->Data4[0],pGuid->Data4[1],pGuid->Data4[2],pGuid->Data4[3],
            pGuid->Data4[4],pGuid->Data4[5],pGuid->Data4[6],pGuid->Data4[7] );

            if ((len = SearchPath(
                             lppath,        // search path semi-colon seperated
                             filename,      // file name with extension
                             NULL,          // file extension (not reqd.)
                             MAX_PATH,      // size of buffer
                             filepath,      // found file name buffer
                             &lpFilePart    // file component
                          ) !=0) && (len <= MAX_PATH)) {
                //_tprintf(_T("Opening file %s\n"),filepath);

                if(GetTraceGuidsW(filepath, HeadEventList)) 
                { 
        
                    if (UserDefinedGuid(*HeadEventList,pGuid, wstr)) {
                        free(lppath);
                        return;
                    }
                }
            }
            free(lppath);
        }

        _tcscpy(wstr, GUID_TYPE_UNKNOWN);
    }
}

ULONG
UserDefinedGuid(
        OUT PLIST_ENTRY HeadEventList,
        IN  LPGUID      pGuid,
        OUT LPTSTR      wstr
        )
{
    PLIST_ENTRY Head, Next;
    PMOF_INFO   pMofInfo;

    // Search the eventList for this Guid and find the head
    //
    if (HeadEventList == NULL)
    {  
        /*
       HeadEventList = (PLIST_ENTRY) malloc(sizeof(LIST_ENTRY));
       if(HeadEventList == NULL)
           return FALSE; 

       InitializeListHead(HeadEventList); */
        return FALSE; 
    }

    // Traverse the list and look for the Mof info head for this Guid.
    //
    Head = HeadEventList;
    Next = Head->Flink;
    while(Head  != Next && Next != NULL){
    
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        if (pMofInfo != NULL && IsEqualGUID(&pMofInfo->Guid, pGuid))
        {
            if ( pMofInfo->strDescription == NULL)
            {
                return FALSE;
            }
            else
            {
                _tcscpy(wstr, pMofInfo->strDescription);
                return TRUE;
            }
        }
        Next = Next->Flink;
	}
    return FALSE;
}

ULONG
WINAPI
GetTraceGuidsW(
        TCHAR       * GuidFile,
        PLIST_ENTRY * HeadEventList                                                                       )
{
    FILE     * f;
    TCHAR      line[MAXSTR],
               nextline[MAXSTR],
               arg[MAXSTR],
               strGuid[MAXSTR];
    PMOF_TYPE  types;
    LPGUID     Guid;
    UINT       i,
               n;
    TCHAR    * name,
             * s,
             * guidName;
    PMOF_INFO  pMofInfo;
    SIZE_T     len       = 0;
    UINT       typeCount = 0;
    BOOL inInfo = FALSE;
    BOOL eof = FALSE ;
    BOOL nextlineF = FALSE ;

    if (HeadEventList == NULL) {
        return 0 ;
    } 
    if (*HeadEventList == NULL)
    {
        if( (*HeadEventList = (PLIST_ENTRY) malloc(sizeof(LIST_ENTRY))) == NULL) 
			return 0 ;
		
        RtlZeroMemory(*HeadEventList, sizeof(LIST_ENTRY));
        InitializeListHead(*HeadEventList);
    }

    Guid = (LPGUID) malloc(sizeof(GUID));
    if (Guid == NULL)
    {
        return 0;
    }

    types = (PMOF_TYPE) malloc(MAXTYPE * sizeof(MOF_TYPE));
    if (types == NULL)
    {
        free(Guid);
        return 0;
    }

    RtlZeroMemory(types,   MAXTYPE * sizeof(MOF_TYPE));
    RtlZeroMemory(line,    MAXSTR  * sizeof(TCHAR));
    RtlZeroMemory(strGuid, MAXSTR  * sizeof(TCHAR));

    f = _tfopen( GuidFile, _T("r"));
    if (f == NULL)
    {
        free(Guid);
        free(types);
        return 0;
    }
    n = 0;

    while (!eof )
    {
       if (nextlineF) { // Sometimes we read ahead a bit
          _tcscpy(line, nextline);
          nextlineF = FALSE ;
       } else {
         if (_fgetts(line, MAXSTR, f) == NULL) {
            eof = TRUE ;
            break;
         }
       }
//    jump_inside:;
        if (line[0] == '/')
        {
            continue;
        }
        else if (line[0] == '{')
        {
            inInfo = TRUE;
        }
        else if ( line[0] == '}')
        {
            typeCount = 0;
            inInfo = FALSE;
        }
        else if (inInfo)
        {
            ITEM_TYPE   type;
            PTCHAR      ItemListValue = NULL;

            name = _tcstok(line, _T("\n\t,"));
            s    = _tcstok(NULL, _T(" \n\t,("));
            if (s != NULL && name != NULL )
            {
                if (!_tcsicmp(s,STR_ItemChar))           type = ItemChar;
                else if (!_tcsicmp(s,STR_ItemUChar))     type = ItemUChar;
                else if (!_tcsicmp(s,STR_ItemCharShort)) type = ItemCharShort;
                else if (!_tcsicmp(s,STR_ItemCharSign))  type = ItemCharSign;
                else if (!_tcsicmp(s,STR_ItemShort))     type = ItemShort;
                else if (!_tcsicmp(s,STR_ItemHRESULT))   type = ItemHRESULT;
                else if (!_tcsicmp(s,STR_ItemDouble))    type = ItemDouble;
                else if (!_tcsicmp(s,STR_ItemUShort))    type = ItemUShort;
                else if (!_tcsicmp(s,STR_ItemLong))      type = ItemLong;
                else if (!_tcsicmp(s,STR_ItemULong))     type = ItemULong;
                else if (!_tcsicmp(s,STR_ItemULongX))    type = ItemULongX;
                else if (!_tcsicmp(s,STR_ItemLongLong))  type = ItemLongLong;
                else if (!_tcsicmp(s,STR_ItemULongLong)) type = ItemULongLong;
                else if (!_tcsicmp(s,STR_ItemString))    type = ItemString;
                else if (!_tcsicmp(s,STR_ItemWString))   type = ItemWString;
                else if (!_tcsicmp(s,STR_ItemRString))   type = ItemRString;
                else if (!_tcsicmp(s,STR_ItemRWString))  type = ItemRWString;
                else if (!_tcsicmp(s,STR_ItemPString))   type = ItemPString;
                else if (!_tcsicmp(s,STR_ItemMLString))  type = ItemMLString;
                else if (!_tcsicmp(s,STR_ItemNWString))  type = ItemNWString;
                else if (!_tcsicmp(s,STR_ItemPWString))  type = ItemPWString;
				else if (!_tcsicmp(s,STR_ItemDSString))  type = ItemDSString;
				else if (!_tcsicmp(s,STR_ItemDSWString)) type = ItemDSWString;
                else if (!_tcsicmp(s,STR_ItemPtr))       type = ItemPtr;
                else if (!_tcsicmp(s,STR_ItemSid))       type = ItemSid;
                else if (!_tcsicmp(s,STR_ItemChar4))     type = ItemChar4;
                else if (!_tcsicmp(s,STR_ItemIPAddr))    type = ItemIPAddr;
                else if (!_tcsicmp(s,STR_ItemPort))      type = ItemPort;
                else if (!_tcsicmp(s,STR_ItemListLong))  type = ItemListLong;
                else if (!_tcsicmp(s,STR_ItemListShort)) type = ItemListShort;
                else if (!_tcsicmp(s,STR_ItemListByte))  type = ItemListByte;
                else if (!_tcsicmp(s,STR_ItemSetLong))  type = ItemSetLong;
                else if (!_tcsicmp(s,STR_ItemSetShort)) type = ItemSetShort;
                else if (!_tcsicmp(s,STR_ItemSetByte))  type = ItemSetByte;
				else if (!_tcsicmp(s,STR_ItemNTerror))   type = ItemNTerror;
				else if (!_tcsicmp(s,STR_ItemMerror))	 type = ItemMerror;
				else if (!_tcsicmp(s,STR_ItemTimestamp)) type = ItemTimestamp;
                else if (!_tcsicmp(s,STR_ItemGuid))      type = ItemGuid;
				else if (!_tcsicmp(s,STR_ItemWaitTime)) type = ItemWaitTime;
                else if (!_tcsicmp(s,STR_ItemTimeDelta))      type = ItemTimeDelta;
				else if (!_tcsicmp(s,STR_ItemNTSTATUS))  type = ItemNTSTATUS;
				else if (!_tcsicmp(s,STR_ItemWINERROR))  type = ItemWINERROR;
				else if (!_tcsicmp(s,STR_ItemNETEVENT))  type = ItemNETEVENT;
                else if (!_tcsicmp(s,STR_ItemCharHidden))  type = ItemCharHidden;
                else                                     type = ItemUnknown;

				// Get List elements
				if ((type == ItemListLong) || (type == ItemListShort) || (type == ItemListByte)
				  ||(type == ItemSetLong)  || (type == ItemSetShort)  || (type == ItemSetByte) )
                {
                    s = _tcstok(NULL, _T("()"));
					ItemListValue =
						    (TCHAR *) malloc((_tcslen(s) + 1) * sizeof(TCHAR));
                    if (ItemListValue == NULL) {
                        return 1 ;
                    }
					RtlCopyMemory(
						    ItemListValue,
							s,
							(_tcslen(s) + 1) * sizeof(TCHAR));
				}
				// Get Module specification for ItemMerror
				if ((type == ItemMerror)) {
					TCHAR * ppos ;
                    s = _tcstok(NULL, _T(" \t"));
					ppos = _tcsrchr(s,'\n');
					if (ppos != NULL) {
						*ppos  = UNICODE_NULL ;
						ItemListValue =
								(TCHAR *) malloc((_tcslen(s) + 1) * sizeof(TCHAR));
                        if (ItemListValue == NULL) {
                            return 1 ;
                        }
						RtlCopyMemory(
								ItemListValue,
								s,
								(_tcslen(s) + 1) * sizeof(TCHAR));
					}
                }
                // Get size for ItemCharHidden
                if (type == ItemCharHidden) {
					TCHAR * ppos ;
                    s = _tcstok(NULL, _T("["));
					ppos = _tcsrchr(s,']');
					if (ppos != NULL) {
						*ppos  = UNICODE_NULL ;
						ItemListValue =
								(TCHAR *) malloc((_tcslen(s) + 1) * sizeof(TCHAR));
                        if (ItemListValue == NULL) {
                            return 1 ;
                        }
						RtlCopyMemory(
								ItemListValue,
								s,
								(_tcslen(s) + 1) * sizeof(TCHAR));
					}
                }

                if (typeCount == 0)
                {
                    AddMofInfo(
                            * HeadEventList,
                            Guid,
                            NULL,
                            -1,
                            name,
                            type,
                            NULL,
                            0,
                            NULL);
                }
                else
                {
                    for (i = 0; i < typeCount; i ++)
                    {
                        AddMofInfo(
                                * HeadEventList,
                                Guid,
                                types[i].strType,
                                types[i].TypeIndex,
                                name,
                                type,
                                ItemListValue,
                                types[i].TypeType,
                                types[i].TypeFormat);
                    }
                }
            }
        }
        else if (line[0] == '#')
        {
            TCHAR * token, * etoken;
            int Indent ;                    // Special parameter values(numeric) from comments
            TCHAR FuncName[MAXNAMEARG],     // Special parameter values from comment
                  LevelName[MAXNAMEARG],
                  CompIDName[MAXNAMEARG],
                  *v ;
           
            //This is a workaround to defend against newlines in TMF files.
            while (!nextlineF && !eof) {
               if (_fgetts(nextline,MAXSTR,f) != NULL) {
                    if ((nextline[0] != '{') && nextline[0] != '#') {
                        TCHAR * eol ;
                        if ((eol = _tcsrchr(line,'\n')) != NULL) {
                            *eol = 0 ;
                        }
                        _tcsncat(line,nextline,MAXSTR-_tcslen(line)) ;
                    } else {
                        nextlineF = TRUE ;
                    }
                } else {
                    eof = TRUE ;
                }
            }

            // Find any special names in the comments
            // As this gets longer we should make it generic
            Indent = FindIntValue(line,_T("INDENT="));  // Indentaion Level 
            v = FindValue(line,_T("FUNC="));            // Function Name
            _tcsncpy(FuncName, v,  MAXNAMEARG);
            v = FindValue(line,_T("LEVEL="));           // Tracing level or Flags
            _tcsncpy(LevelName, v, MAXNAMEARG);
            v = FindValue(line,_T("COMPNAME="));          // Component ID
            _tcsncpy(CompIDName, v, MAXNAMEARG);

            token = _tcstok(line,_T(" \t"));
            if (_tcsicmp(token,_T("#type")) == 0)
            {
                types[typeCount].TypeType = 1 ;
            }
            else if (_tcsicmp(token,_T("#typev")) == 0)
            {
                types[typeCount].TypeType = 2 ;
            }
            else
            {
                fclose(f);
                free(Guid);
                free(types);
                return(-10);
            }
            token = _tcstok( NULL, _T(" \t\n"));		// Get Type Name
            _tcscpy(types[typeCount].strType,token);
            token =_tcstok( NULL, _T("\"\n,"));			// Look for a Format String
            if (token != NULL) {
                types[typeCount].TypeIndex = _ttoi(token);	// Get the type Index
                token =_tcstok( NULL, _T("\n"));
            }
            etoken = NULL;
            if (token != NULL)
            {
                etoken = _tcsrchr(token,_T('\"'));  // Find the closing quote
            }

            if (etoken !=NULL)
            {
                etoken[0] = 0;
            }
            else
            {
                token = NULL;
            }

            if (token != NULL)
            {
                if (token[0] == '%' && token[1] == '0') {
                    // add standard prefix
                    if (StdPrefix[0] == 0) {
                        // need to initialize it.
                        LPTSTR Prefix = NULL ; int len, waslen = 0 ;        
                        while (((len = GetEnvironmentVariable(TRACE_FORMAT_PREFIX, Prefix, waslen )) - waslen) > 0) {
                            if (len - waslen > 0 ) {
                                if (Prefix != NULL) {
                                    free(Prefix);
                                }
                        Prefix = malloc((len+1) * sizeof(TCHAR)) ;
                        if (Prefix == NULL) {
                            return -11 ;
                        }
                        waslen = len ;
                        }
                    }

                        if (Prefix) {
                            _tcsncpy(StdPrefix, Prefix, MAXSTR);
                        } else {
                            _tcscpy(StdPrefix, STD_PREFIX);
                        }
                        free(Prefix) ;
                    }
                    _tcscpy(types[typeCount].TypeFormat,StdPrefix);
                    _tcscat(types[typeCount].TypeFormat,token + 2);
                } else {                
                    _tcscpy(types[typeCount].TypeFormat,token);
                }
                // process the special variable names
                // Make generic in future
                ReplaceStringUnsafe(types[typeCount].TypeFormat, _T("%!FUNC!"), FuncName);
                ReplaceStringUnsafe(types[typeCount].TypeFormat, _T("%!LEVEL!"), LevelName);
                ReplaceStringUnsafe(types[typeCount].TypeFormat, _T("%!COMPNAME!"), CompIDName);

            }
            else
            {
                types[typeCount].TypeFormat[0] = types[typeCount].TypeFormat[1]
                                               = 0;
            }

            if (   types[typeCount].TypeFormat[0] == 0
                && types[typeCount].TypeFormat[1] == 0)
            {
                pMofInfo = GetMofInfoHead(
                        HeadEventList,
                        Guid,
                        types[typeCount].strType,
                        types[typeCount].TypeIndex,
                        types[typeCount].TypeType,
                        NULL,
                        FALSE);
            }
            else
            {
                pMofInfo = GetMofInfoHead(
                        HeadEventList,
                        Guid,
                        types[typeCount].strType,
                        types[typeCount].TypeIndex,
                        types[typeCount].TypeType,
                        types[typeCount].TypeFormat,
                        FALSE);
            }

			if(pMofInfo == NULL){
				fclose(f);
				free(Guid);
				free(types);
				return 0;

			}
            if (_tcslen(strGuid) > 0)
            {
                pMofInfo->strDescription =
                      (PTCHAR) malloc((_tcslen(strGuid) + 1) * sizeof(TCHAR));
                if (pMofInfo->strDescription == NULL) {
				    fclose(f);
				    free(Guid);
				    free(types);
				    return 0;
                }
                _tcscpy(pMofInfo->strDescription, strGuid);
            }

            typeCount++;
            if(typeCount >= MAXTYPE)
            {
                fclose(f);
                free(Guid);
                free(types);
                return(-11);
            }
        }
        else if (   (line[0] >= '0' && line[0] <= '9')
                 || (line[0] >= 'a' && line[0] <= 'f')
                 || (line[0] >= 'A' && line[0] <= 'F'))
        {
            typeCount = 0;

            _tcsncpy(arg, line, 8);
            arg[8]      = 0;
            Guid->Data1 = ahextoi(arg);

            _tcsncpy(arg, &line[9], 4);
            arg[4]      = 0;
            Guid->Data2 = (USHORT) ahextoi(arg);

            _tcsncpy(arg, &line[14], 4);
            arg[4]      = 0;
            Guid->Data3 = (USHORT) ahextoi(arg);

            for (i = 0; i < 2; i ++)
            {
                _tcsncpy(arg, &line[19 + (i * 2)], 2);
                arg[2]         = 0;
                Guid->Data4[i] = (UCHAR) ahextoi(arg);
            }

            for (i = 2; i < 8; i ++)
            {
                _tcsncpy(arg, &line[20 + (i * 2)], 2);
                arg[2]         = 0;
                Guid->Data4[i] = (UCHAR) ahextoi(arg);
            }

            // Find the next non whitespace character
            //
            guidName = &line[36];

            while (*guidName == ' '|| *guidName == '\t')
            {
                guidName++;
            }

            // cut comment out (if present)
            {
                TCHAR* comment = _tcsstr(guidName, TEXT("//"));
                if (comment) {
                    // remove whitespace
                    --comment;
                    while (comment >= guidName && isspace(*comment)) --comment;
                    *++comment = 0;
                }
            }

            len = _tcslen(guidName);
            s   = guidName;

            while (len > 0)
            {
                len -= 1;
                if (*s == '\n' || *s == '\0' || *s == '\t')
                {
                    *s = '\0';
                    break;
                }
                s++;
            }

            pMofInfo = GetMofInfoHead(
                    HeadEventList, Guid, NULL, -1, 0, NULL, FALSE);

			if(pMofInfo == NULL){
				fclose(f);
				free(Guid);
				free(types);
				return (ULONG) 0;
			}

            if (pMofInfo->strDescription != NULL)
            {
                free(pMofInfo->strDescription);
                pMofInfo->strDescription = NULL;
            }
            _tcscpy(strGuid, guidName);
            pMofInfo->strDescription =
                    (PTCHAR) malloc((_tcslen(guidName) + 1) * sizeof(TCHAR));
            if (pMofInfo->strDescription == NULL ) {
                // We really have problems
                fclose(f);
                free(Guid);
                free(types);
                return (ULONG) 0 ;
            }
            _tcscpy(pMofInfo->strDescription, strGuid);
            n++ ;                                      // Thats one more GUID
        }
        RtlZeroMemory(line, MAXSTR * sizeof(TCHAR));
    }

    fclose(f);
    free(Guid);
    free(types);
    return (ULONG) n;
}

ULONG
ahextoi(
        TCHAR *s
        )
{
    SSIZE_T   len;
    ULONG num, base, hex;

    len  = _tcslen(s);
    hex  = 0;
    base = 1;
    num  = 0;
    while (--len >= 0)
    {
        if ((s[len] == 'x' || s[len] == 'X') && (s[len-1] == '0'))
        {
            break;
        }

        if (s[len] >= '0' && s[len] <= '9')
        {
            num = s[len] - '0';
        }
        else if (s[len] >= 'a' && s[len] <= 'f')
        {
            num = (s[len] - 'a') + 10;
        }
        else if (s[len] >= 'A' && s[len] <= 'F')
        {
            num = (s[len] - 'A') + 10;
        }
        else
        {
            continue;
        }

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

void
WINAPI
SummaryTraceEventListW(
        TCHAR       * SummaryBlock,
        ULONG         SizeSummaryBlock,
        PLIST_ENTRY   EventListHead
        )
{
    PLIST_ENTRY Head, Next;
    PMOF_INFO   pMofInfo;
    TCHAR       strGuid[MAXSTR];
    TCHAR       strName[MAXSTR];
    TCHAR       strBuffer[MAXSTR];

    if (EventListHead == NULL)
    {
        return;
    }
    if (SummaryBlock == NULL)
    {
        return;
    }
    RtlZeroMemory(SummaryBlock, sizeof(TCHAR) * SizeSummaryBlock);

    Head = EventListHead;
    Next = Head->Flink;
    while (Head != Next)
    {
        RtlZeroMemory(strName, 256);
        RtlZeroMemory(strBuffer, 256);
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        if (pMofInfo->EventCount > 0)
        {
            GuidToString((PTCHAR) strGuid, &pMofInfo->Guid);
            MapGuidToName(&EventListHead, &pMofInfo->Guid, 0, strName);
            _sntprintf(strBuffer,
                       MAXSTR,
                      _T("|%10d    %-20s %-10s  %36s|\n"),
                      pMofInfo->EventCount,
                      strName,
                      pMofInfo->strType ? pMofInfo->strType : _T("General"),
                      strGuid);

            _tcscat(SummaryBlock, strBuffer);
            if (_tcslen(SummaryBlock) >= SizeSummaryBlock)
            {
                return;
            }
        }

        Next = Next->Flink;
    }
}

PTCHAR
GuidToString(
        PTCHAR s,
        LPGUID piid
        )
{
    _stprintf(s, _T("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"),
               piid->Data1,
               piid->Data2,
               piid->Data3,
               piid->Data4[0],
               piid->Data4[1],
               piid->Data4[2],
               piid->Data4[3],
               piid->Data4[4],
               piid->Data4[5],
               piid->Data4[6],
               piid->Data4[7]);
    return(s);
}

// This routine is called by the WBEM interface routine for each property
// found for this Guid. The ITEM_DESC structure is allocted for each Property.
//
VOID
AddMofInfo(
              PLIST_ENTRY   HeadEventList,
              const GUID        * Guid,
              LPTSTR        strType,
              ULONG         typeIndex,
              LPTSTR        strDesc,
              ITEM_TYPE     ItemType,
              TCHAR       * ItemList,
              ULONG         typeOfType,
              LPTSTR        typeFormat
        )
{
    PITEM_DESC  pItem;
    PLIST_ENTRY pListHead;
    PMOF_INFO   pMofInfo;

    if (strDesc == NULL)
    {
        return;
    }

    pItem = (PITEM_DESC) malloc(sizeof(ITEM_DESC));
	if(pItem == NULL)return;	//silent error 

    RtlZeroMemory(pItem, sizeof(ITEM_DESC));
    pItem->strDescription =
            (LPTSTR) malloc((_tcslen(strDesc) + 1) * sizeof(TCHAR));

	if( pItem->strDescription == NULL ){
		free(pItem);
		return;
	}

    _tcscpy(pItem->strDescription, strDesc);
    pItem->ItemType = ItemType;
    pItem->ItemList = ItemList ;
    pMofInfo = GetMofInfoHead(
            (PLIST_ENTRY *) HeadEventList,
            (LPGUID) Guid,
            strType,
            typeIndex,
            typeOfType,
            typeFormat,
            FALSE);
    if (pMofInfo != NULL)
    {
        pListHead = pMofInfo->ItemHeader;
        InsertTailList(pListHead, &pItem->Entry);
    }
	else{
	
		free(pItem->strDescription); 
		free(pItem);
	}

}

void
WINAPI
CleanupTraceEventList(
        PLIST_ENTRY HeadEventList
        )
{

    PLIST_ENTRY Head, Next;
    PMOF_INFO   pMofInfo;

    if (HeadEventList == NULL)
    {
        return;
    }

    Head = HeadEventList;
    Next = Head->Flink;
    while (Head != Next)
    {
        pMofInfo = CONTAINING_RECORD(Next, MOF_INFO, Entry);
        RemoveEntryList(&pMofInfo->Entry);
        RemoveMofInfo(pMofInfo->ItemHeader);
        free(pMofInfo->ItemHeader);
        free(pMofInfo->strDescription);
        free(pMofInfo->TypeFormat);
        free(pMofInfo->strType);
        Next = Next->Flink;
        free(pMofInfo);
    }

    free(HeadEventList);
}

void
RemoveMofInfo(
        PLIST_ENTRY pMofInfo
        )
{
    PLIST_ENTRY Head, Next;
    PITEM_DESC  pItem;

    Head = pMofInfo;
    Next = Head->Flink;
    while (Head != Next)
    {
        pItem = CONTAINING_RECORD(Next, ITEM_DESC, Entry);
        Next = Next->Flink;
        RemoveEntryList(&pItem->Entry);

        if (pItem->strDescription != NULL)
            free(pItem->strDescription);
        if (pItem->ItemList != NULL)
            free(pItem->ItemList);
        free(pItem);
    }

}

// Now for some of the ASCII Stuff
//
SIZE_T
WINAPI
FormatTraceEventA(
        PLIST_ENTRY   HeadEventList,
        PEVENT_TRACE  pInEvent,
        CHAR        * EventBuf,
        ULONG         SizeEventBuf,
        CHAR        * pszMask
        )
{
    SIZE_T  Status;
    ULONG   uSizeEventBuf;
    TCHAR * EventBufW;
    TCHAR * pszMaskW;

    EventBufW = (TCHAR *) malloc(SizeEventBuf * sizeof(TCHAR) + 2);
    if (EventBufW == (TCHAR *) NULL)
    {
        return -1;
    }

    pszMaskW = (TCHAR *) NULL;

    if (pszMask != NULL && strlen(pszMask) != 0)
    {
        pszMaskW = (TCHAR *) malloc(strlen(pszMask) * sizeof(TCHAR));
        if (pszMaskW == (TCHAR *) NULL)
        {
            free(EventBufW);
            return -1;
        }
		RtlZeroMemory(pszMaskW, strlen(pszMask) * sizeof(TCHAR));
    }



    uSizeEventBuf = SizeEventBuf;

    Status = FormatTraceEventW(
                    HeadEventList,
                    pInEvent,
                    EventBufW,
                    SizeEventBuf,
                    pszMaskW);
    if (Status == 0)
    {
        free(EventBufW);
        free(pszMaskW);
        return -1;
    }

    RtlZeroMemory(EventBuf,uSizeEventBuf);

    WideCharToMultiByte(
            CP_ACP,
            0,
            EventBufW,
            (int) _tcslen(EventBufW),   // Truncate in Sundown!!
            EventBuf,
            uSizeEventBuf,
            NULL,
            NULL);

    free(EventBufW);
    free(pszMaskW);

    return Status;
}

ULONG
WINAPI
GetTraceGuidsA(
        CHAR        * GuidFile,
        PLIST_ENTRY * HeadEventList
        )
{
    INT     Status;
    TCHAR * GuidFileW;
    SIZE_T len;

    if ((len = strlen(GuidFile)) == 0)
    {
        return 0;
    }

    GuidFileW = malloc(sizeof(TCHAR) * strlen(GuidFile) + 2);
    if (GuidFileW == NULL)
    {
        return 0;
    }

    if ((MultiByteToWideChar(
                    CP_ACP,
                    0,
                    GuidFile,
                    -1,
                    GuidFileW,
                    (int) strlen(GuidFile) * sizeof(TCHAR))) // Truncate in Sundown!!
        == 0)
    {
		free(GuidFileW);
        return 0;
    }

    Status = GetTraceGuidsW(GuidFileW, HeadEventList);

    free (GuidFileW);
    return Status;
}

void
WINAPI
SummaryTraceEventListA(
        CHAR       * SummaryBlock,
        ULONG        SizeSummaryBlock,
        PLIST_ENTRY  EventListhead
        )
{
    TCHAR * SummaryBlockW;

	if(SizeSummaryBlock <= 0 || SizeSummaryBlock * sizeof(TCHAR) <= 0 )return;

    SummaryBlockW = (TCHAR *) malloc(SizeSummaryBlock * sizeof(TCHAR));
    if (SummaryBlockW == (TCHAR *)NULL)
		return;
	
	//RtlZeroMemory(SummaryBlock, SizeSummaryBlock);
    RtlZeroMemory(SummaryBlockW, SizeSummaryBlock*sizeof(TCHAR));
    SummaryTraceEventListW(
            SummaryBlockW,
            SizeSummaryBlock * ((ULONG)sizeof(TCHAR)),
            EventListhead);

    WideCharToMultiByte(
            CP_ACP,
            0,
            SummaryBlockW,
            (int)_tcslen(SummaryBlockW), // Truncate in Sundown!!
            SummaryBlock,
            SizeSummaryBlock,
            NULL,
            NULL);
    free(SummaryBlockW);
}

void
WINAPI
GetTraceElapseTime(
        __int64 * pElapseTime
        )
{
    * pElapseTime = ElapseTime;
}

ULONG
WINAPI
SetTraceFormatParameter(
        PARAMETER_TYPE  Parameter ,
        PVOID           ParameterValue 
        )
{
    switch (Parameter) {
        case ParameterINDENT: 
            bIndent = PtrToUlong(ParameterValue);
            break;

        case ParameterSEQUENCE: 
            bSequence = PtrToUlong(ParameterValue);
            if (bSequence) {
                STD_PREFIX = STD_PREFIX_SEQ;
            } else {
                STD_PREFIX = STD_PREFIX_NOSEQ;
            }
            break;

        case ParameterGMT: 
            bGmt = PtrToUlong(ParameterValue);
            break;

    case ParameterTraceFormatSearchPath:
            
            break;
    }

    return 0 ;
}

ULONG
WINAPI
GetTraceFormatParameter(
        PARAMETER_TYPE  Parameter ,
        PVOID           ParameterValue 
        )
{
    switch (Parameter) {
        case ParameterINDENT: return bIndent;
        case ParameterSEQUENCE: return bSequence; 
        case ParameterGMT: return bGmt;
    }

    return 0 ;

}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracelog\tracelog.c ===
// begin_sdk
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    tracelog.c

Abstract:

    Sample trace control program. Allows user to start, stop event tracing

// end_sdk

Author:

    Jee Fung Pang (jeepang) 03-Dec-1997

Revision History:

    Insung Park (insungp)   28-Nov-2000

          Now tracelog can be used to set the registry keys to start or stop 
        GlobalLogger. Other options also works except a few (such as -enable).
        e.g.
            tracelog -start GlobalLogger
            tracelog -stop GlobalLogger
            tracelog -q GlobalLogger

          However, "-start" option does not start GlobalLogger immediately. The
        machine must be rebooted. "-stop" option resets the registry keys and
        stop GlobalLogger.
          Users can use other options to customize the GlobalLogger sessions
        such as minimum and maximum buffers, buffer size, flush timer, and so on.
        One catch is, if any of the enable flags is set, GlobalLogger turns into
        NT Kernel Logger and its instance vanishes. Any attempt to access 
        GlobalLogger with its name will fail with ERROR_WMI_INSTANCE_NOT_FOUND. 
        "-stop" option will still reset registry keys so that the next time the
        machine boots GlobalLogger will not start.
        
          If any of the flags is set, users should access NT Kernel Logger to
        control it.

          Modified/updated functions include GetGlobalLoggerSettings,
        SetGlobalLoggerSettings, main, PrintLoggerStatus.

    Insung Park (insungp)   19-Dec-2000
        
          Changed trace function calls so that tracelog can be used on Win2K.
        FlushTrace and EnumTraceGuids are not implemented on Win2K, but they do 
        not stop the execution of tracelog. An attempt to use FlushTrace or
        EnumTraceGuids on W2K will generate an error message.
          Fixed "-flags -1" bug. tracelog does not accept any flag with MSB=1.

    Insung Park (insungp)   21-Dec-2000
          Added a version display.
          Fixed PrintHelpMessage() so that options not available on Win2K will
        not be printed. ("-paged", "-flush", "-enumguid", "-append", "-newfile",
        "-eflag", "-ls", "-gs")
          Cleaned up the if blocks in main() so that tracelog frees allocated
        space properly before exiting regardless of error status.

// begin_sdk

--*/
#ifndef UNICODE
#define UNICODE
#endif
#ifndef _UNICODE
#define _UNICODE
#endif

#include <stdio.h>
#include <stdlib.h>
// end_sdk
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
// begin_sdk
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <guiddef.h>
#include <evntrace.h>
#include <wmiguid.h>
// end_sdk
#include <ntwmi.h>
// begin_sdk

#define MAXSTR                          1024
#define DEFAULT_LOGFILE_NAME            _T("C:\\LogFile.Etl")

// end_sdk
#define GLOBAL_LOGGER                   _T("GlobalLogger")
#define EVENT_LOGGER                    _T("WMI Event Logger")
#define MAXENABLEFLAGS                  10
// begin_sdk
#define MAXIMUM_LOGGERS                  32
#define MAXGUIDS                        128

#define ACTION_QUERY                    0
#define ACTION_START                    1
#define ACTION_STOP                     2
#define ACTION_UPDATE                   3
#define ACTION_LIST                     4
#define ACTION_ENABLE                   5
#define ACTION_HELP                     6
#define ACTION_FLUSH                    7
#define ACTION_ENUM_GUID                8
// end_sdk
#define ACTION_REMOVE                   9
// begin_sdk
#define ACTION_UNDEFINED               10

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))
#define WSTRSIZE(str) (ULONG) ( (str) ? ((PCHAR) &str[wcslen(str)] - (PCHAR)str) + sizeof(UNICODE_NULL) : 0 )

// Functions not implemented on Win2K need to be searched and loaded separately.
// To make further accesses easy, an array of function pointers will be used.
// The following list serves as indices to that array.
//
// If new functions are added to evntrace.h, the following list should be updated
// as well as the array initialization routine at the beginning of main(). 
#define FUNC_FLUSH_TRACE        0
#define FUNC_ENUM_TRACE_GUIDS   1
// Funtion pointer array for unimplemented functions on Win2K.
// Note: This may not work if this code is ported to C++, because
// all the function pointers may be typedefed differently.
#define MAXFUNC                 10
FARPROC FuncArray[MAXFUNC];
HINSTANCE advapidll;

BOOLEAN Whistler;

void
PrintLoggerStatus(
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
// end_sdk
    IN ULONG GlobalLoggerStartValue,
// begin_sdk
    IN ULONG Status,
    IN BOOL PrintStatus
    );

#define PRINTSTATUS TRUE
#define NOPRINTSTATUS FALSE

LPTSTR
DecodeStatus(
    IN ULONG Status
    );

LONG
GetGuids(
    IN LPTSTR GuidFile, 
    OUT LPGUID *GuidArray
    );

ULONG 
ahextoi(
    IN TCHAR *s
    );

void 
StringToGuid(
    IN TCHAR *str,
    OUT LPGUID guid
    );

PTCHAR 
GuidToString(
    IN OUT PTCHAR s,
    IN LPGUID piid
    );

TCHAR ErrorMsg[MAXSTR];

void 
PrintHelpMessage();

// end_sdk
ULONG
SetGlobalLoggerSettings(
    IN DWORD StartValue,
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
    IN DWORD ClockType
);

ULONG
GetGlobalLoggerSettings(
    IN OUT PEVENT_TRACE_PROPERTIES LoggerInfo,
    OUT PULONG ClockType,
    OUT PDWORD pdwStart
);
// begin_sdk

//
//  main function
//
__cdecl main(argc, argv)
    int argc;
    char **argv;
/*++

Routine Description:

    It is the main function.

Arguments:
  

Return Value:

    Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS (== 0).


--*/{
    ULONG i, j;
    LONG GuidCount;
    USHORT Action = ACTION_UNDEFINED;
    ULONG Status = 0;
    LPTSTR LoggerName;
    LPTSTR LogFileName;
    TCHAR GuidFile[MAXSTR];
    PEVENT_TRACE_PROPERTIES pLoggerInfo;
    TRACEHANDLE LoggerHandle = 0;
    LPTSTR *targv, *utargv = NULL;
    LPGUID *GuidArray;
    char *Space;
    char *save;
    BOOL bKill = FALSE;
    BOOL bForceKill = FALSE ;
    BOOL bEnable = TRUE;
    ULONG iLevel = 0;
    ULONG iFlags = 0;
    ULONG SizeNeeded = 0;
    ULONG specialLogger = 0;
    ULONG GlobalLoggerStartValue = 0;
    PULONG pFlags = NULL;

    BOOL bProcess = TRUE;
    BOOL bThread  = TRUE;
    BOOL bDisk    = TRUE;
    BOOL bNetwork = TRUE;

    TCHAR tstrLogFileName[MAXSTR];

    OSVERSIONINFO OSVersion;

    OSVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    Whistler = FALSE;
    if (GetVersionEx(&OSVersion))
        Whistler = (OSVersion.dwMajorVersion > 5) ||
                    ((OSVersion.dwMajorVersion == 5) && (OSVersion.dwMinorVersion > 0));

    // Load functions that are not implemented on Win2K
    for (i = 0; i < MAXFUNC; ++i)
        FuncArray[i] = NULL;
    if (Whistler) {
        advapidll = LoadLibrary(_T("advapi32.dll"));
        if (advapidll != NULL) {
#ifdef UNICODE
            FuncArray[FUNC_FLUSH_TRACE] = GetProcAddress(advapidll, "FlushTraceW");
#else
            FuncArray[FUNC_FLUSH_TRACE] = GetProcAddress(advapidll, "FlushTraceA");
#endif
            FuncArray[FUNC_ENUM_TRACE_GUIDS] = GetProcAddress(advapidll, "EnumerateTraceGuids");
        }
    }

    // Initialize structure first
    SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAXSTR * sizeof(TCHAR);
// end_sdk
    SizeNeeded += MAXENABLEFLAGS * sizeof(ULONG); // for extension enable flags
// begin_sdk
    pLoggerInfo = (PEVENT_TRACE_PROPERTIES) malloc(SizeNeeded);
    if (pLoggerInfo == NULL) {
        if (advapidll != NULL)
            FreeLibrary(advapidll);
        return (ERROR_OUTOFMEMORY);
    }
    

    RtlZeroMemory(pLoggerInfo, SizeNeeded);

    pLoggerInfo->Wnode.BufferSize = SizeNeeded;
    pLoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
    pLoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    pLoggerInfo->LogFileNameOffset = pLoggerInfo->LoggerNameOffset + MAXSTR * sizeof(TCHAR);

    LoggerName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LoggerNameOffset);
    LogFileName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LogFileNameOffset);
    _tcscpy(LoggerName, KERNEL_LOGGER_NAME);

    Space = (char*) malloc( (MAXGUIDS * sizeof(GuidArray)) +
                            (MAXGUIDS * sizeof(GUID) ));
    if (Space == NULL) {
        free(pLoggerInfo);
        if (advapidll != NULL)
            FreeLibrary(advapidll);
        return(ERROR_OUTOFMEMORY);
    }
    save = Space;
    GuidArray = (LPGUID *) Space;
    Space += MAXGUIDS * sizeof(GuidArray);

    for (GuidCount=0; GuidCount<MAXGUIDS; GuidCount++) {
        GuidArray[GuidCount] = (LPGUID) Space;
        Space += sizeof(GUID);
    }
    GuidCount = 0;

#ifdef UNICODE
    if ((targv = CommandLineToArgvW(
                      GetCommandLineW(),    // pointer to a command-line string
                      &argc                 // receives the argument count
                      )) == NULL) {
        free(pLoggerInfo);
        free(save);
        if (advapidll != NULL)
            FreeLibrary(advapidll);
        return (GetLastError());
    };
    utargv = targv;
#else
    targv = argv;
#endif

    pFlags = &pLoggerInfo->EnableFlags;
    //
    // Add default flags. Should consider options to control this independently
    //
    while (--argc > 0) {
        ++targv;
        if (**targv == '-' || **targv == '/') {  // argument found
            if(targv[0][0] == '/' ) targv[0][0] = '-';
            if (!_tcsicmp(targv[0], _T("-start"))) {
                Action = ACTION_START;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-enable"))) {
                Action = ACTION_ENABLE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-disable"))) {
                Action = ACTION_ENABLE;
                bEnable = FALSE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-stop"))) {
                Action = ACTION_STOP;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-update"))) {
                Action = ACTION_UPDATE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
// end_sdk
            else if (!_tcsicmp(targv[0], _T("-remove"))) {
                Action = ACTION_REMOVE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
                // if it is not GlobalLogger, nothing happens.
            }
// begin_sdk
            else if (!_tcsicmp(targv[0], _T("-q"))) {
                Action = ACTION_QUERY;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-flush"))) {
                Action = ACTION_FLUSH;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-enumguid"))) {
                Action = ACTION_ENUM_GUID;
            }
            else if (!_tcsicmp(targv[0], _T("-f"))) {
                if (argc > 1) {
                    if (Whistler) 
                        _tcscpy(LogFileName, targv[1]);
                    else 
                        _tfullpath(LogFileName, targv[1], MAXSTR);
                    _tcscpy(tstrLogFileName, targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Setting log file to: %s\n"), LogFileName);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-append"))) {
                // _tprintf(_T("Appending log file: %s\n"), LogFileName);
                pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_APPEND;
            }
            else if (!_tcsicmp(targv[0], _T("-prealloc"))) {
                // _tprintf(_T("Preallocating log file: %s\n"), LogFileName);
                pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_PREALLOCATE;
            }
            else if (!_tcsicmp(targv[0], _T("-guid"))) {
                if (argc > 1) {
                    if (targv[1][0] == _T('#')) {
                        StringToGuid(&targv[1][1], GuidArray[0]);
                        ++targv; --argc;
                        GuidCount = 1;
                    }
                    else if (targv[1][0] != '-' && targv[1][0] != '/') {
                        _tfullpath(GuidFile, targv[1], MAXSTR);
                        ++targv; --argc;
                        // _tprintf(_T("Getting guids from %s\n"), GuidFile);
                        GuidCount = GetGuids(GuidFile, GuidArray);
                        if (GuidCount < 0) {
                            _tprintf( _T("Error: %s does no exist\n"), GuidFile );
                        }
                        else if (GuidCount == 0){
                            _tprintf( _T("Error: %s is invalid\n"), GuidFile );
                            Status = ERROR_INVALID_PARAMETER;
                            goto CleanupExit;
                        }
                    }
                }
            }
// end_sdk
            else if (!_tcsicmp(targv[0], _T("-UsePerfCounter"))) {
                pLoggerInfo->Wnode.ClientContext = 1;
            }
            else if (!_tcsicmp(targv[0], _T("-UseSystemTime"))) {
                pLoggerInfo->Wnode.ClientContext = 2;
            }
            else if (!_tcsicmp(targv[0], _T("-UseCPUCycle"))) {
                pLoggerInfo->Wnode.ClientContext = 3;
            }
// begin_sdk
            else if (!_tcsicmp(targv[0], _T("-seq"))) {
                if (argc > 1) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_SEQUENTIAL;
                    pLoggerInfo->MaximumFileSize = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Setting maximum sequential logfile size to: %d\n"),
                    //    pLoggerInfo->MaximumFileSize);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-newfile"))) {
                if (argc > 1) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_NEWFILE;
                    pLoggerInfo->MaximumFileSize = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Setting maximum logfile size to: %d\n"),
                    //    pLoggerInfo->MaximumFileSize);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-cir"))) {
                if (argc > 1) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_CIRCULAR;
                    pLoggerInfo->MaximumFileSize = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Setting maximum circular logfile size to: %d\n"),
                    //    pLoggerInfo->MaximumFileSize);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-b"))) {
                if (argc > 1) {
                    pLoggerInfo->BufferSize = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Changing buffer size to %d\n"),
                    //    pLoggerInfo->BufferSize);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-flag")) || !_tcsicmp(targv[0], _T("-flags"))) {
                if (argc > 1) {
                    if (targv[1][1] == _T('x') || targv[1][1] == _T('X')) {
                        pLoggerInfo->EnableFlags |= ahextoi(targv[1]);
                    } else {
                        pLoggerInfo->EnableFlags |= _ttoi(targv[1]);
                    }
                    iFlags =  pLoggerInfo->EnableFlags ;   // Copy for EnableTrace
                    ++targv; --argc;
                    // Do not accept flags with MSB = 1.

                    if (0x80000000 & pLoggerInfo->EnableFlags) {
                        _tprintf(_T("Invalid Flags: 0x%0X(%d.)\n"),
                            pLoggerInfo->EnableFlags, pLoggerInfo->EnableFlags);
                        Status = ERROR_INVALID_PARAMETER;
                        goto CleanupExit;
                    }

                    // _tprintf(_T("Setting logger flags to 0x%0X(%d.)\n"),
                    //    pLoggerInfo->EnableFlags, pLoggerInfo->EnableFlags );
                }
            }
// end_sdk
            else if (!_tcsicmp(targv[0], _T("-eflag"))) {
                if (argc > 2) {
                    USHORT nFlag = (USHORT) _ttoi(targv[1]);
                    USHORT i, offset;
                    PTRACE_ENABLE_FLAG_EXTENSION FlagExt;

                    ++targv; --argc;
                    if (nFlag > MAXENABLEFLAGS || nFlag < 1) {
                       _tprintf(_T("Error: Invalid number of enable flags\n"));
                       Status = ERROR_INVALID_PARAMETER;
                       goto CleanupExit;
                    }
                    offset = (USHORT) 
                             (SizeNeeded - (sizeof(ULONG) * MAXENABLEFLAGS));
                    pLoggerInfo->EnableFlags = EVENT_TRACE_FLAG_EXTENSION;
                    FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                                &pLoggerInfo->EnableFlags;
                    FlagExt->Offset = offset;
                    FlagExt->Length = (UCHAR) nFlag;

                    pFlags = (PULONG) ( offset + (PCHAR) pLoggerInfo );
                    for (i=0; i<nFlag && argc > 1; i++) {
                        if (targv[1][0] == '/' || targv[1][0] == '-') {
                            // Correct the number of eflags when the user
                            // types an incorrect number.
                            // However, this does not work if the next
                            // argument is Logger Name.
                            break;
                        }
                        pFlags[i] = ahextoi(targv[1]);
                        ++targv; --argc;
                        // _tprintf(_T("Setting logger flags to 0x%0X(%d.)\n"),
                        //    pFlags[i], pFlags[i] );
                    }
                    nFlag = i;
                    for ( ; i < MAXENABLEFLAGS; i++) {
                        pFlags[i] = 0;
                    }
                    if (FlagExt->Length != (UCHAR)nFlag) {
                        // _tprintf(_T("Correcting the number of eflags to %d\n"), i),
                        FlagExt->Length = (UCHAR)nFlag;
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-pids"))) {

                if (argc > 2) {
                    USHORT nFlag = (USHORT) _ttoi(targv[1]);
                    USHORT i, offset;
                    PTRACE_ENABLE_FLAG_EXTENSION FlagExt;

                    ++targv; --argc;
                    if (nFlag > MAXENABLEFLAGS || nFlag < 1) {
                       _tprintf(_T("Error: Invalid number of enable flags\n"));
                       Status = ERROR_INVALID_PARAMETER;
                       goto CleanupExit;
                    }
                    offset = (USHORT) 
                             (SizeNeeded - (sizeof(ULONG) * MAXENABLEFLAGS));
                    pLoggerInfo->EnableFlags = EVENT_TRACE_FLAG_EXTENSION;
                    FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                                &pLoggerInfo->EnableFlags;
                    FlagExt->Offset = offset;
                    FlagExt->Length = (UCHAR) nFlag;

                    pFlags = (PULONG) ( offset + (PCHAR) pLoggerInfo );
                    for (i=0; i<nFlag && argc > 1; i++) {
                        if (targv[1][0] == '/' || targv[1][0] == '-') {
                            // Correct the number of eflags when the user
                            // types an incorrect number.
                            // However, this does not work if the next
                            // argument is Logger Name.
                            break;
                        }
                        pFlags[i] = _ttol((PTCHAR)targv[1]);
                        ++targv; --argc;
                        // _tprintf(_T("Setting logger flags to 0x%0X(%d.)\n"),
                        //    pFlags[i], pFlags[i] );
                    }
                    nFlag = i;
                    for ( ; i < MAXENABLEFLAGS; i++) {
                        pFlags[i] = 0;
                    }
                    if (FlagExt->Length != (UCHAR)nFlag) {
                        // _tprintf(_T("Correcting the number of eflags to %d\n"), i),
                        FlagExt->Length = (UCHAR)nFlag;
                    }
                }
            }
            else if (!_tcsicmp(targv[0],_T("-ls"))) {
                pLoggerInfo->LogFileMode |= EVENT_TRACE_USE_LOCAL_SEQUENCE  ;
            }
            else if (!_tcsicmp(targv[0],_T("-gs"))) {
                pLoggerInfo->LogFileMode |= EVENT_TRACE_USE_GLOBAL_SEQUENCE ;
            }
// begin_sdk
            else if (!_tcsicmp(targv[0], _T("-min"))) {
                if (argc > 1) {
                    pLoggerInfo->MinimumBuffers = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Changing Minimum Number of Buffers to %d\n"),
                    //    pLoggerInfo->MinimumBuffers);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-max"))) {
                if (argc > 1) {
                    pLoggerInfo->MaximumBuffers = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Changing Maximum Number of Buffers to %d\n"),
                    //    pLoggerInfo->MaximumBuffers);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-level"))) {
                if (argc > 1) {
                    iLevel = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Setting tracing level to %d\n"), iLevel);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-ft"))) {
                if (argc > 1) {
                    pLoggerInfo->FlushTimer = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Setting buffer flush timer to %d seconds\n"),
                    //    pLoggerInfo->FlushTimer);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-um"))) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_PRIVATE_LOGGER_MODE;
                    // _tprintf(_T("Setting Private Logger Flags\n"));
            }
            else if (!_tcsicmp(targv[0], _T("-paged"))) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_USE_PAGED_MEMORY;
                    // _tprintf(_T("Setting Paged Memory Flag\n"));
            }
            else if (!_tcsicmp(targv[0], _T("-rt"))) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_REAL_TIME_MODE;
                    // _tprintf(_T("Setting real time mode\n"));
// end_sdk
               if (argc > 1) {
                   if (targv[1][0] != '-' && targv[1][0] != '/') {
                       ++targv; --argc;
                       if (targv[0][0] == 'b')
                           pLoggerInfo->LogFileMode |= EVENT_TRACE_BUFFERING_MODE;
                   }
               }
// begin_sdk
            }
            else if (!_tcsicmp(targv[0], _T("-age"))) {
                if (argc > 1) {
                    pLoggerInfo->AgeLimit = _ttoi(targv[1]);
                    ++targv; --argc;
                    // _tprintf(_T("Changing Aging Decay Time to %d\n"),
                    //    pLoggerInfo->AgeLimit);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-l"))) {
                Action  = ACTION_LIST;
                bKill   = FALSE;
            }
            else if (!_tcsicmp(targv[0], _T("-x"))) {
                Action  = ACTION_LIST;
                bKill   = TRUE;
            }
            else if (!_tcsicmp(targv[0], _T("-xf"))) {
                Action  = ACTION_LIST;
                bKill   = TRUE;
                bForceKill = TRUE ;
            }
            else if (!_tcsicmp(targv[0], _T("-noprocess"))) {
                bProcess = FALSE;
            }
            else if (!_tcsicmp(targv[0], _T("-nothread"))) {
                bThread = FALSE;
            }
            else if (!_tcsicmp(targv[0], _T("-nodisk"))) {
                bDisk = FALSE;
            }
            else if (!_tcsicmp(targv[0], _T("-nonet"))) {
                bNetwork = FALSE;
            }
            else if (!_tcsicmp(targv[0], _T("-fio"))) {
                if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_DISK_FILE_IO;
                }
                else {
                    _tprintf(_T("Option -fio cannot be used with -eflags. Ignored\n"));
                }
            }
            else if (!_tcsicmp(targv[0], _T("-pf"))) {
                if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS;
                }
                else {
                    _tprintf(_T("Option -pf cannot be used with -eflags. Ignored\n"));
                }
            }
            else if (!_tcsicmp(targv[0], _T("-hf"))) {
                if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS;
                }
                else {
                    _tprintf(_T("Option -hf cannot be used with -eflags. Ignored\n"));
                }
            }
            else if (!_tcsicmp(targv[0], _T("-img"))) {
                if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_IMAGE_LOAD;
                }
                else {
                    _tprintf(_T("Option -img cannot be used with -eflags. Ignored\n"));
                }
            }
            else if (!_tcsicmp(targv[0], _T("-cm"))) {
                if (pFlags == &pLoggerInfo->EnableFlags) {
                    *pFlags |= EVENT_TRACE_FLAG_REGISTRY;
                }
                else {
                    _tprintf(_T("Option -cm cannot be used with -eflags. Ignored\n"));
                }
            }
            else if ( targv[0][1] == 'h' || targv[0][1] == 'H' || targv[0][1] == '?'){
                Action = ACTION_HELP;
                PrintHelpMessage();
                goto CleanupExit;
            }
            else Action = ACTION_UNDEFINED;
        }
        else { // get here if "-" or "/" given
            _tprintf(_T("Invalid option given: %s\n"), targv[0]);
            Status = ERROR_INVALID_PARAMETER;
            goto CleanupExit;
        }
    }
    if (!_tcscmp(LoggerName, KERNEL_LOGGER_NAME)) {
        if (pFlags == &pLoggerInfo->EnableFlags) {
            if (bProcess)
                *pFlags |= EVENT_TRACE_FLAG_PROCESS;
            if (bThread)
                *pFlags |= EVENT_TRACE_FLAG_THREAD;
            if (bDisk)
                *pFlags |= EVENT_TRACE_FLAG_DISK_IO;
            if (bNetwork)
                *pFlags |= EVENT_TRACE_FLAG_NETWORK_TCPIP;
        }

        pLoggerInfo->Wnode.Guid = SystemTraceControlGuid; // defaults to OS
        specialLogger = 1;
    }
// end_sdk
    if (!_tcscmp(LoggerName, GLOBAL_LOGGER)) {
        pLoggerInfo->Wnode.Guid = GlobalLoggerGuid;
        specialLogger = 3;
    }
    else if (!_tcscmp(LoggerName, EVENT_LOGGER)) {
        pLoggerInfo->Wnode.Guid = WmiEventLoggerGuid;
        specialLogger = 2;
    }
// begin_sdk
    if ( !(pLoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) ) {
        if (specialLogger != 3 && _tcslen(LogFileName) <= 0 && Action == ACTION_START) {
            _tcscpy(LogFileName, DEFAULT_LOGFILE_NAME); // for now...
            _tcscpy(tstrLogFileName, DEFAULT_LOGFILE_NAME);
        }
    }

    switch (Action) {
        case  ACTION_START:
        {

           if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
               if (GuidCount != 1) {
                   _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                   Status = ERROR_INVALID_PARAMETER;
                   break;
               }
               pLoggerInfo->Wnode.Guid = *GuidArray[0];
           }

           if (pLoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_PREALLOCATE  &&
               pLoggerInfo->MaximumFileSize == 0) {
               _tprintf(_T("Need file size for preallocated log file\n"));
               Status = ERROR_INVALID_PARAMETER;
               break;
           }
// end_sdk
            if (specialLogger == 3) {  // Global Logger
                Status = SetGlobalLoggerSettings(1L, pLoggerInfo, pLoggerInfo->Wnode.ClientContext);
                if (Status != ERROR_SUCCESS)
                    break;
                Status = GetGlobalLoggerSettings(pLoggerInfo, &pLoggerInfo->Wnode.ClientContext, &GlobalLoggerStartValue);
                break;
            }
// begin_sdk
            if(pLoggerInfo->EnableFlags & EVENT_TRACE_FLAG_EXTENSION){
                if(IsEqualGUID(&CritSecGuid,GuidArray[0]) ||
                    IsEqualGUID(&HeapGuid,GuidArray[0])){
                    pLoggerInfo->Wnode.HistoricalContext = iLevel;
                }
            }
            Status = StartTrace(&LoggerHandle, LoggerName, pLoggerInfo);

            if (Status != ERROR_SUCCESS) {
                _tprintf(_T("Could not start logger: %s\n") 
                         _T("Operation Status:       %uL\n")
                         _T("%s\n"),
                         LoggerName,
                         Status,
                         DecodeStatus(Status));

                break;
            }
            _tprintf(_T("Logger Started...\n"));

        case ACTION_ENABLE:

            if (Action == ACTION_ENABLE ){

                if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
                {
                    if (GuidCount != 1)
                    {
                        _tprintf(_T("Need one GUID for PRIVATE loggers\n"));
                        Status = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    pLoggerInfo->Wnode.Guid = *GuidArray[0];
                }

                Status = ControlTrace((TRACEHANDLE) 0, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
                if( Status != ERROR_SUCCESS ){
                    if( Status != ERROR_SUCCESS ){
                        if( IsEqualGUID(&HeapGuid,&pLoggerInfo->Wnode.Guid) 
                        || IsEqualGUID(&CritSecGuid,&pLoggerInfo->Wnode.Guid) 
                        ){
                            //do nothing 
                        } else {

                            _tprintf( _T("ERROR: Logger not started\n")
                                      _T("Operation Status:    %uL\n")
                                      _T("%s\n"),
                                      Status,
                                      DecodeStatus(Status));
							break;
                        }
                    }
                }
                LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;
            }

            if ( (GuidCount > 0) && (specialLogger == 0)) {
                _tprintf(_T("Enabling trace to logger %d\n"), LoggerHandle);
                for (i=0; i<(ULONG)GuidCount; i++) {
                    Status = EnableTrace (
                                    bEnable,
                                    iFlags,
                                    iLevel,
                                    GuidArray[i], 
                                    LoggerHandle);

                    //
                    // If the Guid can not be enabled, it is a benign 
                    // failure. Print Warning message and continue. 
                    //
                    if (Status == 4317) {
                       _tprintf(_T("WARNING: Could not enable some guids.\n")); 
                       _tprintf(_T("Check your Guids file\n")); 
                        Status = ERROR_SUCCESS;
                    }

                    if (Status != ERROR_SUCCESS) {
                        _tprintf(_T("ERROR: Failed to enable Guid [%d]...\n"), i);
                        _tprintf(_T("Operation Status:       %uL\n"), Status);
                        _tprintf(_T("%s\n"),DecodeStatus(Status));
                        break;
                    }
                }
            }
            else {
                if (GuidCount > 0) {
                    _tprintf(_T("ERROR: System Logger does not accept application guids...\n"));
                    Status = ERROR_INVALID_PARAMETER;
                }
            }
            break;
        }

        case ACTION_STOP :
            LoggerHandle = (TRACEHANDLE) 0;
            Status = ERROR_SUCCESS;
            if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                if (GuidCount != 1) {
                    _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                    Status = ERROR_INVALID_PARAMETER;
                    break;
                }
                pLoggerInfo->Wnode.Guid = *GuidArray[0];
            }
// end_sdk
            if (specialLogger == 3)
                Status = GetGlobalLoggerSettings(pLoggerInfo, &pLoggerInfo->Wnode.ClientContext, &GlobalLoggerStartValue);
// begin_sdk
            if (specialLogger != 0) {
                if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                    Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
                    if (Status != ERROR_SUCCESS)
                        break;
                    LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;
                    Status = EnableTrace( FALSE,
                                          EVENT_TRACE_PRIVATE_LOGGER_MODE,
                                          0,
                                          GuidArray[0],
                                          LoggerHandle );
                }
                else {
                    Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
                    if (Status == ERROR_WMI_INSTANCE_NOT_FOUND)
                        break;
                    LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;

                    for (i=0; i<(ULONG)GuidCount; i++) {
                    Status = EnableTrace( FALSE,
                                              0,
                                              0,
                                              GuidArray[i],
                                              LoggerHandle);
                    }

                }
            }

            Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_STOP);
            break;
// end_sdk
        case ACTION_REMOVE :
            if (specialLogger == 3) {  // Global Logger
                Status = SetGlobalLoggerSettings(0L, pLoggerInfo, pLoggerInfo->Wnode.ClientContext);
                if (Status != ERROR_SUCCESS)
                    break;
                Status = GetGlobalLoggerSettings(pLoggerInfo, &pLoggerInfo->Wnode.ClientContext, &GlobalLoggerStartValue);
                if (Status != ERROR_SUCCESS)
                    break;
            }
            break;
// begin_sdk

        case ACTION_LIST :
        {
            ULONG i, returnCount ;
            ULONG SizeNeeded;
            PEVENT_TRACE_PROPERTIES pLoggerInfo[MAXIMUM_LOGGERS];
            PEVENT_TRACE_PROPERTIES pStorage;
            PVOID Storage;

            SizeNeeded = MAXIMUM_LOGGERS * (sizeof(EVENT_TRACE_PROPERTIES)
                                      + 2 * MAXSTR * sizeof(TCHAR));

            Storage =  malloc(SizeNeeded);
            if (Storage == NULL) {
                Status = ERROR_OUTOFMEMORY;
                break;
            }
            RtlZeroMemory(Storage, SizeNeeded);

            pStorage = (PEVENT_TRACE_PROPERTIES)Storage;
            for (i=0; i<MAXIMUM_LOGGERS; i++) {
                pStorage->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES)
                                         + 2 * MAXSTR * sizeof(TCHAR);
                pStorage->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES)
                                        + MAXSTR * sizeof(TCHAR);
                pStorage->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
                pLoggerInfo[i] = pStorage;
                pStorage = (PEVENT_TRACE_PROPERTIES) (
                                 (char*)pStorage + 
                                  pStorage->Wnode.BufferSize);
            }
        
            Status = QueryAllTraces(pLoggerInfo,
                                MAXIMUM_LOGGERS,
                                & returnCount);
    
            if (Status == ERROR_SUCCESS)
            {
                for (j= 0; j < returnCount; j++)
                {
                    LPTSTR LoggerName;
                    TCHAR asked = _T('?') ;
                    BOOL StatusPrint = FALSE ;
                    if (bKill)
                    {

                        LoggerName = (LPTSTR) ((char*)pLoggerInfo[j] + 
                                      pLoggerInfo[j]->LoggerNameOffset);
                        if (!bForceKill) {
                            while (!(asked == _T('y')) && !(asked == _T('n'))) {
                                _tprintf(_T("Do you want to kill Logger \"%s\" (Y or N)?"),LoggerName);
                                _tscanf(_T(" %c"),&asked);
                                if (asked == _T('Y')) {
                                    asked = _T('y') ;
                                } else if (asked == _T('N')) {
                                    asked = _T('n') ;
                                }
                            }
                        } else {
                            asked = _T('y');
                        }
                        if (asked == _T('y')) {
                            if (!IsEqualGUID(& pLoggerInfo[j]->Wnode.Guid,
                                         & SystemTraceControlGuid))
                            {
                                LoggerHandle = pLoggerInfo[j]->Wnode.HistoricalContext;
                                Status = EnableTrace(
                                          FALSE,
                                          (pLoggerInfo[j]->LogFileMode &
                                                  EVENT_TRACE_PRIVATE_LOGGER_MODE)
                                              ? (EVENT_TRACE_PRIVATE_LOGGER_MODE)
                                              : (0),
                                          0,
                                          & pLoggerInfo[j]->Wnode.Guid,
                                          LoggerHandle);
                            }
                            Status = ControlTrace((TRACEHANDLE) 0,
                                            LoggerName,
                                            pLoggerInfo[j],
                                            EVENT_TRACE_CONTROL_STOP);
                            _tprintf(_T("Logger \"%s\" has been killed\n"),LoggerName);
                            StatusPrint = TRUE ;
                        } else {
                            _tprintf(_T("Logger \"%s\" has not been killed, current Status is\n"),LoggerName);
                            StatusPrint = FALSE ;
                        }
                    }
                    PrintLoggerStatus(pLoggerInfo[j], 
// end_sdk
                                        0, 
// begin_sdk
                                        Status, 
                                        StatusPrint);
                    _tprintf(_T("\n"));
                }
            }

            i = 0;
            free(Storage);
            break;
        }

        case ACTION_UPDATE :
        case ACTION_FLUSH  :
        case ACTION_QUERY  :
            if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                if (GuidCount != 1) {
                    _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                    Status = ERROR_INVALID_PARAMETER;
                    break;
                }
                pLoggerInfo->Wnode.Guid = *GuidArray[0];
            }
            if (Action == ACTION_QUERY) {
// end_sdk
                if (specialLogger == 3) {
                    Status = GetGlobalLoggerSettings(pLoggerInfo, &pLoggerInfo->Wnode.ClientContext, &GlobalLoggerStartValue);
                }
// begin_sdk
                Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_QUERY);
            }

            else if (Action == ACTION_UPDATE) {
// end_sdk               
                if (specialLogger == 3) {
                    Status = GetGlobalLoggerSettings(pLoggerInfo, &pLoggerInfo->Wnode.ClientContext, &GlobalLoggerStartValue);
                }
// begin_sdk
                Status = ControlTrace(LoggerHandle, LoggerName, pLoggerInfo, EVENT_TRACE_CONTROL_UPDATE);
            }
            else if (Action == ACTION_FLUSH) {
                // Since FlushTrace is not implemented on Win2K, use the function pointer
                // loaded from advapi32.dll separately.
                // Originally, this block had one line: 
                // Status = FlushTrace(LoggerHandle, LoggerName, pLoggerInfo);
                if (FuncArray[FUNC_FLUSH_TRACE] == NULL) {
                    _tprintf(_T("Flush Trace is not supported on this system\n"));
                    Status = ERROR_INVALID_PARAMETER;
                    break;
                }
                Status = (ULONG)(*FuncArray[FUNC_FLUSH_TRACE])(LoggerHandle, LoggerName, pLoggerInfo);
            }

            break;

        case ACTION_ENUM_GUID:
        {
            ULONG i;
            ULONG PropertyArrayCount=10;
            PTRACE_GUID_PROPERTIES  *GuidPropertiesArray;
            ULONG GuidCount;
            ULONG SizeStorage;
            PVOID StorageNeeded;
            PTRACE_GUID_PROPERTIES CleanStorage;
            TCHAR str[MAXSTR];

            // Since EnumTraceGuids is not implemented on Win2K, use the function pointer
            // loaded from advapi32.dll separately.
            if (FuncArray[FUNC_ENUM_TRACE_GUIDS] == NULL) {
                _tprintf(_T("Enumerating trace GUIDS is not supported on this system\n"));
                Status = ERROR_INVALID_PARAMETER;
                break;
            }

Retry:
            SizeStorage = PropertyArrayCount * (sizeof(TRACE_GUID_PROPERTIES) + sizeof(PTRACE_GUID_PROPERTIES));
            StorageNeeded =  malloc(SizeStorage);
            if (StorageNeeded== NULL) {
                Status = ERROR_OUTOFMEMORY;
                break;
            }
            RtlZeroMemory(StorageNeeded, SizeStorage);
            GuidPropertiesArray = (PTRACE_GUID_PROPERTIES *)StorageNeeded;
            CleanStorage = (PTRACE_GUID_PROPERTIES)((char*)StorageNeeded + PropertyArrayCount * sizeof(PTRACE_GUID_PROPERTIES));
            for (i=0; i < PropertyArrayCount; i++) {
                GuidPropertiesArray[i] = CleanStorage;
                CleanStorage = (PTRACE_GUID_PROPERTIES) (
                                    (char*)CleanStorage + sizeof(TRACE_GUID_PROPERTIES)
                                    );
            }
            // Use function pointer for EnumTraceGuids
            Status = (ULONG)(*FuncArray[FUNC_ENUM_TRACE_GUIDS])(GuidPropertiesArray,PropertyArrayCount,&GuidCount);
            if(Status == ERROR_MORE_DATA)
            {
                PropertyArrayCount=GuidCount;
                free(StorageNeeded);
                goto Retry;

            }

            //
            // print the GUID_PROPERTIES and Free Strorage
            //

            _tprintf(_T("    Guid                     Enabled  LoggerId Level Flags\n"));
            _tprintf(_T("------------------------------------------------------------\n"));
            for (i=0; i < GuidCount; i++) {
                _tprintf(_T("%s     %5s  %d    %d    %d\n"),
                                           GuidToString(&str[0],&GuidPropertiesArray[i]->Guid), 
                                           (GuidPropertiesArray[i]->IsEnable) ? _T("TRUE") : _T("FALSE"),
                                            GuidPropertiesArray[i]->LoggerId,
                                           GuidPropertiesArray[i]->EnableLevel,
                                           GuidPropertiesArray[i]->EnableFlags 
                                                               );
            }
            free(StorageNeeded);
        }
        break;

        case ACTION_HELP:
            PrintHelpMessage();
            break;
        default :
            _tprintf(_T("Error: no action specified\n"));
            PrintHelpMessage();
            break;
    }
    
    if ((Action != ACTION_HELP) && (Action != ACTION_ENUM_GUID) 
        && (Action != ACTION_UNDEFINED) && (Action != ACTION_LIST))
        PrintLoggerStatus(pLoggerInfo,
// end_sdk
                            GlobalLoggerStartValue,
// begin_sdk
                            Status, 
                            PRINTSTATUS);
CleanupExit: 
    SetLastError(Status);
    if (utargv != NULL) {
        GlobalFree(utargv);
    }
    free(pLoggerInfo);
    free(save);
    if (advapidll != NULL)
        FreeLibrary(advapidll);
    return(Status);
}


void
PrintLoggerStatus(
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
// end_sdk
    IN ULONG GlobalLoggerStartValue,
// begin_sdk
    IN ULONG Status,
    IN BOOL PrintStatus
    )
/*++

Routine Description:

    Prints out the status of the specified logger.

Arguments:

    LoggerInfo - The pointer to the resident EVENT_TRACE_PROPERTIES that has
        the information about the current logger.
// end_sdk
    GlobalLoggerStartValue - The Start value for GlobalLogger (not used if it is
        not GlobalLogger).
// begin_sdk
    Status - The returned status of the last executed command 
        or
        the operation status of the current logger.

    PrintStatus - Determines which type of status it is using.

Return Value:

    None

--*/
{
    LPTSTR LoggerName, LogFileName;
    
    if ((LoggerInfo->LoggerNameOffset > 0) &&
        (LoggerInfo->LoggerNameOffset  < LoggerInfo->Wnode.BufferSize)) {
        LoggerName = (LPTSTR) ((char*)LoggerInfo +
                                LoggerInfo->LoggerNameOffset);
    }
    else LoggerName = NULL;

    if ((LoggerInfo->LogFileNameOffset > 0) &&
        (LoggerInfo->LogFileNameOffset  < LoggerInfo->Wnode.BufferSize)) {
        LogFileName = (LPTSTR) ((char*)LoggerInfo +
                                LoggerInfo->LogFileNameOffset);
    }
    else LogFileName = NULL;

    if (PrintStatus) {
        _tprintf(_T("Operation Status:       %uL\t"), Status);
        _tprintf(_T("%s\n"), DecodeStatus(Status));
    }
    
    _tprintf(_T("Logger Name:            %s\n"),
            (LoggerName == NULL) ?
            _T(" ") : LoggerName);
// end_sdk
    if (LoggerName == NULL || !_tcscmp(LoggerName, GLOBAL_LOGGER)) {
        // Logger ID
        _tprintf(_T("Status:                 %s\n"), 
                GlobalLoggerStartValue ?
                _T("Registry set to start") : _T("Registry set to stop"));
        _tprintf(_T("Logger Id:              %I64x\n"), LoggerInfo->Wnode.HistoricalContext);
        _tprintf(_T("Logger Thread Id:       %p\n"), LoggerInfo->LoggerThreadId);
        if (LoggerInfo->BufferSize == 0)
            _tprintf(_T("Buffer Size:            default value\n"));
        else
            _tprintf(_T("Buffer Size:            %d Kb\n"), LoggerInfo->BufferSize);

        if (LoggerInfo->MaximumBuffers == 0)
            _tprintf(_T("Maximum Buffers:        default value\n"));
        else
            _tprintf(_T("Maximum Buffers:        %d\n"), LoggerInfo->MaximumBuffers);
        if (LoggerInfo->MinimumBuffers == 0)
            _tprintf(_T("Minimum Buffers:        default value\n"));
        else
            _tprintf(_T("Minimum Buffers:        %d\n"), LoggerInfo->MinimumBuffers);
        
        _tprintf(_T("Number of Buffers:      %d\n"), LoggerInfo->NumberOfBuffers);
        _tprintf(_T("Free Buffers:           %d\n"), LoggerInfo->FreeBuffers);
        _tprintf(_T("Buffers Written:        %d\n"), LoggerInfo->BuffersWritten);
        _tprintf(_T("Events Lost:            %d\n"), LoggerInfo->EventsLost);
        _tprintf(_T("Log Buffers Lost:       %d\n"), LoggerInfo->LogBuffersLost);
        _tprintf(_T("Real Time Buffers Lost: %d\n"), LoggerInfo->RealTimeBuffersLost);
        _tprintf(_T("AgeLimit:               %d\n"), LoggerInfo->AgeLimit);

        if (LogFileName == NULL) {
            _tprintf(_T("Buffering Mode:         "));
        }
        else {
            _tprintf(_T("Log File Mode:          "));
        }
        if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) {
            _tprintf(_T("Append  "));
        }
        if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
            _tprintf(_T("Circular\n"));
        }
        else if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
            _tprintf(_T("Sequential\n"));
        }
        else {
            _tprintf(_T("Sequential\n"));
        }
        if (LoggerInfo->MaximumFileSize > 0)
            _tprintf(_T("Maximum File Size:      %d Mb\n"), LoggerInfo->MaximumFileSize);

        if (LoggerInfo->FlushTimer > 0)
            _tprintf(_T("Buffer Flush Timer:     %d secs\n"), LoggerInfo->FlushTimer);
        if (LoggerInfo->EnableFlags != 0) {
            _tprintf(_T("Enabled tracing:        "));
            if ((LoggerName != NULL) && (!_tcscmp(LoggerName, KERNEL_LOGGER_NAME))) {

                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_PROCESS)
                    _tprintf(_T("Process "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_THREAD)
                    _tprintf(_T("Thread "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
                    _tprintf(_T("Disk "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
                    _tprintf(_T("File "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
                    _tprintf(_T("PageFaults "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
                    _tprintf(_T("HardFaults "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
                    _tprintf(_T("ImageLoad "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
                    _tprintf(_T("TcpIp "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_REGISTRY)
                    _tprintf(_T("Registry "));
            }
            else {
                _tprintf(_T("0x%08x"), LoggerInfo->EnableFlags );
            }
            _tprintf(_T("\n"));
        }
        if (LogFileName == NULL || _tcslen(LogFileName) == 0) {
            _tprintf(_T("Log Filename:           default location\n"));
            _tprintf(_T("                        %%SystemRoot%%\\System32\\LogFiles\\WMI\\trace.log\n"));
        }
        else
            _tprintf(_T("Log Filename:           %s\n"), LogFileName);

        if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_LOCAL_SEQUENCE) {
            _tprintf(_T("Local Sequence numbers in use\n"));
        }
        else if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) {
            _tprintf(_T("Global Sequence numbers in use\n"));
        }
    }
    else {
// begin_sdk
        _tprintf(_T("Logger Id:              %I64x\n"), LoggerInfo->Wnode.HistoricalContext);
        _tprintf(_T("Logger Thread Id:       %p\n"), LoggerInfo->LoggerThreadId);
        if (Status != 0)
            return;

        _tprintf(_T("Buffer Size:            %d Kb"), LoggerInfo->BufferSize);
        if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_PAGED_MEMORY) {
            _tprintf(_T(" using paged memory\n"));
        }
        else {
            _tprintf(_T("\n"));
        }
        _tprintf(_T("Maximum Buffers:        %d\n"), LoggerInfo->MaximumBuffers);
        _tprintf(_T("Minimum Buffers:        %d\n"), LoggerInfo->MinimumBuffers);
        _tprintf(_T("Number of Buffers:      %d\n"), LoggerInfo->NumberOfBuffers);
        _tprintf(_T("Free Buffers:           %d\n"), LoggerInfo->FreeBuffers);
        _tprintf(_T("Buffers Written:        %d\n"), LoggerInfo->BuffersWritten);
        _tprintf(_T("Events Lost:            %d\n"), LoggerInfo->EventsLost);
        _tprintf(_T("Log Buffers Lost:       %d\n"), LoggerInfo->LogBuffersLost);
        _tprintf(_T("Real Time Buffers Lost: %d\n"), LoggerInfo->RealTimeBuffersLost);
        _tprintf(_T("AgeLimit:               %d\n"), LoggerInfo->AgeLimit);

        if (LogFileName == NULL) {
            _tprintf(_T("Buffering Mode:         "));
        }
        else {
            _tprintf(_T("Log File Mode:          "));
        }
        if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) {
            _tprintf(_T("Append  "));
        }
        if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
            _tprintf(_T("Circular\n"));
        }
        else if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
            _tprintf(_T("Sequential\n"));
        }
        else {
            _tprintf(_T("Sequential\n"));
        }
        if (LoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
            _tprintf(_T("Real Time mode enabled"));
// end_sdk
            if (LoggerInfo->LogFileMode & EVENT_TRACE_BUFFERING_MODE) {
                _tprintf(_T(": buffering only"));
            }
// begin_sdk
            _tprintf(_T("\n"));
        }

        if (LoggerInfo->MaximumFileSize > 0)
            _tprintf(_T("Maximum File Size:      %d Mb\n"), LoggerInfo->MaximumFileSize);

        if (LoggerInfo->FlushTimer > 0)
            _tprintf(_T("Buffer Flush Timer:     %d secs\n"), LoggerInfo->FlushTimer);

        if (LoggerInfo->EnableFlags != 0) {
            _tprintf(_T("Enabled tracing:        "));

            if ((LoggerName != NULL) && (!_tcscmp(LoggerName, KERNEL_LOGGER_NAME))) {

                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_PROCESS)
                    _tprintf(_T("Process "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_THREAD)
                    _tprintf(_T("Thread "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
                    _tprintf(_T("Disk "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
                    _tprintf(_T("File "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
                    _tprintf(_T("PageFaults "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
                    _tprintf(_T("HardFaults "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
                    _tprintf(_T("ImageLoad "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
                    _tprintf(_T("TcpIp "));
                if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_REGISTRY)
                    _tprintf(_T("Registry "));
            }else{
                _tprintf(_T("0x%08x"), LoggerInfo->EnableFlags );
            }
            _tprintf(_T("\n"));
        }
        if (LogFileName != NULL) {
            _tprintf(_T("Log Filename:           %s\n"), LogFileName);
        }
// end_sdk
        if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_LOCAL_SEQUENCE) {
            _tprintf(_T("Local Sequence numbers in use\n"));
        }
        else if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) {
            _tprintf(_T("Global Sequence numbers in use\n"));
        }
    }
// begin_sdk

}

LPTSTR
DecodeStatus(
    IN ULONG Status
    )
/*++

Routine Description:

    Decodes WIN32 error into a string in the default language.

Arguments:

    Status - The error status from the last executed command 
        or
        the operation status of the current logger.

Return Value:

    LPTSTR - String containing the decoded message.


--*/
{
    memset( ErrorMsg, 0, MAXSTR );
    FormatMessage(     
        FORMAT_MESSAGE_FROM_SYSTEM |     
        FORMAT_MESSAGE_IGNORE_INSERTS,    
        NULL,
        Status,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) ErrorMsg,
        MAXSTR,
        NULL );

    return ErrorMsg;
}

LONG
GetGuids(
    IN LPTSTR GuidFile, 
    IN OUT LPGUID *GuidArray
)
/*++

Routine Description:

    Reads GUIDs from a file and stores them in an GUID array.

Arguments:

    GuidFile - The file containing GUIDs. 
    GuidArray - The GUID array that will have GUIDs read from the file.

Return Value:

    ULONG - The number of GUIDs processed.


--*/
{
    FILE *f;
    TCHAR line[MAXSTR], arg[MAXSTR];
    LPGUID Guid;
    int i, n;

    f = _tfopen((TCHAR*)GuidFile, _T("r"));

    if (f == NULL)
        return -1;

    n = 0;
    while ( _fgetts(line, MAXSTR, f) != NULL ) {
        if (_tcslen(line) < 36)
            continue;
        if (line[0] == ';'  || 
            line[0] == '\0' || 
            line[0] == '#' || 
            line[0] == '/')
            continue;
        Guid = (LPGUID) GuidArray[n];
        n ++;

        _tcsncpy(arg, line, 8);
        arg[8] = 0;
        Guid->Data1 = ahextoi(arg);
        _tcsncpy(arg, &line[9], 4);
        arg[4] = 0;
        Guid->Data2 = (USHORT) ahextoi(arg);
        _tcsncpy(arg, &line[14], 4);
        arg[4] = 0;
        Guid->Data3 = (USHORT) ahextoi(arg);

        for (i=0; i<2; i++) {
            _tcsncpy(arg, &line[19 + (i*2)], 2);
            arg[2] = 0;
            Guid->Data4[i] = (UCHAR) ahextoi(arg);
        }
        for (i=2; i<8; i++) {
            _tcsncpy(arg, &line[20 + (i*2)], 2);
            arg[2] = 0;
            Guid->Data4[i] = (UCHAR) ahextoi(arg);
        }
    }
    return (ULONG)n;
}

ULONG 
ahextoi(
    IN TCHAR *s
    )
/*++

Routine Description:

    Converts a hex string into a number.

Arguments:

    s - A hex string in TCHAR. 

Return Value:

    ULONG - The number in the string.


--*/
{
    int len;
    ULONG num, base, hex;

    len = _tcslen(s);
    hex = 0; base = 1; num = 0;
    while (--len >= 0) {
        if ( (s[len] == 'x' || s[len] == 'X') &&
             (s[len-1] == '0') )
            break;
        if (s[len] >= '0' && s[len] <= '9')
            num = s[len] - '0';
        else if (s[len] >= 'a' && s[len] <= 'f')
            num = (s[len] - 'a') + 10;
        else if (s[len] >= 'A' && s[len] <= 'F')
            num = (s[len] - 'A') + 10;
        else 
            continue;

        hex += num * base;
        base = base * 16;
    }
    return hex;
}


void 
StringToGuid(
    IN TCHAR *str, 
    IN OUT LPGUID guid
)
/*++

Routine Description:

    Converts a string into a GUID.

Arguments:

    str - A string in TCHAR.
    guid - The pointer to a GUID that will have the converted GUID.

Return Value:

    None.


--*/
{
    TCHAR temp[10];
    int i, n;

    temp[8]=_T('\0');
    _tcsncpy(temp, str, 8);
    _stscanf(temp, _T("%x"), &(guid->Data1));

    temp[4]=_T('\0');
    _tcsncpy(temp, &str[9], 4);
    _stscanf(temp, _T("%x"), &(guid->Data2));

    _tcsncpy(temp, &str[14], 4);
    _stscanf(temp, _T("%x"), &(guid->Data3));

    temp[2]='\0';
    for(i=0;i<8;i++)
    {
        temp[0]=str[19+((i<2)?2*i:2*i+1)]; // to accomodate the minus sign after
        temp[1]=str[20+((i<2)?2*i:2*i+1)]; // the first two chars
        _stscanf(temp, _T("%x"), &n);      // if used more than byte alloc
        guid->Data4[i]=(unsigned char)n;   // causes overrun of memory
    }
}

void 
DisplayVersionInfo()
/*++

Routine Description:

    prints out a version information.

Arguments:

    None.

Return Value:

    None.


--*/
{
    TCHAR buffer[512];
    TCHAR strProgram[MAXSTR];
    DWORD dw;
    BYTE* pVersionInfo;
    LPTSTR pVersion = NULL;
    LPTSTR pProduct = NULL;
    LPTSTR pCopyRight = NULL;

    dw = GetModuleFileName(NULL, strProgram, MAXSTR);

    if( dw>0 ){

        dw = GetFileVersionInfoSize( strProgram, &dw );
        if( dw > 0 ){

            pVersionInfo = (BYTE*)malloc(dw);
            if( NULL != pVersionInfo ){
                if(GetFileVersionInfo( strProgram, 0, dw, pVersionInfo )){
                    LPDWORD lptr = NULL;
                    VerQueryValue( pVersionInfo, _T("\\VarFileInfo\\Translation"), (void**)&lptr, (UINT*)&dw );
                    if( lptr != NULL ){
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("ProductVersion") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pVersion, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("OriginalFilename") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pProduct, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("LegalCopyright") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pCopyRight, (UINT*)&dw );
                    }
                
                    if( pProduct != NULL && pVersion != NULL && pCopyRight != NULL ){
                        _tprintf( _T("\nMicrosoft (R) %s (%s)\n%s\n\n"), pProduct, pVersion, pCopyRight );
                    }
                }
                free( pVersionInfo );
            }
        }
    }
}

void PrintHelpMessage()
/*++

Routine Description:

    prints out a help message.

Arguments:

    None.

Return Value:

    None.


--*/
{
// end_sdk
    DisplayVersionInfo();
// begin_sdk
    _tprintf(_T("Usage: tracelog [actions] [options] | [-h | -help | -?]\n"));
    _tprintf(_T("\n    actions:\n"));
    _tprintf(_T("\t-start   [LoggerName] Starts up the [LoggerName] trace session\n"));
    _tprintf(_T("\t-stop    [LoggerName] Stops the [LoggerName] trace session\n"));
    _tprintf(_T("\t-update  [LoggerName] Updates the [LoggerName] trace session\n"));
    _tprintf(_T("\t-enable  [LoggerName] Enables providers for the [LoggerName] session\n"));
    _tprintf(_T("\t-disable [LoggerName] Disables providers for the [LoggerName] session\n"));
    if (Whistler)
        _tprintf(_T("\t-flush   [LoggerName] Flushes the [LoggerName] active buffers\n"));
// end_sdk
    _tprintf(_T("\t-remove  GlobalLogger Removes registry keys that activate GlobalLogger\n"));
// begin_sdk
    if (Whistler)
        _tprintf(_T("\t-enumguid             Enumerate Registered Trace Guids\n"));
    _tprintf(_T("\t-q       [LoggerName] Query status of [LoggerName] trace session\n"));
    _tprintf(_T("\t-l                    List all trace sessions\n"));
    _tprintf(_T("\t-x                    Stops all active trace sessions\n"));

    _tprintf(_T("\n    options:\n"));
    _tprintf(_T("\t-b   <n>              Sets buffer size to <n> Kbytes\n"));
    _tprintf(_T("\t-min <n>              Sets minimum buffers\n"));
    _tprintf(_T("\t-max <n>              Sets maximum buffers\n"));
    _tprintf(_T("\t-f <name>             Log to file <name>\n"));
    if (Whistler) {
        _tprintf(_T("\t-append               Append to file\n"));
        _tprintf(_T("\t-prealloc             Pre-allocate\n"));
    }
    _tprintf(_T("\t-seq <n>              Sequential logfile of up to n Mbytes\n"));
    _tprintf(_T("\t-cir <n>              Circular logfile of n Mbytes\n"));
    if (Whistler)
        _tprintf(_T("\t-newfile <n>          Log to a new file after every n Mbytes\n"));
    _tprintf(_T("\t-ft <n>               Set flush timer to n seconds\n"));
    if (Whistler)
        _tprintf(_T("\t-paged                Use pageable memory for buffers\n"));
    _tprintf(_T("\t-noprocess            Disable Process Start/End tracing\n"));
    _tprintf(_T("\t-nothread             Disable Thread Start/End tracing\n"));
    _tprintf(_T("\t-nodisk               Disable Disk I/O tracing\n"));
    _tprintf(_T("\t-nonet                Disable Network TCP/IP tracing\n"));
    _tprintf(_T("\t-fio                  Enable file I/O tracing\n"));
    _tprintf(_T("\t-pf                   Enable page faults tracing\n"));
    _tprintf(_T("\t-hf                   Enable hard faults tracing\n"));
    _tprintf(_T("\t-img                  Enable image load tracing\n"));
    _tprintf(_T("\t-cm                   Enable registry calls tracing\n"));
    _tprintf(_T("\t-um                   Enable Process Private tracing\n"));
    _tprintf(_T("\t-guid <file>          Start tracing for providers in file\n"));
    _tprintf(_T("\t-rt                   Enable tracing in real time mode\n"));
    _tprintf(_T("\t-age <n>              Modify aging decay time to n minutes\n"));
    _tprintf(_T("\t-level <n>            Enable Level passed to the providers\n"));
    _tprintf(_T("\t-flag <n>             Enable Flags passed to the providers\n"));
// end_sdk
    if (Whistler) {
        _tprintf(_T("\t-eflag <n> <flag...>  Enable flags (several) to providers\n"));
        _tprintf(_T("\t-ls                   Generate Local Sequence Numbers\n"));
        _tprintf(_T("\t-gs                   Generate Global Squence Numbers\n"));
        _tprintf(_T("\t-pids <n> <pid1 pid2 ... >\n"));
        _tprintf(_T("\t                      Tracing for Heap and Crit Sect for different process\n"));
    }
// begin_sdk
    _tprintf(_T("\n"));
    _tprintf(_T("\t-h\n"));
    _tprintf(_T("\t-help\n"));
    _tprintf(_T("\t-?                    Display usage information\n"));
}


PTCHAR 
GuidToString(
    IN OUT PTCHAR s,
    LPGUID piid
    )
/*++

Routine Description:

    Converts a GUID into a string.

Arguments:

    s - A string in TCHAR that will have the converted GUID.
    piid - The pointer to a GUID.

Return Value:

    PTCHAR - The string containig the convereted GUID.


--*/
{
    _stprintf(s, _T("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"),
               piid->Data1, piid->Data2,
               piid->Data3,
               piid->Data4[0], piid->Data4[1],
               piid->Data4[2], piid->Data4[3],
               piid->Data4[4], piid->Data4[5],
               piid->Data4[6], piid->Data4[7]);
    return(s);
}

// end_sdk
LPCWSTR cszGlobalLoggerKey = L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\WMI\\GlobalLogger";
LPCWSTR cszStartValue = L"Start";
LPCWSTR cszBufferSizeValue = L"BufferSize";
LPCWSTR cszMaximumBufferValue = L"MaximumBuffers";
LPCWSTR cszMinimumBufferValue = L"MinimumBuffers";
LPCWSTR cszFlushTimerValue = L"FlushTimer";
LPCWSTR cszFileNameValue = L"FileName";
LPCWSTR cszEnableKernelValue = L"EnableKernelFlags";
LPCWSTR cszClockTypeValue = L"ClockType";

//
// GlobalLogger functions
// 
ULONG
SetGlobalLoggerSettings(
    IN DWORD StartValue,
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
    IN DWORD ClockType
)
/*++

Since it is a standalone utility, there is no need for extensive comments. 

Routine Description:

    Depending on the value given in "StartValue", it sets or resets event
    trace registry. If the StartValue is 0 (Global logger off), it deletes
    all the keys (that the user may have set previsouly).
    
    Users are allowed to set or reset individual keys using this function,
    but only when "-start GlobalLogger" is used.

    The section that uses non NTAPIs is not guaranteed to work.

Arguments:

    StartValue - The "Start" value to be set in the registry.
                    0: Global logger off
                    1: Global logger on
    LoggerInfo - The poniter to the resident EVENT_TRACE_PROPERTIES instance.
                whose members are used to set registry keys.

    ClockType - The type of the clock to be set.

Return Value:

    Error Code defined in winerror.h : If the function succeeds, 
                it returns ERROR_SUCCESS.


--*/
{

    DWORD  dwValue;
    NTSTATUS status;
    HANDLE KeyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeLoggerKey, UnicodeString;
    ULONG Disposition, TitleIndex;

    RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    RtlInitUnicodeString((&UnicodeLoggerKey),(cszGlobalLoggerKey));
    InitializeObjectAttributes( 
        &ObjectAttributes,
        &UnicodeLoggerKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL 
        );

    // instead of opening, create a new key because it may not exist.
    // if one exists already, that handle will be passed.
    // if none exists, it will create one.
    status = NtCreateKey(&KeyHandle,
                         KEY_QUERY_VALUE | KEY_SET_VALUE,
                         &ObjectAttributes,
                         0L,    // not used within this call anyway.
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         &Disposition);
    RtlFreeUnicodeString(&UnicodeLoggerKey);

    if(!NT_SUCCESS(status)) {
        return RtlNtStatusToDosError(status);
    }

    TitleIndex = 0L;


    if (StartValue == 1) { // ACTION_START: set filename only when it is given by a user.
        // setting BufferSize
        if (LoggerInfo->BufferSize > 0) {
            dwValue = LoggerInfo->BufferSize;
            RtlInitUnicodeString((&UnicodeString),(cszBufferSizeValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting MaximumBuffers
        if (LoggerInfo->MaximumBuffers > 0) {
            dwValue = LoggerInfo->MaximumBuffers;
            RtlInitUnicodeString((&UnicodeString),(cszMaximumBufferValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting MinimumBuffers 
        if (LoggerInfo->MinimumBuffers > 0) {
            dwValue = LoggerInfo->MinimumBuffers;
            RtlInitUnicodeString((&UnicodeString),(cszMinimumBufferValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting FlushTimer
        if (LoggerInfo->FlushTimer > 0) {
            dwValue = LoggerInfo->FlushTimer;
            RtlInitUnicodeString((&UnicodeString),(cszFlushTimerValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
        // setting EnableFlags
        if (LoggerInfo->EnableFlags > 0) {
            dwValue = LoggerInfo->EnableFlags;
            RtlInitUnicodeString((&UnicodeString),(cszEnableKernelValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(dwValue)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }

        dwValue = 0;
        if (LoggerInfo->LogFileNameOffset > 0) {
            UNICODE_STRING UnicodeFileName;
#ifndef UNICODE
            WCHAR TempString[MAXSTR];
            MultiByteToWideChar(CP_ACP,
                                0,
                                (PCHAR)(LoggerInfo->LogFileNameOffset + (PCHAR) LoggerInfo),
                                strlen((PCHAR)(LoggerInfo->LogFileNameOffset + (PCHAR) LoggerInfo)),
                                TempString,
                                MAXSTR
                                );
            RtlInitUnicodeString((&UnicodeFileName), TempString);
#else
            RtlInitUnicodeString((&UnicodeFileName), (PWCHAR)(LoggerInfo->LogFileNameOffset + (PCHAR) LoggerInfo));
#endif
            RtlInitUnicodeString((&UnicodeString),(cszFileNameValue));
            status = NtSetValueKey(
                        KeyHandle,
                        &UnicodeString,
                        TitleIndex,
                        REG_SZ,
                        UnicodeFileName.Buffer,
                        UnicodeFileName.Length + sizeof(UNICODE_NULL)
                        );
            RtlFreeUnicodeString(&UnicodeString);
            RtlFreeUnicodeString(&UnicodeFileName);
            if (!NT_SUCCESS(status)) {
                NtClose(KeyHandle);
                return RtlNtStatusToDosError(status);
            }
            TitleIndex++;
        }
    }
    else { // if ACTION_STOP then delete the keys that users might have set previously.
        // delete buffer size
        RtlInitUnicodeString((&UnicodeString),(cszBufferSizeValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete maximum buffers
        RtlInitUnicodeString((&UnicodeString),(cszMaximumBufferValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete minimum buffers
        RtlInitUnicodeString((&UnicodeString),(cszMinimumBufferValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete flush timer
        RtlInitUnicodeString((&UnicodeString),(cszFlushTimerValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete enable falg
        RtlInitUnicodeString((&UnicodeString),(cszEnableKernelValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        // delete filename
        RtlInitUnicodeString((&UnicodeString),(cszFileNameValue));
        status = NtDeleteValueKey(
                    KeyHandle,
                    &UnicodeString
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
    }

    // setting ClockType
    if (ClockType > 0) {
        dwValue = ClockType;
        RtlInitUnicodeString((&UnicodeString),(cszClockTypeValue));
        status = NtSetValueKey(
                    KeyHandle,
                    &UnicodeString,
                    TitleIndex,
                    REG_DWORD,
                    (LPBYTE)&dwValue,
                    sizeof(dwValue)
                    );
        RtlFreeUnicodeString(&UnicodeString);
        if (!NT_SUCCESS(status)) {
            NtClose(KeyHandle);
            return RtlNtStatusToDosError(status);
        }
        TitleIndex++;
    }

     // Setting StartValue
    dwValue = StartValue;
    RtlInitUnicodeString((&UnicodeString),(cszStartValue));
    status = NtSetValueKey(
                KeyHandle,
                &UnicodeString,
                TitleIndex,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue)
                );
    RtlFreeUnicodeString(&UnicodeString);
    if (!NT_SUCCESS(status)) {
        NtClose(KeyHandle);
        return RtlNtStatusToDosError(status);
    }
    TitleIndex++;

    NtClose(KeyHandle);
    return 0;
}

ULONG
GetGlobalLoggerSettings(
    IN OUT PEVENT_TRACE_PROPERTIES LoggerInfo,
    OUT PULONG ClockType,
    OUT PDWORD pdwStart
)
/*++

Routine Description:

    It reads registry for golbal logger and updates LoggerInfo. It uses 
    NtEnumerateValueKey() to retrieve the values of the required subkeys.

    The section that uses non NTAPIs is not guaranteed to work.

Arguments:

    LoggerInfo - The poniter to the resident EVENT_TRACE_PROPERTIES instance.
                whose members are updated as the result.

    ClockType - The type of the clock to be updated.
    pdwStart - The "Start" value of currently retained in the registry.

Return Value:

    WINERROR - Error Code defined in winerror.h. If the function succeeds, 
                it returns ERROR_SUCCESS.


--*/
{

    ULONG i, j;
    NTSTATUS status;
    HANDLE KeyHandle;
    WCHAR SubKeyName[MAXSTR];
    PVOID Buffer;
    ULONG BufferLength, RequiredLength, KeyNameLength, KeyDataOffset, KeyDataLength;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeLoggerKey;

    *pdwStart = 0;

    RtlInitUnicodeString((&UnicodeLoggerKey),(cszGlobalLoggerKey));
    RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes( 
        &ObjectAttributes,
        &UnicodeLoggerKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL 
        );
    status = NtOpenKey(
                &KeyHandle,
                KEY_QUERY_VALUE | KEY_SET_VALUE,
                &ObjectAttributes
                );
    RtlFreeUnicodeString(&UnicodeLoggerKey);

    if(!NT_SUCCESS(status)) 
        return RtlNtStatusToDosError(status);

    // KEY_VALUE_FULL_INFORMATION + name (1 WSTR) + data.
    BufferLength = sizeof(KEY_VALUE_FULL_INFORMATION) + 2 * MAXSTR * sizeof(TCHAR);
    Buffer = (PVOID) malloc(BufferLength);
    if (Buffer == NULL) {
        NtClose(KeyHandle);
        return (ERROR_OUTOFMEMORY);
    }

    i = 0;
    do {
        // Using Key Enumeration
        status = NtEnumerateValueKey(
                    KeyHandle,
                    i++,
                    KeyValueFullInformation,
                    Buffer,
                    BufferLength,
                    &RequiredLength
                    );


        if (!NT_SUCCESS(status)) {
            if (status == STATUS_NO_MORE_ENTRIES)
                break;
            else if (status == STATUS_BUFFER_OVERFLOW) {
                Buffer = realloc(Buffer, RequiredLength);
                if (Buffer == NULL) {
                    NtClose(KeyHandle);
                    return (ERROR_OUTOFMEMORY);
                }

                status = NtEnumerateValueKey(
                            KeyHandle,
                            i++,
                            KeyValueFullInformation,
                            Buffer,
                            BufferLength,
                            &RequiredLength
                            );
                if (!NT_SUCCESS(status)) {
                    NtClose(KeyHandle);
                    free(Buffer);
                    return RtlNtStatusToDosError(status);
                }
            }
            else {
                NtClose(KeyHandle);
                free(Buffer);
                return RtlNtStatusToDosError(status);
            }
        }
        KeyNameLength = ((PKEY_VALUE_FULL_INFORMATION)Buffer)->NameLength;
        RtlCopyMemory(SubKeyName, 
            (PUCHAR)(((PKEY_VALUE_FULL_INFORMATION)Buffer)->Name), 
            KeyNameLength
            );
        KeyNameLength /= sizeof(WCHAR);
        SubKeyName[KeyNameLength] = L'\0';
        KeyDataOffset = ((PKEY_VALUE_FULL_INFORMATION)Buffer)->DataOffset;
        KeyDataLength = ((PKEY_VALUE_FULL_INFORMATION)Buffer)->DataLength;
        // Find out what the key is
        if (!_wcsicmp(SubKeyName, cszStartValue)) { //StartValue
            RtlCopyMemory(pdwStart, 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszBufferSizeValue)) { // BufferSizeValue
            RtlCopyMemory(&(LoggerInfo->BufferSize), 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszMaximumBufferValue)) { // MaximumBufferValue
            RtlCopyMemory(&(LoggerInfo->MaximumBuffers), 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszMinimumBufferValue)) { // MinimumBuffers
            RtlCopyMemory(&(LoggerInfo->MinimumBuffers), 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszFlushTimerValue)) { // FlushTimer
            RtlCopyMemory(&(LoggerInfo->FlushTimer), 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszEnableKernelValue)) { // EnableKernelValue
            RtlCopyMemory(&(LoggerInfo->EnableFlags), 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszClockTypeValue)) { // ClockTypeValue
            RtlCopyMemory(ClockType, 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
        }
        else if (!_wcsicmp(SubKeyName, cszFileNameValue)) { // FileName
#ifndef UNICODE
            WCHAR TempString[MAXSTR];
            RtlCopyMemory(TempString, (PUCHAR)Buffer + KeyDataOffset, KeyDataLength);
            WideCharToMultiByte(CP_ACP, 
                                0, 
                                TempString, 
                                wcslen(TempString), 
                                (PUCHAR)LoggerInfo + LoggerInfo->LogFileNameOffset,
                                KeyDataLength, 
                                NULL, 
                                NULL);
#else
            RtlCopyMemory((PUCHAR)LoggerInfo + LoggerInfo->LogFileNameOffset, 
                (PUCHAR)Buffer + KeyDataOffset,
                KeyDataLength);
#endif
        }
        else { // Some other keys are in there
            _tprintf(_T("Warning: Unidentified Key in the trace registry: %s\n"), SubKeyName);
        }
        
    }
    while (1);

    NtClose(KeyHandle);
    free(Buffer);
    return 0; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\traceprt\traceint.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    traceint.h

Abstract:

    Trace formatting internal definitions.

Revision History:

--*/
#ifdef __cplusplus
extern "C"{
#endif
 
#ifndef _TRACEINT_
#define _TRACEINT_

#define MAXLOGFILES    16
#define MAXSTR       1024
#define MAXFORMAT    1024
#define MAXTYPE       256
#define MAXGUIDS      128
#define UC(x)        ((UINT)((x) & 0xFF))
#define NTOHS(x)     ((UC(x) * 256) + UC((x) >> 8))

#ifndef IsEqualGUID
#define IsEqualGUID(guid1, guid2) \
                (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

#define GUID_TYPE_HEADER    _T("Header")
#define GUID_TYPE_UNKNOWN   _T("Unknown")
    
#define STR_ItemChar        _T("ItemChar")
#define STR_ItemUChar       _T("ItemUChar")
#define STR_ItemCharShort   _T("ItemCharShort")
#define STR_ItemCharSign    _T("ItemCharSign")
#define STR_ItemDouble      _T("ItemDouble")
#define STR_ItemShort       _T("ItemShort")
#define STR_ItemUShort      _T("ItemUShort")
#define STR_ItemLong        _T("ItemLong")
#define STR_ItemULong       _T("ItemULong")
#define STR_ItemULongX      _T("ItemULongX")
#define STR_ItemLongLong    _T("ItemLongLong")
#define STR_ItemULongLong   _T("ItemULongLong")
#define STR_ItemString      _T("ItemString")
#define STR_ItemWString     _T("ItemWString")
#define STR_ItemRString     _T("ItemRString")
#define STR_ItemRWString    _T("ItemRWString")
#define STR_ItemPString     _T("ItemPString")
#define STR_ItemPWString    _T("ItemPWString")
#define STR_ItemMLString    _T("ItemMLString")
#define STR_ItemNWString    _T("ItemNWString")
#define STR_ItemPtr         _T("ItemPtr")
#define STR_ItemDSString    _T("ItemDSString")
#define STR_ItemDSWString   _T("ItemDSWString")
#define STR_ItemSid         _T("ItemSid")
#define STR_ItemChar4       _T("ItemChar4")
#define STR_ItemIPAddr      _T("ItemIPAddr")
#define STR_ItemPort        _T("ItemPort")
#define STR_ItemNWString    _T("ItemNWString")
#define STR_ItemListLong    _T("ItemListLong")
#define STR_ItemListShort   _T("ItemListShort")
#define STR_ItemListByte    _T("ItemListByte")
#define STR_ItemNTerror     _T("ItemNTerror")
#define STR_ItemMerror      _T("ItemMerror")
#define STR_ItemTimestamp   _T("ItemTimestamp")
#define STR_ItemHRESULT     _T("ItemHRESULT")
#define STR_ItemNTSTATUS    _T("ItemNTSTATUS")
#define STR_ItemWINERROR    _T("ItemWINERROR")
#define STR_ItemNETEVENT    _T("ItemNETEVENT")
#define STR_ItemGuid        _T("ItemGuid")
#define STR_ItemWaitTime    _T("ItemWaitTime")
#define STR_ItemTimeDelta   _T("ItemTimeDelta")
#define STR_ItemSetLong    _T("ItemSetLong")
#define STR_ItemSetShort   _T("ItemSetShort")
#define STR_ItemSetByte    _T("ItemSetByte")
#define STR_ItemCharHidden    _T("ItemCharHidden")

typedef struct _MOF_INFO
{
    LIST_ENTRY   Entry;
    LPTSTR       strDescription;        // Class Name
    ULONG        EventCount;            
    GUID         Guid;
    PLIST_ENTRY  ItemHeader;            
    LPTSTR       strType;
    LONG         TypeIndex;
    ULONG        TypeOfType;
    LPTSTR       TypeFormat;
    INT          Indent;
}  MOF_INFO, *PMOF_INFO;

typedef struct _MOF_TYPE
{
    TCHAR     strType[MAXSTR];
    LONG      TypeIndex;
    ULONG     TypeType;
    TCHAR     TypeFormat[MAXFORMAT];
} MOF_TYPE, *PMOF_TYPE;

typedef enum _ITEM_TYPE
{
    ItemChar,
    ItemUChar,
    ItemCharShort,
    ItemCharSign,
    ItemShort,
    ItemUShort,
    ItemLong,
    ItemULong,
    ItemULongX,
    ItemLongLong,
    ItemULongLong,
    ItemString,
    ItemWString,
    ItemRString,
    ItemRWString,
    ItemPString,
    ItemPWString,
    ItemDSString,
    ItemDSWString,
    ItemSid,
    ItemChar4,
    ItemIPAddr,
    ItemPort,
    ItemMLString,
    ItemNWString,        // Non-null terminated Wide Char String
    ItemPtr,
    ItemListLong,        // Sort of Enumerated List, field is a long
    ItemListShort,       // Sort of Enumerated List, field is a Short
    ItemListByte,        // Sort of Enumerated List, field is a Byte
	ItemNTerror,		 // Convert an NT error number to the usual error string
	ItemMerror,			 // Convert an error number to a module message
	ItemTimestamp,		 // Convert a LongLong to a timestamp string
    ItemGuid,            // convert a GUID to the usual string
	ItemNTSTATUS,
	ItemWINERROR,
	ItemNETEVENT,
    ItemWaitTime,
    ItemTimeDelta,
    ItemSetLong,     
    ItemSetShort,    
    ItemSetByte,     
    ItemDouble,
    ItemHRESULT,
    ItemCharHidden,     //Just a block of chars ( name from ETW)
    ItemUnknown
} ITEM_TYPE;

typedef struct _ITEM_DESC *PITEM_DESC;
typedef struct _ITEM_DESC
{
    LIST_ENTRY Entry;
    LPTSTR     strDescription;
    ULONG      DataSize;
    LPTSTR     ItemList;
    ITEM_TYPE  ItemType;
} ITEM_DESC;

//
// Now the routines we export
//
#ifndef TRACE_API
#ifdef TRACE_EXPORTS
#define TRACE_API __declspec(dllexport)
#else
#define TRACE_API __declspec(dllimport)
#endif
#endif

TRACE_API void
MapGuidToName(
        OUT PLIST_ENTRY * HeadEventList,
        IN  LPGUID      pGuid,
        IN  ULONG       nType,
        OUT LPTSTR      wstr
        );

TRACE_API ULONG
UserDefinedGuid(
        OUT PLIST_ENTRY HeadEventList,
        IN  LPGUID      Guid,
        OUT LPTSTR      wstr
        );

TRACE_API VOID
AddMofInfo(
        PLIST_ENTRY   HeadEventList,
        const GUID  * Guid,
        LPTSTR        strType,
        ULONG         typeIndex,
        LPTSTR        strDesc,
        ITEM_TYPE     ItemType,
        TCHAR       * ItemList,
        ULONG         TypeOfType,
        LPTSTR        strFormat
        );
// the following segment is used to impose our own formatting via a copy of RtlTraceFormat,
// but which fixes up selected formats that we cannot handle correctly.
#define STRINGFIXUP 1       // This conditional is used to identify the differences
NTSTATUS
TraceFormatMessage(
    IN PWSTR MessageFormat,
    IN ULONG MaximumWidth OPTIONAL,
    IN BOOLEAN IgnoreInserts,
    IN BOOLEAN ArgumentsAreAnsi,
    IN BOOLEAN ArgumentsAreAnArray,
    IN va_list *Arguments,
    OUT PWSTR Buffer,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );

#endif  // #ifndef _TRACEINT_

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracerpt\tracerpt.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    tracerpt.c

Abstract:

    Event Trace Reporting Tool

Author:

    08-Apr-1998 Melur Raghuraman

Revision History:

--*/

#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>

#include "tracectr.h"
#include "resource.h"
#include "varg.c"

#define GROUP_SRC   0x01

VARG_DECLARE_COMMANDS
    VARG_DEBUG ( VARG_FLAG_OPTIONAL|VARG_FLAG_HIDDEN )
    VARG_HELP  ( VARG_FLAG_OPTIONAL )
    VARG_MSZ   ( IDS_PARAM_LOGFILE,     VARG_FLAG_NOFLAG|VARG_FLAG_EXPANDFILES|VARG_FLAG_ARG_FILENAME, NULL )
    VARG_STR   ( IDS_PARAM_DUMPFILE,    VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_DEFAULTABLE|VARG_FLAG_RCDEFAULT, IDS_DEFAULT_DUMP )
    VARG_STR   ( IDS_PARAM_SUMMARY,     VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_DEFAULTABLE|VARG_FLAG_RCDEFAULT, IDS_DEFAULT_SUMMARY )
    VARG_STR   ( IDS_PARAM_MOFFILE,     VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_HIDDEN|VARG_FLAG_DEFAULTABLE, NULL )
    VARG_STR   ( IDS_PARAM_REPORTFILE,  VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_DEFAULTABLE|VARG_FLAG_RCDEFAULT, IDS_DEFAULT_REPORT )
    VARG_MSZ   ( IDS_PARAM_LOGGERNAME,  0, NULL )
    VARG_INI   ( IDS_PARAM_SETTINGS,    VARG_FLAG_OPTIONAL, NULL )
    VARG_BOOL  ( IDS_PARAM_EXFMT,       VARG_FLAG_OPTIONAL|VARG_FLAG_HIDDEN, FALSE )
    VARG_STR   ( IDS_PARAM_MERGE,       VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_DEFAULTABLE|VARG_FLAG_RCDEFAULT|VARG_FLAG_HIDDEN, IDS_DEFAULT_MERGED )
    VARG_STR   ( IDS_PARAM_COMP,        VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_HIDDEN|VARG_FLAG_RCDEFAULT|VARG_FLAG_DEFAULTABLE, IDS_DEFAULT_COMP )
    VARG_BOOL  ( IDS_PARAM_YES,         VARG_FLAG_OPTIONAL, FALSE )
VARG_DECLARE_NAMES
    eDebug,
    eHelp,
    eLogFile,
    eDump,
    eSummary,
    eMofFile,
    eReport,
    eRealTime,
    eConfig,
    eExFormat,
    eMerge,
    eInterpret,
    eYes,
VARG_DECLARE_FORMAT
    VARG_GROUP( eLogFile,  VARG_EXCL(GROUP_SRC)|VARG_COND(GROUP_SRC) )
    VARG_GROUP( eRealTime, VARG_EXCL(GROUP_SRC)|VARG_COND(GROUP_SRC) )
    VARG_EXHELP( eDump,         IDS_EXAMPLE_DUMPFILE)
    VARG_EXHELP( eSummary,      IDS_EXAMPLE_SUMMARY )
    VARG_EXHELP( eRealTime,     IDS_EXAMPLE_REALTIME)
VARG_DECLARE_END

#define MAXLOGFILES         32
#define MAX_BUFFER_SIZE     1048576
#define CHECK_HR( hr )      if( ERROR_SUCCESS != hr ){ goto cleanup; }

int __cdecl _tmain (int argc, LPTSTR* argv)
{
    LPTSTR* EvmFile = NULL;    // List Of LogFiles To Process
    LPTSTR* Loggers = NULL;    // List of Loggers to process

    ULONG LogFileCount = 0;
    ULONG LoggerCount = 0;
    TCHAR strEventDef[MAXSTR];
    TCHAR strDefinitionFile[MAXSTR] = _T("");
    DWORD dwCheckFileFlag = 0;
    HRESULT hr = ERROR_SUCCESS;

    TRACE_BASIC_INFO TraceBasicInfo;
    //
    //  Parse the Command line arguments
    // 
   
    ParseCmd( argc, argv );
    EvmFile = (LPTSTR*)VARG_ALLOC( GetMaxLoggers() * sizeof(LPTSTR) );
    if( NULL == EvmFile ){
        hr = ERROR_OUTOFMEMORY;
        goto cleanup;
    }
    Loggers = (LPTSTR*)VARG_ALLOC( GetMaxLoggers() * sizeof(LPTSTR) );
    if( NULL == Loggers ){
        hr = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    memset(&TraceBasicInfo, 0, sizeof(TRACE_BASIC_INFO));
    
    PrintMessage( g_normal, IDS_MESSAGE_INPUT );

    if( Commands[eRealTime].bDefined && Commands[eRealTime].strValue != NULL ) {
                
        LPTSTR strLogger = Commands[eRealTime].strValue;
        PrintMessage( g_normal, IDS_MESSAGE_LOGGERS );

        while( *strLogger != _T('\0') ){

            Loggers[LoggerCount] = strLogger;
            LoggerCount++;
            
            varg_printf( g_normal, _T("     %1!s!\n"), strLogger );

            strLogger += (_tcslen(strLogger)+1);
        }
    
        varg_printf( g_normal, _T("\n") );
    }
 
    if( Commands[eLogFile].bDefined && Commands[eLogFile].strValue != NULL ) {

        LPTSTR strLogger = Commands[eLogFile].strValue;
        PrintMessage( g_normal, IDS_MESSAGE_FILES );

        while( *strLogger != '\0' ){
            EvmFile[LogFileCount] = strLogger;
            LogFileCount++;
            hr = CheckFile(strLogger, VARG_CF_EXISTS);
            CHECK_HR( hr );

            varg_printf( g_normal, _T("     %1!s!\n"), strLogger );
            strLogger += (_tcslen(strLogger)+1);
        }

        varg_printf( g_normal, _T("\n") );
    }
 
    
    if( Commands[eMofFile].bDefined && Commands[eMofFile].strValue != NULL ) {
        TraceBasicInfo.MofFileName = Commands[eMofFile].strValue;
        _tcscpy( strEventDef, Commands[eMofFile].strValue );
    }else if( Commands[eMofFile].bDefined && Commands[eMofFile].strValue == NULL ){
        FILE* f;
        hr = GetTempName( strDefinitionFile, MAXSTR );
        CHECK_HR( hr );

        LoadString( NULL, IDS_MESSAGE_DFLTSRC, strEventDef, MAXSTR );
        TraceBasicInfo.MofFileName = strDefinitionFile;

        f = _tfopen( strDefinitionFile, _T("w") );
        if( f ){
            HRSRC hRes;
            HGLOBAL hResData;
            LPSTR buffer = NULL;
            hRes = FindResource( NULL, _T("MOFFILE"), RT_HTML );
            if( hRes != NULL ){
                hResData = LoadResource( NULL, hRes );
                buffer = (LPSTR)LockResource(hResData);
                if( buffer != NULL ){
                    fprintf( f, "\n%s\n", buffer );
                }
            }
            fclose(f);
        }else{
            hr = GetLastError();
            goto cleanup;
        }
    }else{
        TraceBasicInfo.Flags |= TRACE_USE_WBEM;
        *strEventDef = _T('\0');
    }
    
    dwCheckFileFlag = Commands[eYes].bValue ? VARG_CF_OVERWRITE : (VARG_CF_PROMPT|VARG_CF_OVERWRITE);

    if( Commands[eMerge].bDefined ){
        TraceBasicInfo.Flags |= TRACE_MERGE_ETL;
        TraceBasicInfo.MergeFileName = Commands[eMerge].strValue;
    }else if ( _tcslen( strEventDef ) ){
        PrintMessage( g_normal, IDS_MESSAGE_DEFINE, strEventDef );
    }

    if( Commands[eInterpret].bDefined ) {
        TraceBasicInfo.Flags |= TRACE_INTERPRET;
        TraceBasicInfo.CompFileName = Commands[eInterpret].strValue;
        hr = CheckFile( Commands[eInterpret].strValue, dwCheckFileFlag );
        CHECK_HR(hr);

    }
    if( Commands[eReport].bDefined ) {
        TraceBasicInfo.Flags |= TRACE_REDUCE;
        TraceBasicInfo.ProcFileName = Commands[eReport].strValue;
        hr = CheckFile( Commands[eReport].strValue, dwCheckFileFlag );
        CHECK_HR(hr);
    }
    if( Commands[eExFormat].bValue ){
        TraceBasicInfo.Flags |= TRACE_EXTENDED_FMT;
    }
    if( Commands[eDump].bDefined ){
        TraceBasicInfo.Flags |= TRACE_DUMP;
        TraceBasicInfo.DumpFileName = Commands[eDump].strValue;
        hr = CheckFile( Commands[eDump].strValue, dwCheckFileFlag );
        CHECK_HR(hr);
    }
    if( Commands[eSummary].bDefined ) {
        TraceBasicInfo.Flags |= TRACE_SUMMARY;
        TraceBasicInfo.SummaryFileName = Commands[eSummary].strValue;
        hr = CheckFile( Commands[eSummary].strValue, dwCheckFileFlag );
        CHECK_HR(hr);
    }

    //
    // Make dump & summary the default
    //
    if( !(TraceBasicInfo.Flags & (TRACE_DUMP|TRACE_REDUCE|TRACE_MERGE_ETL|TRACE_SUMMARY) ) ) {  
        TraceBasicInfo.Flags |= (TRACE_DUMP|TRACE_SUMMARY);
        TraceBasicInfo.DumpFileName = Commands[eDump].strValue;
        TraceBasicInfo.SummaryFileName = Commands[eSummary].strValue;

        hr = CheckFile( Commands[eDump].strValue, dwCheckFileFlag );
        CHECK_HR(hr);

        hr = CheckFile( Commands[eSummary].strValue, dwCheckFileFlag );
        CHECK_HR(hr);
    }

    TraceBasicInfo.LogFileName  = EvmFile;
    TraceBasicInfo.LogFileCount = LogFileCount;
    TraceBasicInfo.LoggerName   = Loggers;
    TraceBasicInfo.LoggerCount  = LoggerCount;

    hr = InitTraceContext(&TraceBasicInfo);
    CHECK_HR( hr );

    PrintMessage( g_normal, IDS_MESSAGE_OUTPUT );
    if( TraceBasicInfo.Flags & TRACE_DUMP ){
        PrintMessage( g_normal, IDS_MESSAGE_CSVFILE, TraceBasicInfo.DumpFileName );
    }
    if( TraceBasicInfo.Flags & TRACE_SUMMARY ){
        PrintMessage( g_normal, IDS_MESSAGE_SUMMARY, TraceBasicInfo.SummaryFileName );
    }
    if( TraceBasicInfo.Flags & TRACE_REDUCE ){
        PrintMessage( g_normal, IDS_MESSAGE_REPORT, TraceBasicInfo.ProcFileName );
    }
    if( TraceBasicInfo.Flags & TRACE_MERGE_ETL ){
        PrintMessage( g_normal, IDS_MESSAGE_MERGED, TraceBasicInfo.MergeFileName );
    }
    if( TraceBasicInfo.Flags & TRACE_INTERPRET ){
        PrintMessage( g_normal, IDS_MESSAGE_COMP, TraceBasicInfo.CompFileName );
    }

    hr = DeinitTraceContext(&TraceBasicInfo);
    CHECK_HR( hr );


cleanup:
    
    VARG_FREE( Loggers );
    VARG_FREE( EvmFile );

    if( _tcslen( strDefinitionFile ) ){
        DeleteFile( strDefinitionFile );
    }
    varg_printf( g_normal, _T("\n") );
    switch( hr ){
    case ERROR_SUCCESS:
        PrintMessage( g_normal, IDS_MESSAGE_SUCCESS );
        break;
    case ERROR_INVALID_HANDLE:
        PrintMessage( g_debug, IDS_MESSAGE_BADFILE );
        break;
    default:
        PrintError( hr );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracerpt\resource.h ===
//
//    Copyright (c) Microsoft Corporation. All rights reserved.
//

#define IDS_PARAM_LOGFILE       103
#define IDS_PARAM_DUMPFILE      104
#define IDS_PARAM_MOFFILE       105
#define IDS_PARAM_REPORTFILE    106
#define IDS_PARAM_REALTIME      107
#define IDS_PARAM_LOGGERNAME    108
#define IDS_PARAM_EXFMT         111
#define IDS_PARAM_SUMMARY       113
#define IDS_PARAM_MERGE         114
#define IDS_PARAM_COMP          115
#define IDS_PARAM_YES           116

#define IDS_DEFAULT_DUMP        200
#define IDS_DEFAULT_MOF         201
#define IDS_DEFAULT_REPORT      202
#define IDS_DEFAULT_SUMMARY     203
#define IDS_DEFAULT_MERGED      204
#define IDS_DEFAULT_COMP        205

#define IDS_MESSAGE_INPUT       300
#define IDS_MESSAGE_OUTPUT      301
#define IDS_MESSAGE_BADFILE     302
#define IDS_MESSAGE_LOGGERS     303
#define IDS_MESSAGE_FILES       304
#define IDS_MESSAGE_DEFINE      305
#define IDS_MESSAGE_CSVFILE     306
#define IDS_MESSAGE_REPORT      307
#define IDS_MESSAGE_SUMMARY     308
#define IDS_MESSAGE_DFLTSRC     310
#define IDS_MESSAGE_MERGED      311
#define IDS_MESSAGE_COMP        312

#define IDS_EXAMPLE_DUMPFILE    800
#define IDS_EXAMPLE_SUMMARY     801
#define IDS_EXAMPLE_REALTIME    802
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\traceprt\trfmtmsg.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    traceprt.c

Abstract:

    Trace formatting library. Converts binary trace file to CSV format,
    and other formattted string formats.

Author:

    Ian Service (IanServ) 3rd May 2000

Revision History:

    Source taken from RtlFormatMessage and adapted for the needs of TraceFmt processing.
    
    Due to the way we pre format strings and get information about 64 and 32 bit strings, the odditties
    like %p do not work correctly when handled on a machine of the other type.
    This module contains a special version of RtlFormatMessage that does fixups in conjunction
    with TracePrt's processing of ItemPtr.

--*/

#ifdef __cplusplus
extern "C"{
#endif 

#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>\

#define MAX_INSERTS 200

NTSTATUS
TraceFormatMessage(
    IN PWSTR MessageFormat,
    IN ULONG MaximumWidth OPTIONAL,
    IN BOOLEAN IgnoreInserts,
    IN BOOLEAN ArgumentsAreAnsi,
    IN BOOLEAN ArgumentsAreAnArray,
    IN va_list *Arguments,
    OUT PWSTR Buffer,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    ULONG Column;
    int cchRemaining, cchWritten;
    PULONG_PTR ArgumentsArray = (PULONG_PTR)Arguments;
    ULONG_PTR rgInserts[ MAX_INSERTS ];
    ULONG cSpaces;
    ULONG MaxInsert, CurInsert;
    ULONG PrintParameterCount;
    ULONG_PTR PrintParameter1;
    ULONG_PTR PrintParameter2;
    WCHAR PrintFormatString[ 32 ];
    BOOLEAN DefaultedFormatString;
    WCHAR c;
    PWSTR s, s1;
    PWSTR lpDst, lpDstBeg, lpDstLastSpace;

    cchRemaining = Length / sizeof( WCHAR );
    lpDst = Buffer;
    MaxInsert = 0;
    lpDstLastSpace = NULL;
    Column = 0;
    s = MessageFormat;
    while (*s != UNICODE_NULL) {
        if (*s == L'%') {
            s++;
            lpDstBeg = lpDst;
            if (*s >= L'1' && *s <= L'9') {
                CurInsert = *s++ - L'0';
                if (*s >= L'0' && *s <= L'9') {
                    CurInsert = (CurInsert * 10) + (*s++ - L'0');
                    if (*s >= L'0' && *s <= L'9') {
                        CurInsert = (CurInsert * 10) + (*s++ - L'0');
                        if (*s >= L'0' && *s <= L'9') {
                            return( STATUS_INVALID_PARAMETER );
                            }
                        }
                    }
                CurInsert -= 1;

                PrintParameterCount = 0;
                if (*s == L'!') {
                    DefaultedFormatString = FALSE;
                    s1 = PrintFormatString;
                    *s1++ = L'%';
                    s++;
                    while (*s != L'!') {
                        if (*s != UNICODE_NULL) {
                            if (s1 >= &PrintFormatString[ 31 ]) {
                                return( STATUS_INVALID_PARAMETER );
                                }

                            if (*s == L'*') {
                                if (PrintParameterCount++ > 1) {
                                    return( STATUS_INVALID_PARAMETER );
                                    }
                                }

                            *s1++ = *s++;
                            }
                        else {
                            return( STATUS_INVALID_PARAMETER );
                            }
                        }

                    s++;
                    *s1 = UNICODE_NULL;
                    }
                else {
                    DefaultedFormatString = TRUE;
                    wcscpy( PrintFormatString, L"%s" );
                    s1 = PrintFormatString + wcslen( PrintFormatString );
                    }

                if (IgnoreInserts) {
                    if (!wcscmp( PrintFormatString, L"%s" )) {
                        cchWritten = _snwprintf( lpDst,
                                                 cchRemaining,
                                                 L"%%%u",
                                                 CurInsert+1
                                               );
                        }
                    else {
                        cchWritten = _snwprintf( lpDst,
                                                 cchRemaining,
                                                 L"%%%u!%s!",
                                                 CurInsert+1,
                                                 &PrintFormatString[ 1 ]
                                               );
                        }

                    if (cchWritten == -1) {
                        return(STATUS_BUFFER_OVERFLOW);
                        }
                    }
                else
                if (ARGUMENT_PRESENT( Arguments )) {
                    if ((CurInsert+PrintParameterCount) >= MAX_INSERTS) {
                        return( STATUS_INVALID_PARAMETER );
                        }

                    if (ArgumentsAreAnsi) {
                        if (s1[ -1 ] == L'c' && s1[ -2 ] != L'h'
                          && s1[ -2 ] != L'w' && s1[ -2 ] != L'l') {
                            wcscpy( &s1[ -1 ], L"hc" );
                            }
                        else
                        if (s1[ -1 ] == L's' && s1[ -2 ] != L'h'
                          && s1[ -2 ] != L'w' && s1[ -2 ] != L'l') {
                            wcscpy( &s1[ -1 ], L"hs" );
                            }
                        else if (s1[ -1 ] == L'S') {
                            s1[ -1 ] = L's';
                            }
                        else if (s1[ -1 ] == L'C') {
                            s1[ -1 ] = L'c';
                            }
                        }

                    while (CurInsert >= MaxInsert) {
                        if (ArgumentsAreAnArray) {
                            rgInserts[ MaxInsert++ ] = *((PULONG_PTR)Arguments)++;
                            }
                        else {
                            rgInserts[ MaxInsert++ ] = va_arg(*Arguments, ULONG_PTR);
                            }
                        }

                    s1 = (PWSTR)rgInserts[ CurInsert ];
                    PrintParameter1 = 0;
                    PrintParameter2 = 0;
                    if (PrintParameterCount > 0) {
                        if (ArgumentsAreAnArray) {
                            PrintParameter1 = rgInserts[ MaxInsert++ ] = *((PULONG_PTR)Arguments)++;
                            }
                        else {
                            PrintParameter1 = rgInserts[ MaxInsert++ ] = va_arg( *Arguments, ULONG_PTR );
                            }

                        if (PrintParameterCount > 1) {
                            if (ArgumentsAreAnArray) {
                                PrintParameter2 = rgInserts[ MaxInsert++ ] = *((PULONG_PTR)Arguments)++;
                                }
                            else {
                                PrintParameter2 = rgInserts[ MaxInsert++ ] = va_arg( *Arguments, ULONG_PTR );
                                }
                            }
                        }
                    // Here is where we diverage and fro Trace Formatting we fixup parameters
                    // %p becomes %s because thats the way we guarantee that its 64/32 compatible
                    {
                        SIZE_T len = _tcslen(PrintFormatString);
                        if (_tcschr(PrintFormatString,L'p') != NULL || 
                            (len >= 2) && (PrintFormatString[len-2] == 'I') ||
                            (len >= 4) && (PrintFormatString[len-4] == 'I') &&
                            (PrintFormatString[len-3] == '6') &&
                            (PrintFormatString[len-2] == '4') )
                        {
                            _stprintf(PrintFormatString,_T("%%s"));
                        }
                    }
                    cchWritten = _snwprintf( lpDst,
                                             cchRemaining,
                                             PrintFormatString,
                                             s1,
                                             PrintParameter1,
                                             PrintParameter2
                                           );
                    if (cchWritten == -1) {
                        return(STATUS_BUFFER_OVERFLOW);
                        }
                    }
                else {
                    return( STATUS_INVALID_PARAMETER );
                    }

                if ((cchRemaining -= cchWritten) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                lpDst += cchWritten;
                }
            else
            if (*s == L'0') {
                break;
                }
            else
            if (!*s) {
                return( STATUS_INVALID_PARAMETER );
                }
            else
            if (*s == L'r') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                s++;
                lpDstBeg = NULL;
                }
            else
            if (*s == L'n') {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                s++;
                lpDstBeg = NULL;
                }
            else
            if (*s == L't') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                if (Column % 8) {
                    Column = (Column + 7) & ~7;
                    }
                else {
                    Column += 8;
                    }

                lpDstLastSpace = lpDst;
                *lpDst++ = L'\t';
                s++;
                }
            else
            if (*s == L'b') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                lpDstLastSpace = lpDst;
                *lpDst++ = L' ';
                s++;
                }
            else
            if (IgnoreInserts) {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'%';
                *lpDst++ = *s++;
                }
            else {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = *s++;
                }

            if (lpDstBeg == NULL) {
                lpDstLastSpace = NULL;
                Column = 0;
                }
            else {
                Column += (ULONG)(lpDst - lpDstBeg);
                }
            }
        else {
            c = *s++;
            if (c == L'\r' || c == L'\n') {
                if ((c == L'\n' && *s == L'\r') ||
                    (c == L'\r' && *s == L'\n')
                   ) {
                    s++;
                    }

                if (MaximumWidth != 0) {
                    lpDstLastSpace = lpDst;
                    c = L' ';
                    }
                else {
                    c = L'\n';
                    }
                }


            if (c == L'\n') {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                lpDstLastSpace = NULL;
                Column = 0;
                }
            else {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                if (c == L' ') {
                    lpDstLastSpace = lpDst;
                    }

                *lpDst++ = c;
                Column += 1;
                }
            }

        if (MaximumWidth != 0 &&
            MaximumWidth != 0xFFFFFFFF &&
            Column >= MaximumWidth
           ) {
            if (lpDstLastSpace != NULL) {
                lpDstBeg = lpDstLastSpace;
                while (*lpDstBeg == L' ' || *lpDstBeg == L'\t') {
                    lpDstBeg += 1;
                    if (lpDstBeg == lpDst) {
                        break;
                        }
                    }
                while (lpDstLastSpace > Buffer) {
                    if (lpDstLastSpace[ -1 ] == L' ' || lpDstLastSpace[ -1 ] == L'\t') {
                        lpDstLastSpace -= 1;
                        }
                    else {
                        break;
                        }
                    }

                cSpaces = (ULONG)(lpDstBeg - lpDstLastSpace);
                if (cSpaces == 1) {
                    if ((cchRemaining -= 1) <= 0) {
                        return STATUS_BUFFER_OVERFLOW;
                        }
                    }
                else
                if (cSpaces > 2) {
                    cchRemaining += (cSpaces - 2);
                    }

                memmove( lpDstLastSpace + 2,
                         lpDstBeg,
                         (ULONG) ((lpDst - lpDstBeg) * sizeof( WCHAR ))
                       );
                *lpDstLastSpace++ = L'\r';
                *lpDstLastSpace++ = L'\n';
                Column = (ULONG)(lpDst - lpDstBeg);
                lpDst = lpDstLastSpace + Column;
                lpDstLastSpace = NULL;
                }
            else {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                lpDstLastSpace = NULL;
                Column = 0;
                }
            }
        }

    if ((cchRemaining -= 1) <= 0) {
        return STATUS_BUFFER_OVERFLOW;
        }

    *lpDst++ = '\0';
    if ( ARGUMENT_PRESENT(ReturnLength) ) {
        *ReturnLength = (ULONG)(lpDst - Buffer) * sizeof( WCHAR );
        }
    return( STATUS_SUCCESS );
}
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracewpp\crc32.h ===
#ifdef __cplusplus
extern "C" {
#endif

ULONG32
FstubCrc32(
    ULONG32 dwCrc,
    PVOID pvBuffer,
    SIZE_T cbBuffer
    );

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracewpp\ezparse.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    EzParse.cpp

Abstract:

    Poor man C/C++/any file parser.
    
Author:

    Gor Nishanov (gorn) 03-Apr-1999

Revision History:

    Gor Nishanov (gorn) 03-Apr-1999 -- hacked together to prove that this can work

    GorN: 29-Sep-2000 - fix enumeration bug
    GorN: 29-Sep-2000 - add support for KdPrintEx like function
    GorN: 09-Oct-2000 - fixed "//" in the string bug 
    GorN: 23-Oct-2000 - IGNORE_CPP_COMMENT, IGNORE_POUND_COMMENT options added 
    GorN: 16-Apr-2001 - Properly handle \" within a string
    
ToDo:

    Clean it up
    

--*/

#define STRICT

#include <stdio.h>
#include <windows.h>

#pragma warning(disable: 4100)
#include <algorithm>
#include <xstring>
#include "ezparse.h"

DWORD ErrorCount = 0;

PEZPARSE_CONTEXT EzParseCurrentContext = NULL;

// To force build tool to recognize our errors

#define BUILD_PREFIX_FNAME "cl %s\n"
#define BUILD_PREFIX "cl wpp\n"

void ExParsePrintErrorPrefix(FILE* f, char * func)
{
    ++ErrorCount;
    if (EzParseCurrentContext) {
        fprintf(f,BUILD_PREFIX_FNAME "%s(%d) : error : (%s)", 
               EzParseCurrentContext->filename, 
               EzParseCurrentContext->filename, 
               EzGetLineNo(EzParseCurrentContext->currentStart, EzParseCurrentContext),
               func);
    } else {
        fprintf(f,BUILD_PREFIX "wpp : error : (%s)", func);
    }
}

LPCSTR skip_stuff_in_quotes(LPCSTR  q, LPCSTR  begin)
{
    char ch = *q;
    if (q > begin) {
        if (q[-1] == '\\') {
            return q - 1;
        }
    }
    for(;;) {
        if (q == begin) {
            return 0;
        }
        --q;
        if (*q == ch && ( (q == begin) || (q[-1] != '\\') ) ) {
            return q;
        }
    }
}


void
adjust_pair( STR_PAIR& str )
/*++
  Shrink the pair to remote leading and trailing whitespace
 */
{
    while (str.beg < str.end && isspace(*str.beg)) { ++str.beg; }
    while (str.beg < str.end && isspace(str.end[-1])) { --str.end; }
}

void
remove_cpp_comment(STR_PAIR& str)
{
    LPCSTR p = str.beg;

//    printf("rcb: %s\n", std::string(str.beg, str.end).c_str());

    // let's cut the comment in the beginning of the string

    for(;;) {
        // skip the whitespace
        for(;;) {
            if (p == str.end) return;
            if (!isspace(*p)) break;
            ++p;
        }
        str.beg = p;
        if (p + 1 == str.end) return;
        if (p[0] == '/' && p[1] == '/') {

            // we have a comment. Need to get to the end of the comment
            p += 2;
//    printf("rcd: %s %s\n", std::string(str.beg, p).c_str(), std::string(p,str.end).c_str());
            for(;;) {
                if (p == str.end) return;
                if (*p == '\r' || *p == '\n') {                    
                    str.beg = p;
                    break;
                }
                ++p;
            }
        
        } else {
            // no leading comment
            break;
        }
    }    

//    printf("rcc: %s %s\n", std::string(str.beg, p).c_str(), std::string(p,str.end).c_str());    

    for(;;) {
        if (p == str.end) return;
        if (*p == '"') {
            // don't look for comments within a string
            for(;;) {
                if (++p == str.end) return;
                if (*p == '"' && p[-1] != '\\') break;
            }
            ++p;
            continue;
        }
        
        if (p + 1 == str.end) return;
        if (p[0] == '/')
            if (p[1] == '/') break;
            else p += 2;
        else
            p += 1;
    }
    str.end = p;

//    printf("rce: %s\n", std::string(str.beg, str.end).c_str());
}

DWORD
ScanForFunctionCallsEx(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN OUT PEZPARSE_CONTEXT ParseContext,
    IN DWORD Options
    )
/*++

Routine Description:

    Scan the buffer for expressions that looks like function calls,
    i.e name(sd,sdf,sdf,sdf,sdf); . It will treat variable declaration
    with constructor call as a function call as well.
    
Inputs:

    begin, end -- pointers to the beginning and the end of the buffer
    Callback   -- to be called for every function
    Context    -- opaque context to be passed to callback
    ParseContext -- holds current parse state information    

--*/
{
    LPCSTR p = begin;
    LPCSTR q, funcNameEnd;
    DWORD Status = ERROR_SUCCESS;
    bool double_par = FALSE;

no_match:

    if (Options & NO_SEMICOLON) {
        q = end;
        Options &= ~NO_SEMICOLON;
    } else {   
        do {
            ++p;
            if (p == end) {
                return Status;
            }
        } while ( *p != ';' );
        // Ok. Now p points to ';' //

        q = p;
    }    
    
    do {
        if (--q <= begin) {
            goto no_match;
        }
    } while ( isspace(*q) );
    
    // Now q points on the first non white space character        //
    // If it is not a ')' then we need to search for the next ';' //

    if (*q != ')') {
        goto no_match;
    }

    ParseContext->macroEnd = q;

    // Ok. This is a function call (definition).
    // Now, let's go and collect all the arguments of the first level and
    // get to the name of the function

    // HACKHACK
    // We need a special case for functions that looks like
    //   KdPrintEx((Level, Indent, Msg, ...));
    //   Essentially, we need to treat them as
    //   KdPrintEx(Level, Indent, Msg, ...);

    const char *r = q;

    // check if we have ));

    do {
        if (--r <= begin) break; // no "));"
    } while ( isspace(*r) );

    double_par = r > begin && *r == ')';
    if (double_par) {
        q = r;
        // we assume that this is KdPrint((a,b,c,d,...)); at the moment
        // if our assumtion is wrong, we will retry the loop below
    }

retry: 
    {
        int level = 0;

        LPCSTR   ends[128], *current = ends;
        STR_PAIR strs[128];

//        LPCSTR   closing_parenthisis = q;

        *current = q;
        
        for(;;) {
            --q;
            if (q <= begin) {
                goto no_match;
            }
            switch (*q) {
            case ',':  if (!level) *++current = q; break;
            case '(':  if (level) --level; else goto maybe_match; break;
            case ')':  ++level; break;
            case '\'': 
            case '"':  
                q = skip_stuff_in_quotes(q, begin); if(!q) goto no_match;
            }
        }
maybe_match:
        *++current = q;
        funcNameEnd = q;

        // now q point to '(' we need to find name of the function //
        do {
            --q;
            if (q <= begin) {
                goto no_match;
            }

        } while(isspace(*q));

        // now q points to first not white character

        if (double_par) {
            // if we see )); and found a matching
            // parenthesis for the inner one, we can have
            // one of two cases
            //   1) KdPrint((a,b,c,d,...));
            //      or
            //   2) DebugPrint(a,b,(c,d));
            // If it is the latter, we just need to
            // retry the scanning, now using leftmost bracket as a starting point

            if (*q != '(') {
                // restore q to the rightmost parenthesis
                q = ParseContext->macroEnd;
                double_par = FALSE;
                goto retry;
            }
            funcNameEnd = q;
            // now q point to '(' we need to find name of the function //
            do {
                --q;
                if (q <= begin) {
                    goto no_match;
                }

            } while(isspace(*q));
        }
        
        // now q points to first non white character
        // BUGBUG '{' and '}' are allowed only in config files

        if (*q == '}') {
            for(;;) {
                if (--q < begin) goto no_match;
                if (*q == '{') break;
            }
            if (--q < begin) goto no_match;
        }

        if (!(isalpha(*q) || isdigit(*q) || *q == '_')) {
            goto no_match;
        }
        do {
            --q;
            if (q <= begin) {
                goto found;
            }
        } while ( isalpha(*q) || isdigit(*q) || *q == '_');
        ++q;

        if (isdigit(*q)) {
            goto no_match;
        }

found:
        if (Options & IGNORE_COMMENT)
        // Verify that it is not a comment
        //   # sign in the beginning of the line

        {
            LPCSTR line = q;
            //
            // Find the beginning of the line or file
            //

            for(;;) {
                if (line == begin) {
                    // Beginning of the file. Good enough
                    break;
                }
                if (Options & IGNORE_CPP_COMMENT && line[0] == '/' && line[1] == '/') {
                    // C++ comment. Ignore
                    goto no_match;
                }
                if (*line == 13 || *line == 10) {
                    ++line;
                    break;
                }
                --line;
            }

            //
            // If the first non-white character is #, ignore it
            //
            while (line <= q) {
                if ( *line != ' ' && *line != '\t' ) {
                    break;
                }
                ++line;
            }

            if (Options & IGNORE_POUND_COMMENT && *line == '#') {
                goto no_match;
            }
        }


        {
            int i = 0;

            strs[0].beg  = q;
            strs[0].end = funcNameEnd;
            adjust_pair(strs[0]);

            while (current != ends) {
                // putchar('<');printrange(current[0]+1, current[-1]); putchar('>');
                ++i;
                strs[i].beg = current[0]+1;
                --current;
                strs[i].end = current[0];
                adjust_pair(strs[i]);
                remove_cpp_comment(strs[i]);
            }

            ParseContext->currentStart = strs[0].beg;
            ParseContext->currentEnd = strs[0].end;
            ParseContext->doubleParent = double_par;

            Status = Callback(strs, i+1, Context, ParseContext);
            if (Status != ERROR_SUCCESS) {
                return Status;
            }
                
        }
        goto no_match;
    }
    // return ERROR_SUCCESS; // unreachable code
}

DWORD
ScanForFunctionCalls(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN OUT PEZPARSE_CONTEXT ParseContext    
    )
{
    return ScanForFunctionCallsEx(
        begin, end, Callback, Context,
        ParseContext, IGNORE_COMMENT);
}

DWORD 
EzGetLineNo(
    IN LPCSTR Ptr,
    IN OUT PEZPARSE_CONTEXT ParseContext
    )
/*++
    Computes a line number based on 
    an pointer within a buffer.

    Last known lineno/pointer is cached in ParseContext
    for performance
*/
{
    int count = ParseContext->scannedLineCount;
    LPCSTR downto = ParseContext->lastScanned;
        LPCSTR p = Ptr;

    if (downto > p) {
        count = 1;
        downto = ParseContext->start;
    }

    while (p > downto) {
        if (*p == '\n') {
            ++count;
        }
        --p;
    }

    ParseContext->scannedLineCount = count;
    ParseContext->lastScanned = Ptr;

    return count;
}

const char begin_wpp[] = "begin_wpp"; 
const char end_wpp[]   = "end_wpp";  
const char define_[]   = "#define";
const char enum_[]     = "enum ";
enum { 
    begin_wpp_size = (sizeof(begin_wpp)-1),
    end_wpp_size   = (sizeof(end_wpp)-1),
    define_size    = (sizeof(define_)-1),
    enum_size      = (sizeof(enum_)-1),
};

typedef struct _SmartContext {
    EZPARSE_CALLBACK Callback;
    PVOID Context;
    OUT PEZPARSE_CONTEXT ParseContext;
    std::string buf;
} SMART_CONTEXT, *PSMART_CONTEXT;

void DoEnumItems(PSTR_PAIR name, LPCSTR begin, LPCSTR end, PSMART_CONTEXT ctx)
{
    LPCSTR p,q;
    ULONG  value = 0;
    STR_PAIR Item;
    BOOL First = TRUE;
    ctx->buf.assign("CUSTOM_TYPE(");
    ctx->buf.append(name->beg, name->end);
    ctx->buf.append(", ItemListLong");
    p = begin;

    while(begin < end && isspace(*--end)); // skip spaces
    if (begin < end && *end != ',') ++end;

    for(;p < end;) {
        Item.beg = p;
        q = p;
        for(;;) {
            if (q == end) {
                goto enum_end;
            }
            if (*q == ',' || *q == '}') {
                // valueless item. Use current
                Item.end = q;
                break;
            } else if (*q == '=') {
                // need to calc the value. Skip for now //
                Item.end = q;
                while (q < end && *q != ',') ++q;
                break;
            }
            ++q;
        }
        adjust_pair(Item);
        if (Item.beg == Item.end) {
            break;
        }
        if (First) {ctx->buf.append("("); First = FALSE;} else ctx->buf.append(",");
        ctx->buf.append(Item.beg, Item.end);
        if (q == end) break;
        p = q+1;
        ++value;
    }
  enum_end:;  
    ctx->buf.append(") )");
    ScanForFunctionCallsEx(
        &ctx->buf[0], &ctx->buf[0] + ctx->buf.size(), ctx->Callback, ctx->Context,
        ctx->ParseContext, NO_SEMICOLON);
    Flood("enum %s\n", ctx->buf.c_str());
}

void DoEnum(LPCSTR begin, LPCSTR end, PSMART_CONTEXT Ctx)
{
    LPCSTR p, q, current = begin;

    for(;;) {
        p = std::search(current, end, enum_, enum_ + enum_size);
        if (p == end) break;
        q = std::find(p, end, '{');
        if (q == end) break;

        // let's figure out enum name //
        STR_PAIR name;
        name.beg = p + enum_size;
        name.end = q;

        adjust_pair(name);
        if ( *name.beg == '_' ) ++name.beg;

        p = q+1; // past "{";
        q = std::find(p, end, '}');
        if (q == end) break;

        if (name.end > name.beg) {
            DoEnumItems(&name, p, q, Ctx); 
        } else {
            ReportError("Cannot handle tagless enums yet");
        }

        current = q;
    }
}


DWORD
SmartScan(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN OUT PEZPARSE_CONTEXT ParseContext
    )
{
    LPCSTR block_start, block_end, current = begin;
    SMART_CONTEXT Ctx;
    Ctx.Callback = Callback;
    Ctx.Context  = Context;
    Ctx.ParseContext = ParseContext;
    
    for(;;) {
        block_start = std::search(current, end, begin_wpp, begin_wpp + begin_wpp_size);
        if (block_start == end) break;
        
        current = block_start;
        
        block_end = std::search(block_start, end, end_wpp, end_wpp + end_wpp_size);
        if (block_end == end) break;

        Flood("Block Found\n");
        // determine block type //
        
        //  begin_wpp enum
        //  begin_wpp config
        //  begin_wpp func
        //  begin_wpp define
        
        LPCSTR block_type = block_start + begin_wpp_size + 1;
        Flood("block_type = %c%c%c%c\n", block_type[0],block_type[1],block_type[2],block_type[3]); 
        
        if        (memcmp(block_type, "enum",   4) == 0) {
            // do enum block //
            DoEnum( block_type + 4, block_end, &Ctx );
            
        } else if (memcmp(block_type, "config", 6) == 0) {
            // do config block //
            ScanForFunctionCallsEx(block_type + 6, block_end, Callback, Context, ParseContext, IGNORE_POUND_COMMENT);

        } else if (memcmp(block_type, "func", 4) == 0) {
            LPCSTR func_start, func_end;
            current = block_type + 6;
            for(;;) {
                func_start = std::search(current, block_end, define_, define_ + define_size);
                if (func_start == block_end) break;
                func_start += define_size;
                while (isspace(*func_start)) {
                    if(++func_start == block_end) goto no_func;
                }
                func_end = func_start;
                while (!isspace(*func_end)) {
                    if(*func_end == '(') break;
                    if(++func_end == block_end) goto no_func;
                }
                if(*func_end != '(') {
                    Ctx.buf.assign(func_start, func_end);
                    Ctx.buf.append("(MSGARGS)");
                } else {
                    func_end = std::find(func_start, block_end, ')');
                    if (func_end == block_end) break;

                    ++func_end; // include ")"
                    Ctx.buf.assign(func_start, func_end); 
                }
                Flood("Func %s\n", Ctx.buf.c_str());
                ScanForFunctionCallsEx(
                    Ctx.buf.begin(), Ctx.buf.end(), Callback, Context,
                    ParseContext, NO_SEMICOLON);
                current = func_end;
            }            
            no_func:;
        } else if (memcmp(block_type, "define", 6) == 0) {
            // do define block
        } else {
            ReportError("Unknown block");
        }

        current = block_end + end_wpp_size;
    }
    if (current == begin) {
        // file without marking, let's do default processing
        Unusual("Reverting back to plain scan\n");
        ScanForFunctionCalls(begin, end, Callback, Context, ParseContext);
    }

    return ERROR_SUCCESS;
}

DWORD
EzParse(
    IN LPCSTR filename, 
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context)
{
    
//    return EzParseEx(filename, SmartScan, Callback, Context);
    return EzParseEx(filename, ScanForFunctionCalls, Callback, Context, IGNORE_POUND_COMMENT);
}

DWORD
EzParseWithOptions(
    IN LPCSTR filename, 
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN DWORD Options)
{
    
    return EzParseEx(filename, ScanForFunctionCalls, Callback, Context, Options);
}

DWORD
EzParseEx(
    IN LPCSTR filename, 
    IN PROCESSFILE_CALLBACK ProcessData,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN DWORD Options
    )
{    
    DWORD  Status = ERROR_SUCCESS;
    HANDLE mapping;
    HANDLE file = CreateFileA(filename, 
                              GENERIC_READ, FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, 0, 0);
    if (file == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        ReportError("Cannot open file %s, error %u\n", filename, Status );
        return Status;
    }
    DWORD size = GetFileSize(file, 0);
    mapping = CreateFileMapping(file,0,PAGE_READONLY,0,0, 0);
    if (!mapping) {
        Status = GetLastError();
        ReportError("Cannot create mapping, error %u\n", Status );
        CloseHandle(file);
        return Status;
    }
    PCHAR buf = (PCHAR)MapViewOfFileEx(mapping, FILE_MAP_READ,0,0,0,0);
    if (buf) {

        EZPARSE_CONTEXT ParseContext;
        ZeroMemory(&ParseContext, sizeof(ParseContext) );
    
        ParseContext.start = buf;
        ParseContext.filename = filename;
        ParseContext.scannedLineCount = 1;
        ParseContext.lastScanned = buf;
        ParseContext.previousContext = EzParseCurrentContext;
        ParseContext.Options = Options;
        EzParseCurrentContext = &ParseContext;
    
        Status = (*ProcessData)(buf, buf + size, Callback, Context, &ParseContext);

        EzParseCurrentContext = ParseContext.previousContext;
        UnmapViewOfFile( buf );

    } else {
        Status = GetLastError();
        ReportError("MapViewOfFileEx failed, error %u\n", Status );
    }
    CloseHandle(mapping);
    CloseHandle(file);
    return Status;
}

DWORD
EzParseResourceEx(
    IN LPCSTR ResName, 
    IN PROCESSFILE_CALLBACK ProcessData,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context)
{    
    DWORD  Status = ERROR_SUCCESS;
    HRSRC hRsrc;

    hRsrc = FindResource(
        NULL, //this Module
        ResName, 
        RT_RCDATA);
        
    if (hRsrc == NULL) {
        Status = GetLastError();
        ReportError("Cannot open resource %s, error %u\n", ResName, Status );
        return Status;
    }

    HGLOBAL hGlobal = LoadResource(NULL, hRsrc);
    if (!hGlobal) {
        Status = GetLastError();
        ReportError("LockResource failed, error %u\n", Status );
        return Status;
    }

    DWORD size = SizeofResource(NULL, hRsrc);
    
    PCHAR buf = (PCHAR)LockResource(hGlobal);
    if (buf) {

        EZPARSE_CONTEXT ParseContext;
        ZeroMemory(&ParseContext, sizeof(ParseContext) );
    
        ParseContext.start = buf;
        ParseContext.filename = ResName;
        ParseContext.scannedLineCount = 1;
        ParseContext.lastScanned = buf;
        ParseContext.previousContext = EzParseCurrentContext;
        EzParseCurrentContext = &ParseContext;
    
        Status = (*ProcessData)(buf, buf + size, Callback, Context, &ParseContext);
        EzParseCurrentContext = ParseContext.previousContext;
    } else {
        Status = GetLastError();
        ReportError("LockResource failed, error %u\n", Status );
    }
    // According to MSDN. There is no need to call Unlock/Free Resource
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracewpp\crc32.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    crc32.c

Abstract:

    CRC-32 alogorithm

Author:

    MikeSw

Revision History:

    31-Mar-94       MikeSw      Created

--*/

#include <windows.h>

//
// This code comes from Dr. Dobbs Journal, May 1992
//

ULONG32
FstubCrc32(
    ULONG32 dwCrc,
    PVOID pvBuffer,
    SIZE_T cbBuffer
    );


ULONG32 FstubCrcTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };

ULONG32
FstubCrc32(
    IN ULONG32 dwCrc,
    IN PVOID pvBuffer,
    IN SIZE_T cbBuffer
    )
{
    PUCHAR pbBuffer = (PUCHAR) pvBuffer;

    while (cbBuffer-- != 0)
    {
        dwCrc = (dwCrc >> 8) ^ FstubCrcTable[(UCHAR) dwCrc ^ *pbBuffer++];
    }

    return dwCrc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracewpp\md5.h ===
/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

#ifdef __cplusplus
extern "C" {
#endif

/* Data structure for MD5 (Message-Digest) computation */
typedef struct {
  ULONG i[2];                          /* number of _bits_ handled mod 2^64 */
  ULONG buf[4];                                           /* scratch buffer */
  unsigned char in[64];                                     /* input buffer */
  unsigned char digest[16];            /* actual digest after MD5Final call */
  ULONG FinishFlag;
} MD5_CTX;


#define MD5DIGESTLEN 16

#define PROTO_LIST(list)    list


/*
 * MTS: Each of these assumes MD5_CTX is locked against simultaneous use.
 */
void MD5Init PROTO_LIST ((MD5_CTX *));
void MD5Update PROTO_LIST ((MD5_CTX *, const unsigned char *, unsigned int));
void MD5Final PROTO_LIST ((MD5_CTX *));

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracewpp\md5c.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved


#define UINT4   unsigned long
#define ULONG	unsigned long


#include "md5.h"


/* Constants for Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void TransformMD5 PROTO_LIST ((UINT4 *, UINT4 *));

static const unsigned char PADDING[64] = {
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* F, G and H are basic MD5 functions */
#define F(x, y, z) (z ^ (x & (y^z)))	/* optimized version of (((x) & (y)) | ((~x) & (z))) */
#define G(x, y, z) (y ^ (z & (x^y)))	/* optimized version of (((x) & (z)) | ((y) & (~z))) */
#define H(x, y, z) (x ^ y ^ z)
#define I(x, y, z) (y ^ (x | ~z))

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) _rotl((x), (n))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
  {(a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) \
  {(a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }

/*
** MTS: Assumes mdContext is locked against simultaneous use.
*/
void MD5Init (MD5_CTX *mdContext)
{
  mdContext->i[0] = mdContext->i[1] = (UINT4)0;

  /* Load magic initialization constants.
   */
  mdContext->buf[0] = (UINT4)0x67452301;
  mdContext->buf[1] = (UINT4)0xefcdab89;
  mdContext->buf[2] = (UINT4)0x98badcfe;
  mdContext->buf[3] = (UINT4)0x10325476;
}

/*
** MTS: Assumes mdContext is locked against simultaneous use.
*/
void MD5Update (MD5_CTX *mdContext, const unsigned char *inBuf, unsigned int inLen)
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* update number of bits */
  if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])
    mdContext->i[1]++;
  mdContext->i[0] += ((UINT4)inLen << 3);
  mdContext->i[1] += ((UINT4)inLen >> 29);

  while (inLen--) {
    /* add new character to buffer, increment mdi */
    mdContext->in[mdi++] = *inBuf++;

    /* transform if necessary */
    if (mdi == 0x40) {
      for (i = 0, ii = 0; i < 16; i++, ii += 4)
        in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
                (((UINT4)mdContext->in[ii+2]) << 16) |
                (((UINT4)mdContext->in[ii+1]) << 8) |
                ((UINT4)mdContext->in[ii]);
      TransformMD5 (mdContext->buf, in);
      mdi = 0;
    }
  }
}

/*
** MTS: Assumes mdContext is locked against simultaneous use.
*/
void MD5Final (MD5_CTX *mdContext)
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;
  unsigned int padLen;

  /* save number of bits */
  in[14] = mdContext->i[0];
  in[15] = mdContext->i[1];

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* pad out to 56 mod 64 */
  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
  MD5Update (mdContext, PADDING, padLen);

  /* append length in bits and transform */
  for (i = 0, ii = 0; i < 14; i++, ii += 4)
    in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
            (((UINT4)mdContext->in[ii+2]) << 16) |
            (((UINT4)mdContext->in[ii+1]) << 8) |
            ((UINT4)mdContext->in[ii]);
  TransformMD5 (mdContext->buf, in);

  /* store buffer in digest */
  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xff);
    mdContext->digest[ii+1] =
      (unsigned char)((mdContext->buf[i] >> 8) & 0xff);
    mdContext->digest[ii+2] =
      (unsigned char)((mdContext->buf[i] >> 16) & 0xff);
    mdContext->digest[ii+3] =
      (unsigned char)((mdContext->buf[i] >> 24) & 0xff);
  }
}

/* Basic MD5 step. Transforms buf based on in.
 */
static void TransformMD5 (UINT4 *buf, UINT4 *in)
{
  UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];

  /* Round 1 */
  FF ( a, b, c, d, in[ 0], S11, 0xd76aa478); /* 1 */
  FF ( d, a, b, c, in[ 1], S12, 0xe8c7b756); /* 2 */
  FF ( c, d, a, b, in[ 2], S13, 0x242070db); /* 3 */
  FF ( b, c, d, a, in[ 3], S14, 0xc1bdceee); /* 4 */
  FF ( a, b, c, d, in[ 4], S11, 0xf57c0faf); /* 5 */
  FF ( d, a, b, c, in[ 5], S12, 0x4787c62a); /* 6 */
  FF ( c, d, a, b, in[ 6], S13, 0xa8304613); /* 7 */
  FF ( b, c, d, a, in[ 7], S14, 0xfd469501); /* 8 */
  FF ( a, b, c, d, in[ 8], S11, 0x698098d8); /* 9 */
  FF ( d, a, b, c, in[ 9], S12, 0x8b44f7af); /* 10 */
  FF ( c, d, a, b, in[10], S13, 0xffff5bb1); /* 11 */
  FF ( b, c, d, a, in[11], S14, 0x895cd7be); /* 12 */
  FF ( a, b, c, d, in[12], S11, 0x6b901122); /* 13 */
  FF ( d, a, b, c, in[13], S12, 0xfd987193); /* 14 */
  FF ( c, d, a, b, in[14], S13, 0xa679438e); /* 15 */
  FF ( b, c, d, a, in[15], S14, 0x49b40821); /* 16 */

  /* Round 2 */
  GG ( a, b, c, d, in[ 1], S21, 0xf61e2562); /* 17 */
  GG ( d, a, b, c, in[ 6], S22, 0xc040b340); /* 18 */
  GG ( c, d, a, b, in[11], S23, 0x265e5a51); /* 19 */
  GG ( b, c, d, a, in[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG ( a, b, c, d, in[ 5], S21, 0xd62f105d); /* 21 */
  GG ( d, a, b, c, in[10], S22,  0x2441453); /* 22 */
  GG ( c, d, a, b, in[15], S23, 0xd8a1e681); /* 23 */
  GG ( b, c, d, a, in[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG ( a, b, c, d, in[ 9], S21, 0x21e1cde6); /* 25 */
  GG ( d, a, b, c, in[14], S22, 0xc33707d6); /* 26 */
  GG ( c, d, a, b, in[ 3], S23, 0xf4d50d87); /* 27 */
  GG ( b, c, d, a, in[ 8], S24, 0x455a14ed); /* 28 */
  GG ( a, b, c, d, in[13], S21, 0xa9e3e905); /* 29 */
  GG ( d, a, b, c, in[ 2], S22, 0xfcefa3f8); /* 30 */
  GG ( c, d, a, b, in[ 7], S23, 0x676f02d9); /* 31 */
  GG ( b, c, d, a, in[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH ( a, b, c, d, in[ 5], S31, 0xfffa3942); /* 33 */
  HH ( d, a, b, c, in[ 8], S32, 0x8771f681); /* 34 */
  HH ( c, d, a, b, in[11], S33, 0x6d9d6122); /* 35 */
  HH ( b, c, d, a, in[14], S34, 0xfde5380c); /* 36 */
  HH ( a, b, c, d, in[ 1], S31, 0xa4beea44); /* 37 */
  HH ( d, a, b, c, in[ 4], S32, 0x4bdecfa9); /* 38 */
  HH ( c, d, a, b, in[ 7], S33, 0xf6bb4b60); /* 39 */
  HH ( b, c, d, a, in[10], S34, 0xbebfbc70); /* 40 */
  HH ( a, b, c, d, in[13], S31, 0x289b7ec6); /* 41 */
  HH ( d, a, b, c, in[ 0], S32, 0xeaa127fa); /* 42 */
  HH ( c, d, a, b, in[ 3], S33, 0xd4ef3085); /* 43 */
  HH ( b, c, d, a, in[ 6], S34,  0x4881d05); /* 44 */
  HH ( a, b, c, d, in[ 9], S31, 0xd9d4d039); /* 45 */
  HH ( d, a, b, c, in[12], S32, 0xe6db99e5); /* 46 */
  HH ( c, d, a, b, in[15], S33, 0x1fa27cf8); /* 47 */
  HH ( b, c, d, a, in[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II ( a, b, c, d, in[ 0], S41, 0xf4292244); /* 49 */
  II ( d, a, b, c, in[ 7], S42, 0x432aff97); /* 50 */
  II ( c, d, a, b, in[14], S43, 0xab9423a7); /* 51 */
  II ( b, c, d, a, in[ 5], S44, 0xfc93a039); /* 52 */
  II ( a, b, c, d, in[12], S41, 0x655b59c3); /* 53 */
  II ( d, a, b, c, in[ 3], S42, 0x8f0ccc92); /* 54 */
  II ( c, d, a, b, in[10], S43, 0xffeff47d); /* 55 */
  II ( b, c, d, a, in[ 1], S44, 0x85845dd1); /* 56 */
  II ( a, b, c, d, in[ 8], S41, 0x6fa87e4f); /* 57 */
  II ( d, a, b, c, in[15], S42, 0xfe2ce6e0); /* 58 */
  II ( c, d, a, b, in[ 6], S43, 0xa3014314); /* 59 */
  II ( b, c, d, a, in[13], S44, 0x4e0811a1); /* 60 */
  II ( a, b, c, d, in[ 4], S41, 0xf7537e82); /* 61 */
  II ( d, a, b, c, in[11], S42, 0xbd3af235); /* 62 */
  II ( c, d, a, b, in[ 2], S43, 0x2ad7d2bb); /* 63 */
  II ( b, c, d, a, in[ 9], S44, 0xeb86d391); /* 64 */

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracewpp\tpl.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    tpl.h

Abstract:

    template file interpreter declarations
Author:

    Gor Nishanov (gorn) 03-Apr-1999

Revision History:

    gorn 03-Apr-1999 -- hacked it all together to prove that this can work

To Do:

    Clean it up

--*/

#define INSERT_FIELD_NAMES \
  FIELD_NAME(__default__) \
  FIELD_NAME(Version) \
  FIELD_NAME(Time) \
  FIELD_NAME(Date) \
  FIELD_NAME(Count) \
  FIELD_NAME(Struct) \
  FIELD_NAME(Indent) \
  FIELD_NAME(Comment) \
  FIELD_NAME(Checksum) \
  FIELD_NAME(Messages) \
  FIELD_NAME(Text) \
  FIELD_NAME(MsgNames) \
  FIELD_NAME(MacroArgs) \
  FIELD_NAME(MacroExprs) \
  FIELD_NAME(FixedArgs) \
  FIELD_NAME(ReorderSig) \
  FIELD_NAME(Value) \
  FIELD_NAME(GooArgs) \
  FIELD_NAME(GooVals) \
  FIELD_NAME(GooId) \
  FIELD_NAME(GooPairs) \
  FIELD_NAME(MsgNo) \
  FIELD_NAME(GuidNo) \
  FIELD_NAME(Guid) \
  FIELD_NAME(BitNo) \
  FIELD_NAME(Arguments) \
  FIELD_NAME(Permutation) \
  FIELD_NAME(LogArgs) \
  FIELD_NAME(Name) \
  FIELD_NAME(Alias) \
  FIELD_NAME(CtlMsg) \
  FIELD_NAME(Enabled) \
  FIELD_NAME(ID) \
  FIELD_NAME(GRP) \
  FIELD_NAME(ARG) \
  FIELD_NAME(MSG) \
  FIELD_NAME(MofType) \
  FIELD_NAME(DeclVars) \
  FIELD_NAME(References) \
  FIELD_NAME(No) \
  FIELD_NAME(Line) \
  FIELD_NAME(CanonicalName) \
  FIELD_NAME(UppercaseName) \
  FIELD_NAME(Timestamp) \
  FIELD_NAME(EquivType) \
  FIELD_NAME(MacroStart) \
  FIELD_NAME(MacroEnd) \
  FIELD_NAME(MacroName) \
  FIELD_NAME(Path) \
  FIELD_NAME(Extension) \
  FIELD_NAME(TypeSig) \
  FIELD_NAME(MsgVal) \
  FIELD_NAME(FormatSpec) 

    
extern LPCSTR FieldNames[];

enum FieldId {
  #define FIELD_NAME(_name_) fid_ ## _name_,
     INSERT_FIELD_NAMES
  #undef FIELD_NAME
};

DWORD
processTemplate(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN PEZPARSE_CONTEXT ParseContext
    );

void PopulateFieldMap();

void ProcessTemplate(LPCSTR b, LPCSTR e, void* Context);

struct strless {
    bool operator() (const std::string& a, const std::string&b) const { return a.compare(b) < 0; }
};

typedef std::map<std::string, FieldHolder*, strless> OBJECT_MAP;

extern OBJECT_MAP ObjectMap;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracewpp\ezparse.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    EzParse.h

Abstract:

    Poor man C/C++/any file parser declaration.
    
Author:

    Gor Nishanov (gorn) 03-Apr-1999

Revision History:

    Gor Nishanov (gorn) 03-Apr-1999 -- hacked together to prove that this can work

ToDo:

    Clean it up

--*/

typedef struct _STR_PAIR
{
    LPCSTR beg;
    LPCSTR end;
    bool empty() const { return beg == end; }
} STR_PAIR, *PSTR_PAIR;

typedef struct _EZPARSE_CONTEXT {
    LPCSTR start;
    LPCSTR currentStart;
    LPCSTR currentEnd;
    LPCSTR filename;
    LPCSTR lastScanned;
    UINT   scannedLineCount;
    LPCSTR macroEnd;
    BOOL   doubleParent;
    struct _EZPARSE_CONTEXT * previousContext;
    DWORD  Options;
} EZPARSE_CONTEXT, *PEZPARSE_CONTEXT;

void ExParsePrintErrorPrefix(FILE* f, char* funcname);
extern DWORD ErrorCount;

#define ReportError ExParsePrintErrorPrefix(stdout, __FUNCTION__);printf

typedef
DWORD (*EZPARSE_CALLBACK) (PSTR_PAIR, INT, PVOID, PEZPARSE_CONTEXT);

typedef
DWORD (*PROCESSFILE_CALLBACK) (
    LPCSTR, LPCSTR, EZPARSE_CALLBACK,PVOID,PEZPARSE_CONTEXT);

DWORD 
EzGetLineNo(
    IN LPCSTR Ptr,
    IN PEZPARSE_CONTEXT
    );

DWORD
EzParse(
    IN LPCSTR filename, 
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context);

DWORD
EzParseWithOptions(
    IN LPCSTR filename, 
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN DWORD Options
    );

DWORD
EzParseEx(
    IN LPCSTR filename, 
    IN PROCESSFILE_CALLBACK ProcessData,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN DWORD Options);

DWORD
EzParseResourceEx(
    IN LPCSTR ResName, 
    IN PROCESSFILE_CALLBACK ProcessData,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context);

DWORD
SmartScan(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN OUT PEZPARSE_CONTEXT ParseContext
    );

DWORD
ScanForFunctionCalls(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN OUT PEZPARSE_CONTEXT ParseContext    
    );

enum {
    NO_SEMICOLON         = 0x01,
    IGNORE_CPP_COMMENT   = 0x02, 
    IGNORE_POUND_COMMENT = 0x04, 
    IGNORE_COMMENT = IGNORE_CPP_COMMENT | IGNORE_POUND_COMMENT,
};
    
DWORD
ScanForFunctionCallsEx(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK Callback, 
    IN PVOID Context,
    IN OUT PEZPARSE_CONTEXT ParseContext,
    IN DWORD Options
    );

__declspec(selectany) int DbgLevel = 0;

enum DBG_LEVELS {
    DBG_UNUSUAL = 1,
    DBG_NOISE   = 2,
    DBG_FLOOD   = 3,
};    

#define Always printf
#define Flood (DbgLevel < DBG_FLOOD)?0:printf
#define Noise (DbgLevel < DBG_NOISE)?0:printf
#define Unusual (DbgLevel < DBG_UNUSUAL)?0:printf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracewpp\tpl.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    tpl.cpp

Abstract:

    template file interpreter for tracewpp.exe
    
Author:

    Gor Nishanov (gorn) 03-Apr-1999

Revision History:

    Gor Nishanov (gorn) 03-Apr-1999 -- hacked together to prove that this can work
    GorN: 29-Sep-2000 - fix WHERE clause handling

ToDo:

    Clean it up

--*/

#define UNICODE

#include <stdio.h>
#include <windows.h>

#pragma warning(disable: 4786)
#pragma warning(disable: 4503) // decorated length 

#pragma warning(disable: 4512) // cannot generate assignment
#pragma warning(disable: 4100) // '_P' : unreferenced formal parameter
#pragma warning(disable: 4018) // signed/unsigned mismatch
#pragma warning(disable: 4267) // 'return' : conversion from 'size_t' to 'int' 
#include <xmemory>
#include <xstring>
#include <set>
#include <map>
#pragma warning(disable: 4663 4018)
#include <vector>
//#pragma warning(default: 4018 4663) // signed/unsigned mismatch
#pragma warning(default: 4100)

#include "ezparse.h"
#include "fieldtable.h"
#include "tpl.h"

LPCSTR FieldNames[] = {
    #define FIELD_NAME(f) #f,
        INSERT_FIELD_NAMES
    #undef FIELD_NAME
};

OBJECT_MAP ObjectMap;

typedef std::map<std::string, FieldId, strless> FIELD_MAP;

FIELD_MAP FieldMap;

void PopulateFieldMap() {
    #define FIELD_NAME(_name_) FieldMap[#_name_] = fid_ ## _name_;
      INSERT_FIELD_NAMES
    #undef FIELD_NAME

    FIELD_MAP::iterator i;
}

////////////////////////////////////////////////////////////////////////////////////////////

struct LoopVar : FieldHolder {
    Enumerator * Enum;
    std::string Name;

    LoopVar() {}

    DWORD PrintField(int fieldId, FILE* f, const Enumerator** pEnum) const {
        return Enum->GetData()->PrintField(fieldId, f, pEnum);
    }
};

///////////////////////////////////////////////////////////////////////////////////////////

char Delimiter = '`';

std::string COMMENT("*");

std::string FORALL("FORALL");
std::string ENDFOR("ENDFOR");

std::string IF("IF");
std::string ENDIF("ENDIF");

std::string DELIMITER("DELIMITER");
std::string INCLUDE("INCLUDE");
std::string ENV("ENV");

typedef enum Action {
    actText,
    actVar,
    actLoop,
    actIf,
    actInclude,
    actLiteralString,
} Action;

#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union
struct Chunk {
    struct {
        Action  action : 8;
        UCHAR   level  : 8;
        SHORT   loopEnd:16;
    };
    union {
        struct {
            LPCSTR textBeg;
            LPCSTR textEnd;
        };
        struct {
            FieldHolder * p;
            FieldId FieldNo;
            std::string Filter;
        };
    };

    Enumerator* getEnum() { 
        const Enumerator* Enum; p->PrintField(FieldNo, 0, &Enum); return (Enumerator*)Enum; }
    void printField(FILE* out) const {
        p->PrintField(FieldNo, out, 0); }  

    Chunk(){} // to make vector happy
    Chunk (Action Act, FieldHolder* fh, FieldId fid, int lvl, const std::string& filter):
        action(Act),FieldNo(fid),p(fh),level((UCHAR)lvl),Filter(filter) {} 
    Chunk (FieldHolder* fh, FieldId fid):action(actVar),FieldNo(fid),p(fh) {} 
    Chunk (LPCSTR b, LPCSTR e):action(actText),textBeg(b),textEnd(e) {}
    Chunk (Action act, LPCSTR b, LPCSTR e):action(act),textBeg(b),textEnd(e) {}
    explicit Chunk(std::string const& Text):action(actLiteralString),Filter(Text) {}
};

#define MAX_LOOP_LEVEL 127

struct TemplateProcessor {
    LoopVar Loop[MAX_LOOP_LEVEL];
    std::vector<Chunk> Chunks;

    void RunIt(int beg, int end, FILE* out) {
        for(int i = beg; i < end; ) {
            switch(Chunks[i].action) {
            	case actLiteralString:
            	{
            		fwrite(Chunks[i].Filter.c_str(), Chunks[i].Filter.length(), 1, out );
            		++i;
            		break;
            	}
                case actText:
                {
                    for(LPCSTR p = Chunks[i].textBeg; p < Chunks[i].textEnd; ++p) {
                        if (*p != '\r') putc(*p, out);
                    }
                    ++i;
                    break;
                }
                case actVar:
                {
                    Chunks[i].printField(out);
                    ++i;
                    break;
                }
                case actIf:
                {
                    if (!Chunks[i].p->Hidden(Chunks[i].Filter)) {
                        RunIt(i+1, Chunks[i].loopEnd, out);
                    }
                    i = Chunks[i].loopEnd;
                    break;
                }
                case actLoop:
                {
                    Enumerator * Enum = Chunks[i].getEnum();
                    Loop[Chunks[i].level].Enum = Enum;
                    for(Enum->Reset(Chunks[i].Filter); Enum->Valid(); Enum->Next(Chunks[i].Filter) ) {
                        RunIt(i+1, Chunks[i].loopEnd, out);
                    }
                    delete Enum;
                    i = Chunks[i].loopEnd;
                    break;
                }
                case actInclude:
                {
                    ProcessTemplate(Chunks[i].textBeg, Chunks[i].textEnd, out);
                    ++i;
                    break;
                }
            }
        }
    }

    void DoId(LPCSTR q, LPCSTR p, FieldId& fid, FieldHolder*& fh)
    {
        LPCSTR dot = q;

        while (q < p && isspace(*q)) ++q;
        while (q < p && isspace(p[-1])) --p;

        while (dot < p && *dot != '.') ++dot;

        std::string ObjectName(q, dot);
        OBJECT_MAP::iterator it = ObjectMap.find( ObjectName );

        if (it == ObjectMap.end()) {
            ReportError("Var not found: %s\n", ObjectName.c_str() );
            exit(1);
    	} else {
    		std::string FieldName;
    		
    		if (dot == p) {
    			fid = (FieldId)fid___default__;
    			FieldName.assign("__default__");
    		} else {
    			++dot;
    			while (p < dot && isspace(*dot)) ++dot;

    			FieldName.assign(dot,p);
    			
    			FIELD_MAP::iterator fit = FieldMap.find( FieldName.c_str() );
    			if (fit == FieldMap.end()) {
    				ReportError("FieldNotFound: %s.%s\n", ObjectName.c_str(), FieldName.c_str() );
                    exit(1);
    			} else {
    				fid = fit->second;
    			}
    		}
    	}
    	fh = it->second;
    }

    void DoVar(LPCSTR q, LPCSTR p) {
        FieldHolder* fh;
        FieldId      fid;

        DoId(q,p, fid, fh);
        
        Chunks.push_back( Chunk(fh, fid) );
    }

    void DoLoop(int loopLevel, LPCSTR beg, LPCSTR end) {
        FieldHolder* fh;
        FieldId      fid;

        std::string LoopVar;
        std::string LoopSet;
        std::string Filter;

        LPCSTR p,q;

        p = beg+6; while (p < end && isspace(*p)) ++p;
        q = p;     while(p < end && !isspace(*p)) ++p;

        LoopVar.assign(q,p);
        Loop[loopLevel].Name = LoopVar;

        p += 4; while (p < end && isspace(*p)) ++p;
        q = p;  while(p < end && !isspace(*p)) ++p;
        
        DoId(q,p, fid, fh);
        LoopSet.assign(q, p);

        p += 7; while (p < end && isspace(*p)) ++p;
        q = p;  
        if (q < end) {
            p = end; while(p > q && isspace(*--p));
            if (p < end && !isspace(*p)) ++p;
        }

        Filter.assign(q,p);

        Flood("FORALL %s IN %s WHERE %s\n", LoopVar.c_str(), LoopSet.c_str(),
            Filter.c_str());
        
        ObjectMap[LoopVar] = &Loop[loopLevel]; 

        Chunks.push_back( Chunk(actLoop, fh, fid, loopLevel, Filter) );
    }

    void DoIf(int loopLevel, LPCSTR beg, LPCSTR end) {
        FieldHolder* fh;
        FieldId      fid;

        std::string Object;
        std::string Filter;

        LPCSTR p,q;

        p = beg+3; while (p < end && isspace(*p)) ++p;
        q = p;     while(p < end && !isspace(*p)) ++p;

        DoId(q,p, fid, fh); // Split id //
        Object.assign(q, p);

        while (p < end && isspace(*p)) ++p;
        while (p < end && isspace(end[-1]) ) --end;

        Filter.assign(p,end);

        Flood("IF %s %s\n", Object.c_str(), Filter.c_str() );
        
        Chunks.push_back( Chunk(actIf, fh, fid, loopLevel, Filter) );
    }


    DWORD
    CompileAndRun(
        IN LPCSTR begin, 
        IN LPCSTR   end,
        IN FILE* out
        )
    {
        LPCSTR p = begin, PlainText = begin;
        int loop = -1;
        int loopLevel = -1;
        bool comment;

        Chunks.erase(Chunks.begin(), Chunks.end());
        Chunks.reserve(128);    

        for(;;) {
    		LPCSTR q;
    		for(;;) {
    			if (p == end) {
    				Chunks.push_back( Chunk(PlainText, p) );
    				goto done;
    			}				
    			if (*p == Delimiter)
    				break;
    			++p;
    		}
    		q = ++p;
    		comment = (p < end && *p == '*');
    		for(;;) {
    			if (p == end) {
    				ReportError("Unmatched delimiters\n");
    				exit(1);
    			}
    			if (*p == Delimiter) {
    			    if (comment) {
    			        if (p[-1] == '*') break;
    			    } else {
    			        break;
    			    }
    		    }
    			++p;
    		}
    		if (q-1 > PlainText) {
    			Chunks.push_back( Chunk(PlainText, q-1) );
    		}
    		if (p == q) {
    			// PERFPERF If the previous chunk was a text, we can extend it 
    			Chunks.push_back( Chunk(q-1, p) );
    		} else {
    			std::string x(q,p);
    			if (x.compare(0, IF.size(), IF) == 0) {
    				int previous = loop;
    				// KLUDGE merge with FORALL

                    if (loopLevel == MAX_LOOP_LEVEL) {
                        ReportError("Too many nested blocks!\n");
                        exit(1);
                    }
                    ++loopLevel;

    				loop = static_cast<int>( Chunks.size() );

    				DoIf(loopLevel, q,p);

                    if (previous >= 32765) {
                        ReportError("Too many chunks. Make loopEnd a UINT, %d\n", previous);
                        exit(1);
                    }
    				Chunks.back().loopEnd   = (SHORT)previous;

    				while (p+1 < end && (p[1] == '\n' || p[1] == '\r') ) ++p;
    				
    			} else if (x.compare(0, FORALL.size(), FORALL) == 0) {
    				int previous = loop;

                    if (loopLevel == MAX_LOOP_LEVEL) {
                        ReportError("Too many nested loops!\n");
                        exit(1);
                    }
                    ++loopLevel;

    				loop = static_cast<int>( Chunks.size() );

    				DoLoop(loopLevel, q,p);

                    if (previous >= 32765) {
                        ReportError("Too many chunks. Make loopEnd a UINT, %d\n", previous);
                        exit(1);
                    }
    				Chunks.back().loopEnd   = (SHORT)previous;

    				while (p+1 < end && (p[1] == '\n' || p[1] == '\r') ) ++p;
    				
    			} else if (x.compare(0, DELIMITER.size(), DELIMITER) == 0 && x.size() > 10) {
    			    Delimiter = x[10];
    			} else if (x.compare(0, ENV.size(), ENV) == 0) {
    			    // we need to replace this field with 
    			    // the value of the specified env variable
    			    LPCSTR val = getenv( std::string(q+4,p).c_str() );
    			    if (val != NULL) {
                        Chunks.push_back( Chunk(std::string(val)) );
    			    }
    			} else if (x.compare(0, COMMENT.size(), COMMENT) == 0) {
    			    // eat away the whitespace
    				while (p+1 < end && (p[1] == '\n' || p[1] == '\r') ) ++p;
    			} else if (x.compare(0, INCLUDE.size(), INCLUDE) == 0) { // Doesn't work
        			Chunks.push_back( 
        			    Chunk(actInclude, q + INCLUDE.size() + 1, p) );
    			} else if ((x.compare(0, ENDIF.size(), ENDIF) == 0) 
    			       || (x.compare(0, ENDFOR.size(), ENDFOR) == 0)) {

    			    // KLUDGE make them separate or rename both to simply END   

    				// End will be set in ENDFOR //
    				if (loop == -1) {
    					ReportError("ENDFOR without FORALL\n");
    					exit(1);
    				}

                    ObjectMap.erase( Loop[loopLevel].Name );

    				int previous = Chunks[loop].loopEnd;

                    // BUGBUG have a check that confirms that we didn't run out of space
    				Chunks[loop].loopEnd = (SHORT)Chunks.size();

    				loop = previous;
    				--loopLevel;

    				while (p+1 < end && (p[1] == '\n' || p[1] == '\r') ) ++p;
    			} else {
    				DoVar(q, p);
    			}
    		}
    		PlainText = ++p;
    	}
    done:;	
    	if (loop != -1) {
    		ReportError("No ENDFOR for loop, %d\n", loop);
    		exit(1);
    	}

    	RunIt(0, static_cast<int>( Chunks.size() ), out);

        return 0;
    }
};

    
DWORD
processTemplate(
    IN LPCSTR begin, 
    IN LPCSTR   end,
    IN EZPARSE_CALLBACK, 
    IN PVOID Context,
    IN PEZPARSE_CONTEXT
    )
{
    FILE *out = (FILE*)Context;
    TemplateProcessor tpl;
    return tpl.CompileAndRun(begin,end,out);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracewpp\tracewpp.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    tracewpp.c

Abstract:

    Parameter processing and main entry point for tracewpp.exe
    
Author:

    Gor Nishanov (gorn) 03-Apr-1999

Revision History:

    gorn 03-Apr-1999 -- hacked together to prove that this can work

    GorN: 29-Sep-2000 - do not scan files that didn't change
    GorN: 29-Sep-2000 - support -notimechk -nohashchk -dll switches
    GorN: 29-Sep-2000 - add support for KdPrintEx((level,comp,msg,...)) like functions
    GorN: 09-Oct-2000 - fix hashing; added NULL arg
    GorN: 07-Mar-2001 - add arglimit option
    
ToDo:

    all              Clean it up
    parseConfigCheck for premature termination Ex: CUSTOM_TYPE(x, ItemListLong(dfdf))
    cool             Automatic fill of the arguments if ...
    nice             better error chk 
    types to mof     it stinks to generate long enums multiple times
    later            guidless
    bug              check for types with dup names
    bug              tpl: check for unterminated keyword
    later            detect WPP_CLEANUP -- complain
    print in macros  what to do about prints in macro?
    cmdline          get the flags from the env variable
    !!!              Don't assume that whatever is not recognized is func
    bug              updated CRC computations to properly work with consts
    bug              enum doesn't work
    bug              %10!..! doesnt' work
    bug              %% is not handled
    mess             rename hidden => visible
    mess             remove ugly MSGTYPBASE. Make FmtStr 0 based
    mess             let message share some of the func field handlers
    traceprt         think how to make the level indenting
    ezparse          report unmatched end_wpp    
    now              get cmdline options from a file or env.var
    later            handle "str" STRMACRO "another string" as a MSG arg
    
    strange output

..\logsup.c(4180) : error : Unterminated Format SpecifierHere is the signature: (0)
..\logsup.c(4180) : error : Extra argument. Only 0 are specified in the string

    why we didn't catch the error

                CsDbgPrint(LOG_NOISE,
                ("[FM] FmpSetGroupEnumOwner: Group %1!ws! not found\n"));

        CsDbgPrint(LOG_UNUSUAL, (
            "[NMJOIN] Cannot add node '%1!ws!' to the cluster because "
            "no slots are available in the node table.\n"
            ));

    printf("Port no in network order %1!port!, regular order %1!u!, 0x0102);

NetDeviceTrace( NETDEV_DBG_EXIT | NETDEV_DBG_INFO,
                "ClientMdlSetup Client[%10!d!], RCB[%11!d!]: "
                "Exit w/ Func 0x%12!04X!, Send 0x%14!04X!, Recv 0x%15!04X!",
                deviceExtension->Ordinal, // LOGULONG
                RequestCB->RequestIdx, // LOGUSHORT
                ios->MajorFunction, // LOGUCHAR
                ios->MajorFunction, // LOGUCHAR
                sendBytes, // LOGULONG
                recvBytes); // LOGULONG => AV's

    DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE

    later            handle KdPrintEx
    later            add "if" to templates (at least if not empty)
    requirement      md5
    later            detect WPP_INIT_TRACING
    main             Time ourselves and print how fast we are
    useful           ignore anything but .c .cxx .cpp .c++
    useful           -gen{a,b,c}h.tpl
    -ext:.c.cxx.cpp.c++
    -v verbose
    -q extra quiet
    footprint        merge multiple formats together
    difficult?       Think how to unify DoTraceMacro0 TraceLazy, etc
    figureout        DbgPrint
    -odir:path
    trivial          add "\" to -odir if needed
    nice             scan
    -gen:{a.tpl}auto.c
    -gen:{a.tpl}*.c
    outstanding      take plain DebugPrint format as well
    difficult?       Add generation of by value types
    
--*/

#define STRICT

#include <stdio.h>
#include <windows.h>
#include <rpc.h>
#include <rpcdce.h>

#pragma warning(disable: 4702) // unreachable code

#pragma warning(disable: 4786)
#pragma warning(disable: 4503) // decorated length 

#pragma warning(disable: 4512) // cannot generate assignment
#pragma warning(disable: 4100) // '_P' : unreferenced formal parameter
#pragma warning(disable: 4267) // 'return' : conversion from 'size_t' to 'int' 
#include <xmemory>
#include <xstring>
#include <set>
#include <map>
#pragma warning(disable: 4663)
#pragma warning(disable: 4018) // signed/unsigned mismatch
#include <vector>
//#pragma warning(default: 4018 4663) // signed/unsigned mismatch
#pragma warning(default: 4100)
#include <algorithm>

#include "ezparse.h"
#include "crc32.h"
#include "md5.h"
#include "fieldtable.h"
#include "tpl.h"

#define override

//typedef ULONG CRC32;

using namespace std;

BOOL    md5 = TRUE;
BOOL    reorder = FALSE;
BOOL    userMode = TRUE;
BOOL    noshrieks = FALSE;
UINT    SeparateTraceGuidPerFile = 1;
INT     MSGTYPBASE = 10;
UINT    MessageCount = 0;    
UINT    ArgBase = 1;
BOOL    CheckTimestamp = TRUE;
BOOL    CheckHash = TRUE;
BOOL    IgnoreDupTypes = FALSE;
int     arglimit = 32;

//string         OutputInc ("_tracewpp.h");
//string         OutputMof ("_tracewpp.mof");
string  OutputMac;
string  OutputDir (".\\");
//string         ArrayPrefix("WPP_");

string  MacroPrefix("LOG");
string  AllowedExtensions(".c.cxx.cpp.c++.C.CPP");
string  CurrentDir;


#define DEFAULT_UM_GEN_OPTION "{um-default.tpl}*.tmh"
#define DEFAULT_KM_GEN_OPTION "{km-default.tpl}*.tmh"

#define DEFAULT_GEN_OPTION (userMode?DEFAULT_UM_GEN_OPTION:DEFAULT_KM_GEN_OPTION)

#define DEFAULT_CONFIG_NAME "defaultwpp.ini"
string LOCAL_CONFIG_NAME("localwpp.ini");

string         WppDefault(DEFAULT_CONFIG_NAME);
vector<string> SearchDirs;
//string         Revision;
string         LocalConfig;
string         ComponentName;

// Checks whether string passed has an allowed extension
// Lame: uses global variable AllowedExtensions
BOOL AllowedExtension(const string str)
{
    string::size_type p = str.rfind('.'), q, n;
    if (p == string::npos) {
        Unusual("File %s has no extension\n", str.c_str() );
        return FALSE;
    }
    n = str.size() - p; // extension length
    q = AllowedExtensions.find(&str[p], 0, n);
    if ( (q == string::npos) 
    || (q + n < AllowedExtensions.size() && AllowedExtensions[q + n] != '.') ) 
    {
        Unusual("File %s has unrecognized extension\n", str.c_str() );
        return FALSE;
    }
    return TRUE;
}

inline size_t fprint_str(FILE* f, const string& str) {
    return fwrite(str.c_str(), str.length(), 1, f );
}

inline size_t fprint_str(FILE* f, LPCSTR beg, LPCSTR end) {
    return fwrite(beg, end - beg, 1, f );
}

inline size_t fprint_str(FILE* f, const STR_PAIR& Pair) {
    return fwrite(Pair.beg, Pair.end - Pair.beg, 1, f );
}

inline int stoi(const STR_PAIR& str, LPCSTR name)
{
    LPCSTR p = str.beg;
    int sum = 0;
    int sgn = 1;

    if (p < str.end && *p == '-') {
        ++p; sgn = -1;
    }

    while (p < str.end) {
        if (!isdigit(*p)) {
            ReportError("%s should be a number (%s supplied)\n",
                        name, string(str.beg, str.end).c_str() );
            break;            
        }
        sum = 10 * sum + (*p - '0');
        ++p;
    }
    return sgn * sum; 
}

inline unsigned char HexVal(int ch) { 
	return (unsigned char)(isdigit(ch) ? ch - '0' : ch - 'a' + 10); }

UINT Hex(LPCSTR s, int n) 
{
    UINT res = 0;
    while(n--) {
        res = res * 16 + HexVal(*s++);
    }
    return res;
}

CHAR HexDigit(int val) { 
    if (val < 10) return (CHAR)(val + '0'); 
             else return (CHAR)(val + 'a' - 10);
}

ULONGLONG GetFileModificationTime(const string& str)
{
    WIN32_FIND_DATA FindData;
    ULONGLONG Time;
    
    HANDLE FindHandle = FindFirstFile(str.c_str(), &FindData);
    if (FindHandle == INVALID_HANDLE_VALUE) {
        return 0;
    }
    FindClose(FindHandle);

    CopyMemory(&Time, &FindData.ftLastWriteTime, sizeof(Time));
    return Time;
}

// Prototypes //

void DealWithCmdLineOptions(LPCSTR s);

void DealWithCmdLineOptions(LPCSTR beg, LPCSTR end)
{
    DealWithCmdLineOptions(string(beg,end).c_str() );
}


struct Hasher {
    virtual void Init() = 0;
    virtual void Finalize() = 0;
    virtual void Hash(const void* buf, int nBytes) = 0;
    virtual int Size() const = 0;
    virtual const unsigned char * Buf() const = 0;

    void Hash(const std::string& str) {
        Hash(str.begin(), (int)str.size());
    }

    void fromString(LPCSTR beg, LPCSTR end) 
    {
        int n = min((ULONG)(end - beg)/2, Size());
        unsigned char * buf = BufRW();
        ZeroMemory(buf, Size());
        for(int i = 0; i < n; ++i) {
            buf[i] = HexVal(beg[2*i]) * 16 + HexVal(beg[2*i + 1]);
        }
    }
    void print(FILE* out) const {
        int n = Size();
        const UCHAR* buf = Buf();
        for(int i = 0; i < n; ++i) {
            fprintf(out, "%x%x", buf[i] >> 4, buf[i] & 0xF); 
        }
    }

    bool operator ==(const Hasher& b) const {
        return Size() == b.Size() && memcmp(Buf(), b.Buf(), Size()) == 0;
    }
    
private:
    unsigned char* BufRW() { return (unsigned char*)Buf(); }
};

class Crc32Hasher : public Hasher 
{
    ULONG Crc;
public:
    override void Init() { Crc = (ULONG)~0; }
    override void Finalize() {}
    override void Hash(const void* buf, int nBytes) {
        Crc = FstubCrc32(Crc, (PVOID)buf, nBytes);
    }
    override int Size() const { return sizeof(Crc); }
    override const unsigned char * Buf() const { return (UCHAR*)&Crc; }
};

class Md5Hasher : public Hasher
{
    MD5_CTX Ctx;
public:
    override void Init() 
    {
        MD5Init(&Ctx);
    }
    override void Finalize() 
    {
        MD5Final(&Ctx);
    }
    override void Hash(const void* buf, int nBytes) 
    {
        MD5Update(&Ctx, (const unsigned char*)buf, nBytes); 
    }
    virtual int Size() const
    {
//        assert(MD5DIGESTLEN == sizeof(GUID));
        return MD5DIGESTLEN; // == 16
    }
    virtual const unsigned char * Buf() const
    {
        return Ctx.digest;
    }
};

//typedef Crc32Hasher DefaultHasher;
typedef Md5Hasher DefaultHasher;

void ReplaceCrOrLfWith(string& s, char ch)
{
    for(int i = 0; i < s.size(); ++i) {
        if (s[i] == '\n' || s[i] == '\r') s[i] = ch;
        if (s[i] == '"') s[i] = '\'';
    }
}

string currentFileName();

bool
Files_AddFile(const string& Name, string Path, const WIN32_FIND_DATA& FindData) ;

enum {
    WT_MACRONAME = 0x00000001, // TypeName is actually a MacroName. Don't have to be prepended with Log Macro Prefix
};

struct WppType : FieldHolder {
    string TypeName;
    string EquivType;  // c-type
    string MacroStart; // WPP_LOGVALARG(%s, if not specified
    string MofType;    // yeah
    string Extension; // something to be merged with MofType
    string FormatSpec; // sprintf style    
    string Sig;
    int priority;
    int ArgConsumed;
    mutable BOOL   Used;
    DWORD  Flags;

    void hash(Hasher& hash) const {hash.Hash(TypeName);} // BUGBUG ?? Maybe we need to hash it

    string sig() const { return Sig; }
    bool isConstant() const { return EquivType.size() == 0; }

    WppType() {} // To make STL happy

    WppType(const string& a, const string&b, const string& c, 
            const string& d, const string& e, const string& f, 
            const string& g, int prio, int argConsumed):
        TypeName(a), EquivType(b), MacroStart(c), MofType(d),  
        Extension(e), FormatSpec(f), Sig(g), 
        priority(prio),Used(0),ArgConsumed(argConsumed) {}

//    WppType(LPCSTR beg, LPCSTR end):TypeName(beg, end),Used(0){}
//    explicit WppType(char name):TypeName(&name, &name+1),Used(0){}
    bool operator < (const WppType& b) const {
        int diff = b.priority - priority; // higher prio first
        if (diff < 0) return TRUE;
        if (diff > 0) return FALSE;
        return TypeName.compare(b.TypeName) < 0;
    }

    virtual BOOL Hidden(std::string) const { return !Used; }

    BEGIN_FIELD_TABLE(WppType, f)
        TEXT_FIELD(Name)       fprint_str(f, TypeName);
        TEXT_FIELD(EquivType)  fprint_str(f, EquivType);
        TEXT_FIELD(MacroName)  
            { 
                if (!(Flags & WT_MACRONAME)) fprint_str(f, MacroPrefix);
                fprint_str(f, TypeName);
            }
        TEXT_FIELD(MacroStart) fprintf(f, MacroStart.c_str(), EquivType.c_str());
        TEXT_FIELD(MacroEnd)   fprintf(f, ")");
        TEXT_FIELD(MofType)    fprint_str(f, MofType);
        TEXT_FIELD(Extension)  fprint_str(f, Extension);
        TEXT_FIELD(FormatSpec) fprint_str(f, FormatSpec);
    END_FIELD_TABLE
};
typedef map<string,WppType,strless> TYPE_SET;

string SimpleValueMacroStart("WPP_LOGTYPEVAL(%s,");
string SimplePtrMacroStart("WPP_LOGTYPEPTR(");

TYPE_SET TypeSet;

struct Argument : FieldHolder {
    const WppType* Type;
    string Name;
    string OverrideName;
    int    No;

    bool operator < (const Argument& b) const { return *Type < *b.Type; }

    Argument(){} // To make STL happy //
    Argument(string name, const WppType* type):Type(type),Name(name)
        { ReplaceCrOrLfWith(Name, ' '); }

    void hash(Hasher& hash) const {
        hash.Hash(Name);
        if(Type) Type->hash(hash);
    }

    BEGIN_FIELD_TABLE(Argument, f)
        TEXT_FIELD(No)      {fprintf(f, "%d",   No);}
        TEXT_FIELD(Name)    {fprint_str(f, Name);}
        TEXT_FIELD(MofType) {fprint_str(f, Type->MofType); fprint_str(f,Type->Extension);}
    END_FIELD_TABLE
};

struct Reorder : FieldHolder {
    string Name;
    vector<int> Args;

    Reorder(){} // to make stl happy
    explicit Reorder(string name, const vector<Argument>& args): Name(name) 
    {   Args.resize( args.size() );
        for(int i = 0; i < args.size(); ++i) {
            Args[i] = args[i].No - MSGTYPBASE;
        }
    }

    bool operator < (const Reorder& b) const 
        { return Name.compare(b.Name) < 0; }

    BEGIN_FIELD_TABLE(Reorder, f)
        TEXT_FIELD(Name) fprint_str(f, Name);
        TEXT_FIELD(Permutation) 
            {
                for(int i = 0; i < Args.size(); ++i) {
                    fprintf(f, ", a%d", Args[i]);
                }
            }
        TEXT_FIELD(Arguments) 
            {
                fprintf(f,"MSG");
                for(int i = 0; i < Args.size(); ++i) {
                    fprintf(f, ", a%d", i);
                }
            }
    END_FIELD_TABLE    
};

set<Reorder> ReorderSet; 

string GetReorderSig(const vector<Argument>& args)
{
    string sig;

    if (args.size() > 256) {
        ReportError("Only upto 256 arguments are supported\n");
        return sig;
    }
    if (args.size() <= 16) {
        sig.resize(args.size());
        for(int i = 0; i < args.size(); ++i) {
            sig[i] = HexDigit(args[i].No - MSGTYPBASE);
        }
    } else {
        sig.resize(2 * args.size());
        for(int i = 0; i < args.size(); ++i) {
            int val = args[i].No;
            sig[2 * i] = HexDigit(val >> 16);
            sig[2 * i + 1] = HexDigit(val & 15);
        }
    }

    ReorderSet.insert( Reorder(sig, args) );
    return sig;
}



#include "parsed-string.hxx"

struct TypeSig : FieldHolder {
    string Name;
    vector<const WppType*> Types;
    BOOL Unsafe;

    TypeSig() {} // To make STL happy

    TypeSig(const vector<Argument>& args, const string& sig, BOOL unsafe):
        Unsafe(unsafe)
    {
        Name.assign(sig);
        for(int i = 0; i < args.size(); ++i) {
            Types.push_back(args[i].Type);
        }
    }

    bool operator < (const TypeSig& b) const {
        return Name.compare(b.Name) < 0;
    }
    
    virtual BOOL Hidden(std::string str) const {
        if (str.size() == 0) { return FALSE; }
        else if (str.compare("UnsafeArgs") == 0) { return !Unsafe; }
        else if (str.compare("!UnsafeArgs") == 0) { return Unsafe; }
        else { ReportError("Unknown filter '%s'\n", str.c_str()); exit(1); }
        return NULL; 
    }
    
    BEGIN_FIELD_TABLE(TypeSig, f)
        TEXT_FIELD(Name)       fprint_str(f, Name);
        TEXT_FIELD(Count)      fprintf(f, "%d", Name.size());
        TEXT_FIELD(Arguments)  
            {
                for(int i = 0; i < Types.size(); ++i) {
                    fprintf(f,", ");
                    fprint_str(f, Types[i]->EquivType);
                    fprintf(f, " _a%d", i+1);
                }
            }
        TEXT_FIELD(LogArgs) 
            {
                for(int i = 0; i < Types.size(); ++i) {
                    fprintf(f, Types[i]->MacroStart.c_str(), 
                               Types[i]->EquivType.c_str());
                    fprintf(f, "_a%d) ", i+1);
                }
            }
        TEXT_FIELD(DeclVars) 
            {
                for(int i = 0; i < Types.size(); ++i) {
                    fprintf(f, "%s _a%d = va_arg(ap, %s); ", 
                    Types[i]->EquivType.c_str(), i+1,
                    Types[i]->EquivType.c_str());
                }
            }
    END_FIELD_TABLE
};
typedef map<string,TypeSig,strless> TYPESIG_MAP;
TYPESIG_MAP TypeSigMap;

TypeSig* GetTypeSig(const vector<Argument>& args, BOOL unsafe)
{
    string sig;
    if (unsafe) {
        sig.assign("v");
    }
    for(int i = 0; i < args.size(); ++i) {
        sig.append(args[i].Type->sig() );
    }
    TYPESIG_MAP::iterator it = TypeSigMap.find( sig );
    if ( it == TypeSigMap.end() ) {
        // we need to add one //
        return &(TypeSigMap[ sig ] = TypeSig(args, sig, unsafe));
    }
    return &it->second;
}

void Fill(
    string pattern)
{
    WIN32_FIND_DATA findData;
    HANDLE handle;

    handle = FindFirstFile(pattern.c_str(), &findData);
    if (handle == INVALID_HANDLE_VALUE) {
        DWORD status = GetLastError();
        if (status != ERROR_FILE_NOT_FOUND) {
            Noise("FindFirstFile(%s): error %d\n", pattern.c_str(), GetLastError() );
        }
        return;
    }

    string::size_type p = pattern.find_last_of(":\\");
    if (p != string::npos) {
        pattern.resize(p+1); // to include the symbol
    } else {
        pattern.resize(0);
    }

    do {
        Files_AddFile(findData.cFileName, pattern, findData);
    } while( FindNextFile(handle, &findData) );

    FindClose(handle);
}

struct Group : FieldHolder {
    UINT GrpId;
    vector<string> MsgIds;
    string _Name;

    Group(){}
    Group(UINT id, string Name, string Msg):GrpId(id),_Name(Name) { MsgIds.push_back(Msg); }

    BEGIN_FIELD_TABLE(Group, f) 
        TEXT_FIELD(GuidNo) fprintf(f, "%d", GrpId / 32);
        TEXT_FIELD(BitNo)  fprintf(f, "%d", GrpId & 31);
        TEXT_FIELD(Name)   fprint_str(f, _Name);
        TEXT_FIELD(References) 
            {
                vector<string>::const_iterator i;
                for(i = MsgIds.begin(); i != MsgIds.end(); ++i) {
                    putc(' ', f); fprint_str(f, *i); 
                }
            }
    END_FIELD_TABLE
};

//void RegenerateMacroMap();

struct Prefix{
    string FuncName;
//    string MsgPrefix;
//    vector<Argument> Args;
    ParsedFormatString FmtStr;

    Prefix(){}
    Prefix(PSTR_PAIR str, UINT count);
};

int inline sign(UCHAR val) { return val?1:0; }

enum FuncOptions {
    FO_VAR_ARGS = 0x01,
    FO_UNSAFE   = 0x02,
    FO_DOUBLEP  = 0x04,
    FO_LINE_BEG = 0x08,
    FO_NOMACRO  = 0x10,
};

struct Func : FieldHolder {
    const Prefix *prefix, *suffix;
    string _name;
    vector<string> Args;  // all supplied args - var args
    vector<string> Goo;   // values for GooId, usually = GooId
    vector<string> GooId; // all unrecognized args + LEV
    
    UCHAR Grp, MsgArg, Msg, Arg;
    UCHAR Num, Indent, MsgVal, Reserved;

    ULONG Options;
    size_t nAssumedArgs;

    void SetPS(const Prefix* val, const Prefix*& var, LPCSTR msg)
    {
        if (val && val->FmtStr.ArgCount > 0 && MsgArg) {
            ReportError("Function %s has (something,(MSG,...)) type\n"
                        "It cannot have non-const %s\n",
                        _name.c_str(), msg );
        }
        var = val;
    }

    void set(ULONG flag) { Options |= flag; }
    ULONG is(ULONG flag) const { return Options & flag; }
    void SetLineBeg() { Options |= FO_LINE_BEG; }
    void SetVarArgs() { Options |= FO_VAR_ARGS | FO_LINE_BEG; }
    void SetUnsafe()  { Options |= FO_UNSAFE; }
    void SetDoubleP() { Options |= FO_DOUBLEP; }

    BOOL LineBeg() const { return Options & FO_LINE_BEG; }
    BOOL VarArgs() const { return Options & FO_VAR_ARGS; }
    BOOL Unsafe() const  { return Options & FO_UNSAFE; }
    BOOL DoubleP() const { return Options & FO_DOUBLEP; }

    void SetPrefix(const Prefix* pr) { SetPS(pr,prefix,"prefix"); }
    void SetSuffix(const Prefix* sf) { SetPS(sf,suffix,"suffix"); }

    virtual BOOL Hidden(std::string str) const {
        if (str.size() == 0) { return FALSE; }
        if (is(FO_NOMACRO)) return str.compare("NoMacro") != 0;
        else if (str.compare("MsgArgs") == 0) { return !MsgArg; }
        else if (str.compare("!MsgArgs") == 0) { return MsgArg; }
        else if (str.compare("!DoubleP && !MsgArgs") == 0) { return !(!DoubleP() && !MsgArg); }
        else if (str.compare("DoubleP && !MsgArgs") == 0) { return !(DoubleP() && !MsgArg); }
        else { ReportError("Unknown filter '%s'\n", str.c_str()); exit(1); }
        return NULL; 
    }

#if 0
    // returns recognized argument count
    int count() const {
        return sign(Grp) + sign(Id) + sign(Msg) + sign(Arg);
    }
#endif
    void printArgs(FILE* f) const {
        for(int i = 1; i <= Num; ++i) {
            if (i > 1) fprintf(f, ", ");
            else fprintf(f, "(");
            fprint_str(f, Args[i]);
/*
            if (i == Grp) fprintf(f,"GRP");
            else if (i == Id) fprintf(f,"ID");
            else if (i == Msg) fprintf(f,"MSG");
            else if (i == Arg) fprintf(f,"ARG");
            else fprintf(f,"_unknown%d", i);
*/            
        }
        fprintf(f, ")");
    }

    BEGIN_FIELD_TABLE(Func, out)
        TEXT_FIELD(Name) fprintf(out, "%s", _name.c_str() );
        TEXT_FIELD(Arguments) {printArgs(out);}
        TEXT_FIELD(MSG) {fprintf(out, Msg?"MSG":"\"\"");}
        TEXT_FIELD(ARG) {fprintf(out, Arg?"ARG":"");}
        TEXT_FIELD(GRP) {fprintf(out, Grp?"GRP":"WPP_DEFAULT_GROUP_ID");}
//        TEXT_FIELD(ID)  {fprintf(out,  Id?"ID":"WPP_AUTO_ID");}
        TEXT_FIELD(FixedArgs) 
            {
                for(int i = 0; i < Args.size(); ++i) {
                    fprint_str(out, Args[i]);
                    fprintf(out,", ");
                }
            } 
        TEXT_FIELD(GooArgs)
            {
                for(int i = 0; i < GooId.size(); ++i) {
                    if (i > 0) fprintf(out,",");
                    fprint_str(out, GooId[i]);
                }
            }
        TEXT_FIELD(GooVals) 
            {
                for(int i = 0; i < Goo.size(); ++i) {
                    if (i > 0) fprintf(out,", ");
                    fprint_str(out, Goo[i]);
                }
            }
        TEXT_FIELD(GooId)
            {
                for(int i = 0; i < GooId.size(); ++i) {
                    fprintf(out,"_");
                    fprint_str(out, GooId[i]);
                }
            }
    END_FIELD_TABLE

    Func(){}
    Func(std::string Name):_name(Name),prefix(0),suffix(0),
        Grp(0), MsgArg(0), Msg(0), Arg(0),
        Num(0), Indent(0), MsgVal(0), Options(0),nAssumedArgs(0) {}
};

#define GRP(x) ((x).Grp)
#define MSG(x) ((x).Msg)
#define ARG(x) ((x).Arg)
#define NUM(x) ((x).Num)

//BOOL
//UpgradeFormatSpecifiers(string& str, int startCount, string* TypeSig = 0);

void printTraceGuid(FILE* f, int guidno);

struct Message : FieldHolder {
//    string Msg;
    string IdName;
    string msgval;
    string Indent;
    string reorderSig;
    int    LineNo;
    ParsedFormatString FormatStr;
    TypeSig* typeSig;
    const Func*    func;

	vector<Argument> Args;
	vector<string> GooActualValues;

    UINT id;
	string TypeListHost;

    virtual BOOL Hidden(std::string str) const { return func->Hidden(str); }

	void hash(Hasher& hash) const;
	int ArgConsumed() const ;
	
//  void ChkArgs() const;
    
    BEGIN_FIELD_TABLE(Message, f)
        TEXT_FIELD(T