har *)ios_empty_in, 0, (64*1024)/8);
		memset((char *)ios_empty_out, 0, (64*1024)/8);
	}
#endif /* PROD */

	for (i = 0; i < PC_IO_MEM_SIZE; i++){
	    Ios_in_adapter_table[i] = EMPTY_ADAPTOR;
	    Ios_out_adapter_table[i] = EMPTY_ADAPTOR;
	}
}


#ifdef NTVDM
GLOBAL char GetExtIoInAdapter (io_addr ioaddr)
{
#ifndef PROD
    printf("GetExtIoInAdapter(%x) called\n",ioaddr);
#endif
    return EMPTY_ADAPTOR;
}

GLOBAL char GetExtIoOutAdapter (io_addr ioaddr)
{
#ifndef PROD
    printf("GetExtIoOutAdapter(%x) called\n",ioaddr);
#endif
    return EMPTY_ADAPTOR;
}
#endif /* NTVDM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\support\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=support
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc

SOURCES=                ..\terminat.c    \
                        ..\time_day.c    \
                        ..\ios.c \
                        ..\main.c \
                        ..\get_env.c \
                        ..\xt.c

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC
!INCLUDE $(SOFTPC_TREE)\base\condincl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\support\main.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title	: Main program
 *
 * Description	: Call initialisation functions then call simulate to
 *	 	  do the work.
 *
 * Author	: Rod Macgregor
 *
 * Notes	: The flag -v tells SoftPC to work silently unless
 *		  an error occurs.
 *
 */

/*
 * static char SccsID[]="@(#)main.c	1.49 06/23/95 Copyright Insignia Solutions Ltd.";
 */


/*
 * O/S includes
 */

#include <stdlib.h>
#include <stdio.h>
#include TypesH

/*
 * SoftPC includes
 */

#include "xt.h"
#include "sas.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "gvi.h"
#include "host.h"
#include "trace.h"
#ifdef SECURE
#include "debug.h"
#endif
#include "gmi.h"
#include "gfx_upd.h"
#include "cmos.h"
#include "gfi.h"
#include "timer.h"
#include "yoda.h"
//#include "host_env.h"

extern	void	host_start_cpu();	/* Start up the Intel emulation */

GLOBAL VOID    mouse_driver_initialisation(void);
GLOBAL void    InitialiseDosEmulation(int, char **);
GLOBAL ULONG   setup_global_data_ptr();

void init_virtual_drivers IPT0();

IMPORT void host_set_yoda_ints IPT0();
IMPORT void host_applClose IPT0();
#if defined(NEC_98)
IMPORT void setup_NEC98_globals IPT0();
#else    //NEC_98
IMPORT void setup_vga_globals IPT0();
#endif   //NEC_98
#ifdef ANSI
extern void host_applInit(int argc, char *argv[]);
#else
extern void host_applInit();
#endif	/* ANSI */

#ifdef REAL_VGA
extern int screen_init;
#endif

/* Have global variables defined here to indicate what product to run as. */

#ifdef SOFTWINDOWS
GLOBAL IBOOL Running_SoftWindows = TRUE;
GLOBAL CHAR *SPC_Product_Name = "SoftWindows";
#else
GLOBAL IBOOL Running_SoftWindows = FALSE;
GLOBAL CHAR *SPC_Product_Name = "SoftPC";
#endif /* SOFTWINDOWS */

GLOBAL char **pargv;	/* Pointer to argv		*/
GLOBAL int *pargc;	/* Pointer to argc		*/

#ifndef NTVDM
#ifndef ProcCommonCommLineArgs
extern VOID ProcCommonCommLineArgs IPT2(LONG, argc, CHAR, *argv[]);
#endif /* ProcCommonCommLineArgs */
#endif /* NTVDM */

/* Does this host need to have a different entry point ? */

#if defined(NTVDM) || defined(host_main)
INT host_main IFN2(INT, argc, CHAR **, argv)
#else   /* host_main */
INT      main IFN2(INT, argc, CHAR **, argv)
#endif  /* host_main */
{

#ifndef	CPU_40_STYLE
  IMPORT ULONG Gdp;
#endif	/* CPU_40_STYLE */

#ifdef SECURE
	char * sys_config_filename;
	ErrData err_data;
#endif

#ifdef	SETUID_ROOT

	/* make sure the real and effective UIDs are OK */
	host_init_uid ();

#endif	/* SETUID_ROOT */

#if !defined(PROD) || defined(HUNTER)

	trace_init();		/* set up the trace file */

#endif /* !PROD || HUNTER */

/***********************************************************************
 *								       *
 * Set up the global pointers to argc and argv for lower functions.    *
 * These must be saved as soon as possible as they are required for    *
 * displaying the error panel for the HP port.  Giving a null pointer  *
 * as the address of argc crashed the X Toolkit.		       *
 *								       *
 ***********************************************************************/

  pargc = &argc;
  pargv = argv;

#if !defined(NTVDM) && !defined(macintosh) && !defined(VMS)
  setupEnv(argc,argv);	/* set up Unix run-time environment */
#endif	/* NTVDM, macintosh, VMS */

#ifndef PROD
  host_set_yoda_ints();
#endif /* !PROD */

#ifdef SECURE
  err_data.string_1 = err_data.string_2 = err_data.string_3 = "";
#endif

#ifndef NTVDM
  ProcCommonCommLineArgs(argc,argv);
#endif /* NTVDM */
  host_applInit(argc,argv);	/* recommended home is host/xxxx_reset.c */

#ifdef SECURE
  /* Now that error panels are available, Validate SoftWindows Integrity. */
  sys_config_filename = host_expand_environment_vars(SYSTEM_CONFIG);
  if (!host_validate_swin_integrity(sys_config_filename))
  {
#ifdef PROD
    err_data.string_3 = sys_config_filename;
    (VOID) host_error_ext(EG_SYS_INSECURE, ERR_QUIT, &err_data);
    exit(1);
#else
    always_trace1("Secure Mode ERROR:\"%s\" is insecure.", sys_config_filename);
#endif
  }
#endif
#if defined(CPU_40_STYLE) && !defined(CCPU)
  {
	extern void parse_lc_options IPT2(int *,pargc, char ***,pargv);

  	parse_lc_options(&argc,&argv);
  }
#endif /* assembler 4.0 cpu */

  verbose = FALSE;

#ifndef PROD
  io_verbose = FALSE;
#endif

  /*
   * Pre-Config Base code initilisation.
   *
   * Setup the initial gfi funtion pointers before going into config
   */
#ifndef NEC_98
  gfi_init();
#endif   //NEC_98

  /*
   * Initialise any Windows 3.x compliant DOS Drivers.
   * We do it here as config (and who knows who else) believe they can
   * access certain driver data at any time. Logically it ought to be done
   * when the driver is loaded under DOS, however historically it used to
   * be done as Static Data initialisation, so we mirror this old method
   * as closely as possible.
   *
   * The mac doesn't use the base config system and so calls init_virtual_drivers()
   * as part of it's host_applInit().
   */

#ifndef	macintosh
  init_virtual_drivers();
#endif

/*
 * Find our configuration
 *------------------------*/

  config();

#if defined(PROFILE) && !defined(CPU_40_STYLE)
/*
 * Stick this after config as Gdp must be set up. 4.0 calls ProfileInit from
 * sas_init() to ensure everything included.
 */
  ProfileInit();
#endif	/*PROFILE*/

#ifndef NEC_98
#if defined(NTVDM) || defined(macintosh)
/* Read the cmos from file to emulate data not being
 * lost between invocations of SoftPC
 *-----------------------------------------------------*/

  cmos_pickup();
#endif	/* defined(NTVDM) || defined(macintosh) */

#if !defined(PROD) || defined(HUNTER)

/******************************************************************
 *								  *
 * Bit of a liberty being taken here.				  *
 * Hunter and noProd versions can set NPX and GFX adapter from	  *
 * environment vars, this can cause the old cmos to disagree	  *
 * with the new config structure.				  *
 * This function call updates the cmos.				  *
 *								  *
 ******************************************************************/

  cmos_equip_update();

#endif
#endif   //NEC_98

/*
 * initialise the cpu
 *----------------------*/

  cpu_init();

#ifndef PROD

  if (host_getenv("YODA") != NULL)
  {
    force_yoda();
  }

/*
 * Look for environment variable TOFF, when set no timer interrupts
 *------------------------------------------------------------------*/

  if( host_getenv("TOFF") != NULL )
    axe_ticks( -1 );		/* lives in base:timer.c */

#endif /* PROD */

#ifdef GISP_SVGA
  /* We have to go here to ensure that config doesn't undo any of the
  lovely patching that we do to the ROMs */
  gispROMInit( );
#endif /* GISP_SVGA */

	/*
	 * Set up the VGA globals before host_init_screen() in
	 * case of graphics activity.
	 *-------------------------------------------------------*/

#ifndef A3CPU
	(VOID) setup_global_data_ptr();
#endif	/* not A3CPU */

#if defined(NEC_98)
        setup_NEC98_globals();
#else    //NEC_98
#ifndef GISP_SVGA
	setup_vga_globals();
#else /* GISP_SVGA */
	setupHwVGAGlobals( );
#endif /* GISP_SVGA */
#endif   //NEC_98

#if defined(NEC_98)
  host_init_screen();
#else   //NEC_98
#ifdef REAL_VGA
	if (screen_init == 0)
	{
#endif /* REAL_VGA */

  host_init_screen();

#ifdef REAL_VGA
	}
#endif /* REAL_VGA */
#endif   //NEC_98

#ifdef IPC
  host_susp_q_init();
#endif

#ifdef NTVDM
/*
 * If you've got Dos Emulation - flaunt it!!
 * Initialise VDDs, Read in the Dos ntio.sys file and arrange for the cpu
 * to start execution at it's initialisation entry point.
 */
    InitialiseDosEmulation(argc, argv);
#endif	/* NTVDM */

/*
 * simulate the Intel 8088/iAPX286 cpu
 *-------------------------------------*/
/*
	Start off the cpu emulation. This will either be software
	emulation of protected mode 286/287 or possibly hardware
	eg 486 on Sparc platform
*/

  host_start_cpu();
  host_applClose();    /* recommended home is host/xxxx_reset.c */

/*
 * We should never get here so return an error status.
 */

  return(-1);

}


/**/

GLOBAL void init_virtual_drivers (void)
{
#ifdef HFX
	hfx_driver_initialisation();
#endif
	mouse_driver_initialisation();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\support\xt.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title	: Global variable definitions
 *
 * Description	: Contains definitions for registers and general
 *		  variables required by all modules.
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 *
 */

/*
 * static char SccsID[]="@(#)xt.c	1.22 01/23/95 Copyright Insignia Solutions Ltd.";
 */


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"

/*
 * ============================================================================
 * Global data
 * ============================================================================
 */

/*
   specific CPU variables.
 */
word  cpu_interrupt_map;                /* Bit map of ints outstanding  */

half_word cpu_int_translate[16];        /* this will go very soon!      */
/*
 *
 * The current usage is:
 *
 *              0       - Hardware interrupt
 *              1-7     - Not Used
 *              8       - Software Int - set by cpu_sw_interrupt() - REMOVED!
 *              9       - Trap
 *              10      - Reset IP after a POP/MOV CS.
 *              11      - Trap flag changed - this has delay.
 *              12-15   - Not Used
 */

word cpu_int_delay;                     /* Delay before pending interrupt */

int trap_delay_count;

/*
 * The lock flag prevents the Interrupt Controller Adapter from being
 * called from a signal handler while it is already active in the mainline.
 */

half_word ica_lock;

/*
 * The actual CCPU registers
 */

#if defined(CCPU) && !defined(CPU_30_STYLE)
#ifndef MAC_LIKE
reg A;		/* Accumulator		*/
reg B;		/* Base			*/
reg C;		/* Count		*/
reg D;		/* Data			*/
reg BP;		/* Base pointer		*/
reg SI;		/* Source Index		*/
reg DI;		/* Destination Index	*/
#endif /* MAC_LIKE */
reg SP;		/* Stack Pointer	*/

reg IP;		/* Instruction Pointer	*/

reg CS;		/* Code Segment		*/
reg DS;		/* Data Segment		*/
reg SS;		/* Stack Segment	*/
reg ES;		/* Extra Segment	*/

/* Code Segment Register */
half_word CS_AR;    /* Access Rights Byte */
sys_addr  CS_base;  /* Base Address */
word      CS_limit; /* Segment 'size' */
int       CPL;      /* Current Privilege Level */

/* Data Segment Register */
half_word DS_AR;    /* Access Rights Byte */
sys_addr  DS_base;  /* Base Address */
word      DS_limit; /* Segment 'size' */

/* Stack Segment Register */
half_word SS_AR;    /* Access Rights Byte */
sys_addr  SS_base;  /* Base Address */
word      SS_limit; /* Segment 'size' */

/* Extra Segment Register */
half_word ES_AR;    /* Access Rights Byte */
sys_addr  ES_base;  /* Base Address */
word      ES_limit; /* Segment 'size' */

/* Global Descriptor Table Register */
sys_addr GDTR_base;  /* Base Address */
word     GDTR_limit; /* Segment 'size' */

/* Interrupt Descriptor Table Register */
sys_addr IDTR_base;  /* Base Address */
word     IDTR_limit; /* Segment 'size' */

/* Local Descriptor Table Register */
reg      LDTR;       /* Selector */
sys_addr LDTR_base;  /* Base Address */
word     LDTR_limit; /* Segment 'size' */

/* Task Register */
reg      TR;       /* Selector */
sys_addr TR_base;  /* Base Address */
word     TR_limit; /* Segment 'size' */

mreg MSW;	/* Machine Status Word */

int STATUS_CF;
int STATUS_SF;
int STATUS_ZF;
int STATUS_AF;
int STATUS_OF;
int STATUS_PF;
int STATUS_TF;
int STATUS_IF;
int STATUS_DF;
int STATUS_NT;
int STATUS_IOPL;
#endif /* defined(CCPU) && !defined(CPU_30_STYLE) */

/*
 * Global Flags and variables
 */

int verbose;			/* TRUE => trace instructions   */

/*
 * Misc. Prot Mode support routines which are independant of CPU type
 *                                  ---------------------------------
 */
#ifdef CPU_30_STYLE
#ifndef GISP_CPU    /* GISP has its own versions of these internal to the CPU */

#define GET_SELECTOR_INDEX_TIMES8(x)  ((x) & 0xfff8)
#define GET_SELECTOR_TI(x)            (((x) & 0x0004) >> 2)

#if defined(CPU_40_STYLE)
#if defined(PROD) && !defined(CCPU)
#undef effective_addr
GLOBAL LIN_ADDR effective_addr IFN2(IU16, seg, IU32, off)
{
	return (*(Cpu.EffectiveAddr))(seg, off);
}
#endif	/* PROD & !CCPU */
#else	/* !CPU_40_STYLE */
#if !(defined(NTVDM) && defined(MONITOR))  /* MS NT monitor has own effective_addr fn */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Calculate effective address.                                       */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

GLOBAL LIN_ADDR effective_addr IFN2(IU16, seg, IU32, off)
{
	LIN_ADDR descr_addr;
	DESCR entry;

	if ((!getPE()) || getVM()) {
		return ((LIN_ADDR)seg << 4) + off;
	} else {
#if defined(SWIN_CPU_OPTS) || defined(CPU_40_STYLE)
		LIN_ADDR base;

		if (Cpu_find_dcache_entry( seg, &base ))
		{
			/* Cache Hit!! */
			return base + off;
		}
#endif /* SWIN_CPU_OPTS or CPU_40_STYLE*/

		if ( selector_outside_table(seg, &descr_addr) == 1 ) {

			/*
			 * This is probably not a major disaster, just a result
			 * of the fact that after protected mode is invoked it
			 * will take say 5-10 instructions for an application
			 * to update all the segment registers. We just
			 * maintain real mode semantics while this error occurs.
			 */

			return ((LIN_ADDR)seg << 4) + off;
		}
		else
		{
			read_descriptor(descr_addr, &entry);
			return entry.base + off;
		}
      	}
}

#endif	/* !(NTVDM & MONITOR) */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Read a decriptor table entry from memory.                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
#endif	/* !CPU_40_STYLE */

GLOBAL void read_descriptor IFN2(LIN_ADDR, addr, DESCR *, descr)
{
	IU32 first_dword, second_dword;
	IU32 limit;

	/*
	 * The format of a 286 descriptor is:-
	 *
	 * ===========================
	 * +1 |        LIMIT 15-0       | +0
	 * ===========================
	 * +3 |        BASE 15-0        | +2
	 * ===========================
	 * +5 |     AR     | BASE 23-16 | +4
	 * ===========================
	 * +7 |         RESERVED        | +6
	 * ===========================
	 */
	/*
	 * The format of a 386 descriptor is:-
	 *
	 *    =============================      AR  = Access Rights.
	 * +1 |         LIMIT 15-0        | +0   AVL = Available.
	 *    =============================      D   = Default Operand
	 * +3 |         BASE 15-0         | +2          Size, = 0 16-bit
	 *    =============================                   = 1 32-bit.
	 * +5 |      AR     | BASE 23-16  | +4   G   = Granularity,
	 *    =============================             = 0 byte limit
	 *    |             | | | |A|LIMIT|             = 1 page limit.
	 * +7 | BASE 31-24  |G|D|0|V|19-16| +6
	 *    |             | | | |L|     |
	 *    =============================
	 *
	 */

	/* read in decriptor with minimum interaction with memory */
#if defined(NTVDM) && defined(CPU_40_STYLE)
    /* On NT, this routine can be called from non-CPU threads, so we don't */
    /* want to use SAS at all. Instead, we rely on NtGetPtrToLinAddrByte,  */
    /* which is provided by the CPU and is safe for multi-threading. We are*/
    /* also relying on the fact the NT is always little-endian. */
    {
        IU32 *desc_addr = (IU32 *) NtGetPtrToLinAddrByte(addr);

        first_dword = *desc_addr;
        second_dword = *(desc_addr + 1);
    }
#else
	first_dword = sas_dw_at(addr);
	second_dword = sas_dw_at(addr+4);
#endif

	/* load attributes and access rights */
	descr->AR = (USHORT)((second_dword >> 8) & 0xff);

	/* unpack the base */
	descr->base = (first_dword >> 16) |
#ifdef SPC386
	    (second_dword & 0xff000000) |
#endif
	    (second_dword << 16 & 0xff0000 );

	/* unpack the limit */
#ifndef SPC386
	descr->limit = first_dword & 0xffff;
#else
	limit = (first_dword & 0xffff) | (second_dword & 0x000f0000);

	if ( second_dword & 0x00800000 ) /* check bit 23 */
		{
			/* Granularity Bit Set. Limit is expressed in pages
	 (4k bytes), convert to byte limit */
			limit = limit << 12 | 0xfff;
		}
	descr->limit = limit;
#endif /* ifndef SPC386 else */

}

#if !(defined(NTVDM) && defined(MONITOR))  /* MS NT monitor has own selector_outside_table fn */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check if selector outside bounds of GDT or LDT                     */
/* Return 1 for outside table, 0 for inside table.                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

GLOBAL boolean selector_outside_table IFN2(IU16, selector, LIN_ADDR *, descr_addr)
{
	/* selector		(I) selector to be checked */
	/* descr_addr	(O) address of related descriptor */

	LIN_ADDR offset;

	offset = GET_SELECTOR_INDEX_TIMES8(selector);

	/* choose a table */
	if ( GET_SELECTOR_TI(selector) == 0 )
	{
		/* GDT - trap NULL selector or outside table */
		if ( offset == 0 || offset + 7 > getGDT_LIMIT() )
			return 1;
		*descr_addr = getGDT_BASE() + offset;
	}
	else
	{
		/* LDT - trap invalid LDT or outside table */
		if ( getLDT_SELECTOR() == 0 || offset + 7 > getLDT_LIMIT() )
			return 1;
		*descr_addr = getLDT_BASE() + offset;
	}

	return 0;
}

#endif	/* !(NTVDM & MONITOR) */

#endif /* !GISP_CPU */
#endif /* CPU_30_STYLE */


/*
 * The following is a table lookup for finding parity of a byte
 */

#if !defined(MAC_LIKE) && !defined(CPU_30_STYLE)

half_word pf_table[] = {
	1,	/* 00 */
	0,	/* 01 */
	0,	/* 02 */
	1,	/* 03 */
	0,	/* 04 */
	1,	/* 05 */
	1,	/* 06 */
	0,	/* 07 */
	0,	/* 08 */
	1,	/* 09 */
	1,	/* 0a */
	0,	/* 0b */
	1,	/* 0c */
	0,	/* 0d */
	0,	/* 0e */
	1,	/* 0f */
	0,	/* 10 */
	1,	/* 11 */
	1,	/* 12 */
	0,	/* 13 */
	1,	/* 14 */
	0,	/* 15 */
	0,	/* 16 */
	1,	/* 17 */
	1,	/* 18 */
	0,	/* 19 */
	0,	/* 1a */
	1,	/* 1b */
	0,	/* 1c */
	1,	/* 1d */
	1,	/* 1e */
	0,	/* 1f */
	0,	/* 20 */
	1,	/* 21 */
	1,	/* 22 */
	0,	/* 23 */
	1,	/* 24 */
	0,	/* 25 */
	0,	/* 26 */
	1,	/* 27 */
	1,	/* 28 */
	0,	/* 29 */
	0,	/* 2a */
	1,	/* 2b */
	0,	/* 2c */
	1,	/* 2d */
	1,	/* 2e */
	0,	/* 2f */
	1,	/* 30 */
	0,	/* 31 */
	0,	/* 32 */
	1,	/* 33 */
	0,	/* 34 */
	1,	/* 35 */
	1,	/* 36 */
	0,	/* 37 */
	0,	/* 38 */
	1,	/* 39 */
	1,	/* 3a */
	0,	/* 3b */
	1,	/* 3c */
	0,	/* 3d */
	0,	/* 3e */
	1,	/* 3f */
	0,	/* 40 */
	1,	/* 41 */
	1,	/* 42 */
	0,	/* 43 */
	1,	/* 44 */
	0,	/* 45 */
	0,	/* 46 */
	1,	/* 47 */
	1,	/* 48 */
	0,	/* 49 */
	0,	/* 4a */
	1,	/* 4b */
	0,	/* 4c */
	1,	/* 4d */
	1,	/* 4e */
	0,	/* 4f */
	1,	/* 50 */
	0,	/* 51 */
	0,	/* 52 */
	1,	/* 53 */
	0,	/* 54 */
	1,	/* 55 */
	1,	/* 56 */
	0,	/* 57 */
	0,	/* 58 */
	1,	/* 59 */
	1,	/* 5a */
	0,	/* 5b */
	1,	/* 5c */
	0,	/* 5d */
	0,	/* 5e */
	1,	/* 5f */
	1,	/* 60 */
	0,	/* 61 */
	0,	/* 62 */
	1,	/* 63 */
	0,	/* 64 */
	1,	/* 65 */
	1,	/* 66 */
	0,	/* 67 */
	0,	/* 68 */
	1,	/* 69 */
	1,	/* 6a */
	0,	/* 6b */
	1,	/* 6c */
	0,	/* 6d */
	0,	/* 6e */
	1,	/* 6f */
	0,	/* 70 */
	1,	/* 71 */
	1,	/* 72 */
	0,	/* 73 */
	1,	/* 74 */
	0,	/* 75 */
	0,	/* 76 */
	1,	/* 77 */
	1,	/* 78 */
	0,	/* 79 */
	0,	/* 7a */
	1,	/* 7b */
	0,	/* 7c */
	1,	/* 7d */
	1,	/* 7e */
	0,	/* 7f */
	0,	/* 80 */
	1,	/* 81 */
	1,	/* 82 */
	0,	/* 83 */
	1,	/* 84 */
	0,	/* 85 */
	0,	/* 86 */
	1,	/* 87 */
	1,	/* 88 */
	0,	/* 89 */
	0,	/* 8a */
	1,	/* 8b */
	0,	/* 8c */
	1,	/* 8d */
	1,	/* 8e */
	0,	/* 8f */
	1,	/* 90 */
	0,	/* 91 */
	0,	/* 92 */
	1,	/* 93 */
	0,	/* 94 */
	1,	/* 95 */
	1,	/* 96 */
	0,	/* 97 */
	0,	/* 98 */
	1,	/* 99 */
	1,	/* 9a */
	0,	/* 9b */
	1,	/* 9c */
	0,	/* 9d */
	0,	/* 9e */
	1,	/* 9f */
	1,	/* a0 */
	0,	/* a1 */
	0,	/* a2 */
	1,	/* a3 */
	0,	/* a4 */
	1,	/* a5 */
	1,	/* a6 */
	0,	/* a7 */
	0,	/* a8 */
	1,	/* a9 */
	1,	/* aa */
	0,	/* ab */
	1,	/* ac */
	0,	/* ad */
	0,	/* ae */
	1,	/* af */
	0,	/* b0 */
	1,	/* b1 */
	1,	/* b2 */
	0,	/* b3 */
	1,	/* b4 */
	0,	/* b5 */
	0,	/* b6 */
	1,	/* b7 */
	1,	/* b8 */
	0,	/* b9 */
	0,	/* ba */
	1,	/* bb */
	0,	/* bc */
	1,	/* bd */
	1,	/* be */
	0,	/* bf */
	1,	/* c0 */
	0,	/* c1 */
	0,	/* c2 */
	1,	/* c3 */
	0,	/* c4 */
	1,	/* c5 */
	1,	/* c6 */
	0,	/* c7 */
	0,	/* c8 */
	1,	/* c9 */
	1,	/* ca */
	0,	/* cb */
	1,	/* cc */
	0,	/* cd */
	0,	/* ce */
	1,	/* cf */
	0,	/* d0 */
	1,	/* d1 */
	1,	/* d2 */
	0,	/* d3 */
	1,	/* d4 */
	0,	/* d5 */
	0,	/* d6 */
	1,	/* d7 */
	1,	/* d8 */
	0,	/* d9 */
	0,	/* da */
	1,	/* db */
	0,	/* dc */
	1,	/* dd */
	1,	/* de */
	0,	/* df */
	0,	/* e0 */
	1,	/* e1 */
	1,	/* e2 */
	0,	/* e3 */
	1,	/* e4 */
	0,	/* e5 */
	0,	/* e6 */
	1,	/* e7 */
	1,	/* e8 */
	0,	/* e9 */
	0,	/* ea */
	1,	/* eb */
	0,	/* ec */
	1,	/* ed */
	1,	/* ee */
	0,	/* ef */
	1,	/* f0 */
	0,	/* f1 */
	0,	/* f2 */
	1,	/* f3 */
	0,	/* f4 */
	1,	/* f5 */
	1,	/* f6 */
	0,	/* f7 */
	0,	/* f8 */
	1,	/* f9 */
	1,	/* fa */
	0,	/* fb */
	1,	/* fc */
	0,	/* fd */
	0,	/* fe */
	1	/* ff */
};
#endif /* !defined(MAC_LIKE) && !defined(CPU_30_STYLE) */


/*(
 *========================== CsIsBig ===================================
 * CsIsBig
 *
 * Purpose
 *	This function returns true if the indicated code segment is a 32 bit
 *	one, and false if it isn't.
 *
 * Input
 *	csVal	The selector to check
 *
 * Outputs
 *	None.
 *
 * Description
 *	Look at the descriptor.
)*/

GLOBAL IBOOL
CsIsBig IFN1(IU16, csVal)
{
#ifdef SPC386
	LIN_ADDR base, offset;	/* Of the descriptor to use */

	if(getVM() || !getPE()) {
		return(FALSE);	/* no 32 bit CS in V86 or real modes */
	} else {
		offset = csVal & (~7);	/* remove the RPL and TI gives offset */
		if (csVal & 4) {	/* check TI bit */
			base = getLDT_BASE();
		} else {
			base = getGDT_BASE();
		}

		/*
		 * Return true if the big bit in the descriptor is set.
		 */

		return(sas_hw_at(base + offset + 6) & 0x40);
	}
#else /* SPC386 */
	return (FALSE);
#endif /* SPC386 */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\support\terminat.c ===
#include "insignia.h"
#include "host_def.h"
/*[
        Name:           terminate.c
        Derived From:   Base 2.0
        Author:         Rod MacGregor
        Created On:     Unknown
        Sccs ID:        @(#)terminate.c 1.23 06/15/94
        Purpose:        We are about to die, put the kernel back the way
                        that it was.

        (c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

#include <stdlib.h>
#include <stdio.h>
#include TypesH

#include "xt.h"
#include "error.h"
#include "config.h"
#include "host_lpt.h"
#include "rs232.h"
#include "host_com.h"
#include "timer.h"
#include "cmos.h"
#include "fdisk.h"
#include "debug.h"
#include "gvi.h"
#include CpuH
#ifdef NOVELL
#include "novell.h"
#endif
#ifdef GISP_SVGA
#include HostHwVgaH
#include "hwvga.h"
#endif /* GISP_SVGA */
#ifdef LICENSING
#include "host_lic.h"
#endif
#include "emm.h"
#include "sndblst.h"

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

IMPORT VOID host_applClose IPT0();
IMPORT VOID host_terminate IPT0();

void terminate()
{
        SAVED BOOL already_called_terminate = FALSE;
        UTINY i;

        if (already_called_terminate)
        {
                assert0( NO, "Error: terminate called twice - exiting" );
                exit(0);
        }
        else
                already_called_terminate = TRUE;

#ifdef MSWDVR
        WinTerm();
#endif

#ifdef SWIN_SNDBLST_NULL
        sb_term();
#else
        SbTerminate();
#endif /* SWIN_SNDBLST_NULL */

#ifdef GISP_SVGA
        /* Get back to window if we are full screen */
        if( hostIsFullScreen( ) )
                disableFullScreenVideo( FALSE );
#endif /* GISP_SVGA */

        /* terminate COM and LPT devices */
#ifdef  PC_CONFIG
        /* PC_CONFIG style host_lpt_close() and
        host_com_close() calls should be added
        in here */
#else
        for (i = 0 ; i < NUM_PARALLEL_PORTS; i++)
                config_activate((IU8)(C_LPT1_NAME + i), FALSE);

        for (i = 0 ; i < NUM_SERIAL_PORTS; i++)
                config_activate((IU8)(C_COM1_NAME + i), FALSE);
#endif

        /* Update the cmos.ram file */
        cmos_update();

        host_fdisk_term();

        gvi_term();     /* close down the video adaptor */

#ifndef NTVDM
        host_timer_shutdown(); /* Stop the timer */
#endif

#ifdef LIM
        host_deinitialise_EM(); /* free memory or file used by EM */
#endif

        config_activate(C_FLOPPY_A_DEVICE, FALSE);
#ifdef FLOPPY_B
        config_activate(C_FLOPPY_B_DEVICE, FALSE);
#endif /* FLOPPY_B */
#ifdef SLAVEPC
        config_activate(C_SLAVEPC_DEVICE, FALSE);
#endif /* SLAVEPC */

        /*
         * Do any cpu-specific termination bits.
         */
#ifdef CPU_30_STYLE
        cpu_terminate();
#endif

#ifdef NOVELL
        net_term();     /* Shutdown network */
#endif

#ifdef LICENSING
        (*license_exit)(); /* Shutdown licensing system */
#endif
        /*
         * Do any host-specific termination bits.
         */
        host_applClose();
        host_terminate();

        /*
         * Seppuku.
         */
        exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\support\time_day.c ===
#if defined(NEC_98)
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#endif   //NEC_98
#include "windows.h"   /* included for Sleep() */



#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 2.0
 *
 * File		: time_day.c
 *
 * Title	: Time of day
 *
 * Sccs ID	: @(#)time_day.c	1.27 4/20/94
 *
 * Description	: Get/Set time of day
 *
 * Author	: Henry Nash
 *
 * Notes	: The PC-XT version has an interrupt 18.203 times a second
 *		  to keep the counter up to date.  We interrupt at a similar
 *		  rate, but because of occasional heavy graphics or disk
 *		  operations we lose ticks. In an attempt to still keep
 *		  good time, we correct the stored time whenever the host
 *		  detects a timer event, using the host time facilities.
 *
 *                Upon reset time_of_day_init() grabs the host system time &
 *                puts it into the BIOS data area variables. Subsequent
 *                time of day accesses are maintained using the host system
 *		  time. This enables well behaved programs to keep good time
 *		  even if ticks are missed.
 *
 * Mods: (r3.4) : Make use of the host time structures host_timeval,
 *                host_timezone, and host_tm, which are equivalent
 *		  to the Unix BSD4.2 structures.
 *
 *		  Removed calls to cpu_sw_interrupt and replaced with
 *		  host_simulate
 */

#ifdef SCCSID
static char SccsID[]="@(#)time_day.c	1.27 4/20/94 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_BIOS.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdlib.h>
#include <stdio.h>
#include TimeH
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "sas.h"
#include "ios.h"
#include CpuH
#include "bios.h"
#include "fla.h"
#include "host.h"
#include "timeval.h"
#include "timer.h"
#include "error.h"

#include "cmos.h"
#include "cmosbios.h"
#include "ica.h"


/*
 * ===========================================================================
 * Local static data and defines
 * ===========================================================================
 */
#if defined(NEC_98)
LOCAL word bin2bcd();
LOCAL word bcd2bin();
#else   //NEC_98

#ifdef XTSFD
#    define DAY_COUNT	BIOS_VAR_START + 0xCE
#endif


#ifdef NTVDM

BOOL UpDateInProgress(void);
#define UPDATE_IN_PROGRESS      UpDateInProgress()
IMPORT VOID host_init_bda_timer(void);

#else

#define UPDATE_IN_PROGRESS      ( cmos_read(CMOS_REG_A ) & 0x80 )
static sys_addr user_timer_int_vector;
static IVT_ENTRY standard_user_timer_int_vector;
static IVT_ENTRY compatibility_user_timer_int_vector;
#endif

#ifdef ANSI
LOCAL void get_host_timestamp(word *, word *, half_word *);
LOCAL void write_host_timestamp(int, int);
LOCAL void TimeToTicks(int, int, int, word *, word *);
LOCAL void get_host_time(int *, int *, int *);
#else
LOCAL void get_host_timestamp();
LOCAL void write_host_timestamp();
LOCAL void TimeToTicks();
LOCAL void get_host_time();
#endif /* ANSI */
#endif   //NEC_98

#define TICKS_PER_HOUR      65543L
#define TICKS_PER_MIN       1092L
#define TICKS_PER_SEC       18L

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */

void time_of_day()
{
#if defined(NEC_98)
    SYSTEMTIME  now;
    DWORD       DataBuffer;
    WORD        tmp;
    NTSTATUS    Status;
    HANDLE      Token;
    BYTE        OldPriv[1024];
    PBYTE       pbOldPriv;
    LUID        LuidPrivilege;
    PTOKEN_PRIVILEGES   NewPrivileges;
    ULONG       cbNeeded;

    switch(getAH()) {
        case 0:
            GetLocalTime(&now);
            DataBuffer = (getES() << 4) + getBX();
            now.wYear = now.wYear - ( now.wYear / 100 ) * 100;
            sas_store(DataBuffer, bin2bcd(now.wYear));
            sas_store(DataBuffer + 1, (now.wMonth << 4) | now.wDayOfWeek);
            sas_store(DataBuffer + 2, bin2bcd(now.wDay));
            sas_store(DataBuffer + 3, bin2bcd(now.wHour));
            sas_store(DataBuffer + 4, bin2bcd(now.wMinute));
            sas_store(DataBuffer + 5, bin2bcd(now.wSecond));
            break;
        case 1:
            tmp = 0;
            DataBuffer = (getES() << 4) + getBX();
            sas_load(DataBuffer, &tmp);
            if(bcd2bin(tmp) > 79)
                now.wYear = bcd2bin(tmp) + 1900;
            else
                now.wYear = bcd2bin(tmp) + 2000;
            sas_load(DataBuffer + 1, &tmp);
            now.wMonth = tmp >> 4;
            now.wDayOfWeek = tmp & 0x0F;
            sas_load(DataBuffer + 2, &tmp);
            now.wDay = bcd2bin(tmp);
            sas_load(DataBuffer + 3, &tmp);
            now.wHour = bcd2bin(tmp);
            sas_load(DataBuffer + 4, &tmp);
            now.wMinute = bcd2bin(tmp);
            sas_load(DataBuffer + 5, &tmp);
            now.wSecond = bcd2bin(tmp);
            now.wMilliseconds = 0;

            Status = NtOpenProcessToken(
                        NtCurrentProcess(),
                        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                        &Token
                        );

            if ( !NT_SUCCESS( Status )) {
                break;
            }

            pbOldPriv = OldPriv;

    //
    // Initialize the privilege adjustment structure
    //

//          LuidPrivilege = RtlConvertLongToLargeInteger(SE_SYSTEMTIME_PRIVILEGE);
            LuidPrivilege.LowPart  = SE_SYSTEMTIME_PRIVILEGE;
            LuidPrivilege.HighPart = 0L;

            NewPrivileges = (PTOKEN_PRIVILEGES)malloc(sizeof(TOKEN_PRIVILEGES) +
                (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
            if (NewPrivileges == NULL) {
                CloseHandle(Token);
                break;
            }

            NewPrivileges->PrivilegeCount = 1;
            NewPrivileges->Privileges[0].Luid = LuidPrivilege;
            NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //

            cbNeeded = 1024;

            Status = NtAdjustPrivilegesToken (
                Token,
                FALSE,
                NewPrivileges,
                cbNeeded,
                (PTOKEN_PRIVILEGES)pbOldPriv,
                &cbNeeded
                );

            if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                pbOldPriv = malloc(cbNeeded);

                if ( pbOldPriv == NULL ) {
                    CloseHandle(Token);
                    free(NewPrivileges);
                    break;
                }

                Status = NtAdjustPrivilegesToken (
                        Token,
                        FALSE,
                        NewPrivileges,
                        cbNeeded,
                        (PTOKEN_PRIVILEGES)pbOldPriv,
                        &cbNeeded
                        );

            }

    //
    // STATUS_NOT_ALL_ASSIGNED means that the privilege isn't
    // in the token, so we can't proceed.
    //
    // This is a warning level status, so we must check
    // for it explicitly.
    //

            if ( !NT_SUCCESS( Status ) || (Status == STATUS_NOT_ALL_ASSIGNED) ) {

                CloseHandle( Token );
                free(NewPrivileges);
                free(pbOldPriv);
                break;
            }

            SetLocalTime(&now);


            (VOID) NtAdjustPrivilegesToken (
                Token,
                FALSE,
                (PTOKEN_PRIVILEGES)pbOldPriv,
                0,
                NULL,
                NULL
                );

            CloseHandle( Token );
            free(NewPrivileges);
            free(pbOldPriv);
            break;
    }
#else    //NEC_98

    /*
     * BIOS function to return the number of PC interrupts since boot.
     */

    half_word mask;
    word low, high;
    half_word overflow, alarm;


    /*
     * Block the Alarm signal whilst we are looking at the clock timer
     */

#ifdef BSD4_2
    host_block_timer();
#endif

    switch (getAH()) {
	case 0x00:			/* Get time	*/

#ifdef NTVDM
            sas_loadw(TIMER_LOW, &low);
	    setDX(low);

            sas_loadw(TIMER_HIGH, &high);
	    setCX(high);

            sas_load(TIMER_OVFL, &overflow);
 	    setAL(overflow);
            sas_store(TIMER_OVFL, 0);   /* Always write zero after read */

#else   /* ! NTVDM */
#ifndef PROD
	if (host_getenv("TIME_OF_DAY_FRIG") == NULL){
#endif
	    /*
	     * First get the time from the host
	     */

	    get_host_timestamp(&low, &high, &overflow);

	    /*
	     * Use it to return the time AND overwrite the BIOS data
	     */

	    setDX(low);
	    sas_storew(TIMER_LOW, low);

	    setCX(high);
	    sas_storew(TIMER_HIGH, high);

 	    setAL(overflow);
	    sas_store(TIMER_OVFL, 0);	/* Always write zero after read	*/

#ifndef PROD
	}else{
	    SAVED int first=1;

	    if (first){
		first = 0;
		printf ("FRIG ALERT!!!! - time of day frozen!\n");
	    }

	    setDX(1);
	    sas_storew(TIMER_LOW, 1);

	    setCX(1);
	    sas_storew(TIMER_HIGH, 1);

 	    setAL(0);
	    sas_store(TIMER_OVFL, 0);	/* Always write zero after read	*/
	}
#endif
#endif /* NTVDM */

	    break;

	case 0x01:			/* Set time	*/
	    /*
	     * Load the BIOS variables
	     */

	    sas_storew(TIMER_LOW, getDX());
	    sas_storew(TIMER_HIGH, getCX());
	    sas_store(TIMER_OVFL, 0);

#ifndef NTVDM
	    /*
	     * Also the host timestamp
	     */

	    write_host_timestamp(getDX(), getCX());
#endif
	    break;
	case 2:	/* read the real time clock	*/

#ifndef NTVDM
#ifndef PROD
	if (host_getenv("TIME_OF_DAY_FRIG") == NULL){
#endif
#endif
		if( UPDATE_IN_PROGRESS )
			setCF(1);
		else
		{
			setDH( cmos_read( CMOS_SECONDS ) );
			setDL( (UCHAR)(cmos_read( CMOS_REG_B ) & 1) );	/* DSE bit	*/
			setCL( cmos_read( CMOS_MINUTES ) );
			setCH( cmos_read( CMOS_HOURS ) );
			setCF(0);
		}
#ifndef NTVDM
#ifndef PROD
	}else{
	    SAVED int first=1;

	    if (first){
		first = 0;
		printf ("FRIG ALERT!!!! - real time clock frozen!\n");
	    }

			setDH( 1 );
			setDL( 0 );	/* DSE bit	*/
			setCL( 1 );
			setCH( 1 );
			setCF(0);
	}
#endif
#endif
		break;

	case 3:	/* Set the real time clock	*/

		if( UPDATE_IN_PROGRESS )
		{
			/* initialise real time clock	*/
			cmos_write( CMOS_REG_A, 0x26 );
			cmos_write( CMOS_REG_B, 0x82 );
			cmos_read( CMOS_REG_C );
			cmos_read( CMOS_REG_D );
		}
		cmos_write( CMOS_SECONDS, getDH() );
		cmos_write( CMOS_MINUTES, getCL() );
		cmos_write( CMOS_HOURS, getCH() );
		alarm = ( cmos_read( CMOS_REG_B ) & 0x62 ) | 2;
		alarm |= (getDL() & 1);			/* only use the DSE bit	*/
		cmos_write( CMOS_REG_B, alarm );
		setCF(0);
		break;


	case 4:	/* read the date from the real time clock	*/

#ifndef NTVDM
#ifndef PROD
	if (host_getenv("TIME_OF_DAY_FRIG") == NULL){
#endif
#endif
		if( UPDATE_IN_PROGRESS )
			setCF(1);
		else
		{
			setDL( cmos_read( CMOS_DAY_MONTH ) );
			setDH( cmos_read( CMOS_MONTH ) );
			setCL( cmos_read( CMOS_YEAR ) );
			setCH( cmos_read( CMOS_CENTURY ) );
			setCF(0);
		}
#ifndef NTVDM
#ifndef PROD
	}else{
	    SAVED int first=1;

	    if (first){
		first = 0;
		printf ("FRIG ALERT!!!! - date frozen!\n");
	    }

			setDL( 1 );
			setDH( 4 );
			setCL( 91 );
			setCH( 19 );
			setCF(0);
	}
#endif
#endif
		break;

	case 5:	/* Set the date into the real time clock	*/

		if( UPDATE_IN_PROGRESS )
		{
			/* initialise real time clock	*/
			cmos_write( CMOS_REG_A, 0x26 );
			cmos_write( CMOS_REG_B, 0x82 );
			cmos_read( CMOS_REG_C );
			cmos_read( CMOS_REG_D );
		}
		cmos_write( CMOS_DAY_WEEK, 0 );
		cmos_write( CMOS_DAY_MONTH, getDL() );
		cmos_write( CMOS_MONTH, getDH() );
		cmos_write( CMOS_YEAR, getCL() );
		cmos_write( CMOS_CENTURY, getCH() );
		alarm = cmos_read( CMOS_REG_B ) & 0x7f;		/* clear 'set bit'	*/
		cmos_write( CMOS_REG_B, alarm);
		setCF(0);
		break;

	case 6:	/* set the alarm	*/

		if( cmos_read(CMOS_REG_B) & 0x20 )		/* alarm already enabled?	*/
		{
			setCF(1);
#ifdef BSD4_2
			host_release_timer();
#endif
			return;
		}
		if( UPDATE_IN_PROGRESS )
		{
			/* initialise real time clock	*/
			cmos_write( CMOS_REG_A, 0x26 );
			cmos_write( CMOS_REG_B, 0x82 );
			cmos_read( CMOS_REG_C );
			cmos_read( CMOS_REG_D );
		}
		cmos_write( CMOS_SEC_ALARM, getDH() );
		cmos_write( CMOS_MIN_ALARM, getCL() );
		cmos_write( CMOS_HR_ALARM, getCH() );
		inb( ICA1_PORT_1, &mask );
		mask &= 0xfe;					/* enable alarm timer int.	*/
		outb( ICA1_PORT_1, mask );
		alarm = cmos_read( CMOS_REG_B ) & 0x7f;		/* ensure set bit turned off	*/
		alarm |= 0x20;					/* turn on alarm enable		*/
		cmos_write( CMOS_REG_B, alarm );
		break;

	case 7:

		alarm = cmos_read( CMOS_REG_B );
		alarm &= 0x57;					/* turn off alarm enable	*/	
		cmos_write( CMOS_REG_B, alarm );
		break;


#ifdef XTSFD
	case 0x0A:
	{
	    word count;

	    sas_loadw(DAY_COUNT, &count);
	    setCX( count );
	    break;
	}
	case 0x0B:
  	    sas_storew(DAY_COUNT, getCX() );
	    break;
	default:
	    setCF( 1 );
#else
        default:
            ; /* Do nothing */
#endif
    }
    setAH( 0 );

#ifdef BSD4_2
    host_release_timer();
#endif
#endif   //NEC_98
}

#if defined(NEC_98)
LOCAL word bin2bcd(word i)
{
    word        bcd_h,bcd_l;

    bcd_h = i / 10;
    bcd_l = i - bcd_h * 10;
    return((bcd_h << 4) + bcd_l);
}

LOCAL word bcd2bin(half_word i)
{
    word        bcd_h,bcd_l;

    bcd_h = (half_word)(i >> 4);
    bcd_l = (half_word)(i & 0x0F);
    return(bcd_h * 10 + bcd_l);
}
#endif   //NEC_98

void time_int()
{
#ifndef NEC_98
    /*
     * NT port does everything in 16 bit int08 handler
     */
#ifndef NTVDM

    /*
     * The BIOS timer interrupt routine.
     */
    word low, high;
    half_word motor_count, motor_flags;

    /*
     * Increment the low portion
     */

    sas_loadw(TIMER_LOW, &low);
    sas_storew(TIMER_LOW, ++low);

    /*
       1.9.92 MG
       We need to actually load the timer high value before doing the 24 hour
       test below here.
    */

    sas_loadw(TIMER_HIGH, &high);

    if (low == 0)
    {
	/*
	 * Timer has wrapped so update the high count
	 */

	sas_storew(TIMER_HIGH, ++high);
    }

    /*
     * Wrap at 24 hrs
     */

    if (high == 0x0018 && low == 0x00b0)
    {
	sas_storew(TIMER_LOW,  0x0000);
	sas_storew(TIMER_HIGH, 0x0000);
	sas_store(TIMER_OVFL,  0x01);
    }

    /*
     *  Decrement motor count
     */

    sas_load(MOTOR_COUNT, &motor_count);
	if(motor_count < 4)
		motor_count = 0;
	else
		motor_count -= 4;
    sas_store(MOTOR_COUNT, motor_count);

    if (motor_count == 0)
    {
	/*
	 * Turn off motor running bits
	 */

	sas_load(MOTOR_STATUS,&motor_flags);
	motor_flags &= 0xF0;
	sas_store(MOTOR_STATUS,motor_flags);


	/*
	 * Provided FLA is not busy, then actually turn the motor off.
	 */

  	if (!fla_busy)
	    outb(DISKETTE_DOR_REG, 0x0C);
    }

    if ( getVM() ||
	 ((standard_user_timer_int_vector.all != sas_dw_at(user_timer_int_vector)) &&
          (compatibility_user_timer_int_vector.all != sas_dw_at(user_timer_int_vector))) )
        /*
	 * There is a user time routine defined - so lets call it
	 */
	{
		exec_sw_interrupt(USER_TIMER_INT_SEGMENT,
				  USER_TIMER_INT_OFFSET);
	}
#endif	/* NTVDM */
#endif   //NEC_98
}

/*
 * ============================================================================
 * Internal Functions
 * ============================================================================
 */

/*
 *  NT's sense of time in the bios data area is always
 *  kept in sync with the real systems tic count
 *  Most of the compensation to readjust tics according
 *  to the time of day stuff is not needed
 */
#ifndef NTVDM
/*
 * The routines get_host_timestamp() and write_host_timestamp() are used to
 * override the BIOS record of time, since timer events are known to be lost.
 * Internally the routines work in seconds and microseconds, using the "timeval"
 * struct provided by 4.2BSD. Since System V does not provide this, we supply a
 * version of the 4.2BSD gettimeofday() function locally, making use of the
 * System V function ticks().
 */

/*
 * Our own timestamp for calculating PC time
 */

static struct host_timeval time_stamp;

LOCAL void get_host_timestamp(low, high, overflow)
word *low, *high;
half_word *overflow;
{
    /*
     * Provide the time in PC interrupts since startup, in the
     * 32-bit value high:low. The parameter overflow is set to 1
     * if a 24-hour boundary has been passed since the last call.
     */

    struct host_timeval now, interval;
    struct host_timezone junk;		/* Not used		*/
    unsigned long ticks;		/* Total ticks elapsed	*/
    long   days;
    SAVED long last_time = 0;
    long hours, mins, secs;

    /*
     * Obtain the current time (since host boot-up)
     */

    host_gettimeofday(&now, &junk);

    /*
     * Calculate how long has passed since the time stamp
     */

    interval.tv_sec  = now.tv_sec  - time_stamp.tv_sec;
    interval.tv_usec = now.tv_usec - time_stamp.tv_usec;

    /*
     * Handle the "borrow" correction
     */

    if (interval.tv_sec > 0 && interval.tv_usec < 0)
    {
	interval.tv_usec += 1000000L;
	interval.tv_sec  -= 1;
    };

    /*
	 * TMM 8/1/92:
	 * -----------
	 *
	 * If someone changes the date forwards by >= 24 hours then we should set
	 * the overflow flag and ensure that we don't return an interval greater
	 * than 24 hours. If the date has changed by >= 48 hours then we will have
	 * lost a day. So we put up a panel to tell the user.
	 *
	 * If some one has set the date backwards and the interval has gone
	 * negative then all we can do is put up an error panel informing
	 * the user and ensure that we don't set the interval to a negative
	 * value.
	 *
	 * Notes:
	 *
	 * 1. Setting the overflow flag causes DOS to add a day onto the current
	 *    date.
	 *
	 * 2. Setting the interval to a value greater than 24 hours causes DOS
	 *    to print a "Divide Overflow" error.
	 *
	 * 3. Setting the interval to a -ve value causes DOS to go into an
	 *    infinite loop printing "Divide Overflow".
     */

	days = interval.tv_sec / (24 * 60 * 60);

	if (days >= 1)
    {
		/*
		 * Someone has set the clock forwards, or we have been frozen for a
		 * couple of days. Ensure that the interval is not more than 24 hours,
		 * adjust the time_stamp to take care of the lost days.
		 */

		interval.tv_sec   %= 24 * 60 * 60;
		time_stamp.tv_sec += days * (24 * 60 * 60);
		
		if (days > 1)
		{
			host_error (EG_DATE_FWD, ERR_CONT | ERR_RESET, "");
		}

		*overflow = 1;
    }
	else if (interval.tv_sec < 0)
	{
		/*
		 * Somebody has set the clock backwards, all we can do is maintain
		 * the same time that we had before the clock went back.
		 */

		time_stamp.tv_sec -= (last_time - now.tv_sec );
		interval.tv_sec = now.tv_sec - time_stamp.tv_sec;
	
		*overflow = 0;
		
		host_error (EG_DATE_BACK, ERR_CONT | ERR_RESET, "");
	}
    else
		*overflow = 0;

    /*
     * Convert seconds to hours/minutes/seconds
     */

    hours = interval.tv_sec / (60L*60L);        /* Hours */
    interval.tv_sec %= (60L*60L);

    mins = interval.tv_sec / 60L;               /* Minutes */
    secs = interval.tv_sec % 60L;               /* Seconds */

    /*
     * Now convert the interval into PC ticks
     * One tick lasts 54925 microseconds.
     */


    ticks = hours * TICKS_PER_HOUR + mins * TICKS_PER_MIN +
            secs * TICKS_PER_SEC + interval.tv_usec/54925 ;

    /*
     * Split the value into two 16-bit quantities and return
     */

    *low  = ticks & 0xffff;
    *high = ticks >> 16;
}


LOCAL void write_host_timestamp(low, high)
int low, high;
{
    /*
     * Update our timestamp so that subsequent calls of get_host_timestamp
     * return the correct value. A call of get_host_timestamp() made immediately
     * after this call must return the values set here, so set the timestamp
     * to be the current time less the value set here.
     */

    struct host_timeval now, interval;
    struct host_timezone junk;          /* Not used             */
    long lowms;

    /*
     * Get the current time.
     */

    host_gettimeofday(&now, &junk);


    interval.tv_sec = high * 3599 + high/2;     /* high ticks to seconds */

    /*
     * The multiply below can overflow, which has the interesting effect
     * of making Softpc 1 hr 12 mins 40 secs (4300 secs, or 2^32 us) slow
     * if booted in the last third of every hour. So compensate by
     * letting the overflow occur and correcting interval by 4300 secs.
     */

    lowms =  (IS32) (low & 0xffff) * 54925 + (low & 0xffff)/2;
    if (low > 39098)
	interval.tv_sec += 4300;

    interval.tv_sec += lowms / 1000000;
    interval.tv_usec = lowms % 1000000;

    /*
     * The timestamp is the current time less this interval
     */

    time_stamp.tv_sec  = now.tv_sec  - interval.tv_sec;
    time_stamp.tv_usec = now.tv_usec - interval.tv_usec;

    /*
     * Handle the "borrow" correction, including negative timestamps
     */

    if (time_stamp.tv_sec > 0 && time_stamp.tv_usec < 0)
    {
        time_stamp.tv_usec += 1000000L;
        time_stamp.tv_sec  -= 1;
    }
    else
    if (time_stamp.tv_sec < 0 && time_stamp.tv_usec > 0)
    {
        time_stamp.tv_usec -= 1000000L;
        time_stamp.tv_sec  += 1;
    }
}


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif


LOCAL void get_host_time( h, m, s )
int *h, *m, *s; /* hours, minutes and secs */
{
    struct host_tm *tp;
    time_t SecsSince1970;

    SecsSince1970 = host_time(NULL);
    tp = host_localtime(&SecsSince1970);
    *h = tp->tm_hour;
    *m = tp->tm_min;
    *s = tp->tm_sec;
}

#ifndef NEC_98
/*
** Take a normal time in hours, minutes and seconds then
** transmutate it into PC ticks since the beginning of the day.
*/
LOCAL void TimeToTicks( hour, minutes, sec, low, hi )
int hour, minutes, sec;	/* inputs */
word *low, *hi;		/* outputs */
{
    unsigned long ticks;                /* Total ticks elapsed  */

    /*
     * Calculate ticks to date
     */


    ticks = hour * TICKS_PER_HOUR + minutes * TICKS_PER_MIN +
            sec * TICKS_PER_SEC;

    /*
     * Split the value into two 16-bit quantities and return
     */

    *low  = ticks & 0xffff;
    *hi = ticks >> 16;
}
#endif   //NEC_98

#endif  /* ifndef NTVDM */


void time_of_day_init()
{
#ifndef NEC_98
#ifndef NTVDM
    int hour, minutes, sec;		/* Current host time */
    word low, hi;		/* Host time in PC ticks */

    /*
     * Initialise the clock timer.
     */

    get_host_time( &hour, &minutes, &sec );	/* get the time from the host */

    TimeToTicks( hour, minutes, sec, &low, &hi );	/* convert to PC time */

    sas_storew(TIMER_LOW, low  );
    sas_storew(TIMER_HIGH, hi );
    sas_store(TIMER_OVFL,0x01);

    /*
     * Initialise the host time stamp
     */

    write_host_timestamp( low, hi );

    /*
     * Build the standard IVT entry for the user timer interrupt(s)
     */

	compatibility_user_timer_int_vector.all = ((double_word)ADDR_COMPATIBILITY_SEGMENT << 16) + ADDR_COMPATIBILITY_OFFSET;
	standard_user_timer_int_vector.all = ((double_word)DUMMY_INT_SEGMENT << 16) + DUMMY_INT_OFFSET;
	
    user_timer_int_vector = BIOS_USER_TIMER_INT * 4;

#endif  /* NTVDM */
#endif   //NEC_98
}



#ifndef NEC_98
#ifdef NTVDM

/*
 *  NTVDM: the rtc is setup so that the UIP bit is set on a cmos
 *  port read if the cmos ports haven't been touched for at least
 *  1 second. The IBM pc bios routine for accessing the clock
 *  polls RegA for UIP bit in a tight loop 600h times before
 *  failing the call. This means that MOST of the time the int1ah
 *  rtc fns almost never fail! To mimic this behaviour we poll
 *  the port until success, since we know that our rtc will clear
 *  UIP bit very quickly.
 */
BOOL UpDateInProgress(void)
{

   while (cmos_read(CMOS_REG_A) & 0x80) {
       Sleep(0);  // give other threads a chance to work
       }

   return FALSE;

}
#endif
#endif   //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\system\cmosnt.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "insignia.h"
#include "host_def.h"
/*
 * Name:		cmos.c
 *
 * Sccs ID:		@(#)cmos.c	1.38 07/11/95
 *
 * Purpose:		Unknown
 *
 * (c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
 *
 */

/*
 * O/S include files.
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>

/*
 * SoftPC include files
 */

#include "xt.h"
#include "cmos.h"
#include "cmosbios.h"
#include "ios.h"
#include "spcfile.h"
#include "error.h"
#include "config.h"
#include "timeval.h"
#include "ica.h"
#include "timer.h"
#include "tmstrobe.h"
#include "gfi.h"
#include "sas.h"
#include "debug.h"
#include "quick_ev.h"

#include <nt_eoi.h>


half_word(*bin2bcd)(int x);
half_word(*_24to12)(half_word x);
int (*bcd2bin)(int x);
int (*_12to24)(int x);

boolean  data_mode_yes;
boolean  twenty4_hour_clock;
int cmos_index = 0;


typedef struct _HOST_TIME{
   int Year;
   int Month;
   int Day;
   int Hour;
   int Minute;
   int Second;
   int WeekDay;
} HOSTTIME, *PHOSTTIME;

HOSTTIME   HostTime;      /* The host time */
PHOSTTIME  ht = &HostTime;


IU32 rtc_period_mSeconds = 976;

half_word cmos[CMOS_SIZE] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* Timing info + alarms */
	REG_A_INIT,
	REG_B_INIT,
	REG_C_INIT,
	REG_D_INIT,
	DIAG_INIT,
	SHUT_INIT,
	FLOP_INIT,
        DISK_INIT,
	DISK_INIT,
	CMOS_RESVD,
	EQUIP_INIT,
	BM_LO_INIT, BM_HI_INIT,
	EXP_LO, EXP_HI,
	DISK_EXTEND, DISK2_EXTEND,
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x1b - 0x1e */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x1f - 0x22 */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x23 - 0x26 */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x27 - 0x2a */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x2b - 0x2d */
	CHK_HI_INIT, CHK_LO_INIT,
	EXT_LO_INIT, EXT_HI_INIT,
	CENT_INIT,
	INFO_128_INIT,
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x34 - 0x37 */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x38 - 0x3b */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x3c - 0x3f */
};

half_word *cmos_register = &cmos[CMOS_SHUT_DOWN];


int RtcLastAlarm;
int RtcAlarmTime;
int RtcHostUpdateTime;
BOOL RtcEoiPending;
int  RtcUpdateCycle=-1;
unsigned char TogglePfCount;
unsigned char PendingCReg = 0;
struct host_timeval RtcTickTime = {0,0};


/*
 *
 * ===========================================================================
 * Internal functions
 * ===========================================================================
 *
 */




/*
 *  Calculates next AlarmTime in seconds based on RtcTickTime.
 *  Assumes that RtcHostUpdateTime == RtcTickTime->tv_sec
 */
void ResetAlarm(void)
{
   int HourDue;
   int MinDue;
   int SecDue;
   int SecondsTillDue;


   if (RtcLastAlarm) {
       return;
       }

   if (!(cmos[CMOS_REG_B] & AIE) || (cmos[CMOS_REG_B] & SET)) {
       RtcAlarmTime = 0;
       return;
       }


   /*
    * Determine hour, min, and sec when Next Alarm is due.
    *
    */

   HourDue = cmos[CMOS_HR_ALARM] >= DONT_CARE
                 ? ht->Hour
                 : (*_12to24)((*bcd2bin)(cmos[CMOS_HR_ALARM]));

   MinDue = cmos[CMOS_MIN_ALARM] >= DONT_CARE
                 ? ht->Minute
                 : (*bcd2bin)(cmos[CMOS_MIN_ALARM]);

   SecDue = cmos[CMOS_SEC_ALARM] >= DONT_CARE
                 ? ht->Second + 1
                 : (*bcd2bin)(cmos[CMOS_SEC_ALARM]);


   /*
    * Determine Seconds until Next alarm due. NEVER schedule alarms
    * for the current update cycle, as this will cause multiple alarms
    * to occur because alarm interrupts are queued in RtcTick(). ie
    * assume CurrTime is 1 sec in the future.
    *
    * AlarmSecs = SecDue + MinDue * 60 + HourDue * 3600;
    * CurrSecs  = ht->Second + 1 + ht->Minute * 60 + ht->Hour * 3600;
    * SecondsTillDue = AlarmSecs - CurrSecs - 1;
    *
    */

   SecondsTillDue = (HourDue - ht->Hour) * 3600 +
                    (MinDue -  ht->Minute)  * 60 +
                    SecDue - ht->Second - 1;

   if (SecondsTillDue < 0) {
       SecondsTillDue += 24 *3600;
       }

   SecondsTillDue++;

   /*
    *  The Next AlarmTime is RtcTickTime + SecondsTillDue;
    */
   RtcAlarmTime = RtcTickTime.tv_sec + SecondsTillDue;

}





/*
 *  Function to change Host Time where the the Day might change.
 *  (ie past midnight!).
 */
BOOL
HostTimeAdjust(
    int Seconds
    )
{
    TIME_FIELDS    tf;
    LARGE_INTEGER  liTime;

    tf.Milliseconds = 0;
    tf.Second     = (SHORT)ht->Second;
    tf.Minute     = (SHORT)ht->Minute;
    tf.Hour       = (SHORT)ht->Hour;
    tf.Day        = (SHORT)ht->Day;
    tf.Month      = (SHORT)ht->Month;
    tf.Year       = (SHORT)ht->Year;

    if (!RtlTimeFieldsToTime(&tf, &liTime)) {
        return FALSE;
        }

    liTime.QuadPart += Int32x32To64(Seconds, 10000000);

    RtlTimeToTimeFields(&liTime, &tf);

    ht->Second    = tf.Second;
    ht->Minute    = tf.Minute;
    ht->Hour      = tf.Hour;
    ht->Day       = tf.Day;
    ht->Month     = tf.Month;
    ht->Year      = tf.Year;
    ht->WeekDay   = tf.Weekday;

    return TRUE;
}




void
UpdateCmosTime(
   void
   )
{
   ULONG CurrTic;
   int SecsElapsed;


   if ((cmos[CMOS_REG_B] & SET)) {
       return;
       }

   TogglePfCount++;


   SecsElapsed = RtcTickTime.tv_sec - RtcHostUpdateTime;

   if (SecsElapsed > 0) {
       RtcHostUpdateTime = RtcTickTime.tv_sec;
       cmos[CMOS_REG_A] |= UIP;
       RtcUpdateCycle = 3;

       ht->Second += SecsElapsed;
       if (ht->Second >= 60) {
           ht->Minute += (ht->Second / 60);
           ht->Second = ht->Second % 60;
           if (ht->Minute >= 60) {
               ht->Hour += ht->Minute / 60;
               ht->Minute  = ht->Minute % 60;

                   /*
                    * To increment Time past midnight is hard
                    * because we don't have a calender. Let Nt
                    * deal with it.
                    */
               if (ht->Hour >= 24) {
                   int Seconds;

                   Seconds = (ht->Hour - 23) * 60 * 60;
                   ht->Hour = 23;
                   if (!HostTimeAdjust(Seconds)) {
                       ht->Hour = 0;
                       }
                   }
               }
           }
       }


}




void
QueueRtcInterrupt(
    unsigned char CRegFlag,
    BOOL  InEoi
    )
{
    unsigned long Delay;

    PendingCReg |= CRegFlag;

    if (RtcEoiPending || !PendingCReg) {
        return;
        }

    RtcEoiPending = TRUE;

    if (PendingCReg & C_PF) {
        Delay = rtc_period_mSeconds;
        }
    else if (InEoi) {
        Delay = 10000;
        }
    else {
        Delay = 0;
        }

    cmos[CMOS_REG_C] |= PendingCReg | C_IRQF;

    if (Delay) {
        host_DelayHwInterrupt(8,   // ICA_SLAVE, CPU_RTC_INT
                              1,
                              Delay
                              );
        }
    else {
        ica_hw_interrupt(ICA_SLAVE, CPU_RTC_INT, 1);
        }

    PendingCReg = 0;
}



void
RtcIntEoiHook(int IrqLine, int CallCount)
{
     RtcEoiPending = FALSE;

     if (RtcLastAlarm) {
         RtcLastAlarm = 0;
         UpdateCmosTime();
         ResetAlarm();
         }

     QueueRtcInterrupt((half_word)((cmos[CMOS_REG_B] & PIE) &&  rtc_period_mSeconds ? C_PF : 0),
                       TRUE
                       );
}



void do_checksum IFN0()
{
	int             i;
	word            checksum = 0;

	for (i = CMOS_DISKETTE; i < CMOS_CKSUM_HI; i++)
	{
		checksum += cmos[i];
	}
	cmos[CMOS_CKSUM_LO] = checksum & 0xff;
	cmos[CMOS_CKSUM_HI] = checksum >> 8;
}

half_word yes_bin2bcd IFN1(int, x)
{
	/* converts binary x to bcd */
	half_word       tens, units;

	tens = x / 10;
	units = x - tens * 10;
	return ((tens << 4) + units);
}

half_word no_bin2bcd IFN1(int, x)
{
	return ((half_word) x);
}

int yes_bcd2bin IFN1(int, x)
{
	/* converts x in bcd format to binary */
	return ((int) ((x & 0x0f) + (x >> 4) * 10));
}

int no_bcd2bin IFN1(int, x)
{
	return ((int) (half_word) x);
}

int no_12to24 IFN1(int, x)
{
	return (x);
}

half_word no_24to12 IFN1(half_word, x)
{
	return (x);
}

half_word yes_24to12 IFN1(half_word, x)
{
	/* converts binary or bcd x from 24 to 12 hour clock */
	half_word       y = (*bin2bcd) (12);

	if (x > y)
		x = (x - y) | 0x80;
	else if (x == 0)
		x = y | 0x80;
	return (x);
}

int yes_12to24 IFN1(int, x)
{
	/* converts binary or bcd x from 12 to 24 hour clock */
	half_word       y = (*bin2bcd) (12);

	if (x == (0x80 + y))
		return (0);
	else if (x & 0x80)
		return ((x & 0x7f) + y);
	else
		return (x);
}

int verify_equip_byte IFN1(half_word *, equip)
{
	static half_word display_mask[] =
	{
		MDA_PRINTER,	CGA_80_COLUMN,	CGA_80_COLUMN,
		OWN_BIOS,	MDA_PRINTER
	};
	int equip_err;
	int num_flops;
	SHORT adapter;

	/* Check the Equipment Byte */
	*equip = 0;
        adapter = (SHORT) config_inquire(C_GFX_ADAPTER, NULL);
	if(adapter != -1)
		*equip |= display_mask[adapter];

	if( host_runtime_inquire(C_NPX_ENABLED) )
		*equip |= CO_PROCESSOR_PRESENT;

#ifdef SLAVEPC
	if (host_runtime_inquire(C_FLOPPY_SERVER) == GFI_SLAVE_SERVER)
	{
		num_flops =
			(*(CHAR *) config_inquire(C_SLAVEPC_DEVICE, NULL))
			? 1:0;
	}
	else
#endif /* SLAVEPC */
	{
		num_flops  =
			(*(CHAR *) config_inquire(C_FLOPPY_A_DEVICE, NULL))
			? 1:0;
#ifdef FLOPPY_B
		num_flops +=
			(*(CHAR *) config_inquire(C_FLOPPY_B_DEVICE, NULL))
			? 1:0;
#endif
	}

	if (num_flops == 2)
		*equip |= TWO_DRIVES;
	if (num_flops)
		*equip |= DISKETTE_PRESENT;

	equip_err = (*equip ^ cmos[CMOS_EQUIP]);
	return equip_err;
}

/*
 * =========================================================================
 *  External functions
 * =========================================================================
 */

GLOBAL void cmos_inb IFN2(io_addr, port, half_word *, value)
{
        /*
	** Tim September 92, hack for DEC 450ST
	*/
	if( port==0x78 )
	{
		*value = 0;
		return;
	}

	port = port & CMOS_BIT_MASK;	/* clear unused bits */

	if (port == CMOS_DATA)
        {
            host_ica_lock();

            UpdateCmosTime();

            switch (cmos_index) {
                case CMOS_REG_A:
                      *value = *cmos_register;

                      /*
                       *  If app polling RegA and Update Cycle pending,
                       *  complete it.
                       */
                      if (RtcUpdateCycle > 0 && !--RtcUpdateCycle) {
                          cmos[CMOS_REG_A] &= ~UIP;
                          if (cmos[CMOS_REG_B] & UIE) {
                              QueueRtcInterrupt(C_UF, FALSE);
                              }
                          else {
                              cmos[CMOS_REG_C] |= C_UF;
                              }
                          }

                      break;

                case CMOS_REG_C:
                      *value = *cmos_register;

                      /*
                       * Reading Register C on real rtc clears all bits.
                       * However, Need to toggle PF bit when PIE is
                       * not enabled for polling apps.
                       */
                      cmos[CMOS_REG_C] = C_CLEAR;
                      if (!(cmos[CMOS_REG_B] & PIE) && rtc_period_mSeconds) {
                          if (!(*value & C_PF) || (TogglePfCount & 0x8)) {
                              cmos[CMOS_REG_C]  |= C_PF;
                              }
                          }

                      break;

                case CMOS_SECONDS:
                      *value = (*bin2bcd) (ht->Second);
                      break;

                case CMOS_MINUTES:
                      *value = (*bin2bcd) (ht->Minute);
                      break;

                case CMOS_HOURS:
                      *value = (*_24to12) ((*bin2bcd) (ht->Hour));
                      break;

                case CMOS_DAY_WEEK:
                      /* Sunday = 1 on RTC, 0 in HOSTTIME */
                      *value = (*bin2bcd) (ht->WeekDay + 1);
                      break;

                case CMOS_DAY_MONTH:
                      *value = (*bin2bcd) (ht->Day);
                      break;

                case CMOS_MONTH:
                      /* [1-12] on RTC, [1-12] in HOSTTIME */
                      *value = (*bin2bcd) (ht->Month);
                      break;

                case CMOS_YEAR:
                      *value = (*bin2bcd) (ht->Year % 100);
                      break;

                case CMOS_CENTURY:
                      *value = (*bin2bcd) (ht->Year / 100);
                      break;

                default:
                      *value = *cmos_register;
                      break;
                }

            host_ica_unlock();

	}
	note_trace2(CMOS_VERBOSE, "cmos_inb() - port %x, returning val %x",
		    port, *value);
}


GLOBAL void cmos_outb IFN2(io_addr, port, half_word, value)
{
	static IU32 pirUsec[] = {
		     0,
		  3906,
		  7812,
		   122,
		   244,
		   488,
		   976,
		  1953,
		  3906,
		  7812,
		 15625,
		 31250,
		 62500,
		125000,
		250000,
		500000
	};


	/*
	** Tim September 92, hack for DEC 450ST
	*/
	if( port == 0x78 )
	    return;


	port = port & CMOS_BIT_MASK;	/* clear unused bits */

        note_trace2(CMOS_VERBOSE, "cmos_outb() - port %x, val %x", port, value);


        host_ica_lock();
        UpdateCmosTime();


        if (port == CMOS_PORT)
        {
                cmos_register = &cmos[cmos_index = (value & CMOS_ADDR_MASK)];

	} else if (port == CMOS_DATA)
        {
                switch (cmos_index)
		{
		case CMOS_REG_C:
		case CMOS_REG_D:
			/* These two registers are read only */
                        break;

                case CMOS_REG_B:

                        if (value & DM)
			{
				if (data_mode_yes)
				{
					bin2bcd = no_bin2bcd;
					bcd2bin = no_bcd2bin;
					data_mode_yes = FALSE;
				}
			} else
			{
				if (!data_mode_yes)
				{
					bin2bcd = yes_bin2bcd;
					bcd2bin = yes_bcd2bin;
					data_mode_yes = TRUE;
				}
			}
			if (value & _24_HR)
			{
				if (!twenty4_hour_clock)
				{
					_24to12 = no_24to12;
					_12to24 = no_12to24;
					twenty4_hour_clock = TRUE;
				}
			} else
			{
				if (twenty4_hour_clock)
				{
					_24to12 = yes_24to12;
					_12to24 = yes_12to24;
					twenty4_hour_clock = FALSE;
				}
                        }

                        if (value & SET) {
                            value  &= ~UIE;
                            }


                        if (*cmos_register != value) {

                            unsigned char ChangedBits;

                            ChangedBits = *cmos_register ^ value;
                            *cmos_register = value;

                            if (ChangedBits & PIE) {
                                if ((value & PIE) && rtc_period_mSeconds) {
                                    QueueRtcInterrupt(C_PF, FALSE);
                                    }
                                }

                            if (ChangedBits & (AIE | SET)) {
                                if (ChangedBits & SET) {
                                    RtcUpdateCycle = -1;
                                    cmos[CMOS_REG_A] &= ~UIP;
                                    RtcHostUpdateTime = RtcTickTime.tv_sec;
                                    }
                                ResetAlarm();
                                }
                            }

                        break;


		case CMOS_REG_A:
			/* This CMOS byte is read/write except for bit 7 */
			*cmos_register = (*cmos_register & TOP_BIT) | (value & REST);
                        rtc_period_mSeconds = pirUsec[*cmos_register & (RS3 | RS2 | RS1 | RS0)];

                        if ((*cmos_register & 0x70) != 0x20)
			{

                             note_trace1(CMOS_VERBOSE,
                                         "Cmos unsuported divider rate 0x%02x ignored",
                                         *cmos_register & 0x70);
                        }

                        break;


                case CMOS_SECONDS:
                        ht->Second = (*bcd2bin)(value);
                        break;

                case CMOS_MINUTES:
                        ht->Minute = (*bcd2bin)(value);
                        break;

                case CMOS_HOURS:
                        ht->Hour = (*_12to24)((*bcd2bin)(value));
                        break;

                case CMOS_DAY_WEEK:
                        /* Sunday = 1 on RTC, 0 in HOSTTIME */
                        ht->WeekDay  = (*bcd2bin)(value) - 1;
                        break;

                case CMOS_DAY_MONTH:
                        ht->Day = (*bcd2bin)(value);
                        break;

                case CMOS_MONTH:
                        /* [1-12] on RTC, [1-12] in HOSTTIME */
                        ht->Month = (*bcd2bin)(value);
                        break;

                case CMOS_YEAR:
                        ht->Year -=  ht->Year % 100;
                        ht->Year += (*bcd2bin)(value);
                        break;

                case CMOS_CENTURY:
                        ht->Year  %= 100;
                        ht->Year  += (*bcd2bin)(value) * 100;
                        break;

                default:
                        *cmos_register = value;
                        break;
                }



                /*
                 *  if one of the time fields changed Reset the alarm
                 */
                if (cmos_index <= CMOS_HR_ALARM) {
                    ResetAlarm();
                    }

        } else
	{
		note_trace2(CMOS_VERBOSE,
			    "cmos_outb() - Value %x to unsupported port %x", value, port);
        }

        host_ica_unlock();

}




GLOBAL void  cmos_equip_update IFN0()
{
	half_word       equip;

        host_ica_lock();

	if (verify_equip_byte(&equip))
	{
		note_trace0(CMOS_VERBOSE, "updating the equip byte silently");
		cmos[CMOS_EQUIP] = equip;
		/* correct the checksum */
		do_checksum();
        }

        host_ica_unlock();
}

/*
 * * General function to change the specified cmos byte to the specified
 * value
 *
 * MUST NOT BE USED FOR TIME. 14-Nov-1995 Jonle
 */
GLOBAL int cmos_write_byte IFN2(int, cmos_byte, half_word, new_value)
{
        if (cmos_byte >= 0 && cmos_byte <= 64)
        {

                note_trace2(CMOS_VERBOSE, "cmos_write_byte() byte=%x value=%x",
                            cmos_byte, new_value);

                host_ica_lock();
		cmos[cmos_byte] = new_value;
                do_checksum();
                host_ica_unlock();

                return (0);
	} else
	{
		always_trace2("ERROR: cmos write request: byte=%x value=%x",
			      cmos_byte, new_value);
		return (1);
        }

}
/*
 * * General fuunction to read specified cmos byte.
 *
 * MUST NOT BE USED FOR TIME. 14-Nov-1995 Jonle
 *
 */
GLOBAL int cmos_read_byte IFN2(int, cmos_byte, half_word *, value)
{

        if (cmos_byte >= 0 && cmos_byte <= 64)
        {
                host_ica_lock();
                *value = cmos[cmos_byte];
                host_ica_unlock();

		note_trace2(CMOS_VERBOSE, "cmos_read_byte() byte=%x value=%x",
			    cmos_byte, value);
		return (0);
	} else
	{
		always_trace1("ERROR: cmos read request: byte=%x", cmos_byte);
		return (1);
        }

}


void cmos_error IFN6(int, err, half_word, diag, half_word, equip,
	int, equip_err, half_word, floppy, half_word, disk)
{
	char            err_string[256];

	if (err & BAD_SHUT_DOWN)
	{
		strcpy(err_string, "shut ");
		note_trace0(CMOS_VERBOSE, "eek! someone's furtling with the shutdown byte");
	} else
		strcpy(err_string, "");

	if (err & BAD_REG_D)
	{
		strcat(err_string, "power ");
		note_trace0(CMOS_VERBOSE, " The battery is dead - this shouldn't happen!");
	}
	if (err & BAD_DIAG)
	{
		strcat(err_string, "diag ");
		if (diag & BAD_BAT)
			note_trace0(CMOS_VERBOSE, "bad battery");
		if (diag & BAD_CONFIG)
			note_trace0(CMOS_VERBOSE, "bad config");
		if (diag & BAD_CKSUM)
			note_trace0(CMOS_VERBOSE, "bad chksum");
		if (diag & W_MEM_SIZE)
			note_trace0(CMOS_VERBOSE, "memory size != configuration");
		if (diag & HF_FAIL)
			note_trace0(CMOS_VERBOSE, "fixed disk failure on init");
		if (diag & CMOS_CLK_FAIL)
			note_trace0(CMOS_VERBOSE, "cmos clock not updating or invalid");
	}
	if (err & BAD_EQUIP)
	{
		strcat(err_string, "equip ");

		if (equip_err)
		{
			if (equip_err & DRIVE_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect diskette - resetting");
			if (equip_err & DISPLAY_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect display - resetting");
			if (equip_err & NPX_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect npx - resetting CMOS");
			if (equip_err & RESVD_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect reserved bytes - resetting");
		}
	}
	if (err & BAD_FLOPPY)
	{
		strcat(err_string, "flop ");
		note_trace0(CMOS_VERBOSE, "incorrect diskette type - resetting");
	}
	if (err & BAD_DISK)
	{
		strcat(err_string, "disk ");
		note_trace0(CMOS_VERBOSE, "incorrect disk type - resetting");
	}
	if (err & BAD_BMS)
	{
		strcat(err_string, "bms ");
		note_trace0(CMOS_VERBOSE, "bad base memory - resetting");
	}
	if (err & BAD_XMS)
	{
		strcat(err_string, "extended memory ");
		note_trace0(CMOS_VERBOSE, "bad extended memory CMOS entry - resetting");
	}
	if (err & BAD_CHECKSUM)
	{
		strcat(err_string, "cksum ");
		note_trace0(CMOS_VERBOSE, "bad Checksum - resetting");
        }

        if (err & BAD_SHUT_DOWN)
		cmos[CMOS_SHUT_DOWN] = SHUT_INIT;
	if (err & BAD_REG_D)
		cmos[CMOS_REG_D] = REG_D_INIT;
	if (err & BAD_DIAG)
		cmos[CMOS_DIAG] = DIAG_INIT;
	if (err & BAD_EQUIP)
		cmos[CMOS_EQUIP] = equip;
	if (err & BAD_FLOPPY)
		cmos[CMOS_DISKETTE] = floppy;
	if (err & BAD_DISK)
		cmos[CMOS_DISK] = disk;
	if (err & BAD_BMS)
	{
		cmos[CMOS_B_M_S_LO] = BM_LO_INIT;
		cmos[CMOS_B_M_S_HI] = BM_HI_INIT;
	}
	if (err & BAD_XMS)
	{
                cmos[CMOS_E_M_S_LO] = (half_word)((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 10);
                cmos[CMOS_E_M_S_HI] = (half_word)((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 18);
	}
	/* Reset the Checksum if there is any error */
	if (err)
	{
		/* Do the Checksum */
		do_checksum();
	}
}


/*  rtc_nit
 *  Assumes Caller holds Ica lock
 */

GLOBAL void rtc_init(void)
{
     SYSTEMTIME st;

     RtcAlarmTime = 0;
     RtcLastAlarm = 0;
     RtcEoiPending  = FALSE;

     GetLocalTime(&st);
     ht->Second    = st.wSecond;
     ht->Minute    = st.wMinute;
     ht->Hour      = st.wHour;
     ht->Day       = st.wDay;
     ht->Month     = st.wMonth;
     ht->Year      = st.wYear;
     ht->WeekDay   = st.wDayOfWeek;

     host_GetSysTime(&RtcTickTime);
     RtcHostUpdateTime = RtcTickTime.tv_sec;

     ResetAlarm();
}



/*  RtcTick
 *  Assumes caller is holding Ica lock
 *
 *  WARNING: this routine is invoked by the hi-priority heartbeat
 *  thread at a rate of 18.2 time per sec with minimal variance.
 *  It is a polling routine, and because of the hi-freq and hi-priority
 *  it must be mean and lean, so don't do anything which could be
 *  done elsewhere.
 */

GLOBAL void RtcTick(struct host_timeval *time)
{
    /*
     *  Save away the RtcTick time stamp
     */
    RtcTickTime = *time;

    /*
     *  Check if time for Alarm interrupt
     */
    if (RtcAlarmTime && RtcAlarmTime <= RtcTickTime.tv_sec) {
        RtcLastAlarm = RtcTickTime.tv_sec;
        RtcAlarmTime = 0;
        QueueRtcInterrupt(C_AF, FALSE);
        }


    /*
     *  If we are in an update cycle complete it.
     *
     */

    if (RtcUpdateCycle >= 0) {
        RtcUpdateCycle = -1;
        cmos[CMOS_REG_A] &= ~UIP;
        if (cmos[CMOS_REG_B] & UIE) {
            QueueRtcInterrupt(C_UF, FALSE);
            }
        }

     /*
      *  If UIE active, then we have to keep HostTime in
      *  sync so we know when to do the Update End Interrupt.
      */
    else if (cmos[CMOS_REG_B] & UIE) {
        UpdateCmosTime();
        }

}



GLOBAL void cmos_init IFN0()
{
      io_addr         i;

      /* Set Up the cmos time bytes to be in BCD by default */
      bin2bcd = yes_bin2bcd;
      bcd2bin = yes_bcd2bin;
      data_mode_yes = TRUE;

      /* Set Up the cmos hour bytes to be 24 hour by default */
      _24to12 = no_24to12;
      _12to24 = no_12to24;
      twenty4_hour_clock = TRUE;


      /* attach the ports */
      io_define_inb(CMOS_ADAPTOR, cmos_inb);
      io_define_outb(CMOS_ADAPTOR, cmos_outb);

      for (i = CMOS_PORT_START; i <= CMOS_PORT_END; i++)
           io_connect_port(i, CMOS_ADAPTOR, IO_READ_WRITE);


      RegisterEOIHook(8,   // ICA_SLAVE, CPU_RTC_INT
                      RtcIntEoiHook
                      );
      rtc_init();
}


GLOBAL void cmos_pickup IFN0()
{
      /*
       *  Static init plus post is used instead of external files
       */
}


GLOBAL void cmos_post IFN0()
{
	/*
	 * The IBM POST checks the current settings in the CMOS with the
	 * equipment determined by writing to the hardware. Any discrepencies
	 * cause a bad config bit to be set and the user is then requested to
	 * run the Setup utility. Here we check the CMOS against the current
	 * settings in the config structure. If there is a discrepency we
	 * correct the CMOS silently.
	 */
	int             cmos_err, equip_err;
	half_word       diag, equip, floppy, disk;
	word            checksum = 0;
	int             i;


	cmos_err = 0;

	/* Check the Shutdown Byte */
	if (cmos[CMOS_SHUT_DOWN])
		cmos_err |= BAD_SHUT_DOWN;

	/* Check The Power */
	if (!(cmos[CMOS_REG_D] & VRT))
		cmos_err |= BAD_REG_D;

	/* Check The Diagnostic Status Byte */
	if (diag = cmos[CMOS_DIAG])
		cmos_err |= BAD_DIAG;

	/* Check the Equipment Byte */
	if (equip_err = verify_equip_byte(&equip))
		cmos_err |= BAD_EQUIP;

	/* Check the Floppy Byte */
	floppy = gfi_drive_type(1) | (gfi_drive_type(0) << 4);
	if (floppy != cmos[CMOS_DISKETTE])
		cmos_err |= BAD_FLOPPY;

	/* Check the Fixed Disk Type */
	 disk = 0x30;         /* Drive C type always 3 - then <<4 */
	 /* check whether D drive exists */
	 if ( *((CHAR *) config_inquire(C_HARD_DISK2_NAME, NULL)))
		 disk = 0x34;         /* 3 << 4 | 4 */
	if (disk != cmos[CMOS_DISK])
		cmos_err |= BAD_DISK;

	/* Check the Base Memory */
	if ((cmos[CMOS_B_M_S_LO] != BM_LO_INIT) || (cmos[CMOS_B_M_S_HI] != BM_HI_INIT))
		cmos_err |= BAD_BMS;

	/* Check the extended memory */
	if ((cmos[CMOS_E_M_S_LO] !=
	     (((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 10) & 0xff)) ||
	    (cmos[CMOS_E_M_S_HI] !=
	     (((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 18) & 0xff)))
		cmos_err |= BAD_XMS;

	/* Ignore the Contents of the Drive C and Drive D extended bytes */

	/* Do the Checksum */
	for (i = CMOS_DISKETTE; i < CMOS_CKSUM_HI; i++)
	{
		checksum += cmos[i];
	}
	/* If the CMOS is OK test the checksum */
	/* If not, we will have to change it anyway */
	if (!cmos_err)
	{
		if ((checksum & 0xff) != cmos[CMOS_CKSUM_LO])
		{
			cmos_err |= BAD_CHECKSUM;
		}
		if ((checksum >> 8) != cmos[CMOS_CKSUM_HI])
		{
			cmos_err |= BAD_CHECKSUM;
		}
	}
	if (cmos_err)
            cmos_error(cmos_err, diag, equip, equip_err, floppy, disk);

	cmos[CMOS_REG_A] = REG_A_INIT;

        /* Check the Extended Memory */
        cmos[CMOS_U_M_S_LO] = (half_word)((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 10);
        cmos[CMOS_U_M_S_HI] = (half_word)((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 18);

	/* Set up the default cmos location */
	cmos_register = &cmos[cmos_index = CMOS_SHUT_DOWN];

}



/*
 *  WE DON'T EVER read or write a central cmos
 */
GLOBAL void cmos_update IFN0()
{
    ; /* do nothing */
}



/*(
========================= cmos_clear_shutdown_byte ============================
PURPOSE:
	To clear the "shutdown" byte in the CMOS which indicates that the
	next reset is not a "soft" one. (e.g. it is a CTRL-ALT-DEL or panel
	reset). This routine is needed (rather than just doung cmos_outb()
	since the processor might currently be in enhanced mode with io to CMOS
	virtualised.
INPUT:
OUTPUT:
===============================================================================
)*/

GLOBAL void cmos_clear_shutdown_byte IFN0()
{
        host_ica_lock();

        cmos[CMOS_SHUT_DOWN] = 0;

        host_ica_unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\system\cmos.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * Name:		cmos.c
 *
 * Sccs ID:		@(#)cmos.c	1.38 07/11/95
 *
 * Purpose:		Unknown
 * 
 * (c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
 * 
 */

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_CMOS.seg"
#endif


/*
 * O/S include files.
 */
#include <stdlib.h>
#include <stdio.h>
#include StringH
#include TimeH
#include FCntlH

/*
 * SoftPC include files
 */

#include "xt.h"
#include "cmos.h"
#include "cmosbios.h"
#include "ios.h"
#include "spcfile.h"
#include "error.h"
#include "config.h"
#include "timeval.h"
#include "ica.h"
#include "timer.h"
#include "tmstrobe.h"
#include "gfi.h"
#include "sas.h"
#include "debug.h"
#include "quick_ev.h"


/*
 * 
 * ============================================================================
 * Global data
 * ===========================================================================
 * =
 */
static boolean  data_mode_yes;
static          half_word(*bin2bcd) ();
static          half_word(*_24to12) IPT1(half_word, x);
static int      (*bcd2bin) IPT1(int, x);
static int      (*_12to24) ();
static boolean  twenty4_hour_clock;

#if defined(NTVDM) || defined(macintosh)
static boolean  cmos_has_changed = FALSE;
static boolean  cmos_read_in = FALSE;
#endif	/* defined(NTVDM) || defined(macintosh) */

static long     filesize;
static int      cmos_index;
static boolean  reset_alarm = FALSE;
static time_t	user_time = 0;	/* difference between the host and the CMOS
				 * time */
static struct host_tm *ht;	/* The host time */
static IU32 rtc_period_mSeconds = 0;

#if defined(NTVDM) || defined(macintosh)
static half_word cmos[CMOS_SIZE] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* Timing info + alarms */
	REG_A_INIT,
	REG_B_INIT,
	REG_C_INIT,
	REG_D_INIT,
	DIAG_INIT,
	SHUT_INIT,
	FLOP_INIT,
	CMOS_RESVD,
	DISK_INIT,
	CMOS_RESVD,
	EQUIP_INIT,
	BM_LO_INIT, BM_HI_INIT,
	EXP_LO, EXP_HI,
	DISK_EXTEND, DISK2_EXTEND,
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x1b - 0x1e */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x1f - 0x22 */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x23 - 0x26 */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x27 - 0x2a */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x2b - 0x2d */
	CHK_HI_INIT, CHK_LO_INIT,
	EXT_LO_INIT, EXT_HI_INIT,
	CENT_INIT,
	INFO_128_INIT,
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x34 - 0x37 */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x38 - 0x3b */
	CMOS_RESVD, CMOS_RESVD, CMOS_RESVD, CMOS_RESVD,	/* 0x3c - 0x3f */
};
#else	/* defined(NTVDM) || defined(macintosh) */
static half_word cmos[CMOS_SIZE];
#endif	/* defined(NTVDM) || defined(macintosh) */

static half_word *cmos_register = &cmos[CMOS_SHUT_DOWN];

#ifdef NTVDM
unsigned long   dwTickCount,dwAccumulativeMilSec;
extern unsigned long GetTickCount (VOID);
#endif

#ifdef TEST_HARNESS
unsigned long   io_verbose = 0;
#endif

int             rtc_int_enabled;


/*
 * 
 * ============================================================================
 * Static data and defines
 * ===========================================================================
 * =
 */

/*
 * 
 * ============================================================================
 * Internal functions
 * ===========================================================================
 * =
 */

LOCAL q_ev_handle rtc_periodic_event_handle = (q_ev_handle)0;

LOCAL void rtc_periodic_event IFN1(long, parm)
{
	if (cmos[CMOS_REG_B] & PIE)
	{
		cmos[CMOS_REG_C] |= (C_IRQF | C_PF);
		note_trace2(CMOS_VERBOSE, "INTERRUPT: PIE regC=%02x uS=%d",
			    cmos[CMOS_REG_C], rtc_period_mSeconds);
		ica_hw_interrupt(ICA_SLAVE, CPU_RTC_INT, 1);
		rtc_periodic_event_handle = add_q_event_t(rtc_periodic_event,
							  rtc_period_mSeconds,
							  0);
	}
	else
	{
		rtc_periodic_event_handle = (q_ev_handle)0;
	}
}

LOCAL void change_pie IFN1(IBOOL, newPIE)
{
	if (newPIE && (rtc_period_mSeconds != 0))
	{
		/* Turning on periodic interrupts */

		note_trace1(CMOS_VERBOSE, "Starting periodic interrupts every %d uS", rtc_period_mSeconds);
		rtc_periodic_event_handle = add_q_event_t(rtc_periodic_event,
							  rtc_period_mSeconds,
							  0);
	}
	else
	{
		/* Turning off periodic interrupts */
		note_trace0(CMOS_VERBOSE, "Stopping periodic interrupts");
		delete_q_event( rtc_periodic_event_handle );
	}
}

LOCAL void enable_nmi IFN0()
{
}

LOCAL void disable_nmi IFN0()
{
}

LOCAL void do_checksum IFN0()
{
	int             i;
	word            checksum = 0;

	for (i = CMOS_DISKETTE; i < CMOS_CKSUM_HI; i++)
	{
		checksum += cmos[i];
	}
	cmos[CMOS_CKSUM_LO] = checksum & 0xff;
	cmos[CMOS_CKSUM_HI] = checksum >> 8;
}

LOCAL half_word yes_bin2bcd IFN1(int, x)
{
	/* converts binary x to bcd */
	half_word       tens, units;

	tens = x / 10;
	units = x - tens * 10;
	return ((tens << 4) + units);
}

LOCAL half_word no_bin2bcd IFN1(int, x)
{
	return ((half_word) x);
}

LOCAL int yes_bcd2bin IFN1(int, x)
{
	/* converts x in bcd format to binary */
	return ((int) ((x & 0x0f) + (x >> 4) * 10));
}

LOCAL int no_bcd2bin IFN1(int, x)
{
	return ((int) (half_word) x);
}

LOCAL int no_12to24 IFN1(int, x)
{
	return (x);
}

LOCAL half_word no_24to12 IFN1(half_word, x)
{
	return (x);
}

LOCAL half_word yes_24to12 IFN1(half_word, x)
{
	/* converts binary or bcd x from 24 to 12 hour clock */
	half_word       y = (*bin2bcd) (12);

	if (x > y)
		x = (x - y) | 0x80;
	else if (x == 0)
		x = y | 0x80;
	return (x);
}

LOCAL int yes_12to24 IFN1(int, x)
{
	/* converts binary or bcd x from 12 to 24 hour clock */
	half_word       y = (*bin2bcd) (12);

	if (x == (0x80 + y))
		return (0);
	else if (x & 0x80)
		return ((x & 0x7f) + y);
	else
		return (x);
}

LOCAL void rtc_alarm IFN1(long, param)
{
        UNUSED (param);

	note_trace0(CMOS_VERBOSE, "rtc_alarm() gone off");

	cmos[CMOS_REG_C] |= C_AF;

	if (cmos[CMOS_REG_B] & AIE)
	{
		note_trace0(CMOS_VERBOSE, "rtc_alarm() setting IRQF due to AIE");
		cmos[CMOS_REG_C] |= C_IRQF;
		if (rtc_int_enabled)
		{
			note_trace1(CMOS_VERBOSE, "INTERRUPT: AIE regC=%02x", cmos[CMOS_REG_C]);
			ica_hw_interrupt(ICA_SLAVE, CPU_RTC_INT, 1);
		}
	}

	reset_alarm = TRUE;
}

LOCAL void set_alarm IFN0()
{
#ifndef	JOKER

	long            numsecs;
	long            alarm_secs, now_secs;
	long            num_pc_ticks;
	static word     handle;

	if (cmos[CMOS_HR_ALARM] & DONT_CARE)
	{
		if (cmos[CMOS_MIN_ALARM] & DONT_CARE)
		{
			if (cmos[CMOS_SEC_ALARM] & DONT_CARE)
				numsecs = 1;
			else
				numsecs = 60;
		} else
			numsecs = 3600;
	} else
	{
		alarm_secs = (*bcd2bin) (cmos[CMOS_SEC_ALARM]) +
			((*bcd2bin) (cmos[CMOS_MIN_ALARM]) * 60) +
			((*_12to24) ((*bcd2bin) (cmos[CMOS_HR_ALARM])) * 3600);
		now_secs = ht->tm_sec + 60 * ht->tm_min + 3600 * ht->tm_hour;
		numsecs = alarm_secs - now_secs;
		if (numsecs < 0)
			numsecs += 24 * 3600;
	}

	/* As close as we can to 18.2 Hz */
	num_pc_ticks = 18 * numsecs;

	note_trace1(CMOS_VERBOSE, "set_alarm() requesting alarm in %d ticks", num_pc_ticks);
	if (handle > 0)
		delete_tic_event(handle);
	handle = add_tic_event(rtc_alarm, num_pc_ticks, 0);

#endif	/* JOKER */

}

LOCAL int verify_equip_byte IFN1(half_word *, equip)
{
	static half_word display_mask[] = 
	{
		MDA_PRINTER,	CGA_80_COLUMN,	CGA_80_COLUMN,
		OWN_BIOS,	MDA_PRINTER
	};
	int equip_err;
	int num_flops;
	SHORT adapter;

	/* Check the Equipment Byte */
	*equip = 0;
	adapter = (ULONG) config_inquire(C_GFX_ADAPTER, NULL);
	if(adapter != -1)
		*equip |= display_mask[adapter];

	if( host_runtime_inquire(C_NPX_ENABLED) )
		*equip |= CO_PROCESSOR_PRESENT;

#ifdef SLAVEPC
	if (host_runtime_inquire(C_FLOPPY_SERVER) == GFI_SLAVE_SERVER)
	{
		num_flops =
			(*(CHAR *) config_inquire(C_SLAVEPC_DEVICE, NULL))
			? 1:0;
	}
	else
#endif /* SLAVEPC */
	{
		num_flops  =
			(*(CHAR *) config_inquire(C_FLOPPY_A_DEVICE, NULL))
			? 1:0;
#ifdef FLOPPY_B
		num_flops +=
			(*(CHAR *) config_inquire(C_FLOPPY_B_DEVICE, NULL))
			? 1:0;
#endif
	}

	if (num_flops == 2)
		*equip |= TWO_DRIVES;
	if (num_flops)
		*equip |= DISKETTE_PRESENT;

	equip_err = (*equip ^ cmos[CMOS_EQUIP]);
	return equip_err;
}

/*
 * =========================================================================
 *  External functions
 * =========================================================================
 */

GLOBAL void cmos_inb IFN2(io_addr, port, half_word *, value)
{
#ifndef NTVDM
IMPORT ADAPTER_STATE adapter_state[2];
#else
IMPORT VDMVIRTUALICA VirtualIca[];
#define ADAPTER_STATE VDMVIRTUALICA
#define adapter_state VirtualIca
#endif /* !NTVDM */

#ifdef NTVDM
	/*
	** Tim September 92, hack for DEC 450ST
	*/
	if( port==0x78 )
	{
		*value = 0;
		return;
	}
#endif
	port = port & CMOS_BIT_MASK;	/* clear unused bits */

	if (port == CMOS_DATA)
	{
		*value = *cmos_register;

		/*
		 * We clear the UIP bit every time we read register A, (whether
		 * it was set or not) as previously we had it set for a whole
		 * timer tick, which could fool a DOS retry.
		 */
		 
		if (cmos_index == CMOS_REG_A) {
			cmos[CMOS_REG_A] &= ~UIP;
		
		} else 	if (cmos_index == CMOS_REG_C) {
			/* 
			 * Reading Register C clears it.
		 	 */
			*cmos_register = C_CLEAR;
		}
		else if (cmos_index < CMOS_REG_A)
		{
#ifndef NTVDM
#ifndef PROD
			if (host_getenv("TIME_OF_DAY_FRIG") == NULL)
			{
#endif /* !PROD */
#endif /* !NTVDM */

				switch (cmos_index)
				{
				case CMOS_SECONDS:
					*cmos_register = (*bin2bcd) (ht->tm_sec);
					break;
				case CMOS_MINUTES:
					*cmos_register = (*bin2bcd) (ht->tm_min);
					break;
				case CMOS_HOURS:
					*cmos_register = (*_24to12) ((*bin2bcd) (ht->tm_hour));
					break;
				case CMOS_DAY_WEEK:
					/* Sunday = 1 on RTC, 0 in structure */
					*cmos_register = (*bin2bcd) (ht->tm_wday + 1);
					break;
				case CMOS_DAY_MONTH:
					*cmos_register = (*bin2bcd) (ht->tm_mday);
					break;
				case CMOS_MONTH:
					/* [1-12] on RTC, [0-11] in structure */
					*cmos_register = (*bin2bcd) (ht->tm_mon + 1);
					break;
				case CMOS_YEAR:
					*cmos_register = (*bin2bcd) (ht->tm_year);
					break;
				default:
					break;
				}
#ifndef NTVDM
#ifndef PROD
			} else
			{
				static int      first = 1;

				if (first)
				{
					first = 0;
					printf("FRIG ALERT!!!! - cmos clock frozen!");
				}
				*cmos_register = 1;
			}
#endif /* !PROD */
#endif /* !NTVDM */

			*value = *cmos_register;
		}
	}
	note_trace2(CMOS_VERBOSE, "cmos_inb() - port %x, returning val %x",
		    port, *value);
}


GLOBAL void cmos_outb IFN2(io_addr, port, half_word, value)
{
	static IU32 pirUsec[] = {
		     0,
		  3906,
		  7812,
		   122,
		   244,
		   488,
		   976,
		  1953,
		  3906,
		  7812,
		 15625,
		 31250,
		 62500,
		125000,
		250000,
		500000
	};

#ifdef NTVDM
	/*
	** Tim September 92, hack for DEC 450ST
	*/
	if( port == 0x78 )
	    return;
#endif /* NTVDM */

	port = port & CMOS_BIT_MASK;	/* clear unused bits */

	note_trace2(CMOS_VERBOSE, "cmos_outb() - port %x, val %x", port, value);

	if (port == CMOS_PORT)
	{
		if (value & NMI_DISABLE)
			disable_nmi();
		else
			enable_nmi();

		cmos_register = &cmos[cmos_index = (value & CMOS_ADDR_MASK)];
	} else if (port == CMOS_DATA)
	{
		switch (cmos_index)
		{
		case CMOS_REG_C:
		case CMOS_REG_D:
			/* These two registers are read only */
			break;
		case CMOS_REG_B:
			if (value & DM)
			{
				if (data_mode_yes)
				{
					bin2bcd = no_bin2bcd;
					bcd2bin = no_bcd2bin;
					data_mode_yes = FALSE;
				}
			} else
			{
				if (!data_mode_yes)
				{
					bin2bcd = yes_bin2bcd;
					bcd2bin = yes_bcd2bin;
					data_mode_yes = TRUE;
				}
			}
			if (value & _24_HR)
			{
				if (!twenty4_hour_clock)
				{
					_24to12 = no_24to12;
					_12to24 = no_12to24;
					twenty4_hour_clock = TRUE;
				}
			} else
			{
				if (twenty4_hour_clock)
				{
					_24to12 = yes_24to12;
					_12to24 = yes_12to24;
					twenty4_hour_clock = FALSE;
				}
			}

			if (*cmos_register != value)
			{
#if defined(NTVDM) || defined(macintosh)
				cmos_has_changed = TRUE;
#endif
				if ((*cmos_register ^ value) & PIE)
				{
					change_pie((value & PIE) != 0);
				}
				*cmos_register = value;
			}
			break;
		case CMOS_REG_A:
			/* This CMOS byte is read/write except for bit 7 */
			*cmos_register = (*cmos_register & TOP_BIT) | (value & REST);
			rtc_period_mSeconds = pirUsec[*cmos_register & (RS3 | RS2 | RS1 | RS0)];
			if ((*cmos_register & 0x70) != 0x20)
			{
				/* Internal divider is set to non-standard rate. */
				note_trace1(CMOS_VERBOSE,
					    "Cmos unsuported divider rate 0x%02x ignored",
					    *cmos_register & 0x70);
			}
#if defined(NTVDM) || defined(macintosh)
			cmos_has_changed = TRUE;
#endif
			break;
		case CMOS_SECONDS:
			/* This CMOS byte is read/write except for bit 7 */
			*cmos_register = (*cmos_register & TOP_BIT) | (value & REST);
			user_time += (*bcd2bin) (value) - ht->tm_sec;
			reset_alarm = TRUE;
			break;
		case CMOS_MINUTES:
			user_time += ((*bcd2bin) (value) - ht->tm_min) * 60;
			*cmos_register = value;
			reset_alarm = TRUE;
			break;
		case CMOS_HOURS:
			user_time += ((*_12to24) ((*bcd2bin) (value)) - ht->tm_hour) * 60 * 60;
			*cmos_register = value;
			reset_alarm = TRUE;
			break;
		case CMOS_DAY_WEEK:
			/* this being changed doesn't change the time */
			*cmos_register = value;
			break;
		case CMOS_DAY_MONTH:
			user_time += ((*bcd2bin) (value) - ht->tm_mday) * 60 * 60 * 24;
			*cmos_register = value;
			break;
		case CMOS_MONTH:
			user_time += ((*bcd2bin) (value) - 1 - ht->tm_mon) * 60 * 60 * 24 * 30;
			*cmos_register = value;
			break;
		case CMOS_YEAR:
			user_time += ((*bcd2bin) (value) - ht->tm_year) * 60 * 60 * 24 * 30 * 12;
			*cmos_register = value;
			break;
		case CMOS_SEC_ALARM:
		case CMOS_MIN_ALARM:
		case CMOS_HR_ALARM:
			reset_alarm = TRUE;
			/* falling through */
		default:
			*cmos_register = value;
#if defined(NTVDM) || defined(macintosh)
			cmos_has_changed = TRUE;
#endif
			break;
		}
	} else
	{
		note_trace2(CMOS_VERBOSE,
			    "cmos_outb() - Value %x to unsupported port %x", value, port);
	}
}

static int      cmos_count = 0;

GLOBAL void rtc_tick IFN0()
{
	switch (cmos_count)
	{
	case 0:
		if (cmos[CMOS_REG_B] & UIE)
		{
			cmos[CMOS_REG_C] |= C_IRQF;
			note_trace0(CMOS_VERBOSE, "rtc_tick() setting IRQF due to UIE");
			if (rtc_int_enabled)
			{
				note_trace1(CMOS_VERBOSE, "INTERRUPT: UIE regC=%02x", cmos[CMOS_REG_C]);
				ica_hw_interrupt(ICA_SLAVE, CPU_RTC_INT, 1);
			}
		}

		/*
		 * Set the C_UF and UIP bits until the next timer tick.
		 * We also clear the UIP bit if register A is read, so that
		 * it doesn't stay on to long (done elsewhere).
		 */
		 
		cmos[CMOS_REG_C] ^= C_UF;
#ifndef NTVDM
		cmos[CMOS_REG_A] |= UIP;	/* Set the bit */
#endif
		break;

	case 1:
		cmos[CMOS_REG_C] ^= C_UF;
#ifndef NTVDM
		cmos[CMOS_REG_A] &= ~UIP;	/* Clear it again */
#endif
		break;

	case 17:
		/* update the time at some suitable point in cycle */
		if (cmos[CMOS_REG_B] & SET)
		{
			/* User is updating user_time */
		} else
		{
#ifdef NTVDM
        /* sudeepb 08-Jul-1993 Old code assumed rtc-tick will be called */
        /* 20 times a second. This is not true under NTVDM. So we have  */
        /* to keep track of time seperately and add to the cmos time.   */
unsigned long dwTemp;
                    dwTemp =  GetTickCount();
                    dwAccumulativeMilSec += (dwTemp - dwTickCount);
                    dwTickCount = dwTemp;
                    ht->tm_sec = (ULONG) ht->tm_sec +
                                        (dwAccumulativeMilSec / 1000);
                    dwAccumulativeMilSec = dwAccumulativeMilSec % 1000;
                    if (ht->tm_sec >= 60)
                    {
                            ht->tm_min += (ht->tm_sec / 60);
                            ht->tm_sec = (ht->tm_sec % 60);
                            if (ht->tm_min >= 60)
                            {
                                    ht->tm_hour++;
                                    ht->tm_min -= 60;
                                    if (ht->tm_hour == 25)
                                    {
                                            ht->tm_hour = 0;
                                            ht->tm_mday++;
                                            /* Kop out at this point */
                                    }
                            }
                    }
#else /* NTVDM */
			/* simple update - add 1 second to time */
			ht->tm_sec++;
			if (ht->tm_sec == 60)
			{
				ht->tm_sec = 0;
				ht->tm_min++;
				if (ht->tm_min == 60)
				{
					ht->tm_min = 0;
					ht->tm_hour++;
					if (ht->tm_hour == 25)
					{
						ht->tm_hour = 0;
						ht->tm_mday++;
						/* Kop out at this point */
					}
				}
			}
#endif /* NTVDM */
		}
		break;

	default:
		break;
	}

	/* As close as we can to 18.2 Hz */
	cmos_count = (++cmos_count) % 18;

	if ((rtc_periodic_event_handle == (q_ev_handle)0)
	    && ((cmos[CMOS_REG_B] & PIE) == 0))
	{
		/* There is no period interrupt being generated by quick event,
		 * and periodic interrupts are not enabled, so waggle the status
		 * bit in case something is polling.
		 */
		cmos[CMOS_REG_C] ^= C_PF;
	}
	if (reset_alarm)
	{
		reset_alarm = FALSE;
		set_alarm();
	}
}

GLOBAL void  cmos_equip_update IFN0()
{
	half_word       equip;

	if (verify_equip_byte(&equip))
	{
		note_trace0(CMOS_VERBOSE, "updating the equip byte silently");
		cmos[CMOS_EQUIP] = equip;
		/* correct the checksum */
		do_checksum();
	}
}

/*
 * * General function to change the specified cmos byte to the specified
 * value
 */
GLOBAL int cmos_write_byte IFN2(int, cmos_byte, half_word, new_value)
{
	note_trace2(CMOS_VERBOSE, "cmos_write_byte() byte=%x value=%x",
		    cmos_byte, new_value);
	if (cmos_byte >= 0 && cmos_byte <= 64)
	{
		cmos[cmos_byte] = new_value;
		do_checksum();
		return (0);
	} else
	{
		always_trace2("ERROR: cmos write request: byte=%x value=%x",
			      cmos_byte, new_value);
		return (1);
	}
}
/*
 * * General fuunction to read specified cmos byte.
 */
GLOBAL int cmos_read_byte IFN2(int, cmos_byte, half_word *, value)
{
	if (cmos_byte >= 0 && cmos_byte <= 64)
	{
		*value = cmos[cmos_byte];
		note_trace2(CMOS_VERBOSE, "cmos_read_byte() byte=%x value=%x",
			    cmos_byte, value);
		return (0);
	} else
	{
		always_trace1("ERROR: cmos read request: byte=%x", cmos_byte);
		return (1);
	}
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

#if defined(NTVDM) || defined(macintosh)
LOCAL void read_cmos IFN0() 
{
	filesize = host_read_resource(CMOS_REZ_ID, CMOS_FILE_NAME,
				      cmos, sizeof(cmos), SILENT);

	/* Set a flag to say we've tried to read the CMOS file */
	cmos_read_in = TRUE;
}
#endif	/* defined(NTVDM) || defined(macintosh) */

#if defined(NTVDM) || defined(macintosh)
LOCAL void write_cmos IFN0()
{
	/* terminate might be called before reset */
	if (cmos_read_in && cmos_has_changed)
	{
		host_write_resource(CMOS_REZ_ID, CMOS_FILE_NAME,
				    cmos, sizeof(cmos));
	}
}
#endif	/* defined(NTVDM) || defined(macintosh) */

LOCAL void cmos_error IFN6(int, err, half_word, diag, half_word, equip,
	int, equip_err, half_word, floppy, half_word, disk)
{
	char            err_string[256];

	if (err & BAD_SHUT_DOWN)
	{
		strcpy(err_string, "shut ");
		note_trace0(CMOS_VERBOSE, "eek! someone's furtling with the shutdown byte");
	} else
		strcpy(err_string, "");

	if (err & BAD_REG_D)
	{
		strcat(err_string, "power ");
		note_trace0(CMOS_VERBOSE, " The battery is dead - this shouldn't happen!");
	}
	if (err & BAD_DIAG)
	{
		strcat(err_string, "diag ");
		if (diag & BAD_BAT)
			note_trace0(CMOS_VERBOSE, "bad battery");
		if (diag & BAD_CONFIG)
			note_trace0(CMOS_VERBOSE, "bad config");
		if (diag & BAD_CKSUM)
			note_trace0(CMOS_VERBOSE, "bad chksum");
		if (diag & W_MEM_SIZE)
			note_trace0(CMOS_VERBOSE, "memory size != configuration");
		if (diag & HF_FAIL)
			note_trace0(CMOS_VERBOSE, "fixed disk failure on init");
		if (diag & CMOS_CLK_FAIL)
			note_trace0(CMOS_VERBOSE, "cmos clock not updating or invalid");
	}
	if (err & BAD_EQUIP)
	{
		strcat(err_string, "equip ");

		if (equip_err)
		{
			if (equip_err & DRIVE_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect diskette - resetting");
			if (equip_err & DISPLAY_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect display - resetting");
			if (equip_err & NPX_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect npx - resetting CMOS");
			if (equip_err & RESVD_INFO)
				note_trace0(CMOS_VERBOSE, "incorrect reserved bytes - resetting");
		}
	}
	if (err & BAD_FLOPPY)
	{
		strcat(err_string, "flop ");
		note_trace0(CMOS_VERBOSE, "incorrect diskette type - resetting");
	}
	if (err & BAD_DISK)
	{
		strcat(err_string, "disk ");
		note_trace0(CMOS_VERBOSE, "incorrect disk type - resetting");
	}
	if (err & BAD_BMS)
	{
		strcat(err_string, "bms ");
		note_trace0(CMOS_VERBOSE, "bad base memory - resetting");
	}
	if (err & BAD_XMS)
	{
		strcat(err_string, "extended memory ");
		note_trace0(CMOS_VERBOSE, "bad extended memory CMOS entry - resetting");
	}
	if (err & BAD_CHECKSUM)
	{
		strcat(err_string, "cksum ");
		note_trace0(CMOS_VERBOSE, "bad Checksum - resetting");
	}
#ifndef PROD
	if (!filesize)
		always_trace1("Incorrect CMOS entries %s", err_string);
#endif

	if (err & BAD_SHUT_DOWN)
		cmos[CMOS_SHUT_DOWN] = SHUT_INIT;
	if (err & BAD_REG_D)
		cmos[CMOS_REG_D] = REG_D_INIT;
	if (err & BAD_DIAG)
		cmos[CMOS_DIAG] = DIAG_INIT;
	if (err & BAD_EQUIP)
		cmos[CMOS_EQUIP] = equip;
	if (err & BAD_FLOPPY)
		cmos[CMOS_DISKETTE] = floppy;
	if (err & BAD_DISK)
		cmos[CMOS_DISK] = disk;
	if (err & BAD_BMS)
	{
		cmos[CMOS_B_M_S_LO] = BM_LO_INIT;
		cmos[CMOS_B_M_S_HI] = BM_HI_INIT;
	}
	if (err & BAD_XMS)
	{
		cmos[CMOS_E_M_S_LO] =
			((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 10) & 0xff;
		cmos[CMOS_E_M_S_HI] =
			((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 18) & 0xff;
	}
	/* Reset the Checksum if there is any error */
	if (err)
	{
		/* Do the Checksum */
		do_checksum();
	}
}

GLOBAL void cmos_init IFN0()
{
#ifndef TEST_HARNESS
	cmos_io_attach();
#endif

#ifndef NTVDM
#ifndef PROD
	if (host_getenv("TIME_OF_DAY_FRIG") == NULL)
#endif	/* PROD */
#endif	/* NTVDM */
		rtc_int_enabled = TRUE;
#ifndef NTVDM
#ifndef PROD
	else
		rtc_int_enabled = FALSE;
#endif	/* PROD */
#endif	/* NTVDM */

	rtc_init();
}

#if defined(NTVDM) || defined(macintosh)
GLOBAL void cmos_pickup IFN0()
{
	read_cmos();
}
#endif	/* defined(NTVDM) || defined(macintosh) */

GLOBAL void cmos_io_attach IFN0()
{
	io_addr         i;

	io_define_inb(CMOS_ADAPTOR, cmos_inb);
	io_define_outb(CMOS_ADAPTOR, cmos_outb);

	for (i = CMOS_PORT_START; i <= CMOS_PORT_END; i++)
		io_connect_port(i, CMOS_ADAPTOR, IO_READ_WRITE);
}

GLOBAL void cmos_post IFN0()
{
	/*
	 * The IBM POST checks the current settings in the CMOS with the
	 * equipment determined by writing to the hardware. Any discrepencies
	 * cause a bad config bit to be set and the user is then requested to
	 * run the Setup utility. Here we check the CMOS against the current
	 * settings in the config structure. If there is a discrepency we
	 * correct the CMOS silently.
	 */
	int             cmos_err, equip_err;
	half_word       diag, equip, floppy, disk;
	word            checksum = 0;
	int             i;


	cmos_err = 0;

	/* Check the Shutdown Byte */
	if (cmos[CMOS_SHUT_DOWN])
		cmos_err |= BAD_SHUT_DOWN;

	/* Check The Power */
	if (!(cmos[CMOS_REG_D] & VRT))
		cmos_err |= BAD_REG_D;

	/* Check The Diagnostic Status Byte */
	if (diag = cmos[CMOS_DIAG])
		cmos_err |= BAD_DIAG;

	/* Check the Equipment Byte */
	if (equip_err = verify_equip_byte(&equip))
		cmos_err |= BAD_EQUIP;

	/* Check the Floppy Byte */
	floppy = gfi_drive_type(1) | (gfi_drive_type(0) << 4);
	if (floppy != cmos[CMOS_DISKETTE])
		cmos_err |= BAD_FLOPPY;

	/* Check the Fixed Disk Type */
	 disk = 0x30;         /* Drive C type always 3 - then <<4 */
	 /* check whether D drive exists */
	 if ( *((CHAR *) config_inquire(C_HARD_DISK2_NAME, NULL)))
		 disk = 0x34;         /* 3 << 4 | 4 */
	if (disk != cmos[CMOS_DISK])
		cmos_err |= BAD_DISK;

	/* Check the Base Memory */
	if ((cmos[CMOS_B_M_S_LO] != BM_LO_INIT) || (cmos[CMOS_B_M_S_HI] != BM_HI_INIT))
		cmos_err |= BAD_BMS;

	/* Check the extended memory */
	if ((cmos[CMOS_E_M_S_LO] !=
	     ((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 10) & 0xff) ||
	    (cmos[CMOS_E_M_S_HI] !=
	     ((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 18) & 0xff))
		cmos_err |= BAD_XMS;

	/* Ignore the Contents of the Drive C and Drive D extended bytes */

	/* Do the Checksum */
	for (i = CMOS_DISKETTE; i < CMOS_CKSUM_HI; i++)
	{
		checksum += cmos[i];
	}
	/* If the CMOS is OK test the checksum */
	/* If not, we will have to change it anyway */
	if (!cmos_err)
	{
		if ((checksum & 0xff) != cmos[CMOS_CKSUM_LO])
		{
			cmos_err |= BAD_CHECKSUM;
		}
		if ((checksum >> 8) != cmos[CMOS_CKSUM_HI])
		{
			cmos_err |= BAD_CHECKSUM;
		}
	}
	if (cmos_err)
		cmos_error(cmos_err, diag, equip, equip_err, floppy, disk);

	cmos[CMOS_REG_A] = REG_A_INIT;

#if	!defined(JOKER) && !defined(NTVDM)
	set_tod();
#endif	/* JOKER */

	/* Check the Extended Memory */
	cmos[CMOS_U_M_S_LO] = ((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 10) & 0xff;
	cmos[CMOS_U_M_S_HI] = ((sys_addr) (sas_memory_size() - PC_MEM_SIZE) >> 18) & 0xff;

	/* Set up the default cmos location */
	cmos_register = &cmos[cmos_index = CMOS_SHUT_DOWN];

#if defined(NTVDM) || defined(macintosh)
	cmos_has_changed = FALSE;
#endif
}

GLOBAL void cmos_update IFN0()
{
#if defined(NTVDM) || defined(macintosh)
#ifndef PROD
	int             i;
#endif				/* nPROD */
#else	/* defined(NTVDM) || defined(macintosh) */
	ConfigValues *value;
	char *strPtr;
	int i;
#endif	/* defined(NTVDM) || defined(macintosh) */

#if defined(NTVDM) || defined(macintosh)
	write_cmos();
#else	/* defined(NTVDM) || defined(macintosh) */
	cmos_equip_update();
	config_get(C_CMOS,&value);
	strPtr = value->string;

	for (i = 0; i < CMOS_SIZE; ++i)
		strPtr += sprintf(strPtr,"%02x ",cmos[i]);

	config_put(C_CMOS,NULL);
#endif	/* defined(NTVDM) || defined(macintosh) */

#ifndef PROD
	if (io_verbose & CMOS_VERBOSE)
	{
		for (i = 0; i < 64; i++)
			fprintf(trace_file, "%02x ", cmos[i]);
		fprintf(trace_file, "\n");
		fflush(trace_file);
	}
#endif
}

#ifdef NTVDM
/* NTVDM build does rtc recalibration on rtc_tick */
GLOBAL void  rtc_init IFN0()
{
	long            bintim;

	cmos_count = 0;
	bintim = host_time((long *) 0);
        ht = host_localtime(&bintim);
#ifdef NTVDM
        dwTickCount = GetTickCount ();
        dwAccumulativeMilSec = 0;
#endif

	/* Set Up the cmos time bytes to be in BCD by default */
	bin2bcd = yes_bin2bcd;
	bcd2bin = yes_bcd2bin;
	data_mode_yes = TRUE;

	/* Set Up the cmos hour bytes to be 24 hour by default */
	_24to12 = no_24to12;
	_12to24 = no_12to24;
	twenty4_hour_clock = TRUE;

	cmos[CMOS_SECONDS] = (*bin2bcd) (ht->tm_sec);
        cmos[CMOS_MINUTES] = (*bin2bcd) (ht->tm_min);
	cmos[CMOS_HOURS] = (*_24to12) ((*bin2bcd) (ht->tm_hour));
	cmos[CMOS_DAY_WEEK] = (*bin2bcd) (ht->tm_wday + 1);
	cmos[CMOS_MONTH] = (*bin2bcd) (ht->tm_mon + 1);
	cmos[CMOS_YEAR] = (*bin2bcd) (ht->tm_year);
	cmos[CMOS_CENTURY] = (*bin2bcd) (19);

	set_alarm();
}





#else

LOCAL void
sync_rtc_to_host_time IFN1( long, param )
{
	time_t bintim;

	UNUSED( param );

	cmos_count = 0;
	bintim = host_time(NULL);
	ht = host_localtime(&bintim);

	cmos[CMOS_SECONDS] = (*bin2bcd) (ht->tm_sec);
	cmos[CMOS_MINUTES] = (*bin2bcd) (ht->tm_min);
	cmos[CMOS_HOURS] = (*_24to12) ((*bin2bcd) (ht->tm_hour));
	cmos[CMOS_DAY_WEEK] = (*bin2bcd) (ht->tm_wday + 1);
	cmos[CMOS_MONTH] = (*bin2bcd) (ht->tm_mon + 1);
	cmos[CMOS_YEAR] = (*bin2bcd) (ht->tm_year);
	cmos[CMOS_CENTURY] = (*bin2bcd) (19);

	/*
	 * Re-sync every 200 ticks ( ca. 11 seconds ). This stops
	 * the RTC from running slow on a loaded machine ( which
	 * loses host heartbeat events ( SIGALRM on Unix )).
	 * 200 ticks is not too often as to be a performance impact
	 * but should be often enough to be useful.
	 */

	(void) add_tic_event( sync_rtc_to_host_time, 200, 0 );
}

GLOBAL void  rtc_init IFN0()
{
#ifdef NTVDM
        dwTickCount = GetTickCount ();
        dwAccumulativeMilSec = 0;
#endif

	/* Set Up the cmos time bytes to be in BCD by default */
	bin2bcd = yes_bin2bcd;
	bcd2bin = yes_bcd2bin;
	data_mode_yes = TRUE;

	/* Set Up the cmos hour bytes to be 24 hour by default */
	_24to12 = no_24to12;
	_12to24 = no_12to24;
	twenty4_hour_clock = TRUE;

	sync_rtc_to_host_time( 0 );

	set_alarm();
}

#endif	/* NTVDM */

/*(
========================= cmos_clear_shutdown_byte ============================
PURPOSE:
	To clear the "shutdown" byte in the CMOS which indicates that the
	next reset is not a "soft" one. (e.g. it is a CTRL-ALT-DEL or panel
	reset). This routine is needed (rather than just doung cmos_outb()
	since the processor might currently be in enhanced mode with io to CMOS
	virtualised.
INPUT:
OUTPUT:
===============================================================================
)*/

GLOBAL void cmos_clear_shutdown_byte IFN0()
{
	cmos[CMOS_SHUT_DOWN] = 0;
}


#if !defined(NTVDM) && !defined(macintosh)
/*(
=============================== ValidateCmos ==================================
PURPOSE:
	Initialise CMOS array from values in configuration file.
INPUT:
	hostID - I.D. number of CMOS configuration entry
	vals - Value of CMOS configuration entry
	table - Not used
OUTPUT:
	errString - Error string.
	
	Returns C_CONFIG_OP_OK if CMOS configuration value OK, EG_BAD_VALUE if
	bad value.
===============================================================================
)*/

GLOBAL SHORT ValidateCmos IFN4(
    UTINY, hostID, 
    ConfigValues *, vals,
    NameTable *, table,
    CHAR *, errString
) {
    int i, nItems, value, nChars;
    char *strPtr = vals->string;

    for (i = 0; i < CMOS_SIZE; ++i) {
        nItems = sscanf(strPtr," %x%n",&value,&nChars); 
        if (nItems != 1 || value > 0xff) {
	    *errString = '\0';
            return EG_BAD_VALUE;
        }
        cmos[i] = (half_word)value;
        strPtr += nChars;
    }

    return C_CONFIG_OP_OK;
}
#endif	/* !defined(NTVDM) && !defined(macintosh) */



#ifdef TEST_HARNESS
main()
{
	int             i;
	half_word       j;

	cmos_init();

	printf("\n");
	for (i = 0; i < CMOS_SIZE; i++)
	{
		cmos_outb(CMOS_PORT, i);
		cmos_inb(CMOS_DATA, &j);
		printf("%c", j);
	}
	printf("\n");
	for (i = 0; i < CMOS_SIZE; i++)
	{
		cmos_outb(CMOS_PORT, i);
		cmos_outb(CMOS_DATA, (i + 0x30));
		printf("%c", cmos[i]);
	}
	printf("\n");

	cmos_update();
}
#endif				/* TEST_HARNESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\system\at_dma.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC-AT Revision 3.0
 *
 * Title        : IBM PC-AT DMA Adaptor Functions
 *
 * Description  : This module contains functions that can be used to
 *                access the DMA Adaptor emulation
 *
 * Author       : Ross Beresford
 *
 * Notes        : The external interface to these functions is defined
 *                in the associated header file
 *
 */

/*
 * static char SccsID[]="@(#)at_dma.c   1.15 12/17/93 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "AT_STUFF.seg"
#endif

/*
 *      System include files
 */
#include <stdio.h>
#include StringH
#include TypesH

/*
 *      SoftPC include files
 */
#include "xt.h"
#include "sas.h"
#include "ios.h"
#include "gmi.h"
#include CpuH
#include "trace.h"
#include "dma.h"
#include "debug.h"
#include "sndblst.h"

#if defined(NEC_98)
#ifdef ROM_START
#undef ROM_START
#endif
#define ROM_START       0xC0000
#endif   //NEC_98
/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */

/* the DMA adaptor state */
GLOBAL DMA_ADAPT adaptor = { 0 };

/* local function to do the actual transfer of data */
LOCAL void do_transfer  IPT6(int, type, int, decrement,
        sys_addr, dma_addr, char *, hw_buffer, unsigned long, length,
        unsigned long, size);

LOCAL   void bwd_dest_copy_to_M IPT3(host_addr, s, sys_addr, d, sys_addr, l);

LOCAL   void bwd_dest_copy_from_M       IPT3(sys_addr, s, host_addr, d,
        sys_addr, l);

#ifdef LIM
        static int lim_active = 0;
#endif /* LIM */


/*
 * ============================================================================
 * External functions
 * ============================================================================
 */

#ifdef LIM
/*
** Called from do_transfer() and from init_struc.c in delta
** for the 800 port.
** lim_active is a static int
*/
GLOBAL  int get_lim_setup       IFN0()
{
        return( lim_active );
}
#endif /* LIM */

#ifdef LIM
/*
** called from emm_funcs.c
*/
GLOBAL  void dma_lim_setup      IFN0()
{
        lim_active = 1;
}
#endif /* LIM */

GLOBAL  void dma_post   IFN0()
{
        unsigned int chan, cntrl;

        /*
         *      Reset the DMA Adaptor
         */

        for (cntrl = 0; cntrl < DMA_ADAPTOR_CONTROLLERS; cntrl++)
        {
                adaptor.controller[cntrl].command.all = 0;
                adaptor.controller[cntrl].status.all = 0;
                adaptor.controller[cntrl].request = 0;
                adaptor.controller[cntrl].temporary = 0;
                adaptor.controller[cntrl].mask = ~0;

                adaptor.controller[cntrl].first_last = 0;
        }

        /*
         *      Set the DMA Adaptor channel modes
         */

        for (cntrl = 0; cntrl < DMA_ADAPTOR_CONTROLLERS; cntrl++)
        {
                for (chan = 0; chan < DMA_CONTROLLER_CHANNELS; chan++)
                {
                        adaptor.controller[cntrl].mode[chan].all = 0;
                        /* put the channels into their correct mode */
#if defined(NEC_98)
                        adaptor.controller[cntrl].mode[chan].bits.mode = DMA_SINGLE_MODE;
                        adaptor.controller[cntrl].bank_mode[chan].bits.incrementmode = DMA_64K_MODE;
#else    //NEC_98
                        if (dma_logical_channel(cntrl, chan) == DMA_CASCADE_CHANNEL)
                                adaptor.controller[cntrl].mode[chan].bits.mode = DMA_CASCADE_MODE;
                        else
                                adaptor.controller[cntrl].mode[chan].bits.mode = DMA_SINGLE_MODE;
#endif   //NEC_98
                }
        }
}

GLOBAL  void dma_inb    IFN2(io_addr, port, half_word *, value)
{
        register DMA_CNTRL *dcp;

        note_trace0_no_nl(DMA_VERBOSE, "dma_inb() ");

        /*
         * Get a pointer to the controller and mask out the port's
         * redundant bits.
         * The first check is commented out as DMA_PORT_START is zero,
         * so the check on an unsigned variable is unnecessary.
         */
#ifndef NEC_98
        if (/*port >= DMA_PORT_START &&*/ port <= DMA_PORT_END)
        {
#endif   //NEC_98
                dcp = &adaptor.controller[DMA_CONTROLLER];
                port &= ~DMA_REDUNDANT_BITS;
#ifndef NEC_98
        }
        else
        {
                dcp = &adaptor.controller[DMA1_CONTROLLER];
                port &= ~DMA1_REDUNDANT_BITS;
        }
#endif   //NEC_98

        /*
         *      When the current address and word count are read, the
         *      first/last flip-flop for the controller is used to
         *      determine which byte is accessed, and is then toggled.
         */
        switch (port)
        {
                        /* read channel current address on controller 0 */
        case    DMA_CH0_ADDRESS:
        case    DMA_CH1_ADDRESS:
        case    DMA_CH2_ADDRESS:
        case    DMA_CH3_ADDRESS:
                if (port == SbDmaChannel && dcp->first_last == 0) {
                    SbGetDMAPosition();
                }
#if defined(NEC_98)
                *value = dcp->current_address[(port-DMA_CH0_ADDRESS)/4][dcp->first_last];
                dcp->first_last ^= 1;
                break;
#else    //NEC_98
                *value = dcp->current_address[(port-DMA_CH0_ADDRESS)/2][dcp->first_last];
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* read channel current address on controller 1 */
#ifndef NEC_98
        case    DMA_CH4_ADDRESS:
        case    DMA_CH5_ADDRESS:
        case    DMA_CH6_ADDRESS:
        case    DMA_CH7_ADDRESS:
                *value = dcp->current_address[(port-DMA_CH4_ADDRESS)/4][dcp->first_last];
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* read channel current word count on controller 0 */
        case    DMA_CH0_COUNT:
        case    DMA_CH1_COUNT:
        case    DMA_CH2_COUNT:
        case    DMA_CH3_COUNT:
                if (port == (SbDmaChannel + 2) && dcp->first_last == 0) {
                    SbGetDMAPosition();
                }
#if defined(NEC_98)
                *value = dcp->current_count[(port-DMA_CH0_COUNT)/4][dcp->first_last];
                dcp->first_last ^= 1;
                break;
#else    //NEC_98
                *value = dcp->current_count[(port-DMA_CH0_COUNT)/2][dcp->first_last];
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* read channel current word count on controller 1 */
#ifndef NEC_98
        case    DMA_CH4_COUNT:
        case    DMA_CH5_COUNT:
        case    DMA_CH6_COUNT:
        case    DMA_CH7_COUNT:
                *value = dcp->current_count[(port-DMA_CH4_COUNT)/4][dcp->first_last];
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* read status register - clears terminal counts */
        case    DMA_SHARED_REG_A:
#ifndef NEC_98
        case    DMA1_SHARED_REG_A:
#endif   //NEC_98
                *value = dcp->status.all;
                dcp->status.bits.terminal_count = 0;
                break;

                        /* read temporary register */
        case    DMA_SHARED_REG_B:
#ifndef NEC_98
        case    DMA1_SHARED_REG_B:
#endif   //NEC_98
                *value = dcp->temporary;
                break;

        default:
                note_trace0_no_nl(DMA_VERBOSE, "<illegal read>");
                break;
        }

        note_trace2(DMA_VERBOSE, " port 0x%04x, returning 0x%02x", port,
                    *value);
}

GLOBAL  void dma_outb   IFN2(io_addr, port, half_word, value)
{
        register DMA_CNTRL *dcp;

        note_trace0_no_nl(DMA_VERBOSE, "dma_outb() ");

        /*
         * Get a pointer to the controller and mask out the port's
         * redundant bits.
         * The first check is commented out as DMA_PORT_START is zero,
         * so the check on an unsigned variable is unnecessary.
         */
#if defined(NEC_98)
        dcp = &adaptor.controller[DMA_CONTROLLER];
#else    //NEC_98
        if (/*port >= DMA_PORT_START &&*/  port <= DMA_PORT_END)
        {
                dcp = &adaptor.controller[DMA_CONTROLLER];
                port &= ~DMA_REDUNDANT_BITS;
        }
        else
        {
                dcp = &adaptor.controller[DMA1_CONTROLLER];
                port &= ~DMA1_REDUNDANT_BITS;
        }
#endif   //NEC_98

        /*
         *      When the current address and word count are written, the
         *      first/last flip-flop for the controller is used to
         *      determine which byte is accessed, and is then toggled.
         */
        switch (port)
        {
                        /* write channel addresseess on controller 0 */
        case    DMA_CH0_ADDRESS:
        case    DMA_CH1_ADDRESS:
        case    DMA_CH2_ADDRESS:
        case    DMA_CH3_ADDRESS:
#if defined(NEC_98)
                dcp->current_address[(port-DMA_CH0_ADDRESS)/4][dcp->first_last] = value;
                dcp->base_address[(port-DMA_CH0_ADDRESS)/4][dcp->first_last] = value;
                dcp->first_last ^= 1;
                break;
#else    //NEC_98
                dcp->current_address[(port-DMA_CH0_ADDRESS)/2][dcp->first_last] = value;
                dcp->base_address[(port-DMA_CH0_ADDRESS)/2][dcp->first_last] = value;
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* write channel addresses on controller 1 */
#ifndef NEC_98
        case    DMA_CH4_ADDRESS:
        case    DMA_CH5_ADDRESS:
        case    DMA_CH6_ADDRESS:
        case    DMA_CH7_ADDRESS:
                dcp->current_address[(port-DMA_CH4_ADDRESS)/4][dcp->first_last] = value;
                dcp->base_address[(port-DMA_CH4_ADDRESS)/4][dcp->first_last] = value;
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* write channel word counts on controller 0 */
        case    DMA_CH0_COUNT:
        case    DMA_CH1_COUNT:
        case    DMA_CH2_COUNT:
        case    DMA_CH3_COUNT:
#if defined(NEC_98)
                dcp->current_count[(port-DMA_CH0_COUNT)/4][dcp->first_last] = value;
                dcp->base_count[(port-DMA_CH0_COUNT)/4][dcp->first_last] = value;
                dcp->first_last ^= 1;
                break;
#else    //NEC_98
                dcp->current_count[(port-DMA_CH0_COUNT)/2][dcp->first_last] = value;
                dcp->base_count[(port-DMA_CH0_COUNT)/2][dcp->first_last] = value;
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* write channel word counts on controller 1 */
#ifndef NEC_98
        case    DMA_CH4_COUNT:
        case    DMA_CH5_COUNT:
        case    DMA_CH6_COUNT:
        case    DMA_CH7_COUNT:
                dcp->current_count[(port-DMA_CH4_COUNT)/4][dcp->first_last] = value;
                dcp->base_count[(port-DMA_CH4_COUNT)/4][dcp->first_last] = value;
                dcp->first_last ^= 1;
                break;
#endif   //NEC_98

                        /* write command register */
        case    DMA_SHARED_REG_A:
#ifndef NEC_98
        case    DMA1_SHARED_REG_A:
#endif   //NEC_98
                dcp->command.all = value;
                break;

                        /* write request register */
        case    DMA_WRITE_REQUEST_REG:
#ifndef NEC_98
        case    DMA1_WRITE_REQUEST_REG:
#endif   //NEC_98
                /* this feature is not supported */
                note_trace0_no_nl(DMA_VERBOSE, "<software DMA request>");
                break;

                        /* write single mask register bit */
        case    DMA_WRITE_ONE_MASK_BIT:
#ifndef NEC_98
        case    DMA1_WRITE_ONE_MASK_BIT:
#endif   //NEC_98
                if (value & 0x4)
                {
                        /* set mask bit */
                        dcp->mask |= (1 << (value & 0x3));
                }
                else
                {
                        /* clear mask bit */
                        dcp->mask &= ~(1 << (value & 0x3));
                }
                break;

                        /* write mode register */
        case    DMA_WRITE_MODE_REG:
#ifndef NEC_98
        case    DMA1_WRITE_MODE_REG:
#endif   //NEC_98
                /* note that the bottom 2 bits of value disappear into
                   the mode padding */
                dcp->mode[(value & 0x3)].all = value;
                break;

                        /* clear first/last flip-flop */
        case    DMA_CLEAR_FLIP_FLOP:
#ifndef NEC_98
        case    DMA1_CLEAR_FLIP_FLOP:
#endif   //NEC_98
                dcp->first_last = 0;
                break;

                        /* write master clear */
        case    DMA_SHARED_REG_B:
#ifndef NEC_98
        case    DMA1_SHARED_REG_B:
#endif   //NEC_98
                dcp->command.all = 0;
                dcp->status.all = 0;
                dcp->request = 0;
                dcp->temporary = 0;
                dcp->mask = ~0;

                dcp->first_last = 0;
                break;

                        /* clear mask register */
        case    DMA_CLEAR_MASK:
#ifndef NEC_98
        case    DMA1_CLEAR_MASK:
#endif   //NEC_98
                dcp->mask = 0;
                break;

                        /* write all mask register bits */
        case    DMA_WRITE_ALL_MASK_BITS:
#ifndef NEC_98
        case    DMA1_WRITE_ALL_MASK_BITS:
#endif   //NEC_98
                dcp->mask = value;

        default:
                note_trace0_no_nl(DMA_VERBOSE, "<illegal write>");
                break;
        }

        note_trace2(DMA_VERBOSE, " port 0x%04x, value 0x%02x", port, value);
}

GLOBAL  void dma_page_inb       IFN2(io_addr, port, half_word *, value)
{
        note_trace0_no_nl(DMA_VERBOSE, "dma_page_inb() ");

#ifndef NEC_98
        /* mask out the port's redundant bits */
        port &= ~DMA_PAGE_REDUNDANT_BITS;
#endif  //NEC_98

        /*
         *      Read the value from the appropriate page register.
         *      Unfortunately there does not seem to be any logical
         *      mapping between port numbers and channel numbers so
         *      we use a big switch again.
         */
        switch(port)
        {
        case    DMA_CH0_PAGE_REG:
                *value = adaptor.pages.page[DMA_RESERVED_CHANNEL_0];
                break;
#if defined(NEC_98)
        case    DMA_CH1_PAGE_REG:
                *value = adaptor.pages.page[DMA_RESERVED_CHANNEL_1];
                break;
        case    DMA_CH2_PAGE_REG:
                *value = adaptor.pages.page[DMA_RESERVED_CHANNEL_2];
                break;
        case    DMA_CH3_PAGE_REG:
                *value = adaptor.pages.page[DMA_RESERVED_CHANNEL_3];
                break;
#else    //NEC_98
        case    DMA_CH1_PAGE_REG:
                *value = adaptor.pages.page[DMA_SDLC_CHANNEL];
                break;
        case    DMA_FLA_PAGE_REG:
                *value = adaptor.pages.page[DMA_DISKETTE_CHANNEL];
                break;
        case    DMA_HDA_PAGE_REG:
                *value = adaptor.pages.page[DMA_DISK_CHANNEL];
                break;
        case    DMA_CH5_PAGE_REG:
                *value = adaptor.pages.page[DMA_RESERVED_CHANNEL_5];
                break;
        case    DMA_CH6_PAGE_REG:
                *value = adaptor.pages.page[DMA_RESERVED_CHANNEL_6];
                break;
        case    DMA_CH7_PAGE_REG:
                *value = adaptor.pages.page[DMA_RESERVED_CHANNEL_7];
                break;
        case    DMA_REFRESH_PAGE_REG:
                *value = adaptor.pages.page[DMA_REFRESH_CHANNEL];
                break;
        case    DMA_FAKE1_REG:
                *value = adaptor.pages.page[DMA_FAKE_CHANNEL_1];
                break;
        case    DMA_FAKE2_REG:
                *value = adaptor.pages.page[DMA_FAKE_CHANNEL_2];
                break;
        case    DMA_FAKE3_REG:
                *value = adaptor.pages.page[DMA_FAKE_CHANNEL_3];
                break;
        case    DMA_FAKE4_REG:
                *value = adaptor.pages.page[DMA_FAKE_CHANNEL_4];
                break;
        case    DMA_FAKE5_REG:
                *value = adaptor.pages.page[DMA_FAKE_CHANNEL_5];
                break;
        case    DMA_FAKE6_REG:
                *value = adaptor.pages.page[DMA_FAKE_CHANNEL_6];
                break;
        case    DMA_FAKE7_REG:
                *value = adaptor.pages.page[DMA_FAKE_CHANNEL_7];
                break;
#endif   //NEC_98
        default:
                note_trace0_no_nl(DMA_VERBOSE, "<illegal read>");
                break;
        }

        note_trace2(DMA_VERBOSE, " port 0x%04x, returning 0x%02x", port,
                    *value);
}

GLOBAL  void dma_page_outb      IFN2(io_addr, port, half_word, value)
{
        note_trace0_no_nl(DMA_VERBOSE, "dma_page_outb() ");

        /* mask out the port's redundant bits */
#ifndef NEC_98
        port &= ~DMA_PAGE_REDUNDANT_BITS;
#endif   //NEC_98

        /*
         *      Write the value into the appropriate page register.
         *      Unfortunately there does not seem to be any logical
         *      mapping between port numbers and channel numbers so
         *      we use a big switch again.
         */
        switch(port)
        {
        case    DMA_CH0_PAGE_REG:
                adaptor.pages.page[DMA_RESERVED_CHANNEL_0] = value;
                break;
#if defined(NEC_98)
        case    DMA_CH1_PAGE_REG:
                adaptor.pages.page[DMA_RESERVED_CHANNEL_1] = value;
                break;
        case    DMA_CH2_PAGE_REG:
                adaptor.pages.page[DMA_RESERVED_CHANNEL_2] = value;
                break;
        case    DMA_CH3_PAGE_REG:
                adaptor.pages.page[DMA_RESERVED_CHANNEL_3] = value;
                break;
        case    DMA_MODE_REG:
                if (((value >> 2) & 3) != 2)
                        adaptor.controller[DMA_CONTROLLER].bank_mode[(value & 0x3)].bits.incrementmode = (value >> 2) & 3;
                break;
#else    //NEC_98
        case    DMA_CH1_PAGE_REG:
                adaptor.pages.page[DMA_SDLC_CHANNEL] = value;
                break;
        case    DMA_FLA_PAGE_REG:
                adaptor.pages.page[DMA_DISKETTE_CHANNEL] = value;
                break;
        case    DMA_HDA_PAGE_REG:
                adaptor.pages.page[DMA_DISK_CHANNEL] = value;
                break;
        case    DMA_CH5_PAGE_REG:
                adaptor.pages.page[DMA_RESERVED_CHANNEL_5] = value;
                break;
        case    DMA_CH6_PAGE_REG:
                adaptor.pages.page[DMA_RESERVED_CHANNEL_6] = value;
                break;
        case    DMA_CH7_PAGE_REG:
                adaptor.pages.page[DMA_RESERVED_CHANNEL_7] = value;
                break;
        case    DMA_REFRESH_PAGE_REG:
                adaptor.pages.page[DMA_REFRESH_CHANNEL] = value;
                /* this feature is supported */
                note_trace0_no_nl(DMA_VERBOSE, "<refresh>");
                break;
        case    MFG_PORT:
                /* Manufacturing port */
                /* Meaningless 'checkpoint' debug removed from here STF 11/92 */
                break;
        case    DMA_FAKE1_REG:
                adaptor.pages.page[DMA_FAKE_CHANNEL_1] = value;
                break;
        case    DMA_FAKE2_REG:
                adaptor.pages.page[DMA_FAKE_CHANNEL_2] = value;
                break;
        case    DMA_FAKE3_REG:
                adaptor.pages.page[DMA_FAKE_CHANNEL_3] = value;
                break;
        case    DMA_FAKE4_REG:
                adaptor.pages.page[DMA_FAKE_CHANNEL_4] = value;
                break;
        case    DMA_FAKE5_REG:
                adaptor.pages.page[DMA_FAKE_CHANNEL_5] = value;
                break;
        case    DMA_FAKE6_REG:
                adaptor.pages.page[DMA_FAKE_CHANNEL_6] = value;
                break;
        case    DMA_FAKE7_REG:
                adaptor.pages.page[DMA_FAKE_CHANNEL_7] = value;
                break;
#endif   //NEC_98
        default:
                note_trace0_no_nl(DMA_VERBOSE, "<illegal write>");
                break;
        }

        note_trace2(DMA_VERBOSE, " port 0x%04x, value 0x%02x", port, value);
}

GLOBAL  int     dma_request     IFN3(half_word, channel, char *, hw_buffer,
        word, length)
{
        DMA_CNTRL *dcp;
        unsigned int chan;
        word offset, count;
        sys_addr munch, split_munch1, split_munch2, address;
        unsigned int size;
        int result = TRUE;

        note_trace3(DMA_VERBOSE,
                    "dma_request() channel %d, hw_buffer 0x%08x+%04x",
                    channel, hw_buffer, length);

        /* get a pointer to the controller, the physical channel
           number, and the unit size for the channel */
        dcp = &adaptor.controller[dma_physical_controller(channel)];
        chan = dma_physical_channel(channel);
        size = dma_unit_size(channel);

        /* get out if the whole DMA controller is disabled or if DMA
           requests are disabled for the channel */
        if (    (dcp->command.bits.controller_disable == 0)
             && ((dcp->mask & (1 << chan)) == 0) )
        {
                /* get the working copies of the DMA offset and count */
                offset = (   ( (unsigned int)dcp->current_address[chan][1] << 8)
                           | (dcp->current_address[chan][0] << 0) );
                count  = (   ( (unsigned int)dcp->current_count[chan][1] << 8)
                           | (dcp->current_count[chan][0] << 0) );

                /* get the DMA munch size; it is the count programmed
                   into the registers, up to the limit available in the
                   device's buffer; NB for a count of n, n+1 units will
                   actually be transferred */
                munch = (sys_addr)count + 1;
                if (munch > length)
                        munch = length;

                /* get the base address for the DMA transfer in
                   system address space */
                address = dma_system_address(channel,
                                adaptor.pages.page[channel], offset);
                if (dcp->mode[chan].bits.address_dec == 0)
                {
                        /* increment memory case - check for address wrapping */
                        if ((sys_addr)offset + munch > 0x10000L)
                        {
                                /* transfer must be split */
                                split_munch1 = 0x10000L - (sys_addr)offset;
                                split_munch2 = munch - split_munch1;

                                /* do the first transfer */
                                do_transfer
                                (
                                dcp->mode[chan].bits.transfer_type,
                                dcp->mode[chan].bits.address_dec,
                                address,
                                hw_buffer,
                                split_munch1,
                                size
                                );

                                /* get addresses for second transfer */
                                address = dma_system_address(channel,
                                        adaptor.pages.page[channel], 0);
                                hw_buffer += split_munch1*size;

                                /* do the second transfer */
                                do_transfer
                                (
                                dcp->mode[chan].bits.transfer_type,
                                dcp->mode[chan].bits.address_dec,
                                address,
                                hw_buffer,
                                split_munch2,
                                size
                                );
                        }
                        else
                        {
                                /* no wrap - do the transfer */
                                do_transfer
                                (
                                dcp->mode[chan].bits.transfer_type,
                                dcp->mode[chan].bits.address_dec,
                                address,
                                hw_buffer,
                                munch,
                                size
                                );
                        }

                        /* get the final offset */
                        offset += (word)munch;
                        count  -= (word)munch;
                }
                else
                {
                        /* decrement memory case - check for address wrapping */
                        if ((sys_addr)offset < munch)
                        {
                                /* transfer must be split */
                                split_munch1 = (sys_addr)offset;
                                split_munch2 = munch - split_munch1;

                                /* do the first transfer */
                                do_transfer
                                (
                                dcp->mode[chan].bits.transfer_type,
                                dcp->mode[chan].bits.address_dec,
                                address,
                                hw_buffer,
                                split_munch1,
                                size
                                );

                                /* get addresses for second transfer */
                                address = dma_system_address(channel,
                                        adaptor.pages.page[channel], 0xffff);
                                hw_buffer += split_munch1*size;

                                /* do the second transfer */
                                do_transfer
                                (
                                dcp->mode[chan].bits.transfer_type,
                                dcp->mode[chan].bits.address_dec,
                                address,
                                hw_buffer,
                                split_munch2,
                                size
                                );
                        }
                        else
                        {
                                /* no wrap - do the transfer */
                                do_transfer
                                (
                                dcp->mode[chan].bits.transfer_type,
                                dcp->mode[chan].bits.address_dec,
                                address,
                                hw_buffer,
                                munch,
                                size
                                );
                        }

                        /* get the final offset and count */
                        offset -= (word)munch;
                        count -= (word)munch;
                }

                /* restore the DMA offset and count from the working copies */
                dcp->current_address[chan][1] = offset >> 8;
                dcp->current_address[chan][0] = (UCHAR)offset;
                dcp->current_count[chan][1] = count >> 8;
                dcp->current_count[chan][0] = (UCHAR)count;

                if (count == 0xffff)
                {
                        /*
                         *      Terminal count has been reached
                         */

                        /* no more transfers are required */
                        result = FALSE;

                        /* update the status register */
                        dcp->status.bits.terminal_count |= (1 << chan);
                        dcp->status.bits.request &= ~(1 << chan);

                        /* if autoinitialization is enabled, then reset
                           the channel and wait for a new request */
                        if (dcp->mode[chan].bits.auto_init != 0)
                        {
                                dcp->current_count[chan][0] =
                                        dcp->base_count[chan][0];
                                dcp->current_count[chan][1] =
                                        dcp->base_count[chan][1];

                                dcp->current_address[chan][0] =
                                        dcp->base_address[chan][0];
                                dcp->current_address[chan][1] =
                                        dcp->base_address[chan][1];
                        }
                        else
                        {
                                /* set the mask bit for the channel */
                                dcp->mask |= (1 << chan);
                        }
                }
        }

        return(result);
}

GLOBAL  void dma_enquire        IFN3(half_word, channel,
        sys_addr *, address, word *, length)
{
        register DMA_CNTRL *dcp;
        register unsigned int chan;

        note_trace0_no_nl(DMA_VERBOSE, "dma_enquire() ");

        /* get a pointer to the controller and the physical channel
           number */
        dcp = &adaptor.controller[dma_physical_controller(channel)];
        chan = dma_physical_channel(channel);

        /* build the address */
        *address = dma_system_address(channel,
                        adaptor.pages.page[channel],
                        (   ( (unsigned int)dcp->current_address[chan][1] << 8)
                          | ( dcp->current_address[chan][0] << 0) ) );

        /* build the count */
        *length = (   ((unsigned int)dcp->current_count[chan][1] << 8)
                    | (dcp->current_count[chan][0] << 0) );

        note_trace3(DMA_VERBOSE, " channel %d, returning 0x%08x+%04x",
                    channel, *address, *length);
}

#ifdef NTVDM
/*
 * BOOL dmaGetAdaptor
 *
 * Used by MS for third party Vdds to retrieve current DMA settings
 *
 * entry: void
 * exit : DMA_ADAPT * , pointer to the DMA_ADAPT structure
 *
 */
DMA_ADAPT *dmaGetAdaptor(void)
{
  return &adaptor;
}
#endif  /* NTVDM */


/*
 * ============================================================================
 * Internal functions
 * ============================================================================
 */

LOCAL void do_transfer  IFN6(int, type, int, decrement,
        sys_addr, dma_addr, char *, hw_buffer, unsigned long, length,
        unsigned long, size)
{
        /*
         *      This function moves the data for a DMA transfer.
         *
         *      The value of "type" may be:
         *              DMA_WRITE_TRANSFER - data is moved from the I/O
         *              device's memory space to system address space;
         *              DMA_READ_TRANSFER - data is moved from system
         *              address space to the I/O device's memory space
         *              DMA_VERIFY_TRANSFER - no data is required to be
         *              moved at all.
         *
         *      If "decrement" is TRUE, the pointer to system address
         *      space is decremented during the DMA transfer; otherwise
         *      the pointer is incremented. The pointer to the I/O
         *      device's memory space is always incremented.
         *
         *      "dma_addr" is the offset in system address space where
         *      the DMA transfer will start; "hw_buffer" is the address
         *      of the buffer in the I/O device's memory space where
         *      the DMA transfer will start.
         *
         *      "length" is the number of units of "size" bytes each
         *      that must be transferred.
         */

        /* convert the length to bytes */
        length *= size;

        /* do the transfer */
        switch(type)
        {
        case    DMA_WRITE_TRANSFER:
                if (!decrement)
                {
#ifndef PM
#ifdef LIM
                        if( !get_lim_setup() ){
                                if( dma_addr >= ROM_START ){
                                        if( dma_addr >= ROM_START )
                                                break;
                                        length = ROM_START - dma_addr - 1;
                                }
                        }
#else
                        /* increment case - check for writing to ROM */
                        if ((dma_addr + length) >= ROM_START)
                        {
                                if (dma_addr >= ROM_START)
                                        break;
                                length = ROM_START - dma_addr - 1;
                        }
#endif /* LIM */
#endif /* nPM */
                        sas_PWS(dma_addr, (host_addr) hw_buffer, length);

                }
                else
                {
                        /*  decrement case - check for writing to ROM */
#ifndef PM
#ifdef LIM
                        if( !get_lim_setup() ){
                                if (dma_addr >= ROM_START) {
                                        if (dma_addr-length >= ROM_START)
                                                break;
                                        length = dma_addr-ROM_START+length-1;
                                        dma_addr = ROM_START - 1;
                                }
                        }
#else
                        if (dma_addr >= ROM_START)
                        {
                                if (dma_addr-length >= ROM_START)
                                        break;
                                length = dma_addr - ROM_START + length - 1;
                                dma_addr = ROM_START - 1;
                        }
#endif /* LIM */
#endif /* nPM */
                        bwd_dest_copy_to_M((half_word *)hw_buffer, dma_addr, length);

                }
                break;

        case    DMA_READ_TRANSFER:
                if (!decrement)
                        /* increment case */
                        sas_PRS(dma_addr, (host_addr) hw_buffer, length);
                else
                        /* decrement case */
                        bwd_dest_copy_from_M(dma_addr, (half_word *)hw_buffer, length);
                break;

        case    DMA_VERIFY_TRANSFER:
                break;

        default:
                note_trace0(DMA_VERBOSE, "dma_request() illegal transfer");
                break;
        }
}

/*
 * backward copy routines - these used to be
 * in the host but there seemed to be little point
 */

LOCAL   void    bwd_dest_copy_to_M      IFN3(host_addr, s, sys_addr, d,
        sys_addr, l)
{
        while (l-- > 0)
                sas_PW8(d--, *s++);
}

LOCAL   void    bwd_dest_copy_from_M    IFN3(sys_addr, s, host_addr, d,
        sys_addr, l)
{
        while (l-- > 0)
                *d-- = sas_PR8(s++);
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

GLOBAL  void dma_init   IFN0()
{
        io_addr port;

        note_trace0(DMA_VERBOSE, "dma_init() called");

#ifdef LIM
        lim_active = 0;
#endif

        /*
         * Connect the DMA Adaptor chips to the I/O bus
         */

        /* establish the DMA Controller I/O functions that will be used */
        io_define_inb(DMA_ADAPTOR, dma_inb);
        io_define_outb(DMA_ADAPTOR, dma_outb);

        /* connect the DMA Controller chips to the I/O bus */
#if defined(NEC_98)
        for (port = DMA_PORT_START; port <= DMA_PORT_END; port += 2)
                io_connect_port(port, DMA_ADAPTOR, IO_READ_WRITE);
#else    //NEC_98
        for (port = DMA_PORT_START; port <= DMA_PORT_END; port++)
                io_connect_port(port, DMA_ADAPTOR, IO_READ_WRITE);
        for (port = DMA1_PORT_START; port <= DMA1_PORT_END; port++)
                io_connect_port(port, DMA_ADAPTOR, IO_READ_WRITE);
#endif   //NEC_98

        /* establish the DMA Page Register I/O functions that will be used */
        io_define_inb(DMA_PAGE_ADAPTOR, dma_page_inb);
        io_define_outb(DMA_PAGE_ADAPTOR, dma_page_outb);

        /* connect the DMA Page Register chip to the I/O bus */
#if defined(NEC_98)
        for (port = DMA_PAGE_PORT_START; port <= DMA_PAGE_PORT_END; port += 2)
                io_connect_port(port, DMA_PAGE_ADAPTOR, IO_READ_WRITE);
#else     //NEC_98
        for (port = DMA_PAGE_PORT_START; port <= DMA_PAGE_PORT_END; port++)
                io_connect_port(port, DMA_PAGE_ADAPTOR, IO_READ_WRITE);
#endif   //NEC_98
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\system\dummy_nt.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * VPC Version 1.0
 *
 * Title         : dummy_int.c
 *
 * Decription    : Provide a function which emulates the dummy interrupt
 *                 within the IBM PC BIOS.
 *
 * Author        :
 *
 * Notes         :
 */

#ifdef SCCSID
static char SccsID[]="@(#)dummy_int.c	1.4 08/10/92 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_BIOS.seg"
#endif

void dummy_int()
{
    ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\system\ica.c ===
#include "insignia.h"
#include "host_def.h"

/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC Revision 2.0
 *
 * Title	: ica.c
 *
 * Description	: Interrupt Controller Adapter
 *
 * Author	: Jim Hatfield
 *                (Upgraded to Rev. 2 by David Rees)
 *
 * Notes	: The ICA is responsible for maintaining a mapping
 *		  between an Interrupt Request line and a vector
 *		  number defining an entry in the Interrupt Vector
 *		  table. On reciept of a hardware interrupt, it
 *		  passes the appropriate vector number to the cpu.
 *
 *		  The following functions are provided:
 *
 *		  ica0_init()	- Initialise the first ICA (0 = Master)
 *		  ica1_init()	- Initialise the first ICA (1 = Slave)
 *		  ica_inb()	- Read a byte from an ICA register
 *		  ica_outb()	- Write a command (byte) to the ICA
 *
 *		  ica_hw_interrupt()	- Raise a hardware interrupt line
 *		  ica_clear_int()	- Drop an interrupt line
 *		  ica_intack()		- Acknowledge an interrupt
 *
 *                If DEBUG is defined, the following function
 *                is provided:
 *
 *                ica_dump()    - printd out contents of one element
 *                                of adapter_state[]
 *
 * Restrictions	: This software emulates an Intel 8259A Priority Interrupt
 *		  controller as defined in the Intel Specification pp 2-95 to
 *		  2-112 and pp 2-114 to 2-181, except for the following:
 *
 *		  1) Cascade mode is not supported at all. This mode requires
 *		     that there is more than one 8259A in a system, whereas
 *		     the PC/XT has only one.
 *
 *		  2) 8080/8085 mode is not supported at all. In this mode the
 *		     8259A requires three INTA pulses from the CPU, and an 8088
 *		     only gives two. This would cause the device to lock up and
 *		     cease to function.
 *
 *		  3) Level triggered mode is not supported. The device is
 *		     assumed to operate in edge triggered mode. A call of
 *		     ica_hw_interrupt by another adapter will cause a bit to
 *		     be latched into the Interrupt Request Register. A subsequent
 *		     call of ica_clear_int will cause the bit to be unlatched.
 *
 *		  4) Buffered mode has no meaning in a software emulation and
 *		     so is ignored.
 *
 *		  5) An enhancement is provided such that an adapter may raise
 *		     more than one interrupt in one call of ica_hw_interrupt.
 *		     The effect of this is that as soon as an INTACK is called
 *		     another interrupt is requested. If the chip is in Automatic
 *		     EOI mode then all of the interrupts will be generated in
 *		     one burst.
 *		
 *                5a) A further enhancement is provided such that a delay
 *                   (a number of Intel instructions) can be requested before
 *		     the interrupt takes effect. This delay applies to every
 *		     interrupt if more than one is requested.
 *
 *		  6) Special Fully Nested mode is not supported, since it is
 *		     a submode of Cascade Mode.
 *
 *		  7) Polling is not completely implemented. When a Poll is
 *		     received and there was an interrupt request, the CPU INT
 *		     line (which must have been high) is pulled low. This
 *		     software does NOT reset the jump table address since there
 *		     may be a software interrupt outstanding. However it does
 *		     remove the evidence of a hardware interrupt, which will
 *		     cause the CPU to reset the table address itself.
 *
 *		  When an unsupported mode is set, it is remembered for
 *		  diagnostic purposes, even though it is not acted upon.
 *
 * Modifications for Revision 2.0 :
 *                1) Restrictions 1 and 6 are lifted. The PC-AT contains two
 *                   8259A interrupt controllers. The first (ICA 0) is in Master
 *                   mode, and the second (ICA 1) is in slave mode, and its
 *                   interrupts are directed to IR2 on the master chip. Hence
 *                   cascade mode must be supported to the extent necessary
 *                   to emulate this situation. Also, Special Fully Nested
 *                   Mode must work too. NB. The AT BIOS does NOT initialise
 *                   the Master 8259A to use Special Fully Nested Mode.
 *
 *                2) Restriction 5a (which is an enhancement) has been
 *                   eliminated. Apparently this never really achieved
 *                   its aim.
 *
 *                3) All the static variables declared in this module
 *                   have been placed within a structure, ADAPTER_STATE,
 *                   which is used as the type for a two-element array.
 *                   This allows the code to emulate two 8259As.
 *
 *                4) The routine ica_standard_vector_address() has been
 *                   eliminated, because it is not used anymore.
 *
 *                5) The function ica_init() has been split into two:
 *                   ica0_init() and ica1_init(). The initialization
 *                   via ICWs will now be done by a BIOS POST routine.
 *
 *                6) In the PC-AT, an 8259A determines its Master/Slave
 *                   state by examining the state of the SP/EN pin. We
 *                   simulate this by setting a flag 'ica_master' to
 *                   the appropriate value in the ica_init() routines.
 *
 *                7) The guts of the exported function ica_intack()
 *                   have been placed in an internal routine,
 *                   ica_accept(). This change allows for the INTAs
 *                   to work for both the master and slave 8259As.
 *
 *                8) Added debug function (ica_dump) to allow module
 *                   testing.
 *
 */

#ifdef SCCSID
LOCAL char SccsID[]="@(#)ica.c	1.38 10/19/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_ICA.seg"
#endif

/* these ports have iret hooks enabled automatically - others will have to
 * define hooked_irets as parts of their configuration
 */
#if !defined(NTVDM)
#if defined(CPU_40_STYLE) || defined(GISP_CPU)
#define HOOKED_IRETS    /* switch on IRET hooks */
#endif
#endif

/*
 * SoftPC include files
 */
#include "xt.h"
#include "trace.h"
#include "ios.h"
#include CpuH
#include "ica.h"
#include "host.h"
#include "yoda.h"
#include "debug.h"

#ifdef NOVELL
extern void host_sigio_event IPT0();
#endif /* NOVELL */

/*
 * ============================================================================
 * Local Data
 * ============================================================================
 */

#if !defined(NTVDM)
/*
 *  Table of function pointers to access PIC routines
 */
void (*ica_inb_func) IPT2(io_addr, port, IU8 *, value);
void (*ica_outb_func) IPT2(io_addr, port, IU8, value);
void (*ica_hw_interrupt_func) IPT3(IU32, adapter, IU32, line_no,
	IS32, call_count);
void (*ica_clear_int_func) IPT2(IU32, adapter, IU32, line_no);
#endif

#if defined (CPU_40_STYLE) || defined (NTVDM)
#define ICA_INTACK_REJECT       -1
#endif

#ifndef PROD
char icamsgbuf[132];	/* Text buffer for debug messages */
#endif

/*
 * ============================================================================
 * Data relating to 8259A is replicated in two element array.
 * ============================================================================
 */

#ifdef NTVDM

#include <nt_eoi.h>

/*
 *  Risc 486 ntvdm does not use iret hooks
 *  x86 ntvdm (monitor) uses iret hooks only on comms
 *  and does not require protect mode enable\disable
 *  control over selectors, as app code cannot switch to
 *  protect mode without going thru dpmi.
 *
 *
 *  NTVDM has to export ICA definition for host and for X86 kernel.
 *  To make the namings of these externally referenced type/var more
 *  sensible but leaving the code substantially as the SoftPC base,
 *  use macros to 'edit' the adapter_state variable and type.
 *
 */
VDMVIRTUALICA VirtualIca[2];
#define adapter_state VirtualIca
#define ADAPTER_STATE VDMVIRTUALICA
#define EOI_HOOKS       /* switch on EOI hooks */





/*
 * for ntvdm and x86 build, this variable is shared between ntvdm and
 * the kernel(the kernel dispatches h/w interrupt and handles iret
 * hook inside kernel)
 */

#ifdef MONITOR
extern  ULONG iretHookMask;
extern  ULONG iretHookActive;
#endif


/*
 * noop the ica_lock_set fns, since ntvdm uses a real critical section
 */

#define ica_lock_set(x)
#define ica_lock_inc()
#define ica_lock_dec()


/*
 *  noop the swpic fnptrs
 */

#define SWPIC_inb          ica_inb
#define SWPIC_outb         ica_outb
#define SWPIC_hw_interrupt ica_hw_interrupt
#define SWPIC_clear_int    ica_clear_int


//
// to be removed:
//
// ica_hw_interrupt_func is referenced by emulator libs, so depsite the
// fact that we have removed the swpic function ptrs, we still
// have to provide a fn ptr for the emulator.
//
void
(*ica_hw_interrupt_func)(
    IU32 adapter,
    IU32 line_no,
    IS32 call_count
    )
    = ica_hw_interrupt;



#else   /* !NTVDM */

/* regular SoftPC definitions for ica */
ADAPTER_STATE adapter_state[2];

/* iret hook related defines */
#ifdef PROD
#define host_valid_iret_hook()	(TRUE)
#else		/* allow disabling of iret hooks whilst debugging */
#define host_valid_iret_hook()	(iretHooksEnabled)
#endif
#define host_bop_style_iret_hooks()	(FALSE)
#define host_iret_bop_table_addr(line)	(0)

/* crit section style locks only available on NT */
#define host_ica_lock()
#define host_ica_unlock()
#define host_ica_real_locks() (FALSE)

/* macro'ise simplistic ica lock scheme */

LOCAL IUM8      ica_lock;

#define ica_lock_set(x) ica_lock = x
#define	ica_lock_inc()	ica_lock++
#define ica_lock_dec()  ica_lock--

#endif  /* NTVDM */

#ifdef HOOKED_IRETS		/* iret hook related variables */
LOCAL IBOOL  iretHooksEnabled = FALSE;
LOCAL IU16 iretHookMask = 0;    /* No interrupts hooked by default */
LOCAL IU16 iretHookActive = 0;
#endif /* HOOKED_IRETS */


/*
 * ============================================================================
 * Local defines
 * ============================================================================
 */

#define ICA_BASE_MASK	0xf8	/* Mask to get relevant bits out	*/

/*
 * The following defines describe the usage of the mode bits
 */

#define ICA_IC4		0x0001	/* 0 -> no ICW4, 1 -> ICW4 will be sent	*/
#define ICA_SINGL	0x0002	/* 0 -> cascade, 1 -> single mode	*/
#define ICA_ADI		0x0004	/* 0 -> 8 byte,  1 -> 4 byte interval	*/
#define ICA_LTIM	0x0008	/* 0 -> edge,    1 -> level trigger	*/
#define ICA_ICW1_MASK	0x000f	/* Mask to select above bits in mode	*/

#define ICA_MPM		0x0010	/* 0 -> 8080,	 1 -> 8086/8088 mode	*/
#define ICA_AEOI	0x0020	/* 1 -> Automatic End-Of-Int Mode is on	*/
#define ICA_MS		0x0040	/* 0 -> slave,	 1 -> master mode	*/
#define ICA_BUF		0x0080	/* 1 -> Buffered Mode is on		*/
#define ICA_SFNM	0x0100	/* 1 -> Special Fully Nested Mode is on	*/
#define ICA_ICW4_MASK	0x01f0	/* Mask to select above bits in mode	*/

#define ICA_SMM		0x0200	/* 1 -> Special Mask Mode is on		*/
#define ICA_RAEOI	0x0400	/* 1 -> Rotate on Auto EOI Mode is on	*/
#define ICA_RIS		0x0800	/* 0 -> deliver IRR, 1 -> deliver ISR	*/
#define ICA_POLL	0x1000	/* 1 -> Polling is now in progress	*/

/*
 * ============================================================================
 * Macros
 * ============================================================================
 */
#define ICA_PORT_0							\
	(adapter ? ICA1_PORT_0 : ICA0_PORT_0)

#define ICA_PORT_1							\
	(adapter ? ICA1_PORT_1 : ICA0_PORT_1)

#define adapter_for_port(port)						\
	((port >= ICA0_PORT_START && port <= ICA0_PORT_END)		\
		? ICA_MASTER						\
		: ICA_SLAVE						\
	)

/*
 * ============================================================================
 * Internal functions
 * ============================================================================
 */

IS32 ica_accept IPT1(IU32, adapter);

#ifdef HOOKED_IRETS
extern IU32 ica_iret_hook_needed IPT1(IU32, line);
#endif

#if !defined (NTVDM)
void
SWPIC_init_funcptrs IFN0()
{
	/*
	 *  initialize PIC access functions for SW [emulated] PIC
	 */
	ica_inb_func			= SWPIC_inb;
	ica_outb_func			= SWPIC_outb;
	ica_hw_interrupt_func		= SWPIC_hw_interrupt;
	ica_clear_int_func		= SWPIC_clear_int;
}
#endif

/*
 *	Please note that ica_eoi is called by SUN_VA code and thus needs to
 *	be global.
 */

GLOBAL void
ica_eoi IFN3(IU32, adapter, IS32 *, line, IBOOL, rotate)
{
    /*
     * End Of Interrupt. If *line is -1, this is a non-specific EOI
     * otherwise it is the number of the line to clear. If rotate is
     * TRUE, then set the selected line to lowest priority.
     */

    ADAPTER_STATE *asp = &adapter_state[adapter];
    IS32 i, j;
    IU8 bit;
    IS32 EoiLineNo = -1;	/* if EOI_HOOKS defined this is used otherwise */
				/* rely on compiler elimination as not read */

    if (*line == -1)		/* non specific EOI */
    {
	/*
	 * Clear the highest priority bit in the ISR
	 */
	for(i = 0; i < 8; i++)
	{
	    j = (asp->ica_hipri + i) & 7;
	    bit = (1 << j);
	    if (asp->ica_isr & bit)
	    {
		asp->ica_isr &= ~bit;
		*line = j;
		EoiLineNo = (IS32)*line;
		break;
	    }
	}
    }
    else			/* EOI on specific line */
    {
	bit = 1 << *line;
	if (asp->ica_isr & bit)
		EoiLineNo = *line;
	asp->ica_isr &= ~bit;
    }

#ifndef PROD
    if (io_verbose & ICA_VERBOSE)
    {
	sprintf(icamsgbuf, "**** CPU END-OF-INT %c (%d) ****", (adapter == ICA_MASTER? 'M': 'S'), *line);
	trace(icamsgbuf, DUMP_NONE);
    }
#endif

    if (rotate && (*line >= 0))
	asp->ica_hipri = (USHORT)((*line + 1) & 0x07);

#ifdef EOI_HOOKS
    /*
     * CallOut to device registered EOI Hooks
     */
    if (EoiLineNo != -1)
	host_EOI_hook(EoiLineNo + (adapter << 3), asp->ica_count[EoiLineNo]);
#endif /* EOI_HOOKS */

    /*
     * There may be a lower priority interrupt pending, so check
     */
    if ((i = ica_scan_irr(adapter)) & 0x80)
	   ica_interrupt_cpu(adapter, i & 0x07);

}

GLOBAL IU8
ica_scan_irr IFN1(IU32, adapter)
{
    /*
     * This is the routine which will decide whether an interrupt should
     * be generated. It scans the IRR, the IMR and the ISR to determine
     * whether one is possible. It is also called when the processor has
     * accepted the interrupt to see which one to deliver.
     *
     * A bit set in the IRR will generate an interrupt if:
     *
     * 1) The corresponding bit in the IMR is clear
     *    AND
     * 2) The corresponding bit and all higher priority bits in the ISR are
     *     clear (unless Special Mask Mode, in which case ISR is ignored)
     *
     * The highest priority set bit which meets the above conditions (if any)
     * will be returned with an indicator bit (in the style needed by a Poll)
     */

    ADAPTER_STATE *asp = &adapter_state[adapter];
    IU32 i, j;
    IUM8 bit, irr_and_not_imr, active_isr;
    IUM8 iret_hook_mask;

#if defined (NTVDM)

#ifdef MONITOR
    iret_hook_mask = (IU8)((iretHookActive | DelayIrqLine) >> (adapter << 3));
#else
    iret_hook_mask = (IU8)(DelayIrqLine >> (adapter << 3));
#endif

#else  /* !NTVDM */
    /* if iret hooks are not being used, iretHookActive will always be 0 */
    iret_hook_mask = (IU8)(iretHookActive >> (adapter << 3));
#endif

    /*
     * A bit can only cause an int if it is set in the IRR
     * and clear in the IMR. Generate a set of such bits
     */

    irr_and_not_imr = asp->ica_irr & ~(asp->ica_imr | iret_hook_mask);

    /*
     * Does the current mode require the ica to prevent
     * interrupts if that line is still active (i.e. in the isr)?
     */
    if (asp->ica_mode & (ICA_SMM|ICA_SFNM))
    {
	/* Neither Special Mask Mode nor Special Fully Nested Mode
	 * block interrupts using bits in the isr.
	 *
	 * SMM is the mode used by Windows95 and Win3.1/E
	 *
	 * Note that "Undocumented PC" says SFNM is not used by PCs and
	 * is only intended for larger systems with > 2 ICAs
	 */
	active_isr = 0;
    }
    else
    {
	/* Normal Case: Used by DOS and Win3.1/S
	 * In this mode the isr prevents interrupts.
	 */
	active_isr = asp->ica_isr;
    }

    /*
     * Check the trivial case first: no bits set
     */

    if (irr_and_not_imr == 0)
	return(7);

    for(i = 0; i < 8; i++)
    {
	j = (asp->ica_hipri + i) & 7;
	bit = (1 << j);
	if (active_isr & bit)
	    return(7);		/* No nested interrupt possible */

	if (irr_and_not_imr & bit)
            return((IU8)(0x80 + j));   /* Return line no. + indicator */
    }
    /* Strange. We should not have got here.  */
    return(7);
}


IS32 ica_accept IFN1(IU32, adapter)
{
    /*
     * NOTE: There is no need to set the lock here, since we are called
     *       either from the cpu interrupt code, or from ica_inb, both of
     *       which will have set it for us.
     */

    ADAPTER_STATE *asp = &adapter_state[adapter];
    IU32	line1;
    IS32	line2;
    IU8		bit;

    /*
     * Drop the INT line
     */

    asp->ica_cpu_int = FALSE;

    /*
     * Scan the IRR to find the line which we will use.
     * There should be one set, but check anyway
     * It there isn't, use line 7.
     */

    if (!((line1 = (IU32)ica_scan_irr(adapter)) & 0x80))
    {
	note_trace1(ICA_VERBOSE, "ica_int_accept(%c): No interrupt found!!", (adapter == ICA_MASTER? 'M': 'S'));

	/* we should really return a spurious interrupt - ie interrupt
	 * on line 7, but this is not neccessary and can cause problems
	 * for some programs (eg DOOM with a mouse)
	 */
#if 0
        line1 = 7;
#endif

	/* Skip spurious ints. These are any that are caused by clearing an
	 * int when the cpu has already registered that there is an int to
	 * service.
	 *
	 * This used to be "#if defined(NTVDM) && defined(MONITOR)"
	 * and tried to remove the performance impact on the monitor.
	 */
	return(-1);

    }
    else
    {
        line1 &= 0x07;

#if defined(CPU_40_STYLE) && !defined (NTVDM)
	/* allow some recursion within hooked ISRs */
	if (asp->isr_depth[line1] >= MAX_ISR_DEPTH)
	{
		/* disable further interrupts on this line */
		iretHookActive |= 1 << ((adapter << 3) + line1);

		/* reached maximum ISR recursion - don't do interrupt */
		return((IS32)-1);
	}
#endif /* CPU_40_STYLE */

        bit = (1 << line1);
        asp->ica_isr |= bit;

        if (--(asp->ica_count[line1]) <= 0)
        {				/* If count exhausted for this line */
            asp->ica_irr &= ~bit;	/* Then finally clear IRR bit	*/
            asp->ica_count[line1] = 0;  	/* Just in case		*/
        }
    }

    /*
     * If we are in Automatic EOI mode, then issue a non-specific EOI
     */

    if (asp->ica_mode & ICA_AEOI)
    {
        line2 = -1;
        ica_eoi(adapter, &line2, (asp->ica_mode & ICA_RAEOI) == ICA_RAEOI);
    }

#ifndef PROD
    if (io_verbose & ICA_VERBOSE)
    {
        sprintf(icamsgbuf, "**** CPU INTACK %c (%d) ****", (adapter == ICA_MASTER? 'M': 'S'), line1 + asp->ica_base);
        trace(icamsgbuf, DUMP_NONE);
    }
#endif

    return((IS32)line1);
}

GLOBAL void
ica_interrupt_cpu IFN2(IU32, adapter, IU32, line)
{
    /*
     * This routine actually interrupts the CPU. The method it does this
     * is host specific, and is done in host_cpu_interrupt().
     */

    ADAPTER_STATE *asp = &adapter_state[adapter];

    /*
     * If the INT line is already high, do nothing.
     */

    if (asp->ica_cpu_int)
    {
#ifndef PROD
	if ((io_verbose & ICA_VERBOSE) && ((IU32)(asp->ica_int_line) != line))
	{
	    sprintf(icamsgbuf,"******* INT LINE ALREADY HIGH %c line=%d ****", (adapter == ICA_MASTER? 'M': 'S'), asp->ica_int_line);
	    trace(icamsgbuf, DUMP_NONE);	
	}
#endif
        asp->ica_int_line = line;

	return;
    }

    /*
     * Set the ICA internal flags
     */

    asp->ica_int_line = line;
    asp->ica_cpu_int = TRUE;

    if (asp->ica_master)		/* If ICA is Master */
    {
#ifndef PROD
        if (io_verbose & ICA_VERBOSE)
        {
            sprintf(icamsgbuf, "**** CPU INTERRUPT (%x) ****", line);
            trace(icamsgbuf, DUMP_NONE);
        }
#endif

        /*
         *  Set the 'hardware interrupt' bit in cpu_interrupt_map
         */

#ifndef CPU_40_STYLE	/* No globals in the 4.0 I/F! */
	cpu_int_delay = 0;
#endif

        host_set_hw_int();

#ifdef A2CPU
        host_cpu_interrupt();
#endif

#ifdef NTVDM
        /* call wow routine to check for application unable to service ints */
        WOWIdle(FALSE);
#endif

    }
    else
    {				/* If ICA is Slave */
#ifndef PROD
        if (io_verbose & ICA_VERBOSE)
        {
            sprintf(icamsgbuf, "**** SLAVE ICA INTERRUPT (%x) ****", line);
            trace(icamsgbuf, DUMP_NONE);
        }
#endif
        /*
         * Signal the Master ICA.
         * NB. A kludge is used here. We know that we have
         *     been called from ica_hw_interrupt(), and
         *     therefore ica_lock will be at least 1. To
         *     get the effect we want, it is necessary to
         *     reduce the value of ica_lock for the duration
         *     of the call to ica_hw_interrupt.
	 *
	 * If the host has implemented critical section style locking
	 * then the above kludge does not apply.
         */

        ica_lock_dec();

        ica_hw_interrupt(ICA_MASTER, asp->ica_ssr, 1);

        ica_lock_inc();
    }
}

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */
void SWPIC_inb IFN2(io_addr, port, IU8 *, value)
{
#ifndef PROD
    char *reg_name;
#endif /* nPROD */
    IU32 adapter       = adapter_for_port(port);
    ADAPTER_STATE *asp = &adapter_state[adapter];

    /*
     * First check the validity of the port
     */

#ifndef PROD
    if (io_verbose & ICA_VERBOSE)
        if ((port != ICA_PORT_0) && (port != ICA_PORT_1))
	{
	    sprintf(icamsgbuf, "ica_inb: bad port (%x)", port);
	    trace(icamsgbuf, DUMP_NONE);
	}
#endif

    /*
     * If we are in the middle of a Poll command, then respond to it
     */

    if (asp->ica_mode & ICA_POLL)
    {
	ica_lock_set(1);			/* Lock out signal handlers */
	host_ica_lock();			/* real lock if supported */

	asp->ica_mode &= ~ICA_POLL;

	if ((*value = ica_scan_irr(adapter)) & 0x80) /* See if there is one */
	{
	    (void) ica_accept(adapter);		/* Acknowledge it	*/
            host_clear_hw_int();
	    /*	cpu_int_call_count[0] = 0;         Not used anymore	*/
	}

	ica_lock_set(0);
	host_ica_unlock();			/* free lock if supported */

#ifndef PROD
        if (io_verbose & ICA_VERBOSE)
	{
	    sprintf(icamsgbuf, "ica_inb: responding to Poll with %x", *value);
	    trace(icamsgbuf, DUMP_NONE);
	}
#endif
    }

    /*
     * If the address is ICA_PORT_0, then deliver either the IRR or the ISR,
     * depending on the setting of mode bit ICA_RIS. If the address is
     * ICA_PORT_1, then deliver the IMR
     */

    else
    {
	if (port == ICA_PORT_0)
	    if (asp->ica_mode & ICA_RIS)
	    {
		*value = asp->ica_isr;
#ifndef PROD
		reg_name = "ISR";
#endif /* nPROD */		
	    }
	    else
	    {
		*value = asp->ica_irr;
#ifndef PROD
		reg_name = "IRR";
#endif /* nPROD */		
	    }
	else
	{
	    *value = asp->ica_imr;
#ifndef PROD
	    reg_name = "IMR";
#endif /* nPROD */	
	}

#ifndef PROD
	if (io_verbose & ICA_VERBOSE)
	{
	    sprintf(icamsgbuf, "ica_inb: delivered %s value %x", reg_name, *value);
	    trace(icamsgbuf, DUMP_NONE);
	}
#endif
    }
}

void SWPIC_outb IFN2(io_addr, port, IU8, value)
{

    /*
     * Data sent may either be ICWs or OCWs. All of the OCWs are recognisable
     * individually, but only ICW1 may be recognised directly. It will always
     * be followed by ICW2, and optionally by ICW3 and/or ICW4, depending upon
     * exactly what sort of ICW1 was sent. We use a sequence variable to track
     * this and make sure we interpret the data correctly. After power-on, we
     * ignore everything until we get an ICW1.
     */

    /*
     * Some defines to detect command types
     */
#define ICA_SMM_CMD	0x40
#define ICA_POLL_CMD	0x04
#define ICA_RR_CMD	0x02

    /*
     * Local variables
     */
    IU32 adapter               = adapter_for_port(port);
    ADAPTER_STATE *asp = &adapter_state[adapter];

    SAVED IS32 sequence[2]	/* -1 -> power is on but no ICWs received */
	 	  = { -1, -1 };	/*  0 -> fully initialised, OK to proceed */
				/*  2 -> ICW1 received, awaiting ICW2	  */
				/*  3 -> ICW2 received, awaiting ICW3     */
				/*  4 -> awaiting ICW4			  */

    IU32 i;		/* Counter				  */
    IS32 line;			/* Interrupt line number 		  */

    /*
     * First check the validity of the port
     */

#if defined(NEC_98)
    if ((port & 0xfffc) != ICA_PORT_0)
#else    //NEC_98
    if ((port & 0xfffe) != ICA_PORT_0)
#endif   //NEC_98
    {
#ifndef PROD
	if (io_verbose & ICA_VERBOSE)
	{
	    sprintf(icamsgbuf, "ica_outb: bad port (%x)", port);
	    trace(icamsgbuf, DUMP_NONE);
	}
#endif
	return;
    }

    /*
     * If we get an ICW1 then we are into initialisation
     */

#if defined(NEC_98)
    if (((port & 2) == 0) && (value & 0x10))
#else    //NEC_98
    if (((port & 1) == 0) && (value & 0x10))            /****  ICW1  ****/
#endif   //NEC_98
    {
        asp->ica_irr  = 0;	/* Clear all pending interrupts		*/
        asp->ica_isr  = 0;	/* Clear all in-progress interrupts	*/
        asp->ica_imr  = 0;	/* Clear the mask register		*/
	asp->ica_ssr  = 0;	/* No slaves selected			*/
        asp->ica_base = 0;	/* No base address			*/

	asp->ica_hipri = 0;	/* Line 0 is highest priority		*/

        asp->ica_mode = value & ICA_ICW1_MASK;
				/* Set supplied mode bits from ICW1	*/

	for(i = 0; i < 8; i++)
	    asp->ica_count[i] = 0;	/* Clear IRR extension		*/

	asp->ica_cpu_int = FALSE;	/* No CPU INT outstanding	*/
	sequence[adapter] = 2;		/* Prepare for the rest of the sequence	*/

#ifndef PROD
        if (io_verbose & ICA_VERBOSE)
	    trace("ica_outb: ICW1 detected, initialisation begins", DUMP_NONE);
#endif
        return;
    }

/**/

    /*
     * Lock out calls from signal handlers
     */

    ica_lock_set(1);
    host_ica_lock();			/* real lock if supported */

    /*
     * It wasn't an ICW1, so use the sequence variable to direct our activities
     */

    switch(sequence[adapter])
    {
    case  0:			/* We are expecting an OCW	*/
#if defined(NEC_98)
        if (port & 2)           /* Odd address -> OCW1          */
#else    //NEC_98
        if (port & 1)           /* Odd address -> OCW1          */
#endif   //NEC_98
	{
	    asp->ica_imr = value & 0xff;
#ifndef PROD
            if (io_verbose & ICA_VERBOSE)
	    {
	        sprintf(icamsgbuf, "ica_outb: new %c IMR: %x", (adapter == ICA_MASTER? 'M': 'S'), value);
	        trace(icamsgbuf, DUMP_NONE);
	    }
#endif
	    if (asp->ica_cpu_int)
	    {
		/* We might have masked out a pending interrupt */
		if (asp->ica_imr & (1 << asp->ica_int_line))
		{
			asp->ica_cpu_int = FALSE;	/* No CPU INT outstanding	*/
			if (asp->ica_master)
				host_clear_hw_int();
			else
				ica_clear_int(ICA_MASTER,asp->ica_ssr);
		}
	    }
	    /*
	     * We might have unmasked a pending interrupt
	     */
	    if (!asp->ica_cpu_int && (line = ica_scan_irr(adapter)) & 0x80)
		ica_interrupt_cpu(adapter, line & 0x07); /* Generate interrupt */
	}
	else
/**/
	if ((value & 8) == 0)	/* Bit 3 unset -> OCW2		*/
	{
	    switch ((value >> 5) & 0x07)
	    {
	    case 0:		/* Clear rotate in auto EOI	*/
		asp->ica_mode &= ~ICA_RAEOI;
#ifndef PROD
		if (io_verbose & ICA_VERBOSE)
		    trace("ica_outb: Clear Rotate in Auto EOI",DUMP_NONE);
#endif
		break;

	    case 1:		/* Non-specific EOI		*/
		line = -1;	/* -1 -> highest priority	*/
#ifndef PROD
		if (io_verbose & ICA_VERBOSE)
		    trace("ica_outb: Non-specific EOI", DUMP_NONE);
#endif
		ica_eoi(adapter, &line, FALSE);
		break;

	    case 2:		/* No operation			*/
		break;

	    case 3:		/* Specific EOI command		*/
		line  = value & 0x07;
#ifndef PROD
		if (io_verbose & ICA_VERBOSE)
		{
		    sprintf(icamsgbuf, "ica_outb: Specific EOI, line %d", line);
		    trace(icamsgbuf, DUMP_NONE);
		}
#endif
		ica_eoi(adapter, &line, FALSE);
		break;

	    case 4:		/* Set rotate in auto EOI mode	*/
		asp->ica_mode |= ICA_RAEOI;
#ifndef PROD
		if (io_verbose & ICA_VERBOSE)
		    trace("ica_outb: Set Rotate in Auto EOI",DUMP_NONE);
#endif
		break;

	    case 5:		/* Rotate on non-specific EOI	*/
		line = -1;	/* -1 -> non specific		*/
#ifndef PROD
		if (io_verbose & ICA_VERBOSE)
		    trace("ica_outb: Rotate on Non-specific EOI",DUMP_NONE);
#endif
		ica_eoi(adapter, &line, TRUE);
		break;

	    case 6:		/* Set priority			*/
		asp->ica_hipri = (value + 1) & 0x07;
#ifndef PROD
		if (io_verbose & ICA_VERBOSE)
		{
		    sprintf(icamsgbuf, "ica_outb: Set Priority, line %d", value & 0x07);
		    trace(icamsgbuf, DUMP_NONE);
		}
#endif
		break;

	    case 7:		/* Rotate on specific EOI	*/
		line  = value & 0x07;
#ifndef PROD
		if (io_verbose & ICA_VERBOSE)
		{
		    sprintf(icamsgbuf, "ica_outb: Rotate on specific EOI, line %d", line);
		    trace(icamsgbuf, DUMP_NONE);
		}
#endif
		ica_eoi(adapter, &line, TRUE);
		break;
	    }
	}
/**/
	else			/* Bit 3 set -> OCW3		*/
	{
	    if (value & ICA_SMM_CMD)	/* Set/unset SMM	*/
	    {
		asp->ica_mode = (asp->ica_mode & ~ICA_SMM) | (((IU16)value << 4) & ICA_SMM);
#ifndef PROD
		if (io_verbose & ICA_VERBOSE)
		    if (asp->ica_mode & ICA_SMM)
			trace("ica_outb: Special Mask Mode set", DUMP_NONE);
		    else
			trace("ica_outb: Special Mask Mode unset", DUMP_NONE);
#endif
	    }

	    if (value & ICA_POLL_CMD)	/* We are being polled	*/
	    {
		asp->ica_mode |= ICA_POLL;
#ifndef PROD
		if (io_verbose & ICA_VERBOSE)
		    trace("ica_outb: Poll detected!", DUMP_NONE);
#endif
	    }
	    else
	    if (value & ICA_RR_CMD)	/* Select IRR or ISR	*/
	    {
		asp->ica_mode = (asp->ica_mode & ~ICA_RIS) | (((IU16)value << 11) & ICA_RIS);
#ifndef PROD
		if (io_verbose & ICA_VERBOSE)
		    if (asp->ica_mode & ICA_RIS)
			trace("ica_outb: ISR selected", DUMP_NONE);
		    else
			trace("ica_outb: IRR selected", DUMP_NONE);
#endif
	    }
	}
	break;

/**/
    case  2:			/* We are expecting a ICW2		*/
#if defined(NEC_98)
        if (!(port & 2))
#else    //NEC_98
        if (!(port & 1))        /* Should be odd address, so check      */
#endif   //NEC_98
	{
#ifndef PROD
	    sprintf(icamsgbuf, "ica_outb: bad port (%x) while awaiting ICW2",
			 (unsigned)port);
	    trace(icamsgbuf, DUMP_NONE);
#endif
	}
	else
	{
	    asp->ica_base = value & ICA_BASE_MASK;
#ifndef PROD
	    if (io_verbose & ICA_VERBOSE)
	    {
		sprintf(icamsgbuf, "ica_outb: vector base set to %x", asp->ica_base);
		trace(icamsgbuf, DUMP_NONE);
	    }
#endif
	    if (!(asp->ica_mode & ICA_SINGL))
		sequence[adapter] = 3;
	    else
	    if (asp->ica_mode & ICA_IC4)
		sequence[adapter] = 4;
	    else
		sequence[adapter] = 0;
	}
	break;

/**/
    case  3:			/* We are expecting a ICW3		*/
#if defined(NEC_98)
        if (!(port & 2))
#else    //NEC_98
        if (!(port & 1))        /* Should be odd address, so check      */
#endif   //NEC_98
	{
#ifndef PROD
	    sprintf(icamsgbuf, "ica_outb: bad port (%x) while awaiting ICW3",
			 (unsigned)port);
	    trace(icamsgbuf, DUMP_NONE);
#endif
	}
	else
	{
	    asp->ica_ssr = value & 0xff;
#ifndef PROD
	    if (io_verbose & ICA_VERBOSE)
	    {
		sprintf(icamsgbuf, "ica_outb: slave register set to %x", asp->ica_ssr);
		trace(icamsgbuf, DUMP_NONE);
	    }
#endif
	    if (asp->ica_mode & ICA_IC4)
		sequence[adapter] = 4;
	    else
		sequence[adapter] = 0;
	}
	break;

/**/
    case  4:			/* We are expecting a ICW4		*/
#if defined(NEC_98)
        if (!(port & 2))
#else    //NEC_98
        if (!(port & 1))        /* Should be odd address, so check      */
#endif   //NEC_98
	{
#ifndef PROD
	    sprintf(icamsgbuf, "ica_outb: bad port (%x) while awaiting ICW4",
			 (unsigned)port);
	    trace(icamsgbuf, DUMP_NONE);
#endif
	}
	else
	{
	    asp->ica_mode = (asp->ica_mode & ~ICA_ICW4_MASK)
		           | (((IU16)value << 4) &  ICA_ICW4_MASK);
#ifndef PROD
	    if (io_verbose & ICA_VERBOSE)
	    {
		sprintf(icamsgbuf, "ica_outb: IC4 value %x", value);
		trace(icamsgbuf, DUMP_NONE);
	    }
	    /*
	     * Check the mode bits for sensible values
	     */
	    if (!(asp->ica_mode & ICA_MPM))
		trace("ica_outb: attempt to set up 8080 mode!", DUMP_NONE);

	    if ((asp->ica_mode & ICA_BUF) && !(asp->ica_mode & ICA_MS)
				     && !(asp->ica_mode & ICA_SINGL))
		trace("ica_outb: attempt to set up slave mode!", DUMP_NONE);
#endif
	}
	sequence[adapter] = 0;
	break;

    case -1:		/* Power on but so far uninitialised	*/
#ifndef PROD
	sprintf(icamsgbuf, "ica_outb: bad port/value (%x/%x) while awaiting ICW1",
		     (unsigned)port, value);
	trace(icamsgbuf, DUMP_NONE);
#endif
	break;

    default:		/* This cannot happen			*/;
#ifndef PROD
	trace("ica_outb: impossible error, programmer brain-dead", DUMP_NONE);
#endif
    }

    ica_lock_set(0);
    host_ica_unlock();			/* free lock if supported */
}


void SWPIC_hw_interrupt IFN3(IU32, adapter, IU32, line_no, IS32, call_count)
{
    /*
     * This routine is called by an adapter to raise an interrupt line.
     * It may or may not interrupt the CPU. The CPU may or may not take
     * any notice.
     */

    ADAPTER_STATE *asp = &adapter_state[adapter];
    IU8 bit;
    IU32 line;
#ifdef CPU_40_STYLE
    IS32 depth, *progress;
#endif	/* CPU_40_STYLE */

#ifndef PROD
#if defined(NEC_98)
    SAVED char *linename[2][8] =
    {
        {
            "TIMER",
            "KEYBOARD",
            "CRTV",
            "INT0",
            "COM1",
            "INT1",
            "INT2",
            "reserved"
        },
        {
            "PRINTER",
            "INT3",
            "INT41",
            "INT42",
            "INT5",
            "INT6",
            "NDP",
            "reserved"
        }
    };
#else    //NEC_98
    SAVED char *linename[2][8] =
    {
        {
            "IRQ  0 TIMER",
            "IRQ  1 KEYBOARD",
            "IRQ  2 SLAVE_ICA",
            "IRQ  3 COM2",
            "IRQ  4 COM1",
            "IRQ  5 PARALLEL2",
            "IRQ  6 DISKETTE",
            "IRQ  7 PARALLEL1"
        },
        {
            "IRQ  8 REALTIME CLOCK",
            "IRQ  9 MOUSE",
            "IRQ 10 SOFTNODE",
            "IRQ 11 SOUND DRIVER",
            "IRQ 12 ASPI",
            "IRQ 13 COPROCESSOR",
            "IRQ 14 FIXED DISK",
            "IRQ 15 reserved"
        }
    };
#endif   //NEC_98
#endif

    /*
     * vddsvc.h defines the NTVDM exported call to this function as:
     *    call_ica_hw_interrupt(int, BYTE, int);
     * So, the line_no, being defined here as IU32 is not compatible with
     * VDD's or other DLL's which call through here. Rather than change
     * all the references to it in the source, I'm just going to AND off
     * the potential garbage here.
     */
    line_no &= 0xff;

    host_ica_lock();

#ifndef PROD
    if (io_verbose & ICA_VERBOSE_LOCK)
    {
	if(adapter>1 || line_no>7)
		printf("**** H/W INTERRUPT (%sx%d) [%d:%d] ****\n",
		       linename[adapter][line_no], call_count,adapter,line_no);
    }
#endif

    /*
     * If there is a request already outstanding on this line, then leave
     * the IRR alone, but make a pass through anyway to action previously
     * received but locked calls (see below for details).
     */

    bit = (1 << line_no);
    if (!(asp->ica_irr & bit))
    {
	asp->ica_irr |= bit;		/* Pray we don't get a signal here! */

    }
    asp->ica_count[line_no] += call_count;	/* Add the further requests */

#ifndef PROD
    if (io_verbose & ICA_VERBOSE)
    {
	sprintf(icamsgbuf, "**** H/W INTERRUPT (%sx%d) ****",
			 linename[adapter][line_no], call_count);
	trace(icamsgbuf, DUMP_NONE);
    }
#endif

    /*
     * Check the lock flag. If it is set, then this routine is being called
     * from a signal handler while something else is going on. We can't just
     * ignore the call since we might lose a keyboard interrupt. What we do
     * is to set ica_irr and ica_count as normal (ie code above), then return.
     * The next interrupt which gets through this test will cause the stored
     * interrupt to be processed. This means that any code which plays around
     * with ica_irr and ica_count should take a copy first to prevent problems.
     *
     * If the host supports real (critical section style) locks, then we won't
     * get here in the above situation, so eliminate the following test. That
     * leaves both primitive & real lock styles intact.
     */

#ifndef NTVDM
    if (!host_ica_real_locks())
    {
	if (ica_lock_inc())
	{
#ifndef PROD
		if (io_verbose & ICA_VERBOSE_LOCK)
		{
			sprintf(icamsgbuf, "*");
			trace(icamsgbuf, DUMP_NONE);
		}
#endif
		ica_lock_dec();
		return;
	}
    }
#endif

#if defined (CPU_40_STYLE) && !defined(NTVDM)
    depth = asp->isr_depth[line_no];
    if (depth > 0)
    {
	progress = &asp->isr_progress[line_no][depth];
	*progress += 1;		/* move progress along */
	if ((*progress - *(progress - 1)) > MAX_INTR_DELTA_FOR_LOST_HOOK)
	{
		asp->isr_time_decay[line_no][asp->isr_depth[line_no]] = 0;
		--asp->isr_depth[line_no];	/* reduce depth */

		/* clear CPU side stack */
		if (!host_bop_style_iret_hooks())
			PurgeLostIretHookLine(((adapter << 3) + line_no) + 1, depth - 1);
		/* permit intrs on this line */
		iretHookActive &= ~(1 << ((adapter << 3) + line_no));
	}
    }
#endif	/* CPU_40_STYLE */

    /*
     * Now scan the IRR to see if we can raise a CPU interrupt.
     */

    if ((line = ica_scan_irr(adapter)) & 0x80)
	ica_interrupt_cpu(adapter, line & 0x07);

    ica_lock_set(0);
    host_ica_unlock();
}

void SWPIC_clear_int IFN2(IU32, adapter, IU32, line_no)
{
    /*
     * This routine is called by an adapter to lower an input line.
     * The line will then not interrupt the CPU, unless of course
     * it has already done so.
     */

    ADAPTER_STATE *asp = &adapter_state[adapter];
    IU8 bit, irr_check;

    host_ica_lock();
    /*
     * Decrement the call count and if zero clear the bit in the IRR
     */

    bit = (1 << line_no);
    if (--(asp->ica_count[line_no]) <= 0)
    {
	irr_check = asp->ica_irr;
	asp->ica_irr &= ~bit;
	asp->ica_count[line_no] = 0;		/* Just in case */
	if ((!asp->ica_master) && (ica_scan_irr(adapter)==7))
		{
		asp->ica_cpu_int=FALSE;
		ica_clear_int(ICA_MASTER,asp->ica_ssr);
		}
#ifdef EOI_HOOKS
	/*
	// If the line has a pending interrupt, call the eoi hook
	// to release any device waiting for an EoiHook.
	*/
	if ((irr_check & bit) != 0)
		host_EOI_hook(line_no + (adapter << 3), -1);
#endif	/* EOI_HOOKS */
    }

#ifndef PROD
    if (io_verbose & ICA_VERBOSE)
    {
	sprintf(icamsgbuf, "**** ICA_CLEAR_INT, line %d ****", line_no);
	trace(icamsgbuf, DUMP_NONE);
    }
#endif

    host_ica_unlock();
}

/*
 * The emulation code associated with this interrupt line has decided it
 * doesn't want to generate any more interrupts, even though the ICA may not
 * have got through all the interrupts previously requested.
 * Simply clear the corresponding interrupt count.
 */
void ica_hw_interrupt_cancel IFN2(IU32, adapter, IU32, line_no)
{
	host_ica_lock();
	adapter_state[adapter].ica_count[line_no] = 0;
	host_ica_unlock();
	ica_clear_int(adapter, line_no);
}

#if defined(HOOKED_IRETS) || defined(NTVDM)
GLOBAL IS32
ica_intack IFN1(IU32 *, hook_address)
#else
GLOBAL IS32
ica_intack IFN0()
#endif	/* HOOKED_IRETS */
{
    /*
     * This routine is called by the CPU when it wishes to acknowledge
     * an interrupt. It is equivalent to the INTA pulses from the real
     * device. The interrupt number is delivered.
     * It can also be called from ica_inb as a Poll.
     *
     * Modification for Rev. 2:
     *
     * It is now necessary to detect whether a slave interrupt controller
     * is attached to a particular interrupt request line on the master
     * ICA. If a slave exists, it must be accessed to discover the
     * interrupt vector.
     */
    IS32 line;		/* the IRQ line */
    IU8 bit;		/* bitmask for 'line' */
    IS32 int_no;	/* The interrupt number to return, 0-255 */
    ADAPTER_STATE *asp;	/* working pointer to adapter */

    host_ica_lock();	/* real lock if supported */

    line = ica_accept(ICA_MASTER);

#if defined (CPU_40_STYLE) || defined (NTVDM)
    if (line == -1)	/* skip any spurious ints */
    {
	host_ica_unlock();
	return ICA_INTACK_REJECT;
    }
#endif	/* CPU_40_STYLE */

    bit  = (1 << line);
    if (adapter_state[ICA_MASTER].ica_ssr & bit)
    {
        line = ica_accept(ICA_SLAVE);
	int_no = line + adapter_state[ICA_SLAVE].ica_base;

#if defined (CPU_40_STYLE) || defined (NTVDM)
	if (line == -1)	/* skip any spurious ints */
        {
            adapter_state[ICA_MASTER].ica_isr &= ~bit;
            host_ica_unlock();
	    return ICA_INTACK_REJECT;
	}
#endif	/* CPU_40_STYLE */

#if defined(CPU_40_STYLE) && !defined(NTVDM)
	/* do callback processing for action interrupt */
	asp = &adapter_state[ICA_SLAVE];
	if (asp->callback_fn[line] != NO_ICA_CALLBACK)
	{
	    /* invoke callback function */
	    (*asp->callback_fn[line])(asp->callback_parm[line]);
	    /* clear callback state reject intack call */
	    asp->callback_fn[line] = NO_ICA_CALLBACK;
	    host_ica_unlock();
	    return ICA_INTACK_REJECT;
	}
#endif  /* CPU_40_STYLE */

        line += 8;      /* make in range 8 - 15 for iret hook */

    }
    else
    {
	asp = &adapter_state[ICA_MASTER];	/* also excuse to use asp */

#if defined(CPU_40_STYLE) &&  !defined(NTVDM)
	/* do callback processing for action interrupt */
	if (asp->callback_fn[line] != NO_ICA_CALLBACK)
	{
	    /* invoke callback function */
	    (*asp->callback_fn[line])(asp->callback_parm[line]);
	    /* clear callback state & return reject */
	    asp->callback_fn[line] = NO_ICA_CALLBACK;
	    host_ica_unlock();
	    return ICA_INTACK_REJECT;
	}
#endif	/* CPU_40_STYLE */

	int_no = line + asp->ica_base;
    }


#if defined (NTVDM)

#ifdef MONITOR
    *hook_address = host_iret_bop_table_addr(line);
    if (*hook_address) {
        iretHookActive |= 1 << line;
        }
#else
    *hook_address = 0;
#endif


#else
#ifdef HOOKED_IRETS
    /* check whether IRET Hook required for interrupt on this line.
     * If IRET trapping mechanism is via bops on stack then this may
     * also be conditional on the current state of the emulated hardware.
     * This is checked via a host call (or define).
     */
    if (host_valid_iret_hook())
    {
	*hook_address = ica_iret_hook_needed(line);

#ifdef CPU_40_STYLE
	if (*hook_address != 0)
	{
			IU32 al = line >= 8 ? line - 8 : line; /* line no. within adapter */

	    /* about to do iret hooked interrupt so increase depth */
	    asp->isr_depth[al]++;
	    asp->isr_progress[al][asp->isr_depth[al]] = asp->isr_progress[al][asp->isr_depth[al]-1];
	}
#endif	/* CPU_40_STYLE */
    }
#endif  /* HOOKED_IRETS */
#endif  /* !NTVDM */

    host_ica_unlock();		/* real lock if supported */

    return(int_no);
}


#ifndef NTVDM
#ifdef CPU_40_STYLE

/*(
 ======================= Asynchronous Access to the ICA ==========================

	Potential asynchronous interrupt sources, in descending order of priority
	so that the higher priority interrupt gets raised first (saves a bit of work)
	These things will share the CPU_SIGIO_EVENT callback from the CPU, and may have
	their own specific routine to be called (which presumably includes ica_hw_interrupt,
	but doesn't need to do so).

=========================================================================
)*/
typedef struct {
	IU32	adapter;
	IU32	line_no;
	void	(*interrupt) IPT0();
	IBOOL	pending;
} ICA_ASYNC_HANDLER;

#define ICA_IMPOSSIBLE_LINE	100

/* Make this a GLOBAL variable so that the C compilers can't optimise
 * accesses to it.
 */
GLOBAL ICA_ASYNC_HANDLER async_handlers[] = {

#ifdef NOVELL
	{ ICA_SLAVE, 	NETWORK_INT,	host_sigio_event },
#endif /* NOVELL */

#ifdef SWIN_HAW
	{ ICA_SLAVE,	SWIN_HAW_INT,	0 },
#endif /* SWIN_HAW */

#ifdef ASPI
	{ ICA_SLAVE,	ASPI_INT,	0 },
#endif /* ASPI */

	{ 0, ICA_IMPOSSIBLE_LINE, 0}
};
	
/*(
======================= ica_async_hw_interrupt ==========================

PURPOSE: Simplified interface to replace ica_hw_interrupt() when triggered
	by truly asynchronous host facilties such as signal handlers. This
	routine remembers the need for an interrupt on the appropriate line,
	notifies the CPU that a SIGIO event has occurred, and issues the
	necessary ica_hw_interrupt calls during the ica_sigio_event callback.

INPUT: adapter: IU32. master/slave.
       line: IU32. IRQ line interrupt will appear on.
       call_count: IU32. number of interrupts (must be 1).

=========================================================================
)*/

GLOBAL void ica_async_hw_interrupt IFN3(IU32, adapter, IU32, line_no, IS32, call_count)
{
	ICA_ASYNC_HANDLER *iahp;
	
#ifndef PROD
	if (call_count != 1) {
		always_trace3("ica_async_interrupt(%s, %d, %d): call_count must be 1",
			adapter? "MASTER":"SLAVE", line_no, call_count);
	}
#endif /* !PROD */

	for (iahp = async_handlers; iahp->line_no != ICA_IMPOSSIBLE_LINE; iahp++) {
		if (iahp->adapter == adapter && iahp->line_no == line_no) {
		
			/* This is as near to an atomic action as we can easily arrange,
			 * though there is a minute possibility of missing an interrupt
			 * if it is called between the test and the store in the ica_sigio_event
			 * handler below.
			 */
			if (!iahp->pending) {
				iahp->pending = TRUE;				/* set the flag */
				cpu_interrupt(CPU_SIGIO_EVENT, 0);	/* inform the CPU */
			}
			return;
		}
	}
	always_trace2("Unexpected ica_async_interrupt(%d, %d)", adapter, line_no);
}

/*(
 ========================== ica_sigio_event ==========================

PURPOSE: Called by the CPU in response to cpu_interrupt(CPU_SIGIO_EVENT,0)
	at a point when it is possible to make calls to the ICA hardware
	emulation without suffering from race conditions etc.

=========================================================================
)*/

GLOBAL void ica_sigio_event IFN0()
{
	ICA_ASYNC_HANDLER *iahp;
	
	for (iahp = async_handlers; iahp->line_no != ICA_IMPOSSIBLE_LINE; iahp++) {
		/* This is as near to an atomic action as we can easily arrange,
		 * though there is a minute possibility of missing an interrupt...
		 */
		if (iahp->pending) {
			iahp->pending = FALSE;			/* clear the flag */
			if (iahp->interrupt) {
				(*(iahp->interrupt))();		/* call special handler */
			} else {
				ica_hw_interrupt(iahp->adapter, iahp->line_no, 1);
			}
		}
	}
	
}

LOCAL void ica_sigio_init IFN0()
{
	ICA_ASYNC_HANDLER *iahp;
	
	for (iahp = async_handlers; iahp->line_no != ICA_IMPOSSIBLE_LINE; iahp++) {
		iahp->pending = FALSE;
	}
}

/*(
 =========================== action_interrupt ==========================

PURPOSE: Associate an action with an interrupt on the line. When the CPU
	 is next able to process an interrupt on the requested line, the
	 callback function will be executed. That callback can then call
	 the relevant hardware interrupt interface once it has performed
	 the rest of the associated emulation.

INPUT: adapter: IU32. master/slave.
       line: IU32. IRQ line interrupt will appear on.
       func: callback function address to callback when line available.
       parm: IU32. parameter to pass to above fn.

OUTPUT: Returns false (failure) if action_int already pending on that line
	otherwise true (success).

=========================================================================
)*/
GLOBAL IBOOL
action_interrupt IFN4(IU32, adapter, IU32, line, ICA_CALLBACK, func, IU32, parm)
{
	ADAPTER_STATE *asp = &adapter_state[adapter];

	host_ica_lock();	/* real lock if available */

	line &= 7;

	/* check if callback already outstanding on this line */
	if (asp->callback_fn[line] != NO_ICA_CALLBACK)
	{
#ifndef PROD
		if (io_verbose & ICA_VERBOSE)
		{
			sprintf(icamsgbuf, "action_interrupt called before line %d cleared", line);
			trace(icamsgbuf, DUMP_NONE);
		}
#endif	/* PROD */
		host_ica_unlock();	/* real unlock if available */
		return(FALSE);
	}

	/* store callback information */
	asp->callback_fn[line] = func;
	asp->callback_parm[line] = parm;

	/* set interrupt request bit */
	asp->ica_irr |= (1 << line);
	asp->ica_count[line]++;

	/* make apparent interrupt visible to apps */
	asp->ica_isr |= (1 << line);

	/* get cpu attention for this int. (i.e. get intack called a.s.a.p) */
	host_set_hw_int();

	host_ica_unlock();	/* real unlock */
}

/*(
 ======================== cancel_action_interrupt =======================

PURPOSE: Associate an action with an interrupt on the line. When the CPU
	 is next able to process an interrupt on the requested line, the
	 callback function will be executed. That callback can then call
	 the relevant hardware interrupt interface once it has performed
	 the rest of the associated emulation.

INPUT: adapter: IU32. master/slave.
       line: IU32. IRQ line to cancel interrupt action

OUTPUT: None.

=========================================================================
)*/
GLOBAL void
cancel_action_interrupt IFN2(IU32, adapter, IU32, line)
{
	ADAPTER_STATE *asp = &adapter_state[adapter];

	host_ica_lock();	/* real lock if available */

	/* remove visibility of interrupt request. */
	asp->ica_isr &= ~(1 << line);

	/* irr & count should be cleared by intack, but possible this fn.
	 * has been called before the callback has been executed.
	 */
	if (asp->callback_fn[line] != NO_ICA_CALLBACK)
	{
		asp->ica_irr &= ~(1 << line);
		asp->ica_count[line] = 0;
	}

	/* clear callback information */
	asp->callback_fn[line] = NO_ICA_CALLBACK;
	asp->callback_parm[line] = 0;

	host_ica_unlock();	/* remove real lock */

}
#endif  /* CPU_40_STYLE */

#endif  /* !NTVDM */



#if defined(NTVDM)

#ifdef MONITOR
/*
 *  Assumes caller has ica lock
 */

GLOBAL void
ica_iret_hook_called IFN1(IU32, abs_line)
{
     int i;
     IU32 adapter = abs_line >> 3;

     iretHookActive &= ~(1 << abs_line);
     if ((i = ica_scan_irr(adapter)) & 0x80)
          ica_interrupt_cpu(adapter, i & 0x07);
}


GLOBAL void
ica_iret_hook_control IFN3(IU32, adapter, IU32, line, IBOOL, enable)
{
      int mask = 1 << (line + (adapter << 3));

      host_ica_lock();

      if (enable)
          iretHookMask |= mask;
      else
          iretHookMask &= ~mask;

      host_ica_unlock();
}
#else

/*
 *  obsolete, to be removed... but the current ntvdm emulator libs ref
 * */

GLOBAL void
ica_iret_hook_called IFN1(IU32, abs_line)
{
    return; // do nothing!
}
#endif

#endif   /* NTVDM */


#ifdef HOOKED_IRETS
#ifndef  GISP_CPU           /* GISP has own version of this routine */

GLOBAL IU32 ica_iret_hook_needed IFN1(IU32, line)
{
	IU16 ireq_mask = 1 << line;

#ifndef PROD
	if (line < 0 || line > 15)
	{
		/* Line is out of range */
		sprintf(icamsgbuf, "**** ICA IRET HOOK IMPOSSIBLE line %d ****", line);
		trace(icamsgbuf, DUMP_NONE);
		return 0;
	}
#endif

	/* does this line require iret hooks */
	if (!(iretHookMask & ireq_mask))
		/* Line not hooked. */
		return 0;

	/* if iret hooks implemented via bops, check bop table addresses ok */
        if (host_bop_style_iret_hooks()) {
            iretHookActive |= ireq_mask;
            return(host_iret_bop_table_addr(line));
            }
        else  {
            return(line + 1);
            }
}
#endif	/* GISP_CPU */

GLOBAL void
ica_iret_hook_control IFN3(IU32, adapter, IU32, line, IBOOL, enable)
{
	int mask = 1 << (line + (adapter << 3));

	if (enable)
		iretHookMask |= mask;
	else
		iretHookMask &= ~mask;
}


GLOBAL void
ica_iret_hook_called IFN1(IU32, abs_line)
{
	ADAPTER_STATE *asp;
	IU32 adapter = abs_line >> 3;
	IU32 line = abs_line - (adapter <<3);
	IU8 i;

#ifndef PROD
	if (io_verbose & ICA_VERBOSE)
	{
		sprintf(icamsgbuf, "**** ICA IRET HOOK, line %d ****", line);
		trace(icamsgbuf, DUMP_NONE);
	}
#endif

#ifdef CPU_40_STYLE
	asp = &adapter_state[adapter];
	asp->isr_time_decay[line][asp->isr_depth[line]] = 0;
	asp->isr_depth[line]--;

	/* back to base stack level so restart first level recursion counter */
	if (asp->isr_depth[line] == 0)
		asp->isr_progress[line][1] = 0;

	/* enable interrupts on this line */
	if (asp->isr_depth[line] < MAX_ISR_DEPTH)
		iretHookActive &= ~(1 << abs_line);
#else
	UNUSED(asp);	/* anti warning */
	iretHookActive &= ~(1 << abs_line);
#endif	/* CPU_40_STYLE */


	if ((i = ica_scan_irr(adapter)) & 0x80)
		ica_interrupt_cpu(adapter, i & 0x07);
}


#if defined(CPU_40_STYLE)
#define HOWOFTEN	18	/* approx once per second */
#define MAXAGE		8	/* passes before purge */
GLOBAL void
ica_check_stale_iret_hook IFN0()
{
	SAVED int howoften = 18;
	int line, depth, loop;
	ADAPTER_STATE *asp;
	IS32 *cpdelay;

	howoften --;
	if (howoften == 0)
	{
		howoften = 18;

		host_ica_lock();
		asp = &adapter_state[0];
		for (line = 0; line < 8; line++)
		{
		    if (iretHookMask & (1 << line))
		    {
			for (depth = 0; depth < asp->isr_depth[line]; depth++)
			{
				asp->isr_time_decay[line][depth]++;
				if (asp->isr_time_decay[line][depth] == MAXAGE)
				{
					asp->isr_time_decay[line][depth] = 0;
					if (depth == 0 && asp->ica_count[line] == 0)
						continue;	/* line idle */

					cpdelay = &asp->isr_time_decay[line][depth];
					/* lose hook data for this depth */
					loop = depth;
					while(loop <= asp->isr_depth[line])
					{
						loop ++;
						*cpdelay = *(cpdelay + 1);
						cpdelay++;
					}
					asp->isr_depth[line]--;

					/* fix cpu side */
					PurgeLostIretHookLine(line + 1, depth);

					/* permit intrs on this line */
					iretHookActive &= ~(1 << line);

					break;	/* one hook at a time */
				}
			}
		    }
		}
		asp = &adapter_state[1];
		for (line = 0; line < 8; line++)
		{
		    if (iretHookMask & (0x10 << line))
		    {
			for (depth = 0; depth < asp->isr_depth[line]; depth++)
			{
				asp->isr_time_decay[line][depth]++;
				if (asp->isr_time_decay[line][depth] == MAXAGE)
				{
					asp->isr_time_decay[line][depth] = 0;
					if (depth == 0 && asp->ica_count[line] == 0)
						continue;	/* line idle */

					cpdelay = &asp->isr_time_decay[line][depth];
					/* lose hook data for this depth */
					loop = depth;
					while(loop <= asp->isr_depth[line])
					{
						loop ++;
						*cpdelay = *(cpdelay + 1);
						cpdelay++;
					}
					asp->isr_depth[line]--;

					/* fix cpu side */
					PurgeLostIretHookLine(line + 9, depth);

					/* permit intrs on this line */
					iretHookActive &= ~(1 << (8 + line));

					break;	/* one hook at a time */
				}
			}
		    }
		}
		host_ica_unlock();
	}
}
#endif  /* CPU_40_STYLE */
#endif	/* HOOKED_IRETS */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

#define INIT0_ICW1	(IU8)0x11	
#define INIT0_ICW2	(IU8)0x08	
#if defined(NEC_98)
#define INIT0_ICW3      (IU8)0x80
#define INIT0_ICW4      (IU8)0x1d

#define INIT0_OCW1      (IU8)0x01
#else     //NEC_98
#define INIT0_ICW3	(IU8)0x04	
#define INIT0_ICW4      (IU8)0x01

#ifdef NTVDM
#define INIT0_OCW1      (IU8)0x0

#else

/* POST leaves some int lines masked out (including comms and lpt lines) */
/* The setting of the bits is spread out throughout the real POST code
 * but is collected into one place here. I think that this will not cause
 * any problems but it is conceivable that it will harm other OS's than
 * DOS (eg OS/2 or coherent etc.)
 */
#define INIT0_OCW1      (IU8)0xb8
#endif /* NTVDM */
#endif   //NEC_98

void ica0_post IFN0()
{
    ica_outb(ICA0_PORT_0, INIT0_ICW1);
    ica_outb(ICA0_PORT_1, INIT0_ICW2);
    ica_outb(ICA0_PORT_1, INIT0_ICW3);
    ica_outb(ICA0_PORT_1, INIT0_ICW4);
    ica_outb(ICA0_PORT_1, INIT0_OCW1);
}

void ica0_init IFN0()
{
    io_addr i;

    /*
     * Set up the IO chip select logic for adapter 0. (Master).
     */

#ifdef NTVDM
    io_define_inb(ICA0_ADAPTOR, ica_inb);
    io_define_outb(ICA0_ADAPTOR, ica_outb);
#else
    io_define_inb(ICA0_ADAPTOR, ica_inb_func);
    io_define_outb(ICA0_ADAPTOR, ica_outb_func);
#endif

#if defined(NEC_98)
    for(i = ICA0_PORT_START; i <= ICA0_PORT_END; i += 2)
#else    //NEC_98
    for(i = ICA0_PORT_START; i <= ICA0_PORT_END; i++)
#endif   //NEC_98
        io_connect_port(i, ICA0_ADAPTOR, IO_READ_WRITE);

    adapter_state[ICA_MASTER].ica_master = TRUE;


#ifndef NTVDM

#ifdef CPU_40_STYLE
    for (i = 0; i < 8; i++)
    {
	adapter_state[ICA_MASTER].callback_fn[i] = NO_ICA_CALLBACK;
	adapter_state[ICA_MASTER].isr_depth[i] = 0;
    }

    ica_sigio_init();

#endif  /* CPU_40_STYLE */


#ifdef HOOKED_IRETS
    /* on iret-hooked, non NT ports, enable iret hooks */
    iretHooksEnabled = TRUE;
#endif

#endif  /* !NTVDM */

}


#define INIT1_ICW1	(IU8)0x11	
#if defined(NEC_98)
#define INIT1_ICW2      (IU8)0x10
#define INIT1_ICW3      (IU8)0x07
#define INIT1_ICW4      (IU8)0x09

#define INIT1_OCW1      (IU8)0x20
#else     //NEC_98
#define INIT1_ICW2	(IU8)0x70	
#define INIT1_ICW3	(IU8)0x02	
#define INIT1_ICW4      (IU8)0x01

#ifdef NTVDM
#define INIT1_OCW1      (IU8)0x0


/* POST leaves some int lines masked out (reserved lines and RTC) */
/* see the comment on POST setting mask bits for master ica */
#elif ASPI
#define INIT1_OCW1	(IU8)0x8d
#else /* ASPI */	
#define INIT1_OCW1	(IU8)0x9d	
#endif /* ASPI */
#endif   //NEC_98




void ica1_post IFN0()
{
    ica_outb(ICA1_PORT_0, INIT1_ICW1);
    ica_outb(ICA1_PORT_1, INIT1_ICW2);
    ica_outb(ICA1_PORT_1, INIT1_ICW3);
    ica_outb(ICA1_PORT_1, INIT1_ICW4);
    ica_outb(ICA1_PORT_1, INIT1_OCW1);
}

void ica1_init IFN0()
{
    io_addr i;

    /*
     * Set up the IO chip select logic for adapter 1. (Slave).
     */

#ifdef NTVDM
    io_define_inb(ICA1_ADAPTOR, ica_inb);
    io_define_outb(ICA1_ADAPTOR, ica_outb);
#else
    io_define_inb(ICA1_ADAPTOR, ica_inb_func);
    io_define_outb(ICA1_ADAPTOR, ica_outb_func);
#endif

#if defined(NEC_98)
    for(i = ICA1_PORT_START; i <= ICA1_PORT_END; i += 2)
#else    //NEC_98
    for(i = ICA1_PORT_START; i <= ICA1_PORT_END; i++)
#endif   //NEC_98
        io_connect_port(i, ICA1_ADAPTOR, IO_READ_WRITE);

    adapter_state[ICA_SLAVE].ica_master = FALSE;

#if defined(CPU_40_STYLE) && !defined(NTVDM)
    for (i = 0; i < 8; i++)
    {
	adapter_state[ICA_SLAVE].callback_fn[i] = NO_ICA_CALLBACK;
	adapter_state[ICA_SLAVE].isr_depth[i] = 0;
    }
#endif	/* CPU_40_STYLE */

}


#if !defined(PROD)
/*
 * The following functions are used for DEBUG purposes only.
 */
LOCAL void
ica_print_int IFN2(char *, str, IS32, val)
{
    printf("%-20s 0x%02X\n", str, val);
}

LOCAL void
ica_print_str IFN2(char *, str, char *, val)
{
    printf("%-20s %s\n", str, val);
}

GLOBAL void
ica_dump IFN1(IU32, adapter)
{
    ADAPTER_STATE *asp = &adapter_state[adapter];
    char buff[80];
    int i;

    if (adapter == ICA_MASTER)
        printf("MASTER 8259A State:\n\n");
    else
        printf("SLAVE  8259A State:\n\n");

    ica_print_str("ica_master", (asp->ica_master ? "Master" : "Slave"));
    ica_print_int("ica_irr", asp->ica_irr);
    ica_print_int("ica_isr", asp->ica_isr);
    ica_print_int("ica_imr", asp->ica_imr);
    ica_print_int("ica_ssr", asp->ica_ssr);
    ica_print_int("ica_base", asp->ica_base);
    ica_print_int("ica_hipri", asp->ica_hipri);
    ica_print_int("ica_mode", asp->ica_mode);
    printf("%-20s %8d%8d%8d%8d%8d%8d%8d%8d\n", "ica_count",
		asp->ica_count[0], asp->ica_count[1], asp->ica_count[2], asp->ica_count[3],
		asp->ica_count[4], asp->ica_count[5], asp->ica_count[6], asp->ica_count[7]);
    ica_print_int("ica_int_line", asp->ica_int_line);
    ica_print_str("ica_cpu_int", (asp->ica_cpu_int ? "TRUE" : "FALSE"));

#if defined(CPU_40_STYLE) && !defined(NTVDM)
    printf("%-20s %8d%8d%8d%8d%8d%8d%8d%8d\n", "callback_parm",
                asp->callback_parm[0], asp->callback_parm[1], asp->callback_parm[2], asp->callback_parm[3],
                asp->callback_parm[4], asp->callback_parm[5], asp->callback_parm[6], asp->callback_parm[7]);
    printf("%-20s %8p%8p%8p%8p%8p%8p%8p%8p\n", "callback_fn",
                asp->callback_fn[0], asp->callback_fn[1], asp->callback_fn[2], asp->callback_fn[3],
                asp->callback_fn[4], asp->callback_fn[5], asp->callback_fn[6], asp->callback_fn[7]);
    printf("%-20s %8d%8d%8d%8d%8d%8d%8d%8d\n", "isr_depth",
                asp->isr_depth[0], asp->isr_depth[1], asp->isr_depth[2], asp->isr_depth[3],
                asp->isr_depth[4], asp->isr_depth[5], asp->isr_depth[6], asp->isr_depth[7]);
    for (i=0; i<(MAX_ISR_DEPTH + 1); i++)
    {
	    int j;
	    int progress[8];
	    IBOOL some_progress = FALSE;
	
	    for (j = 0; j < 8; j++)
	    {
		    if (asp->isr_depth[j] >= i)
		    {
			    some_progress = TRUE;
			    progress[j] = asp->isr_progress[j][i];
		    }
		    else
		    {
			    progress[j] = 0;
		    }
	    }
	    sprintf (buff, "isr_progress[%d]", i);
	    printf("%-20s %8d%8d%8d%8d%8d%8d%8d%8d\n", buff,
		   progress[0], progress[1], progress[2], progress[3],
		   progress[4], progress[5], progress[6], progress[7]);
	    if (!some_progress)
		    break;
    }
    for (i=0; i<MAX_ISR_DEPTH; i++)
    {
	    int j;
	    int decay[8];
	    IBOOL some_decay = FALSE;
	
	    for (j = 0; j < 8; j++)
	    {
		    if (asp->isr_depth[j] >= i)
		    {
			    decay[j] = asp->isr_time_decay[j][i];
			    some_decay = TRUE;
		    }
		    else
		    {
			    decay[j] = 0;
		    }
	    }
	    sprintf (buff, "isr_time_decay[%d]", i);
	    printf("%-20s %8d%8d%8d%8d%8d%8d%8d%8d\n", buff,
		   decay[0], decay[1], decay[2], decay[3],
		   decay[4], decay[5], decay[6], decay[7]);
	    if (!some_decay)
		    break;
    }
#endif /* CPU_40_STYLE && !NTVDM */

    printf("\n\n");
}
#endif /* PROD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\system\illegalp.c ===
#include "insignia.h"
#include "host_def.h"
/*[
	Name:		illegal_op.c
	Derived From:	Base 2.0
	Author:		William Gulland
	Created On:	Unknown
	Sccs ID:	@(#)illegal_op.c	1.19 07/04/95
	Notes:		Called from the CPU.
	Purpose:	The CPU has encountered an illegal op code.

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_ERROR.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "sas.h"
#include CpuH
#include "bios.h"
#include "error.h"
#include "config.h"
#include "debug.h"
#include "yoda.h"

#ifndef PROD
IU32	IntelMsgDest = IM_DST_TRACE;
#endif

/* Routine to produce human readable form of where an illegal instruction occured */
LOCAL VOID where IFN3(CHAR *, string, word, cs, LIN_ADDR, ip)
{
	double_word ea = effective_addr(cs, ip);

	sprintf(string,
#ifdef	PROD
		"CS:%04x IP:%04x OP:%02x %02x %02x %02x %02x",
#else	/* PROD */
		"CS:IP %04x:%04x OP:%02x %02x %02x %02x %02x",
#endif	/* PROD */
		cs, ip,
		sas_hw_at(ea), sas_hw_at(ea+1), sas_hw_at(ea+2),
		sas_hw_at(ea+3),sas_hw_at(ea+4));
}

#if defined(NTVDM) && defined(MONITOR)
#define GetInstructionPointer()     getEIP()
#endif


void illegal_op()
{
#ifndef	PROD
	CHAR string[100];

	where(string, getCS(), GetInstructionPointer());
	host_error(EG_BAD_OP, ERR_QU_CO_RE, string);
#endif
}

void illegal_op_int()
{
	CHAR string[100];
	word cs, ip;

#ifdef NTVDM
        UCHAR opcode;
        double_word ea;
#endif

	/* the cs and ip of the faulting instruction should be on the top of the stack */
	sys_addr stack;

	stack=effective_addr(getSS(),getESP());

	ip = sas_hw_at(stack) + (sas_hw_at(stack+1)<<8);
	cs = sas_hw_at(stack+2) + (sas_hw_at(stack+3)<<8);

	where(string, cs, ip);

#ifndef NTVDM
#ifdef PROD
	host_error(EG_BAD_OP, ERR_QU_CO_RE, string);
#else  /* PROD */
	assert1( NO, "Illegal instruction\n%s\n", string );
	force_yoda();
#endif /* PROD */

#else /* NTVDM */
#ifdef PROD
#if defined(MONITOR) || defined(CPU_40_STYLE)
        host_error(EG_BAD_OP, ERR_QU_CO_RE, string);
#else
        ea = effective_addr(cs, ip);
        opcode = sas_hw_at(ea);
        if (opcode == 0x66 || opcode == 0x67)
            host_error(EG_BAD_OP386, ERR_QU_CO_RE, string);
        else
            host_error(EG_BAD_OP, ERR_QU_CO_RE, string);
#endif /* MONITOR */
#endif /* PROD */
#endif /* NTVDM */



	/* the user has requested a `continue` */
	/* we don't know how many bytes this instr should be, so guess 1 */
	if (ip == 0xffff) {
		cs ++;
		sas_store (stack+2, (IU8)(cs & 0xff));
		sas_store (stack+3, (IU8)((cs >> 8) & 0xff));
	}
	ip ++;
	sas_store (stack , (IU8)(ip & 0xff));
	sas_store (stack+1, (IU8)((ip >> 8) & 0xff));
	unexpected_int();
}


void illegal_dvr_bop IFN0()
{
#ifndef NTVDM
	sys_addr bop_addr;
	CHAR buf[256];

	/* This is called when an Insignia Intel driver decides that
	 * this (old) SoftWindows is not compatible.
	 *
	 * We should:
	 * a) Put up a localised panel complaining that
	 *    the named driver CS:[eIP] with decimal
	 *    version AX is incompatible with the SoftWindows.
	 *    N.B. The most compatible way to pass the
	 *    name of the driver is by embedded bytes just
	 *    after the BOP. The problem is caused by the
	 *    fact that the driver may be either 16-bit RM
	 *    or a 32-bit flat VxD so the address of the
	 *    string can be either 16/32 bits, and we
	 *    need to be able to execute (and do nothing)
	 *    on the shipping SoftPC 1.xx which prevents
	 *    us doing anything with 32-bit registers!
	 *
	 *	BOP	driver_incompat
	 *	jmp	SHORT over_name
	 *	db	'somename.drv', 0
	 * over_name:
	 *
	 * b) setCF(0)
	 */

	buf[0] = '\0';
	bop_addr = effective_addr(getCS(), GetInstructionPointer());
	if (sas_hw_at(bop_addr) == 0xEB)
	{
		IU8 data;
		char *p;

		p = buf;
		bop_addr += 2;	/* Skip the xEB xXX */
		do {
			data = sas_hw_at(bop_addr++);
			*p++ = data;
		} while (data != 0);
		sprintf(p-1, " v%d.%02d", getAX() / 100, getAX() % 100);
	}
	host_error(EG_DRIVER_MISMATCH, ERR_CONT, buf);
	setCF(0);
#endif /* ! NTVDM */
}


#ifndef PROD
LOCAL void print_msg IPT1( IU32, ofs );

void dvr_bop_trace IFN0()
{
	sys_addr bop_addr;

	 /*
	 *	BOP	driver_incompat
	 *	jmp	SHORT over_name
	 *	db	'somename.drv', 0
	 * over_name:
	 *
	 */

	bop_addr = effective_addr(getCS(), GetInstructionPointer());
	if (sas_hw_at(bop_addr) == 0xEB)
	{
		print_msg(bop_addr+2); /* Skip the xEB xXX */
	}
}

GLOBAL void trace_msg_bop IFN0()
{
	sys_addr ea, ofs;

	/*
	Stack frame expected:
	N.B. VxDs lives in a flat segment, (mostly) protected mode world!
	This code expects the address to have been converted to a base-0
	linear address already.

		|            |
		--------------
		|  4 byte    |
	ESP-->	| eff. addr  |
		--------------
	*/

	if (sas_hw_at(BIOS_VIRTUALISING_BYTE) != 0)
		fprintf(trace_file, "** WARNING ** Virtual byte non-zero\n");

	ea = getESP();
	ea = effective_addr(getSS(), ea);
	ofs = sas_dw_at_no_check(ea);
	print_msg(ofs);
}

LOCAL void print_msg IFN1( IU32, ofs )
{
	SAVED IBOOL start_buffer = TRUE;
	SAVED char string[164], *p = NULL;
	char finalStr[180];
	IU32 res, width;

	if (start_buffer)
	{
		memset(string, 0, sizeof(string));
		p = string;
		start_buffer = FALSE;
	}

	do
	{
		/* do things which must be done at the start of a line. */
		*p = sas_hw_at(ofs++);
		if (*p == '#')
		{
			/* found poss reg. sequence in string */

			p++;
			p[0] = sas_hw_at(ofs);
			if (('A' <= p[0]) && (p[0] <= 'Z'))
				p[0] += 'a' - 'A';
			p[1] = sas_hw_at(ofs+1);
			if (('A' <= p[1]) && (p[1] <= 'Z'))
				p[1] += 'a' - 'A';
			if (p[0] == 'e')
			{
				/* may be esp, esi, eax, etc... */

				p[2] = sas_hw_at(ofs+2);
				if (('A' <= p[2]) && (p[2] <= 'Z'))
					p[2] += 'a' - 'A';
				p[3] = '\0';
				width = 8;
			}
			else
			{
				/* If not eXX then can only be two letters long */
				p[2] = '\0';
				width = 4;
			}

			if (strcmp(p, "al") == 0)
			{	res = getAL(); width = 2;	}
			else if (strcmp(p, "ah") == 0)
			{	res = getAH(); width = 2;	}
			else if (strcmp(p, "bl") == 0)
			{	res = getBL(); width = 2;	}
			else if (strcmp(p, "bh") == 0)
			{	res = getBH(); width = 2;	}
			else if (strcmp(p, "cl") == 0)
			{	res = getCL(); width = 2;	}
			else if (strcmp(p, "ch") == 0)
			{	res = getCH(); width = 2;	}
			else if (strcmp(p, "dl") == 0)
			{	res = getDL(); width = 2;	}
			else if (strcmp(p, "dh") == 0)
			{	res = getDH(); width = 2;	}
			else if (strcmp(p, "ax") == 0)
				res = getAX();
			else if (strcmp(p, "bx") == 0)
				res = getBX();
			else if (strcmp(p, "cx") == 0)
				res = getCX();
			else if (strcmp(p, "dx") == 0)
				res = getDX();
			else if (strcmp(p, "si") == 0)
				res = getSI();
			else if (strcmp(p, "di") == 0)
				res = getDI();
			else if (strcmp(p, "sp") == 0)
				res = getSP();
			else if (strcmp(p, "bp") == 0)
				res = getBP();
			else if (strcmp(p, "eax") == 0)
				res = getEAX();
			else if (strcmp(p, "ebx") == 0)
				res = getEBX();
			else if (strcmp(p, "ecx") == 0)
				res = getECX();
			else if (strcmp(p, "edx") == 0)
				res = getEDX();
			else if (strcmp(p, "esi") == 0)
				res = getESI();
			else if (strcmp(p, "edi") == 0)
				res = getEDI();
			else if (strcmp(p, "esp") == 0)
				res = getESP();
			else if (strcmp(p, "ebp") == 0)
				res = getEBP();
			else if (strcmp(p, "cs") == 0)
				res = getCS();
			else if (strcmp(p, "ds") == 0)
				res = getDS();
			else if (strncmp(p, "es", 2) == 0)
			{	res = getES(); width = 4; p[2] = '\0';	}
			else if (strcmp(p, "fs") == 0)
				res = getFS();
			else if (strcmp(p, "gs") == 0)
				res = getGS();
			else if (strcmp(p, "fl") == 0)
				res = getFLAGS();
			else if (strcmp(p, "efl") == 0)
				res = getEFLAGS();
			else
				*p = '\0';	/* else just write the '#' */
			if (*p)
			{
				/* Overwrite the "#xx" with it's value */

				ofs += (p[2] ? 3: 2);
				p--;
				if (width == 8)
					sprintf(p, "%08x", res);
				else if (width == 4)
					sprintf(p, "%04x", res);
				else
					sprintf(p, "%02x", res);
				p += strlen(p);
			}
		}
		else if (*p != '\r')	/* ignore CR's */
		{
			if (*p == '\n' || (p - string >= (sizeof(string) - 4)))
			{
				p[1] = '\0';
				sprintf(finalStr, "intel msg at %04x:%04x : %s",
						getCS(), GetInstructionPointer(), string);
#ifdef CPU_40_STYLE
				if (IntelMsgDest & IM_DST_TRACE)
				{
					fprintf(trace_file, finalStr);
				}
#ifndef	CCPU
				if (IntelMsgDest & IM_DST_RING)
				{
					AddToTraceXBuffer( ((GLOBAL_TraceVectorSize - 2) << 4) + 0,
				  		finalStr );
				}
#endif	/* CCPU */
#else	/* CPU_40_STYLE */
				fprintf(trace_file, finalStr);
#endif	/* CPU_40_STYLE */
				memset(string, 0, sizeof(string));
				p = string;
			}
			else if (*p == '\0')	/* no more - stop */
				break;
			else
				p++;
		}
	} while ((p - string) < sizeof(string) - 4);
}
#endif /* ! PROD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\system\qevnt.c ===
/*
 *
 *  NTVDM specific version of Quick event dispatcher.
 *
 *  See quick_ev.c for current insignia compatibility level, and full
 *  documentation. Functionally compatible with:
 *
 *  "quick_ev.c 1.43 07/04/95 Copyright Insignia Solutions Ltd"
 *
 *  Quick Events are fully supported on Risc platforms.
 *  Quick Events are stubbed to dispatch immediatley on x86 platforms.
 *  Tick events are not supported on any platform, (no longer used)
 *  All Global quick event interfaces use the host_ica_lock for
 *  synchronization.
 *
 *  11-Dec-1995 Jonle
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "insignia.h"
#include "host_def.h"
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include TypesH
#include MemoryH
#include "xt.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "debug.h"
#include "timer.h"
#include "host_hfx.h"
#include "quick_ev.h"
#include "timestmp.h"
#include "ica.h"
#include "nt_eoi.h"



/*
 *  The Quick event structure
 */
typedef struct _QuickEventEntry {
     LIST_ENTRY    qevListEntry;
     LARGE_INTEGER DueTimeStamp;
     ULONG         DelayTime;
     Q_CALLBACK_FN qevCallBack;
     long          Param;
     ULONG         QuickEventId;
} QEV_ENTRY, *PQEV_ENTRY;


/*  Quick event handle structure. externally its defined
 *  as a LONGLONG, internally we manipulate as a QEVHANDLE union
 *  giving us a simple and 99% effective algorithm for verifying
 *  qevent handles.
 *
 *  CAVEAT: the QEVHANDLE union MUST not be larger than a LONGLONG.
 */
typedef union _QuickEventHandle {
    struct {
        PVOID pvQuickEvent;
        ULONG QuickEventId;
        };
    LONGLONG Handle;
} QEVHANDLE, PQEVHANDLE;


LIST_ENTRY QuickEventListHead = {&QuickEventListHead,&QuickEventListHead};
ULONG qevNextHandleId=0;
LARGE_INTEGER qevNextDueTime = {0,0};

extern void host_TimeStamp(PLARGE_INTEGER pliTime); // nt_timer.c


/*
 *  Calibration variables
 */
#define DEFAULT_IJCTIME 10
#define CALIBCYCLE16    16  // CALIBCYCLE16 must be 16, because hard coded
                            // shift operations are used to avoid division.


void quick_tick_recalibrate(void);
GLOBAL IBOOL DisableQuickTickRecal = FALSE;
ULONG qevJumpRestart = 100;
ULONG qevUsecPerIJC = 0;
ULONG qevCalibUsecPerIJC;
int  qevCalibCycle=0;

BOOL QevInitialized = FALSE;

LARGE_INTEGER qevCalibCount={0,0};
LARGE_INTEGER qevCalibTime={0,0};
LARGE_INTEGER qevPeriodTime={0,0};

VOID
q_event_init(
      void
      )
{
#ifndef MONITOR
     PLIST_ENTRY Next;
     PQEV_ENTRY pqevEntry;


#if DBG
     if (sizeof(QEVHANDLE) > sizeof(ULONGLONG)) {
         DbgPrint("sizeof(QEVHANDLE) > sizeof(ULONGLONG)\n");
         DbgBreakPoint();
         }
#endif

     host_ica_lock();

     //
     // do first time initialization, this must be done before ANY
     // devices access the quick event interface.
     //
     if (!QevInitialized ) {
         qevJumpRestart = host_get_jump_restart();
         qevUsecPerIJC = DEFAULT_IJCTIME * qevJumpRestart;
         qevCalibUsecPerIJC = DEFAULT_IJCTIME * qevJumpRestart;
         qevPeriodTime.QuadPart = 100000 * 16; // tick every 100 ms, cycle =16
         QevInitialized = TRUE;
         }

     if (IsListEmpty(&QuickEventListHead)) {
         host_q_ev_set_count(0);
         qevNextDueTime.QuadPart = 0;
         }

     qevCalibCycle=0;
     qevCalibCount.QuadPart = 0;
     host_TimeStamp(&qevCalibTime);

     host_ica_unlock();
#endif
}


#ifndef MONITOR

/*
 *  Caller must hold ica lock
 */
void
ResetCpuQevCount(
     PLARGE_INTEGER CurrTime
     )
{
     LARGE_INTEGER DiffTime;
     PQEV_ENTRY  pqevEntry;
     ULONG DelayTime;

     if (IsListEmpty(&QuickEventListHead)) {
         host_q_ev_set_count(0);
         qevNextDueTime.QuadPart = 0;
         return;
         }

     pqevEntry = CONTAINING_RECORD(QuickEventListHead.Flink,
                                   QEV_ENTRY,
                                   qevListEntry
                                   );

     DiffTime.QuadPart = pqevEntry->DueTimeStamp.QuadPart - CurrTime->QuadPart;

        /*
         *  If behind schedule use a reduced delay time to speed up
         *  dispatching of events. Can't go too fast or quick events will
         *  batch up.
         */
     if (DiffTime.QuadPart < 0) {
         DelayTime = (pqevEntry->DelayTime >> 1) + 1;
         }
     else {
         DelayTime = DiffTime.LowPart;    /* ignore overflow! */
         }

     qevNextDueTime.QuadPart = CurrTime->QuadPart + DelayTime;
     host_q_ev_set_count(host_calc_q_ev_inst_for_time(DelayTime));
}
#endif



/*
 * add_q_event_t - add event to do in n usecs
 *
 *
 */

q_ev_handle
add_q_event_t(
      Q_CALLBACK_FN func,
      unsigned long Time,
      long param
      )
{

#ifdef MONITOR
        /*
         *  On X86 dispatch immediately, as x86 has no efficient way
         *  to acheive usec granularity.
         */

        (*func)(param);

        return (q_ev_handle)1;


#else  /* MONITOR */

        QEVHANDLE   qevHandle;
        PLIST_ENTRY Next;
        PQEV_ENTRY  NewEntry;
        PQEV_ENTRY  EarlierEntry;
        PQEV_ENTRY  pqevEntry;
        LARGE_INTEGER CurrTime;


        host_ica_lock();

        NewEntry = qevHandle.pvQuickEvent = malloc(sizeof(QEV_ENTRY));
        if (!NewEntry) {
            host_ica_unlock();
            return (q_ev_handle)1;
            }

        host_TimeStamp(&CurrTime);

        NewEntry->DueTimeStamp.QuadPart = CurrTime.QuadPart + Time;
        NewEntry->qevCallBack = func;
        NewEntry->Param = param;
        NewEntry->QuickEventId = qevNextHandleId++;
        qevHandle.QuickEventId = NewEntry->QuickEventId;

        /*
         *  The Quick event list is sorted in ascending order
         *  by DueTimeStamp, insert in sorted order.
         */
        EarlierEntry = NULL;
        Next = QuickEventListHead.Blink;
        while (Next != &QuickEventListHead) {
            pqevEntry = CONTAINING_RECORD(Next, QEV_ENTRY, qevListEntry);
            if (NewEntry->DueTimeStamp.QuadPart >
                pqevEntry->DueTimeStamp.QuadPart)
              {
                EarlierEntry = pqevEntry;
                break;
                }
            Next= Next->Blink;
            }

        /*
         *  If Earlier Entry found, chain the new entry in after
         *  the earlier entry, and set the DelayTimes.
         */
        if (EarlierEntry) {
            Next = EarlierEntry->qevListEntry.Flink;
            NewEntry->qevListEntry.Flink = Next;
            NewEntry->qevListEntry.Blink = &EarlierEntry->qevListEntry;
            EarlierEntry->qevListEntry.Flink = &NewEntry->qevListEntry;
            NewEntry->DelayTime = (ULONG)(NewEntry->DueTimeStamp.QuadPart -
                                          EarlierEntry->DueTimeStamp.QuadPart);

            if (Next == &QuickEventListHead) {
                QuickEventListHead.Blink = &NewEntry->qevListEntry;
                }
            else {
                pqevEntry = CONTAINING_RECORD(Next, QEV_ENTRY, qevListEntry);
                pqevEntry->qevListEntry.Blink = &NewEntry->qevListEntry;
                pqevEntry->DelayTime = (ULONG)(pqevEntry->DueTimeStamp.QuadPart -
                                               NewEntry->DueTimeStamp.QuadPart);
                }
            }

        /*
         *  Earlier Entry not found insert at head of list,
         *  reset the cpu count and real expected due time.
         */
        else {
            InsertHeadList(&QuickEventListHead, &NewEntry->qevListEntry);
            NewEntry->DelayTime = Time;
            ResetCpuQevCount(&CurrTime);
            }

        host_ica_unlock();

        return qevHandle.Handle;


#endif
}




/*
 * add_q_event_i - add event to do in n number of instructions.
 *
 * HOWEVER, instructions is interpreted as time with (1 instr\1 usec).
 * It is not Instruction Jump Counts (IJC).
 *
 */
q_ev_handle
add_q_event_i(
        Q_CALLBACK_FN func,
        unsigned long instrs,
        long param
        )
{
        return add_q_event_t(func, instrs, param);
}


/*
 * Called from the cpu when a count of zero is reached
 */
VOID
dispatch_q_event(
    void
    )
{
#ifndef MONITOR
        PQEV_ENTRY  pqevEntry;
        LARGE_INTEGER CurrTime;
        Q_CALLBACK_FN qevCallBack = NULL;
        long          Param;


        host_ica_lock();

        if (!IsListEmpty(&QuickEventListHead)) {
            pqevEntry = CONTAINING_RECORD(QuickEventListHead.Flink,
                                          QEV_ENTRY,
                                          qevListEntry
                                          );

            qevCallBack = pqevEntry->qevCallBack;
            Param       = pqevEntry->Param;

            RemoveEntryList(&pqevEntry->qevListEntry);
            free(pqevEntry);
            }

        if (IsListEmpty(&QuickEventListHead)) {
            host_q_ev_set_count(0);
            qevNextDueTime.QuadPart = 0;
            }
        else {
            host_TimeStamp(&CurrTime);
            ResetCpuQevCount(&CurrTime);
            }

        host_ica_unlock();

        if (qevCallBack) {
            (*qevCallBack)(Param);
            }
#endif
}


VOID
delete_q_event(
        q_ev_handle Handle
        )
{
#ifndef MONITOR
        QEVHANDLE   qevHandle;
        PLIST_ENTRY Next;
        LARGE_INTEGER CurrTime;
        PQEV_ENTRY pqevEntry;
        PQEV_ENTRY EntryFound;


        qevHandle.Handle = Handle;

        host_ica_lock();

        //
        // Search the qev list for the entry to ensure
        // that the qevHandle exists.
        //
        EntryFound = NULL;
        Next = QuickEventListHead.Flink;
        while (Next != &QuickEventListHead) {
            pqevEntry = CONTAINING_RECORD(Next, QEV_ENTRY, qevListEntry);
            Next = Next->Flink;
            if (pqevEntry == qevHandle.pvQuickEvent &&
                pqevEntry->QuickEventId == qevHandle.QuickEventId)
               {
                EntryFound = pqevEntry;
                break;
                }
            }

        if (!EntryFound) {
            host_ica_unlock();
            return;
            }

        //
        // Adjust the Next entry's DelayTime.
        //
        if (Next != &QuickEventListHead) {
            pqevEntry = CONTAINING_RECORD(Next, QEV_ENTRY, qevListEntry);
            pqevEntry->DelayTime += EntryFound->DelayTime;
            }

        //
        // If the entry being removed was at the head of the list
        // Get curr time and remember that head has changed.
        //
        if (EntryFound->qevListEntry.Blink == &QuickEventListHead) {
            host_TimeStamp(&CurrTime);
            }
        else {
            CurrTime.QuadPart = 0;
            }

        //
        // Remove the entry found, and reset Cpu qev count
        // if head has changed
        //
        RemoveEntryList(&EntryFound->qevListEntry);
        free(EntryFound);

        //
        // if head of list changed, reset the Cpu quick event count
        //
        if (CurrTime.QuadPart) {
            ResetCpuQevCount(&CurrTime);
            }


        host_ica_unlock();
#endif
}



#ifndef MONITOR

/*
 * The QuickEvent list stores time in usecs. The CPU quick event counter
 * uses Instruction Jump Counts (IJC) which tracks progress in emulated
 * code as opposed to time. The following calibration code attempts to
 * relate the two.
 */

/*
 *   Convert time in usecs to Instruction Jump Counts (IJC)
 */

IU32
calc_q_inst_for_time(
     IU32 Usecs
     )
{
     ULONG InstrJumpCounts;

     InstrJumpCounts = (Usecs * qevJumpRestart)/qevUsecPerIJC;
     if (!InstrJumpCounts) {
         InstrJumpCounts = 1;
         }

     return InstrJumpCounts;
}


/*
 *   Convert Instruction Jump Counts (IJC) to time in usecs
 */
IU32
calc_q_time_for_inst(
     IU32 InstrJumpCounts
     )
{
     ULONG Usecs;

     Usecs = InstrJumpCounts * qevUsecPerIJC / qevJumpRestart;
     if (!Usecs) {
         Usecs = 1;
         }


     return Usecs;
}





/*
 *  Calibration of quick events.
 *
 *  quick_tick_recalibrate is invoked on each timer event. Its purpose is
 *  to align progress in emulated code with real time. Progress in emulated
 *  code is tracked by the cpu with Instruction Jump Counts (IJC).
 *  Real Time is tracked by the NT performance counter, with resolution
 *  in usecs (via host_TimeStamp).
 *
 *  On each call to quick_tick_rcalibrate we retrieve the cpu's IJC, and
 *  the current time, giving us a Usec to Instruction Jump Count ratio.
 *  A running average of the UsecPerIJC ratio is used to convert between
 *  real time and IJC's to set the cpu's quick event counter. An averageing
 *  method was chosen because:
 *
 *   - avoidance of unusual code fragments which may give artificial ratios.
 *
 *   - The cpu emulator only increments the Instruction Jump Counter when it
 *     is emulating code, extended durations out of the emulator produces
 *     unrealistically high UsecPerIJC ratios.
 *
 *   - performance overhead of updating the ratio.
 *
 */

void
quick_tick_recalibrate(void)
{
     LARGE_INTEGER CurrTime, PeriodTime;
     ULONG usecPerIJC;
     ULONG CalibCount;

#ifndef PROD
     if (DisableQuickTickRecal) {
         qevUsecPerIJC = DEFAULT_IJCTIME * qevJumpRestart;
         return;
         }
#endif

     host_ica_lock();

     CalibCount = host_get_q_calib_val();
     if (!CalibCount) {
         host_ica_unlock();
         return;
         }

     qevCalibCount.QuadPart += CalibCount;


     if (++qevCalibCycle == CALIBCYCLE16) {
         host_TimeStamp(&CurrTime);
         PeriodTime.QuadPart = CurrTime.QuadPart - qevCalibTime.QuadPart;
         qevCalibTime = CurrTime;
         qevPeriodTime.QuadPart = (qevPeriodTime.QuadPart + PeriodTime.QuadPart) >> 1;
         qevCalibCycle = 0;
         }
     else {
         //
         // Use an estimate of elapsed time, to avoid calling system on
         // every timer event.
         //
         PeriodTime.QuadPart = (qevPeriodTime.QuadPart >> 4) * qevCalibCycle;
         CurrTime.QuadPart = qevCalibTime.QuadPart + qevPeriodTime.QuadPart;
         }

     //
     // Calculate usecPerIJC for this period, ensuring that its not too
     // large, which is caused by app spending most of its time outside
     // of the emulator (Idle, network etc.).
     //
     usecPerIJC = (ULONG)((PeriodTime.QuadPart * qevJumpRestart)/qevCalibCount.QuadPart);
     if (usecPerIJC > 10000) {  // max at 100 usec PerIJC
         usecPerIJC = 10000;
         }
     else if (usecPerIJC < 100 ) { // min at 1 usec Per IJC
         usecPerIJC = 100;
         }


     //
     // Add it into the averaged usecPerIJC, with 25% weight
     //
     qevUsecPerIJC = (usecPerIJC + qevUsecPerIJC + (qevCalibUsecPerIJC << 1)) >> 2;


     if (!qevCalibCycle) {
         qevCalibUsecPerIJC = qevUsecPerIJC;
         qevCalibCount.QuadPart = 0;
         }


     //
     // Check the quick event list for late events. If more than a msec
     // behind, reduce the delay, and inform the emulator so it
     // will dispatch soon.
     //
     if (qevNextDueTime.QuadPart &&
         qevNextDueTime.QuadPart < CurrTime.QuadPart - 1000)
        {
         ULONG InstrJumpCounts;

         InstrJumpCounts = (host_q_ev_get_count() >> 1) + 1;
         host_q_ev_set_count(InstrJumpCounts);
         }

     host_ica_unlock();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\system\idetect.c ===
#include "insignia.h"
#include "host_def.h"

/*                      INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

	(see /vpc/1.0/Master/src/hdrREADME for help)

DOCUMENT                : name and number

RELATED DOCS            : include all relevant references

DESIGNER                : Phil Bousfield & Jerry Kramskoy

REVISION HISTORY        :
First version           : 31-Aug-89, simplified Phil's idea, and
			  produced an interface.

SUBMODULE NAME          :

SOURCE FILE NAME        : idetect.c

PURPOSE                 : provide idle detect for SoftPC, so it goes into
			  hibernation on detecting consecutive time periods
			  of unsuccessful keyboard polling at a HIGH RATE
			  with no graphics activity. Idling cannot occur
			  if polling occurs at too low a rate.

SccsID = @(#)idetect.c  1.11 10/11/93 Copyright Insignia Solutions Ltd.


[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

	INCLUDE FILE : idetect.gi

[1.1    INTERMODULE EXPORTS]

	PROCEDURES() :  idle_ctl((int)flag)
			idetect((int)event)
			idle_set(int)minpoll, (int)minperiod)

	DATA         :  int idle_no_video/disk/comlpt

---------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]

	STRUCTURES/TYPEDEFS/ENUMS:
		
---------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
	host_release_timeslice()  -     block process until interesting
					system activity occurs (such as
					time tick, I/O etc)
---------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]
	none

[1.4.2 EXPORTED OBJECTS]
=====================================================================
GLOBAL                  int idle_no_video

PURPOSE                 cleared by gvi layer, and video bios ;
			set by this interface every time tick.
			keeps track of video activity.

GLOBAL                  int idle_no_disk

PURPOSE                 cleared by disk bios ;
			set by this interface every time tick.
			keeps track of video activity.

GLOBAL                  int idle_no_comlpt

PURPOSE                 cleared by com/lpt layer,
			set by this interface every time tick.
			keeps track of com/lpt port activity



=====================================================================
PROCEDURE         :     void idle_ctl((int)flag)

PURPOSE           :     enable/disable idle detect.
		
PARAMETERS

	flag      :     0       - disable
			other   - enable.

DESCRIPTION       :     all idetect() calls ignored if disabled ..
			can't idle in this case.

ERROR INDICATIONS :     none
=====================================================================
PROCEDURE         :     void idetect((int)event)

PURPOSE           :     idle detect interface.
		
PARAMETERS

	event     :     IDLE_INIT       - initialise (clears all
					  counters)
			IDLE_KYBD_POLL  _ report an unsucessful keyboard
					  poll made by application
			IDLE_TICK       - check activity during last
					  time tick
			IDLE_WAITIO     - application has demanded i/p
					  and none is available. idle.

GLOBALS           :     idle_no_video/disk/comlpt is read for IDLE_TICK, and
			reset.

DESCRIPTION       :     keeps track of when application appears to be
			idling.

ERROR INDICATIONS :     none

ERROR RECOVERY    :     bad 'event' value ignored.
=====================================================================
PROCEDURE         :     void idle_set((int)minpoll, (int)minperiod)

PURPOSE           :     configure parameters for idling.
		
PARAMETERS

	minpoll   :     0       - don't change
			other   - specify minimum #.of unsuccessful kybd
				  polls to be made in 1 time tick
				  to qualify as an idle time period.
	minperiod :     0       - don't change
			other   - specify minimum #.of consecutive idle
				  time periods to elapse before going
				  idle. (e.g; 3 = 3 time ticks)

DESCRIPTION       :     controls sensitivity for idle detection.

ERROR INDICATIONS :     none

ERROR RECOVERY    :     bad values ignored.
=====================================================================


=====================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=====================================================================

[3.1 INTERMODULE IMPORTS]                                               */

/* [3.1.1 #INCLUDES]                                                */
/* [3.1.2 DECLARATIONS]                                             */
#include "xt.h"
#include "timer.h"

#ifdef NTVDM
/* NT configuration flag showing user request for idle support */
IMPORT BOOL IdleDisabledFromPIF;
IMPORT BOOL ExternalWaitRequest;
IMPORT BOOL VDMForWOW;
IMPORT void WaitIfIdle(void);
IMPORT VOID PrioWaitIfIdle(half_word);
#endif  /* NTVDM */

/* [3.2 INTERMODULE EXPORTS]                                            */
#include "idetect.h"

/*
5.MODULE INTERNALS   : (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]                                                */

/* [5.1.1 #DEFINES]                                                     */

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]                        */


/* [5.1.3 PROCEDURE() DECLARATIONS]                                     */
#ifdef NTVDM
void idle_kybd_poll();
void idle_tick();
#else
        LOCAL void idle_kybd_poll();
        LOCAL void idle_tick();
#endif


/* -------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS                                     */

#ifndef NTVDM
int idle_no_video;
int idle_no_comlpt;
int idle_no_disk;

static int i_counter = 0;
static int nCharPollsPerTick = 0;
static int ienabled = 0;
static int minConsecutiveTicks = 12;
static int minFailedPolls = 10;


#else
#include "vdm.h"

/*  NTVDM
 *  Some of our static global variables are located in 16 bit memory area
 *  so we reference as pointers, inititializaed by kb_setup_vectors
 */
#if defined(NEC_98)
word pICounterwork = 0;
word CharPollsPerTickwork = 0;
word MinConsecutiveTickswork =0;
#endif   //NEC_98
word minFailedPolls = 8;
word ienabled = 0;
word ShortIdle=0;
word IdleNoActivity = 0;


#if defined(NEC_98)
word *pICounter = &pICounterwork;
#else    //NEC_98
word *pICounter;
#endif   //NEC_98
#define i_counter (*pICounter)

#if defined(NEC_98)
word *pCharPollsPerTick = &CharPollsPerTickwork;
#else    //NEC_98
word *pCharPollsPerTick;
#endif   //NEC_98
#define nCharPollsPerTick (*pCharPollsPerTick)

#if defined(NEC_98)
word *pMinConsecutiveTicks = &MinConsecutiveTickswork ;
#else    //NEC_98
word *pMinConsecutiveTicks;
#endif   //NEC_98
#define minConsecutiveTicks (*pMinConsecutiveTicks)

#endif  /* NTVDM */

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]                               */

/*
======================================================================
FUNCTION        :       idle_kybd_poll()
PURPOSE         :       called from keyboard BIOS as result of
			application polling kybd unsuccessfully.
======================================================================
*/


#ifndef NTVDM
#ifdef SMEG
#include "smeg_head.h"

GLOBAL LONG dummy_long_1, dummy_long_2;
GLOBAL BOOL system_has_idled = FALSE;
#endif


LOCAL void my_host_release_timeslice()
{
#ifdef SMEG
    /*
     * Set marker and waste time (SIGPROF screws up
     * host_release_timeslice)
     */

    LONG i;

    smeg_set(SMEG_IN_IDLE);

    system_has_idled = TRUE;

    for (i = 0; i < 100000; i++)
		dummy_long_1 += dummy_long_2;

    smeg_clear(SMEG_IN_IDLE);
#else
    host_release_timeslice();
#endif

    /* re-count polls in next tick */
    nCharPollsPerTick = 0;
}
#endif  /* NTVDM */

#ifdef NTVDM
/*
 * NT uses a slightly modified algorithum to attempt to catch screen updating
 * apps. It also supports Idling calls from VDDs and thus must test which
 * thread requests the idle.
 */
void idle_kybd_poll(void)
{

	/*
	 *  We don't support wow apps reading the kbd
	 *  if a wow app comes here we must prevent them
	 *  from hogging the CPU, so we will always do
	 *  and idle no matter what.
	 */
	if (VDMForWOW) {
	    host_release_timeslice();
	    return;
	    }

	/* go idle if enough consecutive PC timer interrupts
	 * have elapsed during which time unsuccessful polling has
	 * occurred at a large enough rate for each tick.
	 */

        if (i_counter >= minConsecutiveTicks)
        {
            host_release_timeslice();
            }

	/* another unsuccessful poll ! */
	nCharPollsPerTick++;
}
#else
LOCAL void idle_kybd_poll()
{
	/* go idle if enough consecutive PC timer interrupts
	 * have elapsed during which time unsuccessful polling has
	 * occurred at a large enough rate for each tick.
	 */
	if (i_counter >= minConsecutiveTicks)
	{
		my_host_release_timeslice();
	}

	/* another unsuccessful poll ! */
	nCharPollsPerTick++;
}
#endif

/*
======================================================================
FUNCTION        :       idle_tick()
PURPOSE         :       check polling activity and graphics activity
			that's occurred during last tick. If no video
			memory writes, and high enough keyboard poll
			rate (when no i/p available) increment counter
			for triggering going idle. Otherwise reset
			counter.
======================================================================
*/

#ifdef NTVDM
void idle_tick(void)
{
        /* Has another thread asked us to idle? */
	if (ExternalWaitRequest)
	{
	    WaitIfIdle();
	    ExternalWaitRequest = FALSE;
	}
#ifdef MONITOR
    if(*pNtVDMState & VDM_IDLEACTIVITY)
       {
       *pNtVDMState &= ~ VDM_IDLEACTIVITY;
       IdleNoActivity = 0;
       }
#endif
        if (IdleNoActivity)
        {
            /* no graphics or comms/lpt activity has occurred...
	     * see whether enough polling of kybd has occurred
	     * to kick off the idling counter.
	     */
	    if (nCharPollsPerTick >= minFailedPolls) {
		i_counter++;
		if (ShortIdle) {
		    PrioWaitIfIdle(94);
		}
	    }
	}
	else
        {


            /*
             *  Check for apps which cheat idle detection by updating
             *  clocks on the screen causing video activity.
             */
            ShortIdle = nCharPollsPerTick >= minFailedPolls && i_counter >= 8;

            /* invalidate all accumulated ticks */
            i_counter = 0;
            IdleNoActivity = 1;
	}

        nCharPollsPerTick = 0;
}

#else  /* NTVDM */
LOCAL void idle_tick()
{
	if (idle_no_video && idle_no_disk && idle_no_comlpt)
	{
		/* no graphics or comms/lpt activity has occurred...
		 * see whether enough polling of kybd has occurred
		 * to kick off the idling counter.
		 */
		if (nCharPollsPerTick >= minFailedPolls)
			i_counter++;
	}
	else
	{
		i_counter = 0;
	}

	/* set flags and zero poll counter for next time period
	 */
	idle_no_video = 1;
	idle_no_disk = 1;
	idle_no_comlpt = 1;

	nCharPollsPerTick = 0;
}
#endif

/*
7.INTERMODULE INTERFACE IMPLEMENTATION :

[7.1 INTERMODULE DATA DEFINITIONS]                              */



/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]                         */

void idetect (event)
int event;
{
#ifndef NTVDM
	if (!ienabled)
            return;
#endif

	switch (event)
	{
	/* application waiting for input - go idle */
	case IDLE_WAITIO:
#ifdef NTVDM
#ifdef MONITOR
		*pNtVDMState &= ~VDM_IDLEACTIVITY;
#endif
		IdleNoActivity = 1;
                PrioWaitIfIdle(10);
		break;
#else
		my_host_release_timeslice();
#endif
		/* fall thru to idle init */

	/* initialise flags and counter */
	case IDLE_INIT:
		nCharPollsPerTick = 0;
		i_counter = 0;
#ifdef NTVDM
                IdleNoActivity = 1;
#else
		idle_no_video = 1;
		idle_no_disk = 1;
		idle_no_comlpt = 1;
#endif
		break;

	/* application polling for keyboard input */
	case IDLE_KYBD_POLL:
		idle_kybd_poll();
		break;

	case IDLE_TIME_TICK:
		idle_tick();
		break;

	}
}

void idle_set (minpoll, minperiod)
int minpoll, minperiod;
{
	if (minperiod > 0)
		minConsecutiveTicks = (word)minperiod;

	if (minpoll > 0)
		minFailedPolls = (word)minpoll;
}

void idle_ctl (flag)
int flag;
{
#ifdef NTVDM
#ifdef PIG
    ienabled = 0;
#else
    if (IdleDisabledFromPIF)    /* configured setting overrides normal control*/
	ienabled = 0;
    else
	ienabled = (word)flag;
#endif /* PIG */
#else
	ienabled = flag;
#endif  /* NTVDM */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\system\system.c ===
#if defined(NEC_98)

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "insignia.h"
#include "host_def.h"
#include <stdio.h>
#include "xt.h"
#include "ios.h"
#include "bios.h"
#include "sas.h"
#include "trace.h"
#include "debug.h"


#define GDC_5MHz                0x00
#define GDC_2MHz                0x80
#define FIXED_DISK_OFF          0x00
#define FIXED_DISK_ON           0x20
#define MEMORY_SWITCH_HOLD      0x00
#define MEMORY_SWITCH_UNHOLD    0x10
#define DISPLAY_LOW_25          0x00
#define DISPLAY_LOW_20          0x08
#define DISPLAY_COL_80          0x00
#define DISPLAY_COL_40          0x04
#define TERMINAL_MODE           0x00
#define BASIC_MODE              0x02
#define DIP_SWITCH_2    ( 0x41 | FIXED_DISK_ON | MEMORY_SWITCH_HOLD | DISPLAY_LOW_25 | DISPLAY_COL_80 | BASIC_MODE )
#define HIRESO_CRT              0x08

#define MODE_SET_8255           0x92
#define RXRE                    0x00
#define TXEE                    0x02
#define TXRE                    0x04
#define SPEEKER                 0x06
#define MEMORY_CHECK            0x08
#define SHUT1                   0x0A
#define PSTB_MASK               0x0C
#define SHUT0                   0x0E

struct  sysporttag
{
        half_word       speeker;
        half_word       memorycheck;
        half_word       shut0;
        half_word       shut1;
        half_word       pstbmask;
};

struct  sysporttag      sysport;

half_word cal_register[48+1];
half_word cal_cmd_reg;
half_word cal_ex_cmd_reg;
half_word cal_ex_cmd_reg_tmp;
half_word cal_stb;
half_word cal_clk;
int cal_reg_no;
int cal_ex_cmd_cur_no;

#define STB_MASK 0x08
#define CLK_MASK 0x10
#define DI_MASK 0x20
#define CMD_MASK 0x07

#define EX_MODE                         7

#define EX_REGISTER_HOLD                0
#define EX_REGISTER_SHIFT               1
#define EX_TIMESET_COUNTER_HOLD         2
#define EX_TIME_READ                    3

extern GLOBAL UCHAR Configuration_Data[1192];
extern void com_inb(io_addr, half_word *);
extern void com_outb(io_addr, half_word *);
extern BOOL VDMForWOW;
extern VOID host_enable_timer2_sound();
extern VOID host_disable_timer2_sound();
extern void NEC98_in_port_35();
extern void NEC98_out_port_35();
extern void NEC98_out_port_37();
void sys_port_inb();
void sys_port_outb();
void cpu_port_inb();
void cpu_port_outb();

void call_com_inb IFN2(io_addr, port, half_word *, value)
{
    if(VDMForWOW)
        wow_com_inb(port, value);
    else
        com_inb(port, value);
}

void call_com_outb IFN2(io_addr, port, half_word, value)
{
    if(VDMForWOW)
        wow_com_outb(port, value);
    else
        com_outb(port, value);
}

void sys_port_init IFN0()
{
    io_define_inb(SYSTEM_PORT, sys_port_inb);
    io_define_outb(SYSTEM_PORT, sys_port_outb);

    io_connect_port(SYSTEM_READ_PORT_A, SYSTEM_PORT, IO_READ);
    io_connect_port(SYSTEM_READ_PORT_B, SYSTEM_PORT, IO_READ_WRITE);
    io_connect_port(SYSTEM_READ_PORT_C, SYSTEM_PORT, IO_READ_WRITE);
    io_connect_port(SYSTEM_WRITE_MODE, SYSTEM_PORT, IO_READ_WRITE);
}

void sys_port_post IFN0()
{
    sysport.speeker = 1;
    sysport.memorycheck = 0;
    sysport.shut0 = 0;
    sysport.shut1 = 0;
    sysport.pstbmask = 1;
}

void sys_port_inb IFN2(io_addr, port, half_word *, value)
{
    switch(port){
        case SYSTEM_READ_PORT_A:
            *value = DIP_SWITCH_2;
            if(!(Configuration_Data[40+BIOS_NEC98_PRXDUPD-0x400] & 0x20))
                *value |= GDC_2MHz;
            break;

        case SYSTEM_READ_PORT_B:
            call_com_inb(port, value);
            *value &= 0xE0;
            *value |= HIRESO_CRT;
            *value |= (cal_register[cal_reg_no/8] >> (cal_reg_no % 8)) & 1;
            break;

        case SYSTEM_READ_PORT_C:
            call_com_inb(port,value);
            NEC98_in_port_35(value);
            break;

        case SYSTEM_WRITE_MODE:
            com_inb(port,value);
            break;
    }
}

void sys_port_outb IFN2(io_addr, port, half_word, value)
{
    half_word   flag;
    half_word   command;

    switch(port){
        case SYSTEM_READ_PORT_B:
            call_com_outb(port, value);
            break;

        case SYSTEM_READ_PORT_C:
            call_com_outb(port, value);
            NEC98_out_port_35(value);
            break;

        case SYSTEM_WRITE_MODE:
            command = value & 0xFE;
            flag =  value & 0x01;

            switch(command){
                case MODE_SET_8255:
                    break;

                case RXRE:
                case TXRE:
                case TXEE:
                    call_com_outb(port, value);
                    break;

                case SPEEKER:
                    if(!flag) {
                        if(sysport.speeker)
                            host_enable_timer2_sound();
                    } else {
                        if(!sysport.speeker)
                            host_disable_timer2_sound();
                    }
                    sysport.speeker = flag;
                    break;

                case MEMORY_CHECK:
                    sysport.memorycheck = flag;
                    break;

                case SHUT1:
                    sysport.shut1 = flag;
                    break;

                case PSTB_MASK:
                    sysport.pstbmask = flag;
                    NEC98_out_port_37(value);
                    break;

                case SHUT0:
                    sysport.shut0 = flag;
                    break;

            }
            break;
    }
}

void cpu_port_init IFN0()
{
    io_define_inb(CPU_PORT, cpu_port_inb);
    io_define_outb(CPU_PORT, cpu_port_outb);

    io_connect_port(CPU_PORT_START + 0, CPU_PORT, IO_READ_WRITE);
    io_connect_port(CPU_PORT_START + 2, CPU_PORT, IO_WRITE);
    io_connect_port(CPU_PORT_START + 4, CPU_PORT, IO_READ_WRITE);
    io_connect_port(CPU_PORT_START + 6, CPU_PORT, IO_READ_WRITE);
}

void cpu_port_post IFN0()
{
}

void cpu_port_inb IFN2(io_addr, port, half_word *, value)
{
    switch(port){
        case 0xF0:
#ifndef PROD
            printf("NTVDM: This port is not implemented. port=%x\n",port);
#endif
            *value = 0xFF;
            break;
        case 0xF4:
#ifndef PROD
            printf("NTVDM: This port is not implemented. port=%x\n",port);
#endif
            *value = 0xFF;
            break;
        case 0xF6:
#ifndef PROD
            printf("NTVDM: This port is not implemented. port=%x\n",port);
#endif
            *value = 0xFF;
            break;
    }
}

void cpu_port_outb IFN2(io_addr, port, half_word, value)
{
    switch(port){
        case 0xF0:
#ifndef PROD
            printf("NTVDM: This port is not implemented. port=%x ", port);
            printf(" value=%x\n", value);
#endif
            break;
        case 0xF2:
#ifndef PROD
            printf("NTVDM: A20 line enable!!\n");
#endif
            if (sas_twenty_bit_wrapping_enabled())
                xmsDisableA20Wrapping();
            break;
        case 0xF4:
#ifndef PROD
            printf("NTVDM: This port is not implemented. port=%x ", port);
            printf(" value=%x\n", value);
#endif
            break;
        case 0xF6:
#ifndef PROD
            printf("NTVDM: This port is not implemented. port=%x ", port);
            printf(" value=%x\n", value);
#endif
            break;
    }
}

LOCAL word bin2bcd(word i)
{
    word        bcd_h,bcd_l;

    bcd_h = i / 10;
    bcd_l = i - bcd_h * 10;
    return((bcd_h << 4) + bcd_l);
}

void calender_load IFN0()
{
    SYSTEMTIME  now;
    cal_reg_no = 0;
    GetLocalTime(&now);
    cal_register[0] = bin2bcd(now.wSecond);
    cal_register[1] = bin2bcd(now.wMinute);
    cal_register[2] = bin2bcd(now.wHour);
    cal_register[3] = bin2bcd(now.wDay);
    cal_register[4] = bin2bcd((now.wMonth << 4) | now.wDayOfWeek);
    cal_register[5] = bin2bcd(now.wYear % 100);
}

void set_cal_command IFN0()
{
    switch(cal_cmd_reg) {
        case EX_MODE:
            cal_ex_cmd_reg = cal_ex_cmd_reg_tmp;
            switch(cal_ex_cmd_reg) {
                case EX_TIME_READ:
                    calender_load();
                    break;
                case EX_REGISTER_SHIFT:
                    break;
                default:
#ifndef PROD
                    printf("NTVDM: Illegal Calender mode!!\n");
#endif
                    break;
            }
            break;
        default:
#ifndef PROD
            printf("NTVDM: Illegal Calender mode!!\n");
#endif
            break;
    }
}

void calender_outb IFN2(io_addr, port, half_word, value)
{
    if(value & CLK_MASK) {
        if(cal_cmd_reg == EX_MODE && cal_ex_cmd_reg == EX_REGISTER_SHIFT && cal_reg_no < 48) {
            cal_reg_no++;
        } else {
            if(value & DI_MASK)
                cal_ex_cmd_reg_tmp |= (1 << cal_ex_cmd_cur_no++);
            else
                cal_ex_cmd_reg_tmp &= ~(1 << cal_ex_cmd_cur_no++);
            cal_ex_cmd_cur_no &= 3;
        }
    }
    else if(value & STB_MASK) {
        cal_cmd_reg = value & CMD_MASK;
        set_cal_command();
    }
}

void calender_init IFN0()
{
    io_define_outb(CALENDER_PORT, calender_outb);
    io_connect_port(CALENDAR_SET_REG, CALENDER_PORT, IO_WRITE);
}

void calender_post IFN0()
{
    int i;

    for(i=0;i<48;i++)
        cal_register[i] = 0;
    cal_cmd_reg = 0;
    cal_ex_cmd_reg = 0;
    cal_ex_cmd_reg_tmp = 0;
    cal_stb = 0;
    cal_clk = 0;
    cal_reg_no = 0;
    cal_ex_cmd_cur_no = 0;
}

#endif   //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\system\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=system
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc

SOURCES=..\at_dma.c      \
        ..\cmosnt.c      \
        ..\ica.c         \
        ..\idetect.c     \
        ..\illegalp.c    \
        ..\qevnt.c       \
        ..\rom.c         \
        ..\timer.c       \
        ..\timestrb.c    \
        ..\dummy_nt.c    \
        ..\system.c      \
        ..\unexp_nt.c

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\system\rom.c ===
#include "insignia.h"
#include "host_def.h"
/*
* SoftPC Revision 3.0
*
* Title	: ROM init functions
*
* Author	: Ade Brownlow	
*
* NB : These functions are used by BOTH the c and assembler cpus.
*		also note that host_read_resource now returns a long.
*
* SCCS ID:	@(#)rom.c	1.53 06/16/95
*
* (C) Copyright Insignia Solutions Ltd, 1994.
*/

#include <stdio.h>
#include <malloc.h>

#include TypesH
#include MemoryH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "sas.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "rom.h"
#include "debug.h"
#include "ckmalloc.h"
#include "yoda.h"
#include "gispsvga.h"

#ifdef	CPU_40_STYLE
#ifdef CCPU
#include "ccpusas4.h"
#else	/* ! CCPU */
#include "Cpu_c.h"
#endif	/* ! CCPU */
#endif	/* CPU_40_STYLE */

#if defined(NEC_98)

#ifndef BIOSNROM_FILENAME
#define BIOSNROM_FILENAME       "biosn.rom"
#endif /* BIOSNROM_FILENAME */

#ifndef BIOSNWROM_FILENAME
#define BIOSNWROM_FILENAME      "biosnw.rom"
#endif /* BIOSNWROM_FILENAME */

#ifndef RS232CEXROM_FILENAME
#define RS232CEXROM_FILENAME    "rs232cex.rom"
#endif
#else    //NEC_98

#ifndef BIOS1ROM_FILENAME
#define	BIOS1ROM_FILENAME	"bios1.rom"
#endif /* BIOS1ROM_FILENAME */

#ifndef BIOS2ROM_FILENAME
#if defined(CPU_40_STYLE) || defined(ARCX86)
#define	BIOS2ROM_FILENAME	"bios4.rom"
#else	/* CPU_40_STYLE */
#define	BIOS2ROM_FILENAME	"bios2.rom"
#endif	/* CPU_40_STYLE */
#endif /* BIOS2ROM_FILENAME */

#ifndef EGAROM_FILENAME
#define	EGAROM_FILENAME		"ega.rom"
#endif /* EGAROM_FILENAME */

#ifndef VGAROM_FILENAME
#define	VGAROM_FILENAME		"vga.rom"
#endif /* VGAROM_FILENAME */

#ifndef V7VGAROM_FILENAME
#define	V7VGAROM_FILENAME	"v7vga.rom"
#endif /* V7VGAROM_FILENAME */

#endif   //NEC_98

#ifdef 	GISP_SVGA
#define	GISP_VGAROM_FILENAME         "hwvga.rom"
#define	GISP_BIOS1ROM_FILENAME       "hwbios1.rom"
#define	GISP_BIOS2ROM_FILENAME       BIOS2ROM_FILENAME
#endif

#ifndef ADAPTOR_ROM_START
#define ADAPTOR_ROM_START	0xc8000
#endif	/* ADAPTOR_ROM_START */

#ifndef ADAPTOR_ROM_END
#define ADAPTOR_ROM_END		0xe0000
#endif	/* ADAPTOR_ROM_END */

#define ADAPTOR_ROM_INCREMENT	0x800

#ifndef EXPANSION_ROM_START
#define EXPANSION_ROM_START	0xe0000
#endif	/* EXPANSION_ROM_START */

#ifndef EXPANSION_ROM_END
#define EXPANSION_ROM_END	0xf0000
#endif	/* EXPANSION_ROM_END */

#define EXPANSION_ROM_INCREMENT	0x10000

#define	ROM_SIGNATURE		0xaa55

#if defined(NEC_98)
#define SIXTY_FOUR_K 1024*64
#define NINETY_SIX_K 1024*96
#endif   //NEC_98

/* Current SoftPC verion number */
#define MAJOR_VER	0x03
#define MINOR_VER	0x00

#if defined(macintosh) && defined(A2CPU)
	/* Buffer is temporarily allocted  - no bigger than needed. */
#define ROM_BUFFER_SIZE 1024*25
#else
	/* Using sas_scratch_buffer - will get 64K anyway. */
#define ROM_BUFFER_SIZE 1024*64
#endif

LOCAL LONG read_rom IPT2(char *, name, sys_addr, address);
LOCAL	half_word	do_rom_checksum IPT1(sys_addr, addr);

#ifdef ANSI
extern long host_read_resource (int, char *, host_addr, int ,int);
#else
extern long host_read_resource ();
#endif

extern void host_simulate();

#if defined(NEC_98)
VOID setup_memory_switch(VOID);
extern GLOBAL BOOL HIRESO_MODE;
extern sys_addr host_check_rs232cex();
extern BOOL video_emu_mode;
#endif   //NEC_98

/*(
 *=========================== patchCheckSum ================================
 * patchCheckSum
 *
 * Purpose
 *	This function calculates the check-sum for the indicated ROM,
 *	and patches it in at the indicated offset into the ROM.
 *
 *	It also checks that the ROM has the correct signature, and length,
 *	and rounds the size up to a multiple of 512 bytes.
 *
 *	Note this routine should not be called once paging is turned on.
 *
 * Input
 *	start	Physical address of start of ROM
 *	length	length of ROM in bytes
 *	offset	Checksum byte offset from start.
 *
 * Outputs
 *	None.
 *
 * Description
 *	We round the size-up to a multiple of 512 bytes, check the
 *	signature, then patch-in the checksum.
)*/

LOCAL void
patchCheckSum IFN3(PHY_ADDR, start, PHY_ADDR, length, PHY_ADDR, offset)
{
	PHY_ADDR roundedLength;
	IU16 signature;
	IU8 checksum;
	IU8 *buffer;
	PHY_ADDR currByte;
	PHY_ADDR indicatedLength;
	

	roundedLength = (length + 511) & (~511);
	sas_connect_memory(start, start + roundedLength - 1, SAS_RAM);

#ifndef PROD
	if (roundedLength != length) {
		always_trace3("ROM at 0x%.5lx length rounded up from 0x%.8lx to 0x%.8lx", start, length, roundedLength);
	}

	if (roundedLength > (128 * 1024)) {
		always_trace2("ROM at 0x%.5lx has a length of 0x%.8lx which is more than 128K", start, roundedLength);
		force_yoda();
		return;
	}

	if ((roundedLength <= offset) || (roundedLength < 4)) {
		always_trace1("ROM at 0x%.5lx is too short!", start);
		force_yoda();
		return;
	}
#endif

	signature = sas_PR16(start);
	if (signature != 0xaa55) {
		always_trace2("ROM at 0x%.5lx has an invalid signature 0x%.4x (should be aa55)", start, signature);
		sas_PW16(start, 0xaa55);
	}

	indicatedLength = sas_PR8(start + 2) * 512;
	if (indicatedLength != roundedLength) {
		always_trace3("ROM at 0x%.5lx has incorrect length 0x%.8lx (actually 0x%.8lx)", start, indicatedLength, roundedLength);
		sas_PW8(start + 2, (IU8)(roundedLength / 512));
	}


	check_malloc(buffer, roundedLength, IU8);

	sas_loads((LIN_ADDR)start, buffer, roundedLength);

	checksum = 0;
	for (currByte = 0; currByte < roundedLength; currByte++) {
		checksum += buffer[currByte];
	}
	host_free(buffer);

	if (checksum != 0) {
		always_trace2("ROM at 0x%.8lx has incorrect checksum 0x%.2x",
			start, checksum);
		sas_PW8(start + offset,
			(IU8)((IS8)sas_PR8(start + offset) - checksum));
	}
	sas_connect_memory(start, start + roundedLength - 1, SAS_ROM);

}


/*(
=============================== read_video_rom ============================
PURPOSE:	Load the appropriate video rom file.
INPUT:		None.
OUTPUT:		None.
===========================================================================
)*/
GLOBAL void read_video_rom IFN0()
{
#ifndef NEC_98
#ifdef REAL_VGA
	read_rom (VGAROM_FILENAME, EGA_ROM_START);
#else /* REAL_VGA */
	PHY_ADDR romLength = 0;

	switch ((ULONG) config_inquire(C_GFX_ADAPTER, NULL))
	{
#ifndef GISP_SVGA
#ifdef	VGG
	case VGA:
#ifdef V7VGA
		romLength = read_rom (V7VGAROM_FILENAME, EGA_ROM_START);
#else	/* V7VGA */
#ifdef ARCX86
        if (UseEmulationROM)
            romLength = read_rom (V7VGAROM_FILENAME, EGA_ROM_START);
        else
            romLength = read_rom (VGAROM_FILENAME, EGA_ROM_START);
#else  /* ARCX86 */
		romLength = read_rom (VGAROM_FILENAME, EGA_ROM_START);
#endif /* ARCX86 */
#endif  /* V7VGA */
		break;
#endif	/* VGG */

#ifdef	EGG
	case EGA:
		romLength = read_rom (EGAROM_FILENAME, EGA_ROM_START);
		break;
#endif	/* EGG */

	default:
		/* No rom required */
		break;

#else			/* GISP_SVGA */

	/* GISP_SVGA - only have the gisp vga roms or, none for CGA boot */
	case VGA:
		romLength = read_rom (GISP_VGAROM_FILENAME, EGA_ROM_START);
	default:
		break;

#endif		/* GISP_SVGA */	

	}

	if (romLength != 0)
	{
		/* There is a problem with emm386 and Windows start up, which
		 * is cured by setting the video bios rom internal length
		 * to 32Kb.
		 * Is seems that the V86 manager (or emm386) incorrectly
		 * maps C6000..C7FFF during initialisation.
		 * We round up the video ROM to 32Kb to avoid this problem,
		 * which reduces the amount of "upper memory" RAM available to
		 * dos extenders by 12K.
		 */
		if (romLength < (32*1024))
			romLength = (32*1024);
		patchCheckSum(EGA_ROM_START, romLength, 5);
	}
#endif	/* not REAL_VGA */
#endif   //NEC_98
}

GLOBAL void rom_init IFN0()
{
#if defined(NEC_98)
    sys_addr    rs232cex_rom_addr;

    sas_fills( ROM_START, BAD_OP, PC_MEM_SIZE - ROM_START);
//  if(HIRESO_MODE){
//      read_rom (BIOSHROM_FILENAME, BIOSH_START);
//      sas_connect_memory (BIOSH_START, 0xFFFFFL,SAS_ROM);
//  }else{
        rs232cex_rom_addr = host_check_rs232cex();
        if(rs232cex_rom_addr){
            read_rom (RS232CEXROM_FILENAME, rs232cex_rom_addr);
            sas_connect_memory (rs232cex_rom_addr, rs232cex_rom_addr + 0x4000, SAS_ROM);
        }
        if(!video_emu_mode)
            read_rom (BIOSNROM_FILENAME, BIOSN_START);
        else
            read_rom (BIOSNWROM_FILENAME, BIOSN_START);
        sas_connect_memory (BIOSN_START, 0xFFFFFL,SAS_ROM);
//  }
    setup_memory_switch();
#else    //NEC_98

#if !defined(NTVDM) || ( defined(NTVDM) && !defined(X86GFX) )
	 /*
     * Fill up all of ROM (Intel C0000 upwards) with bad op-codes.
     * This is the Expansion ROM and the BIOS ROM.
     * This will enable the CPU to trap any calls to ROM that are not made at a
     * valid entry point.
     */

#ifdef GISP_SVGA
	mapHostROMs( );
#else		/* GISP_SVGA */
#if	defined(macintosh) && defined(A2CPU)
	/* not macintosh 2.0 cpus - they have sparse M */
#else
	sas_fills( ROM_START, BAD_OP, PC_MEM_SIZE - ROM_START);
#endif		/* macintosh && A2CPU */
#endif		/* GISP_SVGA */

	/*
	 * emm386 needs a hole to put it's page frame in.
	 */
#if defined(SPC386) && !defined(GISP_CPU)
	sas_connect_memory(0xc0000, 0xfffff, SAS_ROM);
#endif

	/* Load the video rom. */
	read_video_rom();

	/* load the rom bios */
#ifdef GISP_SVGA
	if ((ULONG) config_inquire(C_GFX_ADAPTER, NULL) == CGA )
	{
		read_rom (BIOS1ROM_FILENAME, BIOS_START);
		read_rom (BIOS2ROM_FILENAME, BIOS2_START);
	}
	else
	{
		read_rom (GISP_BIOS1ROM_FILENAME, BIOS_START);
		read_rom (GISP_BIOS2ROM_FILENAME, BIOS2_START);
	}

#else		/* GISP_SVGA */

	read_rom (BIOS1ROM_FILENAME, BIOS_START);
	read_rom (BIOS2ROM_FILENAME, BIOS2_START);

#endif		/* GISP_SVGA */

#else	/* !NTVDM | (NTVDM & !X86GFX) */

#ifdef ARCX86
    if (UseEmulationROM) {
        sas_fills( EGA_ROM_START, BAD_OP, 0x8000);
        sas_fills( BIOS_START, BAD_OP, PC_MEM_SIZE - BIOS_START);
        read_video_rom();
        read_rom (BIOS1ROM_FILENAME, BIOS_START);
        read_rom (BIOS2ROM_FILENAME, BIOS2_START);
    } else {
        sas_connect_memory (BIOS_START, 0xFFFFFL, SAS_ROM);
    }
#else  /* ARCX86 */
	/*
	 * Now tell the CPU what it's not allowed to write over...
	 *
	 * These used to be done for everyone, but now they're only done for NT
	 * as everyone else should have done it inside read_rom.
	 */
	sas_connect_memory (BIOS_START, 0xFFFFFL, SAS_ROM);
#endif /* ARCX86 */

#ifdef EGG
	sas_connect_memory (EGA_ROM_START, EGA_ROM_END-1, SAS_ROM);
#endif
#endif /* !NTVDM | (NTVDM & !X86GFX) */

	host_rom_init();
#endif   //NEC_98
}

LOCAL LONG read_rom IFN2(char *, name, sys_addr, address)
{
#if defined(NEC_98)
    host_addr tmp;
    long size = 0;
    if(HIRESO_MODE) {
       if (!(tmp = (host_addr)sas_scratch_address(SIXTY_FOUR_K)))
       {
           host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, NULL);
           return(0);
       }
       if (size = host_read_resource(ROMS_REZ_ID, name, tmp, SIXTY_FOUR_K, TRUE))
       {
           sas_connect_memory( address, address+size, SAS_RAM);
           sas_stores (address, tmp, size);
           sas_connect_memory( address, address+size, SAS_ROM);
       }
    } else {
       if (!(tmp = (host_addr)sas_scratch_address(NINETY_SIX_K)))
       {
           host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, NULL);
           return(0);
       }
       if (size = host_read_resource(ROMS_REZ_ID, name, tmp, NINETY_SIX_K, TRUE))
       {
           sas_connect_memory( address, address+size, SAS_RAM);
           sas_stores (address, tmp, size);
           sas_connect_memory( address, address+size, SAS_ROM);
       }
    }
   return( size );
#else    //NEC_98

#if !(defined(NTVDM) && defined(MONITOR))
	host_addr tmp;
	long size = 0;

    /* do a rom load - use the sas_io buffer to get it the right way round 	*/
    /* BIOS rom first. 														*/
	/* Mac on 2.0 cpu doesn't want to use sas scratch buffer. 				*/
#if defined(macintosh) && defined(A2CPU)
    tmp = (host_addr)host_malloc(ROM_BUFFER_SIZE);
#else
	tmp = (host_addr)sas_scratch_address(ROM_BUFFER_SIZE);
#endif

    if (!tmp)
    {
	host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, NULL);
	return(0);
    }
    if (size = host_read_resource(ROMS_REZ_ID, name, tmp, ROM_BUFFER_SIZE, TRUE))
    {
	sas_connect_memory( address, address+size, SAS_RAM);
        sas_stores (address, tmp, size);
	sas_connect_memory( address, address+size, SAS_ROM);
    }

#if defined(macintosh) && defined(A2CPU)
	host_free((char *)tmp);
#endif

    return( size );
#else

#ifdef ARCX86
    if (UseEmulationROM) {
        host_addr tmp;
        long size = 0;

        tmp = (host_addr)sas_scratch_address(ROM_BUFFER_SIZE);
        if (!tmp)
        {
            host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, NULL);
            return(0);
        }
        if (size = host_read_resource(ROMS_REZ_ID, name, tmp, ROM_BUFFER_SIZE, TRUE))
        {
            sas_connect_memory( address, address+size, SAS_RAM);
            sas_stores (address, tmp, size);
            sas_connect_memory( address, address+size, SAS_ROM);
        }
        return( size );
    } else {
        return ( 0L );
    }
#else  /* ARCX86 */
    return ( 0L );
#endif /* ARCX86 */

#endif	/* !(NTVDM && MONITOR) */
#endif   //NEC_98
}

#if defined(NEC_98)

static byte memory_sw_n[32] = {0xE1,0x00,0x48,0x00,0xE1,0x00,0x05,0x00,
                               0xE1,0x00,0x04,0x00,0xE1,0x00,0x00,0x00,
                               0xE1,0x00,0x01,0x00,0xE1,0x00,0x00,0x00,
                               0xE1,0x00,0x00,0x00,0xE1,0x00,0x93,0x00};
static byte memory_sw_h[32] = {0xE1,0x00,0x48,0x00,0xE1,0x00,0x05,0x00,
                               0xE1,0x00,0x05,0x00,0xE1,0x00,0x00,0x00,
                               0xE1,0x00,0x41,0x00,0xE1,0x00,0x00,0x00,
                               0xE1,0x00,0x00,0x00,0xE1,0x00,0x92,0x00};

VOID setup_memory_switch(VOID)
{
        int i;

        if(HIRESO_MODE){
           for (i=0;i<32;i++)
           {
           sas_PW8((MEMORY_SWITCH_START_H+i),memory_sw_h[i]);
           }
        } else {
           for (i=0;i<32;i++)
           {
           sas_PW8((MEMORY_SWITCH_START_N+i),memory_sw_n[i]);
           }
        }
}
#endif   //NEC_98

LOCAL	half_word	do_rom_checksum IFN1(sys_addr, addr)
{
	LONG	sum = 0;
	sys_addr	last_byte_addr;

	last_byte_addr = addr + (sas_hw_at(addr+2)*512);

	for (; addr<last_byte_addr; addr++)
		sum += sas_hw_at(addr);

	return( (half_word)(sum % 0x100) );
}

LOCAL	VOID	do_search_for_roms IFN3(sys_addr, start_addr,
	sys_addr, end_addr, unsigned long, increment)
{
	word	signature;
	half_word	checksum;
	sys_addr	addr;
	word		savedCS;
	word		savedIP;

	for ( addr = start_addr; addr < end_addr; addr += increment )
	{
		if ((signature = sas_w_at(addr)) == ROM_SIGNATURE)
		{
			if ((checksum = do_rom_checksum(addr)) == 0)
			{
			/*
				Now point at address of init code.
			*/
				addr += 3;
			/*
				Fake a CALLF by pushing a return CS:IP.
				This points at a BOP FE in the bios to
				get us back into 'c'
			*/
				push_word( 0xfe00 );
				push_word( 0x95a );
				savedCS = getCS();
				savedIP = getIP();
				setCS((UCHAR)((addr & 0xf0000) >> 4));
				setIP((USHORT)((addr & 0xffff)));
				host_simulate();
				setCS(savedCS);
				setIP(savedIP);
				assert1(NO, "Additional ROM located and initialised at 0x%x ", addr-3);
			}
			else
			{
				assert2(NO, "Bad additonal ROM located at 0x%x, checksum = 0x%x\n", addr, checksum);
			}
		}
	}
}

GLOBAL void search_for_roms IFN0()
{
#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX))
#ifndef GISP_SVGA
/*
        First search for adaptor ROM modules
*/
    do_search_for_roms(ADAPTOR_ROM_START,
                                ADAPTOR_ROM_END, ADAPTOR_ROM_INCREMENT);

/*
        Now search for expansion ROM modules
*/
    do_search_for_roms(EXPANSION_ROM_START,
                                EXPANSION_ROM_END, EXPANSION_ROM_INCREMENT);
#endif 		/* GISP_SVGA */
#endif	/* !NTVDM | (NTVDM & !X86GFX) */
}


GLOBAL void rom_checksum IFN0()
{
#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )
	patchCheckSum(BIOS_START, PC_MEM_SIZE - BIOS_START,
				0xfffff - BIOS_START);
#endif	/* !NTVDM | (NTVDM & !X86GFX) */
}

GLOBAL VOID patch_rom IFN2(sys_addr, addr, half_word, val)
{
#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )
	UTINY	old_val;

	/*
	 * 4.0 style CPUs don't export this variable, and if sas hasn't been
	 * inited, then the sas_connect will drop out to yoda.
	 */

#ifdef CPU_40_STYLE

	IU8	*hostPtr;

	/* TMM 14/2/95
	 * -----------
	 * What we are doing here is replacing the sas_connect() method of writing to ROM
	 * with the new approach of poking the values directly in there. See display_string()
	 * below for a more detiled discussion of the why's and wherefores.
	 */

#ifdef macintosh

	/* The Mac config system wants to call this routine before the
	 * CPU exists, so we'd better invent a Mac-specific IBOOL to
	 * make the symptom non-fatal - finding and fixing the cause
	 * is too hard.
	 */
	{
		extern IBOOL SafeToCallSas;

		if (!SafeToCallSas)
			return;	
	}

#endif /* macintosh */

	/* The page might not be present (Arrggghhhh!!!!!)
	** so we can't do anything sensible and must give
	** up. We print an error though.
	*/
	hostPtr = getPtrToPhysAddrByte (addr);
	if (hostPtr == 0)
	{
		host_error(EG_OWNUP, ERR_QUIT, NULL);
		return;
	}

	old_val = *hostPtr;

	/* Optimisation - don't upset the world if the value is unchanged.
	 */
	if (old_val == val)
		return;

	*hostPtr = val;

/*
 *	Adjust the checksum value by new - old.
 *	val is now difference between new and old value.
 *	We don't do this for GISP_SVGA because the checksums are already
 *	screwed, and attempting to write to the real host system ROM would
 *	only make things worse!
 */

#ifndef GISP_SVGA
	/* Now get the checksum at the end of the ROM */
	hostPtr = getPtrToPhysAddrByte (0xFFFFFL);
	if (hostPtr == 0)
	{
		host_error(EG_OWNUP, ERR_QUIT, NULL);
		return;
	}
	
	/* Now set the checksum to the difference between the old and new values */
	*hostPtr -= (val - old_val);
	
#endif /* GISP_SVGA */

#else	/* CPU_40_STYLE */

	/*
	 * 4.0 style CPUs don't export this variable, and if sas hasn't been
	 * inited, then the sas_connect will drop out to yoda.
	 */

	if (Length_of_M_area == 0)
		return;

	old_val = sas_hw_at( addr );

	/* Optimisation - don't upset the world if the value is unchanged.
	 */
	if (old_val == val)
		return;

	sas_connect_memory (addr, addr, SAS_RAM);
	sas_store (addr,val);
	sas_connect_memory (addr, addr, SAS_ROM);
/*
 *	Adjust the checksum value by new - old.
 *	val is now difference between new and old value.
 *	We don't do this for GISP_SVGA because the checksums are already
 *	screwed, and attempting to write to the real host system ROM would
 *	only make things worse!
 */

#ifndef GISP_SVGA
	val -= old_val;
	old_val = sas_hw_at( 0xFFFFFL );

	old_val -= val;
	sas_connect_memory (0xFFFFFL, 0xFFFFFL, SAS_RAM);
	sas_store (0xFFFFFL, old_val);
	sas_connect_memory (0xFFFFFL, 0xFFFFFL, SAS_ROM);
#endif /* GISP_SVGA */

#endif	/* CPU_40_STYLE */

#endif	/* !NTVDM | (NTVDM & !X86GFX) */
}

#ifndef GISP_SVGA

/*
 * These routines were used by 2.0 CPUs which performed
 * post-write checks. Since all 3.0 and later CPUs do
 * pre-write checks they're no longer needed.
 */

#if !(defined(NTVDM) & defined(MONITOR))
void update_romcopy IFN1(long, addr)
{
	UNUSED( addr );
}
#endif

GLOBAL void copyROM IFN0()
{
}

#endif		/* GISP_SVGA */

/*
 * To enable our drivers to output messages generated from
 * our bops we use a scratch area inside our rom.
 */
#ifndef GISP_SVGA
LOCAL sys_addr  cur_loc = DOS_SCRATCH_PAD;
#else		/* GISP_SVGA */
/* For GISP svga builds, we initialise from gispROMInit() */
sys_addr  cur_loc;
#endif		/* GISP_SVGA */

GLOBAL void display_string IFN1(char *, string_ptr)
{
#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) ) || defined(ARCX86)
#ifdef ARCX86
  if (UseEmulationROM)
#endif
  {
	/*
	 * Put the message "*string_ptr" in the ROM
	 * scratch area where the drivers know where
	 * to output it from.
	 */

#ifdef CPU_40_STYLE

	IU8	*hostPtr;
	IU16	count;
	IU32	endLinAddr;

	/* In a paging environment, we must be careful as a
	** the ROM area could have been copied and/or mapped
	** as read only. We must alter the memory which is
	** currently at the linear address of the ROM (whether
	** that is actually our rom or a RAM copy of it). We
	** must force this alteration despite any protection
	** placed on the page by the Intel page tables.
	*/

	/* get a host pointer to the memory behind the required
	** linear address.
	*/
	hostPtr = getPtrToLinAddrByte(cur_loc);

	/* The page might not be present (Arrggghhhh!!!!!)
	** so we can't do anything sensible and must give
	** up. We print an error though.
	*/
	if (hostPtr == 0)
	{
		host_error(EG_OWNUP, ERR_QUIT, NULL);
		return;
	}

	/* the area to be patched must lie entirely in one intel page for
	** this method to be sure to work. So check it.
	*/
	endLinAddr = (cur_loc + strlen(string_ptr) + 2);
	if (((endLinAddr ^ DOS_SCRATCH_PAD) > 0xfff) || (endLinAddr > DOS_SCRATCH_PAD_END))
	{
#ifndef PROD
		fprintf(trace_file, "*** Warning ***: patch string into ROM too long; tuncating string '%s'", string_ptr);
#endif
		if ((DOS_SCRATCH_PAD_END ^ DOS_SCRATCH_PAD) > 0xfff)
		{
			/* The defined DOS scratch pad crosses a page
			** boundary. must truncate to the page boundary,
			** allowing for the '$' and terminating zero
			*/
			string_ptr[0xffd - (DOS_SCRATCH_PAD & 0xfff)] = '\0';
		}
		else
		{
			/* The string overflows the DOS scratch pad. We
			** must truncate to the scrtach pad boundary,
			** allowing for the '$' and terminating zero
			*/
			string_ptr[cur_loc - DOS_SCRATCH_PAD - 2] = '\0';
		}
	}
	for (count = 0; count < strlen(string_ptr); count++)
	{
		*IncCpuPtrLS8(hostPtr) = string_ptr[count];
	}
	/* Terminate the string */
	*IncCpuPtrLS8(hostPtr) = '$';
	*IncCpuPtrLS8(hostPtr) = '\0';
#else /* CPU_40_STYLE */
	sas_connect_memory(DOS_SCRATCH_PAD, DOS_SCRATCH_PAD_END, SAS_RAM);
	sas_stores(cur_loc, (host_addr)string_ptr, strlen(string_ptr));
	cur_loc += strlen(string_ptr);

	/* Terminate the string */
	sas_store(cur_loc, '$');
	sas_store(cur_loc + 1, '\0');
	sas_disconnect_memory(DOS_SCRATCH_PAD, DOS_SCRATCH_PAD_END);
	cur_loc -= strlen(string_ptr);
#endif /* CPU_40_STYLE */
  }
#endif	/* !NTVDM | !MONITOR | ARCX86 */
	cur_loc+=strlen(string_ptr);
}

GLOBAL void clear_string IFN0()
{
        cur_loc = DOS_SCRATCH_PAD;  /* Need to reset this pointer to start of **
                                    ** scratch area to prevent messages being **
                                    ** repeatedly displayed.                  */
	display_string ("");
}

/* Returns the SoftPC version to our device drivers */

GLOBAL void softpc_version IFN0()
{
	setAH(MAJOR_VER);
	setAL(MINOR_VER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\system\unexp_nt.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Version 2.0
 *
 * Title	: Unexpected interrupt routine
 *
 * Description	: This function is called for those interrupt vectors
 *		  which should not occur.
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)unexp_int.c	1.8 06/15/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_ERROR.seg"
#endif


/*
 *    O/S include files.
 */
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "bios.h"
#include "ica.h"
#include "ios.h"
#include "sas.h"
#include "debug.h"

#define INTR_FLAG 0x6b
#define EOI 0x20

void unexpected_int()
{
   half_word m_isr, m_imr, s_isr, s_imr;

   /* Read ica registers to determine interrupt reason */

   outb(ICA0_PORT_0, 0x0b);
   inb(ICA0_PORT_0, &m_isr);

   /* HW or SW ? */

   if ( m_isr == 0 )
      {
      /* Non hardware interrupt(= software) */
      m_isr = 0xFF;
      always_trace0("Non hardware interrupt(= software)");
      }
   else
      {
      /* Hardware interrupt */
      inb(ICA0_PORT_1, &m_imr);
      if ((m_imr & 0xfb) != 0)
	always_trace1("hardware interrupt master isr %02x", m_isr);
      m_imr |= m_isr;
      m_imr &= 0xfb;	/* avoid masking line 2 as it's the other ica */

      /* check second ICA too */
      outb(ICA1_PORT_0, 0x0b);
      inb(ICA1_PORT_0, &s_isr);
      if (s_isr != 0)	/* ie hardware int on second ica */
	{
	  always_trace1("hardware interrupt slave isr %02x", s_isr);
          inb(ICA1_PORT_1, &s_imr);	/* get interrupt mask */
	  s_imr |= s_isr;		/* add the one that wasn't expected */
          outb(ICA1_PORT_1, s_imr);	/* and mask out */
          outb(ICA1_PORT_0, EOI);
	}

      /* now wind down main ica */
      outb(ICA0_PORT_1, m_imr);
      outb(ICA0_PORT_0, EOI);
      }

   /* Set Bios data area up with interrupt cause */
   sas_store(BIOS_VAR_START + INTR_FLAG, m_isr);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\cg.c ===
#if defined(NEC_98)
#include "insignia.h"
#include "host_def.h"
#include "xt.h"
#include "ios.h"
#include "debug.h"
#include "cg.h"

extern unsigned short cg_font_load ();
extern void mapping_init();
extern void host_sleep();
extern BOOL cg_lock;
void cg_write_2nd IPT1(half_word,value);
void cg_write_1st IPT1(half_word,value);
void cg_write_count IPT1(half_word,value);
void cg_write_pattern IPT1(half_word,value);
void cg_read_pattern IPT1(half_word *,value);
CG_GLOBS cgglobs;

BOOL half_access;

void cg_write_2nd IFN1(half_word,value) {
        unsigned short  src,dst;
//      if ((value == 0) || ((value >= 0x21) && (value <= 0x7E))) {
                src = (unsigned short) value;
                dst = cgglobs.code;
                cgglobs.code = src |(dst & 0xFF00);
                cg_font_load(cgglobs.code,(unsigned char *) NULL);
//      }
}

void cg_write_1st IFN1(half_word,value) {
        unsigned short  src,dst;
        src = (unsigned short) value;
        dst = cgglobs.code;
        cgglobs.code = (src << 8) | (dst & 0x00FF);
        cg_font_load(cgglobs.code,(unsigned char *) NULL);
}

void cg_write_count IFN1(half_word,value) {
        cgglobs.counter = value;
        if (half_access && !((cgglobs.code & 0x00FF) == 0))
                cg_font_load(cgglobs.code,(unsigned char *) NULL);
}

void cg_write_pattern IFN1(half_word,value) {
        unsigned short count_pos;
        count_pos = ((cgglobs.counter & 0x0F)<<1);
        if (cgglobs.counter & 0x20) {
                cgglobs.cgwindow_ptr[count_pos+33] = value;
        } else {
                cgglobs.cgwindow_ptr[count_pos+1] = value;
        }
}

void cg_read_pattern IFN1(half_word *,value) {
        unsigned short count_pos;
        count_pos = ((cgglobs.counter & 0x0F)<<1);
        if (half_access) {
                if (cgglobs.counter & 0x20) {
                        *value = cgglobs.cgwindow_ptr[count_pos+33];
                } else {
                        *value = cgglobs.cgwindow_ptr[count_pos+1];
                }
        } else {
                if (cgglobs.counter & 0x20) {
                        *value = cgglobs.cgwindow_ptr[count_pos+32];
                } else {
                        *value = cgglobs.cgwindow_ptr[count_pos+1];
                }
        }
}

GLOBAL void cg_inb IFN2(io_addr, port, half_word *, value) {
        switch(port) {
                case CG_READ_PATTERN:
                        cg_read_pattern(value);
                        break;
                default:
                        assert1(FALSE,"NEC98:Illegal Port %#x",port);
        }
}

GLOBAL void cg_outb IFN2(io_addr, port, half_word *, value) {

        while(cg_lock)
                host_sleep(10);
        cg_lock = TRUE;

        switch(port) {
                case CG_WRITE_SECOND:
                        cg_write_2nd(value);
                        break;
                case CG_WRITE_FIRST:
                        cg_write_1st(value);
                        break;
                case CG_WRITE_COUNTER:
                        cg_write_count(value);
                        break;
                case CG_WRITE_PATTERN:
                        cg_write_pattern(value);
                        break;
                default:
                        assert1(FALSE,"NEC98:Illegal Port %#x",port);
        }
        cg_lock = FALSE;
}

GLOBAL void cg_init IFN0() {
    io_define_inb(CG_ADAPTOR,cg_inb);
    io_define_outb(CG_ADAPTOR,cg_outb);
        io_connect_port(CG_WRITE_SECOND,CG_ADAPTOR,IO_WRITE);
        io_connect_port(CG_WRITE_FIRST,CG_ADAPTOR,IO_WRITE);
    io_connect_port(CG_WRITE_COUNTER,CG_ADAPTOR, IO_WRITE);
        io_connect_port(CG_WRITE_PATTERN,CG_ADAPTOR,IO_READ_WRITE);
        cgglobs.cgwindow_ptr = CG_WINDOW_OFF;
        mapping_init();
}

GLOBAL void cg_post IFN0() {
        cg_outb(CG_WRITE_SECOND,0x00);
        cg_outb(CG_WRITE_FIRST,0xFF);
        cg_outb(CG_WRITE_COUNTER,0x00);
}

#endif   //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\system\timestrb.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Version 3.0
 *
 * Title	: Time Strobe
 *
 * Description	: This is the central base routine that is called from the
 *		  host alarm (approx 20 times a second). It replaces the 
 *		  previous time_tick() routine in the timer module which now
 *		  is called from this module's timer_strobe() and just deals
 *		  with the periodic updates required for the timer.
 *
 * Author	: Leigh Dworkin
 *
 * Notes	 :
 * 		  Code has been added to time_tick() to spot
 *                that video has been disabled for a period. If this is
 *                so, clear the screen. Refresh when video is enabled
 *                again.
 *                Modified 21/6/89 by J.D.R. to allow another alarm call
 *                to be made. This is used by the autoflush mechanism.
 *
 */

/*
 * static char SccsID[]="@(#)timestrobe.c	1.12 11/01/94 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_SUPPORT.seg"
#endif


/*
 *    O/S include files.
 */

/*
 * SoftPC include files
 */
#include "xt.h"
#include "cmos.h"
#include "timer.h"
#include "tmstrobe.h"
#include "gmi.h"
#include "gfx_upd.h"
#include "host_qev.h"

#ifdef HUNTER
#include <stdio.h>
#include "hunter.h"
#endif

#include "host_gfx.h"

static void dummy_alarm()
{
}

/**************************************************************************************/
/*                                 External Functions                                  */
/**************************************************************************************/
void time_strobe()
{

#define VIDEO_COUNT_LIMIT    19    /* One second, plus a bit */
    static   int       video_count = 0;
    static   boolean   video_off   = FALSE;

#if !defined(REAL_TIMER) && !defined(NTVDM)
	time_tick();
#endif

#ifdef HUNTER
        do_hunter();
#endif    


#ifndef NTVDM
#ifndef	REAL_TIMER
	/* Update the real time clock */
#ifndef NEC_98
        rtc_tick();
#endif   //NEC_98
#endif	/* REAL_TIMER */

        dispatch_tic_event();

#if defined(CPU_40_STYLE)
	ica_check_stale_iret_hook();
#endif
#endif

        /*
         * Check to see if the screen is currently enabled.
         */
        if (timer_video_enabled) {
            if (video_off) {
                screen_refresh_required();
                video_off = FALSE;
            }
            video_count = 0;
        }
        else {
            video_count++;
            if (video_count == VIDEO_COUNT_LIMIT) {
                host_clear_screen();
                video_off = TRUE;
            }
        }
#ifdef	EGA_DUMP
	dump_tick();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\system\quick_ev.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 2.0
 *
 * Title	:	Quick event dispatcher
 *
 * Desription	:	This module contains those function calls necessary to
 *			interface to the quick event dispatcher
 *
 *                      Public functions:
 *                      q_event_init()	: initialise conditions
 *                      add_q_event_i()	: do an event after a given number of
 *					  instructions
 *			add_q_event_t()	: do an event after a given number of
 *					  microseconds
 *			delete_q_event(): delete an entry from the event queue
 *
 * Author	:	WTG Charnell
 *
 * Notes	:
 *
 *	This is what I (Mike) think happens in this module (before
 *	CPU_40_STYLE).
 * 
 *	This module handles two types of events - quick events, and tick events
 *	which are similar in most ways.  The module contains functions to
 *	add events, delete events and dispatch events (action them) for both
 *	types.  The only significant difference (apart from the fact that
 *	they're held in different (but similar) data structures, is that
 *	the quick event dispatch function is called from the CPU when the
 *	next quick event must be dispatched, while the tic event dispatch
 *	function is called on every timer tick, and only causes dispatch
 *	of an event when enough calls have taken place to reach the next event.
 *
 *	The impression the module gives is that tic events were added as an
 *	after thought...
 *
 *	The most important data structure is the Q_EVENT structure, from
 *	which most other structures are built.  This has the following
 *	elements:-
 *
 *	func	-	the action function to be called when the event goes
 *			off.
 *	time_from_last	Contains the delta time from the previous entry
 *			in the time ordered chain of events (see below).
 *	handle	-	Unique handle to identify an event.
 *	param	-	Paramter passed to the action function when it's
 *			called.
 *	next,previous - pointers for a time ordered list of events.
 *	next_free -	Dual purpose - link free structures together, or
 *			form a hash chain for a table hashed on handle.
 *
 *	q_list_head & q_list_tail (and their equivalents tic_list_head & 
 *	tic_list_tail) are used to keep a time-ordered dual linked list
 *	(yes, you guessed it, it was written by wtgc) of events.
 */
 
#ifdef SCCSID
LOCAL char SccsID[]="@(#)quick_ev.c	1.43 07/04/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_QUICKEV.seg"
#endif

/*
** Normal UNIX includes
*/
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include TypesH
#include MemoryH

/*
** SoftPC includes
*/
#include "xt.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "debug.h"
#include "timer.h"

#ifdef SFELLOW
#include "malloc.h"
#else
/* for host_malloc & host_free */
#include "host_hfx.h" 
#endif	/* SFELLOW */

#include "quick_ev.h"

#if defined(CPU_40_STYLE) && !defined (SFELLOW)
#include "timestmp.h"	/* for timestamp definitions */
#endif

#ifdef NTVDM
#include "ica.h"
#endif


#define HASH_SIZE	16
#define HASH_MASK	0xf

#ifdef CPU_40_STYLE
/* defines for calibration mechanism */
#define Q_RATIO_HISTORY_SHIFT	3	/* power of two selection */
#define Q_RATIO_HISTORY_SIZE	(1 << Q_RATIO_HISTORY_SHIFT)	/* corresponding size */
#define Q_RATIO_WRAP_MASK	(Q_RATIO_HISTORY_SIZE - 1)
#define Q_RATIO_DEFAULT	1
#endif	/* CPU_40_STYLE */

typedef enum { EVENT_TIME, EVENT_INSTRUCTIONS, EVENT_TICK } EVENTTYPE;

/*
 *	Structure for event list elements
 */

struct Q_EVENT
{
	void	(* func)();
	unsigned long	time_from_last;
	unsigned long	original_time;
	q_ev_handle	handle;
	long	param;
	EVENTTYPE event_type;
	struct Q_EVENT *next;
	struct Q_EVENT *previous;
	struct Q_EVENT *next_free;
};

typedef struct Q_EVENT t_q_event;
typedef t_q_event *TQ_TABLE[];

typedef void (*VOID_FUNC)();
typedef ULONG (*ULONG_FUNC)();

/*
** our static vars.
*/
#if defined(CPU_40_STYLE) && !defined(SFELLOW)
LOCAL struct {
	IU32 jc_ms;
	IU32 time_ms;
} q_ratio_history[Q_RATIO_HISTORY_SIZE];
LOCAL IUM32 q_ratio_head = 0L;
LOCAL IBOOL q_ratio_initialised = FALSE;
LOCAL QTIMESTAMP previous_tstamp;
LOCAL IU32 ideal_q_rate = 1, real_q_rate = 1;
#endif	/* CPU_40_STYLE && !SFELLOW */

LOCAL t_q_event *q_free_list_head = NULL;
LOCAL t_q_event *q_list_head = NULL;
LOCAL t_q_event *q_list_tail = NULL;

LOCAL t_q_event *q_ev_hash_table[HASH_SIZE];
LOCAL q_ev_handle next_free_handle = 1;

/*
	Separate list for events on timer ticks
*/
#if defined(SFELLOW)
/*
 * a single, shared free list (both tic and quick events
 * use the same structs)
 */
#define	tic_free_list_head	q_free_list_head
#else
LOCAL t_q_event *tic_free_list_head = NULL;
#endif	/* SFELLOW */
LOCAL t_q_event *tic_list_head = NULL;
LOCAL t_q_event *tic_list_tail = NULL;

LOCAL t_q_event *tic_ev_hash_table[HASH_SIZE];
LOCAL q_ev_handle tic_next_free_handle = 1;
LOCAL ULONG tic_event_count = 0;

#if defined(CPU_40_STYLE) && !defined(SFELLOW)
LOCAL void init_q_ratio IPT0();
LOCAL void add_new_q_ratio IPT2(IU32, jumps_ms, IU32, time_ms);
LOCAL void q_weighted_ratio IPT2(IU32 *, mant, IU32 *, divis);
void quick_tick_recalibrate IPT0();

#else
#define	init_q_ratio()
#endif	/* CPU_40_STYLE && !SFELLOW */

LOCAL ULONG calc_q_ev_time_for_inst IPT1(ULONG, inst);

LOCAL q_ev_handle gen_add_q_event IPT4(Q_CALLBACK_FN, func, unsigned long, time, long, param, EVENTTYPE, event_type);

/*
 * Global vars
 */
#if defined(CPU_40_STYLE) && !defined(SFELLOW)
GLOBAL IBOOL DisableQuickTickRecal = FALSE;
#endif


#if defined NTVDM && !defined MONITOR
/*  NTVDM
 *
 *  The Timer hardware emulation for NT is multithreaded
 *  So we use the ica critsect to synchronize access to the following
 *  quick event functions:
 *
 *   q_event_init()
 *   add_q_event_i()
 *   add_q_event_t()
 *   delete_q_event()
 *   dispatch_q_event()
 *
 *  tic events are not affected
 *  On x86 platforms (MONITOR) the quick event mechanism
 *  is to call the func directly so synchronization is not needed.
 *
 */

#endif


/*
 *	initialise linked list etc
 */

#ifdef ANSI
LOCAL void  q_event_init_structs(t_q_event **head, t_q_event **tail,
				 t_q_event **free_ptr, t_q_event *table[],
				 q_ev_handle *free_handle)
#else
LOCAL void  q_event_init_structs(head, tail, free_ptr, table, free_handle)
t_q_event **head;
t_q_event **tail;
t_q_event **free_ptr;
t_q_event *table[];
q_ev_handle *free_handle;
#endif	/* ANSI */
{
	int i;
	t_q_event *ptr;

	while (*head != NULL) {
		ptr = *head;
		*head = (*head)->next;
#ifdef SFELLOW
		ptr->next_free = *free_ptr;
		*free_ptr = ptr;
	}
	*head = *tail = NULL;
#else	/* SFELLOW */
		host_free(ptr);
	}
	while (*free_ptr != NULL) {
		ptr = *free_ptr;
		*free_ptr = (*free_ptr)->next_free;
		host_free(ptr);
	}
	*head = *tail = *free_ptr=NULL;
#endif	/* SFELLOW */

	*free_handle = 1;
	for (i = 0; i < HASH_SIZE; i++){
		table[i] = NULL;
	}
}

LOCAL t_q_event* makeSomeFreeEvents IPT0()
{
	t_q_event *nptr;
#ifdef SFELLOW
	IUH	count;

	nptr = SFMalloc(4096,TRUE);
	for (count=0; count< (4096/sizeof(t_q_event)); count++)
	{
		nptr->next_free = q_free_list_head;
		q_free_list_head = nptr;
		nptr++;
	}
	nptr = q_free_list_head;
	q_free_list_head = nptr->next_free;
#else
	nptr = (t_q_event *)host_malloc(sizeof(t_q_event));
#endif
	return nptr;
}

VOID q_event_init IFN0()
{
	
#if defined NTVDM && !defined MONITOR
     host_ica_lock();
#endif


	host_q_ev_set_count(0);
	q_event_init_structs(&q_list_head, &q_list_tail, &q_free_list_head, 
		q_ev_hash_table, &next_free_handle);
	sure_sub_note_trace0(Q_EVENT_VERBOSE,"q_event_init called");

	init_q_ratio();

#if defined NTVDM && !defined MONITOR
     host_ica_unlock();
#endif
}

LOCAL VOID
tic_ev_set_count IFN1(ULONG, x )
{
	tic_event_count = x;
}

LOCAL ULONG
tic_ev_get_count IFN0()
{
	return(tic_event_count);
}

VOID tic_event_init IFN0()
{
	tic_ev_set_count(0);
	q_event_init_structs(&tic_list_head, &tic_list_tail, &tic_free_list_head, 
		tic_ev_hash_table, &tic_next_free_handle);
	sure_sub_note_trace0(Q_EVENT_VERBOSE,"tic_event_init called");
}

/*
 *	add item to list of quick events to do
 */
LOCAL q_ev_handle
add_event IFN10(t_q_event **, head, t_q_event **, tail, t_q_event **, free,
	       t_q_event **, table, q_ev_handle *, free_handle, Q_CALLBACK_FN, func,
	       unsigned long, time, long,  param, unsigned long, time_to_next_trigger,
	       EVENTTYPE, event_type )
{

	t_q_event *ptr, *nptr, *pp, *hptr;
	int finished;
	unsigned long run_time;
	q_ev_handle handle;

	if (*head != NULL)
	{
		(*head)->time_from_last = time_to_next_trigger;
		sure_sub_note_trace1(Q_EVENT_VERBOSE,
				"add_event changes current list head to %d",
				(*head)->time_from_last);

	}

	if (time==0)
	{
		/* do func immediately */
		sure_sub_note_trace0(Q_EVENT_VERBOSE, "add_event doing func immediately");
		(*func)(param);
		return 0;
	}

	/* get a structure element to hold the event */
	if (*free == NULL)
	{
		/* we have no free list elements, so we must create one */
#if defined(SFELLOW)
		if ((nptr = (t_q_event *)makeSomeFreeEvents()) ==
#else
		if ((nptr = (t_q_event *)host_malloc(sizeof(t_q_event))) ==
#endif	/* SFELLOW */
			(t_q_event *)0 )
		{
			always_trace0("ARRGHH! malloc failed in add_q_event");
#if defined(SFELLOW)
			return 0;
#else
			return 0xffff;
#endif	/* SFELLOW */
		}
	}
	else
	{
		/* use the first free element */
		nptr = *free;
		*free = nptr->next_free;
	}

	handle = (*free_handle)++;
	if ((handle == 0) || (handle == 0xffff))
	{
		handle = 1;
		*free_handle=2;
	}
	nptr->handle = handle;
	nptr->param = param;
	nptr->event_type = event_type;

	/* now put the new event into the hash table structure */
	hptr=table[handle & HASH_MASK];
	if (hptr == NULL)
	{
		/* the event has hashed to a previously unused hash */
		table[handle & HASH_MASK] = nptr;
	}
	else
	{
		/* find the end of the list of events that hash to this
		** hash number
		*/
		while ((hptr->next_free) != NULL)
		{
			hptr = hptr->next_free;
		}
		hptr->next_free = nptr;
	}
	nptr -> next_free = NULL;

	/* fill the rest of the element */
	nptr->func=func;

	/* find the place in the list (sorted in time order) where
	   the new event must go */
	ptr = *head;
	run_time = 0;
	finished = FALSE;
	while (!finished)
	{
		if (ptr == NULL)
		{
			finished=TRUE;
		}
		else
		{
			run_time += ptr->time_from_last;
			if (time < run_time)
			{
				finished=TRUE;
			}
			else
			{
				ptr=ptr->next;
			}
		}
	}

	/* ptr points to the event which should follow the new event in the
	** list, so if it is NULL the new event goes at the end of the list.
	*/	
	if (ptr == NULL)
	{
		/* must add on to the end of the list */
		if (*tail==NULL)
		{
			/* list is empty */
			sure_sub_note_trace0(Q_EVENT_VERBOSE,
				"linked list was empty");
			*head = *tail = nptr;
			nptr->next = NULL;
			nptr->previous=NULL;
			nptr->time_from_last = time;
			nptr->original_time = time;
		}
		else
		{
			(*tail)->next = nptr;
			nptr->time_from_last = time-run_time;
			nptr->original_time = nptr->time_from_last;
			nptr->previous = *tail;
			*tail = nptr;
			nptr->next = NULL;
			sure_sub_note_trace1(Q_EVENT_VERBOSE,
				"adding event to the end of the list, diff from previous = %d",
				nptr->time_from_last);
		}
	} 
	else 
	{
		/* event is not on the end of the list */
		if (ptr->previous == NULL)
		{
			/* must be at head of (non empty) list */
			sure_sub_note_trace0(Q_EVENT_VERBOSE,
				"adding event to the head of the list");
			*head=nptr;
			ptr->previous = nptr;
			nptr->time_from_last = time;
			nptr->original_time = time;
			ptr->time_from_last -= time;
			nptr->next = ptr;
			nptr->previous = NULL;
		}
		else
		{
			/* the event is in the middle of the list */
			pp = ptr->previous;
			pp->next = nptr;
			ptr->previous = nptr;
			nptr->next = ptr;
			nptr->previous = pp;
			nptr->time_from_last = time -
				(run_time-(ptr->time_from_last));
			nptr->original_time = nptr->time_from_last;
			ptr->time_from_last -= nptr->time_from_last;
			sure_sub_note_trace1(Q_EVENT_VERBOSE,
				"adding event to the middle of the list, diff from previous = %d",
				nptr->time_from_last);
		}
	}

	return(handle);
}

GLOBAL q_ev_handle add_q_event_i IFN3(Q_CALLBACK_FN, func,
				 unsigned long, instrs,
			         long, param)
{
	return(gen_add_q_event(func, instrs, param, EVENT_INSTRUCTIONS));
}

LOCAL q_ev_handle gen_add_q_event IFN4(Q_CALLBACK_FN, func,
				 unsigned long, event_value,
			         long, param,
				 EVENTTYPE, event_type)
{
	q_ev_handle handle;
	unsigned long	jumps_remaining_to_count_down;
	unsigned long	time_remaining_to_next_trigger;
	unsigned long	jumps_till_trigger;
	unsigned long	event_time;

#if (defined(NTVDM) && defined(MONITOR)) || defined(GISP_CPU)	/* No quick events - just call func */
    (*func)(param);
    return(1);
#endif	/* NTVDM & MONITOR */

#if defined NTVDM && !defined MONITOR
        host_ica_lock();
#endif

	jumps_remaining_to_count_down = (unsigned long)host_q_ev_get_count();

#if defined(CPU_40_STYLE)
	sure_sub_note_trace1(Q_EVENT_VERBOSE,
		"jumps remaining to count down in cpu = %d",
		jumps_remaining_to_count_down);

	time_remaining_to_next_trigger =
		host_calc_q_ev_time_for_inst( jumps_remaining_to_count_down );
#else
	time_remaining_to_next_trigger = jumps_remaining_to_count_down;
#endif

	if( event_type == EVENT_TIME )
	{
		sure_sub_note_trace1(Q_EVENT_VERBOSE,
			"got request to do func in %d usecs", event_value);

		/* 1 usec -> 1 usec */
		event_time = event_value;
	}
	else
	{
		sure_sub_note_trace1(Q_EVENT_VERBOSE,
			"got request to do func in %d instructions", event_value);
		
		/* 1 million instrs/sec -> 1 instr takes 1 usec */
		event_time = event_value;
	}

	sure_sub_note_trace1(Q_EVENT_VERBOSE,
		"time remaining to next trigger = %d", time_remaining_to_next_trigger);

	handle = add_event( &q_list_head, &q_list_tail, &q_free_list_head, 
		q_ev_hash_table, &next_free_handle, func, event_time, param,
		time_remaining_to_next_trigger, event_type );

	/* set up the counter */
	if (q_list_head)
	{
#ifdef CPU_40_STYLE

		if (q_list_head->time_from_last > q_list_head->original_time)
		{
			jumps_till_trigger = 1;
		}
		else
		{
			jumps_till_trigger = host_calc_q_ev_inst_for_time(
						q_list_head->time_from_last);

			if (jumps_till_trigger == 0)
			{
				jumps_till_trigger = 1;
			}
		}
		host_q_ev_set_count(jumps_till_trigger);

		sure_sub_note_trace1( Q_EVENT_VERBOSE,
			"setting CPU counter to %d", jumps_till_trigger );

#else	/* CPU_40_STYLE */

		host_q_ev_set_count(q_list_head->time_from_last);
#endif	/* CPU_40_STYLE */
	}
	sure_sub_note_trace1(Q_EVENT_VERBOSE,"q_event returning handle %d",handle);

        /*
         * Notify host of event iff we are really queueing it. This is
         * to support CPUs that don't drive qevents (Sun HW)
         */
        host_note_queue_added(event_value);

#if defined NTVDM && !defined MONITOR
        host_ica_unlock();
#endif

	return(	(q_ev_handle)handle );
}

q_ev_handle add_tic_event IFN3(Q_CALLBACK_FN, func, unsigned long, time, long, param)
{
	q_ev_handle handle;
	unsigned long	cur_count_val;

	cur_count_val = (unsigned long)tic_ev_get_count();
	sure_sub_note_trace1(Q_EVENT_VERBOSE,
		"got request to do func in %d ticks", time);
	sure_sub_note_trace1(Q_EVENT_VERBOSE,
		"current tick delay count = %d", cur_count_val);

	handle = 
		add_event( &tic_list_head, &tic_list_tail, &tic_free_list_head, 
		tic_ev_hash_table, &tic_next_free_handle, func, time, param,
		cur_count_val, EVENT_TICK );
	/* set up the counter */
	if (tic_list_head)
		tic_ev_set_count(tic_list_head->time_from_last);
	sure_sub_note_trace1(Q_EVENT_VERBOSE,"tic_event returning handle %d",handle);
	return(	handle );
}

GLOBAL q_ev_handle add_q_event_t IFN3(Q_CALLBACK_FN, func, unsigned long, time,
				 long, param)
{
#ifdef CPU_40_STYLE
	return (gen_add_q_event(func, time, param, EVENT_TIME));
#else
	return (gen_add_q_event(func, host_calc_q_ev_inst_for_time(time),param, EVENT_TIME));
#endif
}

/*
 * Called from the cpu when a count of zero is reached
 */

LOCAL VOID
dispatch_event IFN6(t_q_event **, head, t_q_event **, tail, t_q_event **, free,
			  TQ_TABLE, table, VOID_FUNC, set_count, ULONG_FUNC, get_count )
{
	/* now is the time to do the event at the head of the list */
	int finished, finished2;
	q_ev_handle handle;
	t_q_event *ptr, *hptr, *last_hptr;

	UNUSED(get_count);
	
	finished = FALSE;
	while (!finished) {
		/* first adjust the lists */
		ptr = *head;
		if (ptr == NULL)	/* firewall */
		{
    			finished = TRUE;
    			continue;
		}
		*head = ptr->next;
		if (*head != NULL) {

			IU32 jumps;

			(*head)->previous = NULL;
			/* adjust counter to time to new head item */

			jumps = host_calc_q_ev_inst_for_time(
					(*head)->time_from_last);

			/* A quick event delay of zero means ignore */

			if( jumps == 0 )
			{
				/* Convert to a small but actionable delay */

				jumps = 1;
			}

			switch( (*head)->event_type )
			{
				case EVENT_TIME:

					sure_sub_note_trace2( Q_EVENT_VERBOSE,
						"set new time delay %d usecs -> %d jumps",
						(*head)->time_from_last,
						jumps );

					(*set_count)( jumps );
					
					break;

				case EVENT_INSTRUCTIONS:
#ifdef CPU_40_STYLE
					sure_sub_note_trace2( Q_EVENT_VERBOSE,
						"set new inst delay %d usecs -> %d jumps",
						(*head)->time_from_last,
						jumps );

					(*set_count)( jumps );

#else
					sure_sub_note_trace1(Q_EVENT_VERBOSE,
						"set new inst delay %d",
						(*head)->time_from_last );

					(*set_count)((*head)->time_from_last);
#endif
					break;

				case EVENT_TICK:
					sure_sub_note_trace1(Q_EVENT_VERBOSE,
						"set new tick delay %d",
						(*head)->time_from_last );

					(*set_count)((*head)->time_from_last);

					break;

				default:
#ifndef PROD
					always_trace1( "Invalid quick event type %d",
								(*head)->event_type );
					assert( FALSE );
#endif
					break;
			}
			
		} else {
			/* the queue is now empty */
			sure_sub_note_trace0(Q_EVENT_VERBOSE,"list is now empty");
			*tail = NULL;
		}
		/* find the event in the hash structure */
		handle = ptr->handle;
		finished2 = FALSE;
		hptr=table[handle & HASH_MASK];
		last_hptr = hptr;
		while (!finished2) {
			if (hptr == NULL) {
				finished2 = TRUE;
				always_trace0("quick event being done but not in hash list!!");
			} else {
				if (hptr->handle == handle) {
					/* found it! */
					finished2 = TRUE;
					if (last_hptr == hptr) {
						/* it was the first in the list for that hash */
						table[handle & HASH_MASK] = hptr->next_free;
					} else {
						last_hptr->next_free = hptr->next_free;
					}
				} else {
					last_hptr = hptr;
					hptr = hptr->next_free;
				}
			}
		}
		/* link the newly free element into the free list */
		ptr->next_free = *free;
		*free = ptr;

		sure_sub_note_trace1(Q_EVENT_VERBOSE,"performing event (handle = %d)", handle);

		(* (ptr->func))(ptr->param); /* do event */

		if (*head == NULL) {
			finished = TRUE;
		} else {
			if ((*head) -> time_from_last != 0) {
				/* not another event to dispatch */
				finished=TRUE;
			} else {
				sure_sub_note_trace0(Q_EVENT_VERBOSE,"another event to dispatch at this time, so do it now..");
			}
		}
	}
}

VOID    user_dispatch_q_event (user_set_count,user_get_count)

VOID    (*user_set_count)();
ULONG   (*user_get_count)();

{
        dispatch_event(&q_list_head,
                        &q_list_tail,
                        &q_free_list_head,
                        q_ev_hash_table,
                        user_set_count,
                        user_get_count);
}

VOID	dispatch_tic_event IFN0()
{
	ULONG	count;

	if ( (count = tic_ev_get_count()) > 0 )
	{
		tic_ev_set_count( --count );
		if (!count)
			dispatch_event( &tic_list_head, &tic_list_tail, 
				&tic_free_list_head, tic_ev_hash_table,
				tic_ev_set_count, tic_ev_get_count );
	}
}

VOID	dispatch_q_event IFN0()
{
#if defined NTVDM && !defined MONITOR
        host_ica_lock();
#endif

	dispatch_event( &q_list_head, &q_list_tail, &q_free_list_head,
			q_ev_hash_table, host_q_ev_set_count,
			host_q_ev_get_count );

#if defined NTVDM && !defined MONITOR
        host_ica_unlock();
#endif
}

/*
 * delete a previuosly queued event by handle
 */

LOCAL ULONG
unit_scaler IFN1
(
	IU32,	val
)
{
	return val;
}

LOCAL VOID
delete_event IFN7(t_q_event **, head, t_q_event **, tail, t_q_event **, free,
			TQ_TABLE, table, q_ev_handle, handle, VOID_FUNC, set_count,
			ULONG_FUNC, get_count )
{
	int time_counted_down, finished, cur_counter, handle_found, time_to_next_trigger;
	t_q_event *ptr, *pptr, *last_ptr;
	ULONG_FUNC scale_func, unscale_func;

	if (handle == 0)
	{
		sure_sub_note_trace0(Q_EVENT_VERBOSE," zero handle");
		return;
	}
	sure_sub_note_trace1(Q_EVENT_VERBOSE,"deleting event, handle=%d",handle);
	ptr = table[handle & HASH_MASK];

	handle_found = FALSE;
	finished = FALSE;
	last_ptr = ptr;

	/* find and remove event from hash structure */
	while (!finished) {
		if (ptr == NULL) {
			/* we can't find the handle in the hash structure */
			finished = TRUE;
		} else {
			if (ptr->handle == handle) {
				/* found it ! */
				if (last_ptr == ptr) {
					/* it was the first in the list */
					table[handle & HASH_MASK] = ptr->next_free;
				} else {
					last_ptr->next_free = ptr->next_free;
				}
				finished = TRUE;
				handle_found = TRUE;
			} else {
				last_ptr = ptr;
				ptr = ptr->next_free;
			}
		}
	}
	if (handle_found) {
		pptr = ptr->previous;
		if (pptr != NULL) {
			pptr->next = ptr->next;
		}
		pptr = ptr->next;
		if (pptr != NULL) {
			pptr->previous = ptr->previous;
			pptr->time_from_last += ptr->time_from_last;
		}
		if (ptr == *tail) {
			*tail = ptr->previous;
		}
		ptr->next_free = *free;
		*free = ptr;
		if (ptr == *head) {
			/* this is the event currently
				being counted down to, so
				we need to alter the counter */

			switch( (*head)->event_type )
			{
				case EVENT_TIME:
				case EVENT_INSTRUCTIONS:
#if defined(CPU_40_STYLE)
					scale_func = host_calc_q_ev_inst_for_time;
#else
					scale_func = unit_scaler;
#endif
					unscale_func = host_calc_q_ev_time_for_inst;
					break;

				case EVENT_TICK:
					sure_sub_note_trace0( Q_EVENT_VERBOSE,
							"deleting tick event" );
					scale_func = unit_scaler;
					unscale_func = unit_scaler;

					break;

				default:
#ifndef PROD
					always_trace1( "Invalid quick event type %d",
								(*head)->event_type );
					assert( FALSE );
#endif
					break;
			}

			cur_counter = (*get_count)();

#ifdef CPU_40_STYLE
			/*
			 * We are deleting an unexpired event at the
			 * the head of the queue. In the EDL CPU it is
			 * impossible for this event to still be in the
			 * queue and cur_counter to be negative.
			 * This is also true of the tick event counter
			 * mechanism ( see dispatch_tic_event() ).
			 */

#ifndef PROD
			if( cur_counter < 0 )
			{
				always_trace1( "cur_counter is negative (%d)",
								cur_counter );
				FmDebug(0);
			}
#endif
#endif

			time_to_next_trigger = (*scale_func)(cur_counter);
			time_counted_down = ptr->time_from_last - time_to_next_trigger;

			*head = ptr->next;
			pptr = ptr->next;
			if (pptr != NULL) {
				/*
				 * pptr->time_from_last was adjusted above to include
				 * the time_from_last of the event we are deleting
				 */

				if (pptr->time_from_last <= time_counted_down)
				{
					/* enough elapsed to dispatch next */
					dispatch_q_event();
				}
				else
				{
					/* set countdown from new head */
					pptr->time_from_last -= time_counted_down;
					(*set_count)(
						(*unscale_func)( pptr->time_from_last ));
				}
			}else {
				/* event list is now empty */
				(*set_count)(0);
			}
		} 
		sure_sub_note_trace0(Q_EVENT_VERBOSE,"event deleted");
	} else {
		sure_sub_note_trace0(Q_EVENT_VERBOSE,"handle not found");
	}
}

VOID delete_q_event IFN1(q_ev_handle, handle )
{
#if defined NTVDM && !defined MONITOR
        host_ica_lock();
#endif

	delete_event( &q_list_head, &q_list_tail, &q_free_list_head,
		q_ev_hash_table, handle, host_q_ev_set_count,
		host_q_ev_get_count );

#if defined NTVDM && !defined MONITOR
        host_ica_unlock();
#endif
}

VOID delete_tic_event IFN1(q_ev_handle,  handle )
{
	delete_event( &tic_list_head, &tic_list_tail, &tic_free_list_head,
		tic_ev_hash_table, handle, tic_ev_set_count,
		tic_ev_get_count );
}

#if defined(CPU_40_STYLE) && !defined(SFELLOW)
LOCAL void
init_q_ratio IFN0()
{
	ISH loop;

#ifdef CCPU
	/* CCPU doesn't support recalibrating quick evs */
	DisableQuickTickRecal = TRUE;
#endif
	if (host_getenv("DisableQuickTickRecal") != (char *)0)
		DisableQuickTickRecal = TRUE;

	/* initialise q_ratio buffer */
	for (loop = 0; loop < Q_RATIO_HISTORY_SIZE; loop++)
	{
		q_ratio_history[loop].jc_ms = Q_RATIO_DEFAULT;
		q_ratio_history[loop].time_ms = Q_RATIO_DEFAULT;
	}
	ideal_q_rate = 1;
	real_q_rate = 1;
	/* write 'first' timestamp */
	host_q_write_timestamp(&previous_tstamp);
	q_ratio_initialised = TRUE;
}

LOCAL void
add_new_q_ratio IFN2(IU32, jumps_ms, IU32, time_ms)
{
	/* add new value & update circular buffer index */
	q_ratio_history[q_ratio_head].jc_ms = jumps_ms;
	q_ratio_history[q_ratio_head].time_ms = time_ms;
	q_ratio_head = (q_ratio_head + 1) & Q_RATIO_WRAP_MASK;
}

LOCAL void
q_weighted_ratio IFN2(IU32 *, mant, IU32 *, divis)
{
	IUM32 index;
	IU32 jsum, jmin = (IU32)-1, jmax = 0;
	IU32 tsum, tmin = (IU32)-1, tmax = 0;

	index = q_ratio_head;	/* start at 'oldest' (next to be overwritten) */
	tsum = jsum = 0;
	/* take sum of history ratios */
	do {
		/* update sum of jumps + max & min */
		if (q_ratio_history[index].jc_ms < jmin)
			jmin = q_ratio_history[index].jc_ms;
		if (q_ratio_history[index].jc_ms > jmax)
			jmax = q_ratio_history[index].jc_ms;
		jsum += q_ratio_history[index].jc_ms;

		/* update sum of time + max & min */
		if (q_ratio_history[index].time_ms < tmin)
			tmin = q_ratio_history[index].time_ms;
		if (q_ratio_history[index].time_ms > tmax)
			tmax = q_ratio_history[index].time_ms;
		tsum += q_ratio_history[index].time_ms;

		index = (index + 1) & Q_RATIO_WRAP_MASK;

	} while(index != q_ratio_head);

	/* remove extreme values */
	jsum -= jmin;
	jsum -= jmax;

	tsum -= tmin;
	tsum -= tmax;

	jsum /= Q_RATIO_HISTORY_SIZE - 2;
	tsum /= Q_RATIO_HISTORY_SIZE - 2;

	*mant = jsum;
	*divis = tsum;
}

/***********************************************************************
	Recalibration:

ijc == InitialJumpCounter
measure minimum counter period - ijc->0 counters. (usecPerIJC)

1 tick = 54945us

so 1 tick 'should' take 54945/usecPerIJC = N (ijc) jumps.

per tick:
	get time delta.  (approx 54945)
	divide by usecPerIJC to get # of ijc's. (numijc)
	multiply by ijc to get theoretical jumpcal for delta. (idealjc)
	get real jumpcal for delta. 	(realjc)

tick adjust ratio is therefore   realjc * requestime / idealjc

****************************************************************************/

/* calculate a number for number of pig-synchs per microsecond for a 33Mhz processor:
** Assume a synch on average every 5 Intel instructions, and each intel
** instruction takes about 2 cycles on average. The proper answer comes out as
** 3.3, but this has to be an integer, so round it down to 3
*/
#define SYNCS_PER_USEC		3

static IU32 jumpRestart = (IU32)-1;
static IU32 usecPerIJC = (IU32)-1;

/*
 * host_calc_q_ev_inst_for_time for CPU_40_STYLE ports. See above for
 * recalibration vars used to scale time->jumps
 */

IU32
calc_q_inst_for_time IFN1(IU32, time)
{
#ifdef SYNCH_TIMERS
	return (time * SYNCS_PER_USEC);
#else
	IU32 inst, jumps;

	/* be crude before initialisation */
	if (usecPerIJC == (IU32)-1)
		return(time / 10);	/* CCPU style! */
	
	/* first adjust us -> jumps */
	jumps = (time * jumpRestart) / usecPerIJC;

	/* now fine adjust jumps for recent period */
	inst = (jumps * real_q_rate) / (ideal_q_rate);

	return(inst);
#endif /* SYNCH_TIMERS */
}

/*
 * Time quick events are held internally with time unscaled. CPU reports
 * current elapsed time as scaled - convert from scaled->unscaled.
 * This routine implements the mathematical inverse of the above routine
 * except for the boundary condition checking.
 */

IU32
calc_q_time_for_inst IFN1(IU32, inst)
{
#ifdef SYNCH_TIMERS
	return (inst / SYNCS_PER_USEC);
#else
	IU32 time, jumps;

	/* be crude before initialisation */
	if (usecPerIJC == (IU32)-1)
		return(inst * 10);	/* CCPU style! */
	
	/* remove fine scaling */
	jumps = (inst * ideal_q_rate) / real_q_rate;

	/* now usec/jump adjustment */
	time = (jumps * usecPerIJC) / jumpRestart;

	/* allow for rounding to 0 on small numbers */
	if (time == 0 && inst != 0)
		return(inst);
	else
		return(time);
#endif /* SYNCH_TIMERS */
}

#define FIRSTFEW 33
#define IJCPERIOD 91

GLOBAL void
quick_tick_recalibrate IFN0()
{
	QTIMESTAMP now;
	IU32 idealrate, realrate;
	IUH tdiff;
	extern int soft_reset;
	static int firstfew = FIRSTFEW;
	static QTIMESTAMP ijc_tstamp;
	static IU32 ijc_recount, ijc_calib;

#if defined(CCPU) || !defined(PROD)
	/* allow dev disabling of quick tick recal. Yoda 'qrecal {on|off}' */
	if (DisableQuickTickRecal)
	{
		ideal_q_rate = Q_RATIO_DEFAULT;
		real_q_rate = Q_RATIO_DEFAULT;
		return;
	}
#endif	/* PROD */

	/* Boot time introduces some unrealistic time intervals - avoid them */
	if (!soft_reset)
		return;

	/* quick event initialisation only on warm boot */
	if (!q_ratio_initialised)
	{
		init_q_ratio();
		return;
	}

	if (firstfew)
	{
		switch (firstfew)
		{
		case FIRSTFEW:	/* first tick after reset */
			host_q_write_timestamp(&previous_tstamp);
			jumpRestart = host_get_jump_restart();
			break;

		case 1:		/* last tick of 'firstfew' */
			host_q_write_timestamp(&now);
			/* get real elapsed time of firstfew ticks */
			tdiff = host_q_timestamp_diff(&previous_tstamp, &now);

			/* get CPU activity rate in the period */
			realrate = host_get_q_calib_val();

			usecPerIJC = (tdiff * jumpRestart) / realrate;

			sure_sub_note_trace4(Q_EVENT_VERBOSE,
				"Baseline time for ijc = %d us (%d*%d)/%d",
				usecPerIJC, tdiff,
				jumpRestart, realrate);
			host_q_write_timestamp(&previous_tstamp);
			ijc_tstamp.data[0] = previous_tstamp.data[0];
			ijc_tstamp.data[1] = previous_tstamp.data[1];
			ijc_recount = IJCPERIOD;
			ijc_calib = 1;
			break;
		}
		firstfew --;
		return;
	}
	else	/* periodic update of usecPerIJC value */
	{
		ijc_recount--;
		if (ijc_recount == 0)
		{
			if (ijc_calib > 50000)	/* questimate value 1% of us */
			{
				host_q_write_timestamp(&now);
				tdiff = host_q_timestamp_diff(&ijc_tstamp, &now);
				usecPerIJC = (tdiff * jumpRestart) / ijc_calib;
				sure_sub_note_trace4(Q_EVENT_VERBOSE,
					"New usecPerIJC %d us (%d*%d)/%d",
					usecPerIJC, tdiff,
					jumpRestart, ijc_calib);
				ijc_recount = IJCPERIOD;
				ijc_tstamp.data[0] = now.data[0];
				ijc_tstamp.data[1] = now.data[1];
				ijc_calib = 1;
			}
			else	/* too small (idling?) - keep current value for now */
			{
				sure_sub_note_trace1(Q_EVENT_VERBOSE,
					"No new usecPerIJC as calib too small (%d)", ijc_calib);
				host_q_write_timestamp(&ijc_tstamp);
				ijc_calib = 1;
				ijc_recount = IJCPERIOD;
			}
		}
	}

	/* make ratio of code progress to elapsed time period */
	host_q_write_timestamp(&now);
	tdiff = host_q_timestamp_diff(&previous_tstamp, &now);

	/*
 	* The recalibration must be done by the 'slow' ticker. If the
 	* heartbeat is running too quickly for some reason, ignore
 	* recal requests until approx correct period is achieved. (This
 	* definition of 'correct' allows for signal waywardness).
 	*/
	if (tdiff < 5000)
		return;

	/* idle, graphics, net waits all can spoil recalibrations day... */
	if (tdiff > 5*54945)	/* 54945 is 1000000us/18.2 */
	{
		/* skip this attempt, try again when more settled */
		host_q_write_timestamp(&previous_tstamp);
		return;
	}

	idealrate = (tdiff * jumpRestart) / usecPerIJC;

	if (idealrate == 0)
		return;		/* usecPerIJC too high - idling or stuck in C */

	realrate = host_get_q_calib_val();

	if (realrate == 0)	/* must be idling or stuck in C */
		return;		/* try again when actually moving */

	ijc_calib += realrate;

#ifdef AVERAGED	/* not for the moment */
	/* add new value to buffer */
	add_new_q_ratio(idealrate, realrate);

	/* ... and get average of accumulated ratios */
	q_weighted_ratio(&ideal_q_rate, &real_q_rate);
#else
	ideal_q_rate = idealrate;
	real_q_rate = realrate;
#endif

	/* timestamp for next recalc period */
	host_q_write_timestamp(&previous_tstamp);
}




#ifndef NTVDM

/* functions required to implement the add_q_ev_int_action interface */
LOCAL Q_INT_ACT_REQ int_act_qhead;
IS32 int_act_qident = 0;

/*(
 =========================== add_new_int_action ==========================
PURPOSE: add to the add_q_ev_int_action queue.
INPUT:  func, adapter, line, parm - as add_q_ev_int_action
OUTPUT: queue identifier or -1 failure
=========================================================================
)*/
LOCAL IU32
add_new_int_action IFN4(Q_CALLBACK_FN, func, IU32, adapter, IU32, line, IU32, parm)
{
	Q_INT_ACT_REQ_PTR qptr, prev;	/* list walkers */
	SAVED IBOOL firstcall = TRUE;

	if (firstcall)	/* ensure head node setup on first call */
	{
		firstcall = FALSE;
		int_act_qhead.ident = 0;
		int_act_qhead.next = Q_INT_ACT_NULL;
	}

	/* maintain permanent head node for efficiency */

	/* check whether head used (ident == 0 means unused) */
	if (int_act_qhead.ident == 0)
	{
		/* copy parameters to head node */
		int_act_qhead.func = func;
		int_act_qhead.adapter = adapter;
		int_act_qhead.line = line;
		int_act_qhead.param = parm;

		/* get identifier for node */
		int_act_qident ++;
		/* cope with (eventual) wrap */
		if (int_act_qident > 0)
			int_act_qhead.ident = int_act_qident;
		else
			int_act_qhead.ident = int_act_qident = 1;
	}
	else	/* find end of queue */
	{
		/* start where head node points */
		qptr = int_act_qhead.next;
		prev = &int_act_qhead;

		while (qptr != Q_INT_ACT_NULL)
		{
			prev = qptr;
			qptr = qptr->next;
		}
		/* add new node */
		prev->next = (Q_INT_ACT_REQ_PTR)host_malloc(sizeof(Q_INT_ACT_REQ));
		/* malloc ok? */
		if (prev->next == Q_INT_ACT_NULL)
			return((IU32)-1);

		/* initialise node */
		qptr = prev->next;
		qptr->next = Q_INT_ACT_NULL;
		qptr->func = func;
		qptr->adapter = adapter;
		qptr->line = line;
		qptr->param = parm;

		/* get identifier for node */
		int_act_qident ++;
		/* cope with (eventual) wrap */
		if (int_act_qident > 0)
			qptr->ident = int_act_qident;
		else
			qptr->ident = int_act_qident = 1;
	}

	sure_sub_note_trace2(Q_EVENT_VERBOSE,"add_new_q_int_action added fn %#x as id %d", (IHPE)func, int_act_qident);
}

/*(
 =========================== select_int_action ==========================
PURPOSE: choose from the q'ed add_q_ev_int_action requests which delay has
	 expired. Call action_interrupt with the appropriate parameters. Remove
	 request from queue.
INPUT:  long: identifier of request 
OUTPUT: None.
=========================================================================
)*/
LOCAL void
select_int_action IFN1(long, identifier)
{
	Q_INT_ACT_REQ_PTR qptr, prev;	/* list walkers */

	/* check permanent head node first */
	if (int_act_qhead.ident == (IS32)identifier)
	{
		action_interrupt(int_act_qhead.adapter, int_act_qhead.line,
				int_act_qhead.func, int_act_qhead.param);
		int_act_qhead.ident = 0;	/* mark unused */
	}
	else	/* search list */
	{
		/* start search beyond head */
		qptr = int_act_qhead.next;
		prev = &int_act_qhead;

		while (qptr != Q_INT_ACT_NULL && qptr->ident != (IS32)identifier)
		{
			prev = qptr;
			qptr = qptr->next;
		}
		
		/* if node found, dispatch action_int */
		if (qptr != Q_INT_ACT_NULL)
		{
			action_interrupt(qptr->adapter, qptr->line, qptr->func, qptr->param);
			/* and remove node */
			prev->next = qptr->next;	/* connect around node */
			host_free(qptr);		/* chuck back on heap */
		}
		else	/* odd - identifier not found! */
		{
			assert1(FALSE, "select_int_action: id %d not found",identifier);
		}
	}
}

/*(
 =========================== add_q_ev_int_action ==========================
PURPOSE: Prepare to call a hardware interrupt after a quick event managed 
	 delay. The interrupt must be called from the passed callback
	 function at the same time as any associated emulation. The callback
	 will be called once the delay has expired and the cpu is ready to
	 receive interrupts on the passed line. See also ica.c:action_interrupt()

INPUT:  time: unsigned long - us of delay before calling action_interrupt
	func: callback function address to callback when line available.
	adapter: IU32. master/slave.
	line: IU32. IRQ line interrupt will appear on.
	parm: IU32. parameter to pass to above fn.

OUTPUT: Returns q_ev_handle associated with quick event delay
=========================================================================
)*/
GLOBAL q_ev_handle
add_q_ev_int_action IFN5(unsigned long, time, Q_CALLBACK_FN, func, IU32, adapter, IU32, line, IU32, parm)
{
	IU32 action_id;		/* int_action list id */

	/* store action_int parameters in internal list */
	action_id = add_new_int_action(func, adapter, line, parm);

	/* check for failure */
	if (action_id == -1)
		return((q_ev_handle)-1);

	/* set quick event up to call selection func on expiry */
	return( add_q_event_t(select_int_action, time, (long)action_id) );
}

#endif

#endif /* CPU_40_STYLE && !SFELLOW */

#ifdef QEVENT_TESTER

/*
 * The routine qevent_tester() below can be called from a BOP, which
 * in turn can be called from a .BAT file using bop.com in a loop.
 * This doesn't test the quick event system exhaustively but puts it
 * under a bit more pressure.
 */

LOCAL q_ev_handle handles[256];
LOCAL IU8 deleter = 1;

LOCAL void
tester_func IFN1
(
	IU32,	param
)
{
	SAVED IU8 do_delete = 0;

	handles[param] = 0;

	if( handles[deleter] && (( do_delete++ & 0x1 ) == 0 ))
	{
		delete_q_event( handles[deleter] );
	}

	deleter += 7;
}

GLOBAL void
qevent_tester IFN0()
{
	SAVED IU8 indx = 0;

	handles[indx++] = add_q_event_i((Q_CALLBACK_FN) tester_func, 100, indx );
	handles[indx++] = add_q_event_t((Q_CALLBACK_FN) tester_func, 300, indx );
	handles[indx++] = add_q_event_i((Q_CALLBACK_FN) tester_func, 1000, indx );
	handles[indx++] = add_q_event_t((Q_CALLBACK_FN) tester_func, 3000, indx );
	handles[indx++] = add_q_event_i((Q_CALLBACK_FN) tester_func, 10000, indx );
	handles[indx++] = add_q_event_t((Q_CALLBACK_FN) tester_func, 30000, indx );
	handles[indx++] = add_q_event_i((Q_CALLBACK_FN) tester_func, 100000, indx );
	handles[indx++] = add_q_event_t((Q_CALLBACK_FN) tester_func, 300000, indx );
}
#endif /* QEVENT_TESTER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\system\timer.c ===
#include "insignia.h"
#include "host_def.h"

/*
 * SoftPC version 2.0
 *
 * Title        : Time Handler
 *
 * Description  : Emulate the 8253 3-channel timer; invoke 'BIOS
 *                sytem timer interrupt code', cursor flash, repeat
 *                key processing etc.
 *
 * Author       : Jerry Kramskoy
 *
 * Notes        : There is only one real time timer per process, this
 *                module counts clock ticks and distributes calls
 *                to the appropriate functions as required.
 *
 *                This module is host independent - see xxxx_timer.c
 *                where xxxx is a machine type for host dependent stuff.
 *
 * Mods: (r3.2) : (SCR 257). Code has been added to time_tick() to spot
 *                that video has been disabled for a period. If this is
 *                so, clear the screen. Refresh when video is enabled
 *                again.
 *
 *       (r3.4) : Make use of the host time structures host_timeval,
 *                host_timezone, and host_tm, which are equivalent
 *                to the Unix BSD4.2 structures.
 *                Also convert references to gettimeofday() to
 *                host_getIdealTime().
 */

#ifdef SCCSID
static char SccsID[]="@(#)timer.c       1.41 05/31/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_SUPPORT.seg"
#endif


/*
 *    O/S include files.
 */

#include <stdio.h>
#include TypesH
#include TimeH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "ica.h"
#include "trace.h"
#include "bios.h"
#include "host.h"
#include "timer.h"
#include "timeval.h"
#include "idetect.h"
#include "debug.h"
#include "quick_ev.h"

#ifndef PROD
#include <stdlib.h>
#endif

#ifdef HUNTER
#include "hunter.h"
#endif

#ifdef NTVDM
#include "fla.h"
#include "nt_eoi.h"
#include "nt_reset.h"
#include "nt_pif.h"
#include "vdm.h"
#undef LOCAL
#define LOCAL
#endif

/* Imports */


/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */

/* 'idealtime' gets initialised to be the host system's current
 * time value (timer_init()), and thereafter gets incremented by
 * the value 'idealInterval' every time that time_tick() gets called
 * which gives the illusion of a 100% accurate signal delivery
 */

static struct host_timeval idealtime;
static unsigned long idealInterval;
#ifdef NTVDM
ULONG timer_delay_size= HOST_IDEAL_ALARM >> 1; // usecs
ULONG EoiPending=0;
ULONG EoiIntsPending=0;
ULONG EoiDelayInUse=0;
int ticks_blocked = 0;
BOOL JoyTimeLatchPending = FALSE;
USHORT JoyTimeCountCounterZero;
#else /* NTVDM */
static unsigned long ticksPerIdealInterval;
static  int     ticks_blocked = 0;
#endif /* NTVDM */

#ifndef PROD
static char buf[80];  /* Used for tracing messages */
#endif

#ifdef HUNTER                   /* Only needed for HUNTER */
word timer_batch_count;         /* Batch update when PC tick occurs */
#endif
int timer_int_enabled;          /* Whether Bios timer ints are required */


/* control word format */

/* Values in D54 of control word - number of bytes to read/load into counter */
#define LATCH                   0
#define RL_LSB                  1
#define RL_MSB                  2
#define RL_LMSB                 3

/* Values in D321 of control word - the counter mode. */
#define INT_ON_TERMINALCOUNT    0
#define PROG_ONESHOT                    1
#define RATE_GEN                                2
#define SQUAREWAVE_GEN                  3
#define SW_TRIG_STROBE                  4
#define HW_TRIG_STROBE                  5
/* NB. 6 = RATE_GEN, 7 = SQUAREWAVE_GEN */

/* Values in D0 of control word - whether prog wants to read/write binary or BCD to counter */
#define BINARY                  0
#define BCD                             1

#define INDEFINITE              (ULONG)-1
#define STARTLO                 0
#define STARTHI                 1
#define NOREPEAT                0
#define REPEAT                  ~NOREPEAT

#define WRITE_SIGNAL     1
#define GATE_SIGNAL      2

#define UNLOCKED 0
#define LOCKED ~UNLOCKED

#define STATE_FUNCTION void
#define UNBLOCK_FUNCTION void
#define GATENABLED_FUNCTION void
#define UPDATECOUNTER_FUNCTION void

/*
 * Timer read state
 */
#define UNREAD                  0       /* Timer is in normal state */
#define READMSB                 1       /* First byte of LMSB mode read, but not second yet */
#define READSTATUS              2       /* Status latched, will read it first */

/*
 * These two figures give a timer frequency of 1.193 MHz (which is
 * how fast the 8235 is clocked. This means that the timer will wrap round
 * every 1/18.2th of a second... the same amount of time as the PC tick
 * rate. This is not surprizing, as the PC tick rate is controlled by
 * timer 0. Every time timer 0 wraps, the PC is interrupted by the timer.
 */

#define TIMER_CLOCK_NUMER       1000
#if defined(NEC_98)
#define TIMER_CLOCK_DENOM_10    2458
#define TIMER_CLOCK_DENOM_8     1997
#else    //NEC_98
#define TIMER_CLOCK_DENOM       1193
#endif   //NEC_98

typedef half_word TSIGNAL;

/* the following structure defines an output waveform from a
 * timer channel. The waveform consists of 'n' clocks at one
 * logic level, and 'm' ticks at the other logic level.
 * Which level starts the waveform is given by 'startLogicLevel'.
 *      e.g; the following waveform ...
 */

typedef struct {
        long clocksAtLoLogicLevel;
        long clocksAtHiLogicLevel;
        long period;
        long startLogicLevel;
        long repeatWaveForm;
} WAVEFORM;

/*      __ __ __ __ __ __        __ __ __ __ __ __        __ __ __ __ __ __
 *                      |        |               |        |                |
 *                      |__ __ __|               |__ __ __|                |
 *
 * would be described by
 *      clocksAtLoLogicLevel = 3
 *      clocksAtHiLogicLevel = 6
 *      startLogicLevel = STARTHI
 *      repeatWaveForm = TRUE;
 *
 *
 * The overall state of a counter is represented by the following
 * structure. Its contents are described below.
 */

typedef enum trigCond_ {LEVEL, EDGE} trigCond;
typedef enum countload_ {AVAILABLE, USED} countload;

typedef struct {
        int                     m;
        int                     bcd;
        int                     rl;

        STATE_FUNCTION  (*state) IPT2(int, signal, half_word, value);
        STATE_FUNCTION  (*statePriorWt) IPT2(int, signal, half_word, value);
        STATE_FUNCTION  (*stateOnGate) IPT2(int, signal, half_word, value);
        UNBLOCK_FUNCTION        (*actionOnWtComplete) IPT0();
        UNBLOCK_FUNCTION        (*actionOnGateEnabled) IPT0();
        void            (*getTime) IPT1(struct host_timeval *, t);

        unsigned char   outblsb;
        unsigned char   outbmsb;
        unsigned        long initialCount;
        int                     readState;
        int                     countlatched;
        unsigned char   latchvaluelsb;
        unsigned char   latchvaluemsb;
        unsigned char   latchstatus;
        word            Count;
        countload       newCount;
        word            tickadjust;
        struct host_timeval activationTime;
        int             tc;
        int             freezeCounter;

#ifndef NTVDM
        unsigned long lastTicks;
        long            microtick;
        long            timeFrig;
        word            saveCount;
        int             guessesPerHostTick;     /* How often per host tick are we forced to guess? */
        int             guessesSoFar;           /* How many times have we guessed so far? */
#endif

        unsigned int    delay;

        trigCond        trigger;
        TSIGNAL         gate;
        TSIGNAL         clk;
        WAVEFORM        out;
} COUNTER_UNIT;

/*
 * When the counter is programmed, the 8253 receives a control word.
 * (see pg 6-266 of manual). The counter being programmed is specified
 * within this word. Provided 'rl' is non-zero, then this counter is
 * being reprogrammed, and we remember the values of m (mode), rl
 * (control of which bytes are involved in a read or load sequence)
 * and bcd (whether the counter is in binary or bcd mode).
 * Based on rl, the counter then must receive one or two bytes via
 * outb's. Two states are used to accept 'outblsb' or
 * 'outbmsb', or both. When the full byte complement has been received,
 * 'initialCount' gets set to the value specified by 'outblsb' and 'outbmsb',
 * taking account of BCD etc., along with 'Count'.
 * 'Count' gets adjusted by the value of 'timeadjust'.
 * 'timeadjust' is initialised to zero every time a new mode
 * word (non-zero) is received. For certain modes of the counter,
 * if they are sent a new count, without receiving a new mode, then
 * this will cause the counter to start counting from this new count
 * at some stage (based on mode and gate values). SInce we are not
 * maintaining the counters continually (rather we prod them as a
 * result of io or gate activity) then there is a good chance we
 * will be late at resetting a counter for counting again. Hence
 * 'timeadjust' is calculated for this lateness, and used as a
 * correction factor.

 * If a 'latch counter' command ('rl'=0 in command word) is issued, then
 * the current counter value is latched into 'latchvaluelsb' and
 * 'latchvaluemsb', and the flag 'countlatched' is set non-zero.
 * If this flag is non-zero during a counter read, then these latched
 * bytes are returned, and upon completion of the read sequence, the
 * flag is cleared. If this flag is zero, then the current counter value
 * is read, and returned. 'donate' is used to point at the appropriate
 * byte to be delivered to the 'inb'.

 * when a counter activates (i.e; count begins or continues after
 * a gate signal change) a time stamp is taken, to enable a time delta
 * to be calculated whenever the counter is read .. this is stored in
 * 'activationTime'.

 * A state function (state), representing the current state
 * of the counter, gets called whenever inb,outb accesses occur, or when
 * the ppi's signal TIM2GATESPK changes. reading/writing of the counters
 * (as opposed to the control word register) always 'blocks' the current
 * state,and puts the counter into a temporary state which handles reading or
 * loading the counter. The blocked state is remembered in 'statePriorWt'.
 * Once the counter has been loaded or read (as specified by its 'rl'
 * parameter) then 'actionOnWtComplete' gets called. Typically this in turn
 * reverts the counter back to the state it was in before it became
 * blocked.

 * If a counter is read, then the function 'updateCounter' gets called to
 * determine what the current counter value is.
 * If the counter's gate signal is disabling counting, and the counter
 * has been fully programmed (and hence able to count), then the counter
 * will be in the state 'awaitingGate'. When the appropriate gate signal
 * appears (via a ppi call), the counter activates by calling the
 * function 'actionOnGateEnabled'. This will take some sort of action, and then
 * place the counter into the state 'stateOnGate'.
 *
 * sending a new count to a counter in modes 2 or 3 will not take
 * effect until the end of the current period ... hence 'delay'
 * is used as an indicator (for sound logic emulation only) of
 * this. If the counter has say 10 clocks left to count down to
 * the end of the period when it receives new waveform parameters,
 * this information is passed onto the sound logic, with a 'delay'
 * of 10. Otherwise 'delay' is not used.
 *
 * On some operating systems, the real time clock may well have to
 * coarse a granularity. If the 8253 is read to quickly, there is a
 * very good chance that the OS clock will still be reading the same.
 * To cater for this, a frig factor 'microsecs' has been introduced.
 * This gets incremented every time the above condition is detected,
 * and used as part of the counter update calculations. Whenever
 * the OS actually says something sensible, it gets cleared again.
 */

static COUNTER_UNIT timers[3], *pcu;

LOCAL STATE_FUNCTION uninit IPT2(int, signal, half_word, value);
LOCAL STATE_FUNCTION awaitingGate IPT2(int, signal, half_word, value);
LOCAL STATE_FUNCTION waitingFor1stWrite IPT2(int, signal, half_word, value);
LOCAL STATE_FUNCTION waitingFor2ndWrite IPT2(int, signal, half_word, value);
LOCAL STATE_FUNCTION Counting0 IPT2(int, signal, half_word, value);
LOCAL STATE_FUNCTION Counting_4_5 IPT2(int, signal, half_word, value);
LOCAL STATE_FUNCTION Counting1 IPT2(int, signal, half_word, value);
LOCAL STATE_FUNCTION Counting_2_3 IPT2(int, signal, half_word, value);
LOCAL UNBLOCK_FUNCTION resumeCounting_1_5 IPT0();
LOCAL GATENABLED_FUNCTION resumeCounting_2_3_4 IPT0();
LOCAL void resumeAwaitGate IPT0();
LOCAL UNBLOCK_FUNCTION CounterBufferLoaded IPT0();
LOCAL UNBLOCK_FUNCTION timererror IPT0();
LOCAL GATENABLED_FUNCTION runCount IPT0();
LOCAL void controlWordReg IPT1(half_word, cwd);
LOCAL void latchStatusValue IPT0();
LOCAL void readCounter IPT0();
LOCAL void timestamp IPT0();
LOCAL void outputWaveForm IPT5(unsigned int, delay, unsigned long, lowclocks,
        unsigned long, hiclocks, int, lohi, int, repeat);
LOCAL void outputHigh IPT0();
LOCAL void outputLow IPT0();
LOCAL void setOutputAfterMode IPT0();
LOCAL void loadCounter IPT0();
LOCAL void updateCounter IPT0();
LOCAL void startCounting IPT0();

#ifdef NTVDM
unsigned long updateCount(void);
#else
LOCAL void updateCount IPT3(unsigned long, ticks, unsigned long *, wrap,
        struct host_timeval *, now);
#endif
LOCAL unsigned  short bin_to_bcd IPT1(unsigned long, val);
LOCAL word bcd_to_bin IPT1(word, val);
LOCAL void emu_8253 IPT3(io_addr, port, int, signal, half_word, value);
LOCAL void Timer_init IPT0();
LOCAL unsigned long timer_conv IPT1(word, count);
LOCAL void issueIREQ0 IPT1(unsigned int, n);
#ifndef NTVDM
LOCAL unsigned long guess IPT0();
LOCAL void throwaway IPT0();
#endif
#ifdef SYNCH_TIMERS
GLOBAL void IdealTimeInit IPT0();
#else
LOCAL void IdealTimeInit IPT0();
#endif
LOCAL void updateIdealTime IPT0();
LOCAL void getIdealTime IPT1(struct host_timeval *, t);
#ifndef NTVDM
LOCAL void getHostSysTime IPT1(struct host_timeval *, t);
LOCAL void checktimelock IPT0();
#endif
LOCAL void setTriggerCond IPT0();
LOCAL void WtComplete IPT0();
LOCAL void counter_init IPT1(COUNTER_UNIT *, p);
#ifndef NTVDM
LOCAL void setLastWrap IPT2(unsigned int, nclocks, struct host_timeval *, now);
LOCAL void timer_generate_int IPT1(long, n);
LOCAL void timer_multiple_ints IPT1(long, n);

#define MAX_BACK_SECS 15
LOCAL IU32 max_backlog = 0;     /* max # of ints allowed to queue up */
IBOOL active_int_event = FALSE; /* current quick_event for timer queue */
IU32 more_timer_mult = 0;       /* additions to timer int queue */
IU32 timer_multiple_delay = 0;  /* us delay to next timer queue elem */
#endif

#if defined(NTVDM)

void timer_generate_int(void);
unsigned long clocksSinceCounterUpdate(struct host_timeval *pCuurTime,
                                       struct host_timeval *pLastTime,
                                       word                *pCounter);
void ReinitIdealTime IPT1(struct host_timeval *, t);
void host_GetSysTime(struct host_timeval *time);
void InitPerfCounter(void);

/* holds real time values for counter zero */
struct host_timeval LastTimeCounterZero;
word                RealTimeCountCounterZero;


#ifndef PROD
ULONG NtTicTesting = 0;   /* tracing specific to NT port */
ULONG TicsGenerated;
ULONG TicsReceived;
#endif

    /* for optimizing timer hardware interrupt generation */
word TimerInt08Seg = TIMER_INT_SEGMENT;
word TimerInt08Off = TIMER_INT_OFFSET;
word TimerInt1CSeg;
word TimerInt1COff;



#else

static int timelock;            /* locks out time_tick if set */
static int needtick;            /* causes time_tick() to be called if set */

/*
 * Data for the hack to make sure that windows in standard mode doesn't get two timer
 * ticks too close together.
 */

LOCAL BOOL      hack_active=FALSE;                      /* This boolean indicates that we are spacing
                                                           timer interrupts out by discarding timer ticks.
                                                           It is set when we see a protected mode tick */
LOCAL BOOL      too_soon_after_previous=FALSE;          /* This boolean is set on when an interrupt is
                                                           generated... a quick event is requested to
                                                           clear it again after a "fixed" number of
                                                           instructions */
LOCAL BOOL      ticks_lost_this_time=FALSE;             /* This boolean is set if any interrupts were
                                                           required to be generated while too_soon_after_previous
                                                           was TRUE - if it's TRUE when too_soon_after_previous
                                                           is being set to FALSE, we generate an immediate
                                                           interrupt to get the best responsiveness */
LOCAL ULONG     real_mode_ticks_in_a_row = 0;           /* A count of the number of real mode ticks in a row...
                                                           this is used to disable the hack again when we have
                                                           left protected mode for a good while */
LOCAL ULONG     instrs_per_tick = 37000;                /* Nominal (as timed on the reference machine - a SPARC 1+) */
LOCAL ULONG     adj_instrs_per_tick = 0;                /* The estimated number of Intel instructions being emulated
                                                           each 20th of a second */
LOCAL ULONG     n_rm_instrs_before_full_speed = 3000000;/* Nominal number of instructions to be emulated in real mode
                                                           before we're convinced that we're staying back in real mode */
LOCAL ULONG     adj_n_real_mode_ticks_before_full_speed = 0;/* The value which real_mode_ticks_in_a_row must reach
                                                           before the hack is disabled */
#ifndef PROD
LOCAL ULONG     ticks_ignored = 0;                      /* For information purposes only. */
#endif

#endif /* NTVDM */

#ifndef PROD    /* Specific Timer change tracing that isn't timer_verbose */


GLOBAL int DoTimerChangeTracing = 0;
#endif

#if !defined(NTVDM)
#if defined(IRET_HOOKS) && defined(GISP_CPU)
extern IBOOL HostDelayTimerInt IPT1(int, numberInts);
extern IBOOL HostPendingTimerInt IPT0();
extern void HostResetTimerInts IPT0();

#endif /* IRET_HOOKS && GISP_CPU */
#endif

#if defined(NTVDM)
#ifndef MONITOR
#define pNtVDMState ((PULONG)(Start_of_M_area + FIXED_NTVDMSTATE_LINEAR))
#endif
#endif

/*
 * ============================================================================
 * External variables
 * ============================================================================
 */

boolean timer_video_enabled;

/*
 *  Table of function pointers to access TIMER routines
 */
void (*timer_inb_func) IPT2(io_addr, port, half_word *, value);
void (*timer_outb_func) IPT2(io_addr, port, half_word, value);
void (*timer_gate_func) IPT2(io_addr, port, half_word, value);
void (*timer_tick_func) IPT0();

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */
#if defined(NEC_98)
extern void SetRSBaud();
extern void SetBeepFrequency();
unsigned short RSBaud = 0;
#endif   //NEC_98

void
SWTMR_init_funcptrs IFN0()
{
        /*
         *  initialize access functions for SW [emulated] TIMER
         */
        timer_inb_func                  = SWTMR_inb;
        timer_outb_func                 = SWTMR_outb;
        timer_gate_func                 = SWTMR_gate;
        timer_tick_func                 = SWTMR_time_tick;

#ifndef NTVDM
        /*
         * initialise stuff for PM timer hack
         */
        too_soon_after_previous         = FALSE;
        if (adj_n_real_mode_ticks_before_full_speed == 0){
                HOST_TIMER_DELAY_SIZE=25000;
                adj_instrs_per_tick = host_speed (instrs_per_tick);
                adj_n_real_mode_ticks_before_full_speed = n_rm_instrs_before_full_speed / adj_instrs_per_tick;
        }
#endif
}

void
SWTMR_time_tick IFN0()
{

    /*
     * Give the idle detector a chance to see if we are really idle.
     */
#ifndef NTVDM
    /* this is done in Nt's host heartbeat */
    IDLE_tick();
#endif

    /*
     * Interrupt routine - called from time_strobe event/signal handler.
     * That is called from host_timer_event
     */

#ifndef NTVDM
    /* protect ourselves from shafting a timer-channel in midst-program
     * ... the lock is controlled by timer_inb(),_outb() and _gate()
     */

    if (timelock == LOCKED)
    {
        needtick = ~0;
        return;
    }
#endif

    /* ideal time goes up by the number of timer clocks
     * equivalent to the interval between calls to 'time_tick'
     * (we assume these calls appear at perfectly spaced intervals ...
     * thus ignoring fluctuations on the host system)
     * The idea is to give an illusion of constant ticks here
     */

    updateIdealTime();

    pcu = &timers[0];
    updateCounter();

    /*
     * Counter 2 is only used for sound, or for timing very short
     * times. For timing short times (~100ms) we need accurate time
     * all the time.
     */

#if defined(NEC_98)
    pcu = &timers[1];
#else    //NEC_98
    pcu = &timers[2];
#endif   //NEC_98
    updateCounter();
}


/*
 * The timer low I/O functions that support the Intel 8253 Counter chip.
 *
 * The Counters are used by the PC in the following ways:
 *
 *      Counter 0  -  Bios time of day function
 *      Counter 1  -  Handler memory refresh
 *      Counter 2  -  Drive Speaker Interface (plus input on PPI)
 *
 */

/*
 * These control the timer chip. they are the interface between the
 * CPU and the timer chip.
 */

void SWTMR_gate IFN2(io_addr, port, half_word, value)
{
#ifdef  NTVDM
    host_ica_lock();
#else
    timelock = LOCKED;
#endif

    emu_8253 (port, GATE_SIGNAL, value);
#ifndef PROD
    if (io_verbose & TIMER_VERBOSE)
    {
        sprintf(buf, "timer_gate() - sending %d to port 0x%x", value, port);
        trace(buf, DUMP_REG);
    }
#endif

#ifdef NTVDM
    host_ica_unlock();
#else
    checktimelock();
#endif
}


void SWTMR_inb IFN2(io_addr, port, half_word *, value)
{
#ifdef NTVDM
    host_ica_lock();
#else
    timelock = LOCKED;
#endif


#if defined(NEC_98)
    pcu = &timers[(port & 7) >> 1];
#else    //NEC_98
    pcu = &timers[port & 3];
#endif   //NEC_98
        if (!pcu->countlatched)
                readCounter();
        switch (pcu->readState)
        {
                case UNREAD:
                        switch (pcu->rl)
                        {
                        case RL_LSB:
                                *value = pcu->latchvaluelsb;
                                pcu->countlatched = 0;  /* Unlatch the value read by inb() */
                                break;
                        case RL_LMSB:
                                *value = pcu->latchvaluelsb;
                                pcu->readState = READMSB;       /* Read LSB, next in read MSB. */
                                break;
                        case RL_MSB:
                                *value = pcu->latchvaluemsb;
                                pcu->countlatched = 0;  /* Unlatch the value read by inb() */
                                break;
                        }
                        break;
                case READMSB:
                        *value = pcu->latchvaluemsb;
                        pcu->countlatched = 0;  /* Unlatch the value read by inb() */
                        pcu->readState = UNREAD;        /* Read MSB, back to unread state. */
                        break;
                case READSTATUS:
                        *value = pcu->latchstatus;
                        pcu->readState = UNREAD;
                        break;
        }
#ifndef PROD
    if (io_verbose & TIMER_VERBOSE)
    {
        sprintf(buf, "timer_inb() - Returning %d(0x%x) for port 0x%x", *value, *value, port);
        trace(buf, DUMP_REG);
    }
#endif
#ifdef NTVDM
    host_ica_unlock();
#else
    checktimelock();
#endif

}


void SWTMR_outb IFN2(io_addr, port, half_word, value)
{
#if defined(NTVDM) || defined(GISP_SVGA)
#ifndef NEC_98
    if (port == 0x4f)   /* dead port used by PS/2 XGA bios for DAC delays */
        return;
#endif   //NEC_98
#ifdef NTVDM
    host_ica_lock();
#endif
#else
    timelock = LOCKED;
#endif

#if defined(NEC_98)
        if(port == 0x77 || port == 0x3fdf)
#else    //NEC_98
    port = port & TIMER_BIT_MASK;
        if(port == 0x43)
#endif   //NEC_98
                controlWordReg(value);
        else
            emu_8253 (port, WRITE_SIGNAL, value);
#ifndef PROD
    if (io_verbose & TIMER_VERBOSE)
    {
        sprintf(buf, "timer_outb() - Value %d to port 0x%x", value, port);
        trace(buf, DUMP_REG);
    }
#endif

#ifdef NTVDM
    host_ica_unlock();
#else
    checktimelock();
#endif

#if defined(NEC_98)
    if( RSBaud ) {
        SetRSBaud( RSBaud );
        RSBaud = 0;
    }
#endif   //NEC_98
}


/* --------------------------------------------------------------------------- */
/*                                                                             */
/*              Return the current DOS tick value based on Timer 0             */
/*                                                                             */
/* --------------------------------------------------------------------------- */

#ifndef NTVDM
GLOBAL ULONG get_DOS_ticks IFN0()
{
        return( timers[0].Count );
}
#endif /* NTVDM */

#ifdef NTVDM
/*
 *  called by host to update the current ideal time
 *  after a block and resume.
 */
void ReinitIdealTime IFN1(struct host_timeval *, t)
{

    /*
     *  Currently these are all time stamped by the same thing!
     */
   LastTimeCounterZero      =
   timers[2].activationTime =
   timers[1].activationTime =
   timers[0].activationTime =
                  idealtime = *t;
   /*
    * Clear out extra pending interrupts
    */
   if (EoiPending) {
       EoiPending = 1;
       }

   EoiIntsPending = 0;

}
#endif




/* **************************************************************************** */
/* **************************************************************************** */
/* **************************************************************************** */

#ifndef NTVDM
/* check whether a time lock (set while application io is being serviced)
 * has blocked out an alarm signal ... call time_tick() to catch up if so
 * ... (time_tick() sets timelock = ~0, and just returns, if it sees the time
 * lock set
 */

LOCAL void checktimelock IFN0()
{
        timelock = UNLOCKED;
        if (needtick)
        {
                needtick = 0;
                time_tick();
        }
}
#endif

/*
 *      emulate the 8253 chip.
 *
 *      emu_8253(port,signal,value)
 *
 *      port    -       port address being accessed
 *                      (port & 3) gives A0,A1 lines
 *
 *      signal  -       WRITE_SIGNAL (outb) or
 *                      GATE_SIGNAL (ppi TIM2GATESPK change)
 *
 *      value   -
 *                      for WRITE_SIGNAL, value = byte being written to chip
 *                      for GATE_SIGNAL,  value = GATE_SIGNAL_LOW or
 *                                                GATE_SIGNAL_RISE
 */


LOCAL void emu_8253 IFN3(io_addr, port, int, signal, half_word, value)
{

        int A0A1;

        /* get address lines A0 and A1 */
#if defined(NEC_98)
        A0A1 = (port & 7) >> 1;
#else    //NEC_98
        A0A1 = port & 3;
#endif   //NEC_98

        /* handle the access */
                pcu = &timers[A0A1];
                (pcu->state)(signal,value);
}


/* if a timer channel is unitialised, this is its associated
 * state function ... simply ignore all accesses in this state
 * A state transition from this state is only possible via
 * the procedure controlReg()
 */



/* handle write access to the control word register.
 * The documentation does not specify what happens if a mode
 * setting control word is issued while a counter is active.
 * In this model, we assume it resets the operation back to
 * the start of a new counter programming sequence
 */

/*ADE*/
#define SELECT_0 0x00
#define SELECT_1 0x01
#define SELECT_2 0x02
#define READ_BACK 0x03

LOCAL void controlWordReg IFN1(half_word, cwd)
{
        int rl,m,channel;
        half_word select_bits;

        /* decode control word */
        channel = (cwd & 0xc0) >> 6;
        if(channel == READ_BACK)
        {
                /* decode read back command */
                select_bits = (cwd & 0xe) >> 1;
                /* first look for counters to latch */
                if (!(cwd & 0x20))
                {
                        /* count bit low so latch selected counters */
                        if (select_bits & 0x01)
                        {
                                /* counter 0 */
                                pcu = &timers[0];
                                readCounter();
                                pcu->countlatched = 1;
                        }
                        if (select_bits & 0x02)
                        {
                                /* counter 1 */
                                pcu = &timers[1];
                                readCounter();
                                pcu->countlatched = 1;
                        }
                        if (select_bits & 0x04)
                        {
                                /* counter 2 */
                                pcu = &timers[2];
                                readCounter();
                                pcu->countlatched = 1;
                        }
                }

                /* now look for the status latch */
                if (!(cwd & 0x10))
                {
                        /* status bit low - status to be latched */
                        if (select_bits & 0x01)
                        {
                                /* counter 0 */
                                pcu = &timers[0];
                                latchStatusValue();
                        }
                        if (select_bits & 0x02)
                        {
                                /* counter 1 */
                                pcu = &timers[1];
                                latchStatusValue();
                        }
                        if (select_bits & 0x04)
                        {
                                /* counter 2 */
                                pcu = &timers[2];
                                latchStatusValue();
                        }
                }
        }
        else
        {
                pcu = &timers[channel];
                rl = (cwd & 0x30) >> 4;


                /* are we simply latching the present count value, or are
                 * programming up a new mode ??
                 */
                if (rl == LATCH)
                {       /* latching present count value */
                        readCounter();
                        pcu->countlatched = 1;
                        return;
                }
                else
                {       /* new mode */
                        if (pcu == &timers[0])
                                timer_int_enabled = FALSE;
                        pcu->countlatched = 0;
                        pcu->tc = 0;
                        pcu->tickadjust = 0;
#ifndef NTVDM
                        pcu->microtick = 0;
                        pcu->saveCount = 0;
#endif

                        m  = (cwd & 0xe)  >> 1;
                        if(m > 5)m -= 4; /* Modes 6 and 7 don't exist - they are intepreted as modes 2 and 3 */
                        pcu->m = m;
                        setTriggerCond();
                        setOutputAfterMode();
                        pcu->bcd = cwd & 1;
                        pcu->rl = rl;
                        pcu->actionOnWtComplete = CounterBufferLoaded;
                        pcu->actionOnGateEnabled = CounterBufferLoaded;
                        pcu->statePriorWt = pcu->state;
                        pcu->state = waitingFor1stWrite;
                }
        }
}

/* latch status ready for reading */
LOCAL void latchStatusValue IFN0()
{
        /*
        *       Status byte is of format :
        *
        *       |OUT|Null Count|RW1|RW0|M2|M1|M0|BCD|
        *
        */

        /* NULL COUNT still only approximated. Who cares? */
        pcu->latchstatus = (unsigned char)(
                  (pcu->out.startLogicLevel<<7)
                | (pcu->newCount == AVAILABLE ? (1<<6) : 0)
                | (pcu->rl<<4)
                | (pcu->m<<1) | (pcu->bcd));
        pcu->readState = READSTATUS;
}

/* set up flag establishing type of trigger condition for
 * counter bassed on its mode
 */

LOCAL void setTriggerCond IFN0()
{
        switch (pcu->m)
        {
        case RATE_GEN:
        case SQUAREWAVE_GEN:
        case SW_TRIG_STROBE:
        case INT_ON_TERMINALCOUNT:
                pcu->trigger = LEVEL;
                return;
        case PROG_ONESHOT:
        case HW_TRIG_STROBE:
                pcu->trigger = EDGE;
                return;
        }
}


/* transfer count buffer into counter */

LOCAL void loadCounter IFN0()
{
        unsigned long modulo;
#ifndef NTVDM
        IU32 maxback;
#endif

        /* set counter */
        /* get correct modulo to use for counter calculations */
        modulo = (pcu->outbmsb << 8) | pcu->outblsb;
        if (pcu->bcd == BCD)
        {
                if(modulo)
                        modulo = bcd_to_bin((word)modulo);
                else
                        modulo = 10000L;
        }
        else
                if(!modulo)modulo = 0x10000L;

        /* Beware - Count and initialCount are different sizes, so don't merge the next two lines!! */
        pcu->initialCount = modulo;
        pcu->Count = (word)modulo;

        /*
         * not at terminal count anymore, so reflect this fact by resetting
         * tc (which I think means "reached terminal count"
         */
        pcu->tc = 0;
        pcu->newCount = USED;
        if(pcu == &timers[0])
        {
            /* Get rid of pending interrupts - these may no longer me appropriate - eg. in Sailing */
            ica_hw_interrupt_cancel(ICA_MASTER,CPU_TIMER_INT);
#ifdef NTVDM
            RealTimeCountCounterZero = pcu->Count;
#endif

#ifndef NTVDM
                /* how many interrupts in MAX_BACK_SECS seconds? */
                maxback = (1193180 * MAX_BACK_SECS) / modulo;

                if (maxback > max_backlog)
                {
#ifndef PROD
                        fprintf(trace_file, "setting max backlog to %d\n", maxback);
#endif
                        max_backlog = maxback;
                }
#endif

        }

#if defined(NTVDM) && !defined(PROD)
        if (NtTicTesting)  {
            printf("Timer %d modulo=%lu %dHz\n",
                    pcu-timers, modulo, 1193180/modulo);
            }
#endif /*NTVDM & !PROD*/
}

/* read counter into latch, ready for next read */

LOCAL void readCounter IFN0()
{
        int countread;

        updateCounter();

#ifdef NTVDM
           /*
            *  Timer Zero is a special case, as it is maintaned
            *  by IdealInterval, and not RealTime. We must give
            *  real time granularity
            */
        countread = pcu == &timers[0] ? (JoyTimeLatchPending ?
                                        JoyTimeCountCounterZero :
                                        RealTimeCountCounterZero)
                                      : pcu->Count;
    JoyTimeLatchPending = FALSE;
        if (pcu->bcd == BCD)
            countread = bin_to_bcd(countread);

#else
        if(pcu->bcd == BCD)
                countread = bin_to_bcd(pcu->Count);
        else
                countread = pcu->Count;
#endif

        pcu->latchvaluemsb = countread >> 8;
        pcu->latchvaluelsb = countread & 0xff;
        sure_note_trace1(TIMER_VERBOSE,"reading count %d",pcu->Count);
}

/* active counter (mode 0) lost its gate ... gate has now
 * reappeared. Either continue 'active' counting (pre terminal count)
 * or continue decrementing, but with OUT signal at high indefinitely.
 */
LOCAL GATENABLED_FUNCTION resumeCounting0onGate IFN0()
{
        if (pcu->freezeCounter)
        {
                pcu->freezeCounter = 0;
                timestamp();
        }
        if (pcu->newCount == AVAILABLE)
                loadCounter();
        if (!pcu->tc)
        {
                timestamp();
                pcu->stateOnGate = Counting0;
                runCount();
        }
        else
                pcu->state = Counting0;
}

LOCAL GATENABLED_FUNCTION resumeCounting0 IFN0()
{
        int doadjust = 0;
        if (pcu->freezeCounter)
        {
                pcu->freezeCounter = 0;
                timestamp();
        }
        if (pcu->newCount == AVAILABLE)
        {
                doadjust = 1;
                loadCounter();
        }
        if (!pcu->tc)
        {
                pcu->stateOnGate = Counting0;
                runCount();
        }
        else
        {
                pcu->state = Counting0;
                if (doadjust)
                        pcu->Count -= pcu->tickadjust;
        }
}

LOCAL GATENABLED_FUNCTION resumeCounting_2_3_4_onGate IFN0()
{
        /* for modes 2 and 3, ought to wait until counter
         * completes its current period, but we cant be as accurate
         * as that
         */
        if (pcu->newCount == AVAILABLE)
                loadCounter();
        if (pcu->m == RATE_GEN || pcu->m == SQUAREWAVE_GEN)
                pcu->stateOnGate = Counting_2_3;
        else
                pcu->stateOnGate = Counting_4_5;
        timestamp();
        runCount();
}

LOCAL GATENABLED_FUNCTION resumeCounting_2_3_4 IFN0()
{
        /* for modes 2 and 3, ought to wait until counter
         * completes its current period, but we cant be as accurate
         * as that
         */
        if (pcu->newCount == AVAILABLE)
        {
                pcu->delay = pcu->Count;
                loadCounter();
        }
        if (pcu->m == RATE_GEN || pcu->m == SQUAREWAVE_GEN)
                pcu->stateOnGate = Counting_2_3;
        else
                pcu->stateOnGate = Counting_4_5;
        runCount();
}


LOCAL GATENABLED_FUNCTION runCount IFN0()
{
        unsigned long lowticks, hiticks;
        unsigned long adjustedCount;    /* For count = 0 and BCD */

        adjustedCount = timer_conv(pcu->Count);
        pcu->state = pcu->stateOnGate;
        switch (pcu->m)
        {
        case INT_ON_TERMINALCOUNT:
                outputWaveForm(pcu->delay,adjustedCount,
                        INDEFINITE,STARTLO,NOREPEAT);
                return;
        case PROG_ONESHOT:
                loadCounter();
                outputWaveForm(pcu->delay,adjustedCount,
                        INDEFINITE,STARTLO,NOREPEAT);
                pcu->Count -= pcu->tickadjust;
                return;
        case RATE_GEN:
                loadCounter();
                outputWaveForm(pcu->delay,1,
                        adjustedCount-1,STARTHI,REPEAT);
                pcu->Count -= pcu->tickadjust;
                return;
        case SQUAREWAVE_GEN:
                loadCounter();
                if (!(pcu->Count & 1))
                        lowticks = hiticks = adjustedCount >> 1;
                else
                {
                        lowticks = (adjustedCount - 1) >> 1;
                        hiticks = (adjustedCount + 1) >> 1;
                }
                outputWaveForm(pcu->delay,lowticks, hiticks,STARTHI,REPEAT);
                pcu->Count -= pcu->tickadjust;
                return;
        case SW_TRIG_STROBE:
                outputWaveForm(pcu->delay,1, adjustedCount,STARTHI,NOREPEAT);
                return;
        case HW_TRIG_STROBE:
                loadCounter();
                outputWaveForm(pcu->delay,1, adjustedCount,STARTHI,NOREPEAT);
                return;
        }
}


/* return to state waiting for gate signal */

LOCAL void resumeAwaitGate IFN0()
{
        pcu->actionOnWtComplete = timererror;
        pcu->state = awaitingGate;
        awaitingGate(GATE_SIGNAL,pcu->gate);
}



/* ========================= OUTPUT SIGNAL UTILITIES ====================== */
/* ========================= OUTPUT SIGNAL UTILITIES ====================== */
/* ========================= OUTPUT SIGNAL UTILITIES ====================== */

/* set state of output signal after a mode command has
 * been programmed (see pages 6-266 - 6-268 of Intel manual 231306-001)
 */

LOCAL void setOutputAfterMode IFN0()
{
        switch (pcu->m)
        {
        case INT_ON_TERMINALCOUNT:
                outputLow( /*INDEFINITE*/ );
                return;
        case PROG_ONESHOT:
        case RATE_GEN:
        case SQUAREWAVE_GEN:
        case SW_TRIG_STROBE:
        case HW_TRIG_STROBE:
                outputHigh( /*INDEFINITE*/ );
                return;
        }
}


/* set output state low ... inform sound chip emulation if
 * channel 2
 */

LOCAL void outputLow IFN0()
{
        outputWaveForm(0,INDEFINITE,0,STARTLO,NOREPEAT);
}


/* set output state high ... inform sound chip emulation if
 * channel 2
 */

LOCAL void outputHigh IFN0()
{
        outputWaveForm(0,0,INDEFINITE,STARTHI,NOREPEAT);
}


/* when the wave form is deterministic, tell the sound emulation about it.
 *      delay           -       if <>0, don't start this waveform for
 *                              this number of counter clocks.
 *      lowclocks       -       the #.counter clocks to stay low for
 *      hiclocks        -       the #.counter clocks to stay high for
 *      (either parameter may be INDEFINITE duration)
 *      lohi            -       0 ==> start at low logic level
 *                      -     <>0 ==> start at high logic level
 *      repeat          -       0 ==> don't
 *                            <>0 ==> repeat.
 *
 *      (n.b; 1 counter clock period = 1.19318 usecs)
 */

LOCAL void outputWaveForm IFN5(unsigned int, delay, unsigned long, lowclocks,
        unsigned long, hiclocks, int, lohi, int, repeat)
{
#ifdef DOCUMENTATION
        int ch;
#endif /* DOCUMENTATION */
        pcu->out.startLogicLevel = lohi;
        pcu->out.repeatWaveForm = repeat;
        pcu->out.clocksAtLoLogicLevel = lowclocks;
        pcu->out.clocksAtHiLogicLevel = hiclocks;
        if (repeat == REPEAT)
                pcu->out.period = lowclocks + hiclocks;
#if defined(NEC_98)
        if (pcu == &timers[1])
#else    //NEC_98
        if (pcu == &timers[2])
#endif   //NEC_98
        {
                host_timer2_waveform(delay,lowclocks,hiclocks,lohi,repeat);
        }
        pcu->delay = 0;

#ifdef DOCUMENTATION
        if (pcu==&timers[0])
                ch = 0;
        if (pcu==&timers[1])
                ch = 1;
        if (pcu==&timers[2])
                ch = 2;
        sprintf(buf,"ch.%d waveform:delay %d lo %d hi %d lohi %d repeat %d\n",
                ch,delay,lowclocks,hiclocks,lohi,repeat);
        trace(buf,0);
#endif /* DOCUMENTATION */
}

/* time stamp the counter unit ... it is counting from this time
 */

LOCAL void timestamp IFN0()
{
#ifdef NTVDM
       /* update counter zero time stamp */
       if (pcu == &timers[0]) {
           host_GetSysTime(&LastTimeCounterZero);
           }
#else
        /* Initialise lastTicks before referencing it in updateCount() */
        /* Makes Norton SYSINFO version 5.0 work on fast (HP) machines */
        pcu->lastTicks = 0 ;
#endif
        /* Go and get the time since it was activated */
        (*pcu->getTime)(&pcu->activationTime);
}

LOCAL UNBLOCK_FUNCTION timererror IFN0()
{
        always_trace0("time error!!!!");
}

/* *************** COUNTER UPDATING FUNCTIONS FOR NON_IDLE COUNTERS **********/
/* *************** COUNTER UPDATING FUNCTIONS FOR NON_IDLE COUNTERS **********/
/* *************** COUNTER UPDATING FUNCTIONS FOR NON_IDLE COUNTERS **********/


/* ************************ STATE FUNCTIONS ********************************* */
/* ************************ STATE FUNCTIONS ********************************* */
/* ************************ STATE FUNCTIONS ********************************* */

/*
 * STATE_FUNCTION uninit();
 * STATE_FUNCTION awaitingGate();
 * STATE_FUNCTION waitingFor1stWrite();
 * STATE_FUNCTION waitingFor2ndWrite();
 * STATE_FUNCTION Counting0();
 * STATE_FUNCTION Counting_4_5();
 * STATE_FUNCTION Counting1();
 * STATE_FUNCTION Counting_2_3();
 */

LOCAL STATE_FUNCTION uninit IFN2(int, signal, half_word, value)
{
        if (signal == GATE_SIGNAL)
                pcu->gate = value;
}

LOCAL STATE_FUNCTION awaitingGate IFN2(int, signal, half_word, value)
{
        switch (signal)
        {
        case GATE_SIGNAL:
                pcu->gate = value;
                if (value == GATE_SIGNAL_LOW)
                        return;

                /* this is pathological ... should never have to
                 * wait for gate for channel 0
                 */
                if (pcu == &timers[0])
                        timer_int_enabled = TRUE;

                (pcu->actionOnGateEnabled)();
                return;
        case WRITE_SIGNAL:
                pcu->actionOnWtComplete = resumeAwaitGate;
                pcu->statePriorWt = pcu->state;
                waitingFor1stWrite(signal,value);
                return;
        }
}

/*
 * Perform first of (probably) 2 writes.
 * This is either called directly when some other state is
 * written to, or set up as the current state when the timer mode is changed.
 * If the timer is in 'read/write 2 bytes' mode, set the timer state
 * to 'waiting for second byte'.
 */

LOCAL STATE_FUNCTION waitingFor1stWrite IFN2(int, signal, half_word, value)
{
        switch (signal)
        {
        case GATE_SIGNAL:
                /* remember gate signal state */
                pcu->gate = value;
                return;
        case WRITE_SIGNAL:
                switch (pcu->rl)
                {
                case RL_LSB:
                        pcu->outblsb = value;
                        /* Zero the most signifcant byte. */
                        pcu->outbmsb = 0;
                        pcu->newCount = AVAILABLE;
                        WtComplete();
                        return;
                case RL_LMSB:
                        pcu->outblsb = value;
                        pcu->state = waitingFor2ndWrite;
                        return;
                case RL_MSB:
                        pcu->outbmsb = value;
                        /* Zero the least signifcant byte. */
                        pcu->outblsb = 0;
                        pcu->newCount = AVAILABLE;
                        WtComplete();
                        return;
                }
        }
}

/*
 * Write second byte to timer and unblock it.
 */

LOCAL STATE_FUNCTION waitingFor2ndWrite IFN2(int, signal, half_word, value)
{
        switch (signal)
        {
        case GATE_SIGNAL:
                /* remember gate signal state */
                pcu->gate = value;
                return;
        case WRITE_SIGNAL:
                pcu->newCount = AVAILABLE;
                pcu->outbmsb = value;
                WtComplete();
                return;
        }
}


/*
 * the full complement of bytes has been read/loaded. During this
 * phase, the gate signal might have been removed ... if so,
 * change state to wait for an enabling gate signal. Otherwise
 * take appropriate action to get back to previous state
 */

LOCAL void WtComplete IFN0()
{
        if (pcu->gate == GATE_SIGNAL_LOW && pcu->trigger == LEVEL)
        {
                pcu->state = awaitingGate;
                awaitingGate(GATE_SIGNAL, pcu->gate);
        }
        else
                (pcu->actionOnWtComplete)();
}

/* active counter (Interrupt on Terminal Count)
 * if the gate is lost, then
 *      set the output indefinitely high if at terminal count, or
 *      indefinitely low if still counting (i.e; extend current low
 *      level signal duration).
 *      if count reprogrammed during this time, this new count will be
 *      used on next trigger (gate).
 * else
 *      if new count programmed, stop counter on receiving 1st byte.
 *      start new count on second byte. (done by resumeCounting0())
 */

LOCAL STATE_FUNCTION Counting0 IFN2(int, signal, half_word, value)
{
        pcu->actionOnGateEnabled = resumeCounting0onGate;
        pcu->actionOnWtComplete = resumeCounting0;

        switch (signal)
        {
        case GATE_SIGNAL:
                if (value == GATE_SIGNAL_HIGH)
                        return;
                /* we're about to freeze timer channel ...
                 * get an up to date count. This might change the
                 * state of the counter.
                 */
                updateCounter();
                pcu->gate = value;
                if (pcu->tc)
                        outputHigh();
                else
                        outputLow();
                pcu->state = awaitingGate;
                return;
        case WRITE_SIGNAL:
                pcu->freezeCounter = 1;
                updateCounter();
                if (pcu->tc)
                        outputHigh();
                else
                        outputLow();
                pcu->statePriorWt = pcu->state;
                waitingFor1stWrite(signal,value);
                return;
        }
}

/* active counter (programmable One-Shot)
 * if cvounter loses its gate, then simply wait for retrigger
 * to start off count again.
 */

LOCAL STATE_FUNCTION Counting1 IFN2(int, signal, half_word, value)
{
        pcu->actionOnGateEnabled = startCounting;
        pcu->actionOnWtComplete = resumeCounting_1_5;

        switch (signal)
        {
        case GATE_SIGNAL:
                /* ignore transition to low on trigger.
                 * any rising edge retriggers the counter.
                 */
                if (value == GATE_SIGNAL_LOW)
                        return;
                pcu->gate = GATE_SIGNAL_HIGH;
                pcu->stateOnGate = Counting1;
                timestamp();
                runCount();
                return;
        case WRITE_SIGNAL:
                pcu->statePriorWt = pcu->state;
                waitingFor1stWrite(signal,value);
                return;
        }
}

LOCAL UNBLOCK_FUNCTION resumeCounting_1_5 IFN0()
{
        /* if terminal count has been reached, wait for the next
         * trigger ... any new count value programmed will be used
         * then.
         * Otherwise, even if new count is available, it still won't
         * be used until next trigger
         */
        if (pcu->gate == GATE_SIGNAL_RISE)
        {
                pcu->state = Counting1;
                if (pcu->m == HW_TRIG_STROBE)
                        pcu->state = Counting_4_5;
                return;
        }

        if (pcu->tc)
                pcu->state = awaitingGate;
        else
        {
                pcu->state = Counting1;
                if (pcu->m == HW_TRIG_STROBE)
                        pcu->state = Counting_4_5;
        }
}

LOCAL STATE_FUNCTION Counting_2_3 IFN2(int, signal, half_word, value)
{
        pcu->actionOnGateEnabled = resumeCounting_2_3_4_onGate;
        pcu->actionOnWtComplete = resumeCounting_2_3_4;

        switch (signal)
        {
        case GATE_SIGNAL:
                if (value == GATE_SIGNAL_HIGH)
                        return;
                /* we're about to freeze timer channel ...
                 * get an up to date count. This might change the
                 * state of the counter.
                 */
                updateCounter();
                pcu->gate = value;
                outputHigh();
                pcu->state = awaitingGate;
                return;
        case WRITE_SIGNAL:
                pcu->statePriorWt = pcu->state;
                waitingFor1stWrite(signal,value);
                return;
        }
}

LOCAL STATE_FUNCTION Counting_4_5 IFN2(int, signal, half_word, value)
{
        pcu->actionOnGateEnabled = resumeCounting_2_3_4_onGate;
        pcu->actionOnWtComplete = resumeCounting_2_3_4;
        if (pcu->m == HW_TRIG_STROBE)
        {
                pcu->actionOnGateEnabled = resumeCounting_1_5;
                pcu->actionOnWtComplete = resumeCounting_1_5;
        }

        switch (signal)
        {
        case GATE_SIGNAL:
                if (value == GATE_SIGNAL_HIGH)
                        return;
                /* we're about to freeze timer channel ...
                 * get an up to date count. This might change the
                 * state of the counter.
                 */
                updateCounter();
                pcu->gate = value;
                outputHigh();
                pcu->state = awaitingGate;
                return;
        case WRITE_SIGNAL:
                pcu->statePriorWt = pcu->state;
                waitingFor1stWrite(signal,value);
                return;
        }
}

/* ****************** UNBLOCK FUNCTIONS ************************************* */
/* ****************** UNBLOCK FUNCTIONS ************************************* */
/* ****************** UNBLOCK FUNCTIONS ************************************* */

/* upon reaching this state, the timer's count register can be
 * loaded (as per 'rl') ... and it can potentially start counting
 * depending upon the state of its gate signal.
 * If it can begin counting, then setup the output waveform that will
 * appear at the timer channel's OUT signal.
 * (If this channel is for sound, the waveform is exactly known)
 */

LOCAL UNBLOCK_FUNCTION CounterBufferLoaded IFN0()
{
        unsigned long lowticks, hiticks, adjustedCount;
        pcu->actionOnWtComplete = timererror;
        loadCounter();

#ifdef DOCUMENTATION
        /*
         * Output state of timer if tracing.
         * Currently dumpCounter has no effect, so just leave this in
         * case anyone wants to implement it properly.
         */

        if (io_verbose & TIMER_VERBOSE)
        {
                dumpCounter();
        }
#endif /* DOCUMENTATION */

        if (pcu->gate != GATE_SIGNAL_LOW)
        {
#if defined(NEC_98)
                if (pcu == &timers[2])
//                  SetRSBaud( pcu->outblsb + (pcu->outbmsb) * 0x100 );
                    RSBaud = pcu->outblsb + (pcu->outbmsb) * 0x100;
                if (pcu == &timers[1])
                    SetBeepFrequency( (DWORD)pcu->outblsb + (pcu->outbmsb) * 0x100) ;
#endif   //NEC_98
                if (pcu == &timers[0])
                        timer_int_enabled = TRUE;
                timestamp();
                adjustedCount = timer_conv(pcu->Count);
                switch (pcu->m)
                {
                case INT_ON_TERMINALCOUNT:
                        outputWaveForm(pcu->delay,adjustedCount,
                                INDEFINITE,STARTLO,NOREPEAT);
                        pcu->Count -= pcu->tickadjust;
                        pcu->state = Counting0;
                        return;
                case PROG_ONESHOT:
                        outputWaveForm(pcu->delay,adjustedCount,
                                INDEFINITE,STARTLO,NOREPEAT);
                        pcu->Count -= pcu->tickadjust;
                        pcu->state = Counting1;
                        return;
                case RATE_GEN:
                        outputWaveForm(pcu->delay,1,
                                adjustedCount-1,STARTHI,REPEAT);
                        pcu->Count -= pcu->tickadjust;
                        pcu->state = Counting_2_3;
                        return;
                case SQUAREWAVE_GEN:
                        if (!(pcu->Count & 1))
                                lowticks = hiticks = adjustedCount >> 1;
                        else
                        {
                                lowticks = (adjustedCount - 1) >> 1;
                                hiticks = (adjustedCount + 1) >> 1;
                        }
                        outputWaveForm(pcu->delay,lowticks,
                                hiticks,STARTHI,REPEAT);
                        pcu->Count -= pcu->tickadjust;
                        pcu->state = Counting_2_3;
                        return;
                case SW_TRIG_STROBE:
                case HW_TRIG_STROBE:
                        outputWaveForm(pcu->delay,1,
                                adjustedCount,STARTHI,NOREPEAT);
                        pcu->Count -= pcu->tickadjust;
                        pcu->state = Counting_4_5;
                        return;
                }
        }
        else
                if (pcu == &timers[0])
                        timer_int_enabled = FALSE;
                pcu->state = awaitingGate;
                pcu->actionOnGateEnabled = startCounting;
                switch (pcu->m)
                {
                case INT_ON_TERMINALCOUNT:
                        pcu->stateOnGate = Counting0;
                        return;
                case PROG_ONESHOT:
                        pcu->stateOnGate = Counting1;
                        return;
                case RATE_GEN:
                case SQUAREWAVE_GEN:
                        pcu->stateOnGate = Counting_2_3;
                        return;
                case SW_TRIG_STROBE:
                case HW_TRIG_STROBE:
                        pcu->stateOnGate = Counting_4_5;
                        return;
                }
}

LOCAL void startCounting IFN0()
{
        timestamp();
        runCount();
}

#ifndef NTVDM
/* calculate the number of 8253 clocks elapsed since counter was last
 * activated
 */

LOCAL unsigned long clocksSinceCounterActivated IFN1(struct host_timeval *, now)
{
    struct host_timeval *first;
    register unsigned long usec_val, nclocks;
    register unsigned int secs;
#if defined(NEC_98)
    unsigned short bios_flag;
#endif   //NEC_98

    first = &pcu->activationTime;
    (*pcu->getTime)(now);

    /* calculate #.usecs elapsed */

    secs = (int)(now->tv_sec - first->tv_sec);
    switch (secs)
    {
    case 0:  usec_val = now->tv_usec - first->tv_usec;
#ifndef PROD
            if (io_verbose & TIMER_VERBOSE)
                    if ( usec_val == 0 )
                        trace("clocksSinceCounterActivated() == 0 !", 0);
#endif
#if defined(NEC_98)
            sas_loadw(BIOS_NEC98_BIOS_FLAG,&bios_flag);
            if(bios_flag & 0x8000)
                nclocks = (usec_val * TIMER_CLOCK_DENOM_8) / TIMER_CLOCK_NUMER;
            else
                nclocks = (usec_val * TIMER_CLOCK_DENOM_10) / TIMER_CLOCK_NUMER;
#else    //NEC_98
             nclocks  = (usec_val * TIMER_CLOCK_DENOM) / TIMER_CLOCK_NUMER;
#endif   //NEC_98
             break;

    case 1:  usec_val = 1000000L + now->tv_usec - first->tv_usec;
#if defined(NEC_98)
            sas_loadw(BIOS_NEC98_BIOS_FLAG,&bios_flag);
            if(bios_flag & 0x8000)
                nclocks = (usec_val * TIMER_CLOCK_DENOM_8) / TIMER_CLOCK_NUMER;
            else
                nclocks = (usec_val * TIMER_CLOCK_DENOM_10) / TIMER_CLOCK_NUMER;
#else    //NEC_98
             nclocks  = (usec_val * TIMER_CLOCK_DENOM) / TIMER_CLOCK_NUMER;
#endif   //NEC_98
             break;

    default:
             nclocks   = ((now->tv_usec - first->tv_usec) * TIMER_CLOCK_DENOM) / TIMER_CLOCK_NUMER;
             nclocks  += secs * (1000000L * TIMER_CLOCK_DENOM / TIMER_CLOCK_NUMER);
#ifndef PROD
            if (io_verbose & TIMER_VERBOSE) {
                sprintf(buf, "timer[%d]: %d seconds have passed!", pcu-timers, secs);
                trace(buf, DUMP_NONE);
            }
#endif
             break;
    }
    return nclocks;
}

#endif


LOCAL void updateCounter IFN0()
{
#ifndef NTVDM
    unsigned long nticks;
    struct host_timeval now;
#endif /* NTVDM */
    unsigned long wrap;
#if defined(NEC_98)
    int         save_tc;
#endif   //NEC_98

        switch (pcu->m)
        {
        case INT_ON_TERMINALCOUNT:
        case RATE_GEN:
        case SQUAREWAVE_GEN:
                if (pcu->gate == GATE_SIGNAL_LOW)
                        return;
#ifdef NTVDM
                wrap = updateCount();
#else
                nticks = clocksSinceCounterActivated(&now);
                updateCount(nticks, &wrap,&now);
#endif
                if (wrap)
                        pcu->tickadjust = pcu->Count;
                if (pcu->m == INT_ON_TERMINALCOUNT && wrap)
#if defined(NEC_98)
                        save_tc = pcu->tc;
#else   //NEC_98
                        pcu->tc = 1;
#endif   //NEC_98
                if (pcu == &timers[0] && wrap){
                        if (pcu->m != INT_ON_TERMINALCOUNT)
                                issueIREQ0((unsigned int)wrap);
                        else
                                issueIREQ0(1);
#ifdef HUNTER
                        timer_batch_count = wrap;
#endif

                }
                return;
        case PROG_ONESHOT:
        case SW_TRIG_STROBE:
        case HW_TRIG_STROBE:
                if (pcu->tc)
                        return;
#ifdef NTVDM
                wrap = updateCount();
#else
                nticks = clocksSinceCounterActivated(&now);
                updateCount(nticks, &wrap,&now);
#endif
                if (wrap)
                {
                        pcu->Count = 0;
                        pcu->tc = 1;
#ifdef NTVDM
                        RealTimeCountCounterZero = 0;
#endif

                }
#ifdef HUNTER
                if (pcu == &timers[0]){
                        timer_batch_count = wrap;
                }
#endif
                return;
        }
}


#ifndef NTVDM
#ifndef DELAYED_INTS
/*
 *      timer_no_longer_too_soon() - this is the function invoked by the quick event manager
 *      "HOST_TIMER_TOOLONG_DELAY" instructions after a hardware interrupt is generated. It
 *      clears the variable "too_soon_after_previous" to allow more interrupts to be
 *      generated and kicks off an immediate one if any have been suppressed this time.
 */
LOCAL void timer_no_longer_too_soon IFN1(long, dummy)
{
        UNUSED(dummy);

        too_soon_after_previous = FALSE;
        if (ticks_lost_this_time){
                /* At least one tick was suppressed... so send another one immediately */
                timer_generate_int (1);
        }
}

/*
 *      timer_generate_int() -The routine to generate a single timer hardware interrupt (and to
 *      schedule a quick event timer call on itself to have the remaining pending interrupts
 *      generated at a later time).
 *
 */
LOCAL void timer_generate_int IFN1(long, n)
{
#if !(defined(GISP_CPU) || defined(CPU_40_STYLE))
        if (getPE()){
                /* Prot mode tick... */
#ifndef PROD
                if (!hack_active){
                        SAVED BOOL first=TRUE;

                        always_trace0 ("PM timer Hack activated.");
                        if (first){
                                always_trace1 ("Min # instrs between interrupts = %d", HOST_TIMER_TOOLONG_DELAY);
                                always_trace1 ("        Nominal instrs_per_tick = %d", instrs_per_tick);
                                always_trace1 ("       adjusted instrs_per_tick = %d", adj_instrs_per_tick);
                                always_trace1 ("  # rm instrs before full speed = %d", n_rm_instrs_before_full_speed);
                                always_trace1 ("     rm ticks before full speed = %d", adj_n_real_mode_ticks_before_full_speed);
                                first = FALSE;
                        }
                }
#endif
                hack_active = TRUE;
                real_mode_ticks_in_a_row = 0;

        }else{
                /* Real Mode Tick... */
                if (hack_active){
                        real_mode_ticks_in_a_row++;
                        if (real_mode_ticks_in_a_row >= adj_n_real_mode_ticks_before_full_speed){
                                hack_active = FALSE;
                                always_trace0 ("PM timer Hack deactivated.");
                        }
                }
        }
#endif  /* ! (GISP_CPU||CPU_40_STYLE) */

        if (hack_active){
                if (!too_soon_after_previous){
                        ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, 1);
                        too_soon_after_previous = TRUE;
                        ticks_lost_this_time = FALSE;
                        add_q_event_i(timer_no_longer_too_soon,HOST_TIMER_TOOLONG_DELAY,0);
                }else{
                        ticks_lost_this_time = TRUE;
#ifndef PROD
                        ticks_ignored++;
                        if (!(ticks_ignored & 0xFF)){
                                always_trace0 ("another 256 ticks lost!");
                        }
#endif
                }
        }else{
#ifndef GISP_CPU
                ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, 1);
        }
}
#else /* GISP_CPU */
#if defined(IRET_HOOKS)
                if (!HostDelayTimerInt(n))
                {       /* no host need to delay this timer int, so generate one now. */
                        ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, 1);
                }

#else /* !IRET_HOOKS */
                /* GISP_CPU doesn't use quick events so use ica_hw_interrupt(,,n). */
                ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, n);
#endif /* IRET_HOOKS */
        }
}
#endif /* GISP_CPU */

#endif /* DELAYED_INTS */

#else   /* NTVDM */


/*
 *  TimerGenerateMultipleInterrupts
 *
 */
void TimerGenerateMultipleInterrupts(long n)
{


    if (!EoiPending) {
        EoiPending += n;
        ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, n);
        }
    else {
        if (n > 5 && (dwWNTPifFlags & COMPAT_TIMERTIC)) {
            n = 5;
            }

        if (EoiIntsPending/n < 19) {   // less than a second behind ?
            EoiIntsPending += n;
            }
        else {
            EoiIntsPending++;
            }
#if defined(NEC_98)
        ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, n);
#endif   //NEC_98
        }
}


#ifndef MONITOR

/* On RISC ports, it is dangerous to call getIF from a non-CPU thread,
   so we replace the call with a peek at the global 'EFLAGS' variable
   until the CPU emulator getIF is made safe.
*/

#undef getIF
#define getIF() (GLOBAL_EFLAGS & 0x200)

#endif /* !MONITOR */


/*  timer_generate_int NTVDM
 *
 */
void timer_generate_int (void)
{
    word lo, hi, wrap;

      /*
       *  For Nt port see if we really need to generate
       *  an int, checking if an app has hooked real-mode
       *  or protect-mode vectors.
       *
       *  If we don't need to do it, then update the bios
       *  Data tic count directly.
       *
       *  WARNING according to sfrost it is not safe to
       *          use sas, because of multithreading.
       */


#if defined(NEC_98)
        ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, 1);
#else   //NEC_98

    hi = * (word *)(Start_of_M_area+0x1c*4+2);
    lo = * (word *)(Start_of_M_area+0x1c*4);
    wrap = (word) *(half_word *)(Start_of_M_area + ((ULONG)hi << 4) + lo);
    if (!getIF() || ((hi != TimerInt1CSeg || lo != TimerInt1COff) && wrap != 0xcf) ||
        *(word *)(Start_of_M_area+0x08*4+2) != TimerInt08Seg ||
        *(word *)(Start_of_M_area+0x08*4)   != TimerInt08Off ||
        (*pNtVDMState & VDM_INT_HOOK_IN_PM))
       {
        TimerGenerateMultipleInterrupts(1);
        }
    else {  /* update Bios Data Area directly */
        ++(*(double_word *)(Start_of_M_area + TIMER_LOW));

            /* Wrap at 24 hours ? */
        if (*(double_word *)(Start_of_M_area + TIMER_LOW) == 0x1800b0)
           {
            *(word *)(Start_of_M_area + TIMER_LOW)  = 0;
            *(word *)(Start_of_M_area + TIMER_HIGH) = 0;
            *(half_word *)(Start_of_M_area+TIMER_OVFL)=1;
           }

            /* decr motor count */
        --(*(half_word *)(Start_of_M_area + MOTOR_COUNT));

            /*  if motor count went to zero turn off the motor */
        if (!*(half_word *)(Start_of_M_area + MOTOR_COUNT))
           {
            *(half_word *)(Start_of_M_area + MOTOR_STATUS) &= 0xF0;
            fla_outb(DISKETTE_DOR_REG, 0x0C);
            }

        if (EoiDelayInUse && !(--EoiDelayInUse))  {
            host_DelayHwInterrupt(CPU_TIMER_INT, 0, 0xFFFFFFFF);
            }
        }
#endif   //NEC_98
}



/*  TimerEoiHook
 *
 *  EoiHook for the timer interrupt used to regulate the flow of
 *  timer interrupts to ensure that ints are not generated too
 *  close together. This routine is invoked by the ica EoiHook
 *  callbacks.
 *
 */
void TimerEoiHook(int IrqLine, int CallCount)
{
    if (EoiPending)
        --EoiPending;

    if (CallCount < 0) {       // interrupts were canceled
        EoiIntsPending = 0;
        EoiPending = 0;
        }
    else if (CallCount) {
#if defined(NEC_98)
        EoiDelayInUse = 2;
#else    //NEC_98
        EoiDelayInUse = 100;
#endif   //NEC_98
        host_DelayHwInterrupt(CPU_TIMER_INT,
                              0,
                              timer_delay_size
                              );
        }
    else if (EoiIntsPending) {
#if defined(NEC_98)
        EoiDelayInUse = 2;
#else    //NEC_98
        EoiDelayInUse = 100;
#endif   //NEC_98
        if (host_DelayHwInterrupt(CPU_TIMER_INT,
                                  EoiIntsPending,
                                  timer_delay_size
                                  ))
           {
            EoiPending = EoiIntsPending;
            }
        EoiIntsPending = 0;
        }
    else {
        if (EoiDelayInUse && !(--EoiDelayInUse))  {
            host_DelayHwInterrupt(CPU_TIMER_INT, 0, 0xFFFFFFFF);
            }
        }

}

#endif /* NTVDM */


#ifndef NTVDM
/*
 * Handle a cranked up timer where multiple interrupts are
 * required per tick. Schedule 'n' ints over a tick. Period
 * stored in quick event argument rather than in global.
 */
LOCAL void timer_multiple_ints IFN1(long, num_ints)
{
        /* generate timer int */
        timer_generate_int(1);

        /* one less to do */
        num_ints --;

        /* any more arrived whilst we were q_ expiring? */
        num_ints += more_timer_mult;
        more_timer_mult = 0;

        /* throw away ints that are going to take more than MAX_BACK_SECS
         * to clear up. (!!!!)
         */
        if (num_ints > max_backlog)
        {
                num_ints = max_backlog;
        }

        /* schedule next int (if required) */
        if (num_ints == 0)
        {
                active_int_event = FALSE;
                 /* 1.193180 usecs per clock */
                max_backlog = (1193180 * MAX_BACK_SECS) / timers[0].initialCount;
        }
        else    /* more work to do */
        {
                /* set new quick_ev off - delay determined by timer wrap rate */
                add_q_event_t(timer_multiple_ints, timer_multiple_delay, num_ints);
        }

}
#endif


LOCAL void issueIREQ0 IFN1(unsigned int, n)
{
        IU16 int_delay; /* delay before handling wrapped int */

#ifndef PROD
static  pig_factor  = 0;
static  time_factor = 0;
#endif

#ifdef PIG
extern  IBOOL ccpu_pig_enabled;
#endif

#ifndef PROD
    if ( time_factor == 0 )
    {
        char *env;

        env = host_getenv("TIMER_FACTOR");
        if ( env )
                time_factor = atoi(env);
        if ( time_factor == 0 )
                time_factor = 1;
#ifdef PIG
        if ( pig_factor == 0 )
        {
                env = host_getenv("PIG_TIMER_FACTOR");
                if ( env )
                        pig_factor = atoi(env);
                if ( pig_factor == 0 )
                        pig_factor = 10;
        }
#else
        pig_factor = 1;
#endif
    }
#endif

    if (ticks_blocked == 0)
    {
#ifndef PROD
#ifdef PIG
                if ( ccpu_pig_enabled ) {
                        ticks_blocked = pig_factor-1;
                } else
#endif
                        ticks_blocked = time_factor-1;
#endif
                if (timer_int_enabled)
                {
#ifdef DELAYED_INTS
                        ica_hw_interrupt_delay(ICA_MASTER,CPU_TIMER_INT, n,
                                HOST_TIMER_INT_DELAY);
#else /* !DELAYED_INTS */

#ifdef NTVDM
                        if (n > 0) {
                            if (n <= 4) {
                                timer_delay_size= (HOST_IDEAL_ALARM) / (n+1);
                            } else {
                                timer_delay_size= (HOST_IDEAL_ALARM - (HOST_IDEAL_ALARM >> 2)) / (n+1);
                            }
                        }


                        if (n == 1) {
                            timer_generate_int();
                            }
                        else if (n > 1){
                            TimerGenerateMultipleInterrupts(n);
                            }
#else /* !NTVDM */


                        /* if we've got a quick event running, add to its workload */
                        if (active_int_event)
                        {
                                /* spread interrupts through system tick */
                                int_delay = SYSTEM_TICK_INTV / (n + 1);
                                if (int_delay < timer_multiple_delay)
                                        timer_multiple_delay = int_delay;
                                more_timer_mult += n;
                        }
                        else
                        {
                                /* ensure multiple delay restarts at sensible speed */
                                timer_multiple_delay = SYSTEM_TICK_INTV >> 1;
                                if (n == 1)
                                {
                                        timer_generate_int(1);
                                }
                                else
                                {
                                        /* spread interrupts through system tick */
                                        timer_generate_int(1);
                                        timer_multiple_delay = SYSTEM_TICK_INTV / n;
                                        active_int_event = TRUE;
                                        add_q_event_t(timer_multiple_ints, timer_multiple_delay, n-1);
                                }
                        }

#endif /* !NTVDM */
#endif /* !DELAYED_INTS */
                }
    }
    else if (ticks_blocked > 0)
    {
                ticks_blocked--;
    }
}



#ifdef NTVDM
unsigned long clocksSinceCounterUpdate(struct host_timeval *pCurrTime,
                                       struct host_timeval *pLastTime,
                                       word                *pCounter  )
{
     unsigned long clocks, wrap, usecs;
#if defined(NEC_98)
     unsigned long nclocks;
     unsigned short bios_flag;
#endif   //NEC_98


         /*  Calculate usecs elapsed and clocks elapsed since last update
          *
          *  For NT port timer zero's IdealInterval is exact to a modulo
          *  of 65536, for efficiency and accuracy we stick with the exact
          *  number of clocks between IdealIntervals.
          */
     if (pCounter == &timers[0].Count)  { /* update quick way for IdealTime */
        if (pCurrTime->tv_sec  != pLastTime->tv_sec ||
            pCurrTime->tv_usec != pLastTime->tv_usec  )
           {
            *pLastTime = *pCurrTime;
            return 65536/pcu->initialCount;
            }
        else {
            usecs = clocks = 0;
            }
        }
    else {              /* calc diff in usecs and clocks elapsed */
        usecs =  (unsigned long)(pCurrTime->tv_sec - pLastTime->tv_sec);
        if (!usecs) {
            usecs = pCurrTime->tv_usec - pLastTime->tv_usec;
            }
        else if (usecs == 1) {
            usecs = 1000000L - pLastTime->tv_usec + pCurrTime->tv_usec;
            }
        else {
            usecs = pCurrTime->tv_usec - pLastTime->tv_usec +
                    (pCurrTime->tv_sec - pLastTime->tv_sec) * 1000000L;
            }

         /* ... clocks elapsed 1.193180 usecs per clock
          *
          * However, app time is not real time so round down
          * a teency bit by truncating the "180"
          *
          * clocks = (usecs * 1193)/1000  + (usecs * 180)/1000000;
          */

#if defined(NEC_98)
        sas_loadw(BIOS_NEC98_BIOS_FLAG,&bios_flag);
        if(bios_flag & 0x8000)
            nclocks = TIMER_CLOCK_DENOM_8;
        else
            nclocks = TIMER_CLOCK_DENOM_10;
        clocks =  (usecs * nclocks)/1000;
#else    //NEC_98
        clocks =  (usecs * 1193)/1000;
#endif   //NEC_98
        }

         /* how many times did counter wrap ? */
    wrap = clocks/pcu->initialCount;

         /* calc ticks from elapsed clocks */
    clocks = clocks && pcu->initialCount ? clocks % pcu->initialCount : 0;
    *pCounter = (word) (pcu->initialCount - clocks);

       /* if the count wrapped reset Last Update time stamp */
    if (wrap)  {
        *pLastTime = *pCurrTime;

        if ((ULONG)pLastTime->tv_usec < usecs)  {
            pLastTime->tv_sec--;
            pLastTime->tv_usec = 1000000L + pLastTime->tv_usec - usecs;
            }
        else  {
            pLastTime->tv_usec -= usecs;
            }
        }

    return wrap;
}


unsigned long updateCount(void)
{
     unsigned long wrap;
     struct host_timeval curr;


         /*
          * For timer zero, update real time count, time stamp
          */
     if (pcu == &timers[0]) {
         host_GetSysTime(&curr);
         clocksSinceCounterUpdate(&curr,
                                  &LastTimeCounterZero,
                                  &RealTimeCountCounterZero);
         }

          /*
           *  Update the pcu count, time stamps
           */
     (*pcu->getTime)(&curr);
     wrap = clocksSinceCounterUpdate(&curr,
                                     &pcu->activationTime,
                                     &pcu->Count);

     return wrap;
}


unsigned short GetLastTimer0Count(void)
{
    return RealTimeCountCounterZero;
}

unsigned short LatchAndGetTimer0Count(void)
{
    controlWordReg(0);
    return RealTimeCountCounterZero;
}

void SetNextTimer0Count(unsigned short val)
{
    JoyTimeCountCounterZero = val;
    JoyTimeLatchPending = TRUE;
    return;
}

unsigned long GetTimer0InitialCount(void)
{
    return timers[0].initialCount;
}



#else
LOCAL void updateCount IFN3(unsigned long, ticks, unsigned long *, wrap,
        struct host_timeval *, now)
{
        unsigned long modulo = pcu->initialCount;

        /*
         * PCLABS version 4.2 uses counter 2 (the sound channel) to
         * time around 45 ms on a 8MHz 286. On SoftPC we cannot
         * guarantee to go that fast, and so we must wind the tick
         * rate down to ensure that the counter does not wrap. How much
         * we wind down the tick rate is host dependent. The object is
         * to get the test finishing in less than
         * host_timer_2_frig_factor/18 secs.
         *
         * host_timer_2_frig_factor is now redundant. 28/4/93 niall.
         */

#if defined(NEC_98)
        if (pcu == &timers[1]) {
#else    //NEC_98
        if (pcu == &timers[2]) {
#endif   //NEC_98
                /*
                 * PMINFO uses ~counter, so one tick becomes 0.
                 * 2 ticks is just as good. Avoid guessing (frig_factor!).
                 */
                if ((ticks - pcu->lastTicks) == 0)
                        ticks = 2;
        }

        /* if the counter has been read too quickly after its last
         * access, then the host may not show any visible change in
         * host time ... in which case we just guess at a suitable
         * number of elapsed ticks.
         */

        if ((long)(ticks - pcu->lastTicks) <= 0){
                ticks = guess();
        }else{
                throwaway();
                pcu->lastTicks = ticks;
        }

        /* the counter holds some count down value ...
         * if the number of 8253 clocks elapsed exceeds this amount
         * then the counter must have wrapped
         */

        if ( ticks < modulo ) {
                *wrap = 0;
        } else {
                *wrap = 1;
                ticks -= modulo;

                if ( pcu->m == INT_ON_TERMINALCOUNT )
                        modulo = 0x10000L;

                if ( ticks >= modulo ) {
                        *wrap += ticks/modulo;
                        ticks %= modulo;

#ifndef PROD
                        if (io_verbose & TIMER_VERBOSE)
                            if ( pcu->m == INT_ON_TERMINALCOUNT ) {
                                sprintf(buf, "%lx wraps for timer[%d]", *wrap, pcu-timers);
                                trace(buf, DUMP_NONE);
                        }
#endif
                }
        }

        /* calculate new counter value */
        pcu->Count = (word)(modulo-ticks);

        /* calculate time at which last wrap point occurred, and
         * use this to stamp the counter
         */

        if (*wrap)
                setLastWrap((unsigned int)(modulo-pcu->Count),now);

}



/* calculate time for last wrap around of counter, and use this
 * to mark counter activation time.
 */

LOCAL void setLastWrap IFN2(unsigned int, nclocks, struct host_timeval *, now)
{
        struct host_timeval *stamp;
        unsigned long usecs;
#if defined(NEC_98)
        unsigned short bios_flag;
#endif   //NEC_98

        stamp  = &pcu->activationTime;
        *stamp = *now;
#if defined(NEC_98)
        sas_loadw(BIOS_NEC98_BIOS_FLAG,&bios_flag);
        if(bios_flag & 0x8000)
            usecs = ((unsigned long)nclocks * TIMER_CLOCK_NUMER) / TIMER_CLOCK_DENOM_8;
        else
            usecs = ((unsigned long)nclocks * TIMER_CLOCK_NUMER) / TIMER_CLOCK_DENOM_10;
#else    //NEC_98
        usecs  = ((unsigned long)nclocks * TIMER_CLOCK_NUMER) / TIMER_CLOCK_DENOM;
#endif   //NEC_98

        if (stamp->tv_usec < usecs)
        {
                stamp->tv_sec--;
                stamp->tv_usec += 1000000L;
        }
        stamp->tv_usec -= usecs;

        pcu->lastTicks = nclocks;
}

#endif  /* NTVDM*/



#ifndef NTVDM
/*
 * If the host timer gives the same result as last time it was called,
 * we must give the illusion that time has passed.
 * The algorithm uesd is to keep track of how often we have to guess
 * between host timer ticks, and to assume that guesses should be evenly
 * distributed between host ticks, ie. the time between two guesses should be:
 *      Guess ticks = hosttickinterval/nguesses
 * If we find that the total guessed time is getting dangerously near to being the time
 * between two host ticks, we start reducing the guess tick interval so as to avoid
 * guessing a total time that is too large.
 *
 * From observation, applications use the timer in both coarse and fine 'modes'.
 * The coarse mode is the hardware interrupt handler and then in between
 * interrupts, the timer is polled to detect time passing (hence guess below).
 * The fine mode polling does not commence until some portion of the tick time
 * has elapsed - probably as the coarse int handler will consume some of the
 * time. If guess() bases its timefrig over the whole tick, then given the
 * above behaviour, a polling counter can reach tick end time before the int
 * is delivered. This can fool applications (e.g. Win 3.1 VTD) into having
 * time pass at the wrong rate (approx double for Win 3.1). By calculating
 * the timefrig on most (7/8) of the tick period, this problem is avoided.
 */

LOCAL unsigned long guess IFN0()
{
        if (!pcu->microtick)
        {
                pcu->saveCount = pcu->Count;
                pcu->timeFrig = ((ticksPerIdealInterval * 7) >> 3) / pcu->guessesPerHostTick;      /* guesses over 7/8 of tick */
#ifndef PROD
                if (io_verbose & TIMER_VERBOSE) {
                        sprintf(buf, "guess init timer[%d]: timeFrig = %lx", pcu-timers, pcu->timeFrig);
                        trace(buf, DUMP_NONE);
                }
#endif
        }
        if(pcu->guessesSoFar++ > pcu->guessesPerHostTick)
        {
        /*
         * PC Program is reading the timer more often than in the last timer tick, so need to
         * decay timeFrig to avoid too much 'time' passing between host ticks
         */
                pcu->timeFrig = (pcu->timeFrig >> 1) + 1;
#ifndef PROD
                if (io_verbose & TIMER_VERBOSE) {
                        sprintf(buf, "guess decay: timeFrig = %lx", pcu->timeFrig);
                        trace(buf, DUMP_NONE);
                }
#endif
        }
        pcu->microtick += pcu->timeFrig;
        return (pcu->microtick + pcu->lastTicks);
}


/*
 * After a few (maybe none) guesses, the host timer has finally ticked.
 * Try and work out a good frig factor for the next few guesses, based
 * on the number of guesses we had to make.
 */
LOCAL void throwaway IFN0()
{
        pcu->guessesPerHostTick = (pcu->guessesPerHostTick + pcu->guessesSoFar)>>1;
        pcu->guessesSoFar = 2;          /* Handy to count from 2! */
        if (!pcu->microtick)
                return;
#ifndef PROD
    if (io_verbose & TIMER_VERBOSE)
    {
        sprintf(buf, "throwaway: guessesPerHostTick = %d", (int)pcu->guessesPerHostTick);
        trace(buf, DUMP_NONE);
    }
#endif
        pcu->Count = pcu->saveCount;
        pcu->microtick = 0;
}

#endif  /* ndef NTVDM */

LOCAL unsigned  short bin_to_bcd IFN1(unsigned long, val)
{
    register unsigned  short m, bcd, i;

    m = (short)(val % 10000L);
    bcd = 0;
    for (i=0; i<4; i++)
    {
         bcd = bcd | ((m % 10) << (i << 2));
         m /= 10;
    }
    return(bcd);
}

/*
 * convert 4 decade bcd value to binary
 */
LOCAL word bcd_to_bin IFN1(word, val)
{
    register word bin, i, mul;
    bin = 0;
    mul = 1;
    for (i=0; i<4; i++)
    {
        bin += (val & 0xf) * mul;
        mul *= 10;
        val = val >> 4;
    }
    return (bin);
}

/*
 * this routine returns the number of timer clocks equivalent
 * to the input count, allowing for timer mode and down count.
 */

LOCAL unsigned long timer_conv IFN1(word, count)
{
        if (!count)
        {
                if (pcu->bcd == BCD)
                        return 10000L;
                else
                        return 0x10000L;
        }
        else
                return (unsigned long)count;
}


/* this routine returns the current ideal time value ...
 * this is a very coarse resolution time ... it only changes
 * per call to time_tick(). It does however represent what the
 * system time would be given 100% accurate time signal
 * ... this routine gets used for time-stamping if time_tick()
 * is active, otherwise time-stamping is done using
 * getHostSysTime() ... see below.
 */

LOCAL void getIdealTime IFN1(struct host_timeval *, t)
{
        t->tv_sec = idealtime.tv_sec;
        t->tv_usec = idealtime.tv_usec;
}

/* update our ideal time by the period (in usecs) between timer signals
 * from the host as though these were delivered 100% accurately
 */

LOCAL void updateIdealTime IFN0()
{
        idealtime.tv_usec += idealInterval;
        if (idealtime.tv_usec > 1000000L)
        {
                idealtime.tv_usec -=1000000L;
                idealtime.tv_sec++;
        }
}

#ifndef NTVDM

/* get current host system time ... used for time-stamping and
 * querying during io from Intel application
 */

LOCAL void getHostSysTime IFN1(struct host_timeval *, t)
{
        struct host_timezone dummy;
        host_gettimeofday(t, &dummy);

        /*
         * check that we haven't gone back in time.
         */

        if (t->tv_sec < idealtime.tv_sec ||
         (t->tv_usec < idealtime.tv_usec && t->tv_sec == idealtime.tv_sec))
        {
                /*
                 * The real time has fallen behind the ideal time.
                 * This should never happen... If it does we must
                 * stay at the ideal time.
                 */

#ifndef PROD
#ifndef PIG
                sprintf(buf,"TIME WARP!!");
                trace(buf,0);
#endif
#endif
                *t = idealtime;
        }
}
#endif /* !NTVDM */


/*
 * Used to temporarily stop the timer interrupts. PCLABS bench29
 * causes this to be called iff a 80287 is being used.
 */

void    axe_ticks IFN1(int, ticks)
{
#ifndef PROD
        /*
         * No need to axe ticks if timers are disabled by toff2 (if
         * ticks_blocked is negative)
         */
        if (ticks_blocked >=0)
#endif  /* PROD */
                ticks_blocked = ticks;
}

/*
 * Initialization code
 */
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

#if defined(NEC_98)
GLOBAL void IdealTimeInit IFN0()
{
    unsigned short bios_flag;

    idealInterval = HOST_IDEAL_ALARM;
#ifndef NTVDM
    getHostSysTime(&idealtime);
    sas_loadw(BIOS_NEC98_BIOS_FLAG,&bios_flag);
    if(bios_flag & 0x8000)
        ticksPerIdealInterval = (idealInterval * TIMER_CLOCK_DENOM_8) / TIMER_CLOCK_NUMER;
    else
        ticksPerIdealInterval = (idealInterval * TIMER_CLOCK_DENOM_10) / TIMER_CLOCK_NUMER;
#endif
}
#else    //NEC_98
#ifdef SYNCH_TIMERS

GLOBAL void IdealTimeInit IFN0()
{

    extern IU32 Q_timer_restart_val;

    idealInterval = Q_timer_restart_val;

#else

LOCAL void IdealTimeInit IFN0()
{
    idealInterval = HOST_IDEAL_ALARM;

#endif

#ifndef NTVDM
    getHostSysTime(&idealtime);
        ticksPerIdealInterval = (idealInterval * TIMER_CLOCK_DENOM) / TIMER_CLOCK_NUMER;
#endif
}
#endif   //NEC_98

LOCAL void Timer_init IFN0()
{
        int i;
        for (i=0; i<3; i++)
                counter_init(&timers[i]);
#ifdef NTVDM
        timers[0].getTime = getIdealTime;       /* Use the 'ideal' time for timer 0, ie. calls to time_tick */
        timers[1].getTime = host_GetSysTime;    /* We don't really expect anyone to use timer 1 */
        timers[2].getTime = host_GetSysTime;    /* Use real host time for timer 2 */
#else
        timers[0].getTime = getIdealTime;       /* Use the 'ideal' time for timer 0, ie. calls to time_tick */
        timers[1].getTime = getHostSysTime;     /* We don't really expect anyone to use timer 1 */
        timers[2].getTime = getHostSysTime;     /* Use real host time for timer 2 */
#endif
}

LOCAL void counter_init IFN1(COUNTER_UNIT *, p)
{
        p->state = uninit;
        p->initialCount = 0x10000L;     /* Avoid dividing by zero in updateCount()! */
#ifndef NTVDM
        p->guessesPerHostTick = p->guessesSoFar = 2;            /* Handy to count from 2! */
        p->timeFrig = ticksPerIdealInterval / p->guessesPerHostTick;
#endif
}

#if !defined (NTVDM)
#if defined(IRET_HOOKS) && defined(GISP_CPU)
/*(
 *======================= TimerHookAgain() ============================
 * TimerHookAgain
 *
 * Purpose
 *      This is the function that we tell the ica to call when a timer
 *      interrupt service routine IRETs.
 *
 * Input
 *      adapter_id      The adapter id for the line. (Note the caller doesn't
 *                      know what this is, he's just returning something
 *                      we gave him earlier).
 *
 * Outputs
 *      return  TRUE if there are more interrupts to service, FALSE otherwise.
 *
 * Description
 *      Check if we have a delayed interrupt, if so then generate the timer int
 *      and return TRUE, else return FALSE
)*/

GLOBAL IBOOL
TimerHookAgain IFN1(IUM32, adapter)
{       char scancode;

        if (HostPendingTimerInt())
        {       /* We have a host delayed interrupt, so generate a timer int. */
                sure_note_trace0(TIMER_VERBOSE,"callback with delayed timer int.");
                ica_hw_interrupt(ICA_MASTER,CPU_TIMER_INT, 1);
                return(TRUE);   /* more to do */
        }
        else
        {
                return(FALSE);
        }
}

#endif /* IRET_HOOKS && GISP_CPU */
#endif /* !NTVDM */

void timer_init IFN0()
{
    io_addr i;

    /*
     * Set up the IO chip select logic for this adaptor
     */

    io_define_inb(TIMER_ADAPTOR, timer_inb_func);
    io_define_outb(TIMER_ADAPTOR, timer_outb_func);

#if defined(NEC_98)
    for(i = TIMER_PORT_START; i < TIMER_PORT_END; i += 2)
        {
                if( (i & 7) == 7 )
#else    //NEC_98
    for(i = TIMER_PORT_START; i < TIMER_PORT_END; i++)
        {
                if( (i & 3) == 3 )
#endif   //NEC_98
                        io_connect_port(i, TIMER_ADAPTOR, IO_WRITE);            /* Control port - write only */
                else
                io_connect_port(i, TIMER_ADAPTOR, IO_READ_WRITE);       /* Timer port - read/write */
        }

#if defined(NEC_98)
    io_connect_port(0x3fdb, TIMER_ADAPTOR, IO_READ_WRITE);
    io_connect_port(0x3fdf, TIMER_ADAPTOR, IO_WRITE);
#endif   //NEC_98
    IdealTimeInit();

    Timer_init();

#ifndef NTVDM
    timelock = UNLOCKED;
    needtick = 0;
#else
    RegisterEOIHook(CPU_TIMER_INT, TimerEoiHook);
#endif

        /*
         * Start up the host alarm system
         */

        host_timer_init();

#if !defined(NTVDM)
#if defined(IRET_HOOKS) && defined(GISP_CPU)
        /*
         * Remove any existing hook call-back, and re-instate it afresh.
         * TimerHookAgain is what gets called on a timer int iret.
         */

        Ica_enable_hooking(CPU_TIMER_INT, NULL, ICA_MASTER);
        Ica_enable_hooking(CPU_TIMER_INT, TimerHookAgain, ICA_MASTER);

        /* Host routine to reset any internal data for IRET_HOOK delayed ints. */
        HostResetTimerInts();

#endif /* IRET_HOOKS && GISP_CPU */


        active_int_event = FALSE; /* clear any cranked timer state */
        more_timer_mult = 0;

#if defined(CPU_40_STYLE)
        ica_iret_hook_control(ICA_MASTER, CPU_TIMER_INT, TRUE);
#endif
#endif /* !NTVDM */
}

void    timer_post IFN0()
{
#if defined(NEC_98)
    unsigned short bios_flag;
#endif   //NEC_98
    /* enable gates on all timer channels */
    timer_gate(TIMER0_REG,GATE_SIGNAL_RISE);    /* start timer 1 going... */
    timer_gate(TIMER1_REG,GATE_SIGNAL_RISE);
    timer_gate(TIMER2_REG,GATE_SIGNAL_RISE);

#if defined(NEC_98)
    timer_outb(TIMER_MODE_REG,0x30);
    timer_outb(TIMER0_REG,0);
    timer_outb(TIMER0_REG,0);

    timer_outb(TIMER_MODE_REG,0x76);
    sas_loadw(BIOS_NEC98_BIOS_FLAG,&bios_flag);
    if(bios_flag & 0x8000) {
        timer_outb(TIMER1_REG,0xE6);
        timer_outb(TIMER1_REG,0x03);
    } else {
        timer_outb(TIMER1_REG,0xcd);
        timer_outb(TIMER1_REG,0x04);
    }

    timer_outb(TIMER_MODE_REG,0xb6);
    timer_outb(TIMER2_REG,0x01);
    timer_outb(TIMER2_REG,0x01);
#else    //NEC_98
    timer_outb(TIMER_MODE_REG,0x36);
    timer_outb(TIMER0_REG,0);
    timer_outb(TIMER0_REG,0);

    timer_outb(TIMER_MODE_REG,0x54);
    timer_outb(TIMER1_REG,17);

    timer_outb(TIMER_MODE_REG,0xb6);
    timer_outb(TIMER2_REG,0x68);
    timer_outb(TIMER2_REG,0x04);
#endif   //NEC_98
}

#ifdef DOCUMENTATION
#ifndef PROD

/*
 * Debugging code....
 * This code has no effect.  It is left here in case anyone wants to
 * expand it in future.
 */

dumpCounter IFN0()
{
        static char *modes[] =
        {       "int on tc",
                "prog one shot",
                "rate gen",
                "squarewave gen",
                "sw trig strobe",
                "hw trig strobe"
        };

        static char *as[] =
        {       "binary",
                "bcd"
        };

        char *p, *q;

        p = modes[pcu->m];
        q = as[pcu->bcd];
}
#endif /* nPROD */
#endif /* DOCUMENTATION */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\crtc.c ===
/*      CRTC Emulation File                                                   */
/*                                                            NEC     NEC98    */

#if defined(NEC_98)
#include "insignia.h"
#include "host_def.h"
#include "xt.h"
#include "ios.h"
#include "crtc.h"
#include "debug.h"
#include "gvi.h"

extern BOOL HIRESO_MODE;
extern BOOL     video_emu_mode;

CRTC_GLOBS crtcglobs;

GLOBAL void crtc_outb IFN2(io_addr, port, half_word, value) {
        if (!HIRESO_MODE) {
                switch(port) {
                        case CRTC_SET_PL:
                        case CRTC_SET_BL:
                                if(port==CRTC_SET_PL){
                                        crtcglobs.regpl = value;
                                }else{
                                        crtcglobs.regbl = value;
                                }
//                              if( video_emu_mode ){
                                        if( (crtcglobs.regpl==0x1E) &&
                                                (crtcglobs.regbl==0x11) )
                                        {
                                                set_char_height(20);
                                                set_mode_change_required(TRUE);
                                        }
                                        else if( (crtcglobs.regpl == 0x00) &&
                                                 (crtcglobs.regbl == 0x0F) )
                                        {
                                                set_char_height(16);
                                                set_mode_change_required(TRUE);
                                        }
//                              }
                                break;
                        case CRTC_SET_CL:
                                crtcglobs.regcl = value;
                                break;
                        case CRTC_SET_SSL:
                                crtcglobs.regssl = value;
                                break;
                        case CRTC_SET_SUR:
                                crtcglobs.regsur = value;
                                break;
                        case CRTC_SET_SDR:
                                crtcglobs.regsdr = value;
                                break;
                        default:
                                assert1(FALSE,"NEC98:Illegal Port %#x",value);
        }
        }
}

GLOBAL void crtc_init IFN0() {
        if (!HIRESO_MODE) {
            io_define_outb(LINE_COUNTER,crtc_outb);
                io_connect_port(CRTC_SET_PL,LINE_COUNTER,IO_WRITE);
                io_connect_port(CRTC_SET_BL,LINE_COUNTER,IO_WRITE);
        io_connect_port(CRTC_SET_CL,LINE_COUNTER, IO_WRITE);
                io_connect_port(CRTC_SET_SSL,LINE_COUNTER,IO_WRITE);
                io_connect_port(CRTC_SET_SUR,LINE_COUNTER,IO_WRITE);
                io_connect_port(CRTC_SET_SDR,LINE_COUNTER,IO_WRITE);
        }
}

GLOBAL void crtc_post IFN0() {
        if (!HIRESO_MODE) {
                crtc_outb(CRTC_SET_PL,0);
                crtc_outb(CRTC_SET_BL,0x0F);
                crtc_outb(CRTC_SET_CL,0x10);
                crtc_outb(CRTC_SET_SSL,0);
                crtc_outb(CRTC_SET_SUR,1);
                crtc_outb(CRTC_SET_SDR,0);
        }
}

#endif   //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\ega_dmmy.c ===
#include "insignia.h"
#include "host_def.h"

#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )

/*
 * SccsID = "@(#)ega_dummy.c	1.6 8/25/93 Copyright Insignia Solutions Ltd."
 */


#ifdef EGG

/*  Dummy routines for EGA */

#include	"xt.h"
#include	"sas.h"
#include	"ios.h"
#include	"gmi.h"
#include	"gvi.h"
#include	"debug.h"
#include	"egacpu.h"
#include	"egaports.h"
#include	"gfx_upd.h"
#include	"egagraph.h"

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_EGA.seg"
#endif

/* dummy stuff to keep linker happy */
#define def_dummy(type,name,res) \
type name() { note_entrance0("name");res; }

def_dummy(int,get_ega_switch_setting,return 0)


/*-----------dummy write handlers -------------------------*/

/*-----------end of dummy stuff ---------------------------*/
#endif /* EGG */

#endif	/* !NTVDM | (NTVDM & !X86GFX) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\cga.c ===
#include "insignia.h"
#include "host_def.h"

#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )

/*
 * SoftPC Revision 3.0
 *
 * Title        : IBM Colour/Graphics Adapter simulator
 *
 * Description  : Simulates the IBM CGA.
 *
 * Author       : Rod MacGregor / Henry Nash
 *
 * Notes        : The earlier versions of this module could run on an ADM 3E,
 *                a dumb ANSI standard terminal, in debug mode  or in a Sun
 *                Window. In the interests of sanity and as the versions other
 *                than the Sun were not fully developed, they were removed. if
 *                interested in the workings of these implementations they are
 *                available in the SCCS file before version 2.36.
 *
 *                The supported functions are:
 *
 *                      cga_init             Initialise the subsystem
 *                      cga_term             Terminate the subsystem
 *                      cga_inb              I/P a byte from the MC6845 chip
 *                      cga_outb             O/P a byte to the MC6845 chip
 *
 * In the new EGA world, we use screen start instead of screen base.
 * This is also a WORD address if the adapter is in text mode.
 * (Thats how the EGA works!)
 * So we don't have to double it now. Ho Hum.
 *
 * Mods: (r2.71): In the real 6845 chip, the pointer which addresses the
 *                base of the screen is a WORD ptr. We've just discovered
 *                this; all usage of the variable 'screen_base' assumes
 *                that it is a BYTE ptr. Hence in cga_outb() we now
 *                double the value in screen_base when it is set.
 *
 *       (r3.2) : (SCR 258). cur_offset now declared as static.
 *
 *       (r3.3) : (SCR 257). Set timer_video_enabled when the bit in
 *                the M6845 mode register which controls the video
 *                display is changed. Also neatened the indentation
 *                for outb().
 *
 */

/*
 * static char SccsID[]="@(#)cga.c	1.36 05/05/95 Copyright Insignia Solutions Ltd.";
 */

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_CGA.seg"
#endif

/*
 *    O/S include files.
 */
#include <stdio.h>
#include <malloc.h>
#include TypesH
#include StringH
#include FCntlH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "timeval.h"
#include "timer.h"
#include CpuH
#include "ios.h"
#include "gmi.h"
#include "gfx_upd.h"
#include "gvi.h"
#include "sas.h"
#include "cga.h"
#include "error.h"
#include "config.h"
#include "host.h"
#include "trace.h"
#include "debug.h"
#include "cpu_vid.h"
#ifdef  EGG
#include "egacpu.h"
#endif  /* EGG */
#include "video.h"
#include "ckmalloc.h"

#ifdef REAL_VGA
#include "avm361.h"
#else
#include "host_gfx.h"
#endif


/*
 *============================================================================
 *              Local Defines, Macros & Declarations
 *============================================================================
 */

#define CURSOR_NON_DISPLAY_BIT  (1 << 5)
				/* Bit in Cursor Start Register which
				   makes the cursor invisible */
#define CURSOR_USED_BITS        0x1f
				/* Mask to clear out unused bits */

static int current_mode = -1;   /* Value of Mode Select at last call    */

/*
 * MC6845 Registers
 */

#ifdef HUNTER
half_word MC6845[MC6845_REGS];  /* The current values of the MC6845 registers */
half_word mode_reg;             /* The value of the mode control register */
#endif

static half_word index_reg = 00 ;       /* Index register        */

/*
 * 6845 Register variables
 */
static half_word R0_horizontal_total;
static half_word R1_horizontal_displayed = 80;
static half_word R2_horizontal_sync_pos;
static half_word R3_horizontal_sync_width;
static half_word R4_vertical_total;
static half_word R5_vertical_total_adjust;
static half_word R6_vertical_displayed   = 25;
static half_word R7_vertical_sync;
static half_word R9_max_scan_line_addr   = 7;
static half_word R8_interlace;
static half_word Ra_cursor_start = 0;
static half_word Rb_cursor_end = 0;
static half_word Re_cursor_loc_high = 0;
static half_word Rf_cursor_loc_low = 0;

/*
 * global variables peculiar to the cga
 */

CGA_GLOBS       CGA_GLOBALS;

GLOBAL VOID (*bios_ch2_byte_wrt_fn)();
GLOBAL VOID (*bios_ch2_word_wrt_fn)();

GLOBAL IU8 *cga_screen_buf = 0;

/*
 * Globals used in various functions to synchronise the display
 */

int cursor_over_screen = FALSE; /* When set to TRUE the cursor is over the    */
				/* screen areas and the cursor should flash   */

/*
 * Static forward declarations.
 */

static void set_cga_palette     IPT2(int, screen_mode, int, res);
static void update_cursor_shape IPT0();


#ifdef A3CPU
IMPORT WRT_POINTERS Glue_writes;
#else
IMPORT MEM_HANDLERS Glue_writes;
#endif /* A3CPU */
IMPORT WRT_POINTERS simple_writes;
IMPORT READ_POINTERS Glue_reads;
IMPORT READ_POINTERS read_glue_ptrs;
IMPORT READ_POINTERS simple_reads;

#ifdef  A2CPU
LOCAL ULONG dummy_read IFN1(ULONG, offset)
{
	UNUSED(offset);
	return 0;
}

LOCAL void dummy_str_read IFN3(UTINY *, dest, ULONG, offset, ULONG, count)
{
	UNUSED(dest);
	UNUSED(offset);
	UNUSED(count);
}

LOCAL READ_POINTERS     dummy_reads =
{
	dummy_read,
	dummy_read
#ifndef NO_STRING_OPERATIONS
	,
	dummy_str_read
#endif  /* NO_STRING_OPERATIONS */
};
#endif  /* A2CPU */

/*
 *==========================================================================
 *      Global Functions
 *==========================================================================
 */

/*
 ********** Functions that operate on the I/O Address Space ********************
 */

/*
 * Global variables
 */

half_word bg_col_mask = 0x70;
reg regen_start;                /* Regen start address                   */

void cga_inb    IFN2(io_addr, address, half_word *, value)
{

#ifndef NEC_98
static int cga_state = 0;       /* current cga status state */
static long state_count = 1;    /* position in that state */
static int sub_state = 0;       /* sub state for cga state 2 */
static unsigned long gmfudge = 17; /* Random number seed for pseudo-random
				      bitstream generator to give the state
				      lengths below that 'genuine' hardware
				      feel to progs that require it! */
register unsigned long h;

/*
 * relative 'lengths' of each state. State 2 is *3 as it has 3 sub states
 */
static int s_lengths[] = { 8, 18, 8, 6 };

/*
 * Read from MC6845 Register
 */

if ( address == 0x3DA ) {

    /*
     * Status register, simulated adapter has
     *
     *  bit                     setting
     *  ---                     -------
     *  Display enable             1/0 Toggling each inb
     *  Light Pen                  0
     *  Light Pen                  0
     *  Vertical Sync              1/0 Toggling each inb
     *  4-7 Unused                 0,0,0,0
     *
     * The upper nibble of the byte is always set.
     * Some programs synchronise with the display by waiting for the
     * next vertical retrace.
     *
     * We attempt to follow the following waveform
     *
     *    --                                                     ----------
     * VS  |_____________________________________________________|        |____
     *
     *
     *    -------------  -   -                           ------------------
     * DE             |__||__||__ ... about 180         _|
     *
     *State|--- 0 ----|-------------- 1 -----------------|-- 3 --|-- 4 --|
     *
     * We do this with a 4 state machine. Each state has a count associated
     * with it to represent the relative time spent in each state. When this
     * count is exhausted the machine moves into the next state. One Inb
     * equals 1 count. The states are as follows:
     *     0: VS low, DE high.
     *     1: VS low, DE toggles. This works via an internal state.
     *     3: VS low, DE high.
     *     4: VS high,DE high.
     *
     */

    state_count --;                     /* attempt relative 'timings' */
    switch (cga_state) {

    case 0:
	if (state_count == 0) {         /* change to next state ? */
	    h = gmfudge << 1;
	    gmfudge = (h&0x80000000L) ^ (gmfudge & 0x80000000L)? h|1 : h;
	    state_count = s_lengths[1] + (gmfudge & 3);
	    cga_state = 1;
	}
	*value = 0xf1;
	break;

    case 1:
	if (state_count == 0) {         /* change to next state ? */
	    h = gmfudge << 1;
	    gmfudge = (h&0x80000000L) ^ (gmfudge & 0x80000000L)? h|1 : h;
	    state_count = s_lengths[2] + (gmfudge & 3);
	    cga_state = 2;
	    sub_state = 2;
	}
	switch (sub_state) {            /* cycle through 0,0,1 sequence */
	case 0:                         /* to represent DE toggling */
	    *value = 0xf0;
	    sub_state = 1;
	    break;
	case 1:
	    *value = 0xf0;
	    sub_state = 2;
	    break;
	case 2:
	    *value = 0xf1;
	    sub_state = 0;
	    break;
	}
	break;

    case 2:
	if (state_count == 0) {         /* change to next state ? */
	    h = gmfudge << 1;
	    gmfudge = (h&0x80000000L) ^ (gmfudge & 0x80000000L)? h|1 : h;
	    state_count = s_lengths[3] + (gmfudge & 3);
	    cga_state = 3;
	}
	*value = 0xf1;
	break;

    case 3:
	if (state_count == 0) {         /* wrap back to first state */
	    h = gmfudge << 1;
	    gmfudge = (h&0x80000000L) ^ (gmfudge & 0x80000000L)? h|1 : h;
	    state_count = s_lengths[0] + (gmfudge & 3);
	    cga_state = 0;
	}
	*value = 0xf9;
	break;
    }
}
else if ( (address & 0xFFF9) == 0x3D1)
	{

	    /*
	     * Internal data register, the only supported internal
	     * registers are E and F the cursor address registers.
	     */

	    switch (index_reg) {

	    case 0xE:
		*value = (get_cur_y() * get_chars_per_line() + get_cur_x() ) >> 8;
		break;
	    case 0xF:
		*value = (get_cur_y() * get_chars_per_line() + get_cur_x()) & 0xff;
		break;
	    case 0x10: case 0x11:
		*value = 0;
		break;
	    default:
		note_trace1(CGA_VERBOSE,
			    "Read from unsupported MC6845 internal reg %x",
			    index_reg);
	    }
	}
else
	/*
	 * Read from a write only register
	 */

	*value = 0x00;
#endif   //NEC_98
}


void cga_outb   IFN2(io_addr, address, half_word, value)
{

/*
 * Output to a 6845 register
 */

word      cur_offset;                   /* The cursor position registers */
static half_word last_mode  = -1;
static half_word last_screen_length  = 25;
static half_word video_mode;
/*
 * Variable used to see if text character height has changed, so that
 * unnecessary calls to host_change_mode can be avoided.
 */
static half_word last_max_scan_line = 7;

/*
 * Masks for testing the input byte. The MODE_MASK hides the (unsupported)
 * blink bit and the video enable bit to ascertain whether any mode specific
 * variables need to be changed. The BLINK_MASK hides the blink bit for storing
 * the current_mode between changes.
 */

#define RESET           0x00
#define ALPHA_80x25     0x01
#define GRAPH           0x02
#define BW_ENABLE       0x04
#define GRAPH_640x200   0x10
#define MODE_MASK       0x17
#define BLINK_MASK      0x1F
#define COLOR_MASK      0x3F

    note_trace2(CGA_VERBOSE, "cga_outb: port %x value %x", address, value);

switch (address) {
    case 0x3D0:
    case 0x3D2:
    case 0x3D4:
    case 0x3D6:

	/*
	 * Index Register
	 */
	index_reg = value;
	break;

    case 0x3D1:
    case 0x3D3:
    case 0x3D5:
    case 0x3D7:
#ifdef HUNTER
	MC6845[index_reg] = value;
#endif

/*
 * This is the data register, the function to be performed depends on the
 * value in the index register
 *
 * The various registers affect the position and size of the screen and the
 * image on it. The screen can be logically divided into two halves: the
 * displayed text and the rest which is the border. The border colour can
 * be changed by programming the 3D9 register.
 * NB. Currently SoftPC does not obey positioning & display sizing
 * information - the display remains constant.
 * The first 8 registers (R0-R7) affect the size & position of the display;
 * their effects are as follows:
 * R0 - R3 control the horizontal display aspects & R4 - R7 the vertical.
 *
 * The diagram below attempts to show how each is related to the screen
 * size & shape.
 *
 *    (Shaded Area - border)
 *   ________________________________________________________ <-------------
 *   |......................................................|  |  | R5  |
 *   |..|-----------------------------------------------|...|  | <----  |
 *   |..|                                               |...|  |     |  |
 *   |..|c>                                             |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  R     R  R
 *   |..|                                               |...|  4     6  7
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|                                               |...|  |     |  |
 *   |..|_______________________________________________|...|  | <-------
 *   |......................................................|  |
 *   -------------------------------------------------------- <------------
 *   ^                                                      ^
 *   |-----------------------R0-----------------------------|
 *   |  ^                                                   |
 *   |R3|                                                   |
 *   |  |                                                ^  |
 *   |  |--------------------R1--------------------------|
 *   |                                                   |
 *   |-----------------------R2--------------------------|
 *
 *   The reason for having 4 registers to handle the full range of values
 *   is because they are actually used to control the horizontal & vertical
 *   traces on the screen hence:
 *        R0 - total time of scan
 *        R1 - active display - scan on
 *        R2 - time sync for scan off/on/off
 *        R3 - time to scan on
 *
 *               R1
 *      -------------------------------------------------
 *      |                                               |
 *      |                                               |
 *   R3 |                                               |
 *   ----                                               ---
 *   <---------------------R2-------------------------->
 *   <---------------------R0----------------------------->
 *
 *  The veritcal registers organise an analagous trace. The two traces are
 *  synchronised by Register 8.
 *
 *  This is why altering these values on the PC will move the display or
 *  more likely cause garbaging of the image!
 */

	switch ( index_reg ) {
	    case 0x00:
		/*
		 * total horizontal display (inc border)
		 */
		R0_horizontal_total = value;
		break;

	    case 0x01:
		/*
		 * Specify the number of characters per row
		 */
		if (value > 80) {
		    always_trace1("cga_outb: trying to set width %d", value);
		    value = 80;
		}
		R1_horizontal_displayed = value;
		set_horiz_total(value);
		break;

	    case 0x02:
		/*
		 * Right hand edge of displayed text
		 * affect left_border(?), right_border(?)
		 */
		R2_horizontal_sync_pos = value;
		break;

	    case 0x03:
		/*
		 * Left hand edge of displayed text
		 * affect left_border, right_border
		 */
		R3_horizontal_sync_width = value;
		break;

	    case 0x04:
		/*
		 * total vertical display (inc border)
		 */
		R4_vertical_total = value;
		break;

	    case 0x05:
		/*
		 * Top edge of displayed text
		 * affect top_border, bottom_border
		 */
		R5_vertical_total_adjust = value;
		break;

	    case 0x06:
		/*
		 * If the screen length is 0, this effectively means
		 * don't display anything.
		 */
		if(value == 0)
		{
		    host_clear_screen();
		    set_display_disabled(TRUE);
		    last_screen_length = 0;
		}
		else
		{
		    /*
		     * Specify the screen length - in our
		     * implementation used only in text mode.
		     * affect top_border, bottom_border
		     */
		    R6_vertical_displayed = value;
		    set_screen_length( R1_horizontal_displayed * R6_vertical_displayed * 2 );
		}
		/*
		 * check if we are resetting the screen to
		 * display again
		 */
		if((value != 0) && (last_screen_length == 0))
		{
		    set_display_disabled(FALSE);
		    host_flush_screen();
		    last_screen_length = value;
		}


		break;

	    case 0x07:
		/*
		 * bottom of displayed text
		 * affect top_border(?), bottom_border(?)
		 */
		R7_vertical_sync = value;
		break;

	    case 0x08:
		/*
		 * interlace of traces - hold constant
		 */
		R8_interlace = 2;
		break;

	    case 0x09:
		/*
		 * Specify the character height - in our
		 * implementation used only in text mode.
		 * The actual number of pixels is one
		 * more than this value.
		 */
		R9_max_scan_line_addr = value;
		set_char_height_recal(R9_max_scan_line_addr + 1);
		set_screen_height_recal( R6_vertical_displayed*(R9_max_scan_line_addr+1) - 1);
		flag_mode_change_required();
		screen_refresh_required();
		break;

	    /*
	     * A defines the cursor start scan line
	     * B defines the cursor stop scan line
	     */
	    case 0x0A:
		/* bypass redundant updates */
		if (Ra_cursor_start != value)
		{
		    Ra_cursor_start = value;
#ifdef REAL_VGA
		    CRTC_REG(0xa, value);
#endif
		    update_cursor_shape();
		}
		break;
	    case 0x0B:
		/* bypass redundant updates */
		if (Rb_cursor_end != (value & CURSOR_USED_BITS))
		{
		    Rb_cursor_end = (value & CURSOR_USED_BITS);
#ifdef REAL_VGA
		    CRTC_REG(0xb, value);
#endif
		    update_cursor_shape();
		}
		break;

	    /*
	     * C & D define the start of the regen buffer
	     */
	    case 0x0C:
		/*
		 * High byte
		 */
		if (value != regen_start.byte.high)
		{
			regen_start.byte.high = value;
			host_screen_address_changed(regen_start.byte.high,
							regen_start.byte.low);
			set_screen_start(regen_start.X  % (short)(CGA_REGEN_LENGTH/2) );
			screen_refresh_required();
		}
#ifdef REAL_VGA
		CRTC_REG(0xc, value);
#endif
		break;

	    case 0x0D:
		/*
		 * low byte
		 */
		if (value != regen_start.byte.low)
		{
			regen_start.byte.low = value;
			host_screen_address_changed(regen_start.byte.high,
							regen_start.byte.low);
			set_screen_start(regen_start.X  % (short)(CGA_REGEN_LENGTH/2));
			screen_refresh_required();
		}
#ifdef REAL_VGA
		CRTC_REG(0xd, value);
#endif
		break;

	    /*
	     * E and F define the cursor coordinates in characters
	     */
	    case 0x0E:
		/*
		 * High byte
		 */
		if (Re_cursor_loc_high != value)
		{
		    Re_cursor_loc_high = value;

		    if(get_cga_mode() == TEXT)
			host_cga_cursor_has_moved(get_cur_x(), get_cur_y());
		    cur_offset = (value << 8) | Rf_cursor_loc_low;
		    cur_offset -= (word) get_screen_start();
		    set_cur_y( cur_offset / get_chars_per_line() );
		    set_cur_x( cur_offset % get_chars_per_line() );

		}
		break;

	    case 0x0F:
		/*
		 * low byte
		 */
		if (Rf_cursor_loc_low != value)
		{
		    Rf_cursor_loc_low = value;

		    if(get_cga_mode() == TEXT)
			host_cga_cursor_has_moved(get_cur_x(), get_cur_y());
		    cur_offset =  (Re_cursor_loc_high << 8) | value;
		    cur_offset -= (word) get_screen_start();
		    set_cur_y( cur_offset / get_chars_per_line());
		    set_cur_x( cur_offset % get_chars_per_line());

		}
		break;

	    default:
		note_trace2(CGA_VERBOSE, "Unsupported 6845 reg %x=%x(write)",
			    index_reg, value);
	}
	break;

    case 0x3D8:
	/*
	 * Mode control register.  The first
	 * six bits are encoded as follows:
	 *
	 * BIT      Function            Status
	 * ---       --------            ------
	 *  0      A/N 80x25 mode        Supported
	 *  1      Graphics Select        Supported
	 *  2      B/W Select            Supported
	 *  3      Enable Video            Supported
	 *  4      640x200 B/W mode        Supported
	 *  5      Change B/G intensity to blink Not Supported
	 *  6,7      Unused
	 */

#ifdef HUNTER
	mode_reg = value;
#endif
	timer_video_enabled = (boolean) (value & VIDEO_ENABLE);

	if (value != current_mode) {

	    if (value == RESET)
		set_display_disabled(TRUE);     /* Chip reset - do nothing */
	    else {
		/*
		 * Take note whether color or B/W
		 */

		set_cga_color_select( !(value & BW_ENABLE) );

		/*
		 * Set up for graphics or text
		 */
		if (value & GRAPH) {
		    set_chars_per_line(R1_horizontal_displayed<<1);
		    set_cursor_visible(FALSE);
		    set_cga_mode(GRAPHICS);
		    host_set_border_colour(0);
		    set_word_addressing(FALSE); /* bytes per line = chars per line */
		    set_cga_resolution( (value & GRAPH_640x200 ? HIGH : MEDIUM) );
		    if (get_cga_resolution() == HIGH) {
			video_mode = 6;
			set_pix_width(1);
		    }
		    else {
			video_mode = (get_cga_color_select() ? 4 : 5);
			set_pix_width(2);
		    }
		    if (video_mode != last_mode)
		    {
			host_change_mode();
			set_cga_palette(get_cga_mode(),get_cga_resolution());
		    }
		}
		else {    /* Text, presumably */
		    set_chars_per_line(R1_horizontal_displayed);
		    set_cga_mode(TEXT);
		    set_cursor_visible(TRUE);
		    set_word_addressing_recal(TRUE);    /* so that bytes per line is twice chars per line */

		    if (value & 0x20)
			/* blinking - not supported */
			bg_col_mask = 0x70;
		    else
			/* using blink bit to provide 16 background colours */
			bg_col_mask = 0xf0;

		    if (value & ALPHA_80x25)
		    {
			video_mode = (get_cga_color_select() ? 3 : 2);
			set_pix_width(1);
			set_pix_char_width(8);
		    }
		    else
		    {
			video_mode = (get_cga_color_select() ? 1 : 0);
			set_pix_width(2);
			set_pix_char_width(16);
		    }


/*
 * Avoid mode changes with disabled screen.
 *
 * Text mode changes are also needed if the character height changes.  The
 * character height is set here rather than when that register is set.  This
 * avoids unnecessary mode changes, as the character height is set before we
 * know if a graphics or text mode is to be entered.
 */
		if ( (value & VIDEO_ENABLE) && ((video_mode != last_mode) ||
		     (last_max_scan_line != R9_max_scan_line_addr)))
		    {
			last_max_scan_line = R9_max_scan_line_addr;
			host_change_mode();        /* redo fonts etc */
			set_cga_palette(get_cga_mode(),get_cga_resolution());
		    }
		}
		set_bytes_per_line(R1_horizontal_displayed<<1);
		set_offset_per_line(get_bytes_per_line());

		if (video_mode != last_mode) {
		    if (value & VIDEO_ENABLE) {
			set_display_disabled(FALSE);
			screen_refresh_required();
			last_mode = video_mode; /* Do this here so when screen display is re-enabled we do 'pending' mode change */
		    }
		    else
			set_display_disabled(TRUE);
		}
		else if ((value & VIDEO_ENABLE)
		  != (current_mode & VIDEO_ENABLE)) {
		    if (value & VIDEO_ENABLE) {
			set_display_disabled(FALSE);
			host_flush_screen();
		    }
		    else
			set_display_disabled(TRUE);
		}
	    }

	}

	current_mode = value;
	break;

    case 0x3D9:
	/*
	 * The Color Select Register. Just save this into a
	 * variable so the machine-specific graphics s/w can
	 * see it, then call a host specific routine to act on it.
	 */

	if ((value & COLOR_MASK) != get_cga_colormask() ) {
	    set_cga_colormask(value & COLOR_MASK);
	    set_cga_palette(get_cga_mode(),get_cga_resolution());
	}
	break;

    default:
	/*
	 * Write to an unsupported 6845 internal register
	 */

	note_trace2(CGA_VERBOSE, "Write to unsupported 6845 reg %x=%x",
			 address,value);
	break;

    }
}


/*
 * Set up the host palette & border for the current CGA screen mode and resolution
 */

static void set_cga_palette     IFN2(int, screen_mode, int, res)
{
#ifndef NEC_98
    /*
     * palette for color text - 16 colors for FG and BG
     * These tables are also used to set some graphic mode palette entries
     * since they represent a 'standard' set of colors.
     */

    static PC_palette cga_text_palette[] =
    {
	0x00, 0x00, 0x00,               /* Black        */
	0x22, 0x22, 0xBB,               /* Blue         */
	0x00, 0xAA, 0x00,               /* Green        */
	0x00, 0xAA, 0xAA,               /* Cyan         */
	0xAA, 0x00, 0x00,               /* Red          */
	0xAA, 0x00, 0xAA,               /* Magenta      */
	0xAA, 0x88, 0x00,               /* Brown        */
	0xCC, 0xCC, 0xCC,               /* White        */
	0x55, 0x55, 0x55,               /* Grey         */
	0x22, 0x22, 0xEE,               /* Light Blue   */
	0x00, 0xEE, 0x00,               /* Light Green  */
	0x00, 0xEE, 0xEE,               /* Light Cyan   */
	0xEE, 0x00, 0x00,               /* Light Red    */
	0xEE, 0x00, 0xEE,               /* Light Magenta*/
	0xEE, 0xEE, 0x00,               /* Yellow       */
	0xFF, 0xFF, 0xFF                /* Bright White */
    };


    /*
     * NOTE: The medium resolution graphics colors below have their first
     *       and second indices reversed, due to a "feature" in the supplied
     *       graphics system library routines. We are trying to persuade IBM
     *       to change the spec of the CGA accordingly.
     */


    /*
     * Medium resolution graphics, color set 1 (Green, Red, Brown)
     */

    static PC_palette cga_graph_m1l[] =
    {
	0x00, 0x00, 0x00,               /* Set dynamically      */
	0x00, 0xAA, 0x00,               /* Green                */
	0xAA, 0x00, 0x00,               /* Red                  */
	0xAA, 0x88, 0x00                /* Brown                */
    };

    /*
     * As above but with high intensity bit on
     */

    static PC_palette cga_graph_m1h[] =
    {
	0x00, 0x00, 0x00,               /* Set dynamically      */
	0x00, 0xEE, 0x00,               /* Green (alt Red)      */
	0xEE, 0x00, 0x00,               /* Red (alt Green)      */
	0xEE, 0xEE, 0x00                /* Yellow               */
    };

    /*
     * Medium resolution graphics, color set 2 (Cyan, Magenta, White)
     */

    static PC_palette cga_graph_m2l[] =
    {
	0x00, 0x00, 0x00,               /* Set dynamically      */
	0x00, 0xAA, 0xAA,               /* Magenta (alt Cyan)   */
	0xAA, 0x00, 0xAA,               /* Cyan (alt Magenta)   */
	0xCC, 0xCC, 0xCC                /* White                */
    };


    /*
     * As above but with high intensity bit on
     */

    static PC_palette cga_graph_m2h[] =
    {
	0x00, 0x00, 0x00,               /* Set dynamically      */
	0x00, 0xEE, 0xEE,               /* Magenta (alt Cyan)   */
	0xEE, 0x00, 0xEE,               /* Cyan (alt Magenta)   */
	0xFF, 0xFF, 0xFF                /* White                */
    };

    /*
     * Medium resolution graphics, color set 3 (Cyan, Red, White)
     * This is what you get when the "Black & White" bit is on!!!
     */

    static PC_palette cga_graph_m3l[] =
    {
	0x00, 0x00, 0x00,               /* Set dynamically      */
	0x00, 0xAA, 0xAA,               /* Cyan (alt Red)       */
	0xAA, 0x00, 0x00,               /* Red (alt Cyan)       */
	0xCC, 0xCC, 0xCC                /* White                */
    };

    /*
     * As above but with high intensity on
     */

    static PC_palette cga_graph_m3h[] =
    {
	0x00, 0x00, 0x00,               /* Set dynamically      */
	0x00, 0xEE, 0xEE,               /* Cyan (alt Red)       */
	0xEE, 0x00, 0x00,               /* Red (alt Cyan)       */
	0xFF, 0xFF, 0xFF                /* White                */
    };


    /*
     * High resolution graphics
     */

    static PC_palette cga_graph_high[] =
    {
	0x00, 0x00, 0x00,               /* Black                */
	0x00, 0x00, 0x00                /* Set dynamically      */
    };


    /*
     * Local variables
     */

    PC_palette *cga_graph_med;
    int ind;

    /*
     * If the mode is TEXT use cga_text_palette
     */

    if (screen_mode == TEXT)
    {
	host_set_palette(cga_text_palette, 16);
	host_set_border_colour(get_cga_colormask() &0xf);
    }

    else        /* Mode must be GRAPHICS */
    if (res == MEDIUM)
    {
	/*
	 * Select the appropriate slot array, then fill in the background.
	 *
	 * Note:  1) On a CGA driving an IBM Color Monitor, the intensity
	 *           of these three colors (but NOT the background color)
	 *           is affected by bit 4 of the Color Register.
	 *
	 *        2) The documentation says that bit 5 of the Color
	 *           register selects one of two color sets. On a CGA
	 *           driving an IBM Color Monitor, this is true UNLESS
	 *           the B/W Enable bit in the Mode Set register is on,
	 *           in which case you get a third set unaffected by
	 *           bit 5 of the Color Register.
	 */

	if (!get_cga_color_select() )                           /* Set 3 */
	    if (get_cga_colormask() & 0x10)             /* High  */
		cga_graph_med = cga_graph_m3h;
	    else                                /* Low   */
		cga_graph_med = cga_graph_m3l;
	else
	if (get_cga_colormask() & 0x20)                 /* Set 2 */
	    if (get_cga_colormask() & 0x10)             /* High  */
		cga_graph_med = cga_graph_m2h;
	    else                                /* Low   */
		cga_graph_med = cga_graph_m2l;
	else                                    /* Set 1 */
	    if (get_cga_colormask() & 0x10)             /* High  */
		cga_graph_med = cga_graph_m1h;
	    else                                /* Low   */
		cga_graph_med = cga_graph_m1l;

	/*
	 * Load the background color from the TEXT palette
	 */

	ind = get_cga_colormask() & 15;         /* Lower 4 bits select color */
	cga_graph_med->red   = cga_text_palette[ind].red;
	cga_graph_med->green = cga_text_palette[ind].green;
	cga_graph_med->blue  = cga_text_palette[ind].blue;

	/*
	 * Load it
	 */
	host_set_palette(cga_graph_med,4);

    }
    else        /* Must be high resolution graphics */
    {
	/*
	 * The background is BLACK, and the foreground is selected
	 * from the lower 4 bits of the Color Register
	 */

	ind = (get_cga_colormask() & 15);
	cga_graph_high[1].red   = cga_text_palette[ind].red;
	cga_graph_high[1].green = cga_text_palette[ind].green;
	cga_graph_high[1].blue  = cga_text_palette[ind].blue;

	host_set_palette(cga_graph_high,2);
    }
#endif   //NEC_98
}

static void update_cursor_shape IFN0()
{
#ifndef NEC_98
	/*
	 *      This function actions a change to the cursor shape
	 *      when either the cursor start or cursor end registers
	 *      are updated with DIFFERENT values.
	 */
	half_word temp_start;


	set_cursor_height1(0);
	set_cursor_start1(0);

	if ( (Ra_cursor_start & CURSOR_NON_DISPLAY_BIT)
	    || ( Ra_cursor_start > CGA_CURS_START)) {
	    /*
	     * Either of these conditions causes the
	     * cursor to disappear on the real PC
	     */
	    set_cursor_height(0);
	    set_cursor_visible(FALSE);
	}
	else {
	    temp_start = Ra_cursor_start & CURSOR_USED_BITS;
	    set_cursor_visible(TRUE);
	    if (Rb_cursor_end > CGA_CURS_START) {  /* block */
		set_cursor_height(CGA_CURS_START);
		set_cursor_start(0);
	    }
	    else if (temp_start <= Rb_cursor_end) {     /* 'normal' */
		set_cursor_start(temp_start);
		set_cursor_height(Rb_cursor_end - temp_start + 1);
	    }
	    else {      /* wrap */
		set_cursor_start(0);
		set_cursor_height(Rb_cursor_end);
		set_cursor_start1(temp_start);
		set_cursor_height1(get_char_height() - temp_start);
	    }
	}
	base_cursor_shape_changed();


	host_cursor_size_changed(Ra_cursor_start, Rb_cursor_end);

#endif   //NEC_98
}

#if !defined(EGG) && !defined(A3CPU) && !defined(A2CPU) && !defined(C_VID) && !defined(A_VID)

/*
	The following functions are MEM_HANDLER functions for the CGA-only
	build with no C_VID (no a common build). They are unused for most
	variants of SoftPC.
*/

#define INTEL_SRC       0
#define HOST_SRC        1

/*
======================== cga_only_simple_handler =========================
PURPOSE:        This function provides a stub for the unused MEM_HANDLER
		functions. This function probably shouldn't be called hence
		the trace statement.
INPUT:          None.
OUTPUT:         None.
==========================================================================
*/
LOCAL void cga_only_simple_handler IFN0()
{
#ifndef NEC_98
	always_trace0("cga_only_simple_handler called");
	setVideodirty_total(getVideodirty_total() + 1);
#endif   //NEC_98
}

/*
=========================== cga_only_b_write =============================
PURPOSE:        Byte write function. Puts the value at the given address
		and increments dirty_flag.
INPUT:          Address (in terms of M) and value to put there.
OUTPUT:         None.
==========================================================================
*/
LOCAL void cga_only_b_write IFN2(UTINY *, addr, ULONG, val)
{
#ifndef NEC_98
	host_addr       ptr;
	ULONG           offs;
	
	offs = (ULONG) (addr - gvi_pc_low_regen);
	ptr = get_screen_ptr(offs);
	*ptr = val & 0xff;
	setVideodirty_total(getVideodirty_total() + 1);
#endif   //NEC_98
}

/*
=========================== cga_only_w_write =============================
PURPOSE:        Word write function. Puts the value at the given address
		and increments dirty_flag.
INPUT:          Address (in terms of M) and value to put there.
OUTPUT:         None.
==========================================================================
*/
LOCAL void cga_only_w_write IFN2(UTINY *, addr, ULONG, val)
{
#ifndef NEC_98
	host_addr       ptr;
	ULONG           offs;
	
	offs = (ULONG) (addr - gvi_pc_low_regen);
	ptr = get_screen_ptr(offs);
	*ptr++ = val & 0xff;
	*ptr = (val >> 8) & 0xff;
	setVideodirty_total(getVideodirty_total() + 2);
#endif   //NEC_98
}

/*
=========================== cga_only_b_fill ==============================
PURPOSE:        Byte fill function. Fills the given address range with the
		value and increments dirty_flag.
INPUT:          Address range (in terms of M) and value to put there.
OUTPUT:         None.
==========================================================================
*/
LOCAL void cga_only_b_fill IFN3(UTINY *, laddr, UTINY *, haddr, ULONG, val )
{
#ifndef NEC_98
	host_addr       ptr;
	IS32            len;
	ULONG           offs;
		
	offs = (ULONG) (laddr - gvi_pc_low_regen);
	ptr = get_screen_ptr(offs);
	for (len = (haddr - laddr); len > 0; len--)
		*ptr++ = val;
#endif   //NEC_98
}

/*
=========================== cga_only_w_fill ==============================
PURPOSE:        Word fill function. Fills the given address range with the
		value and increments dirty_flag.
INPUT:          Address range (in terms of M) and value to put there.
OUTPUT:         None.
==========================================================================
*/
LOCAL void cga_only_w_fill IFN3(UTINY *, laddr, UTINY *, haddr, ULONG, val )
{
#ifndef NEC_98
	host_addr       ptr;
	IS32            len;
	IU8             lo;
	IU8             hi;
	ULONG           offs;
	
	lo = val & 0xff;
	hi = (val >> 8) & 0xff;
	offs = (ULONG) (laddr - gvi_pc_low_regen);
	ptr = get_screen_ptr(offs);
	for (len = (haddr - laddr) >> 1; len > 0; len--)
	{
		*ptr++ = lo;
		*ptr++ = hi;
	}
#endif   //NEC_98
}

LOCAL void cga_only_b_move IFN4(UTINY *, laddr, UTINY *, haddr, UTINY *, src,
	UTINY, src_type)
{
#ifndef NEC_98
	host_addr       src_ptr;
	host_addr       dst_ptr;
	IS32            len;
	ULONG           offs;
	BOOL            move_bwds = getDF();
	
	offs = (ULONG) (laddr - gvi_pc_low_regen);
	dst_ptr = get_screen_ptr(offs);
	len = haddr - laddr;
	if ((src_type == HOST_SRC) || (src < (UTINY *)gvi_pc_low_regen) ||
		((UTINY *)gvi_pc_high_regen < src))
	{
		/* Ram source */
		if (src_type == INTEL_SRC)
			src_ptr = get_byte_addr(src);
		else
			src_ptr = src;
		
		/* Ram to video move - video is always forwards, ram
		** depends on BACK_M.
		*/
		if (move_bwds)
		{
			dst_ptr += len;
#ifdef  BACK_M
			src_ptr -= len;
			for ( ; len > 0; len--)
				*(--dst_ptr) = *(++src_ptr);
#else
			src_ptr += len;
			for ( ; len > 0; len--)
				*(--dst_ptr) = *(--src_ptr);
#endif  /* BACK_M */
		}
		else
		{
#ifdef  BACK_M
			for ( ; len > 0; len--)
				*dst_ptr++ = *src_ptr--;
#else
			memcpy(dst_ptr, src_ptr, len);
#endif  /* BACK_M */
		}
	}
	else
	{
		/* Video source */
		offs = (ULONG) (src - gvi_pc_low_regen);
		src_ptr = get_screen_ptr(offs);
		
		/* Video to video move - both sets of memory are always
		** forwards.
		*/
		if (move_bwds)
		{
			dst_ptr += len;
			src_ptr += len;
			for ( ; len > 0; len--)
				*(--dst_ptr) = *(--src_ptr);
		}
		else
			memcpy(dst_ptr, src_ptr, len);
	}
#endif   //NEC_98
}

LOCAL MEM_HANDLERS cga_only_handlers =
{
	cga_only_b_write,
	cga_only_w_write,
	cga_only_b_fill,
	cga_only_w_fill,
	cga_only_b_move,
	cga_only_simple_handler         /* word move - not used? */
};

#endif /* not EGG or A3CPU or A2CPU or C_VID or A_VID */

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

void cga_init()
{
#ifndef NEC_98
IMPORT void Glue_set_vid_rd_ptrs IPT1(READ_POINTERS *, handler );
IMPORT void Glue_set_vid_wrt_ptrs IPT1(WRT_POINTERS *, handler );

io_addr i;

#ifdef HUNTER
for (i = 0; i < MC6845_REGS; i++)
    MC6845[i] = 0;
#endif


/*
 * Set up the IO chip select logic for this adaptor
 */

io_define_inb(CGA_ADAPTOR, cga_inb);
io_define_outb(CGA_ADAPTOR, cga_outb);

for(i = CGA_PORT_START; i <= CGA_PORT_END; i++)
    io_connect_port(i, CGA_ADAPTOR, IO_READ_WRITE);

/*
 * Initialise the adapter, assume Alpha numeric 80x25 as start up state
 * with active page of zero & default cursor
 */

	gvi_pc_low_regen  = CGA_REGEN_START;
	gvi_pc_high_regen = CGA_REGEN_END;
	set_cursor_start(8-CGA_CURS_HEIGHT);
	set_cursor_height(CGA_CURS_HEIGHT);
	set_cga_color_select(FALSE);            /* B/W at switch-on */
	set_cga_colormask(0);                   /* Will be set by BIOS */

#ifndef GISP_CPU
/* GISP CPU physically cannot perform read and/or write checks */

#ifdef  JOKER

	/* gmi_define_mem(SAS_VIDEO, &Glue_writes); */
	Glue_set_vid_wrt_ptrs(&simple_writes);
	Glue_set_vid_rd_ptrs(&simple_reads);

#else   /* not JOKER */


#ifdef A3CPU
#ifdef C_VID
	Cpu_set_vid_wrt_ptrs( &Glue_writes );
	Cpu_set_vid_rd_ptrs( &Glue_reads );
	Glue_set_vid_wrt_ptrs( &simple_writes );
	Glue_set_vid_rd_ptrs( &simple_reads );
#else
	Cpu_set_vid_wrt_ptrs( &simple_writes );
	Cpu_set_vid_rd_ptrs( &simple_reads );
#endif  /* C_VID */
#else   /* not A3CPU */
#ifdef A2CPU
	gmi_define_mem(SAS_VIDEO, &vid_handlers);
	read_pointers = dummy_reads;
#else
#if !defined(EGG) && !defined(C_VID) && !defined(A_VID)
	gmi_define_mem(SAS_VIDEO, &cga_only_handlers);
#else
	gmi_define_mem(SAS_VIDEO, &Glue_writes);
	read_pointers = Glue_reads;
	Glue_set_vid_wrt_ptrs( &simple_writes );
	Glue_set_vid_rd_ptrs( &simple_reads );
#endif /* not EGG or C_VID or A_VID */
#endif /* A2CPU */
#endif /* A3CPU */

#endif /* JOKER */
#endif /* GISP_CPU */

#ifdef CPU_40_STYLE
	setVideochain(3);
	SetWritePointers();
	SetReadPointers(3);
#endif  /* CPU_40_STYLE */

	sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);

	current_mode = -1;                              /* Only used by outb  */

	set_char_height(8);
	set_pc_pix_height(1);
	set_host_pix_height(2);
	set_word_addressing(TRUE);
	set_screen_height(199);
	set_screen_limit(0x4000);
	set_horiz_total(80);                    /* calculate screen params from this val, and prev 2 */
	set_pix_width(1);
	set_pix_char_width(8);

	set_cga_mode(TEXT);
	set_cursor_height(CGA_CURS_HEIGHT);
	set_cursor_start(8-CGA_CURS_HEIGHT);
	set_screen_start(0);

	check_malloc(cga_screen_buf, CGA_REGEN_LENGTH, IU8);
	set_screen_ptr(cga_screen_buf);
	setVideoscreen_ptr(get_screen_ptr(0));

	sas_fillsw(CGA_REGEN_START, (7 << 8)| ' ', CGA_REGEN_LENGTH >> 1);
						/* Fill with blanks      */

	bios_ch2_byte_wrt_fn = simple_bios_byte_wrt;
	bios_ch2_word_wrt_fn = simple_bios_word_wrt;
#endif   //NEC_98
}

void cga_term   IFN0()
{
#ifndef NEC_98
    io_addr i;

    /*
     * Disconnect the IO chip select logic for this adapter
     */

    for(i = CGA_PORT_START; i <= CGA_PORT_END; i++)
	io_disconnect_port(i, CGA_ADAPTOR);
    /*
     * Disconnect RAM from the adaptor
     */
    sas_disconnect_memory(gvi_pc_low_regen,gvi_pc_high_regen);

    if (cga_screen_buf != 0)
    {
	host_free(cga_screen_buf);
	cga_screen_buf = 0;
    }
#endif   //NEC_98
}


#if !defined(EGG) && !defined(C_VID) && !defined(A_VID)

GLOBAL CGA_ONLY_GLOBS *VGLOBS = NULL;
LOCAL CGA_ONLY_GLOBS CgaOnlyGlobs;
/*(
============================ setup_vga_globals =============================
PURPOSE:        This function is provided for CGA-only builds to set up a
		dummy VGLOBS structure which avoids the need to ifdef all
		references to VGLOBS->dirty_flag and VGLOBS->screen_ptr.
INPUT:          None.
OUTPUT:         None.
============================================================================
)*/
GLOBAL void setup_vga_globals IFN0()
{
#ifndef NEC_98
#ifndef CPU_40_STYLE    /* Evid interface */
	VGLOBS = &CgaOnlyGlobs;
#endif
#endif   //NEC_98
}
#endif  /* not EGG or C_VID or A_VID */
#endif  /* !NTVDM | (NTVDM & !X86GFX) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\ega_prts.c ===
#include "insignia.h"
#include "host_def.h"
/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DOCUMENT 		: name and number

RELATED DOCS		: include all relevant references

DESIGNER		:

REVISION HISTORY	:
First version		: 13 July 1988, J.Roper

SUBMODULE NAME		: ega		

SOURCE FILE NAME	: ega_ports.c

PURPOSE			: emulation of EGA registers (ports).
			  Calls lower levels of the EGA emulation to do the real work.

static char SccsID[]="@(#)ega_ports.c	1.54 07/18/94 Copyright Insignia Solutions Ltd.";


[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

	INCLUDE FILE : ega_ports.gi

[1.1    INTERMODULE EXPORTS]

	PROCEDURES() :
			void ega_init()
			void ega_term()
			int ega_get_line_compare()	(* hunter only *)
			int ega_get_max_scan_lines()	(* hunter only *)

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]
-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
     (not o/s objects or standard libs)

	PROCEDURES() :
			io_define_inb
			io_define_outb
			io_connect_port
			io_disconnect_port

	DATA 	     : 	give name, and source module name

-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

DATA OBJECTS	  :	specify in following procedure descriptions
			how these are accessed (read/modified)

FILES ACCESSED    :	NONE

DEVICES ACCESSED  :	NONE

SIGNALS CAUGHT	  :	NONE

SIGNALS ISSUED	  :	NONE


[1.4.2 EXPORTED OBJECTS]
=========================================================================
PROCEDURE	  : 	ega_init

PURPOSE		  : 	initialize EGA.

PARAMETERS	  :	none

GLOBALS		  :	none

DESCRIPTION	  : 	establish ega ports.
			initialize ega code to sensible state.

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	ega_term

PURPOSE		  : 	terminate EGA.

PARAMETERS	  :	none

GLOBALS		  :	none

DESCRIPTION	  : 	remove ega ports.
			free up allocated memory etc.

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	ega_seq_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to the sequencer chip's ports, and pass
			appropriate info to ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	ega_crtc_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to the sequencer chip's ports, and pass
			appropriate info to ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	ega_crtc_inb((io_addr) port, (half_word) *value)

PURPOSE		  : 	deal with an attempt to read a byte from one of the crtc's register ports,
			and gets info from appropriate ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	pointer to memory byte where value read from port should go.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	ega_gc_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to the graphics controller chip's ports,
			and pass appropriate info to ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	ega_ac_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to the attribute controller chip's ports, and pass
			appropriate info to ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	ega_misc_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to the miscellaneous register's port, and pass
			appropriate info to ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	ega_feat_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to the Feature Control register's port, and pass
			appropriate info to ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	ega_ipstat0_inb((io_addr) port, (half_word) *value)

PURPOSE		  : 	deal with an attempt to read a byte from the input status register 0 port,
			and gets info from appropriate ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	pointer to memory byte where value read from port should go.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	ega_ipstat1_inb((io_addr) port, (half_word) *value)

PURPOSE		  : 	deal with an attempt to read a byte from the input status register 1 port,
			and gets info from appropriate ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	pointer to memory byte where value read from port should go.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	int ega_get_line_compare()

PURPOSE		  : 	Hunter only - returns the line compare value
			from the crtc registers structure

PARAMETERS	  :	none

GLOBALS		  :	none

DESCRIPTION	  : 	Obtains the line compare value from bit 4 of the
			overflow register (0x7) and the line compare
			register (0x18).

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================

PROCEDURE	  : 	int ega_get_max_scan_lines()

PURPOSE		  : 	Hunter only - returns the maximum scan lines value
			from the crtc registers structure

PARAMETERS	  :	none

GLOBALS		  :	none

DESCRIPTION	  : 	Obtains the max scan lines value from the max scan
			lines register (0x9).

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================


/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]						*/

/* [3.1.1 #INCLUDES]                                                    */


#ifndef REAL_VGA	/* ega port handling moved to host for REAL_VGA */
#ifdef EGG

#include	"xt.h"
#include	CpuH
#include	"debug.h"
#include        "timer.h"
#include	"sas.h"
#include	"gmi.h"
#include	"gvi.h"
#include	"ios.h"
#include        "ica.h"
#include        "gfx_upd.h"
#include	"egacpu.h"
#include	"egagraph.h"
#include	"egaread.h"
#include	"egamode.h"
#include	"error.h"
#include	"config.h"

#include	"host_gfx.h"
#include	"egaports.h"

#ifdef GORE
#include  "gore.h"
#endif /* GORE */

#include  "ga_mark.h"
#include  "ga_defs.h"

/* [3.2 INTERMODULE EXPORTS]						*/


/* [3.1.2 DECLARATIONS]                                                 */

IMPORT	void	ega_mode_init IPT0();
IMPORT	int	get_ega_switch_setting IPT0();
IMPORT void v7_get_banks IPT2(UTINY *, rd_bank, UTINY *, wrt_bank );
#ifndef cursor_changed
IMPORT void cursor_changed IPT2(int, x, int, y);
#endif /* cursor_changed */
IMPORT void update_shift_count IPT0();

/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]						*/

LOCAL	void	vote_ega_mode IPT0();
LOCAL void	ega_seq_outb_index IPT2(io_addr, port, half_word, value);
LOCAL void	ega_crtc_outb IPT2(io_addr, port, half_word, value);
LOCAL void	ega_crtc_inb IPT2(io_addr, port, half_word *, value);
LOCAL void	ega_ac_outb IPT2(io_addr, port, half_word, value);
LOCAL void	ega_misc_outb IPT2(io_addr, port, half_word, value);
LOCAL void	ega_feat_outb IPT2(io_addr, port, half_word, value);
LOCAL void	ega_ipstat0_inb IPT2(io_addr, port, half_word *, value);
LOCAL void	ega_ipstat1_inb IPT2(io_addr, port, half_word *, value);


/* [5.1.1 #DEFINES]							*/
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_EGA.seg"
#endif

GLOBAL VOID ega_gc_outw IPT2(io_addr, port, word, outval);

/*
 * EGA_PLANE_DISP_SIZE is already declared in egaports.h. However if V7VGA is
 * defined using this definition will cause problems. See BCN 1486 for details.
 */
#define EGA_PLANE_SZ	0x10000

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]			*/
#ifdef BIT_ORDER1
typedef	union
{
	struct {
		unsigned abyte : 8;
    	} as;
    	struct {
	    unsigned hardware_reset		: 1,	/* NO		*/
	    	     word_or_byte_mode		: 1,	/* YES 		*/
	    	     address_wrap		: 1,	/* NO 		*/
	    	     output_control		: 1,	/* YES - screen goes black		*/
	    	     count_by_two		: 1,	/* NO		*/
	    	     horizontal_retrace_select	: 1,	/* NO		*/
	    	     select_row_scan_counter	: 1,	/* NO		*/
		     compatibility_mode_support	: 1;	/* YES - CGA graphics banks		*/
	} as_bfld;
} MODE_CONTROL;

typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
    	struct {
	    unsigned not_used				: 3,
	    	     line_compare_bit_8			: 1,	/* YES	*/
	    	     start_vertical_blank_bit_8		: 1,	/* NO	*/
	    	     vertical_retrace_start_bit_8	: 1,	/* NO	*/
	    	     vertical_display_enab_end_bit_8	: 1,	/* YES	*/
		     vertical_total_bit_8		: 1;	/* NO	*/
	} as_bfld;
} CRTC_OVERFLOW;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 3,
		     maximum_scan_line			: 5;	/* YES					*/
	} as_bfld;
} MAX_SCAN_LINE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 3,
		     cursor_start			: 5;	/* YES					*/
	} as_bfld;
} CURSOR_START;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 1,
		     cursor_skew_control		: 2,	/* NO					*/
		     cursor_end				: 5;	/* YES					*/
	} as_bfld;
} CURSOR_END;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used			: 6,
	    	     synchronous_reset		: 1,		/* Ditto (could implement as enable_ram)*/
		     asynchronous_reset		: 1;		/* NO - damages video and font RAM	*/
	} as_bfld;
} SEQ_RESET;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used			: 4,
	    	     dot_clock			: 1,		/* YES - distinguishes 40 or 80 chars	*/
	    	     shift_load			: 1,		/* NO					*/
	    	     bandwidth			: 1,		/* NO					*/
		     eight_or_nine_dot_clocks	: 1;		/* NO - only for mono display		*/
	} as_bfld;
} CLOCKING_MODE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used			: 4,
		     all_planes			: 4;		/* YES					*/
	} as_bfld;
} MAP_MASK;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used			: 4,
	    	     character_map_select_b	: 2,		/* YES					*/
		     character_map_select_a	: 2;		/* YES					*/
    	} as_bfld;
	struct {
	    unsigned not_used			: 4,
	    	     map_selects		: 4;		/* YES					*/
    	} character;
} CHAR_MAP_SELECT;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned
	    	     not_used			: 5,		/* If above 2 not both 1, bank 0 set 2	*/
	    	     not_odd_or_even		: 1,		/* YES (check consistency)		*/
	    	     extended_memory		: 1,		/* NO - assume full 256K on board	*/
		     alpha_mode			: 1;		/* YES (check consistency)		*/
	} as_bfld;
} MEMORY_MODE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 4,
		     set_or_reset			: 4;	/* YES - write mode 0 only		*/
	} as_bfld;
} SET_OR_RESET;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 4,
		     enable_set_or_reset		: 4;	/* YES - write mode 0 only		*/
	} as_bfld;
} ENABLE_SET_OR_RESET;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 4,
		     color_compare			: 4;	/* YES - read mode 1 only		*/
	} as_bfld;
} COLOR_COMPARE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 3,
	    	     function_select			: 2,	/* YES - write mode 0 only		*/
		     rotate_count			: 3;	/* YES - write mode 0 only		*/
	} as_bfld;
} DATA_ROTATE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 5,
		 map_select				: 3;	/* YES  				*/
	} as_bfld;
} READ_MAP_SELECT;

typedef	union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 2,
	    	     shift_register_mode		: 1,	/* YES - CGA colour graphics		*/
	    	     odd_or_even			: 1,	/* YES (check for consistency)		*/
	    	     read_mode				: 1,	/* YES					*/
	    	     test_condition			: 1,	/* NO					*/
		     write_mode				: 2;	/* YES					*/
	} as_bfld;
} MODE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 4,
	    	     memory_map				: 2,	/* YES - location of EGA in M		*/
	    	     odd_or_even			: 1,	/* YES (check consistency)		*/
		     graphics_mode			: 1;	/* YES					*/
	} as_bfld;
} MISC_REG;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 4,
		     color_dont_care			: 4;	/* YES - read mode 1 only		*/
	} as_bfld;
} COLOR_DONT_CARE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned
	    	     not_used				: 4,
	    	     background_intensity_or_blink	: 1,	/* NO - never blink			*/
	    	     enable_line_graphics_char_codes	: 1,	/* NO mono display only			*/
	    	     display_type			: 1,	/* NO - always colour display		*/
		     graphics_mode			: 1;	/* YES - with Sequencer Mode reg	*/
	} as_bfld;
} AC_MODE_CONTROL;

typedef union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	unsigned vertical_retrace_polarity	: 1,		/* YES - switch between 200/350 lines	*/
    		 horizontal_retrace_polarity	: 1,		/* NO - probably destroys display!	*/
    		 page_bit_odd_even		: 1,		/* NO - selects 32k page in odd/even?	*/
    		 disable_internal_video_drivers	: 1,		/* NO - like switching PC off		*/
    		 clock_select			: 2,		/* YES - only for switch address	*/
    		 enable_ram			: 1,		/* YES - writes to display mem ignored	*/
		 io_address_select		: 1;		/* NO - only used for mono screens	*/
	} as_bfld;
} MISC_OUTPUT_REG;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	unsigned not_used			: 4,
    		 reserved			: 2,		/* YES - ignore				*/
		 feature_control		: 2;		/* NO - device not supported		*/
	} as_bfld;
} FEAT_CONT_REG;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	unsigned crt_interrupt			: 1,		/* YES - sequence if not timing		*/
    		 reserved			: 2,		/* YES - all bits 1			*/
    		 switch_sense			: 1,		/* YES - switch selected by clock sel.	*/
		 not_used			: 4;		/* YES - all bits 1			*/
	} as_bfld;
} INPUT_STAT_REG0;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
    	struct {
	    unsigned not_used				: 2,
		     video_status_mux			: 2,	/* NO					*/
		     color_plane_enable			: 4;	/* YES  NB. affects attrs in text mode	*/
	} as_bfld;
} COLOR_PLANE_ENABLE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	unsigned not_used			: 1,		/* YES - set to 1			*/
    		 diagnostic_0			: 1,		/* NO - set to 0			*/
    		 diagnostic_1			: 1,		/* NO - set to 0			*/
    		 vertical_retrace		: 1,		/* YES - sequence only			*/
    		 light_pen_switch		: 1,		/* YES - set to 0			*/
    		 light_pen_strobe		: 1,		/* YES - set to 1			*/
		 display_enable			: 1;		/* YES - sequence only			*/
	} as_bfld;
} INPUT_STAT_REG1;
#endif
#ifdef BIT_ORDER2
typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned compatibility_mode_support		: 1,	/* YES - CGA graphics banks		*/
	    	     select_row_scan_counter		: 1,	/* NO					*/
	    	     horizontal_retrace_select		: 1,	/* NO					*/
	    	     count_by_two			: 1,	/* NO					*/
	    	     output_control			: 1,	/* YES - screen goes black		*/
	    	     address_wrap			: 1,	/* NO 					*/
	    	     word_or_byte_mode			: 1,	/* YES 					*/
	    	     hardware_reset			: 1;	/* NO					*/
	} as_bfld;
} MODE_CONTROL;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned vertical_total_bit_8		: 1,	/* NO					*/
	    	     vertical_display_enab_end_bit_8	: 1,	/* YES					*/
	    	     vertical_retrace_start_bit_8	: 1,	/* NO					*/
	    	     start_vertical_blank_bit_8		: 1,	/* NO					*/
	    	     line_compare_bit_8			: 1,	/* YES					*/
	    	     not_used				: 3;
	} as_bfld;
} CRTC_OVERFLOW;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned maximum_scan_line			: 5,	/* YES					*/
	    	     not_used				: 3;
	} as_bfld;
} MAX_SCAN_LINE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned cursor_start			: 5,	/* YES					*/
	    	     not_used				: 3;
	} as_bfld;
} CURSOR_START;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned cursor_end				: 5,	/* YES					*/
		     cursor_skew_control		: 2,	/* NO					*/
	    	     not_used				: 1;
	} as_bfld;
} CURSOR_END;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned asynchronous_reset		: 1,		/* NO - damages video and font RAM	*/
	    	     synchronous_reset		: 1,		/* Ditto (could implement as enable_ram)*/
	    	     not_used			: 6;
	} as_bfld;
} SEQ_RESET;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned eight_or_nine_dot_clocks	: 1,		/* NO - only for mono display		*/
	    	     bandwidth			: 1,		/* NO					*/
	    	     shift_load			: 1,		/* NO					*/
	    	     dot_clock			: 1,		/* YES - distinguishes 40 or 80 chars	*/
	    	     not_used			: 4;
	} as_bfld;
} CLOCKING_MODE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned all_planes			: 4,		/* YES					*/
		     not_used			: 4;
	} as_bfld;
} MAP_MASK;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned character_map_select_a	: 2,		/* YES					*/
	    	     character_map_select_b	: 2,		/* YES					*/
	    	     not_used			: 4;
    	} as_bfld;
	struct {
	    unsigned map_selects		: 4,		/* YES					*/
	    	     not_used			: 4;
    	} character;
} CHAR_MAP_SELECT;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned alpha_mode			: 1,		/* YES (check consistency)		*/
	    	     extended_memory		: 1,		/* NO - assume full 256K on board	*/
	    	     not_odd_or_even		: 1,		/* YES (check consistency)		*/
	    	     not_used			: 5;		/* If above 2 not both 1, bank 0 set 2	*/
	} as_bfld;
} MEMORY_MODE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned set_or_reset			: 4,	/* YES - write mode 0 only		*/
	    	     not_used				: 4;
	} as_bfld;
} SET_OR_RESET;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned enable_set_or_reset		: 4,	/* YES - write mode 0 only		*/
	    	     not_used				: 4;
	} as_bfld;
} ENABLE_SET_OR_RESET;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned color_compare			: 4,	/* YES - read mode 1 only		*/
	    	     not_used				: 4;
	} as_bfld;
} COLOR_COMPARE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned rotate_count			: 3,	/* YES - write mode 0 only		*/
	    	     function_select			: 2,	/* YES - write mode 0 only		*/
	    	     not_used				: 3;
	} as_bfld;
} DATA_ROTATE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned map_select				: 3,	/* YES - read mode 0 only		*/
	         not_used				: 5;
	} as_bfld;
} READ_MAP_SELECT;

typedef	union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned write_mode				: 2,	/* YES					*/
	    	     test_condition			: 1,	/* NO					*/
	    	     read_mode				: 1,	/* YES					*/
	    	     odd_or_even			: 1,	/* YES (check for consistency)		*/
	    	     shift_register_mode		: 1,	/* YES - CGA colour graphics		*/
	    	     not_used				: 2;
	} as_bfld;
} MODE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned graphics_mode			: 1,	/* YES					*/
	    	     odd_or_even			: 1,	/* YES (check consistency)		*/
	    	     memory_map				: 2,	/* YES - location of EGA in M		*/
	    	     not_used				: 4;
	} as_bfld;
} MISC_REG;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned color_dont_care			: 4,	/* YES - read mode 1 only		*/
	    	     not_used				: 4;
	} as_bfld;
} COLOR_DONT_CARE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned graphics_mode			: 1,	/* YES - with Sequencer Mode reg	*/
	    	     display_type			: 1,	/* NO - always colour display		*/
	    	     enable_line_graphics_char_codes	: 1,	/* NO mono display only			*/
	    	     background_intensity_or_blink	: 1,	/* NO - never blink			*/
	    	     not_used				: 4;
	} as_bfld;
} AC_MODE_CONTROL;

typedef union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	unsigned io_address_select		: 1,		/* NO - only used for mono screens	*/
    		 enable_ram			: 1,		/* YES - writes to display mem ignored	*/
    		 clock_select			: 2,		/* YES - only for switch address	*/
    		 disable_internal_video_drivers	: 1,		/* NO - like switching PC off		*/
    		 page_bit_odd_even		: 1,		/* NO - selects 32k page in odd/even?	*/
    		 horizontal_retrace_polarity	: 1,		/* NO - probably destroys display!	*/
    		 vertical_retrace_polarity	: 1;		/* YES - switch between 200/350 lines	*/
	} as_bfld;
} MISC_OUTPUT_REG;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	unsigned feature_control		: 2,		/* NO - device not supported		*/
    		 reserved			: 2,		/* YES - ignore				*/
    		 not_used			: 4;
	} as_bfld;
} FEAT_CONT_REG;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	unsigned not_used			: 4,		/* YES - all bits 1			*/
    		 switch_sense			: 1,		/* YES - switch selected by clock sel.	*/
    		 reserved			: 2,		/* YES - all bits 1			*/
    		 crt_interrupt			: 1;		/* YES - sequence if not timing		*/
	} as_bfld;
} INPUT_STAT_REG0;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
    	struct {
	    unsigned color_plane_enable			: 4,	/* YES  NB. affects attrs in text mode	*/
		     video_status_mux			: 2,	/* NO					*/
	    	     not_used				: 2;
	} as_bfld;
} COLOR_PLANE_ENABLE;

typedef	union
{
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	unsigned display_enable			: 1,		/* YES - sequence only			*/
    		 light_pen_strobe		: 1,		/* YES - set to 1			*/
    		 light_pen_switch		: 1,		/* YES - set to 0			*/
    		 vertical_retrace		: 1,		/* YES - sequence only			*/
    		 diagnostic_1			: 1,		/* NO - set to 0			*/
    		 diagnostic_0			: 1,		/* NO - set to 0			*/
    		 not_used			: 1;		/* YES - set to 1			*/
	} as_bfld;
} INPUT_STAT_REG1;
#endif



/* [5.1.3 PROCEDURE() DECLARATIONS]					*/


/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS 					*/

/*

/* EGA REGISTERS */
/* Comments after bitfields indicate whether change of value affects emulated screen display or memory interface */

/* Registers not contained in an LSI device */

static	MISC_OUTPUT_REG	miscellaneous_output_register;

static	FEAT_CONT_REG	feature_control_register;

static	INPUT_STAT_REG0	input_status_register_zero;

static	INPUT_STAT_REG1	input_status_register_one;

/* The Sequencer Registers */
#ifdef BIT_ORDER1
static struct
{
    union
    {
	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	    unsigned not_used			: 5,
		     index			: 3;
    	} as_bfld;
    } address;

    SEQ_RESET		reset;
    CLOCKING_MODE	clocking_mode;
    MAP_MASK		map_mask;
    CHAR_MAP_SELECT	character_map_select;
    MEMORY_MODE		memory_mode;
} sequencer;


/* The CRT Controller Registers */

static struct
{
    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	    unsigned not_used				: 3,
		     index				: 5;
    	} as_bfld;
    } address;

    byte horizontal_total;					/* NO - screen trash if wrong value	*/
    byte horizontal_display_end;				/* YES - defines line length!!		*/
    byte start_horizontal_blanking;				/* NO					*/

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 1,
	    	     display_enable_skew_control	: 2,	/* NO					*/
		     end_blanking			: 5;	/* NO					*/
	} as_bfld;
    } end_horizontal_blanking;

    byte start_horizontal_retrace;				/* NO					*/

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 1,
	    	     horizontal_retrace_delay		: 2,	/* NO					*/
		     end_horizontal_retrace		: 5;	/* NO					*/
	} as_bfld;
    } end_horizontal_retrace;

    byte vertical_total;					/* NO					*/
    CRTC_OVERFLOW	crtc_overflow;

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 3,
		     preset_row_scan			: 5;	/* NO					*/
	} as_bfld;
    } preset_row_scan;

    MAX_SCAN_LINE	maximum_scan_line;
    CURSOR_START	cursor_start;
    CURSOR_END		cursor_end;
    byte start_address_high;					/* YES					*/
    byte start_address_low;					/* YES					*/
    byte cursor_location_high;					/* YES					*/
    byte cursor_location_low;					/* YES					*/
    byte vertical_retrace_start;				/* NO					*/
    byte light_pen_high;					/* NO					*/

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned
	    	     not_used				: 2,
	    	     enable_vertical_interrupt		: 1,	/* YES - ditto				*/
	    	     clear_vertical_interrupt		: 1,	/* YES - needs investigation		*/
		     vertical_retrace_end		: 4;	/* NO					*/
	} as_bfld;
    } vertical_retrace_end;

    byte light_pen_low;						/* NO					*/
    byte vertical_display_enable_end;				/* YES - defines screen height		*/
    byte offset;						/* YES (maybe!)	???????			*/

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 3,
		     underline_location			: 5;	/* NO (mono display only)		*/
	} as_bfld;
    } underline_location;

    byte start_vertical_blanking;				/* NO					*/
    byte end_vertical_blanking;					/* NO					*/
    MODE_CONTROL	mode_control;
    byte line_compare;						/* YES					*/

} crt_controller;


/* The Graphics Controller Registers */

static struct
{
    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	    unsigned not_used				: 4,
		     index				: 4;
    	} as_bfld;
    } address;

    SET_OR_RESET	set_or_reset;
    ENABLE_SET_OR_RESET	enable_set_or_reset;
    COLOR_COMPARE	color_compare;
    DATA_ROTATE		data_rotate;
    READ_MAP_SELECT	read_map_select;
    MODE		mode;
    MISC_REG		miscellaneous;
    COLOR_DONT_CARE	color_dont_care;
    byte bit_mask_register;					/* YES - write modes 0 & 2		*/
    byte graphics_1_position;					/* NO					*/
    byte graphics_2_position;					/* NO					*/
} graphics_controller;


/* The Attribute Controller Registers */

static struct
{
    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	    unsigned not_used				: 3,
		     index				: 5;
    	} as_bfld;
    } address;

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned
		     not_used				: 2,	/* YES					*/
		     secondary_red			: 1,	/* YES					*/
		     secondary_green			: 1,	/* YES					*/
		     secondary_blue			: 1,	/* YES					*/
		     red				: 1,	/* YES					*/
		     green				: 1,	/* YES					*/
		     blue				: 1;	/* YES					*/
	} as_bfld;
    } palette[EGA_PALETTE_SIZE];

    AC_MODE_CONTROL	mode_control;

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 2,
		     secondary_red_border		: 1,	/* YES					*/
		     secondary_green_border		: 1,	/* YES					*/
		     secondary_blue_border		: 1,	/* YES					*/
		     red_border				: 1,	/* YES					*/
		     green_border			: 1,	/* YES					*/
		     blue_border			: 1;	/* YES - real thing isn't good at this	*/
	} as_bfld;
    } overscan_color;

    COLOR_PLANE_ENABLE	color_plane_enable;

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned not_used				: 4,
		     horizontal_pel_panning		: 4;	/* NO					*/
	} as_bfld;
    } horizontal_pel_panning;
} attribute_controller;
#endif

#ifdef BIT_ORDER2
static struct
{
    union
    {
	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	    unsigned index				: 3,
		     not_used				: 5;
    	} as_bfld;
    } address;

    SEQ_RESET		reset;
    CLOCKING_MODE	clocking_mode;
    MAP_MASK		map_mask;
    CHAR_MAP_SELECT	character_map_select;
    MEMORY_MODE		memory_mode;
} sequencer;


/* The CRT Controller Registers */

static struct
{
    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	    unsigned index				: 5,
		     not_used				: 3;
    	} as_bfld;
    } address;

    byte horizontal_total;					/* NO - screen trash if wrong value	*/
    byte horizontal_display_end;				/* YES - defines line length!!		*/
    byte start_horizontal_blanking;				/* NO					*/

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned end_blanking			: 5,	/* NO					*/
	    	     display_enable_skew_control	: 2,	/* NO					*/
	    	     not_used				: 1;
	} as_bfld;
    } end_horizontal_blanking;

    byte start_horizontal_retrace;				/* NO					*/

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned end_horizontal_retrace		: 5,	/* NO					*/
	    	     horizontal_retrace_delay		: 2,	/* NO					*/
	    	     not_used				: 1;
	} as_bfld;
    } end_horizontal_retrace;

    byte vertical_total;					/* NO					*/
    CRTC_OVERFLOW	crtc_overflow;

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned preset_row_scan			: 5,	/* NO					*/
	    	     not_used				: 3;
	} as_bfld;
    } preset_row_scan;

    MAX_SCAN_LINE	maximum_scan_line;
    CURSOR_START	cursor_start;
    CURSOR_END		cursor_end;
    byte start_address_high;					/* YES					*/
    byte start_address_low;					/* YES					*/
    byte cursor_location_high;					/* YES					*/
    byte cursor_location_low;					/* YES					*/
    byte vertical_retrace_start;				/* NO					*/
    byte light_pen_high;					/* NO					*/

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned vertical_retrace_end		: 4,	/* NO					*/
	    	     clear_vertical_interrupt		: 1,	/* YES - needs investigation		*/
	    	     enable_vertical_interrupt		: 1,	/* YES - ditto				*/
	    	     not_used				: 2;
	} as_bfld;
    } vertical_retrace_end;

    byte light_pen_low;						/* NO					*/
    byte vertical_display_enable_end;				/* YES - defines screen height		*/
    byte offset;						/* YES (maybe!)	???????			*/

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned underline_location			: 5,	/* NO (mono display only)		*/
	    	     not_used				: 3;
	} as_bfld;
    } underline_location;

    byte start_vertical_blanking;				/* NO					*/
    byte end_vertical_blanking;					/* NO					*/
    MODE_CONTROL	mode_control;
    byte line_compare;						/* YES					*/

} crt_controller;


/* The Graphics Controller Registers */

static struct
{
    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	    unsigned index				: 4,
    	    	     not_used				: 4;
    	} as_bfld;
    } address;

    SET_OR_RESET	set_or_reset;
    ENABLE_SET_OR_RESET	enable_set_or_reset;
    COLOR_COMPARE	color_compare;
    DATA_ROTATE		data_rotate;
    READ_MAP_SELECT	read_map_select;
    MODE		mode;
    MISC_REG		miscellaneous;
    COLOR_DONT_CARE	color_dont_care;
    byte bit_mask_register;					/* YES - write modes 0 & 2		*/
    byte graphics_1_position;					/* NO					*/
    byte graphics_2_position;					/* NO					*/
} graphics_controller;


/* The Attribute Controller Registers */

static struct
{
    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
    	    unsigned index				: 5,
    	    	     not_used				: 3;
    	} as_bfld;
    } address;

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned blue				: 1,	/* YES					*/
		     green				: 1,	/* YES					*/
		     red				: 1,	/* YES					*/
		     secondary_blue			: 1,	/* YES					*/
		     secondary_green			: 1,	/* YES					*/
		     secondary_red			: 1,	/* YES					*/
		     not_used				: 2;	/* YES					*/
	} as_bfld;
    } palette[EGA_PALETTE_SIZE];

    AC_MODE_CONTROL	mode_control;

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned blue_border			: 1,	/* YES - real thing isn't good at this	*/
		     green_border			: 1,	/* YES					*/
		     red_border				: 1,	/* YES					*/
		     secondary_blue_border		: 1,	/* YES					*/
		     secondary_green_border		: 1,	/* YES					*/
		     secondary_red_border		: 1,	/* YES					*/
		     not_used				: 2;
	} as_bfld;
    } overscan_color;

    COLOR_PLANE_ENABLE	color_plane_enable;

    union
    {
    	struct {
		unsigned abyte : 8;
	} as;
	struct {
	    unsigned horizontal_pel_panning		: 4,	/* NO					*/
	    	     not_used				: 4;
	} as_bfld;
    } horizontal_pel_panning;
} attribute_controller;
#endif

static	boolean	ac_index_state = NO;
extern half_word bg_col_mask; /* Used to work out the background colour */

IMPORT VOID _ega_gc_outb_index IPT2(io_addr,port,half_word,value);
IMPORT VOID _ega_gc_outb_mask IPT2(io_addr,port,half_word,value);
IMPORT VOID _ega_gc_outb_mask_ff IPT2(io_addr,port,half_word,value);

/* Declarations for new multi-routine graphics controller */
void	ega_gc_set_reset IPT2(io_addr, port, half_word, value);
void	ega_gc_enable_set IPT2(io_addr, port, half_word, value);
void	ega_gc_compare IPT2(io_addr, port, half_word, value);
void	ega_gc_rotate IPT2(io_addr, port, half_word, value);
void	ega_gc_read_map IPT2(io_addr, port, half_word, value);
void	ega_gc_mode IPT2(io_addr, port, half_word, value);
void	ega_gc_misc IPT2(io_addr, port, half_word, value);
void	ega_gc_dont_care IPT2(io_addr, port, half_word, value);
LOCAL void	ega_gc_mask IPT2(io_addr, port, half_word, value);
void	ega_gc_mask_ff IPT2(io_addr, port, half_word, value);
LOCAL void	ega_index_invalid IPT2(io_addr, port, half_word, value);

void (*ega_gc_regs[]) IPT2(io_addr, port, half_word, value) = {
      ega_gc_set_reset,
      ega_gc_enable_set,
      ega_gc_compare,
      ega_gc_rotate,
      ega_gc_read_map,
      ega_gc_mode,
      ega_gc_misc,
      ega_gc_dont_care,
      ega_gc_mask,
      ega_index_invalid,
      ega_index_invalid,
      ega_index_invalid,
      ega_index_invalid,
      ega_index_invalid,
      ega_index_invalid,
      ega_index_invalid,
};

#ifndef	A2CPU
void (*ega_gc_regs_cpu[]) IPT2(io_addr,port,half_word,value) = {
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
      NULL,
};
#endif	/* A2CPU */

/* Declarations for new seqencer code */
void	ega_seq_reset IPT2(io_addr, port, half_word, value);
void	ega_seq_clock IPT2(io_addr, port, half_word, value);
void	ega_seq_map_mask IPT2(io_addr, port, half_word, value);
void	ega_seq_char_map IPT2(io_addr, port, half_word, value);
void	ega_seq_mem_mode IPT2(io_addr, port, half_word, value);

void (*ega_seq_regs[]) IPT2(io_addr, port, half_word, value) =
{
      ega_seq_reset,
      ega_seq_clock,
      ega_seq_map_mask,
      ega_seq_char_map,
      ega_seq_mem_mode,
      ega_index_invalid,
      ega_index_invalid,
      ega_index_invalid,
};


/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]				*/

/*
==========================================================================
FUNCTION	:	set_index_state()
PURPOSE		:	Set the attribute controller to use the next value
			written to its port as the index value.
EXTERNAL OBJECTS:	
RETURN VALUE	:	None
INPUT  PARAMS	:	None
RETURN PARAMS   :	None
==========================================================================
*/

void	set_index_state IFN0()
{
	/*
	 * Seems strange, but in_index_state changes the state & returns the result
	 * so we set state to NO, so that next call of in_index_state will return YES
	 */
	ac_index_state = NO;
}

/*
==========================================================================
FUNCTION	:	in_index_state()
PURPOSE		:	To determine if the value written to the attribute
			controller is destined for the index register, or
			another register specified by the current index
			value.
EXTERNAL OBJECTS:	
RETURN VALUE	:	Boolean
INPUT  PARAMS	:	None
RETURN PARAMS   :	None
==========================================================================
*/

boolean	in_index_state IFN0()
{
	ac_index_state = ! ac_index_state;
	return(ac_index_state);
}

/*
==========================================================================
FUNCTION	:	do_new_cursor()
PURPOSE		:	deals with the shape of the cursor according to
			char_height, cursor_start and cursor_end. See Tech
			Memo 88.6.1 for details.
EXTERNAL OBJECTS:	EGA_GRAPH.cursor_start,EGA_GRAPH.cursor_height,EGA_cursor_start1,
			EGA_GRAPH.cursor_height1,host_cursor_has_changed().
RETURN VALUE	:	None
INPUT  PARAMS	:	None
RETURN PARAMS   :	None
==========================================================================
*/

LOCAL void	do_new_cursor IFN0()
{
#ifndef NEC_98

	note_entrance0("do_new_cursor()");

#ifdef VGG
    if ( video_adapter == VGA ) {
		note_entrance0("VGA cursor");
		set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_height(crt_controller.cursor_end.as_bfld.cursor_end - crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_start1(0);	/* cursor never splits */
		set_cursor_height1(0);
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
    } else {
#endif
	if (crt_controller.cursor_start.as_bfld.cursor_start >= (unsigned)get_char_height() ) {
		note_entrance0("No cursor");
		set_cursor_visible(FALSE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start | 0x20,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
	else if (crt_controller.cursor_end.as_bfld.cursor_end == 0) {
		note_entrance0("cursor from start to bum");
		set_cursor_start1(0);
		set_cursor_height1(0);
		set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_height(get_char_height() - get_cursor_start());
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
	else if (crt_controller.cursor_end.as_bfld.cursor_end < crt_controller.cursor_start.as_bfld.cursor_start) {
		note_entrance0("2 cursors");
		set_cursor_start1(0);
		set_cursor_height1(crt_controller.cursor_end.as_bfld.cursor_end);
		set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_height(get_char_height() - get_cursor_start());
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
	else if (crt_controller.cursor_end.as_bfld.cursor_end == crt_controller.cursor_start.as_bfld.cursor_start) {
		note_entrance0("One line cursor");
		set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_height(1);
		set_cursor_start1(0);
		set_cursor_height1(0);
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
	else if (crt_controller.cursor_end.as_bfld.cursor_end - 1 >= (unsigned)get_char_height()) {
		note_entrance0("block cursor");
		set_cursor_start(0);
		set_cursor_height(get_char_height());
		set_cursor_start1(0);
		set_cursor_height1(0);
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
	else {
		assert2(((crt_controller.cursor_end.as_bfld.cursor_end - 1) >= crt_controller.cursor_start.as_bfld.cursor_start),
				"cursor values do not match default set Start %d, End %d",
				crt_controller.cursor_end.as_bfld.cursor_end,
				crt_controller.cursor_start.as_bfld.cursor_start);
		note_entrance0("normal cursor");
		set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_height(crt_controller.cursor_end.as_bfld.cursor_end - crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_start1(0);
		set_cursor_height1(0);
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
#ifdef VGG
    }
#endif

	if(( get_cur_y() < 0 ) ||
			((( get_cur_y() + 1 ) * get_char_height()) > get_screen_height() ))
	{
		set_cursor_visible( FALSE );
	}

	base_cursor_shape_changed();
#endif   //NEC_98
}

/*
==========================================================================
FUNCTION	:	do_chain_majority_decision()
PURPOSE		:	deals with any contention regarding whether the
			ega registers indicate that the addressing of the
			planes is in chained mode or not. If the result
			of the election is a new addressing mode, then
			the video routines, read mode and paint modules
			are informed of the change.
EXTERNAL OBJECTS:	uses local ega register data to count votes.
RETURN VALUE	:	None
INPUT  PARAMS	:	None
RETURN PARAMS   :	None
==========================================================================
*/


LOCAL void	do_chain_majority_decision IFN0()
{
#ifndef NEC_98
	static	int	current_votes=0;
	int		new_votes;

	new_votes = sequencer.memory_mode.as_bfld.not_odd_or_even ? 0 : 1 ;	/* 0 - chained */
	new_votes += graphics_controller.mode.as_bfld.odd_or_even ;	/* 1 - chained */
	new_votes += graphics_controller.miscellaneous.as_bfld.odd_or_even ;	/* 1 - chained */

	if( new_votes == 1 && current_votes > 1 )
	{
		/*
		 * Transition from chained to unchained
		 */

		EGA_CPU.chain  = UNCHAINED;
		setVideochain(EGA_CPU.chain);
		ega_read_routines_update();
		ega_write_routines_update(CHAINED);
		set_memory_chained(NO);
		flag_mode_change_required();
	}
	else
		if( new_votes > 1 && current_votes == 1 )
		{
			/*
			 * Transition from unchained to chained
			 */

			EGA_CPU.chain = CHAIN2;
			setVideochain(EGA_CPU.chain);
			ega_read_routines_update();
			ega_write_routines_update(CHAINED);
			set_memory_chained(YES);
			flag_mode_change_required();
		}

	current_votes = new_votes;
#endif   //NEC_98
}


/*
7.INTERMODULE INTERFACE IMPLEMENTATION :

/*
[7.1 INTERMODULE DATA DEFINITIONS]				*/

/*
 * This structure should contain all the global definitions used by EGA
 */

struct	EGA_GLOBALS	EGA_GRAPH;
#if defined(NEC_98)
struct  NEC98_CPU_GLOBALS NEC98_CPU;
#else    //NEC_98
struct	EGA_CPU_GLOBALS	EGA_CPU;
#endif   //NEC_98

byte 	*EGA_planes;

int ega_int_enable;

GLOBAL UTINY *ega_gc_outb_index_addr;


/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]				*/

GLOBAL void
set_banking IFN2(UTINY, rd_bank, UTINY, wrt_bank)
{
#ifndef NEC_98
	ULONG roffs, woffs;
#ifdef PIG
	IMPORT ULONG pig_vid_bank;
#endif

#ifdef V7VGA
	if( get_seq_chain4_mode() && get_chain4_mode() )
	{
		roffs = (ULONG)rd_bank << 16;
		woffs = (ULONG)wrt_bank << 16;
	}
	else
	{
		roffs = (ULONG)rd_bank << 18;
		woffs = (ULONG)wrt_bank << 18;
	}
#else
		UNUSED(rd_bank);
		UNUSED(wrt_bank);
		roffs = 0;
		woffs = 0;
#endif

#ifdef PIG
	pig_vid_bank = woffs;
#endif
	setVideorplane(EGA_planes + roffs);
	setVideowplane(EGA_planes + woffs);

#ifdef	VGG
	if( get_256_colour_mode() )
		setVideov7_bank_vid_copy_off(woffs >> 2);
	else
#endif	/* VGG */
		setVideov7_bank_vid_copy_off(woffs >> 4);

#ifdef GORE
	gd.max_vis_addr = get_screen_length() - 1 + woffs;
#endif /* GORE */
#endif   //NEC_98
}

GLOBAL void
update_banking IFN0()
{
#ifndef NEC_98
	UTINY rd_bank, wrt_bank;

#ifdef V7VGA
	v7_get_banks( &rd_bank, &wrt_bank );
#else
	rd_bank = wrt_bank = 0;
#endif

	set_banking( rd_bank, wrt_bank );
#endif  //NEC_98
}

#if defined(NEC_98)
GLOBAL VOID _simple_mark_lge()
{
}

GLOBAL VOID _simple_mark_sml()
{
}

VOID    init_NEC98_globals()
{
        NEC98GLOBS->v7_vid_copy_off = 0;
        NEC98GLOBS->sr_lookup = sr_lookup;
        NEC98GLOBS->scratch = sas_scratch_address(0x10000);
        NEC98GLOBS->mark_byte = _simple_mark_sml;
        NEC98GLOBS->mark_word = _simple_mark_sml;
        NEC98GLOBS->mark_string = _simple_mark_lge;
}
#endif  //NEC_98

VOID
init_vga_globals IFN0()
{
#ifndef NEC_98
	setVideov7_bank_vid_copy_off(0);
	setVideosr_lookup(sr_lookup);
	setVideovideo_copy(&video_copy[0]);
	setVideoscratch(sas_scratch_address(0x10000));
	setVideoscreen_ptr(EGA_planes);
	setVideorotate(0);
#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX))
#ifndef CPU_40_STYLE	/* EVID */
	setVideomark_byte(_simple_mark_sml);
	setVideomark_word(_simple_mark_sml);
	setVideomark_string(_simple_mark_lge);
#else
	SetMarkPointers(0);
#endif	/* CPU_40_STYLE - EVID */
#endif


	update_banking();
#endif  //NEC_98
}

void	ega_init IFN0()
{
#ifndef NEC_98
	note_entrance0("ega_init");
	/*
	 * Define sequencer's ports
	 */

	io_define_outb(EGA_SEQ_ADAP_INDEX,ega_seq_outb_index);
	io_define_outb(EGA_SEQ_ADAP_DATA,ega_seq_reset);
	io_connect_port(EGA_SEQ_INDEX,EGA_SEQ_ADAP_INDEX,IO_WRITE);
	io_connect_port(EGA_SEQ_DATA,EGA_SEQ_ADAP_DATA,IO_WRITE);

	/*
	 * Define CRTC's ports
	 */

	io_define_outb(EGA_CRTC_ADAPTOR,ega_crtc_outb);
	io_define_inb(EGA_CRTC_ADAPTOR,ega_crtc_inb);
	io_connect_port(EGA_CRTC_INDEX,EGA_CRTC_ADAPTOR,IO_WRITE);
	io_connect_port(EGA_CRTC_DATA,EGA_CRTC_ADAPTOR,IO_READ_WRITE);

	/*
	 * Define Graphics Controller's ports
	 */

	ega_gc_outb_index_addr = (UTINY *) &graphics_controller.address;

	/*io_define_outb(EGA_GC_ADAP_INDEX,ega_gc_outb_index);*/
	io_define_out_routines(EGA_GC_ADAP_INDEX, ega_gc_outb_index, ega_gc_outw, NULL, NULL);

#ifndef CPU_40_STYLE	/* TEMPORARY */
	Cpu_define_outb(EGA_GC_ADAP_INDEX,_ega_gc_outb_index);
#endif

	io_define_outb(EGA_GC_ADAP_DATA,ega_gc_set_reset);
	Cpu_define_outb(EGA_GC_ADAP_DATA,NULL);
#ifndef A2CPU
	ega_gc_regs_cpu[8] = NULL;
#endif

	io_connect_port(EGA_GC_INDEX,EGA_GC_ADAP_INDEX,IO_WRITE);
	io_connect_port(EGA_GC_DATA,EGA_GC_ADAP_DATA,IO_WRITE);

	/*
	 * Define Attribute controller's ports
	 */

	io_define_outb(EGA_AC_ADAPTOR,ega_ac_outb);
	io_connect_port(EGA_AC_INDEX_DATA,EGA_AC_ADAPTOR,IO_WRITE);
	io_connect_port(EGA_AC_SECRET,EGA_AC_ADAPTOR,IO_WRITE);

	/*
	 * Define Miscellaneous register's port
	 */

	io_define_outb(EGA_MISC_ADAPTOR,ega_misc_outb);
	io_connect_port(EGA_MISC_REG,EGA_MISC_ADAPTOR,IO_WRITE);

	/*
	 * Define Feature controller's port
	 */

	io_define_outb(EGA_FEAT_ADAPTOR,ega_feat_outb);
	io_connect_port(EGA_FEAT_REG,EGA_FEAT_ADAPTOR,IO_WRITE);

	/*
	 * Define Input Status Register 0 port
	 */

	io_define_inb(EGA_IPSTAT0_ADAPTOR,ega_ipstat0_inb);
	io_connect_port(EGA_IPSTAT0_REG,EGA_IPSTAT0_ADAPTOR,IO_READ);

	/*
	 * Define Input Status Register 1 port
	 */

	io_define_inb(EGA_IPSTAT1_ADAPTOR,ega_ipstat1_inb);
	io_connect_port(EGA_IPSTAT1_REG,EGA_IPSTAT1_ADAPTOR,IO_READ);

	/*
	 * Initialise internals of EGA
	 * +++++++++++++++++++++++++++
	 */

	/* hardware reset sets Misc reg to 0, so.. */
	/* Perhaps this should be in 'ega_reset()'? */

	miscellaneous_output_register.as.abyte = 0;

	set_pc_pix_height(1); /* set by bit 7 of the misc reg */
	set_host_pix_height(1);

	/* Initialize address map */

	graphics_controller.miscellaneous.as.abyte = 0;
	graphics_controller.read_map_select.as_bfld.map_select = 0;

	/* Looking for bright white */

	graphics_controller.color_compare.as_bfld.color_compare = 0xf;

	/* All planes significant */

	graphics_controller.color_dont_care.as_bfld.color_dont_care = 0xf;

	/* Initialise crtc screen height fields and set screen height to be consistent */

	crt_controller.vertical_display_enable_end = 0;
	crt_controller.crtc_overflow.as_bfld.vertical_display_enab_end_bit_8 = 0;

	set_screen_height(0);

	init_vga_globals();

	EGA_CPU.fun_or_protection = 1;	/* assume complicated until we know it's easy */

	setVideobit_prot_mask(0xffffffff);

	ega_write_init();
	ega_read_init();
	ega_mode_init();	/* sets a flag in ega_mode.c to allow optimisation of mode changes without falling over */

	/*
	 * Some parts of input status register always return 1, so set fields accordingly
	 */
	input_status_register_zero.as.abyte = 0x7f ;

	/*
	 * set up some variables to get us going
	 * (They may have to be changed in the fullness of time)
	 */

	gvi_pc_low_regen  = CGA_REGEN_START;
	gvi_pc_high_regen = CGA_REGEN_END;

	choose_display_mode = choose_ega_display_mode;

	set_pix_width(1);
	set_pix_char_width(8);
	set_display_disabled(FALSE);

	set_char_height(8);
	set_screen_limit(0x8000);
	set_screen_start(0);
	set_word_addressing(YES);
	set_actual_offset_per_line(80);
	set_offset_per_line(160);	/* chained */
	set_horiz_total(80);	/* calc screen params from this and prev 3 */
	set_screen_split(511);	/* make sure there is no split screen to start with ! */

	set_prim_font_index(0);
	set_sec_font_index(0);

	set_regen_ptr(0,EGA_planes);

	/* prevent copyright message mysteriously disappearing */
	timer_video_enabled = TRUE;

#endif  //NEC_98
}

void	ega_term IFN0()
{
#ifndef NEC_98

int	index;

	note_entrance0("ega_term");

	/*
	 * Disconnect sequencer's ports
	 */

	io_disconnect_port(EGA_SEQ_INDEX,EGA_SEQ_ADAP_INDEX);
	io_disconnect_port(EGA_SEQ_DATA,EGA_SEQ_ADAP_DATA);

	/*
	 * Disconnect CRTC's ports
	 */

	io_disconnect_port(EGA_CRTC_INDEX,EGA_CRTC_ADAPTOR);
	io_disconnect_port(EGA_CRTC_DATA,EGA_CRTC_ADAPTOR);

	/*
	 * Disconnect Graphics Controller's ports
	 */

	io_disconnect_port(EGA_GC_INDEX,EGA_GC_ADAP_INDEX);
	io_disconnect_port(EGA_GC_DATA,EGA_GC_ADAP_DATA);

	/*
	 * Disconnect Attribute controller's ports
	 */

	io_disconnect_port(EGA_AC_INDEX_DATA,EGA_AC_ADAPTOR);
	io_disconnect_port(EGA_AC_SECRET,EGA_AC_ADAPTOR);

	/*
	 * Disconnect Miscellaneous register's port
	 */

	io_disconnect_port(EGA_MISC_REG,EGA_MISC_ADAPTOR);

	/*
	 * Disconnect Feature controller's port
	 */

	io_disconnect_port(EGA_FEAT_REG,EGA_FEAT_ADAPTOR);

	/*
	 * Disconnect Input Status Register 0 port
	 */

	io_disconnect_port(EGA_IPSTAT0_REG,EGA_IPSTAT0_ADAPTOR);

	/*
	 * Disconnect Input Status Register 1 port
	 */

	io_disconnect_port(EGA_IPSTAT1_REG,EGA_IPSTAT1_ADAPTOR);

	/*
	 * Free internals of EGA
	 */

	/* free the font files */
	for (index = 0; index < 4; index++)
		host_free_font(index);

	/* Disable CPU read processing */
	ega_read_term();
	ega_write_term();
#endif  //NEC_98
}

LOCAL void	ega_seq_outb_index IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_seq_outb_index(%x,%x)", port, value);
	assert1(value<5,"Bad seq index %d",value);
	NON_PROD(sequencer.address.as.abyte = value);
	io_redefine_outb(EGA_SEQ_ADAP_DATA,ega_seq_regs[value & 7]);
#endif  //NEC_98
}

void	ega_seq_reset IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_seq_reset(%x,%x)", port, value);
	/* change reset register */
	note_entrance0("reset register");
	sequencer.reset.as.abyte = value ;
	if (sequencer.reset.as_bfld.asynchronous_reset==0)
		set_bit_display_disabled(ASYNC_RESET);
	else
		clear_bit_display_disabled(ASYNC_RESET);
	if (sequencer.reset.as_bfld.synchronous_reset==0)
		 set_bit_display_disabled(SYNC_RESET);
	else
		 clear_bit_display_disabled(SYNC_RESET);
#endif  //NEC_98
}

void	ega_seq_clock IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
register unsigned dot_clock;

#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_seq_clock(%x,%x)", port, value);
	/* clock mode register */
	dot_clock = sequencer.clocking_mode.as_bfld.dot_clock;
	sequencer.clocking_mode.as.abyte = value;
	if (sequencer.clocking_mode.as_bfld.dot_clock != dot_clock) {
		/*
		** Switch to/from double width pixels
		*/
		if (sequencer.clocking_mode.as_bfld.dot_clock==1) {
			set_pix_width(2);
			set_double_pix_wid(YES);
			set_pix_char_width(16);
		} else {
			set_pix_width(1);
			set_double_pix_wid(NO);
			set_pix_char_width(8);
		}
		flag_mode_change_required();
	}
#endif  //NEC_98
}

void	ega_seq_map_mask IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_seq_map_mask(%x,%x)", port, value);

	/* map mask register */

	/*
	 * Different display plane(s) have been enabled. Update the video
	 * routines to deal with this
	 */

	setVideoplane_enable(value & 0xf);
	setVideoplane_enable_mask(sr_lookup[value & 0xf]);
	write_state.pe = ((value & 0xf) == 0xf) ? 1 : 0;
	setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);

	ega_write_routines_update(PLANES_ENABLED);
#endif  //NEC_98
}

void	ega_seq_char_map IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
register unsigned map_selects;

#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_seq_char_map(%x,%x)", port, value);
	/* char map select reg */
	map_selects = sequencer.character_map_select.character.map_selects;
	sequencer.character_map_select.as.abyte = value;
	if (sequencer.character_map_select.character.map_selects != map_selects)
	{
		/*
		** character mapping attributes have changed.
		**
		** If fonts selected are different bit 3 of attribute byte in alpha mode
		** selects which of the two fonts to use (giving 512 chars).
		*/

		EGA_GRAPH.attrib_font_select = (sequencer.character_map_select.as_bfld.character_map_select_a !=
						sequencer.character_map_select.as_bfld.character_map_select_b );
		set_prim_font_index(sequencer.character_map_select.as_bfld.character_map_select_a);
		set_sec_font_index(sequencer.character_map_select.as_bfld.character_map_select_b);

		host_select_fonts(get_prim_font_index(), get_sec_font_index());
		flag_mode_change_required();
	}
#endif  //NEC_98
}

void	ega_seq_mem_mode IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_seq_mem_mode(%x,%x)", port, value);

	/* mem mode register */

	sequencer.memory_mode.as.abyte = value ;

	/*
	** Decide alpha/graphics mode by voting
	 */
	vote_ega_mode();

	/*
	 * See if this causes a by-election for plane addressing
	 */

	do_chain_majority_decision();

	assert1(sequencer.memory_mode.as_bfld.extended_memory == 1,"Someone is trying to set extended memory to 0 (reg=%x)",value);
#endif  //NEC_98
}

LOCAL void	ega_crtc_outb IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
	SHORT offset;
	struct {	/* avoid alignment problems with casts */
		unsigned value : 8;
	} new;
	static int old_underline_start;


	note_entrance2("ega_crtc_outb(%x,%x)", port, value);
	new.value = value;
	switch (port) {
		case 0x3d4:
			note_entrance1("New crtc index %d",value);
			crt_controller.address.as.abyte = value;
			break;
		case 0x3d5:
			note_entrance1( "Index %d", crt_controller.address.as_bfld.index );
			switch (crt_controller.address.as_bfld.index) {
				case 0:
					note_entrance0("horiz total");
					NON_PROD(crt_controller.horizontal_total = value);
					break;
				case 1:
					note_entrance0("horiz display end");
					crt_controller.horizontal_display_end = value+1;
					set_horiz_total(crt_controller.horizontal_display_end);
					break;
				case 2:
					note_entrance0("start horiz blank");
					NON_PROD(crt_controller.start_horizontal_blanking = value);
					break;
				case 3:
					note_entrance0("end horiz blank");
					NON_PROD(crt_controller.end_horizontal_blanking.as.abyte = value);
					break;
				case 4:
					note_entrance0("start horiz retrace");
					NON_PROD(crt_controller.start_horizontal_retrace = value);
					break;
				case 5:
					note_entrance0("end horiz retrace");
					NON_PROD(crt_controller.end_horizontal_retrace.as.abyte = value);
					break;
				case 6:
					note_entrance0("vert tot");
					NON_PROD(crt_controller.vertical_total = value);
					break;
				case 7:
					note_entrance0("overflow");
					if (crt_controller.crtc_overflow.as_bfld.vertical_display_enab_end_bit_8 !=
							((CRTC_OVERFLOW*)&new)->as_bfld.vertical_display_enab_end_bit_8)
					{
						/*
						 * Screen height changed
						 */

#ifdef VGG
					/*
					 * if VGG is set then the screen height
					 * definition is extended from 9 bits to
					 * 10. Thus the 9th bit is now a 'med'
					 * bit and not a 'hi' bit.
					 */
						set_screen_height_med_recal(
							((CRTC_OVERFLOW*)&new)->as_bfld.vertical_display_enab_end_bit_8 );
#else
						set_screen_height_hi_recal(
							((CRTC_OVERFLOW*)&new)->as_bfld.vertical_display_enab_end_bit_8 );
#endif
						flag_mode_change_required();
					}
					if (crt_controller.crtc_overflow.as_bfld.line_compare_bit_8 !=
						((CRTC_OVERFLOW*)&new)->as_bfld.line_compare_bit_8)
					{
						/*
						 * split screen height changed
						 */

						EGA_GRAPH.screen_split.as_bfld.top_bit =
								((CRTC_OVERFLOW*)&new)->as_bfld.line_compare_bit_8;

						if( !get_split_screen_used() )
							flag_mode_change_required();

						screen_refresh_required();
					}
					crt_controller.crtc_overflow.as.abyte = value;
					break;
				case 8:
					note_entrance0("preset row scan");
					NON_PROD(crt_controller.preset_row_scan.as.abyte = value);
					break;
				case 9:
					note_entrance0("max scan line");
					if (crt_controller.maximum_scan_line.as_bfld.maximum_scan_line !=
						((MAX_SCAN_LINE*)&new)->as_bfld.maximum_scan_line)
					{
						set_char_height_recal(
							(((MAX_SCAN_LINE*)&new)->as_bfld.maximum_scan_line)+1);
						do_new_cursor();
					}
					crt_controller.maximum_scan_line.as.abyte = value;
					break;
				case 10:
					note_entrance0("cursor start");
					if (crt_controller.cursor_start.as_bfld.cursor_start !=
						((CURSOR_START*)&new)->as_bfld.cursor_start)
					{
						crt_controller.cursor_start.as.abyte = value;
						do_new_cursor();
					}
					break;
				case 11:
					note_entrance0("cursor end");
					if (crt_controller.cursor_end.as_bfld.cursor_end !=
						((CURSOR_END*)&new)->as_bfld.cursor_end)
					{
						crt_controller.cursor_end.as.abyte = value;
						assert0(crt_controller.cursor_end.as_bfld.cursor_skew_control == 0,
								"Someone is trying to use cursor skew");
						do_new_cursor();
					}
					break;
				case 12:
					note_entrance0("start address high");
					if (crt_controller.start_address_high != value)
					{
						set_screen_start((value << 8) + crt_controller.start_address_low);
						host_screen_address_changed(crt_controller.start_address_high,
									crt_controller.start_address_low);
						/* check if it wraps now */
						if ( get_memory_chained() ) {
							if( (get_screen_start()<<1) + get_screen_length() > 2*EGA_PLANE_SZ )
								choose_ega_display_mode();
						}
						else {
							if( get_screen_start() + get_screen_length() > EGA_PLANE_SZ )
								choose_ega_display_mode();
						}
						screen_refresh_required();
					}
					crt_controller.start_address_high = value;
					break;
				case 13:
					note_entrance0("start address low");
					if (crt_controller.start_address_low != value)
					{
						set_screen_start((crt_controller.start_address_high << 8) + value);
						host_screen_address_changed(crt_controller.start_address_high,
									crt_controller.start_address_low);
						/* check if it wraps now */
						if ( get_memory_chained() ) {
							if( (get_screen_start()<<1) + get_screen_length() > 2*EGA_PLANE_SZ )
								choose_ega_display_mode();
						}
						else {
							if( get_screen_start() + get_screen_length() > EGA_PLANE_SZ )
								choose_ega_display_mode();
						}
						screen_refresh_required();
					}
					crt_controller.start_address_low = value;
					break;
				case 14:
					note_entrance0("cursor loc high");
					if (crt_controller.cursor_location_high != value)
					{
						crt_controller.cursor_location_high = value;

						offset = (value<<8) | crt_controller.cursor_location_low;
						offset -= (short)get_screen_start();

						set_cur_x(offset % crt_controller.horizontal_display_end);
						set_cur_y(offset / crt_controller.horizontal_display_end);

						do_new_cursor();

						if(!get_mode_change_required() && is_it_text())
							cursor_changed( get_cur_x(), get_cur_y());
					}
					break;
				case 15:
					note_entrance0("cursor loc lo");
					if (crt_controller.cursor_location_low != value)
					{
						crt_controller.cursor_location_low = value;

						offset = value | (crt_controller.cursor_location_high<<8);
						offset -= (short)get_screen_start();

						set_cur_x(offset % crt_controller.horizontal_display_end);
						set_cur_y(offset / crt_controller.horizontal_display_end);

						do_new_cursor();

						if(!get_mode_change_required() && is_it_text())
							cursor_changed( get_cur_x(), get_cur_y());
					}
					break;
				case 16:
					note_entrance0("vert retrace start");
					NON_PROD(crt_controller.vertical_retrace_start = value);
					break;
				case 17:
					note_entrance0("vert retrace end");
					crt_controller.vertical_retrace_end.as.abyte = value;
                                        if ((value & 32) == 32)
                                           ega_int_enable = 0;
                                        else
                                           ega_int_enable = 1;
                                        if ((value & 16) != 16)
                                        {
                                           ica_clear_int(AT_EGA_VTRACE_ADAPTER,AT_EGA_VTRACE_INT);
                                           /*
                                            * clear status latch
                                            */
                                           input_status_register_zero.as_bfld.crt_interrupt = 0;        /* = !VS */
                                        }
			/* ??? */
					break;
				case 18:
					note_entrance0("vert disp enable end");
					if (crt_controller.vertical_display_enable_end != value)
					{
						crt_controller.vertical_display_enable_end = value;
						set_screen_height_lo_recal(value);
					}
					break;
				case 19:
					note_entrance0("offset");
					if (crt_controller.offset != value)
					{
						crt_controller.offset = value;
						set_actual_offset_per_line(value<<1);	/* actual offset into plane in bytes */
						flag_mode_change_required();
					}
					break;
				case 20:
					note_entrance0("underline loc");
					crt_controller.underline_location.as.abyte = value;
					if( value != old_underline_start )
					{
						old_underline_start = value;
						set_underline_start(
				crt_controller.underline_location.as_bfld.underline_location);
						screen_refresh_required();
					}
					break;
				case 21:
					note_entrance0("start vert blank");
					NON_PROD(crt_controller.start_vertical_blanking = value);
					break;
				case 22:
					note_entrance0("end vert blank");
					NON_PROD(crt_controller.end_vertical_blanking = value);
					break;
				case 23:
					note_entrance0("mode control");
					if (crt_controller.mode_control.as_bfld.compatibility_mode_support !=
						((MODE_CONTROL*)&new)->as_bfld.compatibility_mode_support)
					{
						if ( (((MODE_CONTROL*)&new)->as_bfld.compatibility_mode_support) == 0)
							set_cga_mem_bank(YES);
						else	set_cga_mem_bank(NO);
						flag_mode_change_required();
					}
					if (crt_controller.mode_control.as_bfld.word_or_byte_mode !=
						((MODE_CONTROL*)&new)->as_bfld.word_or_byte_mode)
					{
						set_word_addressing_recal(
							(((MODE_CONTROL*)&new)->as_bfld.word_or_byte_mode) == 0 );
					}
					crt_controller.mode_control.as.abyte = value;
					assert0(crt_controller.mode_control.as_bfld.select_row_scan_counter == 1,"Row scan 0");
					assert0(crt_controller.mode_control.as_bfld.horizontal_retrace_select == 0,
														"retrace select 1");
					assert0(crt_controller.mode_control.as_bfld.output_control == 0,"output control set");
					assert0(crt_controller.mode_control.as_bfld.hardware_reset == 1,"hardware reset cleared");
					break;
				case 24:
					note_entrance0("line compare reg");
					if (crt_controller.line_compare != value)
					{
						crt_controller.line_compare = value;
						EGA_GRAPH.screen_split.as_bfld.low_byte = value;

						if( !get_split_screen_used() )
							flag_mode_change_required();

						screen_refresh_required();

					}
					break;
				default:
					assert1(NO,"Bad crtc index %d",crt_controller.address.as_bfld.index);
					break;
			}
			break;
		default:
			assert1(NO,"Bad port passed %x", port );
			break;
	}
#endif  //NEC_98
}

LOCAL void	ega_crtc_inb IFN2(io_addr, port, half_word *, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance3("ega_crtc_inb(%x,%x) index %d", port, value, crt_controller.address.as_bfld.index);
	switch(crt_controller.address.as_bfld.index) {
		case	10:
			*value = (half_word)crt_controller.cursor_start.as.abyte ;
			note_entrance1("cursor start %d",*value);
			break;
		case	11:
			*value = (half_word)crt_controller.cursor_end.as.abyte ;
			note_entrance1("cursor end %d",*value);
			break;
		case	12:
			*value = crt_controller.start_address_high ;
			note_entrance1("start address high %x",*value);
			break;
		case	13:
			*value = crt_controller.start_address_low ;
			note_entrance1("start address low %x",*value);
			break;
		case	14:
			*value = crt_controller.cursor_location_high ;
			note_entrance1("cursor location high %x",*value);
			break;
		case	15:
			*value = crt_controller.cursor_location_low ;
			note_entrance1("cursor location low %x",*value);
			break;
		case	16:
			*value = 0;	/* light pen high */
			note_entrance1("light pen high %x",*value);
			break;
		case	17:
			*value = 0;	/* light pen low */
			note_entrance1("light pen low %x",*value);
			break;
		default:
			assert1(crt_controller.address.as_bfld.index>24,"inb from bad crtc index %d",crt_controller.address.as_bfld.index);
			*value = IO_EMPTY_PORT_BYTE_VALUE;
			break;
	}
#endif  //NEC_98
}


void	ega_gc_outb_index IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_gc_outb_index(%x,%x)", port, value);
	NON_PROD(graphics_controller.address.as.abyte = value);
	assert1(value<9,"Bad gc index %d",value);

	io_redefine_outb(EGA_GC_ADAP_DATA,ega_gc_regs[value & 15]);
	Cpu_define_outb(EGA_GC_ADAP_DATA,ega_gc_regs_cpu[value & 15]);
#endif  //NEC_98
}


/**/


/*( ega_gc_outw
**	Most PC programs do an "OUT DX, AX" which sets up the GC index
**	register with the AL and the GC data register with AH.
**	Avoid going through generic_outw() by doing it all here!
)*/
GLOBAL VOID ega_gc_outw IFN2(io_addr, port, word, outval)
{
#ifndef NEC_98
	reg     temp;
	INT		value;

	temp.X = outval;
	value = temp.byte.low;

	NON_PROD(graphics_controller.address.as.abyte = value);

	assert1(value<9,"Bad gc index %#x", value);

	value &= 15;

	io_redefine_outb(EGA_GC_ADAP_DATA,ega_gc_regs[value]);
	Cpu_define_outb(EGA_GC_ADAP_DATA,ega_gc_regs_cpu[value]);

	(*(ega_gc_regs[value]))((IU16)(port+1), temp.byte.high);
#endif  //NEC_98
}


/**/


void	ega_gc_set_reset IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
register unsigned set_reset;

#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_gc_set_reset(%x,%x)", port, value);

	set_reset = graphics_controller.set_or_reset.as_bfld.set_or_reset;
	graphics_controller.set_or_reset.as.abyte = value;

	if (graphics_controller.set_or_reset.as_bfld.set_or_reset != set_reset)
	{
		EGA_CPU.set_reset = graphics_controller.set_or_reset.as_bfld.set_or_reset;
		ega_write_routines_update(SET_RESET);
	}
#endif  //NEC_98
}

void	ega_gc_enable_set IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
register unsigned en_set_reset;

#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_gc_enable_set(%x,%x)", port, value);

	en_set_reset = graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset;
	graphics_controller.enable_set_or_reset.as.abyte = value;

	if (graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset != en_set_reset)
	{
		EGA_CPU.sr_enable = graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset;
		write_state.sr = graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset==0?0:1;
		setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);
		ega_write_routines_update(ENABLE_SET_RESET);
	}
#endif  //NEC_98
}

void	ega_gc_compare IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
register unsigned colour_compare;

#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_gc_compare(%x,%x)", port, value);
	colour_compare = graphics_controller.color_compare.as_bfld.color_compare;
	graphics_controller.color_compare.as.abyte = value;
	if (graphics_controller.color_compare.as_bfld.color_compare != colour_compare)
	{
		read_state.colour_compare = (unsigned char)graphics_controller.color_compare.as_bfld.color_compare;
		if (read_state.mode == 1) ega_read_routines_update();
	}
#endif  //NEC_98
}

void	ega_gc_rotate IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
	struct {
		unsigned value : 8;
	} new;

#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_gc_rotate(%x,%x)", port, value);
	note_entrance0("data rotate");
	new.value = value;
	if (graphics_controller.data_rotate.as_bfld.rotate_count != ((DATA_ROTATE*)&new)->as_bfld.rotate_count )
	{
		setVideorotate(((DATA_ROTATE*)&new)->as_bfld.rotate_count);
		ega_write_routines_update(ROTATION);
	}

	if (graphics_controller.data_rotate.as_bfld.function_select != ((DATA_ROTATE*)&new)->as_bfld.function_select)
	{
		write_state.func = ((DATA_ROTATE*)&new)->as_bfld.function_select;
		setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);
		ega_write_routines_update(FUNCTION);
	}
	EGA_CPU.fun_or_protection = (value != 0) || write_state.bp;
	graphics_controller.data_rotate.as.abyte = value;
#endif  //NEC_98
}

void	ega_gc_read_map IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_gc_read_map(%x,%x)", port, value);

	setVideoread_mapped_plane(value & 3);

	update_shift_count();
#endif  //NEC_98
}

void	ega_gc_mode IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
MODE new_mode;

#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_gc_set_reset(%x,%x)", port, value);
	new_mode.as.abyte = value;
	if (graphics_controller.mode.as_bfld.write_mode != new_mode.as_bfld.write_mode)
	{
		/*
		 * write mode change
		 */

		EGA_CPU.write_mode = (unsigned char)new_mode.as_bfld.write_mode;
		setVideowrmode(EGA_CPU.write_mode);
		ega_write_routines_update(WRITE_MODE);
	}

	if (graphics_controller.mode.as_bfld.read_mode != new_mode.as_bfld.read_mode)
	{
		/*
		 * read mode change
		 */
		read_state.mode = new_mode.as_bfld.read_mode;
		ega_read_routines_update();
	}

	if (graphics_controller.mode.as_bfld.shift_register_mode != new_mode.as_bfld.shift_register_mode)
	{
		/*
		 * going to/from one cga graphics mode to another
		 */
		set_graph_shift_reg(new_mode.as_bfld.shift_register_mode);
		flag_mode_change_required();
	}

	graphics_controller.mode.as.abyte = new_mode.as.abyte;

	/*
	 * Check for any change to chained mode rule by having an election
	 * (Note: EGA registers must be updated before calling election)
	 */

	do_chain_majority_decision();

	assert0(graphics_controller.mode.as_bfld.test_condition == 0,"Test conditon set");
#endif  //NEC_98
}

void	ega_gc_misc IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
register unsigned memory_map;

#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_gc_misc(%x,%x)", port, value);
	memory_map = graphics_controller.miscellaneous.as_bfld.memory_map;
	graphics_controller.miscellaneous.as.abyte = value;
	if (graphics_controller.miscellaneous.as_bfld.memory_map != memory_map)
	{
		/*
		 * Where EGA appears in PC memory space changed.
		*/
		if (miscellaneous_output_register.as_bfld.enable_ram)
			sas_disconnect_memory(gvi_pc_low_regen,gvi_pc_high_regen);

		switch (graphics_controller.miscellaneous.as_bfld.memory_map)
		{
			case 0:
				gvi_pc_low_regen = 0xA0000;
				gvi_pc_high_regen = 0xBFFFF;
				break;
			case 1:
				gvi_pc_low_regen = 0xA0000;
				gvi_pc_high_regen = 0xAFFFF;
				break;
			case 2:
				gvi_pc_low_regen = 0xB0000;
				gvi_pc_high_regen = 0xB7FFF;
				break;
			case 3:
				gvi_pc_low_regen = 0xB8000;
				gvi_pc_high_regen = 0xBFFFF;
				break;
		}

		if (miscellaneous_output_register.as_bfld.enable_ram)
			sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);

		/*
		 * Tell cpu associated modules that regen area has moved
		 */

		ega_read_routines_update();
		ega_write_routines_update(RAM_MOVED);
	}

	/*
 	** Vote on alpha/graphics mode.
	 */
	vote_ega_mode();

	/*
	 * Check for any change to chained mode rule by having an election
	 * (Note: EGA registers must be updated before calling election)
	 */

	do_chain_majority_decision();
#endif  //NEC_98
}

void	ega_gc_dont_care IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
register unsigned colour_dont_care;

#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_gc_dont_care(%x,%x)", port, value);
	colour_dont_care = graphics_controller.color_dont_care.as_bfld.color_dont_care;
	graphics_controller.color_dont_care.as.abyte = value;
	if (graphics_controller.color_dont_care.as_bfld.color_dont_care != colour_dont_care)
	{
		read_state.colour_dont_care = (unsigned char)graphics_controller.color_dont_care.as_bfld.color_dont_care;
		if (read_state.mode == 1) ega_read_routines_update();
	}
#endif  //NEC_98
}

/*
 * The EGA mask register is written to more times than all other ports added together!
 * To help make this register fast, we have two different routines to handle it:
 * ega_gc_mask for when the register's current value is not 0xFF, ie. masking is active
 * ega_gc_mask_ff for when the mask register = 0xFF, so masking is disabled.
 */

/*(
** ega_mask_register_changed
**	This gets called whenever the mask register gets changed, and
**	updates the internals appropriately. Since the mask registers
**	are hit more than any other registers, this should do the job!
**
**	Rather than calling the monster ega_write_routines_update() (in "ega_write.c"),
**	we do as little as we possibly can here!
**	In particular, all we do is set the video write pointer handlers
**	to the appropriate one and update the internal EGA_CPU state...
**
**	We DON'T do anything about altering the marking funcs, etc.
**
**	See also "vga_mask_register_changed" in "vga_ports.c"
**
**	NB: GLOBAL for JOKER.
**
)*/
#include	"cpu_vid.h"

IMPORT void Glue_set_vid_wrt_ptrs (WRT_POINTERS * handler );

GLOBAL VOID ega_mask_register_changed IFN1(BOOL, gotBitProtection)
{
#ifndef NEC_98
	ULONG				state;
	SAVED IU8			masks[] = {0x1f, 0x01, 0x0f, 0x0f};
	IMPORT WRT_POINTERS	*mode_chain_handler_table[];
#ifdef V7VGA
	IMPORT	UTINY		Last_v7_fg_bg, fg_bg_control;
#endif

	write_state.bp = gotBitProtection;
	setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);
	EGA_CPU.fun_or_protection = (gotBitProtection || (graphics_controller.data_rotate.as.abyte != 0));

	/* Check that we're not trying to handle any pathological cases here...
	** This means we chicken out for Chain2 and V7VGA dithering.
	*/

	if ((EGA_CPU.chain == CHAIN2)
#ifdef V7VGA
		|| ( Last_v7_fg_bg != fg_bg_control)
#endif /* V7VGA */
		)
	{
		ega_write_routines_update(BIT_PROT);

		return;
	}

	/* the "mode_0" union variant has the largest "lookup" field (5 bits.) */

	state = EGA_CPU.ega_state.mode_0.lookup & masks[EGA_CPU.write_mode];

#ifdef A3CPU
#ifdef C_VID
	Glue_set_vid_wrt_ptrs(&mode_chain_handler_table[EGA_CPU.saved_mode_chain][state]);
#else
	Cpu_set_vid_wrt_ptrs(&mode_chain_handler_table[EGA_CPU.saved_mode_chain][state]);	
#endif /* C_VID */
#else
#if !(defined(NTVDM) && defined(MONITOR))
	Glue_set_vid_wrt_ptrs(&mode_chain_handler_table[EGA_CPU.saved_mode_chain][state]);
#endif /* !(NTVDM && MONITOR) */
#endif /* A3CPU */

	EGA_CPU.saved_state = state;
#endif  //NEC_98
}


/**/


/* ega_gc_mask is the one that is usually called */

LOCAL void	ega_gc_mask IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
	register unsigned int mask;

#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_gc_mask(%x,%x)", port, value);

	/*
	 * Update video routine according to new bit protection
	 */

	mask = value | (((USHORT)value) << 8);
	mask |= (mask << 16);	/* replicate the mask into 4 bytes */
	setVideobit_prot_mask(mask);
	setVideodata_xor_mask(~(EGA_CPU.calc_data_xor & mask));
	setVideolatch_xor_mask(EGA_CPU.calc_latch_xor & mask);
	if( value == 0xff )
	{
#ifndef	USE_OLD_MASK_CODE
		ega_mask_register_changed(/*bit protection :=*/0);
#else
		write_state.bp = 0;
		setVideowrstate(EGA_CPU.ega_state.mode_0.lookup);
		EGA_CPU.fun_or_protection = (graphics_controller.data_rotate.as.abyte != 0);
		ega_write_routines_update(BIT_PROT);
#endif	/* USE_OLD_MASK_CODE */

		/* Alter the function table used by ega_gc_index */
		ega_gc_regs[8] = ega_gc_mask_ff;

#ifndef CPU_40_STYLE	/* TEMPORARY */
#ifndef A2CPU
		/* Alter the function table used by assembler ega_gc_index */
		ega_gc_regs_cpu[8] = _ega_gc_outb_mask_ff;
#endif
#endif

		io_redefine_outb(EGA_GC_ADAP_DATA,ega_gc_mask_ff);

#ifndef CPU_40_STYLE	/* TEMPORARY */
		Cpu_define_outb(EGA_GC_ADAP_DATA,_ega_gc_outb_mask_ff);
#endif
	}
#endif  //NEC_98
}

/* This version isn't called so often */
void	ega_gc_mask_ff IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
	register unsigned int mask;

#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_gc_mask(%x,%x)", port, value);

	/*
	 * Update video routine according to new bit protection
	 */

	if(value != 0xff)
	{
		mask = value | (((USHORT)value) << 8);
		mask |= (mask << 16);	/* replicate the mask into 4 bytes */
		setVideobit_prot_mask(mask);
		setVideodata_xor_mask(~(EGA_CPU.calc_data_xor & mask));
		setVideolatch_xor_mask(EGA_CPU.calc_latch_xor & mask);
#ifndef	USE_OLD_MASK_CODE
		ega_mask_register_changed(/*bit protection :=*/1);
#else
		write_state.bp = 1;
		setVideowrstate(EGA_CPU.ega_state.mode_0.lookup);
		EGA_CPU.fun_or_protection = TRUE;
		ega_write_routines_update(BIT_PROT);
#endif	/* USE_OLD_MASK_CODE*/

		/* Alter the function table used by ega_gc_index */
		ega_gc_regs[8] = ega_gc_mask;

#ifndef CPU_40_STYLE	/* TEMPORARY */
#ifndef A2CPU
		/* Alter the function table used by assembler ega_gc_index */
		ega_gc_regs_cpu[8] = _ega_gc_outb_mask;
#endif
#endif

		io_redefine_outb(EGA_GC_ADAP_DATA,ega_gc_mask);

#ifndef CPU_40_STYLE	/* TEMPORARY */
		Cpu_define_outb(EGA_GC_ADAP_DATA,_ega_gc_outb_mask);
#endif
	}
#endif  //NEC_98
}

LOCAL void	ega_index_invalid IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
	UNUSED(value);
#endif
	note_entrance2("ega_index_invalid(%x,%x)", port, value);
	assert1(NO,"Invalid index %d",graphics_controller.address.as_bfld.index);
#endif  //NEC_98
}

LOCAL void	ega_ac_outb IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
	struct {
		unsigned value : 8;
	} new;

#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_ac_outb(%x,%x)", port, value);
	assert1( port == EGA_AC_INDEX_DATA || port == EGA_AC_SECRET, "Bad port %x", port);
	new.value = value;
	if ( in_index_state() ) {
		note_entrance1("Setting index to %d", value);
		attribute_controller.address.as.abyte = value;
	} else {
		switch (attribute_controller.address.as_bfld.index) {
		case 0:
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
		case 14:
		case 15:
/*
 *		A real EGA monitor behaves in a strange way:
 *		When it is in 200 scan line mode (vertical_retrace_polarity = 0)
 *		it emulates a CGA monitor - not just in screen resolution, but also
 *		in the way it inteprets the colour signals:
 *		Instead of having 6 colour signals: RGBrgb,
 *		it has 4, RGBI. The Intensity signal is on the same input pin as the secondary green signal.
 */
			note_entrance1("Change palette %d",attribute_controller.address.as_bfld.index);
			attribute_controller.palette[attribute_controller.address.as_bfld.index].as.abyte = value;
			if(miscellaneous_output_register.as_bfld.vertical_retrace_polarity)
			{
				EGA_GRAPH.palette[attribute_controller.address.as_bfld.index].red =
										get_palette_color(red,secondary_red);
				EGA_GRAPH.palette[attribute_controller.address.as_bfld.index].green =
										get_palette_color(green,secondary_green);
				EGA_GRAPH.palette[attribute_controller.address.as_bfld.index].blue =
										get_palette_color(blue,secondary_blue);
			}
			else
			{
				/* Interpret secondary_green as intensity */
				EGA_GRAPH.palette[attribute_controller.address.as_bfld.index].red =
										get_palette_color(red,secondary_green);
				EGA_GRAPH.palette[attribute_controller.address.as_bfld.index].green =
										get_palette_color(green,secondary_green);
				EGA_GRAPH.palette[attribute_controller.address.as_bfld.index].blue =
										get_palette_color(blue,secondary_green);
			}
			host_set_palette(EGA_GRAPH.palette,EGA_PALETTE_SIZE);
			break;
		case 16:
			note_entrance0("mode control reg");
			if (attribute_controller.mode_control.as_bfld.background_intensity_or_blink !=
				((AC_MODE_CONTROL*)&new)->as_bfld.background_intensity_or_blink)
			{
				set_intensity( ((AC_MODE_CONTROL*)&new)->as_bfld.background_intensity_or_blink );
			}

			attribute_controller.mode_control.as.abyte = value;

			if (attribute_controller.mode_control.as_bfld.background_intensity_or_blink)
				/* blinking - not supported */
				bg_col_mask = 0x70;
			else
				/* using blink bit to provide 16 background colours */
				bg_col_mask = 0xf0;

			/*
			 ** Vote on alpha/graphics mode
			 */
			 vote_ega_mode();
			assert0(attribute_controller.mode_control.as_bfld.display_type == 0, "Mono display selected");
			assert0(attribute_controller.mode_control.as_bfld.enable_line_graphics_char_codes == 0,
											"line graphics enabled");
			break;
		case 17:
			note_entrance0("set border");
			attribute_controller.overscan_color.as.abyte = value;
			EGA_GRAPH.border[RED] = get_border_color(red_border,secondary_red_border);
			EGA_GRAPH.border[GREEN] = get_border_color(green_border,secondary_green_border);
			EGA_GRAPH.border[BLUE] = get_border_color(blue_border,secondary_blue_border);
			host_set_border_colour(value);
			break;
		case 18:
			note_entrance1("color plane enable %x",value);
			if ( attribute_controller.color_plane_enable.as_bfld.color_plane_enable !=
					((COLOR_PLANE_ENABLE*)&new)->as_bfld.color_plane_enable ) {
				set_plane_mask(((COLOR_PLANE_ENABLE*)&new)->as_bfld.color_plane_enable);
				host_change_plane_mask(get_plane_mask());	/* Update Host palette */
			}
			attribute_controller.color_plane_enable.as.abyte = value;
			break;
		case 19:
			note_entrance0("horiz pel panning");
			NON_PROD(attribute_controller.horizontal_pel_panning.as.abyte = value);
			break;
		default:
			assert1(NO,"Bad ac index %d", attribute_controller.address.as_bfld.index);
			break;
		}
	}
#endif  //NEC_98
}

LOCAL void	ega_misc_outb IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
MISC_OUTPUT_REG new;

#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_misc_outb(%x,%x)", port, value);
	assert1(port==EGA_MISC_REG,"Bad port %x",port);
	new.as.abyte = value;
	if (miscellaneous_output_register.as_bfld.enable_ram != new.as_bfld.enable_ram)
	{
		/*
		 * writes to plane memory en/disabled
		 */

		note_entrance0("Ram enabled");
		if(new.as_bfld.enable_ram)
			sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);
		else
			sas_disconnect_memory(gvi_pc_low_regen,gvi_pc_high_regen);

		EGA_CPU.ram_enabled = new.as_bfld.enable_ram;
		ega_read_routines_update();
		ega_write_routines_update(RAM_ENABLED);
	}

	if (miscellaneous_output_register.as_bfld.vertical_retrace_polarity !=
		new.as_bfld.vertical_retrace_polarity)
	{
		/*
		 * Going to/from CGA monitor compatibility mode
		 * if this bit is set, it means that the pixels are 'stretched' vertically.
		 */

		set_pc_pix_height( new.as_bfld.vertical_retrace_polarity ? 1 : 2);
		flag_mode_change_required();
	}

	miscellaneous_output_register.as.abyte = new.as.abyte;

	set_bit_display_disabled(miscellaneous_output_register.as_bfld.disable_internal_video_drivers ? VIDEO_DRIVERS_DISABLED : 0);

	/*
	 * register value used by ipsr0 to find out the index into the switches
	 * so that correct switch setting can be returned.
	 */
#endif  //NEC_98
}

LOCAL void	ega_feat_outb IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
	UNUSED(value);
#endif
	note_entrance2("ega_feat_outb(%x,%x)", port, value);
	NON_PROD(feature_control_register.as.abyte = value);
#endif  //NEC_98
}

LOCAL void	ega_ipstat0_inb IFN2(io_addr, port, half_word *, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance1("ega_ipstat0_inb(%x)", port);
	input_status_register_zero.as_bfld.switch_sense =
	
	/* The following function call used to pass the argument
	** miscellaneous_output_register.as_bfld.clock_select
	** but the function expects no argument so it was removed.
	*/
	get_ega_switch_setting();
	*value = (half_word)input_status_register_zero.as.abyte;
	note_entrance1("returning %x",*value);
#endif  //NEC_98
}

LOCAL void	ega_ipstat1_inb IFN2(io_addr, port, half_word *, value)
{
#ifndef NEC_98

	/*
	 * The whole of this routine has been nicked from the cga without modification
	 * The s_lengths array should probably be altered for the ega timings, and somewhere
	 * an interrupt should be fired off.
	 */

	static int ega_state = 0;	/* current ega status state */
	static int state_count = 1;     /* position in that state */
	static int sub_state = 0;	/* sub state for ega state 2 */

     static unsigned long gmfudge = 17; /* Random number seed for pseudo-random
                                           bitstream generator to give the state                                           lengths below that 'genuine' feel to
                                           progs that require it! */
     register unsigned long h;

    /*
     * relative 'lengths' of each state. State 2 is *3 as it has 3 sub states
     */

	static int s_lengths[] = { 8, 18, 8, 6 };

    /*
     * Status register, simulated adapter has
     *
     *	bit			setting
     *	---			-------
     *	Display enable		   1/0 Toggling each inb
     *	Light Pen		   0
     *	Light Pen		   0
     * 	Vertical Sync		   1/0 Toggling each inb
     *	4-7 Unused		   0,0,0,0
     *
     * The upper nibble of the byte is always set.
     * Some programs synchronise with the display by waiting for the
     * next vertical retrace.
     *
     * We attempt to follow the following waveform
     *
     *    --                                                     ----------
     * VS  |_____________________________________________________|        |____
     *
     *
     *    -------------  -   -                           ------------------
     * DE             |__||__||__ ... about 180         _|
     *
     *State|--- 0 ----|-------------- 1 -----------------|-- 3 --|-- 4 --|
     *
     * We do this with a 4 state machine. Each state has a count associated
     * with it to represent the relative time spent in each state. When this
     * count is exhausted the machine moves into the next state. One Inb
     * equals 1 count. The states are as follows:
     *     0: VS low, DE high.
     *     1: VS low, DE toggles. This works via an internal state.
     *     3: VS low, DE high.
     *     4: VS high,DE high.
     *
     */

#ifdef PROD
	UNUSED(port);
#endif
	note_entrance1("ega_ipstat1_inb(%x)", port);
    note_entrance2("ega_ipstat1_inb(%x,%x)", port, value);

    set_index_state();	/* Initialize the Attribute register flip-flop (EGA tech ref, p 56) */

    state_count --;	/* attempt relative 'timings' */
    switch (ega_state) {

    case 0:
	if (state_count == 0) {	/* change to next state ? */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
	    state_count = s_lengths[1] + (gmfudge & 3);
	    ega_state = 1;
	}
	input_status_register_zero.as_bfld.crt_interrupt = 1;	/* = !VS */
	*value = 0xf1;
	break;

    case 1:
	if (state_count == 0) {	/* change to next state ? */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
	    state_count = s_lengths[2] + (gmfudge & 3);
	    ega_state = 2;
	    sub_state = 2;
	}
	switch (sub_state) {	/* cycle through 0,0,1 sequence */
	case 0:		/* to represent DE toggling */
	    *value = 0xf0;
	    sub_state = 1;
	    break;
	case 1:
	    *value = 0xf0;
	    sub_state = 2;
	    break;
	case 2:
	    *value = 0xf1;
	    sub_state = 0;
	    break;
        }
	input_status_register_zero.as_bfld.crt_interrupt = 1;	/* = !VS */
	break;

    case 2:
	if (state_count == 0) {	/* change to next state ? */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
	    state_count = s_lengths[3] + (gmfudge & 3);
	    ega_state = 3;
	}
	*value = 0xf1;
	input_status_register_zero.as_bfld.crt_interrupt = 1;	/* = !VS */
	break;

    case 3:
	if (state_count == 0) {	/* wrap back to first state */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
	    state_count = s_lengths[0] + (gmfudge & 3);
	    ega_state = 0;
	}
	input_status_register_zero.as_bfld.crt_interrupt = 0;	/* = !VS */
	*value = 0xf9;
	break;
    }
    note_entrance1("returning %x",*value);
#endif  //NEC_98
}

LOCAL	void	vote_ega_mode IFN0()
{
#ifndef NEC_98
	static	int	old_votes = 3;
	int	votes;

	votes = sequencer.memory_mode.as_bfld.alpha_mode ? 0 : 1;
	votes += graphics_controller.miscellaneous.as_bfld.graphics_mode;
	votes += attribute_controller.mode_control.as_bfld.graphics_mode;
	assert1( votes == 3 || votes == 0, "Headline: Mode government returned with small majority %d", votes);
	if ((old_votes < 2) && (votes >= 2))
	{
		/* change to graphics mode */
		set_text_mode(NO);
		flag_mode_change_required();
	}
	else if ((old_votes >= 2) && (votes < 2))
	{
		/* change to text mode */
		set_text_mode(YES);
		flag_mode_change_required();
	}
	old_votes = votes;
#endif  //NEC_98
}

#ifdef HUNTER

/* Get line compare value */

int ega_get_line_compare IFN0()

    {
    int		return_value;

    return_value = crt_controller.line_compare;
    if (crt_controller.crtc_overflow.as_bfld.line_compare_bit_8 != 0)
	return_value += 0x100;
    return (return_value);
    }			/* ega_get_line_compare */

/* Get maximum scan lines value */

int ega_get_max_scan_lines IFN0()

    {
    return (crt_controller.maximum_scan_line.as_bfld.maximum_scan_line);
    }			/* ega_get_max_scan_lines */

/* Set line compare value */

void ega_set_line_compare IFN1(int, lcomp_val)
    {
#ifndef NEC_98
    CRTC_OVERFLOW	new_overflow;

    new_overflow.as.abyte = crt_controller.crtc_overflow.as.abyte;
    if (lcomp_val >= 0x100)
	new_overflow.as_bfld.line_compare_bit_8 = 1;
    else
	new_overflow.as_bfld.line_compare_bit_8 = 0;

    outb(EGA_CRTC_INDEX, 7);
    outb(EGA_CRTC_DATA, new_overflow.as.abyte);
    outb(EGA_CRTC_INDEX, 24);
    outb(EGA_CRTC_DATA, lcomp_val & 0xff);
#endif  //NEC_98
    }

#endif /* HUNTER */
#endif /* EGG */
#endif /* REAL_VGA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\ega_mode.c ===
#include "insignia.h"
#include "host_def.h"
/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DESIGNER		: S.Frost

REVISION HISTORY	:
First version		: 12 Aug 1988, J.Roper

SOURCE FILE NAME	: ega_mode.c

PURPOSE			: To decide which mode the EGA is in according to variables set in ega_ports.c and
			   to choose the appropriate update and paint routines accordingly.

SccsID[]="@(#)ega_mode.c	1.26 06/01/95 Copyright Insignia Solutions Ltd.";


[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

	INCLUDE FILE : ega_mode.gi

[1.1    INTERMODULE EXPORTS]

	PROCEDURES() :	choose_ega_display_mode

	DATA 	     :	uses EGA_GRAPH.display_state which is set in ega_ports.c, to
			determine what memory organisation the display side is in, and
			hence what sort of update and paint routines to use.

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]

	STRUCTURES/TYPEDEFS/ENUMS: 

uses	enum DISPLAY_STATE which is declared in ega_graph.pi.

uses	EGA_GRAPH structure for global variables set by the ports and
	used by the display.

-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
     (not o/s objects or standard libs)

	PROCEDURES() : vote_ega_mode()
			host_set_paint_routine(DISPLAY_MODE)

	DATA 	     : EGA_GRAPH struct.

-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

[1.4.2 EXPORTED OBJECTS]

=========================================================================
PROCEDURE	  : 	choose_ega_display_mode

PURPOSE		  : 	To decide which memory organisation is being used by the
			ega, and to pick the best update and paint routines accordingly.
			The paint routines are host specific, and so the memory organisation
			is indicated by an enum (called DISPLAY_MODE), describing each sort
			of memory organisation.

PARAMETERS	  :	none 

GLOBALS		  :	uses EGA_GRAPH struct, specially display_state to decide which mode is being used.

=========================================================================


/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]						*/


#ifndef REAL_VGA
#ifdef	EGG

/* [3.1.1 #INCLUDES]                                                    */

#include	"xt.h"
#include	"error.h"
#include	"config.h"
#include	"gvi.h"
#include	"egacpu.h"
#include	"debug.h"
#include	"gmi.h"
#include	"gfx_upd.h"
#include	"egagraph.h"
#include	"vgaports.h"
#include	"egaports.h"
#include	"host_gfx.h"

#ifdef GORE
#include	"gore.h"
#endif /* GORE */

/* [3.1.2 DECLARATIONS]                                                 */

/* [3.2 INTERMODULE EXPORTS]						*/ 

#include	"egamode.h"

boolean	(*choose_display_mode)();

/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]     

[5.1 LOCAL DECLARATIONS]						*/

/* [5.1.1 #DEFINES]							*/
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_EGA.seg"
#endif

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]			*/

/* [5.1.3 PROCEDURE() DECLARATIONS]					*/

/*
=========================================================================
PROCEDURE	  : 	set_up_screen_ptr()

PURPOSE		  : 	Decide which plane the information must come from for displaying

PARAMETERS	  :	none 

GLOBALS		  :	uses EGA_GRAPH struct, plane_mask to decide which planes are enabled

=========================================================================
*/

LOCAL VOID
set_up_screen_ptr()
{
#ifndef NEC_98
	if( get_memory_chained() )
	{
		if( plane01_enabled() )
			set_screen_ptr(EGA_plane01);
		else
			if( plane23_enabled() )
				set_screen_ptr(EGA_plane23);
			else
				assert0(NO,"No planes enabled for chain mode");
	}
	else
		set_screen_ptr(EGA_planes);
#endif   //NEC_98
}

/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS 					*/

GLOBAL	DISPLAY_MODE	choose_mode[] = {

	/* unchained, no cga mem bank, no shift reg */

	EGA_HI,			/* 350 height, no pixel doubling */
	EGA_HI_WR,		/* 350 height, no pixel doubling */
	EGA_HI_SP,		/* 350 height, no pixel doubling */
	EGA_HI_SP_WR,		/* 350 height, no pixel doubling */

	EGA_MED,		/* 200 height, no pixel doubling */
	EGA_MED_WR,		/* 200 height, no pixel doubling */
	EGA_MED_SP,		/* 200 height, no pixel doubling */
	EGA_MED_SP_WR,		/* 200 height, no pixel doubling */

	EGA_HI_FUN,		/* 350 height, pixel doubling */
	EGA_HI_FUN,		/* 350 height, pixel doubling */
	EGA_HI_FUN,		/* 350 height, pixel doubling */
	EGA_HI_FUN,		/* 350 height, pixel doubling */

	EGA_LO,			/* 200 height, pixel doubling */
	EGA_LO_WR,		/* 200 height, pixel doubling */
	EGA_LO_SP,		/* 200 height, pixel doubling */
	EGA_LO_SP_WR,		/* 200 height, pixel doubling */

	/* unchained, no cga_mem_bank, shift reg */

	EGA_HI_FUN,
	EGA_HI_FUN,
	EGA_HI_FUN,
	EGA_HI_FUN,

	EGA_MED_FUN,
	EGA_MED_FUN,
	EGA_MED_FUN,
	EGA_MED_FUN,

	EGA_HI_FUN,
	EGA_HI_FUN,
	EGA_HI_FUN,
	EGA_HI_FUN,

	EGA_LO_FUN,
	EGA_LO_FUN,
	EGA_LO_FUN,
	EGA_LO_FUN,

	/* unchained, cga_mem_bank, no shift reg */

	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,

	CGA_HI,			/* 200 height, no pixel doubling, the real bios mode */
	CGA_HI_FUN,		/* 200 height, no pixel doubling, the real bios mode, wrap */
	CGA_HI_FUN,		/* 200 height, no pixel doubling, the real bios mode, split screen */
	CGA_HI_FUN,		/* 200 height, no pixel doubling, the real bios mode, split screen, wrap */

	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,

	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,

	/* unchained, cga_mem_bank, shift reg */

	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,

	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,

	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,

	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,

	/* chained, no cga_mem_bank, no shift reg */

	EGA_TEXT_80,			/* 350 scan lines */
	EGA_TEXT_80_WR,			/* 350 scan lines */
	EGA_TEXT_80_SP,			/* 350 scan lines */
	EGA_TEXT_80_SP_WR,		/* 350 scan lines */

	CGA_TEXT_80,			/* 200 scan lines */
	CGA_TEXT_80_WR,			/* 200 scan lines */
	CGA_TEXT_80_SP,			/* 200 scan lines */
	CGA_TEXT_80_SP_WR,		/* 200 scan lines */

	EGA_TEXT_40,			/* 350 scan lines */
	EGA_TEXT_40_WR,			/* 350 scan lines */
	EGA_TEXT_40_SP,			/* 350 scan lines */
	EGA_TEXT_40_SP_WR,		/* 350 scan lines */

	CGA_TEXT_40,			/* 200 scan lines */
	CGA_TEXT_40_WR,			/* 200 scan lines */
	CGA_TEXT_40_SP,			/* 200 scan lines */
	CGA_TEXT_40_SP_WR,		/* 200 scan lines */

	/* chained, no cga_mem_bank, shift reg */

	TEXT_80_FUN,
	TEXT_80_FUN,
	TEXT_80_FUN,
	TEXT_80_FUN,

	TEXT_80_FUN,
	TEXT_80_FUN,
	TEXT_80_FUN,
	TEXT_80_FUN,

	TEXT_40_FUN,
	TEXT_40_FUN,
	TEXT_40_FUN,
	TEXT_40_FUN,

	TEXT_40_FUN,
	TEXT_40_FUN,
	TEXT_40_FUN,
	TEXT_40_FUN,

	/* chained, cga mem bank, no shift reg */

	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,

	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,

	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,

	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,

	/* chained, cga mem banks shift reg */

	CGA_MED_FUN,			/* not 200 scan lines and not double pix width */
	CGA_MED_FUN,			/* not 200 scan lines and not double pix width, wrap */
	CGA_MED_FUN,			/* not 200 scan lines and not double pix width, split */
	CGA_MED_FUN,			/* not 200 scan lines and not double pix width, wrap split */

	CGA_MED_FUN,			/* not double pix width */
	CGA_MED_FUN,			/* not double pix width */
	CGA_MED_FUN,			/* not double pix width */
	CGA_MED_FUN,			/* not double pix width */

	CGA_MED_FUN,			/* not 200 scan lines */
	CGA_MED_FUN,			/* not 200 scan lines */
	CGA_MED_FUN,			/* not 200 scan lines */
	CGA_MED_FUN,			/* not 200 scan lines */

	CGA_MED,			/* proper bios mode */
	CGA_MED_FUN,			/* proper bios mode, wrap */
	CGA_MED_FUN,			/* proper bios mode, split */
	CGA_MED_FUN,			/* proper bios mode, split, wrap */


	/* text mode(!), unchained, no cga mem bank, no shift reg
	** we think the textness overrides the unchainedness
	*/

	TEXT_80_FUN,
	TEXT_80_FUN,
	TEXT_80_FUN,
	TEXT_80_FUN,

	TEXT_80_FUN,
	TEXT_80_FUN,
	TEXT_80_FUN,
	TEXT_80_FUN,

	TEXT_40_FUN,
	TEXT_40_FUN,
	TEXT_40_FUN,
	TEXT_40_FUN,

	TEXT_40_FUN,
	TEXT_40_FUN,
	TEXT_40_FUN,
	TEXT_40_FUN,

	/* unchained, no cga_mem_bank, shift reg */

	EGA_HI_FUN,
	EGA_HI_FUN,
	EGA_HI_FUN,
	EGA_HI_FUN,

	EGA_MED_FUN,
	EGA_MED_FUN,
	EGA_MED_FUN,
	EGA_MED_FUN,

	EGA_HI_FUN,
	EGA_HI_FUN,
	EGA_HI_FUN,
	EGA_HI_FUN,

	EGA_LO_FUN,
	EGA_LO_FUN,
	EGA_LO_FUN,
	EGA_LO_FUN,

	/* unchained, cga_mem_bank, no shift reg */

	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,

	CGA_HI,			/* 200 height, no pixel doubling, the real bios mode */
	CGA_HI_FUN,		/* 200 height, no pixel doubling, the real bios mode, wrap */
	CGA_HI_FUN,		/* 200 height, no pixel doubling, the real bios mode, split screen */
	CGA_HI_FUN,		/* 200 height, no pixel doubling, the real bios mode, split screen, wrap */

	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,

	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,

	/* unchained, cga_mem_bank, shift reg */

	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,

	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,

	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,

	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,
	CGA_HI_FUN,

	/* chained, no cga_mem_bank, no shift reg */

	EGA_TEXT_80,			/* 350 scan lines */
	EGA_TEXT_80_WR,			/* 350 scan lines */
	EGA_TEXT_80_SP,			/* 350 scan lines */
	EGA_TEXT_80_SP_WR,		/* 350 scan lines */

	CGA_TEXT_80,			/* 200 scan lines */
	CGA_TEXT_80_WR,			/* 200 scan lines */
	CGA_TEXT_80_SP,			/* 200 scan lines */
	CGA_TEXT_80_SP_WR,		/* 200 scan lines */

	EGA_TEXT_40,			/* 350 scan lines */
	EGA_TEXT_40_WR,			/* 350 scan lines */
	EGA_TEXT_40_SP,			/* 350 scan lines */
	EGA_TEXT_40_SP_WR,		/* 350 scan lines */

	CGA_TEXT_40,			/* 200 scan lines */
	CGA_TEXT_40_WR,			/* 200 scan lines */
	CGA_TEXT_40_SP,			/* 200 scan lines */
	CGA_TEXT_40_SP_WR,		/* 200 scan lines */

	/* chained, no cga_mem_bank, shift reg */

	TEXT_80_FUN,
	TEXT_80_FUN,
	TEXT_80_FUN,
	TEXT_80_FUN,

	TEXT_80_FUN,
	TEXT_80_FUN,
	TEXT_80_FUN,
	TEXT_80_FUN,

	TEXT_40_FUN,
	TEXT_40_FUN,
	TEXT_40_FUN,
	TEXT_40_FUN,

	TEXT_40_FUN,
	TEXT_40_FUN,
	TEXT_40_FUN,
	TEXT_40_FUN,

	/* chained, cga mem bank, no shift reg */

	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,

	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,

	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,

	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,
	CGA_MED_FUN,

	/* chained, cga mem banks shift reg */

	CGA_MED_FUN,			/* not 200 scan lines and not double pix width */
	CGA_MED_FUN,			/* not 200 scan lines and not double pix width, wrap */
	CGA_MED_FUN,			/* not 200 scan lines and not double pix width, split */
	CGA_MED_FUN,			/* not 200 scan lines and not double pix width, wrap split */

	CGA_MED_FUN,			/* not double pix width */
	CGA_MED_FUN,			/* not double pix width */
	CGA_MED_FUN,			/* not double pix width */
	CGA_MED_FUN,			/* not double pix width */

	CGA_MED_FUN,			/* not 200 scan lines */
	CGA_MED_FUN,			/* not 200 scan lines */
	CGA_MED_FUN,			/* not 200 scan lines */
	CGA_MED_FUN,			/* not 200 scan lines */

	CGA_MED,			/* proper bios mode */
	CGA_MED_FUN,			/* proper bios mode, wrap */
	CGA_MED_FUN,			/* proper bios mode, split */
	CGA_MED_FUN,			/* proper bios mode, split, wrap */

};

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]				*/

LOCAL void ega_dummy_calc IFN0()
{
}

static	void	set_update_routine(mode)
DISPLAY_MODE	mode;
{
#ifndef NEC_98
#ifndef NTVDM
	static int last_height = 200;

	if (last_height != get_screen_height()) {
		last_height = get_screen_height();
	}
	note_entrance1("set_update_routine called for mode %s", get_mode_string(mode) );
	switch (mode) {
		case EGA_TEXT_40_SP_WR:
		case EGA_TEXT_80_SP_WR:
		case CGA_TEXT_40_SP_WR:
		case CGA_TEXT_80_SP_WR:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
			set_gfx_update_routines( ega_wrap_split_text_update, SIMPLE_MARKING, NO_SCROLL );
			host_update_fonts();
			break;
		case EGA_TEXT_40_SP:
		case EGA_TEXT_80_SP:
		case CGA_TEXT_40_SP:
		case CGA_TEXT_80_SP:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
			set_gfx_update_routines( ega_split_text_update, SIMPLE_MARKING, NO_SCROLL );
			host_update_fonts();
			break;
		case EGA_TEXT_40_WR:
		case EGA_TEXT_80_WR:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
			assert1( get_screen_height() == 350, "screen height %d for text mode", get_screen_height() );
			set_gfx_update_routines( ega_wrap_text_update, SIMPLE_MARKING, NO_SCROLL );
			host_update_fonts();
			break;
		case EGA_TEXT_40:
		case EGA_TEXT_80:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
			assert1( get_screen_height() == 350, "screen height %d for text mode", get_screen_height() );
			set_gfx_update_routines( ega_text_update, SIMPLE_MARKING, TEXT_SCROLL );
			host_update_fonts();
			break;
		case CGA_TEXT_40_WR:
		case CGA_TEXT_80_WR:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
			assert1( get_screen_height() == 200, "screen height %d for text mode", get_screen_height() );
			set_gfx_update_routines( ega_wrap_text_update, SIMPLE_MARKING, NO_SCROLL );
			host_update_fonts();
			break;
		case CGA_TEXT_40:
		case CGA_TEXT_80:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
			assert1( get_screen_height() == 200, "screen height %d for text mode", get_screen_height() );
			set_gfx_update_routines( text_update, SIMPLE_MARKING, CGA_TEXT_SCROLL );
			host_update_fonts();
			break;
		case CGA_MED:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
			set_gfx_update_routines( cga_med_graph_update, CGA_GRAPHICS_MARKING, CGA_GRAPH_SCROLL );
			break;
		case CGA_HI:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
			set_gfx_update_routines( cga_hi_graph_update, CGA_GRAPHICS_MARKING, CGA_GRAPH_SCROLL );
			break;
		case EGA_HI_WR:
		case EGA_MED_WR:
		case EGA_LO_WR:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
			set_gfx_update_routines( ega_wrap_graph_update, EGA_GRAPHICS_MARKING, NO_SCROLL );
			break;
		case EGA_HI:
		case EGA_MED:
		case EGA_LO:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
#ifdef GORE
			set_gfx_update_routines( process_object_list, EGA_GRAPHICS_MARKING, EGA_GRAPH_SCROLL );
#else
			set_gfx_update_routines( ega_graph_update, EGA_GRAPHICS_MARKING, EGA_GRAPH_SCROLL );
#endif /* GORE */
			break;
		case EGA_HI_SP_WR:
		case EGA_MED_SP_WR:
		case EGA_LO_SP_WR:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
			set_gfx_update_routines( ega_wrap_split_graph_update, EGA_GRAPHICS_MARKING, NO_SCROLL );
			break;
		case EGA_HI_SP:
		case EGA_MED_SP:
		case EGA_LO_SP:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
			set_gfx_update_routines( ega_split_graph_update, EGA_GRAPHICS_MARKING, NO_SCROLL );
			break;
		case TEXT_40_FUN:
		case TEXT_80_FUN:
			assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
			do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
			set_gfx_update_routines( text_update, SIMPLE_MARKING, NO_SCROLL );
			host_update_fonts();
			break;
		case CGA_HI_FUN:
			assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
			do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
			set_gfx_update_routines( cga_hi_graph_update, CGA_GRAPHICS_MARKING, NO_SCROLL );
			break;
		case CGA_MED_FUN:
			assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
			do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
			set_gfx_update_routines( cga_med_graph_update, CGA_GRAPHICS_MARKING, NO_SCROLL );
			break;
		case EGA_HI_FUN:
		case EGA_MED_FUN:
		case EGA_LO_FUN:
			assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
			do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
#ifdef GORE
			set_gfx_update_routines( process_object_list, EGA_GRAPHICS_MARKING, NO_SCROLL );
#else
			set_gfx_update_routines( ega_graph_update, EGA_GRAPHICS_MARKING, NO_SCROLL );
#endif /* GORE */
			break;
		case DUMMY_FUN:
			assert0(NO,"Using the dummy mode!!");
			set_gfx_update_routines( ega_dummy_calc, SIMPLE_MARKING, NO_SCROLL );
			break;
		default:
			assert1(NO,"Bad display mode %d", (int) mode );
			break;
	}
#endif /* NTVDM */
#endif   //NEC_98
}


/*
7.INTERMODULE INTERFACE IMPLEMENTATION :

[7.1 INTERMODULE DATA DEFINITIONS]				*/

/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]				*/



void	ega_mode_init()
{
#ifndef NEC_98
	/*
	** This bit moved here from ega_video_init(), since it's all about 
	** the emulation of the video hardware, not the video BIOS.
	**	WJG 22/8/90
	** Set the host graphics paint function to match the base update
	** function and the PC graphics mode.
	** Normally the host gfx func is not set until the next timer tick
	** as the mode change can involve quite a lot of Intel instructions.
	** However when booting SoftPC the EGA is going into a known mode.
	** This was added to fix a convoluted Fatal bug.
	** 1) Enter a gfx mode in EGA.
	** 2) Reset SoftPC.
	** 3) Bring up the disk panel as soon as you can.
	** 4) SoftPC crashes.
	** Cause: Because SoftPC was in gfx mode the paint function remains
	** a gfx mode paint function even though SoftPC thinks it is now in
	** text mode. When the panel is displayed a full screen update is 
	** forced which then gets too confused and dies.
	*/
	set_update_routine(DUMMY_FUN);
#endif   //NEC_98
}


boolean	choose_ega_display_mode()
{
#ifndef NEC_98
	DISPLAY_MODE	mode;
	int	old_offset;

	note_entrance0("choose ega display mode");

	/*
	 * offset_per_line depends upon whether chained addressing is being used. This is
	 * because we interleave the planes, rather than anything the EGA does.
	 */

	old_offset = get_offset_per_line();
	if ( get_memory_chained() ) {
		set_offset_per_line_recal(get_actual_offset_per_line() << 1);
	}
	else {
		set_offset_per_line_recal(get_actual_offset_per_line());
	}

	/*
	 * If the offset has actually changed, repaint the whole screen
	 */

	if ( old_offset != get_offset_per_line() )
		screen_refresh_required();

	/*
	 * It is possible that the display hardware will wrap the plane addressing. This occurs
	 * when the screen_start plus the screen_length are longer than the plane length.
	 * When in chained mode there is two planes length before wrapping occurs.
	 */

	if ( get_memory_chained() ) {
		set_screen_can_wrap( (get_screen_start()<<1) + get_screen_length() > 2*EGA_PLANE_DISP_SIZE );
	}
	else {
		set_screen_can_wrap( get_screen_start() + get_screen_length() > EGA_PLANE_DISP_SIZE );
	}

	/*
	 * split screen comes into operation when screen_split is less than screen height
	 * split screen used is used as part of munge_index.
	 */

	set_split_screen_used( get_screen_split() < get_screen_height() );

	/*
	 * For the purposes of choosing a mode set up boolean values for chars per line (to help
	 * select the correct text mode), and screen height (to select EGA resolution).
	 */

	set_200_scan_lines( (get_screen_height()/get_pc_pix_height()) == 200 );

	/*
	 * Set up the appropriate update routine according to the memory organisation selected
	 * and return an indication of whether more than 1 plane can be used by the display.
	 *
	 * Note that in chained mode plane01 is considered to be one plane. Similarly for plane23
	 *
	 * We have to be careful that a nasty program, such as EGA-PICS, hasn't set up a ridiculously big
	 * screen size for the CGA modes (presumably caused by us being unlucky when the timer tick goes off).
	 */
	if(is_it_cga() && get_screen_length() > 0x4000)
		mode = DUMMY_FUN;
	else
		mode = choose_mode[get_munged_index()];

	/*
	 * Now set up screen pointers appropriately.
	 */

	set_up_screen_ptr();

	set_update_routine(mode);

	/*
	 * set up the paint routine to correspond with the memory organisation and the update routine
	 * (this bit is host specific)
	 */

	host_set_paint_routine(mode,get_screen_height());

	/*
	 * The screen needs refreshing, because the update and paint routines have changed.
	 * Indicate to the update routines that the next time they are called, they must update
	 * the whole screen
	 */

	screen_refresh_required();
#endif   //NEC_98
	return TRUE;
}

#endif /* EGG */
#endif /* REAL_VGA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\ega_read.c ===
#include "insignia.h"
#include "host_def.h"

#if !(defined(NTVDM) && defined(MONITOR))

/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DOCUMENT 		: name and number

RELATED DOCS		: include all relevant references

DESIGNER		:

REVISION HISTORY	:
First version		: August 1988, J. Maiden
Second version		: February 1991, John Shanly, SoftPC 3.0

SUBMODULE NAME		: ega		

SOURCE FILE NAME	: ega_read.c

PURPOSE			: emulation of EGA read operations

SccsID = @(#)ega_read.c	1.32 09/07/94 Copyright Insignia Solutions Ltd.
		

[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

	INCLUDE FILE : ega_read.gi

[1.1    INTERMODULE EXPORTS]

	PROCEDURES() :
			void ega_read_init()
			void ega_read_term()
			void ega_read_routines_update()
	DATA 	     :	
-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]
-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
	 (not o/s objects or standard libs)

	PROCEDURES() :

	DATA 	     : 	give name, and source module name

-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

[1.4.2 EXPORTED OBJECTS]
=========================================================================
PROCEDURE	 	 : 	ega_read_init

PURPOSE		  : 	initialize EGA read aspects.
		
PARAMETERS	  :	none

GLOBALS		  :	none

DESCRIPTION	  : 	initialize ega read data and code to sensible state.

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================
PROCEDURE	 	 : 	ega_read_term

PURPOSE		  : 	terminate EGA read aspects.
		
PARAMETERS	  :	none

GLOBALS		  :	none

DESCRIPTION	  : 	set things up so that read processing is effectively turned off.

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

PROCEDURE	 	 : 	ega_read_routines_update

PURPOSE		  : 	Update read state to match registers.
		
PARAMETERS	  :	none

GLOBALS		  :	none

DESCRIPTION	  : 	Examines RAM enabled/disabled bit, read mode, chained/unchained
				and either mapped plane or colour compare and colour don't
				care states.  Sets global variables that allow byte_read,
				word_read and string_read to yield the data that would be
				read from M.

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.

=========================================================================

/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]						*/

/* [3.1.1 #INCLUDES]                                                    */


#ifdef EGG

#include	"xt.h"
#include	CpuH
#include	"debug.h"
#include	"sas.h"
#include	"gmi.h"
#include	"gvi.h"
#include	"ios.h"
#include	"egacpu.h"
#include	"egaports.h"
#include	"egaread.h"
#include	"ga_mark.h"
#include	"ga_defs.h"
#include	"cpu_vid.h"

/* [3.1.2 DECLARATIONS]                                                 */

/* [3.2 INTERMODULE EXPORTS]						*/

/*
5.0 MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]						*/

/* [5.1.1 #DEFINES]							*/

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_EGA.seg"
#endif

#if defined(EGA_DUMP) || defined(EGA_STAT)
#define	change_read_pointers(ptr)	dump_change_read_pointers(&ptr)
#else
#ifdef EGATEST
#define	change_read_pointers(ptr)	read_pointers = ptr
#else
#define	change_read_pointers(ptr)	read_glue_ptrs = ptr
#endif /* EGATEST */
#endif

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]			*/


/* [5.1.3 PROCEDURE() DECLARATIONS]					*/


/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

	[5.2.1 INTERNAL DATA DEFINITIONS 					*/

extern IU32 glue_b_read();
extern IU32 glue_w_read();
extern void glue_str_read();

#ifndef REAL_VGA
READ_POINTERS read_glue_ptrs;

/* If we have no string operations, the host allocates storage for "read_pointers" */

#ifndef	NO_STRING_OPERATIONS
GLOBAL READ_POINTERS read_pointers;
#endif	/* NO_STRING_OPERATIONS */


#ifndef CPU_40_STYLE	/* i.e. EVID without introducing an EVID define */
#ifndef EGATEST
#ifndef A3CPU
#ifndef JOKER
READ_POINTERS Glue_reads =
{
	glue_b_read,
	glue_w_read

#ifndef	NO_STRING_OPERATIONS
	,
	glue_str_read
#endif	/* NO_STRING_OPERATIONS */
};
#endif /* JOKER */
#endif /* A3CPU */
#endif /* EGATEST */

READ_POINTERS	simple_reads =
{
	_simple_b_read,
	_simple_w_read

#ifndef	NO_STRING_OPERATIONS
	,
	_simple_str_read
#endif	/* NO_STRING_OPERATIONS */
};

READ_POINTERS	pointers_RAM_off =
{
	_rd_ram_dsbld_byte,
	_rd_ram_dsbld_word

#ifndef	NO_STRING_OPERATIONS
	,
	_rd_ram_dsbld_string
#endif	/* NO_STRING_OPERATIONS */
};

READ_POINTERS	pointers_mode0_nch =
{
	_rdm0_byte_nch,
	_rdm0_word_nch

#ifndef	NO_STRING_OPERATIONS
	,
	_rdm0_string_nch
#endif	/* NO_STRING_OPERATIONS */
};

#ifdef VGG
READ_POINTERS	pointers_mode0_ch4 =
{
	_rdm0_byte_ch4,
	_rdm0_word_ch4

#ifndef	NO_STRING_OPERATIONS
	,
	_rdm0_string_ch4
#endif	/* NO_STRING_OPERATIONS */
};
#endif

READ_POINTERS	pointers_mode1_nch =
{
	_rdm1_byte_nch,
	_rdm1_word_nch

#ifndef	NO_STRING_OPERATIONS
	,
	_rdm1_string_nch
#endif	/* NO_STRING_OPERATIONS */
};

#ifdef VGG
READ_POINTERS	pointers_mode1_ch4 =
{
	_rdm1_byte_ch4,
	_rdm1_word_ch4

#ifndef	NO_STRING_OPERATIONS
	,
	_rdm1_string_ch4
#endif	/* NO_STRING_OPERATIONS */
};
#endif

#ifdef A_VID
extern IU32 _ch2_md0_byte_read_glue();
extern IU32 _ch2_md0_word_read_glue();
extern void _ch2_md0_str_read_glue();

extern IU32 _ch2_md1_byte_read_glue();
extern IU32 _ch2_md1_word_read_glue();
extern void _ch2_md1_str_read_glue();

READ_POINTERS	pointers_mode0_ch2 =
{
	_ch2_md0_byte_read_glue,
	_ch2_md0_word_read_glue

#ifndef	NO_STRING_OPERATIONS
	,
	_ch2_md0_str_read_glue
#endif	/* NO_STRING_OPERATIONS */
};

READ_POINTERS	pointers_mode1_ch2 =
{
	_ch2_md1_byte_read_glue,
	_ch2_md1_word_read_glue

#ifndef	NO_STRING_OPERATIONS
	,
	_ch2_md1_str_read_glue
#endif	/* NO_STRING_OPERATIONS */
};
#else			/* AVID */

extern void rdm0_string_ch2 IPT3(UTINY *, dest, ULONG, offset, ULONG, count );
extern void rdm1_string_ch2 IPT3(UTINY *, dest, ULONG, offset, ULONG, count );
extern IU32 rdm0_byte_ch2 IPT1(ULONG, offset );
extern IU32 rdm1_byte_ch2 IPT1(ULONG, offset );
extern IU32 rdm0_word_ch2 IPT1(ULONG, offset );
extern IU32 rdm1_word_ch2 IPT1(ULONG, offset );

READ_POINTERS	pointers_mode0_ch2 =
{
	rdm0_byte_ch2,
	rdm0_word_ch2

#ifndef	NO_STRING_OPERATIONS
	,
	rdm0_string_ch2
#endif	/* NO_STRING_OPERATIONS */
};

READ_POINTERS	pointers_mode1_ch2 =
{
	rdm1_byte_ch2,
	rdm1_word_ch2

#ifndef	NO_STRING_OPERATIONS
	,
	rdm1_string_ch2
#endif	/* NO_STRING_OPERATIONS */
};

#endif /* A_VID */


#ifdef A3CPU
#ifdef C_VID
GLOBAL READ_POINTERS C_vid_reads;
#endif /* C_VID */
#else
#ifdef C_VID
GLOBAL READ_POINTERS C_vid_reads;
#else
GLOBAL READ_POINTERS A_vid_reads;
#endif /* A_VID */
#endif /* A3CPU */

#ifndef GISP_CPU
#if (defined(A_VID) && defined(A2CPU) && !defined(A3CPU)) || (defined(A3CPU) && defined(C_VID))
extern IU32 _glue_b_read();
extern IU32 _glue_w_read();
extern void _glue_str_read();

READ_POINTERS Glue_reads =
{
	_glue_b_read,
	_glue_w_read

#ifndef	NO_STRING_OPERATIONS
	,
	_glue_str_read
#endif	/* NO_STRING_OPERATIONS */

};
#endif
#endif /* GISP_CPU */

#else	/* CPU_40_STYLE - evid */

#ifdef C_VID
/* C_Evid glue */
extern read_byte_ev_glue IPT1(IU32, eaOff);
extern read_word_ev_glue IPT1(IU32, eaOff);
extern read_str_fwd_ev_glue IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
READ_POINTERS Glue_reads =
{
	read_byte_ev_glue,
	read_word_ev_glue,
	read_str_fwd_ev_glue
};
#else
READ_POINTERS Glue_reads = { 0, 0, 0 };
#endif /* C_VID */
READ_POINTERS	simple_reads;
READ_POINTERS	pointers_mode0_nch;
READ_POINTERS	pointers_mode1_nch;
READ_POINTERS	pointers_mode0_ch4;
READ_POINTERS	pointers_mode1_ch4;
READ_POINTERS	pointers_mode0_ch2;
READ_POINTERS	pointers_mode1_ch2;
GLOBAL READ_POINTERS C_vid_reads;
GLOBAL READ_POINTERS A_vid_reads;

ULONG EasVal;
IU32 latchval;	/* for get_latch() etc macros */
#endif	/* CPU_40_STYLE - evid */

READ_STATE read_state;

#ifndef	NO_STRING_OPERATIONS
GLOBAL void (*string_read_ptr)();
#endif	/* NO_STRING_OPERATIONS */

/* comparison masks for read mode 1 */
ULONG comp0, comp1, comp2, comp3;

/* colour comparison don't care masks for read mode 1 */
ULONG dont_care0, dont_care1, dont_care2, dont_care3;

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]				*/

/* Used to correct writes to M when in mode 0 */

GLOBAL IU32
rdm0_byte_ch2 IFN1(ULONG, offset )
{
	IU32 lsb;
	UTINY temp;
#ifndef NEC_98

	lsb = offset & 0x1;
	offset = ( offset >> 1 ) << 2;
	setVideolatches(*(IU32 *)( EGA_planes + offset ));

	offset |= lsb;

  	temp = EGA_CPU.read_mapped_plane_ch2[offset];

#ifdef C_VID
	EasVal = temp;
#endif
#endif  //NEC_98
	return( temp );
}

/* Used to correct writes to M when in mode 0 */

GLOBAL IU32
rdm0_word_ch2 IFN1(ULONG, offset )
{
	IU32 temp;
#ifndef NEC_98
	IU32 lsb;

	setVideolatches(*(IU32 *)( EGA_planes +
		((( offset + 1 ) >> 1 ) << 2 )));

	lsb = offset & 0x1;
	offset = ( offset >> 1 ) << 2;

	if( lsb )
	{
		temp = EGA_CPU.read_mapped_plane_ch2[offset + 1];
		temp |= ( EGA_CPU.read_mapped_plane_ch2[offset + 4] << 8 );
	}
	else
	{
		temp = EGA_CPU.read_mapped_plane_ch2[offset];
		temp |= ( EGA_CPU.read_mapped_plane_ch2[offset + 1] << 8 );
	}

#ifdef C_VID
	EasVal = temp;
#endif
#endif  //NEC_98
	return( temp );
}

/* Used to correct writes to M when in mode 0 */

GLOBAL void
rdm0_string_ch2 IFN3(UTINY *, dest, ULONG, offset, ULONG, count )
{
#ifndef NEC_98
	ULONG lsb;
	ULONG inc;
	UTINY *planes;

	if( getDF() )
		setVideolatches(*(IU32 *)( EGA_planes + (( offset >> 1 ) << 2 )));
	else
		setVideolatches(*(IU32 *)( EGA_planes + ((( offset + count - 1 ) >> 1 ) << 2 )));

	lsb = offset & 0x1;
	offset = ( offset >> 1 ) << 2;

	if( lsb )
	{
		offset += 1;
		inc = 3;
	}
	else
		inc = 1;

	planes = EGA_CPU.read_mapped_plane_ch2;

    while( count-- )
    {
#ifdef BACK_M
        *dest-- = *(planes + offset);
#else
        *dest++ = *(planes + offset);
#endif
		offset += inc;
		inc ^= 0x2;
    }
#endif  //NEC_98
}

/* Used to correct writes to M when in mode 1 */

GLOBAL IU32
rdm1_byte_ch2 IFN1(ULONG, offset )
{
#if defined(NEC_98)
        return((IU32)0L);
#else   //NEC_98
	IU32 temp, lsb;

	lsb = offset & 0x1;
	offset = ( offset >> 1 ) << 2;
	setVideolatches(*(IU32 *)( EGA_planes + offset ));

	if( lsb )
	{
		offset += 1;

		temp = (IU32)((( EGA_plane01[offset] ^ comp1 ) | dont_care1 )
					& (( EGA_plane23[offset] ^ comp3 ) | dont_care3 ));
	}
	else
	{
		temp = (IU32)((( EGA_plane01[offset] ^ comp0 ) | dont_care0 )
					& (( EGA_plane23[offset] ^ comp2 ) | dont_care2 ));
	}

#ifdef C_VID
	EasVal = temp;
#endif
	return( temp );
#endif  //NEC_98
}

GLOBAL IU32
rdm1_word_ch2 IFN1(ULONG, offset )		/* used to correct writes to M when in mode 1 */
{
#if defined(NEC_98)
        return((IU32)0L);
#else   //NEC_98
	IU32 temp1, temp2, lsb;

	setVideolatches(*(IU32 *)( EGA_planes + ((( offset + 1 ) >> 1 ) << 2 )));

	lsb = offset & 0x1;
	offset = ( offset >> 1 ) << 2;

	if( lsb )
	{
		offset += 1;
		temp1 = (( EGA_plane01[offset] ^ comp1 ) | dont_care1 )
					& (( EGA_plane23[offset] ^ comp3 ) | dont_care3 );

		offset += 3;
		temp2 = (( EGA_plane01[offset] ^ comp0 ) | dont_care0 )
					& (( EGA_plane23[offset] ^ comp2 ) | dont_care2 );
	}
	else
	{
		temp1 = (( EGA_plane01[offset] ^ comp0 ) | dont_care0 )
					& (( EGA_plane23[offset] ^ comp2 ) | dont_care2 );

		offset += 1;
		temp2 = (( EGA_plane01[offset] ^ comp1 ) | dont_care1 )
					& (( EGA_plane23[offset] ^ comp3 ) | dont_care3 );
	}

	temp1 |= temp2 << 8;

#ifdef C_VID
	EasVal = temp1;
#endif
	return( temp1 );
#endif  //NEC_98
}

GLOBAL void
rdm1_string_ch2 IFN3(UTINY *, dest, ULONG, offset, ULONG, count )	/* used to correct writes to M when in mode 1 */
{
#ifndef NEC_98
	UTINY *p01, *p23;
	ULONG tcount, lsb;

#ifdef BACK_M
#define	PLUS -
#define	MINUS +
#else
#define	PLUS +
#define	MINUS -
#endif

	if( getDF() )
		setVideolatches(*(IU32 *)( EGA_planes + (( offset >> 1 ) << 2 )));
	else
		setVideolatches(*(IU32 *)( EGA_planes + ((( offset + count - 1 ) >> 1 ) << 2 )));

	dest = dest PLUS count;

	lsb = offset & 0x1;
	offset = ( offset >> 1 ) << 2;

	/* Two streams of source data */

	p01 = &EGA_plane01[offset];
	p23 = &EGA_plane23[offset];

	offset = 0;

	if( lsb )
	{
		*(dest MINUS count) = (UTINY)((( *(p01 + 1) ^ comp1 ) | dont_care1 )
   							        & (( *(p23 + 1) ^ comp3 ) | dont_care3 ));
		count--;
		offset += 4;
	}

	tcount = count & ~1;

	while( tcount-- )
	{
		*(dest MINUS tcount) = (UTINY)((( *(p01 + offset) ^ comp0) | dont_care0 )
							        & (( *(p23 + offset) ^ comp2 ) | dont_care2 ));

		tcount--;
		offset += 1;

		*(dest MINUS tcount) = (UTINY)((( *(p01 + offset) ^ comp1) | dont_care1 )
							        & (( *(p23 + offset) ^ comp3 ) | dont_care3 ));

		offset += 3;
	}	

	if( count & 1 )
	{
		*(dest MINUS count) = (UTINY)((( *(p01 + offset) ^ comp0 ) | dont_care0 )
							        & (( *(p23 + offset) ^ comp2 ) | dont_care2 ));
	}
#endif  //NEC_98
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_GRAPHICS.seg"
#endif

#if !(defined(NTVDM) && defined(MONITOR))
GLOBAL void
Glue_set_vid_rd_ptrs IFN1(READ_POINTERS *, handler )
{
#ifndef NEC_98
#ifndef CPU_40_STYLE	/* EVID */
#ifdef A3CPU
#ifdef C_VID

	C_vid_reads.b_read = handler->b_read;
	C_vid_reads.w_read = handler->w_read;
	C_vid_reads.str_read = handler->str_read;

#else
	UNUSED(handler);
#endif
#else					/* A3CPU */
#ifdef C_VID

	C_vid_reads.b_read = handler->b_read;
	C_vid_reads.w_read = handler->w_read;

#ifndef	NO_STRING_OPERATIONS
	C_vid_reads.str_read = handler->str_read;
#endif	/* NO_STRING_OPERATIONS */

#else

	A_vid_reads = *handler;

#if	0
	A_vid_reads.b_read = handler->b_read;
	A_vid_reads.w_read = handler->w_read;
#ifndef	NO_STRING_OPERATIONS
	A_vid_reads.str_read = handler->str_read;
#endif	/* NO_STRING_OPERATIONS */
#endif	/* 0 */

#endif	/* C_VID */
#endif	/* A3CPU */
#endif	/* CPU_40_STYLE - EVID */
#endif  //NEC_98
}	
#endif /* !(NTVDM && MONITOR) */

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_EGA.seg"
#endif

GLOBAL void
update_shift_count IFN0()

{
#ifndef NEC_98
	switch( EGA_CPU.chain )
	{
		case UNCHAINED:

 			/*
 			 *	Interleaved - need a shift count for accessing the mapped plane
 			 */

#ifdef BIGEND
 			setVideoread_shift_count(( 3 - getVideoread_mapped_plane() ) << 3);
#else
 			setVideoread_shift_count(getVideoread_mapped_plane() << 3);
#endif /* BIGEND */


			break;

		case CHAIN2:

 			/*
 			 *	Planar - need an offset for accessing the mapped plane
 			 */

 			EGA_CPU.read_mapped_plane_ch2 = EGA_planes +
		 					(getVideoread_mapped_plane() & 2) * EGA_PLANE_SIZE;

			break;

#ifdef	VGG
		case CHAIN4:

 			/*
 			 *	Interleaved - doesn't need any magic numbers
 			 */

			break;
#endif	/* VGG */
	}
#endif  //NEC_98
}

void
ega_read_routines_update IFN0()

{
#ifndef NEC_98
	LOCAL BOOL ram_off = TRUE;	/* optimised to avoid updates if ram disabled */
	LOCAL READ_POINTERS *read_ptrs;

	/* ram disabled and not now being enabled	*/

	if( ram_off && (!EGA_CPU.ram_enabled ))
		return;

	if( !EGA_CPU.ram_enabled )	/* video off, just return 0xff */
	{
#ifdef CPU_40_STYLE
		SetReadPointers(2);
#else  /* CPU_40_STYLE */

#ifndef GISP_CPU	
#ifdef A3CPU
#ifdef C_VID
		Glue_set_vid_rd_ptrs( &pointers_RAM_off );
#else
		Cpu_set_vid_rd_ptrs( &pointers_RAM_off );
#endif /* C_VID */
#else
		Glue_set_vid_rd_ptrs( &pointers_RAM_off );
#endif /* A3CPU */
#endif /* GISP_CPU */

#ifndef	NO_STRING_OPERATIONS
		setVideofwd_str_read_addr(_rd_ram_dsbld_fwd_string_lge);
		setVideofwd_str_read_addr(_rd_ram_dsbld_bwd_string_lge);
#endif	/* NO_STRING_OPERATIONS */

#endif  /* CPU_40_STYLE */

		ram_off = TRUE;	/* prevent recalcs until ram enabled again */

		return;
	}

	ram_off = FALSE;

	if( read_state.mode == 0 )    /* read mode 0 */
	{
		/* chained in write mode implies chained for reading too */

		switch( EGA_CPU.chain )
		{
			case UNCHAINED:
#ifdef CPU_40_STYLE
				SetReadPointers(0);
#else  /* CPU_40_STYLE */

				read_ptrs = &pointers_mode0_nch;
#ifndef	NO_STRING_OPERATIONS
				setVideofwd_str_read_addr(_rdm0_fwd_string_nch_lge);
				setVideobwd_str_read_addr(_rdm0_bwd_string_nch_lge);
#endif	/* NO_STRING_OPERATIONS */
#endif	/* CPU_40_STYLE */
				break;
				
			case CHAIN2:
#ifdef CPU_40_STYLE
				SetReadPointers(0);
#else  /* CPU_40_STYLE */

				read_ptrs = &pointers_mode0_ch2;
#ifndef	NO_STRING_OPERATIONS
				string_read_ptr = rdm0_string_ch2;
#endif	/* NO_STRING_OPERATIONS */
#endif	/* CPU_40_STYLE */
				EGA_CPU.read_mapped_plane_ch2 = EGA_planes +
							(getVideoread_mapped_plane() & 2)*EGA_PLANE_SIZE;
				break;
				
#ifdef	VGG
			case CHAIN4:
#ifdef CPU_40_STYLE
				SetReadPointers(0);
#else  /* CPU_40_STYLE */

				read_ptrs = &pointers_mode0_ch4;
#ifndef	NO_STRING_OPERATIONS
				setVideofwd_str_read_addr(_rdm0_fwd_string_ch4_lge);
				setVideobwd_str_read_addr(_rdm0_bwd_string_ch4_lge);
#endif

#endif	/* CPU_40_STYLE */
				break;
#endif	/* VGG */
		}
	}
	else   /* read mode 1 */
	{
		switch( EGA_CPU.chain )
		{
			case UNCHAINED:
				/* preserve or complement values by xor with comps later */

				setVideodont_care(~sr_lookup[read_state.colour_dont_care]);
				setVideocolour_comp(~sr_lookup[read_state.colour_compare]);

#ifdef CPU_40_STYLE
				SetReadPointers(1);
#else  /* CPU_40_STYLE */

				read_ptrs = &pointers_mode1_nch;
#ifndef	NO_STRING_OPERATIONS
				setVideofwd_str_read_addr(_rdm1_fwd_string_nch_lge);
				setVideobwd_str_read_addr(_rdm1_bwd_string_nch_lge);
#endif	/* NO_STRING_OPERATIONS */
#endif	/* CPU_40_STYLE */
				break;

			case CHAIN2:
				dont_care0 = read_state.colour_dont_care & 1 ? 0 : 0xff;
				dont_care1 = read_state.colour_dont_care & 2 ? 0 : 0xff;
				dont_care2 = read_state.colour_dont_care & 4 ? 0 : 0xff;
				dont_care3 = read_state.colour_dont_care & 8 ? 0 : 0xff;

				comp0 = read_state.colour_compare & 1 ? 0 : 0xff;
				comp1 = read_state.colour_compare & 2 ? 0 : 0xff;
				comp2 = read_state.colour_compare & 4 ? 0 : 0xff;
				comp3 = read_state.colour_compare & 8 ? 0 : 0xff;

#ifdef CPU_40_STYLE
				SetReadPointers(1);
#else  /* CPU_40_STYLE */

				read_ptrs = &pointers_mode1_ch2;
#ifndef	NO_STRING_OPERATIONS
				string_read_ptr = rdm1_string_ch2;
#endif	/* NO_STRING_OPERATIONS */

#endif	/* CPU_40_STYLE */

				break;

#ifdef	VGG
			case CHAIN4:
				setVideodont_care(( read_state.colour_dont_care & 1 ) ? 0 : 0xff);
				setVideocolour_comp(( read_state.colour_compare & 1 ) ? 0 : 0xff);

#ifdef CPU_40_STYLE
				SetReadPointers(1);
#else  /* CPU_40_STYLE */

				read_ptrs = &pointers_mode1_ch4;
#ifndef	NO_STRING_OPERATIONS
				setVideofwd_str_read_addr(_rdm1_fwd_string_ch4_lge);
				setVideobwd_str_read_addr(_rdm1_bwd_string_ch4_lge);
#endif	/* NO_STRING_OPERATIONS */
#endif	/* CPU_40_STYLE */
				break;
#endif	/* VGG */
		}
	}

	update_shift_count();
	update_banking();

#ifndef CPU_40_STYLE
#ifndef GISP_CPU
#ifdef A3CPU
#ifdef C_VID
	Glue_set_vid_rd_ptrs( read_ptrs );
#else
	Cpu_set_vid_rd_ptrs( read_ptrs );
#endif /* C_VID */
#else
	Glue_set_vid_rd_ptrs( read_ptrs );
#endif /* A3CPU */
#endif /* GISP_CPU */
#endif	/* CPU_40_STYLE */
#endif  //NEC_98
}

void
ega_read_init IFN0()

{
#ifndef NEC_98
	read_state.mode = 0;
	read_state.colour_compare = 0x0f;		/* looking for bright white */
	read_state.colour_dont_care = 0xf;		/* all planes significant */

#ifdef CPU_40_STYLE
	SetReadPointers(2);
#else  /* CPU_40_STYLE */

#ifndef	NO_STRING_OPERATIONS
	setVideofwd_str_read_addr(_rd_ram_dsbld_fwd_string_lge);
	setVideobwd_str_read_addr(_rd_ram_dsbld_bwd_string_lge);
#endif	/* NO_STRING_OPERATIONS */
#endif	/* CPU_40_STYLE */

	setVideoread_mapped_plane(0);

	ega_read_routines_update();			/* initialise M */

#if defined(EGA_DUMP) || defined(EGA_STAT)
	dump_read_pointers_init();
#endif

#if !defined(EGATEST) && !defined(A3CPU)
	read_pointers = Glue_reads;
#endif /* EGATEST */

#ifndef CPU_40_STYLE
#ifndef GISP_CPU
#ifdef A3CPU
#ifdef C_VID
	Cpu_set_vid_rd_ptrs( &Glue_reads );
	Glue_set_vid_rd_ptrs( &pointers_mode0_nch );
#else
	Cpu_set_vid_rd_ptrs( &pointers_mode0_nch );
#endif	/* C_VID */
#else	/* A3CPU */
	Glue_set_vid_rd_ptrs( &pointers_mode0_nch );
#endif	/* A3CPU */
#endif /* GISP_CPU */
#endif	/* CPU_40_STYLE */
#endif  //NEC_98
}

void
ega_read_term IFN0()

{
#ifndef NEC_98
	/*
	 *	Turn off read calculations for non EGA/VGA adaptors
	 */

#ifdef CPU_40_STYLE
		SetReadPointers(3);
#else  /* CPU_40_STYLE */

#ifndef GISP_CPU
#ifdef A3CPU
#ifdef C_VID
	Glue_set_vid_rd_ptrs( &simple_reads );
#else
	Cpu_set_vid_rd_ptrs( &simple_reads );
#endif /* C_VID */
#else
	Glue_set_vid_rd_ptrs( &simple_reads );
#endif /* A3CPU */
#endif /* GISP_CPU */
#endif	/* CPU_40_STYLE */
#endif  //NEC_98
}

#endif /* REAL_VGA */
#endif /* EGG */

#endif	/* !(NTVDM && MONITOR) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\ega_trcr.c ===
#include "insignia.h"
#include "host_def.h"

#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )

/*
 * SccsID @(#)ega_tracer.c	1.7 8/25/93 Copyright Insignia Solutions
 *    Set of routines to output all accesses to the EGA, in a form that
 *    can be read in & executed by the stand-alone EGA.
 *
 */


#ifdef EGA_DUMP

#include <stdio.h>
#include TypesH

#include "xt.h"
#include "sas.h"
#include "gmi.h"
#include "egatrace.h"
#include "egaports.h"
#include "gfx_upd.h"
#include CpuH

IMPORT VOID host_applClose IPT0();

static FILE *dump_file;
mem_handlers dump_writes;

static void putl(addr,dest_file)
byte *addr;
FILE *dest_file;
{
	sys_addr addr_m = addr-M;

	putc(addr_m & 0xff,dest_file);
	addr_m >>= 8;
	putc(addr_m & 0xff,dest_file);
	addr_m >>= 8;
	putc(addr_m & 0xff,dest_file);
}

dump_inb(port)
int port;
{
	putc(INB,dump_file);
	putc(port & 0xff,dump_file);
	putc((port>>8) & 0xff,dump_file);
}

dump_inw(port)
int port;
{
	putc(INW,dump_file);
	putc(port & 0xff,dump_file);
	putc((port>>8) & 0xff,dump_file);
}

dump_outb(port,value)
int port,value;
{
	putc(OUTB,dump_file);
	putc(port & 0xff,dump_file);
	putc((port>>8) & 0xff,dump_file);
	putc(value,dump_file);
}

dump_outw(port,value)
int port,value;
{
	putc(OUTW,dump_file);
	putc(port & 0xff,dump_file);
	putc((port>>8) & 0xff,dump_file);
	putc(value & 0xff,dump_file);
	putc((value >> 8),dump_file);
}

boolean	dump_b_write(addr)
host_addr addr;
{
	putc(WRITE_BYTE,dump_file);
	putl(addr,dump_file);
	putc(*addr,dump_file);

	(*dump_writes.b_write)(addr);
}

boolean	dump_w_write(addr)
host_addr addr;
{
	putc(WRITE_WORD,dump_file);
	putl(addr,dump_file);
	putc(*addr,dump_file);
	putc(*(addr+1),dump_file);

	(*dump_writes.w_write)(addr);
}

boolean	dump_b_fill(l_addr,h_addr)
host_addr l_addr,h_addr;
{
	putc(FILL_BYTE,dump_file);
	putl(l_addr,dump_file);
	putl(h_addr,dump_file);
	putc(*l_addr,dump_file);

	(*dump_writes.b_fill)(l_addr,h_addr);
}

boolean	dump_w_fill(l_addr,h_addr)
host_addr l_addr,h_addr;
{
	putc(FILL_WORD,dump_file);
	putl(l_addr,dump_file);
	putl(h_addr,dump_file);
	putc(*l_addr,dump_file);
	putc(*(l_addr+1),dump_file);

	(*dump_writes.w_fill)(l_addr,h_addr);
}

boolean	dump_b_move(l_addr,h_addr)
host_addr l_addr,h_addr;
{
	host_addr i;

	putc(MOVE_BYTE,dump_file);
	putl(l_addr,dump_file);
	putl(h_addr,dump_file);
	putl(haddr_of_src_string,dump_file);
	for(i=l_addr;i<=h_addr;i++)
	{
		putc(*i,dump_file);
	}

	(*dump_writes.b_move)(l_addr,h_addr);
}

boolean	dump_w_move(l_addr,h_addr)
host_addr l_addr,h_addr;
{
	host_addr i;

	putc(MOVE_BYTE,dump_file);
	putl(l_addr,dump_file);
	putl(h_addr,dump_file);
	putl(haddr_of_src_string,dump_file);
	for(i=l_addr;i<=h_addr;i++)
	{
		putc(*i,dump_file);
	}

	(*dump_writes.w_move)(l_addr,h_addr);
}

dump_tick()
{
	putc(TICK,dump_file);
}

dump_scroll(mode,direction,video_addr,video_off,video_cols,lr,tc,rd,cd,lines,attr)
byte mode,direction;
sys_addr video_addr;
word video_off,video_cols;
byte lr,tc,rd,cd,lines,attr;
{
	putc(SCROLL,dump_file);
	putc(mode,dump_file);
	putc(direction,dump_file);
	putl(video_addr,dump_file);
	putc(video_off,dump_file);
	putc(video_off >> 8,dump_file);
	putc(video_cols,dump_file);
	putc(lr,dump_file);
	putc(tc,dump_file);
	putc(rd,dump_file);
	putc(cd,dump_file);
	putc(lines,dump_file);
	putc(attr,dump_file);
}


static	void	recalc_dump(),byte_read_dump(),word_read_dump(),string_read_dump();

struct READ_POINTERS
  {
	void (*recalc_read) ();
	void (*byte_read) ();
	void (*word_read) ();
	void (*string_read) ();
  } dump_read_pointers = { recalc_dump, byte_read_dump, word_read_dump,
				string_read_dump };

extern	struct	READ_POINTERS	read_pointers;

/*
 * cpu read handlers
 * rely on C being called if read_pointer.xxxx_read
 * does not point at byte_read_mode0
 */

static	void	recalc_dump()
{
	printf("recalc dump called!!!\n");
}

static	void	byte_read_dump(addr)
byte	*addr;
{
	putc(READ_BYTE,dump_file);
	putl(addr,dump_file);
	(*dump_read_pointers.byte_read)(addr);
}

static	void	word_read_dump(addr)
byte	*addr;
{
	putc(READ_WORD,dump_file);
	putl(addr,dump_file);
	(*dump_read_pointers.word_read)(addr);
}

static	void	string_read_dump(laddr,haddr)
byte	*laddr,*haddr;
{
	putc(READ_STRING,dump_file);
	putl(laddr,dump_file);
	putl(haddr,dump_file);
	putc(getDF(),dump_file);
	(*dump_read_pointers.string_read)(laddr,haddr);
}

dump_read_pointers_init()
{
	read_pointers = dump_read_pointers;
}

dump_change_read_pointers(ptr)
struct	READ_POINTERS	*ptr;
{
	dump_read_pointers = *ptr;
}

static mem_handlers catch_writes = 
	{dump_b_write,dump_w_write,dump_b_fill,dump_w_fill,dump_b_move,dump_w_move};

void	dump_add_checkpoint()
{
	putc(CHECKPT,dump_file);
}

dump_init(file_name,type)
char *file_name;
char type;
{
	dump_file = fopen(file_name,"w");
	if(dump_file == NULL)
	{
		host_applClose();
		printf("ARRGGH can't open %s\n",file_name);
		exit(1);
	}
	putc(type,dump_file);

	dump_writes = vid_handlers;
	gmi_define_mem(VIDEO,&catch_writes);
}

dump_end()
{
	fclose(dump_file);
}

#endif

#endif	/* !NTVDM | (NTVDM & !X86GFX) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\egawrtm0.c ===
#include "insignia.h"
#include "host_def.h"

#if !(defined(NTVDM) && defined(MONITOR))

/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.


DOCUMENT 		: name and number

RELATED DOCS		: include all relevant references

DESIGNER		: P. Jadeja

REVISION HISTORY	:
First version		: P. Jadeja, SoftPC 2.0, 10-Aug-88
Second version		: John Shanly, SoftPC 3.0, 9 April 1991

SUBMODULE NAME		: write mode 0

SOURCE FILE NAME	: ega_write_mode0.c

PURPOSE			: purpose of this submodule

SccsID = "@(#)ega_wrtm0.c	1.31 11/01/94 Copyright Insignia Solutions Ltd."
		

[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

	INCLUDE FILE : xxx.gi

[1.1    INTERMODULE EXPORTS]

	PROCEDURES() :	ega_mode0_chn_b_write();
			ega_mode0_chn_w_write();
			ega_mode0_chn_b_fill();
			ega_mode0_chn_w_fill();
			ega_mode0_chn_b_move();
			ega_mode0_chn_w_move();

			ega_copy_b_write();
			ega_copy_w_write();
			ega_copy_b_fill();
			ega_copy_w_fill();
			ega_copy_b_move();
			ega_copy_w_move();

			ega_copy_all_b_write();
	DATA 	     :	give type and name

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]

	STRUCTURES/TYPEDEFS/ENUMS:
		
-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
     (not o/s objects or standard libs)

	PROCEDURES() : 	give name, and source module name

	DATA 	     : 	give name, and source module name

-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

DATA OBJECTS	  :	specify in following procedure descriptions
			how these are accessed (read/modified)

FILES ACCESSED    :	list all files, how they are accessed,
			how file data is interpreted, etc. if relevant
			(else omit)

DEVICES ACCESSED  :	list all devices accessed, special modes used
			(e.g; termio structure). if relevant (else
			omit)

SIGNALS CAUGHT	  :	list any signals caught if relevant (else omit)

SIGNALS ISSUED	  :	list any signals sent if relevant (else omit)


[1.4.2 EXPORTED OBJECTS]
=========================================================================
PROCEDURE	  : 	

PURPOSE		  :
		
PARAMETERS	

	name	  : 	describe contents, and legal values
			for output parameters, indicate by "(o/p)"
			at start of description

GLOBALS		  :	describe what exported data objects are
			accessed and how. Likewise for imported
			data objects.

ACCESS		  :	specify if signal or interrupt handler
			if relevant (else omit)

ABNORMAL RETURN	  :	specify if exit() or longjmp() etc.
			can be called if relevant (else omit)

RETURNED VALUE	  : 	meaning of function return values

DESCRIPTION	  : 	describe what (not how) function does

ERROR INDICATIONS :	describe how errors are returned to caller

ERROR RECOVERY	  :	describe how procedure reacts to errors
=========================================================================


/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]						*/

/* [3.1.1 #INCLUDES]                                                    */

IMPORT VOID fill_alternate_bytes IPT3( IS8 *, start, IS8 *, end, IS8, value);
IMPORT VOID fill_both_bytes IPT3( IU16, data, IU16 *, dest, ULONG, len );

#ifdef EGG

#include TypesH
#include "xt.h"
#include CpuH
#include "debug.h"
#include "gmi.h"
#include "sas.h"
#include "egacpu.h"
#include "egaports.h"
#include "cpu_vid.h"
#include "gfx_upd.h"
#include "host.h"

/* [3.1.2 DECLARATIONS]                                                 */

/* [3.2 INTERMODULE EXPORTS]						*/


/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]						*/

/* [5.1.1 #DEFINES]							*/
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#ifdef PROD
#include "SOFTPC_EGA.seg"
#else
#include "SOFTPC_EGA_WRITE.seg"
#endif
#endif

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]			*/

typedef	union {
	unsigned short	as_word;
	struct {
#ifdef	BIGEND
		unsigned char	hi_byte;
		unsigned char	lo_byte;
#else
		unsigned char	lo_byte;
		unsigned char	hi_byte;
#endif
	} as_bytes;
	struct {
		unsigned char	first_byte;
		unsigned char	second_byte;
	} as_array;
} TWO_BYTES;

/* [5.1.3 PROCEDURE() DECLARATIONS]					*/

/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS 					*/

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]				*/

/*
7.INTERMODULE INTERFACE IMPLEMENTATION :
*/

/*
[7.1 INTERMODULE DATA DEFINITIONS]				*/

#ifdef A_VID
IMPORT VOID	_ch2_copy_byte_write();
IMPORT VOID	_ch2_copy_word_write();
IMPORT VOID	_ch2_copy_byte_fill_glue();
IMPORT VOID	_ch2_copy_word_fill_glue();
IMPORT VOID	_ch2_copy_byte_move_glue();
IMPORT VOID	_ch2_copy_word_move_glue();
IMPORT VOID	_ch2_copy_byte_move_glue_fwd();
IMPORT VOID	_ch2_copy_word_move_glue_fwd();
IMPORT VOID	_ch2_copy_byte_move_glue_bwd();
IMPORT VOID	_ch2_copy_word_move_glue_bwd();

IMPORT VOID	_ch2_mode0_chn_byte_write_glue();
IMPORT VOID	_ch2_mode0_chn_word_write_glue();
IMPORT VOID	_ch2_mode0_chn_byte_fill_glue();
IMPORT VOID	_ch2_mode0_chn_word_fill_glue();
IMPORT VOID	_ch2_mode0_chn_byte_move_glue();
IMPORT VOID	_ch2_mode0_chn_word_move_glue();

WRT_POINTERS mode0_copy_handlers =
{
	_ch2_copy_byte_write,
	_ch2_copy_word_write

#ifndef	NO_STRING_OPERATIONS
	,
	_ch2_copy_byte_fill_glue,
	_ch2_copy_word_fill_glue,
	_ch2_copy_byte_move_glue_fwd,
	_ch2_copy_byte_move_glue_bwd,
	_ch2_copy_word_move_glue_fwd,
	_ch2_copy_word_move_glue_bwd

#endif	/* NO_STRING_OPERATIONS */

};

WRT_POINTERS mode0_gen_handlers =
{
	_ch2_mode0_chn_byte_write_glue,
	_ch2_mode0_chn_word_write_glue

#ifndef	NO_STRING_OPERATIONS
	,
	_ch2_mode0_chn_byte_fill_glue,
	_ch2_mode0_chn_word_fill_glue,
	_ch2_mode0_chn_byte_move_glue,
	_ch2_mode0_chn_byte_move_glue,
	_ch2_mode0_chn_word_move_glue,
	_ch2_mode0_chn_word_move_glue

#endif	/* NO_STRING_OPERATIONS */

};
#else
VOID  ega_copy_b_write(ULONG, ULONG);
VOID  ega_copy_w_write(ULONG, ULONG);
VOID  ega_copy_b_fill(ULONG, ULONG, ULONG);
VOID  ega_copy_w_fill(ULONG, ULONG, ULONG);
VOID  ega_copy_b_move_fwd   IPT4(ULONG,  offset, ULONG, eas, ULONG, count, ULONG, src_flag );
VOID  ega_copy_b_move_bwd   IPT4(ULONG,  offset, ULONG, eas, ULONG, count, ULONG, src_flag );
VOID  ega_copy_w_move_fwd   IPT4(ULONG,  offset, ULONG, eas, ULONG, count, ULONG, src_flag );
VOID  ega_copy_w_move_bwd   IPT4(ULONG,  offset, ULONG, eas, ULONG, count, ULONG, src_flag );
			

VOID  ega_mode0_chn_b_write(ULONG, ULONG);
VOID  ega_mode0_chn_w_write(ULONG, ULONG);
VOID  ega_mode0_chn_b_fill(ULONG, ULONG, ULONG);
VOID  ega_mode0_chn_w_fill(ULONG, ULONG, ULONG);
VOID  ega_mode0_chn_b_move_fwd   IPT4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag );
VOID  ega_mode0_chn_b_move_bwd   IPT4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag );
VOID  ega_mode0_chn_w_move_fwd   IPT4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag );
VOID  ega_mode0_chn_w_move_bwd   IPT4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag );


WRT_POINTERS mode0_copy_handlers =
{
      ega_copy_b_write,
      ega_copy_w_write

#ifndef	NO_STRING_OPERATIONS
	  ,
      ega_copy_b_fill,
      ega_copy_w_fill,
      ega_copy_b_move_fwd,
      ega_copy_b_move_bwd,
      ega_copy_w_move_fwd,
      ega_copy_w_move_bwd,

#endif	/* NO_STRING_OPERATIONS */
};

WRT_POINTERS mode0_gen_handlers =
{
      ega_mode0_chn_b_write,
      ega_mode0_chn_w_write

#ifndef	NO_STRING_OPERATIONS
	  ,
      ega_mode0_chn_b_fill,
      ega_mode0_chn_w_fill,
      ega_mode0_chn_b_move_fwd,
      ega_mode0_chn_b_move_bwd,
      ega_mode0_chn_w_move_fwd,
      ega_mode0_chn_w_move_bwd,

#endif	/* NO_STRING_OPERATIONS */
};
#endif /* A_VID */

/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]				*/

byte rotate IFN2(byte, value, int, nobits)
{
	/*
	 * Rotate a byte right by nobits. Do this by making a copy of
	 * the byte into the msbyte of the word, and then shifting the
	 * word by the required amount, and then returning the resulting low byte.
	 */

	TWO_BYTES	double_num;

	double_num.as_bytes.lo_byte = double_num.as_bytes.hi_byte = value;
	double_num.as_word >>= nobits;
	return double_num.as_bytes.lo_byte;
}

#ifndef NEC_98
VOID
ega_copy_b_write IFN2(ULONG, value, ULONG, offset )
{
	ULONG lsb;
	note_entrance0("ega_copy_b_write");

	(*update_alg.mark_byte)( offset );

	lsb = offset & 0x1;
	offset = (offset >> 1) << 2;
	offset |= lsb;

	*(IU8 *)(getVideowplane() + offset) = (IU8)value;
}

VOID
ega_copy_w_write IFN2(ULONG, value, ULONG, offset )
{
	ULONG lsb;
	UTINY *planes;

	note_entrance0("ega_copy_w_write");

	(*update_alg.mark_word)( offset );

	lsb = offset & 0x1;
	offset = (offset >> 1) << 2;
	planes = getVideowplane() + offset;

	if( lsb )
	{
		*(planes + 1) = (UTINY)value;
		*(planes + 4) = (UTINY)(value >> 8);
	}
	else
	{
		*planes = (UTINY)value;
		*(planes + 1) = (UTINY)(value >> 8);
	}
}

VOID
ega_copy_b_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
    ULONG lsb;
    ULONG inc;
    UTINY *planes;

	note_entrance0("ega_copy_b_fill");

	(*update_alg.mark_fill)( offset, offset + count - 1 );

	lsb = offset & 0x1;
	offset = (offset >> 1) << 2;

    planes = getVideowplane() + offset;

    if( lsb )
    {
		planes += 1;
		inc = 3;
    }
    else
		inc = 1;

	while( count-- )
	{
		*planes = (UTINY) value;
		planes += inc;
		inc ^= 2;
	}
}
#endif  //NEC_98

#ifdef  BIGEND
#define first_half(wd)      (((wd) & 0xff00) >> 8)
#define sec_half(wd)        ((wd) & 0xff)
#else
#define first_half(wd)      ((wd) & 0xff)
#define sec_half(wd)        (((wd) & 0xff00) >> 8)
#endif

#ifndef NEC_98
VOID
ega_copy_w_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
    ULONG lsb;
    USHORT *planes;

	note_entrance0("ega_copy_w_fill");

#ifdef BIGEND
	value = ((value >> 8) & 0xff) | ((value << 8) & 0xff00);
#endif

    count >>= 1;

	/* the 3rd parameter is needed by GORE */
	(*update_alg.mark_wfill)( offset, offset + count - 1, 0 );

    lsb = offset & 0x1;
    offset = (offset >> 1) << 2;

    planes = (USHORT *) (getVideowplane() + offset);

    if( lsb )
    {
        word swapped = (word)(((value >> 8) & 0xff) | ((value << 8) & 0xff00));

        *((UTINY *) planes + 1) = (UTINY) first_half(value);

        count--;
        planes += 2;

        while( count-- )
        {
            *planes = swapped;
            planes += 2;
        }

        *((UTINY *) planes) = (UTINY) sec_half(value);
    }
    else
    {
        while( count-- )
        {
            *planes = (USHORT)value;
            planes += 2;
        }
    }
}

LOCAL VOID
ega_copy_move IFN6(UTINY *, dst, UTINY *, eas, ULONG, count, ULONG, src_flag,
	ULONG, w, IBOOL, forward )
{
	ULONG lsbeas, lsbdst;
	ULONG easinc, dstinc;
	ULONG easoff, dstoff;
	UTINY *planes;

	note_entrance0("ega_copy_move");

	(*update_alg.mark_string)( (ULONG) dst, (ULONG) dst + count - 1);

	planes = (UTINY *) getVideowplane();

	if( src_flag == 1 )
	{
		if(!forward)
		{
			eas += w;
			dst += w;
		}

		lsbeas = (ULONG) eas & 0x1;
		lsbdst = (ULONG) dst & 0x1;

		if(forward)
		{
			easinc = lsbeas ? 3 : 1;
			dstinc = lsbdst ? 3 : 1;
		}
		else
		{
			easinc = lsbeas ? -1 : -3;
			dstinc = lsbdst ? -1 : -3;
		}

		easoff = (( (ULONG) eas >> 1 ) << 2 ) | lsbeas;
		dstoff = (( (ULONG) dst >> 1 ) << 2 ) | lsbdst;

		while( count-- )
		{
			*(planes + dstoff) = *(planes + easoff);

			dstoff += dstinc;
			easoff += easinc;
			dstinc ^= 0x2;
			easinc ^= 0x2;
		}
	}
	else
	{
		if(!forward)
		{
			dst += w;
#ifdef BACK_M
			eas -= w;
#else
			eas += w;
#endif
		}

		lsbdst = (ULONG) dst & 0x1;

		if(forward)
		{
#ifdef BACK_M
			easinc = -1;
#else
			easinc = 1;
#endif
			dstinc = lsbdst ? 3 : 1;
		}
		else
		{
#ifdef BACK_M
			easinc = 1;
#else
			easinc = -1;
#endif
			dstinc = lsbdst ? -1 : -3;
		}

		dstoff = (((ULONG) dst >> 1 ) << 2 ) | lsbdst;

		while( count-- )
		{
			*(planes + dstoff) = *eas;

			dstoff += dstinc;
			eas += easinc;
			dstinc ^= 0x2;
		}
	}
}


VOID
ega_copy_b_move IFN4(UTINY *,  offset, UTINY *, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_copy_move(offset, eas, count, src_flag, 0, getDF() ? FALSE : TRUE);
}

VOID
ega_copy_b_move_fwd IFN4(ULONG,  offset, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_copy_move( (UTINY *)offset, (UTINY *)eas, count, src_flag, 0, TRUE );
}

VOID
ega_copy_b_move_bwd IFN4(ULONG,  offset, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_copy_move( (UTINY *)offset, (UTINY *)eas, count, src_flag, 0, FALSE );
}

VOID
ega_copy_w_move IFN4(UTINY *,  offset, UTINY *, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_copy_move(offset, eas, count << 1, src_flag, 1, getDF() ? FALSE : TRUE);
}

VOID
ega_copy_w_move_fwd IFN4(ULONG,  offset, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_copy_move( (UTINY *)offset, (UTINY *)eas, count << 1, src_flag, 1, TRUE );
}

VOID
ega_copy_w_move_bwd IFN4(ULONG,  offset, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_copy_move( (UTINY *)offset, (UTINY *)eas, count << 1, src_flag, 1, FALSE );
}

VOID
ega_mode0_chn_b_write IFN2(ULONG, value, ULONG, offset )
{
	ULONG lsb;

	note_entrance0("ega_mode0_chn_b_write");

   (*update_alg.mark_byte)( offset );

	lsb = offset & 0x1;
    offset = (offset >> 1) << 2;

	if( lsb )	/* odd address, in plane 1 or 3  */
	{
		offset |= 0x1;

		/*
		 * check if plane1 enabled
		 */

		if( getVideoplane_enable() & 2 )
		{
			/*
			 * check if set/reset function enable for this plane
			 */

			if( EGA_CPU.sr_enable & 2 )
			{
				value = *((UTINY *) &EGA_CPU.sr_value + 1);
				value = do_logicals( value, get_latch1 );
				EGA_plane01[offset] = (byte) value;
			}
			else
			{
				/*
				 * set/reset not enabled so here we go
				 */

				if( getVideorotate() > 0 )
					value = rotate( (byte) value, getVideorotate() );

				EGA_plane01[offset] = (byte) do_logicals( value, get_latch1 );
			}
		}

		/*
		 * check if plane3 enabled
		 */

		if( getVideoplane_enable() & 8 )
		{
			/*
			 * check if set/reset function enable for this plane
			 */

			if( EGA_CPU.sr_enable & 8 )
			{
				value = *((UTINY *) &EGA_CPU.sr_value + 3);
				value = do_logicals( value, get_latch3 );
				EGA_plane23[offset] = (byte)value;
			}
			else
			{
				/*
				 * set/reset not enabled so here we go
				 */

				if( getVideorotate() > 0 )
					value = rotate( (byte) value, getVideorotate() );

				EGA_plane23[offset] = (byte) do_logicals( value, get_latch3 );
			}
		}
	}
	else
	{	/* even address, in plane 0 or 2 */
		/*
		 * check if plane0 enabled
		 */

		if( getVideoplane_enable() & 1 )
		{

			/*
			 * check if set/reset function enable for this plane
			 */

			if(( EGA_CPU.sr_enable & 1 ))
			{
				value = *((UTINY *) &EGA_CPU.sr_value);
				value = do_logicals( value, get_latch0 );
				EGA_plane01[offset] = (byte) value;
			}
			else
			{
				/*
				 * set/reset not enabled so here we go
				 */

				if( getVideorotate() > 0 )
					value = rotate( (byte)value, getVideorotate() );

				EGA_plane01[offset] = (byte) do_logicals( value, get_latch0 );
			}
		}

		/*
		 * check if plane2 enabled
		 */

		if( getVideoplane_enable() & 4 )
		{

			/*
			 * check if set/reset function enable for this plane
			 */

			if(( EGA_CPU.sr_enable & 4 ))
			{
				value = *((UTINY *) &EGA_CPU.sr_value + 2);
				value = do_logicals( value, get_latch2 );
				EGA_plane23[offset] = (byte) value;
			}
			else
			{
				/*
				 * set/reset not enabled so here we go
				 */

				if( getVideorotate() > 0 )
					value = rotate( (byte) value, getVideorotate() );

				EGA_plane23[offset] = (byte) do_logicals( value, get_latch2 );
			}
		}
	}
}

VOID
ega_mode0_chn_b_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
	ULONG high_offset;
	UTINY value1, value2;

	note_entrance0("ega_mode0_chn_b_fill");

	/*
	 *	Starting on an odd address is inconvenient - go forward one
	 */

	if(( (ULONG) offset & 1) && count )
	{
		ega_mode0_chn_b_write( value, offset++ );
		count--;
	}

	/*
	 *	Ending on an even address is inconvenient - go back one
	 */

	if(( (ULONG) ( offset + count - 1 ) & 1) == 0 && count )
	{
		ega_mode0_chn_b_write( value, offset + count - 1 );
		count--;
	}

	high_offset = offset + count - 1;

	(*update_alg.mark_fill)( offset, high_offset );

	offset = (offset >> 1) << 2;
	high_offset = (high_offset >> 1) << 2;

	switch( getVideoplane_enable() & 0x3 )
	{
		case 0x1:	/* just plane 0 ie even addresses to be written */
			if (EGA_CPU.sr_enable & 1)
			{
				value = *((UTINY *) &EGA_CPU.sr_value);
			}
			else
			{
				value = rotate( (byte) value, getVideorotate() );
			}

			value = do_logicals( value, get_latch0 );
			fill_alternate_bytes((IS8 *)&EGA_plane01[offset],
					     (IS8 *)&EGA_plane01[high_offset],
					     (IS8)value);
			break;

		case 0x2:	/* just plane 1 ie odd addresses to be written */
			if (EGA_CPU.sr_enable & 2)
			{
				value = *((UTINY *) &EGA_CPU.sr_value + 1);
			}
			else
			{
				value = rotate( (byte) value, getVideorotate() );
			}

			value = do_logicals( value, get_latch1 );
			fill_alternate_bytes((IS8 *)&EGA_plane01[offset + 1],
					     (IS8 *)&EGA_plane01[high_offset],
					     (IS8)value);
			break;

		case 0x3:	/* sensible case is to have both chained planes write enabled */
			if (EGA_CPU.sr_enable & 1)
			{
				value1 = *((UTINY *) &EGA_CPU.sr_value);
			}
			else
			{
				value1 = rotate( (byte) value, getVideorotate() );
			}

			if (EGA_CPU.sr_enable & 2)
			{
				value2 = *((UTINY *) &EGA_CPU.sr_value + 1);
			}
			else
			{
				value2 = rotate((byte) value,getVideorotate());
			}

			value = value1 | value2 << 8;
			value = do_logicals( value, get_latch01 );
			value = (value << 8) | (value >> 8);

			fill_both_bytes( (IU16) value, (USHORT *)&EGA_plane01[offset], count >> 1 );
			break;
	}	/* end of switch on plane01 enabled */

	switch( getVideoplane_enable() & 0xc )
	{
		case 0x4:
			if( EGA_CPU.sr_enable & 4 )
			{
				value = *((UTINY *) &EGA_CPU.sr_value + 2);
			}
			else
			{
				value = rotate( (byte) value, getVideorotate() );
			}

			value = do_logicals( value, get_latch2 );
			fill_alternate_bytes((IS8 *)&EGA_plane23[offset],
					     (IS8 *)&EGA_plane23[high_offset],
					     (IS8)value );
			break;

		case 0x8:
			if( EGA_CPU.sr_enable & 8 )
			{
				value = *((UTINY *) &EGA_CPU.sr_value + 3);
			}
			else
			{
				value = rotate( (byte) value, getVideorotate() );
			}

			value = do_logicals( value, get_latch3 );
			fill_alternate_bytes((IS8 *)&EGA_plane23[offset + 1],
					     (IS8 *)&EGA_plane23[high_offset],
					     (IS8)value );
			break;

		case 0xc:
			if (EGA_CPU.sr_enable & 4)
			{
				value1 = *((UTINY *) &EGA_CPU.sr_value + 2);
			}
			else
			{
				value1 = rotate( (byte) value, getVideorotate() );
			}

			if (EGA_CPU.sr_enable & 8)
			{
				value2 = *((UTINY *) &EGA_CPU.sr_value + 3);
			}
			else
			{
				value2 = rotate( (byte) value, getVideorotate() );
			}

			value = value1 | value2 << 8;
			value = do_logicals( value, get_latch23 );
			value = (value << 8) | (value >> 8);

			fill_both_bytes( (IU16)value, (USHORT *)&EGA_plane01[offset], count >> 1 );
			break;
	}
}


VOID
ega_mode0_chn_w_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
	ULONG high_offset;
	UTINY value1, value2;
	IBOOL odd = FALSE;

	note_entrance0("ega_mode0_chn_w_fill");

	/*
	 *	Starting on an odd address is inconvenient - go forward one -
	 *	and take the even address write off the top as well.
	 */

	if(( (ULONG) offset & 1) && count )
	{
		odd = TRUE;
		ega_mode0_chn_b_write( value, offset++ );
		count -= 2;
		ega_mode0_chn_b_write( value >> 8, offset + count );
	}

	high_offset = offset + count - 1;

	/* the 3rd parameter is needed by GORE */
	(*update_alg.mark_wfill)( offset, high_offset, 0 );

	offset = (offset >> 1) << 2;
	high_offset = (high_offset >> 1) << 2;

	switch( getVideoplane_enable() & 0x3 )
	{
		case 0x1:	/* just plane 0 ie even addresses to be written */
			if (EGA_CPU.sr_enable & 1)
			{
				value1 = *((UTINY *) &EGA_CPU.sr_value);
			}
			else
			{
				value1 = (UTINY)(odd ? value >> 8 : value);

				if( getVideorotate() > 0 )
					value1 = rotate( value1, getVideorotate() );
			}

			value1 = (UTINY) do_logicals( value1, get_latch0 );
			fill_alternate_bytes((IS8 *)&EGA_plane01[offset],
					     (IS8 *)&EGA_plane01[high_offset],
					     (IS8)value1 );

			break;

		case 0x2:	/* just plane 1 ie odd addresses to be written */
			if (EGA_CPU.sr_enable & 2)
			{
				value1 = *((UTINY *) &EGA_CPU.sr_value + 1);
			}
			else
			{
				value1 = (UTINY)(odd ? value : value >> 8);

				if( getVideorotate() > 0 )
					value1 = rotate( value1, getVideorotate() );
			}

			value1 = (UTINY)(do_logicals( value1, get_latch1 ));
			fill_alternate_bytes((IS8 *)&EGA_plane01[offset + 1],
					     (IS8 *)&EGA_plane01[high_offset],
					     (IS8)value1 );

			break;

		case 0x3:	/* sensible case is to have both chained planes write enabled */
			if (EGA_CPU.sr_enable & 1)
			{
				value1 = *((UTINY *) &EGA_CPU.sr_value);
			}
			else
			{
				value1 = (UTINY)(odd ? value >> 8 : value);

				if( getVideorotate() > 0 )
					value1 = rotate( value1, getVideorotate() );
			}

			if (EGA_CPU.sr_enable & 2)
			{
				value2 = *((UTINY *) &EGA_CPU.sr_value + 1);
			}
			else
			{
				value2 = (UTINY)(odd ? value : value >> 8);

				if( getVideorotate() > 0 )
					value2 = rotate( value2, getVideorotate() );
			}

			value = value1 | value2 << 8;
			value = do_logicals( value, get_latch01 );

			fill_both_bytes( (IU16)value, (USHORT *)&EGA_plane01[offset], count >> 1 );

			break;

	}	/* end of switch on plane01 enabled */

	switch( getVideoplane_enable() & 0xc )
	{
		case 0x4:
			if( EGA_CPU.sr_enable & 4 )
			{
				value1 = *((UTINY *) &EGA_CPU.sr_value + 2);
			}
			else
			{
				value1 = (UTINY)(odd ? value >> 8 : value);

				if( getVideorotate() > 0 )
					value1 = rotate( value1, getVideorotate() );
			}

			value1 = (UTINY) do_logicals( value1, get_latch2 );
			fill_alternate_bytes((IS8 *)&EGA_plane23[offset],
					     (IS8 *)&EGA_plane23[high_offset],
					     (IS8)value1 );

			break;

		case 0x8:
			if( EGA_CPU.sr_enable & 8 )
			{
				value2 = *((UTINY *) &EGA_CPU.sr_value + 3);
			}
			else
			{
				value2 = (UTINY)(odd ? value : value >> 8);

				if( getVideorotate() > 0 )
					value2 = rotate( value2, getVideorotate() );
			}

			value2 = (UTINY) do_logicals( value2, get_latch3 );
			fill_alternate_bytes((IS8 *)&EGA_plane23[offset + 1],
					     (IS8 *)&EGA_plane23[high_offset],
					     (IS8)value2 );

			break;

		case 0xc:
			if (EGA_CPU.sr_enable & 4)
			{
				value1 = *((UTINY *) &EGA_CPU.sr_value + 2);
			}
			else
			{
				value1 = (UTINY)(odd ? value >> 8 : value);

				if( getVideorotate() > 0 )
					value1 = rotate( value1, getVideorotate() );
			}

			if (EGA_CPU.sr_enable & 8)
			{
				value2 = *((UTINY *) &EGA_CPU.sr_value + 3);
			}
			else
			{
				value2 = (UTINY)(odd ? value : value >> 8);

				if( getVideorotate() > 0 )
					value2 = rotate( value2, getVideorotate() );
			}

			value = value1 | value2 << 8;
			value = do_logicals( value, get_latch23 );

			fill_both_bytes( (IU16)value, (USHORT *)&EGA_plane01[offset], count >> 1 );

			break;
	}
}

LOCAL VOID
ega_mode0_chn_move_ram_src IFN5(UTINY *, eas, LONG, count, UTINY *, ead,
	UTINY *, EGA_plane, ULONG, plane )
{
	ULONG	offset;
	UTINY *src_offset;
	UTINY value;
	ULONG lsb, srcinc;

	src_offset = (UTINY *) eas;
	offset = (ULONG) ead;

	if(( offset & 1 ) != ( plane & 1 ))
	{
#ifdef BACK_M
		src_offset--;
#else
		src_offset++;
#endif
		offset++;
		count--;
	}

#ifdef BACK_M
	srcinc = -2;
#else
	srcinc = 2;
#endif

	lsb = offset & 1;
	offset = (offset >> 1) << 2;
	offset |= lsb;

	/*
	 * check if set/reset function enable for this plane
	 */

	if( EGA_CPU.sr_enable & ( 1 << plane ))
	{
		value = *((UTINY *) &EGA_CPU.sr_value + plane );

		while( count > 0 )
		{
			count -= 2;

			EGA_plane[offset] = (byte) do_logicals( value, get_latch(plane) );
			offset += 4;
		}
	}
	else
	{
		while( count > 0 )
		{
			value = *src_offset;
			src_offset += srcinc;
			count -= 2;

			/*
			 * set/reset not enabled so here we go
			 */

			if( getVideorotate() > 0 )
				value = rotate( value, getVideorotate() );

			value = (UTINY) do_logicals( value, get_latch(plane) );
			EGA_plane[offset] = value;
			offset += 4;
		}
	}
}

LOCAL VOID
ega_mode0_chn_move_vid_src IFN7(UTINY *, eas, LONG, count, UTINY *, ead,
	UTINY *, EGA_plane, UTINY *, scratch, ULONG, plane, ULONG, w )
{
	ULONG	offset;
	ULONG src_offset;
	UTINY *source;
	UTINY value;
	UTINY valsrc;
	ULONG lsb, inc, srcinc;

	offset = (ULONG ) ead;

	if(( offset & 1 ) != ( plane & 1 ))
	{
		eas++;
#ifdef BACK_M
		scratch--;
#else
		scratch++;
#endif
		offset++;
		count--;
	}

	src_offset = (ULONG) eas;

#ifdef BACK_M
	srcinc = -2;
#else
	srcinc = 2;
#endif
	inc = 4;

	lsb = offset & 1;
	offset = (offset >> 1) << 2;
	offset |= lsb;

	lsb = src_offset & 1;
	src_offset = (src_offset >> 1) << 2;
	src_offset |= lsb;

	source = &EGA_plane[src_offset] + (w << 2);

	/*
	 * check if set/reset function enable for this plane
	 */

	if( EGA_CPU.sr_enable & ( 1 << plane ))
	{
		value = *((UTINY *) &EGA_CPU.sr_value + plane );

		while( count > 0 )
		{
			count -= 2;
			valsrc = *source;
			source += inc;
			EGA_plane[offset] = (byte) do_logicals( value, valsrc );
			offset += inc;
		}
	}
	else
	{
		while( count > 0 )
		{
			count -= 2;

			value = *(UTINY *) scratch;
			scratch += srcinc;

			valsrc = *source;
			source += inc;

			/*
			 * set/reset not enabled so here we go
			 */

			if( getVideorotate() > 0 )
				value = rotate( value, getVideorotate() );

			value = (UTINY) do_logicals( value, valsrc );
			EGA_plane[offset] = value;
			offset += inc;
		}
	}
}

#pragma warning(disable:4146)       // unary minus operator applied to unsigned type

VOID
ega_mode0_chn_move IFN6(UTINY, w, UTINY *, ead, UTINY *, eas, ULONG, count,
	ULONG, src_flag, IBOOL, forwards )
{
	UTINY *scratch;
	IMPORT VOID (*string_read_ptr)();

	note_entrance0("ega_mode0_chn_move");

	if( src_flag == 1 )
	{
		/*
		 *	Source is in EGA, latches will change with each byte moved. We
		 *	restore CPU's view of source in regen, and use it to update planes
		 *	with the aid of the SAS scratch area.
		 */

#ifdef BACK_M
		scratch = getVideoscratch() + 0x10000 - 1;
#else
		scratch = getVideoscratch();
#endif

		if( !forwards )
		{
			eas += - count + 1 + w;
			ead += - count + 1 + w;
		}

		(*string_read_ptr)( scratch, eas, count );

		if( getVideoplane_enable() & 1 )
			ega_mode0_chn_move_vid_src( eas, count, ead, EGA_plane01, scratch, 0, 0 );

		if( getVideoplane_enable() & 2 )
			ega_mode0_chn_move_vid_src( eas, count, ead, EGA_plane01, scratch, 1, w );

		if( getVideoplane_enable() & 4 )
			ega_mode0_chn_move_vid_src( eas, count, ead, EGA_plane23, scratch, 2, 0 );

		if( getVideoplane_enable() & 8 )
			ega_mode0_chn_move_vid_src( eas, count, ead, EGA_plane23, scratch, 3, w );
	}
	else
	{
		if( !forwards )
		{
#ifdef BACK_M
			eas += count - 1 - w;
#else
			eas += - count + 1 + w;
#endif
			ead += - count + 1 + w;
		}

		if( getVideoplane_enable() & 1 )
			ega_mode0_chn_move_ram_src( eas, count, ead, EGA_plane01, 0 );

		if( getVideoplane_enable() & 2 )
			ega_mode0_chn_move_ram_src( eas, count, ead, EGA_plane01, 1 );

		if( getVideoplane_enable() & 4 )
			ega_mode0_chn_move_ram_src( eas, count, ead, EGA_plane23, 2 );

		if( getVideoplane_enable() & 8 )
			ega_mode0_chn_move_ram_src( eas, count, ead, EGA_plane23, 3 );
	}

	(*update_alg.mark_string)( (ULONG) ead, (ULONG) ead + count );
}


VOID
ega_mode0_chn_b_move IFN4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag)
{
	ega_mode0_chn_move( 0, (UTINY *)ead, (UTINY *)eas, count, src_flag, getDF() ? FALSE : TRUE);
}

VOID
ega_mode0_chn_b_move_fwd IFN4(ULONG, ead, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_mode0_chn_move( 0, (UTINY *)ead, (UTINY *)eas, count, src_flag, TRUE );
}

VOID
ega_mode0_chn_b_move_bwd IFN4(ULONG, ead, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_mode0_chn_move( 0, (UTINY *)ead, (UTINY *)eas, count, src_flag, FALSE );
}

VOID
ega_mode0_chn_w_move IFN4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag)
{
	ega_mode0_chn_move(1, (UTINY *)ead, (UTINY *)eas, count << 1, src_flag, getDF() ? FALSE : TRUE);
}

VOID
ega_mode0_chn_w_move_fwd IFN4(ULONG, ead, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_mode0_chn_move(1,(UTINY *)ead, (UTINY *)eas, count << 1, src_flag, TRUE );
}

VOID
ega_mode0_chn_w_move_bwd IFN4(ULONG, ead, ULONG, eas, ULONG, count,
	ULONG, src_flag )
{
	ega_mode0_chn_move(1,(UTINY *)ead, (UTINY *)eas, count << 1, src_flag, FALSE );
}

VOID
ega_mode0_chn_w_write IFN2(ULONG, value, ULONG, offset )
{
   note_entrance0("ega_mode0_chn_w_write");

   ega_mode0_chn_b_write( value, offset );
   ega_mode0_chn_b_write( value >> 8, offset + 1 );
}

#endif  //NEC_98
#endif

#endif	/* !(NTVDM && MONITOR) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\ega_writ.c ===
#include "insignia.h"
#include "host_def.h"

#if !(defined(NTVDM) && defined(MONITOR))

/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DOCUMENT 		: name and number

RELATED DOCS	: include all relevant references

DESIGNER		: J.Roper

REVISION HISTORY	:
First version		: 7/22/88 W.Gulland

SUBMODULE NAME		: ega_write		

SOURCE FILE NAME	: ega_write.c

PURPOSE			: control the way writes to EGA memory is emulated.
			  This module looks at the state of the EGA when it is changed
			  via writes to the EGA registers, and works out what to do about it.
		
		
SccsID = @(#)ega_write.c	1.40 12/15/95 Copyright Insignia Solutions Ltd.

/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]						*/

/* [3.1.1 #INCLUDES]                                                    */


#include <stdio.h>
#include TypesH
#include FCntlH

#ifdef EGG
#include	"xt.h"
#include	CpuH
#include	"debug.h"
#include	"gmi.h"
#include	"gvi.h"
#include	"egacpu.h"
#include	"egaports.h"
#include	"cpu_vid.h"
#include	"video.h"


/* [3.1.2 DECLARATIONS]                                                 */
#if defined(EGA_DUMP) || defined(EGA_STAT)
extern WRT_POINTERS dump_writes;
#endif

extern WRT_POINTERS mode0_gen_handlers, mode0_copy_handlers;
extern WRT_POINTERS mode1_handlers, mode2_handlers;

/* [3.2 INTERMODULE EXPORTS]						*/

/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]						*/
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_EGA.seg"
#endif

#ifndef REAL_VGA

#ifdef V7VGA
IMPORT UTINY fg_bg_control;
GLOBAL UTINY Last_v7_fg_bg;			/* used by {ev}ga_mask_register_changed() */
#endif

#ifndef CPU_40_STYLE	/* EVID without introducing EVID define */

WRT_POINTERS *mode_chain_handler_table[] =
{
	&mode_table.nch.mode_0[0],
	&mode_table.nch.mode_1[0],
	&mode_table.nch.mode_2[0],
#ifdef VGG
	&mode_table.nch.mode_3[0],
#endif

	&mode_table.nch.mode_0[0],		/* This should be chain 2 eventually */
	&mode_table.nch.mode_1[0],		/* This should be chain 2 eventually */
	&mode_table.nch.mode_2[0],		/* This should be chain 2 eventually */
#ifdef VGG
	&mode_table.nch.mode_3[0],		/* This should be chain 2 eventually */
#endif

#ifdef VGG
	&mode_table.ch4.mode_0[0],
	&mode_table.ch4.mode_1[0],
	&mode_table.ch4.mode_2[0],
	&mode_table.ch4.mode_3[0],
#endif /* VGG */
};
	
#ifndef EGATEST
IMPORT VOID glue_b_write IPT2(UTINY *, addr, ULONG, val);
IMPORT VOID glue_w_write IPT2(UTINY *, addr, ULONG, val);
IMPORT VOID glue_b_fill IPT3(UTINY *, laddr, UTINY *, haddr, ULONG, val);
IMPORT VOID glue_w_fill IPT3(UTINY *, laddr, UTINY *, haddr, ULONG, val);
IMPORT VOID glue_b_move IPT4(UTINY *, laddr, UTINY *, haddr, UTINY *, src, UTINY, src_type);
IMPORT VOID glue_w_move IPT3(UTINY *, laddr, UTINY *, haddr, UTINY *, src);

#ifndef GISP_CPU
#ifdef A3CPU
#ifdef C_VID
IMPORT VOID _glue_b_write IPT2(UTINY *, addr, ULONG, val);
IMPORT VOID _glue_w_write IPT2(UTINY *, addr, ULONG, val);
IMPORT VOID _glue_b_fill IPT3(UTINY *, laddr, UTINY *, haddr, ULONG, val);
IMPORT VOID _glue_w_fill IPT3(UTINY *, laddr, UTINY *, haddr, ULONG, val);
IMPORT VOID _glue_b_fwd_move IPT0();
IMPORT VOID _glue_b_bwd_move IPT0();
IMPORT VOID _glue_w_fwd_move IPT0();
IMPORT VOID _glue_w_bwd_move IPT0();

GLOBAL WRT_POINTERS Glue_writes =
{
	_glue_b_write,
	_glue_w_write

#ifndef	NO_STRING_OPERATIONS
	,
	_glue_b_fill,
	_glue_w_fill,
	_glue_b_fwd_move,
	_glue_b_bwd_move,
	_glue_w_fwd_move,
	_glue_w_bwd_move

#endif	/* NO_STRING_OPERATIONS */

};

GLOBAL WRT_POINTERS C_vid_writes;
#endif /* C_VID */
#else

#ifdef A_VID
IMPORT VOID _glue_b_write();
IMPORT VOID _glue_w_write();
IMPORT VOID _glue_b_fill();
IMPORT VOID _glue_w_fill();
IMPORT VOID _glue_b_move();
IMPORT VOID _glue_w_move();

GLOBAL MEM_HANDLERS Glue_writes =
{
	_glue_b_write,
	_glue_w_write,
	_glue_b_fill,
	_glue_w_fill,
	_glue_b_move,
	_glue_w_move,
};

GLOBAL WRT_POINTERS A_vid_writes;

#else

GLOBAL MEM_HANDLERS Glue_writes =
{
	glue_b_write,
	glue_w_write,
	glue_b_fill,
	glue_w_fill,
	glue_b_move,
	glue_w_move,
};

GLOBAL WRT_POINTERS C_vid_writes;
#endif /* C_VID */
#endif /* A3CPU */
#endif /* GISP_CPU */
#endif /* EGATEST */

IMPORT VOID _simple_b_write();
IMPORT VOID _simple_w_write();
IMPORT VOID _simple_b_fill();
IMPORT VOID _simple_w_fill();
IMPORT VOID _simple_bf_move();
IMPORT VOID _simple_wf_move();
IMPORT VOID _simple_bb_move();
IMPORT VOID _simple_wb_move();

WRT_POINTERS simple_writes =
{
	_simple_b_write,
	_simple_w_write
#ifndef	NO_STRING_OPERATIONS
	,
	_simple_b_fill,
	_simple_w_fill,
	_simple_bf_move,
	_simple_bb_move,
	_simple_wf_move,
	_simple_wb_move

#endif	/* NO_STRING_OPERATIONS */
};

IMPORT VOID _dt0_bw_nch();
IMPORT VOID _dt0_ww_nch();
IMPORT VOID _dt0_bf_nch();
IMPORT VOID _dt0_wf_nch();
IMPORT VOID _vid_md0_bfm_0_8();
IMPORT VOID _vid_md0_bbm_0_8();
IMPORT VOID _vid_md0_wfm_0_8();
IMPORT VOID _vid_md0_wbm_0_8();

IMPORT VOID _dt2_bw_nch();
IMPORT VOID _dt2_ww_nch();
IMPORT VOID _dt2_bf_nch();
IMPORT VOID _dt2_wf_nch();
IMPORT VOID _vid_md2_bfm_0_8();
IMPORT VOID _vid_md2_bbm_0_8();
IMPORT VOID _vid_md2_wfm_0_8();
IMPORT VOID _vid_md2_wbm_0_8();

IMPORT VOID _dt3_bw_nch();
IMPORT VOID _dt3_ww_nch();
IMPORT VOID _dt3_bf_nch();
IMPORT VOID _dt3_wf_nch();
IMPORT VOID _vid_md3_bfm_0_8();
IMPORT VOID _vid_md3_bbm_0_8();
IMPORT VOID _vid_md3_wfm_0_8();
IMPORT VOID _vid_md3_wbm_0_8();

WRT_POINTERS dth_md0_writes =
{
	_dt0_bw_nch,
	_dt0_ww_nch

#ifndef	NO_STRING_OPERATIONS
	,
	_dt0_bf_nch,
	_dt0_wf_nch,
	_vid_md0_bfm_0_8,
	_vid_md0_bbm_0_8,
	_vid_md0_wfm_0_8,
	_vid_md0_wbm_0_8

#endif	/* NO_STRING_OPERATIONS */

};

WRT_POINTERS dth_md2_writes =
{
	_dt2_bw_nch,
	_dt2_ww_nch

#ifndef	NO_STRING_OPERATIONS
	,
	_dt2_bf_nch,
	_dt2_wf_nch,
	_vid_md2_bfm_0_8,
	_vid_md2_bbm_0_8,
	_vid_md2_wfm_0_8,
	_vid_md2_wbm_0_8
#endif	/* NO_STRING_OPERATIONS */

};

WRT_POINTERS dth_md3_writes =
{
	_dt3_bw_nch,
	_dt3_ww_nch

#ifndef	NO_STRING_OPERATIONS
	,
	_dt3_bf_nch,
	_dt3_wf_nch,
	_vid_md3_bfm_0_8,
	_vid_md3_bbm_0_8,
	_vid_md3_wfm_0_8,
	_vid_md3_wbm_0_8

#endif	/* NO_STRING_OPERATIONS */

};

#else	/* CPU_40_STYLE - EVID */
WRT_POINTERS *mode_chain_handler_table[] = { 0 };
#ifdef C_VID

/* C_Evid glue */
extern void  write_byte_ev_glue IPT2(IU32, eaOff, IU8, eaVal);
extern void  write_word_ev_glue IPT2(IU32, eaOff, IU16, eaVal);
extern void  fill_byte_ev_glue IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void  fill_word_ev_glue IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void  move_byte_fwd_ev_glue IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void  move_word_fwd_ev_glue IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
MEM_HANDLERS Glue_writes =
{
	write_byte_ev_glue,
	write_word_ev_glue,
	fill_byte_ev_glue,
	fill_word_ev_glue,
	move_byte_fwd_ev_glue,
	move_word_fwd_ev_glue,
};
#else	/* C_VID */
/* no glue required */
MEM_HANDLERS Glue_writes = { 0, 0, 0, 0, 0, 0 };
#endif	/* CVID */
WRT_POINTERS dth_md0_writes;
WRT_POINTERS dth_md2_writes;
WRT_POINTERS simple_writes;
WRT_POINTERS dth_md3_writes;
#endif	/* CPU_40_STYLE - EVID */

IMPORT VOID ega_copy_b_write(ULONG, ULONG);
IMPORT VOID ega_mode0_chn_b_write(ULONG, ULONG);
IMPORT VOID ega_mode1_chn_b_write(ULONG, ULONG);
IMPORT VOID ega_mode2_chn_b_write(ULONG, ULONG);

IMPORT VOID ega_copy_w_write(ULONG, ULONG);
IMPORT VOID ega_mode0_chn_w_write(ULONG, ULONG);
IMPORT VOID ega_mode1_chn_w_write(ULONG, ULONG);
IMPORT VOID ega_mode2_chn_w_write(ULONG, ULONG);

/* Handy array to extract all 4 plane values in one go. */

ULONG sr_lookup[16] =
{
#ifdef LITTLEND
	0x00000000,0x000000ff,0x0000ff00,0x0000ffff,
	0x00ff0000,0x00ff00ff,0x00ffff00,0x00ffffff,
	0xff000000,0xff0000ff,0xff00ff00,0xff00ffff,
	0xffff0000,0xffff00ff,0xffffff00,0xffffffff
#endif
#ifdef BIGEND
	0x00000000,0xff000000,0x00ff0000,0xffff0000,
	0x0000ff00,0xff00ff00,0x00ffff00,0xffffff00,
	0x000000ff,0xff0000ff,0x00ff00ff,0xffff00ff,
	0x0000ffff,0xff00ffff,0x00ffffff,0xffffffff
#endif
};

GLOBAL VOID
stub IFN0()
{
	/*
	 * For VGA write modes we don't do because they represent
	 * unlikely combinations of registers.
	 */
}

GLOBAL ULONG calc_data_xor;
GLOBAL ULONG calc_latch_xor;

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_GRAPHICS.seg"
#endif

#if !(defined(NTVDM) && defined(MONITOR))
GLOBAL VOID
Glue_set_vid_wrt_ptrs IFN1(WRT_POINTERS *, handler )
{

#ifndef CPU_40_STYLE	/* EVID */
#ifndef GISP_CPU
#ifdef A3CPU
#ifdef C_VID

	C_vid_writes.b_write = handler->b_write;
	C_vid_writes.w_write = handler->w_write;
	C_vid_writes.b_fill = handler->b_fill;
	C_vid_writes.w_fill = handler->w_fill;
	C_vid_writes.b_fwd_move = handler->b_fwd_move;
	C_vid_writes.b_bwd_move = handler->b_bwd_move;
	C_vid_writes.w_fwd_move = handler->w_fwd_move;
	C_vid_writes.w_bwd_move = handler->w_bwd_move;

#else
	UNUSED(handler);
#endif /* C_VID */
#else
#ifdef C_VID

	C_vid_writes.b_write = handler->b_write;
	C_vid_writes.w_write = handler->w_write;

#ifndef	NO_STRING_OPERATIONS

	C_vid_writes.b_fill = handler->b_fill;
	C_vid_writes.w_fill = handler->w_fill;
	C_vid_writes.b_fwd_move = handler->b_fwd_move;
	C_vid_writes.b_bwd_move = handler->b_bwd_move;
	C_vid_writes.w_fwd_move = handler->w_fwd_move;
	C_vid_writes.w_bwd_move = handler->w_bwd_move;

#endif	/* NO_STRING_OPERATIONS */

#else

	A_vid_writes = *handler;

#if	0
	A_vid_writes.b_write = handler->b_write;
	A_vid_writes.w_write = handler->w_write;

#ifndef	NO_STRING_OPERATIONS

	A_vid_writes.b_fill = handler->b_fill;
	A_vid_writes.w_fill = handler->w_fill;
	A_vid_writes.b_fwd_move = handler->b_fwd_move;
	A_vid_writes.b_bwd_move = handler->b_bwd_move;
	A_vid_writes.w_fwd_move = handler->w_fwd_move;
	A_vid_writes.w_bwd_move = handler->w_bwd_move;

#endif	/* NO_STRING_OPERATIONS */
#endif	/* 0 */

#endif /* C_VID */
#endif /* A3CPU */
#endif /* GISP_CPU */
#endif 	/* CPU_40_STYLE - EVID */
}
#endif /* !(NTVDM && MONITOR) */

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_EGA.seg"
#endif

/*  Initialize the write module */

VOID
ega_write_init IFN0()
{
#ifndef NEC_98
	WRT_POINTERS *handler;

	note_entrance0("ega_write_init");

	EGA_CPU.saved_state = 0;
	EGA_CPU.write_mode = 0;
	EGA_CPU.chain = UNCHAINED;
	setVideochain(EGA_CPU.chain);
	setVideowrmode(EGA_CPU.write_mode);
	setVideowrstate(0);

	handler = &mode_chain_handler_table[0][0];

#ifdef CPU_40_STYLE
	/* ensure correct write mode in place for initial font writes */
	SetWritePointers();
#endif

#ifdef	JOKER

	Glue_set_vid_wrt_ptrs(handler);

#else	/* not JOKER */

#if defined(EGA_DUMP) || defined(EGA_STAT)
	dump_writes = handler;
#else
#ifdef EGATEST
	gmi_define_mem(VIDEO,(*handler));
#else
#ifndef GISP_CPU
#ifdef A3CPU
#ifdef C_VID
	Cpu_set_vid_wrt_ptrs( &Glue_writes );	
	Glue_set_vid_wrt_ptrs( handler );
#else
	Cpu_set_vid_wrt_ptrs( handler );	
#endif /* C_VID */
#else
	gmi_define_mem(VIDEO,&Glue_writes);
	Glue_set_vid_wrt_ptrs( handler );
#endif /* A3CPU */
#endif /* GISP_CPU */
#endif /* EGATEST */
#endif /* EGA_DUMP || EGA_STAT */
#endif /* JOKER */

	ega_write_routines_update(WRITE_MODE);
	ega_write_routines_update(RAM_MOVED);
	ega_write_routines_update(RAM_ENABLED);
	ega_write_routines_update(SET_RESET);
	ega_write_routines_update(ENABLE_SET_RESET);
	ega_write_routines_update(FUNCTION);
#endif  //NEC_98
}

VOID
ega_write_term IFN0()
{
#ifndef NEC_98
	/*
	 * ensure that if you are an EGA and then change to a VGA (or vice
	 * versa) the write mode will be changed by the new adaptor. Otherwise
	 * this gives a 'drunken' font
	 */

	EGA_CPU.write_mode = 0;
	EGA_CPU.ega_state.mode_0.lookup =
				(EGA_CPU.ega_state.mode_0.lookup == 0) ? 1 : 0;
	setVideowrmode(EGA_CPU.write_mode);

	ega_write_routines_update(WRITE_MODE);
#endif  //NEC_98
}


/* analyze the write state, and update the routines if necesary */

VOID
ega_write_routines_update IFN1(CHANGE_TYPE, reason )
{
#ifndef NEC_98
	ULONG state;
	ULONG mode_and_chain;
	WRT_POINTERS *handler;
#ifndef PROD
	LOCAL WRT_POINTERS *last_handler;
#endif

	note_entrance1("ega_write_routines_update(%d)",reason);

	switch( reason )
	{
		case FUNCTION:
			switch (write_state.func)
			{
				case 0:	/* Assign */
					setVideodata_and_mask(0xffffffff);
					setVideodata_xor_mask(~(getVideobit_prot_mask()));
					setVideolatch_xor_mask(getVideobit_prot_mask());
					EGA_CPU.calc_data_xor = 0xffffffff;
					EGA_CPU.calc_latch_xor = 0xffffffff;
					break;

				case 1:	/* AND */
					setVideodata_and_mask(0xffffffff);
					setVideodata_xor_mask(~(getVideobit_prot_mask()));
					setVideolatch_xor_mask(0);
					EGA_CPU.calc_data_xor = 0xffffffff;
					EGA_CPU.calc_latch_xor = 0x00000000;
					break;

				case 2:	/* OR */
					setVideodata_and_mask(0);
					setVideodata_xor_mask(0xffffffff);
					setVideolatch_xor_mask(
						getVideobit_prot_mask());
					EGA_CPU.calc_data_xor = 0x00000000;
					EGA_CPU.calc_latch_xor = 0xffffffff;
					break;

				case 3:	/* XOR */
					setVideodata_and_mask(0xffffffff);
					setVideodata_xor_mask(0xffffffff);
					setVideolatch_xor_mask(
						getVideobit_prot_mask());
					EGA_CPU.calc_data_xor = 0x00000000;
					EGA_CPU.calc_latch_xor = 0xffffffff;
					break;
			}

			setVideocalc_data_xor(EGA_CPU.calc_data_xor);
			setVideocalc_latch_xor(EGA_CPU.calc_latch_xor);
			break;

		case WRITE_MODE:
			/* write mode 3 has set/reset enabled for all planes
			 * so recalulate the mask ignoring the sr_enable register
			 * otherwise set the mask in case mode 3 last time.
			 */
			if( EGA_CPU.write_mode == 3) {
				setVideosr_nmask(0);
				setVideosr_masked_val(sr_lookup[EGA_CPU.set_reset]);
			} else {
				setVideosr_nmask(~sr_lookup[EGA_CPU.sr_enable]);
				setVideosr_masked_val(sr_lookup[EGA_CPU.set_reset & EGA_CPU.sr_enable]);
			}
			break;

		case SET_RESET:
			EGA_CPU.sr_value= sr_lookup[EGA_CPU.set_reset];
			if( EGA_CPU.write_mode == 3) {
				setVideosr_masked_val(sr_lookup[EGA_CPU.set_reset]);
			} else {
				setVideosr_masked_val(sr_lookup[EGA_CPU.set_reset & EGA_CPU.sr_enable]);
			}
			break;

		case ENABLE_SET_RESET:
			if( EGA_CPU.write_mode == 3) {
				setVideosr_nmask(0);
				setVideosr_masked_val(sr_lookup[EGA_CPU.set_reset]);
			} else {
				setVideosr_nmask(~sr_lookup[EGA_CPU.sr_enable]);
				setVideosr_masked_val(sr_lookup[EGA_CPU.set_reset & EGA_CPU.sr_enable]);
			}
			break;

		case PLANES_ENABLED:
			if (EGA_CPU.chain == CHAIN2)
			{
				if( getVideoplane_enable() & 0xc )
				{
					setVideorplane(EGA_plane23);
					setVideowplane(EGA_plane23);
				}
				else
				{
					setVideorplane(EGA_plane01);
					setVideowplane(EGA_plane01);
				}
			}
			break;

		case CHAINED:
			switch( EGA_CPU.chain )
			{
				case UNCHAINED:
				case CHAIN4:
					update_banking();
					break;

				case CHAIN2:
					if( getVideoplane_enable() & 0xc )
					{
						setVideorplane(EGA_plane23);
						setVideowplane(EGA_plane23);
					}
					else
					{
						setVideorplane(EGA_plane01);
						setVideowplane(EGA_plane01);
					}
					break;
			}

			break;

		case RAM_MOVED:
		case RAM_ENABLED:
		case BIT_PROT:
			/* No action required */
			break;
				
/*
 * Rotates are only partially supported in Avid and Cvid.
 * Mode 0 unchained byte writes are supported.  Word writes are also
 * supported in this case, as they use the byte write routines.
 *
 * Manage Your Money is the only application currently known to use rotates,
 * as of 22 Jan 1993.
 */
		case ROTATION:
			if (getVideorotate() > 0)
			{
#ifdef CPU_40_STYLE
				/* Write pointer change required but probably
				 * no state change otherwise.
				 */
				SetWritePointers();
#endif
				always_trace3("Possible unsupported data rotate mode %d chain %d rotate by %d",
				               EGA_CPU.write_mode,
					       EGA_CPU.chain, getVideorotate());
			}
			break;
				
		default:
			assert0( NO, "Bad reason in ega_write_routines_update" );
			break;
	}

	/*
	 * Now select the right set of write routines according to the current state.
	 */

	switch( EGA_CPU.write_mode )
	{
		case 0:
			state = EGA_CPU.ega_state.mode_0.lookup;
			break;

		case 1:
			state = EGA_CPU.ega_state.mode_1.lookup;
			break;

		case 2:
			state = EGA_CPU.ega_state.mode_2.lookup;
			break;

#ifdef VGG
		case 3:
			state = EGA_CPU.ega_state.mode_3.lookup;
			break;
#endif /* VGG */

		default:
			assert1( NO, "Bad write mode %d\n", EGA_CPU.write_mode );
			break;
	}

#ifdef VGG
	mode_and_chain = (EGA_CPU.chain << 2) + EGA_CPU.write_mode;
#else
	mode_and_chain = (EGA_CPU.chain * 3) + EGA_CPU.write_mode;
#endif /* VGG */

	if(( EGA_CPU.saved_mode_chain != mode_and_chain )
		|| ( EGA_CPU.saved_state != state )
#ifdef V7VGA
		|| ( Last_v7_fg_bg != fg_bg_control)
#endif /* V7VGA */
		)
	{
		setVideowrmode(EGA_CPU.write_mode);	/* reset for 'copy case' below */

		if( EGA_CPU.chain == CHAIN2 )
			switch (EGA_CPU.write_mode)
			{
				case 0:
					if( state == 0 )	/* basic text */
					{
						handler = &mode0_copy_handlers;
#ifdef CPU_40_STYLE
						setVideowrmode(4);	/* indicate 'copy case' */
#endif	/* CPU_40_STYLE */
						bios_ch2_byte_wrt_fn = ega_copy_b_write;
						bios_ch2_word_wrt_fn = ega_copy_w_write;
					}
					else
					{
						handler = &mode0_gen_handlers;
						bios_ch2_byte_wrt_fn = ega_mode0_chn_b_write;
						bios_ch2_word_wrt_fn = ega_mode0_chn_w_write;
					}
					break;

				case 1:
					handler = &mode1_handlers;
					bios_ch2_byte_wrt_fn = ega_mode1_chn_b_write;
					bios_ch2_word_wrt_fn = ega_mode1_chn_w_write;
					break;

				case 2:
				case 3:	/* We don't support mode 3, chain 2 - JS */
					handler = &mode2_handlers;
					bios_ch2_byte_wrt_fn = ega_mode2_chn_b_write;
					bios_ch2_word_wrt_fn = ega_mode2_chn_w_write;
					break;
			}
		else
		{
#ifdef	V7VGA
			/*
			 *	Is it the V7VGA foreground dithering extension ?
			 */

			if( fg_bg_control & 0x8 )
			{
				setVideodither(1);	/* enable Evid dither fns */
				switch( EGA_CPU.write_mode )
				{
					case 0:
						handler = &dth_md0_writes;
						break;
					
					case 1:

						/*
						 *	No fg dither variant for write mode 1
						 */

						handler = &mode_chain_handler_table[mode_and_chain][state];
						break;
					
					case 2:
						handler = &dth_md2_writes;
						break;
					
					case 3:
						handler = &dth_md3_writes;
						break;
				}
			}
			else
#endif	/* V7VGA */
				setVideodither(0);	/* disable Evid dither fns */

				handler = &mode_chain_handler_table[mode_and_chain][state];
		}

#ifdef CPU_40_STYLE
		SetWritePointers();
#else  /* CPU_40_STYLE */

#if defined(EGA_DUMP) || defined(EGA_STAT)
		dump_writes = handler;
#else
		/* Tell the glue code about the new write routines */

#ifdef EGATEST
		gmi_redefine_mem(VIDEO,(*handler));
#else
#ifndef GISP_CPU
#ifdef A3CPU
#ifdef C_VID
		Glue_set_vid_wrt_ptrs( handler );
#else
		Cpu_set_vid_wrt_ptrs( handler );	
#endif /* C_VID */
#else
		Glue_set_vid_wrt_ptrs( handler );
#endif /* A3CPU */
#endif /* GISP_CPU */
#endif /* EGATEST */
#endif

#endif	/* CPU_40_STYLE */

#ifndef PROD
		last_handler = handler;
#endif

		set_mark_funcs();

		EGA_CPU.saved_state = state;
		EGA_CPU.saved_mode_chain = mode_and_chain;
#ifdef V7VGA
		Last_v7_fg_bg = fg_bg_control;
#endif
	}
#endif  //NEC_98
}
#endif /* REAL VGA */
#endif /* EGG */

#endif	/* !(NTVDM && MONITOR) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\ega_vide.c ===
#if !defined(i386) && defined(JAPAN)
#include <windows.h>
#endif
#include "insignia.h"
#include "host_def.h"
/*                      INSIGNIA (SUB)MODULE SPECIFICATION
                        -----------------------------


        THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
        CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
        NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
        AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DOCUMENT                : EGA BIOS

RELATED DOCS            : IBM EGA Technical reference.

DESIGNER                : William Gulland

REVISION HISTORY        :
First version           : 17/8/88 William

SUBMODULE NAME          : ega_video

PURPOSE                 :  Emulate IBM EGA BIOS.


SccsID[]="@(#)ega_video.c       1.70 07/04/95 Copyright Insignia Solutions Ltd.";


[1.INTERMODULE INTERFACE SPECIFICATION]


[1.1    INTERMODULE EXPORTS]

        PROCEDURES() :  give procedure type,name, and argument types
                        void ega_video_init()
                        void ega_video_io()

        DATA         :  give type and name

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]

        STRUCTURES/TYPEDEFS/ENUMS:

-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
     (not o/s objects or standard libs)

        PROCEDURES() :  give name, and source module name

        DATA         :  give name, and source module name

-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

DATA OBJECTS      :     specify in following procedure descriptions
                        how these are accessed (read/modified)

[1.4.2 EXPORTED OBJECTS]
=========================================================================
PROCEDURE         :     ega_video_init()

PURPOSE           :     Initialize EGA-specific bits of the video BIOS.

PARAMETERS         None

ACCESS            :     called from video_init if EGA installed.

DESCRIPTION       :     describe what (not how) function does

                        Initializes ega_info & ega_info3.

=========================================================================

/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]                                               */

/* [3.1.1 #INCLUDES]                                                    */


#ifdef EGG
#include <stdio.h>
#include TypesH
#include FCntlH

#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "gmi.h"
#include "gvi.h"
#include "bios.h"
#include "error.h"
#include "config.h"
#include "equip.h"
#include "egacpu.h"
#include "egaports.h"
#include "gfx_upd.h"
#include "egagraph.h"
#include "egaread.h"
#include "video.h"
#include "egavideo.h"
#include "vgaports.h"
#include "debug.h"
#include "timer.h"
#include "host_gfx.h"
#include "idetect.h"
#ifndef PROD
#include "trace.h"
#endif
#include "host.h"

#ifdef  GISP_SVGA
#include HostHwVgaH
#include "hwvga.h"
#endif          /* GISP_SVGA */
#if defined(JAPAN) || defined(KOREA)
#include <conapi.h>
#endif // JAPAN || KOREA

/* [3.1.2 DECLARATIONS]                                                 */

GLOBAL IU8 Video_mode;  /* Shadow copy of BIOS video mode */
GLOBAL IU8 Currently_emulated_video_mode = 0;   /* Holds last video mode
                                                 * set through bios */

#if defined(NTVDM) && defined(X86GFX)
/* Loads font from PC's BIOS into video memory */
IMPORT void loadNativeBIOSfont IPT1( int, lines );
#endif

#ifdef NTVDM
IMPORT int soft_reset;
IMPORT BOOL VDMForWOW;
IMPORT BOOL WowModeInitialized;
#ifndef X86GFX
IMPORT void mouse_video_mode_changed(int new_video_mode);
#endif
#endif  /* NTVDM */

#ifdef CPU_40_STYLE
GLOBAL IBOOL forceVideoRmSemantics = FALSE;
#endif
#ifdef JAPAN
// mskkbug #3167 works2.5 character corrupted 11/8/93 yasuho
// generate single byte charset for JAPAN
IMPORT GLOBAL void GenerateBitmap();
#endif // JAPAN

/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]                                                */

#ifndef NEC_98
#ifdef ANSI
GLOBAL void ega_set_mode(void),ega_char_gen(void);
static void ega_set_palette(void),ega_alt_sel(void);
GLOBAL void ega_set_cursor_mode(void);
static void ega_emul_set_palette(void);
#else
GLOBAL void ega_set_mode(),ega_char_gen();
static void ega_set_palette(),ega_alt_sel();
GLOBAL void ega_set_cursor_mode();
static void ega_emul_set_palette();
#endif /* ANSI */
static void (*ega_video_func[]) () = {
                                ega_set_mode,
                                ega_set_cursor_mode,
                                vd_set_cursor_position,
                                vd_get_cursor_position,
                                vd_get_light_pen,
                                vd_set_active_page,
                                vd_scroll_up,
                                vd_scroll_down,
                                vd_read_attrib_char,
                                vd_write_char_attrib,
                                vd_write_char,
                                ega_emul_set_palette,
                                vd_write_dot,
                                vd_read_dot,
                                vd_write_teletype,
                                vd_get_mode,
                                ega_set_palette,
                                ega_char_gen,
                                ega_alt_sel,
                                vd_write_string,
#ifdef VGG
                                not_imp,
                                not_imp,
                                not_imp,
                                not_imp,
                                not_imp,
                                not_imp,
                                vga_disp_comb,  /* Function 1A */
                                vga_disp_func,
                                vga_int_1C,     /* Save/Restore Video State */
#endif
                           };
#endif  //NEC_98

static int v7_mode_64_munge[4] ={0, 3, 12, 15};
IMPORT half_word bg_col_mask;

#ifdef  VGG
/*
 * Define arrays for mapping the Video BIOS call start and end
 * cursor scanline to their corresponding VGA/EGA register values.
 * There are seperate arrays for cursor start and end and for
 * 8x8 and 8x16 char cell sizes.
 */

UTINY   vga_cursor8_start[17][17] = {
        /*00*/  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
        /*01*/  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        /*02*/  0x00, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
        /*03*/  0x00, 0x01, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
        /*04*/  0x00, 0x01, 0x05, 0x06, 0x07, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
        /*05*/  0x00, 0x01, 0x02, 0x05, 0x06, 0x07, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
        /*06*/  0x00, 0x01, 0x02, 0x04, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
        /*07*/  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*08*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
        /*09*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
        /*10*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
        /*11*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
        /*12*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x0c, 0x0c, 0x0c, 0x0c,
        /*13*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x0d, 0x0d, 0x0d,
        /*14*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x0e, 0x0e,
        /*15*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x0f,
        /*16*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07,
        };


UTINY   vga_cursor16_start[17][17] = {
        /*00*/  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
        /*01*/  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        /*02*/  0x00, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
        /*03*/  0x00, 0x01, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
        /*04*/  0x00, 0x01, 0x0c, 0x0d, 0x0e, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
        /*05*/  0x00, 0x01, 0x02, 0x0c, 0x0d, 0x0e, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
        /*06*/  0x00, 0x01, 0x02, 0x08, 0x0c, 0x0d, 0x0e, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
        /*07*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*08*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
        /*09*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
        /*10*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
        /*11*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
        /*12*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x0c, 0x0c, 0x0c, 0x0c,
        /*13*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x0d, 0x0d, 0x0d,
        /*14*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x0e, 0x0e,
        /*15*/  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x0f,
        /*16*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e,
        };

#ifdef  USE_CURSOR_END_TABLES

UTINY   vga_cursor8_end[17][17] = {
        /*00*/  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        /*01*/  0x01, 0x01, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*02*/  0x02, 0x02, 0x02, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*03*/  0x03, 0x03, 0x03, 0x03, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*04*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*05*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*06*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*07*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*08*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*09*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*10*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*11*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*12*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*13*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*14*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*15*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        /*16*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
        };

UTINY   vga_cursor16_end[17][17] = {
        /*00*/  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        /*01*/  0x01, 0x01, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
        /*02*/  0x02, 0x02, 0x02, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
        /*03*/  0x03, 0x03, 0x03, 0x03, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
        /*04*/  0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
        /*05*/  0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
        /*06*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
        /*07*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
        /*08*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
        /*09*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
        /*10*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
        /*11*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
        /*12*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f,
        /*13*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f,
        /*14*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f,
        /*15*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
        /*16*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e,
        };
#endif  /* USE_CURSOR_END_TABLES */
#endif  /* VGG */

/* [5.1.1 #DEFINES]                                                     */
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "VIDEO_BIOS_EGA.seg"
#endif

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]                        */


/* [5.1.3 PROCEDURE() DECLARATIONS]                                     */

/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS                                     */

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]                               */


/*
==========================================================================
FUNCTION        :       do_outb
PURPOSE         :       handy utility to output a value to an EGA chip register.
INPUT  PARAMS   :       index port, register, value to write
RETURN PARAMS   :       None
==========================================================================
FUNCTION        :       follow_ptr
PURPOSE         :       handy utility to follow a 'long' intel pointer.
INPUT  PARAMS   :       Address in M of the pointer
RETURN PARAMS   :       Address in M of the pointed-to byte.
==========================================================================
FUNCTION        :       low_set_mode
PURPOSE         :       Does low-level mode change.
EXTERNAL OBJECTS:       list any used, and state changes incurred
RETURN VALUE    :
INPUT  PARAMS   :       mode: screen mode to change to.
RETURN PARAMS   :
==========================================================================
FUNCTION        :       load_font
PURPOSE         :       load part of a font into EGA font memory.
EXTERNAL OBJECTS:       list any used, and state changes incurred
RETURN VALUE    :
INPUT  PARAMS   :       sys_addr table  Address in M of the character bitmaps
                        int count       number of characters to redefine
                        int char_off    first character to redefine
                        int font_no     font to change
                        int nbytes      Number of bytes per character
RETURN PARAMS   :
==========================================================================
PROCEDURE         :     ega_set_mode()
PURPOSE           :     Switch screen mode.
PARAMETERS        :      AL = mode.

GLOBALS           :     describe what exported data objects are
                        accessed and how. Likewise for imported
                        data objects.

ACCESS            :     via ega_video_func[] jump table.

RETURNED VALUE    :     None.

DESCRIPTION       :
==========================================================================
PROCEDURE         :     ega_alt_sel()
PURPOSE           :     Get EGA info
PARAMETERS        :     BL = function
GLOBALS           :
ACCESS            :     via ega_video_func[] jump table.
RETURNED VALUE    :     None.
DESCRIPTION       :
==========================================================================
FUNCTION        :       ega_set_palette
PURPOSE         :       brief description
EXTERNAL OBJECTS:       list any used, and state changes incurred
RETURN VALUE    :
INPUT  PARAMS   :
RETURN PARAMS   :
==========================================================================
FUNCTION        :       ega_emul_set_palette
PURPOSE         :       brief description
EXTERNAL OBJECTS:       list any used, and state changes incurred
RETURN VALUE    :
INPUT  PARAMS   :
RETURN PARAMS   :
==========================================================================
FUNCTION        :       ega_char_gen
PURPOSE         :       brief description
EXTERNAL OBJECTS:       list any used, and state changes incurred
RETURN VALUE    :
INPUT  PARAMS   :
RETURN PARAMS   :
==========================================================================
FUNCTION        :       write_ch_set/xor()
PURPOSE         :       Output character to screen in EGA graphics modes.
EXTERNAL OBJECTS:       list any used, and state changes incurred
RETURN VALUE    :
INPUT  PARAMS   :
RETURN PARAMS   :
==========================================================================
FUNCTION        :       name
PURPOSE         :       brief description
EXTERNAL OBJECTS:       list any used, and state changes incurred
RETURN VALUE    :
INPUT  PARAMS   :
RETURN PARAMS   :
==========================================================================
*/
#ifdef VGG
/* Called for not implemented functions */
void not_imp IFN0()
{
        setAL(0);
}
#endif

static void do_outb IFN3(int, index,int, ega_reg, byte, value)
{
#ifndef NEC_98
        outb((IU16)index,(IU8)ega_reg);
        outb((IU16)(index+1),value);
#endif  //NEC_98
}

sys_addr video_effective_addr IFN2(IU16, seg, IU16, offset)
{
#ifdef CPU_40_STYLE
        if (forceVideoRmSemantics)
        {
                /* can't call effective_addr, as the segment is almost
                ** certainly bogus in prot mode. This mode of operation
                ** should ONLY be used when we are bypassing going to v86
                ** mode to do a video bios operation (see WinVDD.c)
                */
                return((sys_addr)((((IU32)seg)<<4) + offset));
        }
        else
#endif
        {
                return effective_addr(seg, offset);
        }
}

sys_addr follow_ptr IFN1(sys_addr, addr)
{
        return video_effective_addr(sas_w_at_no_check(addr+2),
                sas_w_at_no_check(addr));
}

void low_set_mode IFN1(int, mode)
{
#ifndef NEC_98
        int i;
        sys_addr save_addr,params_addr,palette_addr;
        word temp_word;
        half_word start, end, video_mode;


        params_addr = find_mode_table(mode,&save_addr);

/* setup Sequencer */
#ifndef REAL_VGA
        do_outb(EGA_SEQ_INDEX,0,1);     /* Synchronous reset - turn off Sequencer */
#else
        do_outb(EGA_SEQ_INDEX,0,0);     /* Reset - turn off Sequencer */
#endif
        do_outb(EGA_CRTC_INDEX,0x11,0);
        for(i=0;i<EGA_PARMS_SEQ_SIZE;i++)
        {
                do_outb(EGA_SEQ_INDEX,i+1,sas_hw_at_no_check(params_addr+EGA_PARMS_SEQ+i));
        }
        do_outb(EGA_SEQ_INDEX,0,3);     /* Turn Sequencer back on */
/* setup Miscellaneous register */
        outb(EGA_MISC_REG,sas_hw_at_no_check(params_addr+EGA_PARMS_MISC));
/* setup CRTC */
        for(i=0;i<EGA_PARMS_CRTC_SIZE;i++)
        {
                do_outb(EGA_CRTC_INDEX,i,sas_hw_at_no_check(params_addr+EGA_PARMS_CRTC+i));
        }
        if (video_adapter == EGA) {
            if( (get_EGA_switches() & 1) && mode < 4)
            {
                /* For some reason, the CRTC parameter table for 'enhanced' text has
                 * the same cursor start and end as for 'unenhanced' text.
                 * So fix the cursor start & end values to sensible things.
                 * This is not the case for the VGA BIOS mode table.
                 */
                do_outb(EGA_CRTC_INDEX, R10_CURS_START, 11);
                do_outb(EGA_CRTC_INDEX, R11_CURS_END, 12);
            }
        }
/* setup attribute chip - NB need to do an inb() to clear the address */
        inb(EGA_IPSTAT1_REG, (half_word *)&temp_word);
        for(i=0;i<EGA_PARMS_ATTR_SIZE;i++)
        {
                outb(EGA_AC_INDEX_DATA,(IU8)i);
                outb(EGA_AC_INDEX_DATA,sas_hw_at_no_check(params_addr+EGA_PARMS_ATTR+i));
        }
/* setup graphics chips */
        for(i=0;i<EGA_PARMS_GRAPH_SIZE;i++)
        {
                do_outb(EGA_GC_INDEX,i,sas_hw_at_no_check(params_addr+EGA_PARMS_GRAPH+i));
        }

#ifdef V7VGA
/* setup extensions registers */
#ifndef GISP_SVGA       /* Don't want the V7 stuff for GISP
                           builds that still use our
                           video ROMS */

        if (video_adapter == VGA)
        {
                /* turn on extension registers */
                do_outb(EGA_SEQ_INDEX, 6, 0xea);

                if (mode < 0x46)
                {
                        do_outb(EGA_SEQ_INDEX, 0xfd, 0x22);
                        do_outb(EGA_SEQ_INDEX, 0xa4, 0x00);
                        do_outb(EGA_SEQ_INDEX, 0xfc, 0x08);
                        do_outb(EGA_SEQ_INDEX, 0xf6, 0x00);
                        do_outb(EGA_SEQ_INDEX, 0xf8, 0x00);
                        do_outb(EGA_SEQ_INDEX, 0xff, 0x00);
                }
                else
                {
                        if (mode < 0x62)
                                do_outb(EGA_SEQ_INDEX, 0xfd, 0x00);
                        else if (mode == 0x62)
                                do_outb(EGA_SEQ_INDEX, 0xfd, 0x90);
                        else
                                do_outb(EGA_SEQ_INDEX, 0xfd, 0xa0);

                        if (mode == 0x60)
                                do_outb(EGA_SEQ_INDEX, 0xa4, 0x00);
                        else
                                do_outb(EGA_SEQ_INDEX, 0xa4, 0x10);

                        if (mode < 0x66)
                                if ((mode == 0x63) || (mode == 0x64))
                                        do_outb(EGA_SEQ_INDEX, 0xfc, 0x18);
                                else
                                        do_outb(EGA_SEQ_INDEX, 0xfc, 0x08);
                        else
                                do_outb(EGA_SEQ_INDEX, 0xfc, 0x6c);

                        if ((mode < 0x65) || (mode == 0x66))
                        {
                                do_outb(EGA_SEQ_INDEX, 0xf6, 0x00);
                                do_outb(EGA_SEQ_INDEX, 0xff, 0x00);
                        }
                        else
                        {
                                do_outb(EGA_SEQ_INDEX, 0xf6, 0xc0);
                                do_outb(EGA_SEQ_INDEX, 0xff, 0x10);
                        }

                        if (mode == 0x62)
                                do_outb(EGA_SEQ_INDEX, 0xf8, 0x10);
                        else
                                do_outb(EGA_SEQ_INDEX, 0xf8, 0x00);
                }

                /* turn off extension registers */
                do_outb(EGA_SEQ_INDEX, 6, 0xae);
        }
#endif          /* GISP_SVGA */

        /***
                Update Extended BIOS data stuff ?
        ***/
#endif

    /*
     * Update BIOS data variables
     */

    sas_storew_no_check(VID_COLS,sas_hw_at_no_check(params_addr+EGA_PARMS_COLS)); /* byte in ROM, word in BIOS var! */
    sas_store_no_check(vd_rows_on_screen, sas_hw_at_no_check(params_addr+EGA_PARMS_ROWS));
    sas_store_no_check(ega_char_height, sas_hw_at_no_check(params_addr+EGA_PARMS_HEIGHT));
    sas_storew_no_check(VID_LEN,sas_w_at_no_check(params_addr+EGA_PARMS_LENGTH));

/* save cursor mode: BIOS data area has end byte at the low address,
   so the bytes must be swapped over from the CRTC register sense */
    start = sas_hw_at_no_check(params_addr+EGA_PARMS_CURSOR);
    sas_store_no_check(VID_CURMOD+1, start);
    end = sas_hw_at_no_check(params_addr+EGA_PARMS_CURSOR+1);
    sas_store_no_check(VID_CURMOD, end);
    sure_sub_note_trace2(CURSOR_VERBOSE,"changing mode, setting cursor bios vbls to start=%d, end=%d",start,end);
    sure_sub_note_trace2(CURSOR_VERBOSE,"changing mode, mode=%#x, params_addr=%#x",mode,params_addr);

/* save Palette registers if necessary */
        palette_addr = follow_ptr(save_addr+PALETTE_OFFSET);
    if(palette_addr)
    {
        for(i=0;i<16;i++)
                sas_store_no_check(palette_addr+i, sas_hw_at_no_check(params_addr+EGA_PARMS_ATTR+i));
        sas_store_no_check(palette_addr+16, sas_hw_at_no_check(params_addr+EGA_PARMS_ATTR+17));
    }

/* Get the video_.. variables from the mode table */
        video_mode = sas_hw_at_no_check(vd_video_mode);
#ifdef V7VGA
        if (video_adapter == VGA)
        {
                if (video_mode > 0x13)
                        video_mode += 0x4c;
                else if ((video_mode == 1) && extensions_controller.foreground_latch_1)
                        video_mode = extensions_controller.foreground_latch_1;
        }

        if (video_mode >= 0x60)
        {
        video_pc_low_regen = vd_ext_graph_table[video_mode-0x60].start_addr;
        video_pc_high_regen = vd_ext_graph_table[video_mode-0x60].end_addr;
        }
        else if (video_mode >= 0x40)
        {
        video_pc_low_regen = vd_ext_text_table[video_mode-0x40].start_addr;
        video_pc_high_regen = vd_ext_text_table[video_mode-0x40].end_addr;
        }
        else
        {
        video_pc_low_regen = vd_mode_table[video_mode].start_addr;
        video_pc_high_regen = vd_mode_table[video_mode].end_addr;
        }
#else
    video_pc_low_regen = vd_mode_table[video_mode].start_addr;
    video_pc_high_regen = vd_mode_table[video_mode].end_addr;
#endif /* V7VGA */

#ifdef VGG
    if (video_adapter == VGA) {
        i = get_scanlines();    /* WARNING - needs the BIOS variables! */
        if(mode == 0x13 || mode > 0x65)
        {
            init_vga_dac(2);  /* 256 colour DAC table */
        }
        else if(i == RS200 || mode == 0x63 || mode == 0x64)
        {
            init_vga_dac(1);  /* DACs to emulate CGA palette - RGB + Intensity*/
        }
        else
        {
            init_vga_dac(0);  /* DACs to emulate EGA palette - RGB + rgb */
        }
        outb(VGA_DAC_MASK,0xff);
        /* Initialize the fancy VGA palette stuff to look like an EGA */
        inb(EGA_IPSTAT1_REG, (half_word *)&temp_word);
        outb(EGA_AC_INDEX_DATA, 20); /* Pixel padding register */
        outb(EGA_AC_INDEX_DATA, 0);  /* Use first block of 64 in DACs */
    }
#endif
#endif  //NEC_98
}

/* Load part of a font into EGA font memory. */
void load_font IFN5
   (
   sys_addr, table,     /* Address in M of the character bitmaps */
   int, count,          /* number of characters to redefine */
   int, char_off,       /* first character to redefine */
   int, font_no,        /* font to change */
   int, nbytes          /* Number of bytes per character */
   )
{
#ifndef NEC_98
#if !(defined(NTVDM) && defined(X86GFX)) || defined(ARCX86)
        int i,j;
        sys_addr font_addr;
        sys_addr data_addr;
#endif /* !(NTVDM && X86GFX) || ARCX86 */
        half_word temp_word;
        half_word video_mode;
        static word font_off[] = { 0, 0x4000, 0x8000, 0xc000, 0x2000, 0x6000, 0xa000, 0xe000 };

/* First switch to font loading mode */
        low_set_mode(FONT_LOAD_MODE);


#if defined(NTVDM) && defined(X86GFX)

#ifdef ARCX86
    if (UseEmulationROM) {
        font_addr = (sys_addr)(&EGA_planes[FONT_BASE_ADDR]) +
                    (font_off[font_no] + FONT_MAX_HEIGHT*char_off) * 4;
        data_addr = table;

        for(i=0;i<count;i++)
        {
            for(j=0;j<nbytes;j++)
            {
                sas_store(font_addr, sas_hw_at_no_check(data_addr));
                font_addr += 4;
                data_addr++;
            }

            font_addr += (FONT_MAX_HEIGHT - nbytes) * 4;
        }
    } else {
        loadNativeBIOSfont( 25 );
    }
#else  /* ARCX86 */
        loadNativeBIOSfont( 25 );
#endif /* ARCX86 */

#else
#ifdef GISP_SVGA
        if( hostIsFullScreen( ) )
        {
                loadFontToVGA( table , count , char_off , font_no , nbytes );
        }
        else
        {
                loadFontToEmulation( table , count , char_off , font_no , nbytes );
        }
#else /* GISP_SVGA */


        /* Work out where to put the font. */
        font_addr = 0xA0000 + font_off[font_no] + FONT_MAX_HEIGHT*char_off;
        data_addr = table;

        for(i=0;i<count;i++)   /* for each character */
        {
                for(j=0;j<nbytes;j++)   /* for each byte of character */
                {
                        sas_store(font_addr, sas_hw_at_no_check(data_addr));
                        font_addr++;
                        data_addr++;
                }

                font_addr += (FONT_MAX_HEIGHT - nbytes);
        }
#endif  /* GISP_SVGA */
#endif  /* NTVDM && X86GFX */

/* Finally switch back to the BIOS mode */
        video_mode = sas_hw_at_no_check(vd_video_mode);
#ifdef V7VGA
        if (video_adapter == VGA)
                if (video_mode > 0x13)
                        video_mode += 0x4c;
                else if ((video_mode == 1) && extensions_controller.foreground_latch_1)
                        video_mode = extensions_controller.foreground_latch_1;
#endif /* V7VGA */

        low_set_mode(video_mode);
        inb(EGA_IPSTAT1_REG,&temp_word);
        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);    /* re-enable video */
#endif  //NEC_98
}

void recalc_text IFN1(int, height)
{
#ifndef NEC_98
        int scan_lines;
        half_word video_mode;
        word screen_height;
        half_word oflo;
        half_word protect;
#ifdef NTVDM
    MAX_SCAN_LINE   crtc_reg9;
#endif
#ifdef JAPAN
        // mskkbug #2784 Title of VJE-PEN is strange 11/5/93 yasuho
        word length;
#endif // JAPAN

        video_mode = sas_hw_at_no_check(vd_video_mode);
#ifdef V7VGA
        if (video_adapter == VGA)
                if (video_mode > 0x13)
                        video_mode += 0x4c;
                else if ((video_mode == 1) && extensions_controller.foreground_latch_1)
                        video_mode = extensions_controller.foreground_latch_1;
#endif /* V7VGA */

        if(video_adapter == EGA && !(get_EGA_switches() & 1) && (video_mode < 4))
                scan_lines = 200; /* Low res text mode */
        else
                scan_lines = get_screen_height() + 1;

        sas_store_no_check(ega_char_height, (IU8)height);
        sas_store_no_check(vd_rows_on_screen, (IU8)(scan_lines/height - 1));
#ifdef JAPAN
        // mskkbug #2784 Title of VJE-PEN is strange 11/5/93 yasuho
        // Adjust video length
        length = (sas_hw_at_no_check(vd_rows_on_screen) + 1) *
                sas_w_at_no_check(VID_COLS) * 2;
        if (!is_us_mode() && sas_hw_at_no_check(DosvModePtr) == 0x73)
                length *= 2;
        sas_storew_no_check(VID_LEN, length);
#else // !JAPAN
        if ( video_mode < 4 &&  scan_lines/height == 25 )
                sas_storew_no_check(VID_LEN, (IU16)(video_mode<2 ? 0x800 : 0x1000));
        else
                sas_storew_no_check(VID_LEN, (IU16)((sas_hw_at_no_check(vd_rows_on_screen)+1)*sas_w_at_no_check(VID_COLS)*2));
#endif // !JAPAN
#ifdef NTVDM
    /* preserve other bits in register 9 for VGA */
    if (video_adapter == VGA) {
        outb(EGA_CRTC_INDEX, 9);
        inb(EGA_CRTC_DATA, (half_word *) &crtc_reg9);
        crtc_reg9.as_bfld.maximum_scan_line = height -1;
        outb(EGA_CRTC_DATA, (IU8)crtc_reg9.as.abyte);
    }
    else
        do_outb(EGA_CRTC_INDEX,9,(IU8)(height-1)); /* Character height */
#else
    do_outb(EGA_CRTC_INDEX,9,height-1); /* Character height */
#endif
        do_outb(EGA_CRTC_INDEX,0xA,(IU8)(height-1));    /* Cursor start */
        do_outb(EGA_CRTC_INDEX,0xB,0);          /* Cursor end */

        /*
        * VGA adapter height setting occupies Vertical Display End register
        * plus 2 bits in the overflow register. The overflow register may also
        * be write protected.
        */
        if (video_adapter == VGA)
        {
#ifdef NTVDM
        /* Some globals that the mouse driver needs to have available */
        /* when an application (such as any CW based apps.) makes a   */
        /* call to int 33h AX = 26h.                                  */

        IMPORT word VirtualX, VirtualY;
#endif /* NTVDM */

                screen_height = (sas_hw_at_no_check(vd_rows_on_screen)+1)*height-1;

#ifdef NTVDM
            /* Create the virtual screen size maximums for the text modes */
            /* This is needed here for CW applications.                  */

                VirtualX = 640;         /* This is always this value */
                if(scan_lines == 401)
                    VirtualY = 400;             /* 50 text row mode - 400 scanlines */
                else if(scan_lines == 351)
                    VirtualY = 344;             /* 43 text row mode - 350 scanlines */
                else
                    VirtualY = 200;             /* Failsafe - 25 row mode or rest!  */

#endif /* NTVDM */

                outb(EGA_CRTC_INDEX, 7);        /* overflow register */
                inb(EGA_CRTC_DATA, &oflo);
                outb(EGA_CRTC_INDEX, 0x11);     /* vert sync contains protect bit */
                inb(EGA_CRTC_DATA, &protect);

                if (screen_height & 0x100)
                        oflo |= 2;   /* bit 8 of height -> bit 1 of overflow register */
                else
                        oflo &= ~2;
                if (screen_height & 0x200)
                        oflo |= 0x40;   /* bit 9 of height -> bit 6 of overflow register */
                else
                        oflo &= ~0x40;
                if ((protect & 0x80) == 0x80)    /* overflow reg protected */
                {
                        do_outb(EGA_CRTC_INDEX, 0x11, (IU8)(protect & 0x7f)); /* enable writes */
                        do_outb(EGA_CRTC_INDEX, 7, oflo);       /* overflow reg */
                        do_outb(EGA_CRTC_INDEX, 0x11, protect); /* put back old value */
                }
                else
                        do_outb(EGA_CRTC_INDEX, 7, oflo);       /* overflow reg */

                do_outb(EGA_CRTC_INDEX,0x12, (IU8)(screen_height & 0xff)); /* Vertical display end = scan lines */
        }
        else
        if (video_adapter == EGA)
        {
                screen_height = (sas_hw_at_no_check(vd_rows_on_screen)+1)*height-1;
                outb(EGA_CRTC_INDEX, 7);        /* overflow register */
                inb(EGA_CRTC_DATA, &oflo);
                if (screen_height & 0x100)
                        oflo |= 2;   /* bit 8 of height -> bit 1 of overflow reg */
                else
                        oflo &= ~2;
                do_outb(EGA_CRTC_INDEX, 7, oflo);       /* overflow reg */
                do_outb(EGA_CRTC_INDEX, 0x12, (IU8)(screen_height & 0xff)); /* Vertical display end = scan lines */
        }
        else
        {
                assert1(NO, "Bad video adapter (%d) in recalc_text", video_adapter);
        }

        do_outb(EGA_CRTC_INDEX,0x14,(IU8)height); /* Underline scan line - ie no underline */
#endif  //NEC_98
}

static void set_graph_font IFN1(int, height)
{
#ifndef NEC_98
        switch (getBL())
        {
                case 0:
                        sas_store_no_check(vd_rows_on_screen, (IU8)(getDL()-1));
                        break;
                case 1:
                        sas_store_no_check(vd_rows_on_screen, 13);
                        break;
                case 2:
                        sas_store_no_check(vd_rows_on_screen, 24);
                        break;
                case 3:
                        sas_store_no_check(vd_rows_on_screen, 42);
                        break;
                default:
                        assert2(FALSE,"Illegal char gen sub-function %#x:%#x",getAL(),getBL());
        }
        sas_store_no_check(ega_char_height, (IU8)height);
#endif  //NEC_98
}

LOCAL VOID
write_ch_set IFN5(sys_addr, char_addr, int, screen_off,
        int, colour, int, nchs, int, scan_length)
{
#ifndef NEC_98
        unsigned int i, j, colourmask, data, temp, char_height;
        unsigned int *screen;
        register sys_addr font;

#ifndef REAL_VGA

        /*
         * video mode 11 (VGA 640x480 2 colour mode) is a special case as
         * it does not have a 'no display' attribute.
         */

        if( sas_hw_at_no_check(vd_video_mode) == 0x11 )
                colourmask = ~0;
        else
                colourmask = sr_lookup[colour & 0xf];

        font = char_addr;

        screen = (unsigned int *) &EGA_planes[screen_off << 2];
        char_height = sas_hw_at_no_check(ega_char_height);

        if( nchs == 1 )
        {
                for( i = char_height; i > 0; i-- )
                {
                        data = sas_hw_at_no_check(font);
                        font++;
                        temp = data << 8;
                        data |= temp;
                        temp = data << 16;
                        data |= temp;

                        *screen = data & colourmask;
                        screen += scan_length;
                }
        }
        else
        {
                scan_length -= nchs;

                for( i = char_height; i > 0; i-- )
                {
                        data = sas_hw_at_no_check(font);
                        font++;
                        temp = data << 8;
                        data |= temp;
                        temp = data << 16;
                        data |= temp;

                        data &= colourmask;

                        for( j = nchs; j > 0; j-- )
                        {
                                *screen++ = data;
                        }

                        screen += scan_length;
                }
        }
#else
        vga_card_w_ch_set(char_addr, screen_off, colour, nchs, scan_length, char_height);
#endif
#endif  //NEC_98
}

void write_ch_xor IFN5(sys_addr, char_addr, int, screen_off,
        int, colour, int, nchs, int, scan_length)
{
#ifndef NEC_98
        unsigned int i, j, colourmask, data, temp, char_height;
        unsigned int *screen;
        register sys_addr font;

#ifndef REAL_VGA
        /*
         * video mode 11 (VGA 640x480 2 colour mode) is a special case as
         * it does not have a 'no display' attribute.
         */
        if(sas_hw_at_no_check(vd_video_mode) == 0x11)
                colourmask = ~0;
        else
                colourmask = sr_lookup[colour & 0xf];

        font = char_addr;
        char_height = sas_hw_at_no_check(ega_char_height);

        screen = (unsigned int *) &EGA_planes[screen_off << 2];

        if( nchs == 1 )
        {
                for( i = char_height; i > 0; i-- )
                {
                        data = sas_hw_at_no_check(font);
                        font++;
                        temp = data << 8;
                        data |= temp;
                        temp = data << 16;
                        data |= temp;

                        *screen ^= data & colourmask;
                        screen += scan_length;
                }
        }
        else
        {
                scan_length -= nchs;

                for( i = char_height; i > 0; i-- )
                {
                        data = sas_hw_at_no_check(font);
                        font++;
                        temp = data << 8;
                        data |= temp;
                        temp = data << 16;
                        data |= temp;

                        data &= colourmask;

                        for( j = nchs; j > 0; j-- )
                        {
                                *screen++ ^= data;
                        }

                        screen += scan_length;
                }
        }
#else
        vga_card_w_ch_xor(char_addr, screen_off, colour, nchs, scan_length, char_height);
#endif
#endif  //NEC_98
}

GLOBAL void ega_set_mode IFN0()
{
#ifndef NEC_98
        int pag;
        sys_addr save_addr,font_addr;
        int font_offset;
        half_word temp_word;
        byte mode_byte;
        byte video_mode;
#ifdef V7VGA
        byte saveBL;
#endif /* V7VGA */

#ifndef PROD
        trace("setting video mode", DUMP_REG);
#endif

#ifdef GISP_SVGA
        /* Try and catch mode changes early */

        /* Are we in the ROMS at the BOP 10 ? */
        if( getCS( ) == EgaROMSegment )
        {
                if( videoModeIs( getAL( ) , GRAPH ) )
                {
                        /* Seem to have got a video mode int 10 */
                        videoInfo.modeType = GRAPH;
                        if( !hostEasyMode( ) )
                        {
                                videoInfo.forcedFullScreen = TRUE;

                                /* point IP at the JMP to host roms */
                                setIP( 0x820 );

                                /* and return, to let the host bios do the change */
                                return;
                        }


                }

                /* Not in the vga roms so carry on */
        }
#endif          /* GISP_SVGA */

#ifdef V7VGA
        /*
           Real video-7 maps mode 7 and mode f to mode 0.
        */

        if (video_adapter==VGA) {
                video_mode=(getAL()&0x7F);
                if (video_mode==7||video_mode==0xF) {
                        setAL(getAL()&0x80);
                        always_trace1("V7 doesn't support mode %02x, using mode 0\n",video_mode);
                }
        }
#endif

#ifdef JAPAN
        // mode73h support 5/26/1993 V-KazuyS
        // when it's not US mode, ntvdm maps mode 73 to mode 3.
#ifdef JAPAN_DBG
        DbgPrint( "NTVDM: ega_set_mode() setting video mode %x\n", getAL() );
#endif
        if ( !is_us_mode() ) {
#ifdef i386
            if ( getAL() == 0x73 ) {
                sas_store(DosvModePtr, getAL());
                setAL( 0x03 );
#else // !i386
            if( (getAL() & 0x7f) == 0x73 ) {
                setAL( (getAL() & 0x83) );
#endif // !i386
            }
#if !defined(i386) && defined(JAPAN_DBG)
        DbgPrint( " NTVDM: DosvMode %x\n", sas_hw_at_no_check(DosvModePtr));
#endif
        }
#endif // JAPAN
        if (is_bad_vid_mode(getAL()))
        {
#ifdef V7VGA
                if ((video_adapter == VGA) && is_v7vga_mode(getAL() + 0x4c))
                {
                        saveBL = getBL();
                        /* Put the mode value where the V7 BIOS expects it */
                        setBL(getAL() + 0x4c);
                        v7vga_extended_set_mode();
                        setBL(saveBL);
                }
                else
#endif /* V7VGA */
                        always_trace1("Bad video mode - %d.\n", getAL());
                return;
        }

        video_mode=(getAL()&0x7F);

#ifdef V7VGA
        /*
         * The real V7 VGA does not change into 40 col mode while
         * in any proprietary text mode. (A bug ?!)
         * Emulate this behaviour !
         */
        if ( video_adapter == VGA && video_mode == 1
              && is_v7vga_mode(extensions_controller.foreground_latch_1) ) {
                saveBL = getBL();
                /*
                 * This is all backwards - we make the v7vga extended mode setup
                 * believe the new mode is the old one. Probably the real card's BIOS
                 * is just as confused as this code.
                 * Put the mode value where the V7 BIOS expects it.
                 */
                setBL(extensions_controller.foreground_latch_1);
                v7vga_extended_set_mode();
                setBL(saveBL);
                return;
        }

        /*
         * Don't confuse the tricky V7 extended mode setting, as
         * implemented in v7_video.c, v7vga_extended_set_mode().
         * low_set_mode() looks at it. Zero it.
         */
        extensions_controller.foreground_latch_1 = 0;
#endif  /* V7VGA */

/*
 * Only update the global video mode if we're in the system virtual machine.
 * The global mode should then be valid for use in timer interrupts.
 */

        if (sas_hw_at_no_check(BIOS_VIRTUALISING_BYTE) == 0)
                Video_mode = video_mode;

        sas_store_no_check(vd_video_mode, (IU8)(getAL() & 0x7F)); /* get rid of top bit - indicates clear or not */
        sas_store_no_check(ega_info, (IU8)((sas_hw_at_no_check(ega_info) & 0x7F ) | (getAL() & 0x80))); /* update screen clear flag in ega_info */

#ifdef JAPAN
    // In JP mode, if video mode != jp mode, set US mode.
    if (    ( video_mode != 0x03 )
         && ( video_mode != 0x11 )
         && ( video_mode != 0x12 )
         && ( video_mode != 0x72 )
         && ( video_mode != 0x73 ) ) {
#ifdef JAPAN_DBG
        DbgPrint( "VideoMode(%02x) != jp mode, setCP 437\n", getAL() );
#endif
        SetConsoleCP( 437 );
        SetConsoleOutputCP( 437 );
        SetDBCSVector( 437 );
    }

    // notice video format to console

    VDMConsoleOperation(VDM_SET_VIDEO_MODE,
                        (LPVOID)((sas_hw_at_no_check(DosvModePtr) == 0x73) ? TRUE : FALSE));

    // Int10Flag initialize
    {
        register byte *p = Int10Flag;
        register int i;
        int count = 80*50;

#ifdef JAPAN_DBG
        DbgPrint( "NTVDM: ega_set_mode() Int10Flag Initialize\n" );
#endif
        for ( i = 0; i < count; i++ )
            *p++ = INT10_SBCS | INT10_CHANGED;        // init == all space
        Int10FlagCnt++;
    }

#elif defined(KOREA) // JAPAN
    // In KO mode, if video mode != ko mode, set US mode.
    if (    ( video_mode != 0x03 )
         && ( video_mode != 0x11 )
         && ( video_mode != 0x12 )
         && ( video_mode != 0x72 ) ) {

        SetConsoleCP( 437 );
        SetConsoleOutputCP( 437 );
        SetDBCSVector( 437 );
    }

    // notice video format to console
    VDMConsoleOperation(VDM_SET_VIDEO_MODE, (LPVOID)FALSE);
#endif // KOREA
#ifdef CPU_40_STYLE
        if (forceVideoRmSemantics && (!get_EGA_no_clear()))
        {
            /* empty the planes... */
            memset(&EGA_planes[0], 0, 64*1024*4);
        }
#endif

#ifdef MSWDVR
        /*
         * If the video mode has actually changed, then call
         * host_mswin_disable().
         */
        if (Currently_emulated_video_mode != video_mode)
        {
#ifdef CPU_40_STYLE
                if (!getPE())
                {
                        host_mswin_disable();
                }
#else
                host_mswin_disable();
#endif /* CPU_40_STYLE */
        }
#endif /* MSWDVR */

        Currently_emulated_video_mode = video_mode;

#if defined(NTVDM) && defined(X86GFX)
        /*
        ** Tim August 92. MicroSoft.
        ** Give host a chance to do a zany non-standard mode change.
        ** For Microsoft NT this is a transition to full-screen ie. the
        ** real PC's video BIOS and graphics board.
        **
        ** Return value of TRUE means host has done the mode change for
        ** us, so no need to continue.
        */
        {
                extern BOOL hostModeChange IPT0();

                if( hostModeChange() )
                        return;
        }
#endif  /* NTVDM & X86GFX */

        save_addr = follow_ptr(EGA_SAVEPTR);
        if(alpha_num_mode())
        {
#ifdef VGG
                /* load_font will do the mode change for us */
                if (video_adapter == VGA)
                {
#ifdef NTVDM
                /* Some globals that the mouse driver needs to have available */
                /* when an application (such as any CW based apps.) makes a   */
                /* call to int 33h AX = 26h.                                  */

                IMPORT word VirtualX, VirtualY;
#endif /* NTVDM */

                    switch (get_VGA_lines())
                    {
                        case S350:
                                load_font(EGA_CGMN,256,0,0,14);
#ifdef NTVDM
                                VirtualX = 640;
                                VirtualY = 344;
#endif /* NTVDM */
                                break;
                        case S400:
                                load_font(EGA_HIFONT,256,0,0,16);
#ifdef NTVDM
                        /* This one gets hit the most by C.W. applications. */
                        /* Actually, the other cases never seem to get hit  */
                        /* but are there JUST IN CASE! The 43 and 50 row    */
                        /* modes in recalc_text().                          */

                                VirtualX = 640;
                                VirtualY = 200;
#endif /* NTVDM */
                                break;
                        default:
                                load_font(EGA_CGDDOT,256,0,0,8);
#ifdef NTVDM
                                VirtualX = 640;
                                VirtualY = 400;
#endif /* NTVDM */
                    }
                }
                else
#endif  /* VGG */
                {
                    if(get_EGA_switches() & 1)
                        load_font(EGA_CGMN,256,0,0,14);
                    else
                        load_font(EGA_CGDDOT,256,0,0,8);
                }
                /* Now see if we have a nasty font to load */
                font_addr = follow_ptr(save_addr+ALPHA_FONT_OFFSET);
                if(font_addr != 0)
                {
                /* See if it applies to us */
                        font_offset = 11;
                        do
                   {
                                mode_byte = sas_hw_at_no_check(font_addr + font_offset);
                                if(mode_byte == video_mode)
                        {
                                        load_font(follow_ptr(font_addr+6),sas_w_at_no_check(font_addr+2),sas_w_at_no_check(font_addr+4), sas_hw_at_no_check(font_addr+1), sas_hw_at_no_check(font_addr));
                                        recalc_text(sas_hw_at_no_check(font_addr));
                                        if(sas_hw_at_no_check(font_addr+10) != 0xff)
                                                sas_store_no_check(vd_rows_on_screen, (IU8)(sas_hw_at_no_check(font_addr+10)-1));
                           break;
                        }
                                font_offset++;
                        } while(mode_byte != 0xff);
                   }
#if defined(JAPAN) || defined(KOREA)
        // change Vram addres to DosVramPtr from B8000.
        // Don't call SetVram().
        if ( !is_us_mode() ) {
#ifdef i386
            // set_up_screen_ptr() vga_mode.c
            set_screen_ptr( (byte *)DosvVramPtr );
            // low_set_mode() ega_vide.c
            video_pc_low_regen = DosvVramPtr;
            video_pc_high_regen = DosvVramPtr + DosvVramSize - 1;
            // vga_gc_misc() vga_prts.c
            gvi_pc_low_regen = DosvVramPtr;
            gvi_pc_high_regen = DosvVramPtr + DosvVramSize - 1;
            sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);
            // recalc_screen_params() gvi.c
            set_screen_length( DosvVramSize );
#ifdef JAPAN_DBG
            DbgPrint( "NTVDM:   ega_set_mode() sets VRAM %x, size=%d\n", DosvVramPtr, DosvVramSize );
#endif
#endif // i386
            // copy from calcScreenParams()
            set_screen_height_recal( 474 ); /* set scanline */
            recalc_text(19);                /* char Height == 19 */

        }
#ifdef JAPAN_DBG
            DbgPrint( "NTVDM:   video_pc_low_regen %x, high %x, gvi_pc_low_regen %x, high %x\n", video_pc_low_regen, video_pc_high_regen, gvi_pc_low_regen, gvi_pc_high_regen );
#endif
#endif // JAPAN || KOREA
                }
        else
        {
                /* graphics mode. No font load, so do mode change ourselves */
                low_set_mode(video_mode);
                /* Set up default graphics font */
                sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
                if(video_mode == 16)
                        sas_storew_no_check(EGA_FONT_INT*4,EGA_CGMN_OFF);
                else
#ifdef VGG
                        if (video_mode == 17 || video_mode == 18)
                        sas_storew_no_check(EGA_FONT_INT*4,EGA_HIFONT_OFF);
                    else
#endif
                        sas_storew_no_check(EGA_FONT_INT*4,EGA_CGDDOT_OFF);
                /* Now see if we have a nasty font to load */
                font_addr = follow_ptr(save_addr+GRAPH_FONT_OFFSET);
                if(font_addr != 0)
                {
                /* See if it applies to us */
                        font_offset = 7;
                        do
                   {
                                mode_byte = sas_hw_at_no_check(font_addr + font_offset);
                                if(mode_byte == video_mode)
                        {
                                        sas_store_no_check(vd_rows_on_screen, (IU8)(sas_hw_at_no_check(font_addr)-1));
                                        sas_store_no_check(ega_char_height, sas_hw_at_no_check(font_addr+1));
                                        sas_move_bytes_forward(font_addr+3, 4*EGA_FONT_INT, 4);
                           break;
                        }
                                font_offset++;
                        } while(mode_byte != 0xff);
                   }
                }

    sas_store_no_check(vd_current_page, 0);
    sas_storew_no_check((sys_addr)VID_ADDR, 0);
    sas_storew_no_check((sys_addr)VID_INDEX, EGA_CRTC_INDEX);
/*
 * CGA bios fills this entry in 'vd_mode_table' with 'this is a bad mode'
 * value, so make one up for VGA - used in VGA bios disp_func
 */
    if(video_mode < 8)
                sas_store_no_check(vd_crt_mode, vd_mode_table[video_mode].mode_control_val);
    else if(video_mode < 0x10)
                sas_store_no_check(vd_crt_mode, 0x29);
        else
                sas_store_no_check(vd_crt_mode, 0x1e);
        if(video_mode == 6)
                sas_store_no_check(vd_crt_palette, 0x3f);
        else
                sas_store_no_check(vd_crt_palette, 0x30);

    for(pag=0; pag<8; pag++)
                sas_storew_no_check(VID_CURPOS + 2*pag, 0);

#ifdef V7VGA
        set_host_pix_height(1);
        set_banking( 0, 0 );
#endif

#ifdef NTVDM
    /* Don't want to clear screen on startup if integrated with the console. */
    if (soft_reset)
#endif /* NTVDM */
    {
        /* Clear screen */
        if(!get_EGA_no_clear())
        {
#ifdef REAL_VGA
            sas_fillsw_16(video_pc_low_regen, vd_mode_table[video_mode].clear_char,
                                 (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#else /* REAL_VGA */
#ifdef JAPAN
   // mode73h support
#ifdef i386
        // "video_pc_low_regen" is in DOS address space.
        // Direct access is prohibited.
        // We must use sas function to access DOS address space.
        if ( !is_us_mode() && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ) ) {
            unsigned long *p;
            unsigned long value = (unsigned long)vd_mode_table[0x03].clear_char;
            int  len = (video_pc_high_regen - video_pc_low_regen) / 4 + 1;
#ifdef JAPAN_DBG
            DbgPrint( "NTVDM: Set mode 73H\n" );
#endif
            p = (unsigned long *)video_pc_low_regen;
            while ( len-- ) {
                *p++ = value;
            }
        }
        else {
            // kksuzuka #6168 screen attributes
            extern word textAttr;

            sas_fillsw(video_pc_low_regen,
          ((textAttr << 8) | (vd_mode_table[video_mode].clear_char & 0x00FF)),
                         (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
        }
#else // !i386
        if( !is_us_mode() ) {
          register int len = DosvVramSize/4;
          register long *planes = (long *)get_screen_ptr(0);
          extern word textAttr;

          if( sas_hw_at_no_check(DosvModePtr) == 0x73 )
              sas_fillsw(DosvVramPtr, 0, DosvVramSize/2); // Apr. 18 1994 TakeS
          else
              // kksuzuka #6168 screen attributes
              sas_fillsw(DosvVramPtr, (textAttr << 8) | 0x20, DosvVramSize/2);

          while( len-- ){
            // kksuzuka #6168 screen attributes
            *planes++ = (textAttr << 8) | 0x00000020; //extended attr clear
          ((textAttr << 8) | (vd_mode_table[video_mode].clear_char & 0x00FF));
          }
        }

        sas_fillsw(video_pc_low_regen, vd_mode_table[video_mode].clear_char,
                   (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#endif // !i386
#elif defined(KOREA)
#ifdef i386
        // "video_pc_low_regen" is in DOS address space.
        // Direct access is prohibited.
        // We must use sas function to access DOS address space.

        // kksuzuka #6168 screen attributes
        extern word textAttr;

        sas_fillsw(video_pc_low_regen,
        ((textAttr << 8) | (vd_mode_table[video_mode].clear_char & 0x00FF)),
                           (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#else // !i386
#ifdef LATER // Do we really need this?. Fix for stress failure.
        if( !is_us_mode() ) {
          register int len = DosvVramSize/4;
          register long *planes = (long *)get_screen_ptr(0);
          extern word textAttr;

          // kksuzuka #6168 screen attributes
          sas_fillsw(DosvVramPtr, (textAttr << 8) | 0x20, DosvVramSize/2);

          while( len-- ){
            // kksuzuka #6168 screen attributes
            *planes++ = (textAttr << 8) | 0x00000020; //extended attr clear
          ((textAttr << 8) | (vd_mode_table[video_mode].clear_char & 0x00FF));
          }
        }
#endif
        sas_fillsw(video_pc_low_regen, vd_mode_table[video_mode].clear_char,
                   (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#endif // !i386
#else // !JAPAN & KOREA
            sas_fillsw(video_pc_low_regen, vd_mode_table[video_mode].clear_char,
                                 (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#endif // !JAPAN
#ifdef NTVDM
            /*
             * Need to call host clear screen on NT because text windows don't
             * resize and we need to clear portion not being written to.
             */
            host_clear_screen();
            host_mark_screen_refresh();
#endif /* NTVDM */
#endif /* REAL_VGA */
        }
    }
    inb(EGA_IPSTAT1_REG,&temp_word);
    outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);        /* re-enable video */
#if defined(JAPAN) || defined(KOREA)
    if (BOPFromDispFlag) {
        // mode73h support  set video mode to VGA BIOS work area
        if ( !is_us_mode() ) {
            sas_store_no_check(vd_video_mode, sas_hw_at_no_check(DosvModePtr));
        }
        else {
            sas_store_no_check(DosvModePtr, sas_hw_at_no_check(vd_video_mode));
        }
    }
#endif // JAPAN || KOREA
#if defined(NTVDM) && !defined(X86GFX)
    /*  tell mouse that video mode is changed so it can update its own
     *  EGA registers(for EGA.SYS interface). Only do this on RISC machine.
     *  On X86 machines, ntio.sys int10 handler redirects set mode call
     *  to mouse first which then goes to ega_video_io.
     */
    mouse_video_mode_changed(video_mode);
#endif
#ifndef PROD
    trace("end of video set mode", DUMP_NONE);
#endif
#endif  //NEC_98
}

/*
 * Set the cursor start and end positions. A bit strange, in that it assumes
 * the caller thinks the cursor is in an 8*8 character cell ... but this
 * should be a copy of the IBM EGA BIOS routine ... what more can we do?
 */
#define CGA_CURSOR_OFF_MASK     0x60
#define CGA_CURSOR_OFF_VALUE    0x20
#define EGA_CURSOR_OFF_START    0x1e
#define EGA_CURSOR_OFF_END      0x00

GLOBAL void ega_set_cursor_mode IFN0()
{
#ifndef NEC_98
    /*
     * Set cursor mode
     * Parameters:
     *  CX - cursor value (CH - start scanline, CL - stop scanline)
     */
    int start,end,char_height;

    /* get cursor start and end scan lines */
    start = getCH();
    end = getCL();

    /* The following check is done to see if the application is trying
       to turn the cursor off using a technique that worked on the CGA.
       If the application wants to turn the cursor off, it is faked
       up using suitable EGA start and end values */
    if ((start & CGA_CURSOR_OFF_MASK) == CGA_CURSOR_OFF_VALUE)
    {
        sure_sub_note_trace0(CURSOR_VERBOSE,"ega curs - application req curs off??");
        start = EGA_CURSOR_OFF_START;
        end = EGA_CURSOR_OFF_END;
    }
    /* If the application has enabled cursor emulation, try to fake
       up the same cursor appearance on the EGA 14 scan line character
       matrix as you would get on the CGA 8 scan line matrix. */
    else if(!get_EGA_cursor_no_emulate())
    {
        sure_sub_note_trace2(CURSOR_VERBOSE,"emulate CGA cursor using EGA cursor, CGA vals; start=%d, end = %d",start,end);

        char_height = sas_hw_at_no_check(ega_char_height);
#ifdef JAPAN
        // support Dosv cursor
        if ( !is_us_mode() ) {
            char_height = 8;

            if ( start > (char_height-1) )
                start = char_height - 1;
            if ( end > (char_height-1) )
                end = char_height - 1;

            if ( start <= end ) {
                if ( !( (end == char_height - 1) || (start == char_height - 2) )
                     && ( end > 3 ) ) {
                    if ( start + 2 >= end ) {
                        start = start - end + char_height - 1;
                        end = char_height - 1;
                        if ( char_height >= 14 ) {
                            start--;
                            end--;
                        }
                    }
                    else if ( start <= 2 ) {
                        end = char_height - 1;
                    }
                    else {
                        start = char_height / 2;
                        end = char_height - 1;
                    }
                }
            }
            else if ( end != 0 ) {
                start = end;
                end = char_height - 1;
            }
        }
        else
#endif // JAPAN

#ifdef  VGG
        if (video_adapter == VGA) {
           UTINY saved_start;

           if ( start > 0x10 )
                start = 0x10;
           if ( end > 0x10 )
                end = 0x10;

           /*
            * No more guessing, take the exact values from a real VGA:
            */

           saved_start = (UTINY)start;

           if ( char_height >= 16 ) {
                start = vga_cursor16_start[end][start];
#ifdef  USE_CURSOR_END_TABLES
                end   = vga_cursor16_end[end][saved_start]];
#else
                if ( end && (end > 3 || saved_start > end) )
                        if ( end != 0xF && end >= saved_start
                                        && end <= saved_start + 2 )
                                end = 0xE;
                        else
                                end = 0xF;
#endif
           } else {
                start = vga_cursor8_start[end][start];
#ifdef  USE_CURSOR_END_TABLES
                end   = vga_cursor8_end[end][saved_start]];
#else
                if ( end && (end > 3 || saved_start > end)
                         && !(saved_start==6 && end==6) )
                        end = 7;
#endif
           }
        } else {
#endif  /* VGG */
           /* EGA does not allow for character height & does this. */
           if(start > 4)start += 5;
           if(end > 4)end += 5;

        /* adjust end scan line because the last line is specified by
           the cursor end register MINUS 1 on the EGA ... */
        end++;

        /* on the EGA, cursors extending to the bottom of the character
           matrix are achieved by setting the end register to 0 ... */

        if (start != 0 && end >= char_height)
            end = 0;

        /* this last bit defies any explanation, but it is what the
           IBM BIOS does ... */
        if ((end - start) == 0x10)
            end++;
#ifdef VGG
    }
#endif
    }

    /* actually set the EGA registers */
    sure_sub_note_trace2(CURSOR_VERBOSE,"ega_cur mode start %d end %d", start,end);
    do_outb(EGA_CRTC_INDEX, R10_CURS_START, (IU8)start);
    do_outb(EGA_CRTC_INDEX, R11_CURS_END, (IU8)end);

    /*
     * Update BIOS data variables
     */

    sas_storew_no_check((sys_addr)VID_CURMOD, getCX());
    setAH(0);
#endif  //NEC_98
}

/* This routine is an approximate conversion of the corresponding IBM BIOS routine.
 * I don't think the IBM version works either.
 */
static void ega_emul_set_palette IFN0()
{
#ifndef NEC_98
        sys_addr save_table;
        half_word work_BL;
        byte temp;

        save_table = follow_ptr( follow_ptr(EGA_SAVEPTR)+PALETTE_OFFSET);
/* setup attribute chip - NB need to do an inb() to clear the address */
        inb(EGA_IPSTAT1_REG,&temp);
        work_BL = getBL();
        if(getBH() == 0)
        {
                sas_store_no_check(vd_crt_palette, (IU8)((sas_hw_at_no_check(vd_crt_palette) & 0xe0) | (work_BL & 0x1f)));
           work_BL = (work_BL & 7) | ((work_BL<<1) & 0x10);
           if(!alpha_num_mode())
           {
                /* set Palette 0 (the background) */
                outb(EGA_AC_INDEX_DATA,0);
                outb(EGA_AC_INDEX_DATA,work_BL);
                        if(save_table)
                                sas_store_no_check(save_table, work_BL);
           }
        /* set the overscan register (the border) */
           outb(EGA_AC_INDEX_DATA,17);
           outb(EGA_AC_INDEX_DATA,work_BL);
                if(save_table)
                        sas_store_no_check(save_table+16, work_BL);

        /* Now set BL as if we came in with BH = 1 */
                work_BL = (sas_hw_at_no_check(vd_crt_palette) & 0x20)>>5;
        }

/* Now do BH = 1 stuff. */
        if(!alpha_num_mode())
        {
                sas_store_no_check(vd_crt_palette, (IU8)((sas_hw_at_no_check(vd_crt_palette) & 0xdf) | ((work_BL<<5) & 0x20)));
                work_BL = work_BL | (sas_hw_at_no_check(vd_crt_palette) & 0x10) | 2;
           outb(EGA_AC_INDEX_DATA,1);
           outb(EGA_AC_INDEX_DATA,work_BL);
                if(save_table)
                        sas_store_no_check(save_table+16, work_BL);
           work_BL += 2;
           outb(EGA_AC_INDEX_DATA,2);
           outb(EGA_AC_INDEX_DATA,work_BL);
                if(save_table)
                        sas_store_no_check(save_table+16, work_BL);
           work_BL += 2;
           outb(EGA_AC_INDEX_DATA,3);
           outb(EGA_AC_INDEX_DATA,work_BL);
                if(save_table)
                        sas_store_no_check(save_table+16, work_BL);
        }
        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);    /* re-enable video */
#endif  //NEC_98
}

static void ega_set_palette IFN0()
{
#ifndef NEC_98
        IU8 i;
        byte temp;
        sys_addr save_table, palette_table;
        half_word old_mask;

        save_table = follow_ptr( follow_ptr(EGA_SAVEPTR)+PALETTE_OFFSET);
/* setup attribute chip - NB need to do an inb() to clear the address */
        inb(EGA_IPSTAT1_REG,&temp);
        switch (getAL())
        {
                case 0:
                        outb(EGA_AC_INDEX_DATA,getBL());
                        outb(EGA_AC_INDEX_DATA,getBH());
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        if(save_table)
                                sas_store_no_check(save_table + getBL(), getBH());
                        break;
                case 1:
                        outb(EGA_AC_INDEX_DATA,17);     /* the border colour register */
                        outb(EGA_AC_INDEX_DATA,getBH());
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        if(save_table)
                                sas_store_no_check(save_table + 16, getBH());
                        break;
                case 2:
                        palette_table = video_effective_addr(getES(),
                                getDX());
                        for(i=0;i<16;i++)
                        {
                                outb(EGA_AC_INDEX_DATA,i);
                                outb(EGA_AC_INDEX_DATA,sas_hw_at_no_check(palette_table+i));
                        }
                        outb(EGA_AC_INDEX_DATA,17);
                        outb(EGA_AC_INDEX_DATA,sas_hw_at_no_check(palette_table+16));
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        if(save_table)
                                for(i=0;i<17;i++)
                                        sas_store_no_check(save_table + i, sas_hw_at_no_check(palette_table+i));
                        break;
                case 3:
/*<REAL_VGA>*/
                /* Select blinking or intensity - bit3 of AR10 */
                        /*inb(EGA_IPSTAT1_REG,&temp);*/
                        outb(EGA_AC_INDEX_DATA,16); /* mode control index */
                        inb(EGA_AC_SECRET,&temp);  /* Old value */
                        outb(EGA_AC_INDEX_DATA,
                                (IU8)((temp & 0xf7) | ((getBL() & 1)<<3)));
                        inb(EGA_IPSTAT1_REG,&temp);
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
/*<REAL_VGA>*/
                        old_mask = bg_col_mask;
                        if (getBL())
                        {
                                bg_col_mask = 0x70;
                                assert0(FALSE,"Blinking not supported");
                                sas_store_no_check(vd_crt_mode, 0x29);
                        }
                        else
                        {
                                bg_col_mask = 0xf0; /* Intensity bit set */
                                sas_store_no_check(vd_crt_mode, 0x09);
                        }

            if ( bg_col_mask != old_mask )
                screen_refresh_required();

                        break;
                default:
#ifdef VGG
                        if (video_adapter == VGA)
                                vga_set_palette();      /* VGA has many more subfuncs */
                        else
                        {
                                assert1(FALSE,"Bad set palette submode %#x",getAL());
                                not_imp();
                        }
#else
                        assert1(FALSE,"Bad set palette submode %#x",getAL());
                        setAL(0);
#endif
                        break;
        }
#endif  //NEC_98
}

GLOBAL void ega_char_gen IFN0()
{
#ifndef NEC_98
        switch (getAL())
        {
                case 3:
                        do_outb(EGA_SEQ_INDEX,3,getBL());
                        break;
                case 0:
                case 0x10:
#ifdef JAPAN
                        // ntraid:mskkbug#3167: works2.5: character corrupted
                        // 11/8/93 yasuho
                        // generate single byte charset for DOS/V
                        // #4247: DOSSHELL,WORKS: screen lines are not enough
                        // 12/14/93 yasuho
                        // In Japanese mode, we don't necessary load_font,
                        // recalc_text and so on.
                        if (!is_us_mode()) {
                        GenerateBitmap();
                                break;
                        }
#endif // JAPAN
                        load_font(video_effective_addr(getES(),getBP()),getCX(),getDX(),getBL(),getBH());
                        if(getAL()==0x10)
                                recalc_text(getBH());

#if defined(NTVDM) && defined(X86GFX)
                        if( getBH()==0x16 )
                                loadNativeBIOSfont( 25 );
                        else if( getBH()==0x14 )
                                loadNativeBIOSfont( 28 );
                        else
                                loadNativeBIOSfont( 50 );
#endif /* NTVDM && X86GFX */
                        break;
                case 1:
                case 0x11:
                        load_font(EGA_CGMN,256,0,getBL(),14);
                        if(getAL()==0x11)
                                recalc_text(14);

#if defined(NTVDM) && defined(X86GFX)
                        loadNativeBIOSfont( 28 );
#endif  /* NTVDM & X86GFX */
                        break;
                case 2:
                case 0x12:
                        load_font(EGA_CGDDOT,256,0,getBL(),8);
                        if(getAL()==0x12)
                                recalc_text(8);

#if defined(NTVDM) && defined(X86GFX)
                        loadNativeBIOSfont( 50 );
#endif  /* NTVDM & X86GFX */
                        break;
#ifdef VGG
                case 4:
                case 0x14:
                        load_font(EGA_HIFONT,256,0,getBL(),16);
                        if(getAL()==0x14)
                                recalc_text(16);

#if defined(NTVDM) && defined(X86GFX)
                        loadNativeBIOSfont( 25 );
#endif  /* NTVDM & X86GFX */
                        break;
#endif  /* VGG */
                case 0x20:
                        sas_storew_no_check(BIOS_EXTEND_CHAR*4,getBP());
                        sas_storew_no_check(BIOS_EXTEND_CHAR*4+2,getES());
                        break;
                case 0x21:
                        sas_storew_no_check(EGA_FONT_INT*4,getBP());
                        sas_storew_no_check(EGA_FONT_INT*4+2,getES());
                        set_graph_font(getCX());
                        break;
                case 0x22:
#if defined(NTVDM) && defined(X86GFX)
#ifdef ARCX86
            if (UseEmulationROM) {
                sas_storew_no_check(EGA_FONT_INT*4,EGA_CGMN_OFF);
                sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
            } else {
                sas_storew_no_check(EGA_FONT_INT*4,nativeFontAddresses[F8x14].off);
                sas_storew_no_check(EGA_FONT_INT*4+2,nativeFontAddresses[F8x14].seg);
            }
#else  /* ARCX86 */
                        sas_storew_no_check(EGA_FONT_INT*4,nativeFontAddresses[F8x14].off);
                        sas_storew_no_check(EGA_FONT_INT*4+2,nativeFontAddresses[F8x14].seg);
#endif /* ARCX86 */
#else
                        sas_storew_no_check(EGA_FONT_INT*4,EGA_CGMN_OFF);
                        sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
#endif  /* NTVDM & X86GFX */
                        set_graph_font(14);
                        break;
                case 0x23:
#if defined(NTVDM) && defined(X86GFX)
#ifdef ARCX86
            if (UseEmulationROM) {
                sas_storew_no_check(EGA_FONT_INT*4,EGA_CGDDOT_OFF);
                sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
            } else {
                sas_storew_no_check(EGA_FONT_INT*4,nativeFontAddresses[F8x8pt1].off);
                sas_storew_no_check(EGA_FONT_INT*4+2,nativeFontAddresses[F8x8pt1].seg);
            }
#else  /* ARCX86 */
                        sas_storew_no_check(EGA_FONT_INT*4,nativeFontAddresses[F8x8pt1].off);
                        sas_storew_no_check(EGA_FONT_INT*4+2,nativeFontAddresses[F8x8pt1].seg);
#endif /* ARCX86 */
#else
                        sas_storew_no_check(EGA_FONT_INT*4,EGA_CGDDOT_OFF);
                        sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
#endif  /* NTVDM & X86GFX */
                        set_graph_font(8);
                        break;
#ifdef VGG
                case 0x24:
#if defined(NTVDM) && defined(X86GFX)
#ifdef ARCX86
            if (UseEmulationROM) {
                sas_storew_no_check(EGA_FONT_INT*4,EGA_HIFONT_OFF);
                sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
            } else {
                sas_storew_no_check(EGA_FONT_INT*4,nativeFontAddresses[F8x16].off);
                sas_storew_no_check(EGA_FONT_INT*4+2,nativeFontAddresses[F8x16].seg);
            }
#else  /* ARCX86 */
                        sas_storew_no_check(EGA_FONT_INT*4,nativeFontAddresses[F8x16].off);
                        sas_storew_no_check(EGA_FONT_INT*4+2,nativeFontAddresses[F8x16].seg);
#endif /* ARCX86 */
#else
                        sas_storew_no_check(EGA_FONT_INT*4,EGA_HIFONT_OFF);
                        sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
#endif  /* NTVDM & X86GFX */
                        set_graph_font(16);
                        break;
#endif
                case 0x30:
                        setCX(sas_hw_at_no_check(ega_char_height));
                        setDL(sas_hw_at_no_check(vd_rows_on_screen));
                        switch (getBH())
                        {
                                case 0:
                                        setBP(sas_w_at_no_check(BIOS_EXTEND_CHAR*4));
                                        setES(sas_w_at_no_check(BIOS_EXTEND_CHAR*4+2));
                                        break;
                                case 1:
                                        setBP(sas_w_at_no_check(EGA_FONT_INT*4));
                                        setES(sas_w_at_no_check(EGA_FONT_INT*4+2));
                                        break;

#if defined(NTVDM) && defined(X86GFX)

/* ntdetect.com gets the font info from real card on NT boot. VDM reads it into
 * array 'nativeFontAddresses'. Return these fonts as Insignia ROM not loaded.
 */
#ifdef ARCX86
                                case 2:
                    if (UseEmulationROM)  {
                        setBP(EGA_CGMN_OFF);
                        setES(EGA_SEG);
                    } else {
                        setBP(nativeFontAddresses[F8x14].off);
                        setES(nativeFontAddresses[F8x14].seg);
                    }
                                        break;
                                case 3:
                    if (UseEmulationROM)  {
                        setBP(EGA_CGDDOT_OFF);
                        setES(EGA_SEG);
                    } else {
                        setBP(nativeFontAddresses[F8x8pt1].off);
                        setES(nativeFontAddresses[F8x8pt1].seg);
                    }
                                        break;
                                case 4:
                    if (UseEmulationROM)  {
                        setBP(EGA_INT1F_OFF);
                        setES(EGA_SEG);
                    } else {
                        setBP(nativeFontAddresses[F8x8pt2].off);
                        setES(nativeFontAddresses[F8x8pt2].seg);
                    }
                                        break;
                                case 5:
                    if (UseEmulationROM)  {
                        setBP(EGA_CGMN_FDG_OFF);
                        setES(EGA_SEG);
                    } else {
                        setBP(nativeFontAddresses[F9x14].off);
                        setES(nativeFontAddresses[F9x14].seg);
                    }
                                        break;
                                case 6:
                    if (UseEmulationROM)  {
                        setBP(EGA_HIFONT_OFF);
                        setES(EGA_SEG);
                    } else {
                        setBP(nativeFontAddresses[F8x16].off);
                        setES(nativeFontAddresses[F8x16].seg);
                    }
                                        break;
                                case 7:
                    if (UseEmulationROM)  {
                        setBP(EGA_HIFONT_OFF);
                        setES(EGA_SEG);
                    } else {
                        setBP(nativeFontAddresses[F9x16].off);
                        setES(nativeFontAddresses[F9x16].seg);
                    }
                                        break;
#else  /* ARCX86 */
                                case 2:
                                        setBP(nativeFontAddresses[F8x14].off);
                                        setES(nativeFontAddresses[F8x14].seg);
                                        break;
                                case 3:
                                        setBP(nativeFontAddresses[F8x8pt1].off);
                                        setES(nativeFontAddresses[F8x8pt1].seg);
                                        break;
                                case 4:
                                        setBP(nativeFontAddresses[F8x8pt2].off);
                                        setES(nativeFontAddresses[F8x8pt2].seg);
                                        break;
                                case 5:
                                        setBP(nativeFontAddresses[F9x14].off);
                                        setES(nativeFontAddresses[F9x14].seg);
                                        break;
                                case 6:
                                        setBP(nativeFontAddresses[F8x16].off);
                                        setES(nativeFontAddresses[F8x16].seg);
                                        break;
                                case 7:
                                        setBP(nativeFontAddresses[F9x16].off);
                                        setES(nativeFontAddresses[F9x16].seg);
                                        break;
#endif /* ARCX86 */

#else   /* NTVDM & X86GFX */

                                case 2:
                                        setBP(EGA_CGMN_OFF);
                                        setES(EGA_SEG);
                                        break;
                                case 3:
                                        setBP(EGA_CGDDOT_OFF);
                                        setES(EGA_SEG);
                                        break;
                                case 4:
                                        setBP(EGA_INT1F_OFF);
                                        setES(EGA_SEG);
                                        break;
                                case 5:
                                        setBP(EGA_CGMN_FDG_OFF);
                                        setES(EGA_SEG);
                                        break;

#ifdef VGG
                                case 6:
                                case 7:
                                        setBP(EGA_HIFONT_OFF);
                                        setES(EGA_SEG);
                                        break;
#endif  /* VGG */
#endif  /* NTVDM & X86GFX */
                                default:
                                        assert2(FALSE,"Illegal char_gen subfunction %#x %#x",getAL(),getBH());
                        }
                        break;
                default:
                        assert1(FALSE,"Illegal char_gen %#x",getAL());
        }
#endif  //NEC_98
}

static void ega_alt_sel IFN0()
{
#ifndef NEC_98
        switch (getBL())
        {
           case 0x10:
                setBH( (UCHAR)(get_EGA_disp()) );
                setBL( (UCHAR)(get_EGA_mem()) );
                setCH( (UCHAR)(get_EGA_feature()) );
                setCL( (UCHAR)(get_EGA_switches()) );
                break;
           case 0x20:
        /* Was "enable Print Screen that can do variables lines on screen."
         * This PC/XT bug fix function is redundant on PC/AT's and
         * is removed by BCN3330 -- it has been broken since BCN101.
         */
                assert1(FALSE,"Illegal alt_sel %#x",getBL());
                setAL(0);       /* A function we don't support */
                break;
           default:
#ifdef VGG
                if (video_adapter == VGA)
                    vga_func_12();      /* Try extra VGA stuff */
                else
#endif
                {
                    setAL(0);   /* A function we don't support */
                    assert1(FALSE,"Illegal alt_sel %#x",getBL());
                }
        }
#endif  //NEC_98
}


/*
7.INTERMODULE INTERFACE IMPLEMENTATION :

/*
[7.1 INTERMODULE DATA DEFINITIONS]                              */
/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]                         */

void ega_video_init IFN0()
{
#ifndef NEC_98
        EQUIPMENT_WORD equip_flag;

        /*
         * ESTABLISH EQUIPMENT WORD INITIAL VIDEO MODE FIELD.
         *
         * This field will already have been initialised by this stage
         * to 00(binary) from the corresponding field of the CMOS equipment
         * byte; in that context 00(binary) meant 'primary display has its
         * own BIOS'.
         *
         * However, 00(binary) is not meaningful as the initial mode field
         * and must be updated at this point to 10(binary) for 80X25 colour.
         */
        equip_flag.all = sas_w_at_no_check(EQUIP_FLAG);
        equip_flag.bits.video_mode = VIDEO_MODE_80X25_COLOUR;
        sas_storew_no_check(EQUIP_FLAG, equip_flag.all);

#if !defined(NTVDM) || ( defined(NTVDM) && !defined(X86GFX) ) || defined(ARCX86)
#ifdef ARCX86
    if (UseEmulationROM)
#endif
    {
    /* Initialize the INTs */
        sas_storew_no_check(BIOS_EXTEND_CHAR*4, EGA_INT1F_OFF);
        sas_storew_no_check(BIOS_EXTEND_CHAR*4+2, EGA_SEG);
        sas_move_bytes_forward(BIOS_VIDEO_IO*4, 0x42*4, 4); /* save old INT 10 as INT 42 */
        sas_storew_no_check(BIOS_VIDEO_IO*4, EGA_ENTRY_OFF);
        sas_storew_no_check(BIOS_VIDEO_IO*4+2, EGA_SEG);

    /* Now set up the EGA BIOS variables */
        if (video_adapter == VGA)
            sas_storew_no_check(EGA_SAVEPTR,VGA_PARMS_OFFSET);
        else
            sas_storew_no_check(EGA_SAVEPTR,EGA_PARMS_OFFSET);
        sas_storew_no_check(EGA_SAVEPTR+2,EGA_SEG);
    }
#endif  /* !NTVDM | (NTVDM & !X86GFX) | ARCX86 */
#if defined(NTVDM) && defined(X86GFX)
    sas_store_no_check(ega_info,0x60); /* Clear on mode change, 256K, EGA active, emulate cursor */
#else
#ifdef V7VGA
        if ( video_adapter == VGA )
                sas_store_no_check(ega_info, 0x70);   /* Clear on mode change, 256K, Extensions allowed, EGA active, emulate cursor */
        else
                sas_store_no_check(ega_info, 0x60);   /* Clear on mode change, 256K, EGA active, emulate cursor */
#else   /* V7VGA  -- Macs don't have V7 */
        sas_store_no_check(ega_info, 0x60);   /* Clear on mode change, 256K, EGA active, emulate cursor */
#endif /* V7VGA */

#endif /* NTVDM & X86GFX */
#if !(defined(NTVDM) && defined(X86GFX))
        /* Some VGA cards eg ET4000, store info here needed for sync.
         * Inherit that info from page 0 copy.
         */
        sas_store_no_check(ega_info3, 0xf9);  /* feature bits = 0xF, EGA installed, use 8*14 font */
#endif


#ifdef VGG
        set_VGA_flags(S400 | VGA_ACTIVE);
#endif

/* Set the default mode */
        ega_set_mode();
#endif  //NEC_98
}

void ega_video_io IFN0()
{

#ifndef NEC_98

#if defined(NTVDM) && !defined(X86GFX)
    if (stream_io_enabled && getAH()!= 0x0E &&  getAX() != 0x13FF)
        disable_stream_io();
#endif


    /*
     * The type of operation is coded into the AH register.  Some PC code
     * calls AH functions that are for other even more advanced cards - so we
     * ignore these.
     */

#ifdef V7VGA
#define check_video_func(AH)    ((AH >= 0 && AH < EGA_FUNC_SIZE) || (AH == 0x6f && video_adapter == VGA))
#else
#define check_video_func(AH)    (AH >= 0 && AH < EGA_FUNC_SIZE)
#endif

    if (getAH() != 0xff)
        assert1(check_video_func(getAH()),"Illegal EGA VIO:%#x",getAH());
    if (check_video_func(getAH()))
    {
                IDLE_video();   /* add video anti-idle indicator */
#ifdef V7VGA
                if (getAH() == 0x6f)
                        v7vga_func_6f();
                else
#endif /* V7VGA */
                        (*ega_video_func[getAH()])();
                setCF(0);
    }
    else
        setCF(1);
#endif  //NEC_98
}

/***** Routines to handle the EGA graphics modes,called from video.c **********/
void ega_graphics_write_char IFN6(int, col, int, row, int, ch,
        int, colour, int, page, int, nchs)
{
#ifndef NEC_98
        sys_addr char_addr;
        register int i;
        int screen_off;
        byte char_height;
        register int scan_length = sas_w_at_no_check(VID_COLS);

        char_height = sas_hw_at_no_check(ega_char_height);
        char_addr = follow_ptr(EGA_FONT_INT*4)+char_height*ch;
        screen_off = page*sas_w_at_no_check(VID_LEN)+row*scan_length*char_height+col;
#ifdef V7VGA
        if ( video_adapter == VGA )
                if (sas_hw_at_no_check(vd_video_mode) == 0x18)
                        colour = v7_mode_64_munge[colour&3];
#endif /* V7VGA */
        if(colour & 0x80)
                write_ch_xor(char_addr,screen_off,colour,nchs,scan_length);
        else
                write_ch_set(char_addr,screen_off,colour,nchs,scan_length);

#ifndef REAL_VGA
        nchs--;

        if( nchs )
        {
                for(i=char_height;i>0;i--)
                {
                        (*update_alg.mark_fill)( screen_off, screen_off + nchs );
                        screen_off += scan_length;
                }
        }
        else
        {
                for(i=char_height;i>0;i--)
                {
                        (*update_alg.mark_byte)(screen_off);
                        screen_off += scan_length;
                }
        }
#endif
#endif  //NEC_98
}

void ega_write_dot IFN4(int, colour, int, page, int, pixcol, int, row)
{
#ifndef NEC_98
        register int screen_off,pixmask,setmask,colourmask,temp;

        screen_off = page*sas_w_at_no_check(VID_LEN)+(row*sas_w_at_no_check(VID_COLS)&0xFFFF)+pixcol/8;
        pixmask = 0x80 >>  (pixcol&7);

#ifndef REAL_VGA

        temp = pixmask << 8;
        pixmask |= temp;
        temp = pixmask << 16;
        pixmask |= temp;

#ifdef V7VGA
        if ( video_adapter == VGA )
                if (sas_hw_at_no_check(vd_video_mode) == 0x18)
                        colour = v7_mode_64_munge[colour&3];
#endif /* V7VGA */

        colourmask = sr_lookup[colour & 0xf];

        setmask = pixmask & colourmask;

        if( colour & 0x80 )
        {
                /* XOR pixel */

                temp = *( (unsigned int *) EGA_planes + screen_off );
                *( (unsigned int *) EGA_planes + screen_off ) = temp ^ setmask;
        }
        else
        {
                /* set/clear pixel */

                temp = *( (unsigned int *) EGA_planes + screen_off );
                temp &= ~pixmask;
                *( (unsigned int *) EGA_planes + screen_off ) = ( temp | setmask );
        }

        /* Get the screen updated */

        (*update_alg.mark_byte)(screen_off);
#else
        vga_card_w_dot(screen_off, pixmask, colour);
#endif
#endif  //NEC_98
}

void ega_sensible_graph_scroll_up IFN6(int, row,
        int, col, int, rowsdiff, int, colsdiff, int, lines, int, attr)
{
#ifndef NEC_98
        register int col_incr = sas_w_at_no_check(VID_COLS);
        register int i,source,dest;
        byte char_height;
        boolean screen_updated;

        char_height = sas_hw_at_no_check(ega_char_height);
        dest = sas_w_at_no_check(VID_ADDR)+row*col_incr*char_height+col;
        rowsdiff *= char_height;
        lines *= char_height;
        source = dest+lines*col_incr;
#ifdef REAL_VGA
        vga_card_scroll_up(source, dest, rowsdiff, colsdiff, lines, attr, col_incr);
#else
        screen_updated = (col+colsdiff) <= col_incr;  /* Check for silly scroll */

        if(screen_updated)
                screen_updated = (*update_alg.scroll_up)(dest,colsdiff,rowsdiff,attr,lines,0);

        for(i=0;i<rowsdiff-lines;i++)
        {
                memcpy(&EGA_planes[dest<<2],&EGA_planes[source<<2],colsdiff<<2);

                if(!screen_updated)
                        (*update_alg.mark_string)(dest, dest+colsdiff-1);
                source += col_incr;
                dest += col_incr;
        }

        attr = sr_lookup[attr & 0xf];

        while(lines--)
        {
                memset4( attr, (ULONG *)&EGA_planes[dest<<2], colsdiff );

                if(!screen_updated)
                        (*update_alg.mark_fill)(dest, dest+colsdiff-1);

                dest += col_incr;
        }
#endif
#endif  //NEC_98
}

void ega_sensible_graph_scroll_down IFN6(int, row,
        int, col, int, rowsdiff, int, colsdiff, int, lines, int, attr)
{
#ifndef NEC_98
        register int col_incr = sas_w_at_no_check(VID_COLS);
        register int i,source,dest;
        byte char_height;
        boolean screen_updated;

        char_height = sas_hw_at_no_check(ega_char_height);
        dest = sas_w_at_no_check(VID_ADDR)+row*col_incr*char_height+col;
        rowsdiff *= char_height;
        lines *= char_height;
#ifdef REAL_VGA
        dest += rowsdiff*col_incr-1; /* Last byte in destination */
        source = dest-lines*col_incr;
        vga_card_scroll_down(source, dest, rowsdiff, colsdiff, lines, attr, col_incr);
#else
        screen_updated = (col+colsdiff) <= col_incr;  /* Check for silly scroll */
        if(screen_updated)
                screen_updated = (*update_alg.scroll_down)(dest,colsdiff,rowsdiff,attr,lines,0);
        dest += (rowsdiff-1)*col_incr; /* First byte in last row of dest */
        source = dest-lines*col_incr;

        for(i=0;i<rowsdiff-lines;i++)
        {
                memcpy(&EGA_planes[dest<<2],&EGA_planes[source<<2],colsdiff<<2);

                if(!screen_updated)
                        (*update_alg.mark_string)(dest, dest+colsdiff-1);
                source -= col_incr;
                dest -= col_incr;
        }

        attr = sr_lookup[attr & 0xf];

        while(lines--)
        {
                memset4( attr, (ULONG *)&EGA_planes[dest<<2], colsdiff );

                if(!screen_updated)
                        (*update_alg.mark_fill)(dest, dest+colsdiff-1);

                dest -= col_incr;
        }
#endif
#endif  //NEC_98
}

/* This is called from vga_video.c as well. */
void search_font IFN2(char *, the_char,int, height)
{
#ifndef NEC_98
        register int i;
        register host_addr scratch_addr;
        register sys_addr font_addr;

        font_addr = follow_ptr(4*EGA_FONT_INT);
        scratch_addr = sas_scratch_address(height);
        for(i=0;i<256;i++)
        {
                sas_loads(font_addr, scratch_addr, height);
                if(memcmp(scratch_addr,the_char,height) == 0)
                        break;
                font_addr += height;
        }
        if(i<256)
                setAL((UCHAR)i);
        else
                setAL(0); /* Didn't find a character */
#endif  //NEC_98
}

void ega_read_attrib_char IFN3(int, col, int, row, int, page)
{
#ifndef NEC_98
        byte the_char[256], char_height;
        int screen_off;
        int i, data;

        char_height = sas_hw_at_no_check(ega_char_height);
        screen_off = page*sas_w_at_no_check(VID_LEN)+row*sas_w_at_no_check(VID_COLS)*char_height+col;
        /*
         * Load up the screen character into the_char.
         * We are looking for non-zero pixels, so OR all the planes together
         */
#ifndef REAL_VGA
        for(i=0;i<char_height;i++)
        {
                data = *( (unsigned int *) EGA_planes + screen_off );
                data = ( data >> 16 ) | data;
                the_char[i] = ( data >> 8 ) | data;
                screen_off += sas_w_at_no_check(VID_COLS);
        }
#else
        vga_card_read_ch(screen_off, sas_w_at_no_check(VID_COLS), char_height, the_char);
#endif
        /* Now search the font */
        search_font((char *)the_char,(int)char_height);
#endif  //NEC_98
}
void ega_read_dot IFN3(int, page, int, col, int, row)
{
#ifndef NEC_98
        int screen_off;
        int shift;
        unsigned int data;
        byte val;
        byte mask;
#ifdef  REAL_VGA
        extern half_word vga_card_read_dot();
#endif


        /*
         * The following fixes a bug in print screen from DOS shell.
         * There is a bug in DOS shell that results in -1 and -2 being
         * passed through for the row.  Ignoring these values stops
         * SoftPC falling over.
         */

        if (row & 0x8000)
                return;

        screen_off = page*sas_w_at_no_check(VID_LEN)+row*sas_w_at_no_check(VID_COLS)+(col/8);
        /*
         * The value to return is calculated as:
         * val = plane0 | plane1*2**1 | plane2*2**2 | plane3*2**3
         * The masked-out bit from each plane must therefore be
         * shifted right to bit 0 (note it may already be there)
         * and then shifted up again by the appropriate amount for
         * each plane.
         */

        mask = 0x80 >> (col & 7);
        shift = 7 - (col & 7);

#ifndef REAL_VGA

        data = *((unsigned int *) EGA_planes + screen_off );

        val = ((data >> 24) & mask) >> shift;
        val |= (((data >> 16) & mask) >> shift) << 1;
        val |= (((data >> 8) & mask) >> shift) << 2;
        val |= ((data & mask) >> shift) << 3;

#else
        val = vga_card_read_dot(screen_off, shift);
#endif
        setAL(val);
#endif  //NEC_98
}

/*
 * Routine to grovel around with the fancy EGA mode tables to find the register parameters.
 * This is also called by the mouse driver, because it needs to know where the default
 * EGA register table for the current mode is stored.
 */
sys_addr find_mode_table IFN2(int, mode, sys_addr *, save_addr)
{
        sys_addr params_addr;
#if defined(NEC_98)
        params_addr = 0;
#else   //NEC_98
/*  get address of the SAVEPTR table, and hence the video params table. */
        *save_addr = follow_ptr(EGA_SAVEPTR);
        params_addr = follow_ptr(*save_addr) + mode*EGA_PARMS_SIZE;
/*  If we are modes F or 10, adjust to pick up the 256K EGA parameters */

#ifdef NTVDM
    /* only take real mode number */
    mode &= 0x7F;
#endif
        if(mode == 0xF || mode == 0x10)
                params_addr += 2*EGA_PARMS_SIZE;
#ifdef VGG
        if (video_adapter == VGA)
        {
#ifdef V7VGA
            /* If mode is 0x60+, pick up parameters from 0x1d onwards */
            if (mode >= 0x60)
                params_addr -= 67*EGA_PARMS_SIZE;
            else
            if (mode >= 0x40)
                params_addr -= 25*EGA_PARMS_SIZE;
            else
#endif /* V7VGA */
/*  If we are modes 0x11 - 0x13, pick up parameters from entry 0x1a onwards */
            if(mode == 0x11 || mode == 0x12 || mode == 0x13)
                params_addr += 9*EGA_PARMS_SIZE;
            else if(mode < 4 || mode == 7) /* Alphanumeric mode */
            {
                switch(get_VGA_lines())
                {
                  case S350:    /* EGA-type 350 scanlines */
                        params_addr += 19*EGA_PARMS_SIZE;
                        break;
                  case S400:    /* Real VGA text mode */
                        switch(mode)
                        {
                           case 0:
                           case 1:
                                params_addr += (0x17-mode)*EGA_PARMS_SIZE;
                                break;
                           case 2:
                           case 3:
                                params_addr += (0x18-mode)*EGA_PARMS_SIZE;
                                break;
                           case 7:
                                params_addr += (0x19-mode)*EGA_PARMS_SIZE;
                        }
                  default:      /* 200 scanlines - OK as is. */
                        break;
                }
            }
        }
        else
#endif  /* VGG */
        {               /* EGA */
/*  If modes 0-3, activate enhancement if switches say so */
            if( (get_EGA_switches() & 1) && mode < 4)
                        params_addr += 19*EGA_PARMS_SIZE;
        }

#if defined(NTVDM) && defined(X86GFX)
        /*
        * Tim August 92, Microsoft.
        * Make text modes (0-3) use our mode parameters in KEYBOARD.SYS
        * Three entries in table: 40x25, 80x25 & 80x25 mono
        * Make that 4 - add font load mode B. We have to be defensive in
        * case of dubious values from cards or m/c. (Pro II/EISA, Olivetti MP)
        * Table order: 40x25, 80x25, mono, font
        */
        {
                extern word babyModeTable;
                extern UTINY tempbabymode[];

                if(babyModeTable == 0)    /* ntio not loaded - use temp table */
                {
                    if (!soft_reset)       /* be absolutely sure about this */
                    {
                        /* magic location:good until 16 bit code is running */
                        sas_stores(0x41000, tempbabymode, 2 * EGA_PARMS_SIZE);
                        if (mode == 0xb)
                            params_addr = 0x41000 + EGA_PARMS_SIZE;
                        else
                            params_addr = 0x41000;  /* if not mode 3 tough */
                        return params_addr;
                    }
#ifndef PROD
                    else
                        printf("NTVDM:video window parm table not loaded but system initialised\n");
#endif
                }
                if(babyModeTable > 0)
                {
                    if (get_VGA_lines() == S350 && mode < 4)
                    {
                        if (mode < 2)
                            params_addr = babyModeTable + 4*EGA_PARMS_SIZE;
                        else
                            params_addr = babyModeTable + 5*EGA_PARMS_SIZE;
                    }
                    else
                    {
                        if (mode < 4)
                        {
                            mode = mode/2;
                                params_addr = babyModeTable + mode*EGA_PARMS_SIZE;
                        }
                        else
                        {
                            if (mode == 0xb)
                                params_addr = babyModeTable + 3 * EGA_PARMS_SIZE;
                            else if (mode == 7) /* skip first 2 table entries */
                                params_addr = babyModeTable + 2 * EGA_PARMS_SIZE;
                        }
                    }
                }
        }
#endif  /* NTVDM & X86GFX */

#endif  //NEC_98
        return params_addr;
}

/*
 * Calculate how many scanlines are currently displayed, and return a code:
 * RS200: 200 scanlines
 * RS350: 350 scanlines
 * RS400: 400 scanlines
 * RS480: 480 scanlines
 *
 * Different numbers of scanlines are returned as the code corresonding
 * to the nearest kosher scanline number.
 */

int get_scanlines IFN0()
{
        int scanlines,res;
#if defined(NEC_98)
        res = 0;
#else   //NEC_98

        scanlines = sas_hw_at_no_check(ega_char_height) * sas_hw_at_no_check(vd_rows_on_screen);

        if(scanlines <= 275)
                res = RS200;
        else if(scanlines <=375)
                res = RS350;
        else if(scanlines <= 440)
                res = RS400;
        else
                res = RS480;

#endif  //NEC_98
        return (res);
}

#endif /* EGG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\ga_glue.c ===
#include "insignia.h"
#include "host_def.h"

/*
 * SoftPC Revision 3.0
 *
 * Title		:	ga_glue.c
 *
 * Description	: 	Glue to fit an a2cpu to 3.0 GA graphics
 *			Also used for later C CPUs which use the 2.0
 *			video interface.
 *
 * Author	: John Shanly
 *
 * Notes	:
 *
 */

/*
 *	static char SccsID[] = "@(#)ga_glue.c	1.14 12/17/93 Copyright Insignia Solutions Ltd.";
 */

#ifdef C_VID

#include "xt.h"
#include CpuH
#include "sas.h"
#include "gvi.h"
#include "gmi.h"
#include "egacpu.h"
#include "cpu_vid.h"
#include "ga_defs.h"

#include <stdio.h>
#include "trace.h"
#include "debug.h"

#define INTEL_SRC	0
#define HOST_SRC	1

IMPORT READ_POINTERS C_vid_reads;
IMPORT WRT_POINTERS C_vid_writes;

GLOBAL VOID
glue_b_write( addr, val )

UTINY *addr;
ULONG val;

{
	sub_note_trace2( GLUE_VERBOSE,
			"glue_b_write: addr=%x, pe = %x", addr, VGLOBS->plane_enable );

#ifdef CCPU
	EasVal = val;
	Ead = (ULONG) addr - gvi_pc_low_regen;
#else
	UNUSED(val);
	
	EasVal = *addr;
	Ead = (ULONG) addr - (ULONG) get_byte_addr(gvi_pc_low_regen);
#endif /* CCPU */

	(*C_vid_writes.b_write)( EasVal, Ead );
}

GLOBAL VOID
glue_w_write( addr, val )

UTINY *addr;
ULONG val;

{
	sub_note_trace2( GLUE_VERBOSE,
			"glue_w_write: addr=%x, pe = %x", addr, VGLOBS->plane_enable );

#ifdef CCPU
	EasVal = val;
	Ead = (ULONG) addr - gvi_pc_low_regen;
#else
	UNUSED(val);
	
	EasVal = *addr | ( *(addr+1) << 8 );
	Ead = (ULONG) addr - (ULONG) get_byte_addr(gvi_pc_low_regen);
#endif /* CCPU */

	(*C_vid_writes.w_write)( EasVal, Ead );
}


#ifndef	NO_STRING_OPERATIONS

GLOBAL VOID
glue_b_fill( laddr, haddr, val )

UTINY *laddr, *haddr;
ULONG val;

{
	sub_note_trace3( GLUE_VERBOSE,
		"glue_b_fill: laddr=%x, haddr=%x, pe = %x", laddr, haddr, VGLOBS->plane_enable );

	Count = haddr - laddr + 1;

#ifdef CCPU
	Ead = (ULONG) laddr - gvi_pc_low_regen;
	EasVal = val;
#else
	UNUSED(val);
	
	Ead = (ULONG) laddr - (ULONG) get_byte_addr(gvi_pc_low_regen);
	EasVal = *laddr;
#endif /* CCPU */

	(*C_vid_writes.b_fill)( EasVal, Ead, Count );
}

GLOBAL VOID
glue_w_fill( laddr, haddr, val )

UTINY *laddr, *haddr;
ULONG val;

{
	sub_note_trace3( GLUE_VERBOSE,
		"glue_w_fill: laddr=%x, haddr=%x, pe = %x", laddr, haddr, VGLOBS->plane_enable );

	Count = haddr - laddr + 1;

#ifdef CCPU
	Ead = (ULONG) laddr - gvi_pc_low_regen;
	EasVal = val;
#else
	UNUSED(val);
	
	Ead = (ULONG) laddr - (ULONG) get_byte_addr(gvi_pc_low_regen);
	EasVal = *laddr | ( *(laddr+1) << 8 );
#endif /* CCPU */

	(*C_vid_writes.w_fill)( EasVal, Ead, Count );
}

GLOBAL VOID
glue_b_move( laddr, haddr, src, src_type )

UTINY *laddr, *haddr, *src, src_type;

{
	sub_note_trace3( GLUE_VERBOSE,
		"glue_b_move: laddr=%x, haddr=%x, pe = %x", laddr, haddr, VGLOBS->plane_enable );

	Count = haddr - laddr + 1;

#ifdef CCPU
	Ead = (ULONG) laddr - gvi_pc_low_regen;
	EasVal = (ULONG) src;
#else
	UNUSED(src);
	UNUSED(src_type);
	
	Ead = (ULONG) laddr - (ULONG) get_byte_addr(gvi_pc_low_regen);
	EasVal = (ULONG) haddr_of_src_string - Count + 1;
#endif /* CCPU */

#ifdef CCPU
	if(( src_type == HOST_SRC )
			|| ( EasVal < (ULONG) gvi_pc_low_regen ) || ((ULONG) gvi_pc_high_regen < EasVal ))
#else
	if(( EasVal < (ULONG) get_byte_addr(gvi_pc_low_regen) ) || ((ULONG) get_byte_addr(gvi_pc_high_regen) < EasVal ))
#endif /* CCPU */
	{
		/* Ram source */

		V1 = 0;
#ifdef CCPU
		/*
		 * This looks like a deliberate hack to pass an intel address
		 * in a host pointer.  Hence I've added a cast to the
		 * get_byte_addr call to remove an ANSI warning.  (Mike).
		 */

		if( src_type == INTEL_SRC )
			EasVal = (ULONG) get_byte_addr((PHY_ADDR)src);	/* Staging post eliminated */
#else
		EasVal = (ULONG) laddr;						/* Staging post hack */
#endif /* CCPU */
	}
	else
	{
		/* VGA source */

		V1 = 1;
#ifdef CCPU
		EasVal -= (ULONG) gvi_pc_low_regen;
#else
		EasVal -= (ULONG) get_byte_addr(gvi_pc_low_regen);
#endif /* CCPU */
	}

	if( getDF() )
	{
		Ead += Count - 1;
		EasVal += Count - 1;
		(*C_vid_writes.b_bwd_move)( Ead, EasVal, Count, V1 );
	}
	else
		(*C_vid_writes.b_fwd_move)( Ead, EasVal, Count, V1 );
}

GLOBAL VOID
glue_w_move( laddr, haddr, src )

UTINY *laddr, *haddr, *src;

{
	sub_note_trace3( GLUE_VERBOSE,
		"glue_w_move: laddr=%x, haddr=%x, pe = %x", laddr, haddr, VGLOBS->plane_enable );

	Count = ( haddr - laddr + 1 ) >> 1;

#ifdef CCPU
	Ead = (ULONG) laddr;
	EasVal = (ULONG) src;
#else
	UNUSED(src);
	
	Ead = (ULONG) laddr - (ULONG) get_byte_addr(gvi_pc_low_regen);
	EasVal = (ULONG) haddr_of_src_string - ( Count << 1 ) + 1;
#endif /* CCPU */


#ifdef CCPU
	if(( EasVal < (ULONG) gvi_pc_low_regen ) || ((ULONG) gvi_pc_high_regen < EasVal ))
#else
	if(( EasVal < (ULONG) get_byte_addr(gvi_pc_low_regen) ) || ((ULONG) get_byte_addr(gvi_pc_high_regen) < EasVal ))
#endif /* CCPU */
	{
		/* Ram source */

		V1 = 0;
#ifdef CCPU
		EasVal = (ULONG ) get_byte_addr((PHY_ADDR)laddr);	/* Staging post hack */
#else
		EasVal = (ULONG) laddr;					/* Staging post hack */
#endif /* CCPU */
	}
	else
	{
		/* VGA source */

		V1 = 1;
#ifdef CCPU
		EasVal -= (ULONG) gvi_pc_low_regen;
#else
		EasVal -= (ULONG) get_byte_addr(gvi_pc_low_regen);
#endif /* CCPU */
	}

	if( getDF() )
	{
		Ead += ( Count << 1 ) - 2;
		EasVal += ( Count << 1 ) - 2; 
		(*C_vid_writes.w_bwd_move)( Ead, EasVal, Count, V1 );
	}
	else
		(*C_vid_writes.w_fwd_move)( Ead, EasVal, Count, V1 );
}


#endif	/* NO_STRING_OPERATIONS */


/**/


GLOBAL ULONG
glue_b_read( addr )

UTINY *addr;

{
	sub_note_trace2( GLUE_VERBOSE,
		"glue_b_read: addr=%x, shift = %d", addr, VGLOBS->read_shift_count );

#ifdef CCPU
	EasVal = (ULONG) addr - (ULONG) gvi_pc_low_regen;
#else
	EasVal = (ULONG) addr - (ULONG) get_byte_addr(gvi_pc_low_regen);
#endif /* CCPU */

	(*C_vid_reads.b_read)( EasVal );

#ifdef CCPU
	return( EasVal );
#else
	*addr = EasVal;
	return( 0 );
#endif /* CCPU */
}

GLOBAL ULONG
glue_w_read( addr )

UTINY *addr;

{
	sub_note_trace2( GLUE_VERBOSE,
		"glue_w_read: addr=%x, shift = %d", addr, VGLOBS->read_shift_count );

#ifdef CCPU
	EasVal = (ULONG) addr - (ULONG) gvi_pc_low_regen;
#else
	EasVal = (ULONG) addr - (ULONG) get_byte_addr(gvi_pc_low_regen);
#endif /* CCPU */

	(*C_vid_reads.w_read)( EasVal );

#ifdef CCPU
	return( EasVal );
#else
	*(addr+1) = EasVal >> 8;
	*addr = EasVal;
	return( 0 );
#endif /* CCPU */
}


GLOBAL VOID
glue_str_read( laddr, haddr )

UTINY *laddr, *haddr;

{
	sub_note_trace3( GLUE_VERBOSE,
		"glue_str_read: laddr=%x, haddr=%x, shift = %d",
						laddr, haddr, VGLOBS->read_shift_count );

	Count = haddr - laddr + 1;
#ifdef CCPU
	EasVal = (ULONG) laddr - (ULONG) gvi_pc_low_regen;
#else
	EasVal = (ULONG) laddr - (ULONG) get_byte_addr(gvi_pc_low_regen);
#endif /* CCPU */
	Ead = (ULONG ) laddr;

	(*C_vid_reads.str_read)( (UTINY *)Ead, EasVal, Count );
}

#endif /* C_VID */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\egwrtm12.c ===
#include "insignia.h"
#include "host_def.h"

#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )

/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.


DOCUMENT 			: name and number

RELATED DOCS		: include all relevant references

DESIGNER			: J Maiden

REVISION HISTORY	:
First version		: J Maiden, SoftPC 2.0
Second version		: J Shanly, SoftPC 3.0

SUBMODULE NAME		: write mode 1 and 2

SOURCE FILE NAME	: ega_writem1.c

PURPOSE			: functions to write to EGA memory in write modes 1 & 2
		
		
SccsID = @(#)ega_wrtm12.c	1.20 3/9/94 Copyright Insignia Solutions Ltd.

[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

	INCLUDE FILE : ega_cpu.pi

[1.1    INTERMODULE EXPORTS]

	PROCEDURES() :	
			ega_mode1_chn_b_write();
			ega_mode1_chn_w_write();
			ega_mode1_chn_b_fill();
			ega_mode1_chn_w_fill();
			ega_mode1_chn_b_move();
			ega_mode1_chn_w_move();
			ega_mode2_chn_b_write();
			ega_mode2_chn_w_write();
			ega_mode2_chn_b_fill();
			ega_mode2_chn_w_fill();
			ega_mode2_chn_b_move();
			ega_mode2_chn_w_move();

	DATA 	     :	give type and name

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]

	STRUCTURES/TYPEDEFS/ENUMS:
		
-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
     (not o/s objects or standard libs)


-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

DATA OBJECTS	  :	struct EGA_CPU

FILES ACCESSED    :	NONE

DEVICES ACCESSED  :	NONE

SIGNALS CAUGHT	  :	NONE

SIGNALS ISSUED	  :	NONE


[1.4.2 EXPORTED OBJECTS]

/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]						*/

/* [3.1.1 #INCLUDES]                                                    */


#ifdef EGG

#include	"xt.h"
#include	"debug.h"
#include	"sas.h"
#include	TypesH
#include	CpuH
#include	"gmi.h"
#include	"egacpu.h"
#include	"egaports.h"
#include	"cpu_vid.h"
#include	"gfx_upd.h"

/* [3.1.2 DECLARATIONS]                                                 */


/* [3.2 INTERMODULE EXPORTS]						*/


/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]						*/

/* [5.1.1 #DEFINES]							*/

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#ifdef PROD
#include "SOFTPC_EGA.seg"
#else
#include "SOFTPC_EGA_WRITE.seg"
#endif
#endif

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]			*/


/* [5.1.3 PROCEDURE() DECLARATIONS]					*/


/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS 					*/

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]				*/


/*
7.INTERMODULE INTERFACE IMPLEMENTATION :

/*
[7.1 INTERMODULE DATA DEFINITIONS]				*/

#ifdef A_VID
IMPORT VOID	_ch2_mode1_chn_byte_write_glue();
IMPORT VOID	_ch2_mode1_chn_word_write_glue();
IMPORT VOID	_ch2_mode1_chn_byte_fill_glue();
IMPORT VOID	_ch2_mode1_chn_word_fill_glue();
IMPORT VOID	_ch2_mode1_chn_byte_move_glue();
IMPORT VOID	_ch2_mode1_chn_word_move_glue();

WRT_POINTERS mode1_handlers =
{
	_ch2_mode1_chn_byte_write_glue,
	_ch2_mode1_chn_word_write_glue

#ifndef	NO_STRING_OPERATIONS
	,
	_ch2_mode1_chn_byte_fill_glue,
	_ch2_mode1_chn_word_fill_glue,
	_ch2_mode1_chn_byte_move_glue,
	_ch2_mode1_chn_byte_move_glue,
	_ch2_mode1_chn_word_move_glue,
	_ch2_mode1_chn_word_move_glue

#endif	/* NO_STRING_OPERATIONS */
};

IMPORT VOID	_ch2_mode2_chn_byte_write_glue();
IMPORT VOID	_ch2_mode2_chn_word_write_glue();
IMPORT VOID	_ch2_mode2_chn_byte_fill_glue();
IMPORT VOID	_ch2_mode2_chn_word_fill_glue();
IMPORT VOID	_ch2_mode2_chn_byte_move_glue();
IMPORT VOID	_ch2_mode2_chn_word_move_glue();

WRT_POINTERS mode2_handlers =
{
	_ch2_mode2_chn_byte_write_glue,
	_ch2_mode2_chn_word_write_glue

#ifndef	NO_STRING_OPERATIONS
	,
	_ch2_mode2_chn_byte_fill_glue,
	_ch2_mode2_chn_word_fill_glue,
	_ch2_mode2_chn_byte_move_glue,
	_ch2_mode2_chn_byte_move_glue,
	_ch2_mode2_chn_word_move_glue,
	_ch2_mode2_chn_word_move_glue

#endif	/* NO_STRING_OPERATIONS */
};
#else
VOID	ega_mode1_chn_b_write(ULONG, ULONG);
VOID	ega_mode1_chn_w_write(ULONG, ULONG);
VOID	ega_mode1_chn_b_fill(ULONG, ULONG, ULONG);
VOID	ega_mode1_chn_w_fill(ULONG, ULONG, ULONG);
VOID	ega_mode1_chn_b_move(ULONG, ULONG, ULONG, ULONG);
VOID	ega_mode1_chn_w_move(ULONG, ULONG, ULONG, ULONG);

VOID	ega_mode2_chn_b_write(ULONG, ULONG);
VOID	ega_mode2_chn_w_write(ULONG, ULONG);
VOID	ega_mode2_chn_b_fill(ULONG, ULONG, ULONG);
VOID	ega_mode2_chn_w_fill(ULONG, ULONG, ULONG);
VOID	ega_mode2_chn_b_move IPT4(ULONG, ead, ULONG, eas,
				 ULONG, count, ULONG, src_flag);
VOID	ega_mode2_chn_w_move IPT4(ULONG, ead, ULONG, eas,
				 ULONG, count, ULONG, src_flag);

WRT_POINTERS mode1_handlers =
{
      ega_mode1_chn_b_write,
      ega_mode1_chn_w_write

#ifndef	NO_STRING_OPERATIONS
	  ,
      ega_mode1_chn_b_fill,
      ega_mode1_chn_w_fill,
      ega_mode1_chn_b_move,
      ega_mode1_chn_b_move,
      ega_mode1_chn_w_move,
      ega_mode1_chn_w_move,

#endif	/* NO_STRING_OPERATIONS */

};

WRT_POINTERS mode2_handlers =
{
      ega_mode2_chn_b_write,
      ega_mode2_chn_w_write

#ifndef	NO_STRING_OPERATIONS
	  ,
      ega_mode2_chn_b_fill,
      ega_mode2_chn_w_fill,
      ega_mode2_chn_b_move,
      ega_mode2_chn_b_move,
      ega_mode2_chn_w_move,
      ega_mode2_chn_w_move,

#endif	/* NO_STRING_OPERATIONS */

};
#endif /* A_VID */


GLOBAL VOID
copy_alternate_bytes IFN3(byte *, start, byte *, end, byte *, source)
{
#ifndef NEC_98
	while (start <= end)
	{
		*start = *source;
		start += 4;       /* advance by longs, writing bytes */
		source += 4;
	}
#endif  //NEC_98
}

GLOBAL VOID
fill_alternate_bytes IFN3(byte *, start, byte *, end, byte, value )
{
#ifndef NEC_98
	while( start <= end )
	{
		*start = value;
		start += 4;	/* advance by longs, writing bytes */
	}
#endif  //NEC_98
}

#ifdef  BIGEND
#define first_half(wd)      ((wd & 0xff00) >> 8)
#define sec_half(wd)        (wd & 0xff)
#else
#define first_half(wd)      (wd & 0xff)
#define sec_half(wd)        ((wd & 0xff00) >> 8)
#endif

GLOBAL VOID
fill_both_bytes IFN3(USHORT, data, USHORT *, dest, ULONG, len )
{
#ifndef NEC_98
	USHORT swapped;

#ifdef BIGEND
	swapped = ((data & 0xff00) >> 8) | ((data & 0xff) << 8);
#endif

	if( (ULONG) dest & 1 )
	{
		*((UTINY *) dest) = first_half(data);

		dest = (USHORT *) ((ULONG) dest + 1);
		len--;

		while( len-- )
		{
			*dest = data;
			dest += 2;
		}

		*((UTINY *) dest) = sec_half(data);
	}
	else
	{
		while( len-- )
		{
#ifdef BIGEND
			*dest = swapped;
#else
			*dest = data;
#endif
			dest += 2;
		}
	}
#endif  //NEC_98
}


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_EGA_CHN.seg"
#endif

VOID
ega_mode1_chn_b_write IFN2(ULONG, value, ULONG, offset )
{
#ifndef NEC_98
	ULONG lsb;

	UNUSED(value);
	
	note_entrance0("ega_mode1_chn_b_write");

	lsb = offset & 1;
	offset = (offset >> 1) << 2;

	if( lsb )	/* odd address, in plane 1 or 3 */
	{
		if( getVideoplane_enable() & 2 )
			EGA_plane01[offset + 1] = get_latch1;

		if( getVideoplane_enable() & 8 )
			EGA_plane23[offset + 1] = get_latch3;
	}
	else		/* even address, in plane 0 or 2 */
	{
		if( getVideoplane_enable() & 1 )
			EGA_plane01[offset] = get_latch0;

		if( getVideoplane_enable() & 4 )
			EGA_plane23[offset] = get_latch2;
	}

	update_alg.mark_byte( offset );
#endif  //NEC_98
}

VOID
ega_mode1_chn_w_write IFN2(ULONG, value, ULONG, offset )
{
#ifndef NEC_98
	ULONG lsb;

	UNUSED(value);

	note_entrance0("ega_mode1_chn_w_write");

	lsb = offset & 1;
	offset = (offset >> 1) << 2;

	if( lsb )	/* odd address, low byte in planes 1 and 3 */
	{
		if( getVideoplane_enable() & 2 )
			EGA_plane01[offset + 1] = get_latch1;

		if( getVideoplane_enable() & 1 )
			EGA_plane01[offset + 4] = get_latch0;

		if( getVideoplane_enable() & 8 )
			EGA_plane23[offset + 1] = get_latch3;

		if( getVideoplane_enable() & 4 )
			EGA_plane23[offset + 4] = get_latch2;
	}
	else		/* even address, low byte in planes 0 and 2 */
	{
		if( getVideoplane_enable() & 1 )
			EGA_plane01[offset] = get_latch0;

		if( getVideoplane_enable() & 2 )
			EGA_plane01[offset + 1] = get_latch1;

		if( getVideoplane_enable() & 4 )
			EGA_plane23[offset] = get_latch2;

		if( getVideoplane_enable() & 8 )
			EGA_plane23[offset + 1] = get_latch3;
	}

	update_alg.mark_word( offset );
#endif  //NEC_98
}

/* used by both byte and word mode1 fill */

LOCAL VOID
ega_mode1_chn_fill IFN2(ULONG, offset, ULONG, count )
{
#ifndef NEC_98
	ULONG low_offset;			/* distance into regen buffer of start of write */
	ULONG high_offset;		/* distance into regen buffer of end of write */
	ULONG length;			/* length of fill in bytes */
	ULONG lsb;

	note_entrance0("ega_mode1_chn_fill");

	/*
	 *	Complicated by possibility that only one of a chained pair of
	 *	planes is write enabled, needing alternate bytes to be written.
	 */

	high_offset = offset + count - 1;
	lsb = high_offset & 1;
	high_offset = (high_offset >> 1) << 2;
	high_offset |= lsb;

	low_offset = offset;
	length = count;

	switch( getVideoplane_enable() & 3 )
	{
		case 1:	/* just plane 0, ie even addresses to be written */
			if( offset & 1 )
				low_offset++;

			low_offset = (low_offset >> 1) << 2;
			fill_alternate_bytes( &EGA_plane01[low_offset],
							&EGA_plane01[high_offset], get_latch0 );
			break;

		case 2:	/* just plane 1, ie odd addresses to be written */
			if(( offset & 1 ) == 0 )
				low_offset++;

			low_offset = (low_offset >> 1) << 2;
			fill_alternate_bytes( &EGA_plane01[low_offset],
							&EGA_plane01[high_offset], get_latch1 );
			break;

		case 3:	/* sensible case is to have both chained planes write enabled */
			lsb = low_offset & 1;
			low_offset = (low_offset >> 1) << 2;

			if( lsb )
			{
				EGA_plane01[low_offset + 1] = get_latch1;
				low_offset += 4;
				length--;
			}

			if( length & 1 )
			{
				length -= 1;
				EGA_plane01[low_offset + (length << 1)] = get_latch0;
			}

			fill_both_bytes( get_latch1 | get_latch0 << 8,
							(USHORT *)&EGA_plane01[low_offset], length >> 1 );
			break;
	}	/* end of switch on plane01 enabled */

	low_offset = offset;
	length = count;

	switch( getVideoplane_enable() & 0xc )	/* isolate 2 bits for planes2 and 3 */
	{
		case 4:	/* just plane 2, ie even addresses to be written */
			if( low_offset & 1 )
				low_offset++;

			low_offset = (low_offset >> 1) << 2;
			fill_alternate_bytes( &EGA_plane23[low_offset],
							&EGA_plane23[high_offset], get_latch2 );
			break;

		case 8:	/* just plane 3, ie odd addresses to be written */
			if(( low_offset & 1 ) == 0 )
				low_offset++;

			low_offset = (low_offset >> 1) << 2;
			fill_alternate_bytes( &EGA_plane23[low_offset],
							&EGA_plane23[high_offset], get_latch3 );
			break;

		case 12:	/* sensible case is to have both chained planes write enabled */
			lsb = low_offset & 1;
			low_offset = (low_offset >> 1) << 2;

			if( lsb )
			{
				EGA_plane23[low_offset + 1] = get_latch1;
				low_offset += 4;
				length--;
			}

			if( length & 1 )
			{
				length -= 1;
				EGA_plane23[low_offset + (length << 1)] = get_latch0;
			}

			fill_both_bytes( get_latch1 | get_latch0 << 8,
							(USHORT *)&EGA_plane23[low_offset], length >> 1 );
			break;
	}	/* end of switch on plane23 enabled */
#endif  //NEC_98
}

VOID
ega_mode1_chn_b_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
#ifndef NEC_98
  UNUSED(value);

  note_entrance0("ega_mode1_chn_b_fill");

  ega_mode1_chn_fill( offset, count );
  update_alg.mark_fill( offset, offset + count - 1 );
#endif  //NEC_98
}

VOID
ega_mode1_chn_w_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
#ifndef NEC_98
	UNUSED(value);
	
	note_entrance0("ega_mode1_chn_w_fill");

	ega_mode1_chn_fill( offset, count );
	update_alg.mark_fill( offset, offset + count - 1 );
#endif  //NEC_98
}

LOCAL VOID
ega_mode1_chn_move_vid_src IFN5(ULONG, ead, ULONG, eas, ULONG, count,
	UTINY	*, EGA_plane, ULONG, plane )
{
#ifndef NEC_98
	ULONG end, lsbd, lsbs, dst, src;

	lsbs = eas & 1;
	eas = (eas >> 1) << 2;	
	eas |= lsbs;

	end = ead + count - 1;
	lsbd = end & 1;
	end = (end >> 1) << 2;	
	end |= lsbd;

	lsbd = ead & 1;
	ead = (ead >> 1) << 2;	
	ead |= lsbd;

	if( lsbd != ( plane & 1 ))
	{
		dst = lsbd ? ead + 3 : ead + 1;
		src = lsbs ? eas + 3 : eas + 1;
	}
	else
	{
		dst = ead;
		src = eas;
	}

	copy_alternate_bytes( &EGA_plane[dst], &EGA_plane[end], &EGA_plane[src] );
#endif  //NEC_98
}

GLOBAL VOID
ega_mode1_chn_b_move IFN4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag )
{
#ifndef NEC_98
	note_entrance0("ega_mode1_chn_b_move");

	if( src_flag )
	{
		if( getDF() )
		{
			eas -= count - 1;
			ead -= count - 1;
		}

		if( getVideoplane_enable() & 1 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane01, 0 );

		if( getVideoplane_enable() & 2 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane01, 1 );

		if( getVideoplane_enable() & 4 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane23, 2 );

		if( getVideoplane_enable() & 8 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane23, 3 );
	}
	else	/* source is not in ega memory, it becomes a fill */
	{
		if( getDF() )
			ead -= count - 1;

		ega_mode1_chn_fill( ead, count );
	}

	update_alg.mark_string( ead, ead + count - 1 );
#endif  //NEC_98
}

VOID
ega_mode1_chn_w_move IFN4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag)
{
#ifndef NEC_98
	note_entrance0("ega_mode1_chn_w_move");

	count <<= 1;

	if( src_flag )
	{
		if( getDF() )
		{
			eas -= count - 2;
			ead -= count - 2;
		}

		if( getVideoplane_enable() & 1 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane01, 0 );

		if( getVideoplane_enable() & 2 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane01, 1 );

		if( getVideoplane_enable() & 4 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane23, 2 );

		if( getVideoplane_enable() & 8 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane23, 3 );
	}
	else	/* source is not in ega memory, it becomes a fill */
	{
		if( getDF() )
			ead -= count - 2;

		ega_mode1_chn_fill( ead, count );
	}

	update_alg.mark_string( ead, ead + count - 1 );
#endif  //NEC_98
}

VOID
ega_mode2_chn_b_write IFN2(ULONG, value, ULONG, offset )
{
#ifndef NEC_98
	ULONG	value1;
	ULONG lsb;

	note_entrance0("ega_mode2_chn_b_write");

	lsb = offset & 1;
	offset = (offset >> 1) << 2;

	if( EGA_CPU.fun_or_protection )
	{
		if( lsb )	/* odd address, applies to planes 1 and 3 */
		{
			if( getVideoplane_enable() & 2 )
			{
				value1 = value & 2 ? 0xff : 0;
				EGA_plane01[offset + 1] = (byte) do_logicals( value1, get_latch1 );
			}

			if( getVideoplane_enable() & 8 )
			{
				value1 = value & 8 ? 0xff : 0;
				EGA_plane23[offset + 1] = (byte) do_logicals( value1, get_latch3 );
			}
		}
		else		/* even address, applies to planes 0 and 2 */
		{
			if( getVideoplane_enable() & 1 )
			{
				value1 = value & 1 ? 0xff : 0;
				EGA_plane01[offset] = (byte) do_logicals( value1, get_latch0 );
			}

			if( getVideoplane_enable() & 4 )
			{
				value1 = value & 4 ? 0xff : 0;
				EGA_plane23[offset] = (byte) do_logicals( value1, get_latch2 );
			}
		}
	}
	else	/* no difficult function or protection stuff */
	{
		if( lsb )	/* odd address, applies to planes 1 and 3 */
		{
			if( getVideoplane_enable() & 2 )
				EGA_plane01[offset + 1] = value & 2 ? 0xff : 0;

			if( getVideoplane_enable() & 8 )
				EGA_plane23[offset + 1] = value & 8 ? 0xff : 0;
		}
		else		/* even address, applies to planes 0 and 2 */
		{
			if( getVideoplane_enable() & 1 )
				EGA_plane01[offset] = value & 1 ? 0xff : 0;

			if( getVideoplane_enable() & 8 )
				EGA_plane23[offset] = value & 4 ? 0xff : 0;
		}
	}

	update_alg.mark_byte( offset );
#endif  //NEC_98
}

VOID
ega_mode2_chn_w_write IFN2(ULONG, value, ULONG, offset )
{
#ifndef NEC_98
	ULONG value2;
	ULONG lsb;
	ULONG low, high;

	low = value & 0xff;
	high = value >> 8;

	note_entrance0("ega_mode2_chn_w_write");

	lsb = offset & 1;
	offset = (offset >> 1) << 2;

	if( EGA_CPU.fun_or_protection )
	{
		if( lsb )	/* odd address, low byte in planes 1 and 3 */
		{
			if( getVideoplane_enable() & 2 )
			{
				value2 = low & 2 ? 0xff : 0;
				EGA_plane01[offset + 1] = (byte) do_logicals( value2, get_latch1 );
			}

			if( getVideoplane_enable() & 1 )
			{
				value2 = high & 1 ? 0xff : 0;
				EGA_plane01[offset + 4] = (byte) do_logicals( value2, get_latch0 );
			}

			if( getVideoplane_enable() & 8 )
			{
				value2 = low & 8 ? 0xff : 0;
				EGA_plane23[offset + 1] = (byte) do_logicals( value2, get_latch3 );
			}

			if( getVideoplane_enable() & 4 )
			{
				value2 = high & 4 ? 0xff : 0;
				EGA_plane23[offset + 4] = (byte) do_logicals( value2, get_latch2 );
			}
		}
		else		/* even address, low byte in planes 0 and 2 */
		{
			if( getVideoplane_enable() & 1 )
			{
				value2 = low & 1 ? 0xff : 0;
				EGA_plane01[offset] = (byte) do_logicals( value2, get_latch0 );
			}

			if( getVideoplane_enable() & 2 )
			{
				value2 = high & 2 ? 0xff : 0;
				EGA_plane01[offset + 1] = (byte) do_logicals( value2, get_latch1 );
			}

			if( getVideoplane_enable() & 4 )
			{
				value2 = low & 4 ? 0xff : 0;
				EGA_plane23[offset] = (byte) do_logicals( value2, get_latch2 );
			}

			if( getVideoplane_enable() & 8 )
			{
				value2 = high & 8 ? 0xff : 0;
				EGA_plane23[offset + 1] = (byte) do_logicals( value2, get_latch3 );
			}
		}
	}
	else	/* easy no function or bit prot case */
	{
		if( lsb )	/* odd address, low byte in planes 1 and 3 */
		{
			if( getVideoplane_enable() & 2 )
				EGA_plane01[offset + 1] = low & 2 ? 0xff : 0;

			if( getVideoplane_enable() & 1 )
				EGA_plane01[offset + 4] = high & 1 ? 0xff : 0;

			if( getVideoplane_enable() & 8 )
				EGA_plane23[offset + 1] = low & 8 ? 0xff : 0;

			if( getVideoplane_enable() & 4 )
				EGA_plane23[offset + 4] = high & 4 ? 0xff : 0;
		}
		else		/* even address, low byte in planes 0 and 2 */
		{
			if( getVideoplane_enable() & 1 )
				EGA_plane01[offset] = low & 1 ? 0xff : 0;

			if( getVideoplane_enable() & 2 )
				EGA_plane01[offset + 1] = high & 2 ? 0xff : 0;

			if( getVideoplane_enable() & 4 )
				EGA_plane23[offset] = low & 4 ? 0xff : 0;

			if( getVideoplane_enable() & 8 )
				EGA_plane23[offset + 1] = high & 8 ? 0xff : 0;
		}
	}

	update_alg.mark_word( offset );
#endif  //NEC_98
}

VOID
ega_mode2_chn_b_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
#ifndef NEC_98
	ULONG low_offset;		/* distance into regen buffer of write start and end */
	ULONG high_offset;	/* distance into regen buffer of write start and end */
	ULONG new_value;

	note_entrance0("ega_mode2_chn_b_fill");

	/*
	 *	Complicated by possibility that only one of a chained pair of
	 *	planes is write enabled, needing alternate bytes to be written.
	 */

	/* starting on odd address makes it difficult, go to next one */

	if(( (ULONG) offset & 1 ) && count )
	{
		ega_mode2_chn_b_write(value, offset++ );
		count--;
	}

	/* ending on even address makes it difficult, retreat to previous one */

	if(( (ULONG)( offset + count - 1 ) & 1 ) == 0 && count )
	{
		ega_mode2_chn_b_write(value, offset + count - 1 );
		count--;
	}

	low_offset = (offset >> 1) << 2;				/* start of write */
	high_offset = ((offset + count - 1) >> 1) << 2;		/* end of write */

	switch( getVideoplane_enable() & 3 )
	{
		case 1:	/* just plane 0, ie even addresses to be written */
			value = value & 1 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value = do_logicals( value, get_latch0 );

			fill_alternate_bytes( &EGA_plane01[low_offset],
									&EGA_plane01[high_offset], (byte) value );
			break;

		case 2:	/* just plane 1, ie odd addresses to be written */
			value = value & 2 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value = do_logicals( value, get_latch1 );

			fill_alternate_bytes( &EGA_plane01[low_offset + 1],
									&EGA_plane01[high_offset], (byte) value );
			break;

		case 3:	/* sensible case is to have both chained planes write enabled */
			new_value = ( value & 1 ? 0xff : 0) | (value & 2 ? 0xff00: 0);

			if( EGA_CPU.fun_or_protection )
				new_value = do_logicals( new_value, get_latch01);

			fill_both_bytes( (IU16)new_value, (USHORT *)&EGA_plane01[low_offset], count >> 1 );
			break;

	}	/* end of switch on plane01 enabled */

	switch( getVideoplane_enable() & 0xc )	/* isolate 2 bits for planes2 and 3 */
	{
		case 4:	/* just plane 2, ie even addresses to be written */
			value = value & 4 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value = do_logicals( value, get_latch2 );

			fill_alternate_bytes( &EGA_plane23[low_offset],
								&EGA_plane23[high_offset],  (byte) value );
			break;

		case 8:	/* just plane 3, ie odd addresses to be written */
			value = value & 8 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value = do_logicals( value, get_latch3 );

			fill_alternate_bytes( &EGA_plane23[low_offset + 1],
								&EGA_plane23[high_offset], (byte) value );
			break;

		case 12:	/* sensible case is to have both chained planes write enabled */
			new_value = ( value & 4 ? 0xff : 0) | (value & 8 ? 0xff00: 0);

			if( EGA_CPU.fun_or_protection )
				new_value = do_logicals( new_value, get_latch23);

			fill_both_bytes( (IU16) new_value, (USHORT *)&EGA_plane23[low_offset], count >> 1 );
			break;
	}	/* end of switch on plane23 enabled */

	update_alg.mark_fill( offset, offset + count - 1 );
#endif  //NEC_98
}

VOID
ega_mode2_chn_w_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
#ifndef NEC_98
	ULONG	low_offset;		/* distance into regen buffer of write start and end */
	ULONG	high_offset;	/* distance into regen buffer of write start and end */
	ULONG	value1;

	note_entrance0("ega_mode2_chn_w_fill");

	/*
	 *	Complicated by possibility that only one of a chained pair of
	 *	planes is write enabled, needing alternate bytes to be written.
	 */

	/* starting on odd address makes it difficult, go to next one */

	if(( (ULONG) offset & 1 ) && count )
	{
		ega_mode2_chn_b_write( value, offset++);
		count--;

		if( count )
		{
			ega_mode2_chn_b_write( value >> 8, offset + count - 1 );
			count--;
		}

		value = ( value << 8 ) | ( value >> 8 );
	}

	low_offset = (offset >> 1) << 2;				/* start of write */
	high_offset = ((offset + count - 1) >> 1) << 2;		/* end of write */

	switch( getVideoplane_enable() & 3 )
	{
		case 1:	/* just plane 0, ie even addresses to be written */
			value1 = value & 1 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value1 = do_logicals( value1, get_latch0 );

			fill_alternate_bytes( &EGA_plane01[low_offset],
									&EGA_plane01[high_offset], (byte) value1 );
			break;

		case 2:	/* just plane 1, ie odd addresses to be written */
			value1 = ( value >> 8 ) & 2 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value1 = do_logicals( value1, get_latch1 );

			fill_alternate_bytes( &EGA_plane01[low_offset + 1],
									&EGA_plane01[high_offset], (byte) value1 );
			break;

		case 3:	/* sensible case is to have both chained planes write enabled */
			/* get a word pattern for filling */
			value1 = ( value & 1 ? 0xff : 0 ) | (( value >> 8 ) & 2 ? 0xff00: 0 );

			if( EGA_CPU.fun_or_protection )
				value1 = do_logicals( value1, get_latch01 );

			fill_both_bytes( (IU16) value1, (USHORT *)&EGA_plane01[low_offset], count >> 1 );
			break;
	}	/* end of switch on plane01 enabled */

	switch( getVideoplane_enable() & 0xc )	/* isolate 2 bits for planes 2 and 3 */
	{
		case 4:	/* just plane 2, ie even addresses to be written */
			value1 = value & 4 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value1 = do_logicals( value1, get_latch2 );

			fill_alternate_bytes( &EGA_plane23[low_offset],
									&EGA_plane23[high_offset], (byte) value1 );
			break;

		case 8:	/* just plane 3, ie odd addresses to be written */
			value1 = ( value >> 8 ) & 8 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value1 = do_logicals( value1, get_latch3 );

			fill_alternate_bytes( &EGA_plane23[low_offset + 1],
									&EGA_plane23[high_offset], (byte) value1 );
			break;

		case 12:	/* sensible case is to have both chained planes write enabled */
			/* get a word pattern for filling */
			value1 = ( value & 4 ? 0xff : 0 ) | (( value >> 8 ) & 8 ? 0xff00: 0 );

			if( EGA_CPU.fun_or_protection )
				value1 = do_logicals( value1, get_latch23);

			fill_both_bytes( (IU16) value1, (USHORT *)&EGA_plane23[low_offset], count >> 1 );
			break;
	}	/* end of switch on plane23 enabled */

	/* the 3rd parameter is needed by GORE. */
	update_alg.mark_wfill( offset, offset + count - 1, 0 );
#endif  //NEC_98
}

LOCAL VOID
ega_mode2_chn_move_guts IFN8(UTINY *, eas, UTINY *, ead, LONG, count,
	UTINY *, EGA_plane, ULONG, scratch, ULONG, plane, ULONG, w,
	ULONG, src_flag )
{
#ifndef NEC_98
	ULONG src, dst;
	UTINY *source;
	USHORT value;
	ULONG lsb;

	src = (ULONG) eas;

	dst = (ULONG) ead;

	/*
	 *	even planes cannot start with odd addresses
	 *	odd planes cannot start with even addresses
	 */

	if(( dst & 1 ) != ( plane & 1 ))	
	{
#ifdef BACK_M
		src--;
		scratch--;
#else
		src++;
		scratch++;
#endif
		dst++;
		count--;
	}

	lsb = dst & 1;
	dst = (dst >> 1) << 2;
	dst |= lsb;

	if( src_flag )
	{
		lsb = src & 1;
		src = (src >> 1) << 2;
		src |= lsb;

		if( plane & 1 )
		{

		/*
		 *	This causes latches to be read from 2 bytes above the word
		 *	that was read if it was on an odd address, ie it only applies
		 *	to planes 1 and 3 in chained mode word operations.
		 */

			source = w ? &EGA_plane[src] + 2 : &EGA_plane[src];
		}
		else
		{
			source = &EGA_plane[src];
		}

		src = scratch;
	}

	if( EGA_CPU.fun_or_protection )
	{
		while( count > 0 )
		{
			count -= 2;

			value = *(UTINY *) src & (1 << plane) ? 0xff : 0;
#ifdef BACK_M
			src -= 2;
#else
			src += 2;
#endif

			if( src_flag )
			{
				put_latch( plane, *source );
				source += 4;
			}

			EGA_plane[dst] = (byte) do_logicals( value, get_latch(plane) );
			dst += 4;
		}
	}
	else
	{
		while( count > 0 )
		{
			count -= 2;

			EGA_plane[dst] = *(UTINY *) src & (1 << plane) ? 0xff : 0;
#ifdef BACK_M
			src -= 2;
#else
			src += 2;
#endif
			dst += 4;
		}
	}
#endif  //NEC_98
}

/*
 * Used by ega_mode2_chn_b_move with w == 0 and by
 * ega_mode2_gen_w_move with w == 1
 */

VOID
ega_mode2_chn_move IFN5(UTINY, w, UTINY *, ead, UTINY *, eas, ULONG, count,
	ULONG, src_flag )
{
#ifndef NEC_98
	UTINY *scr;

	IMPORT VOID (*string_read_ptr)();

	count <<= w;

	if( src_flag )
	{
		/*
		 *	Source is in EGA, latches will change with each byte moved. We
		 *	restore CPU's view of source in regen, and use it to update planes
		 *	with the aid of the SAS scratch area.
		 */

#ifdef BACK_M
		scr = getVideoscratch() + 0x10000 - 1;
#else
		scr = getVideoscratch();
#endif

		if( getDF() )
		{
			eas = eas - count + 1 + w;
			ead = ead - count + 1 + w;
		}

		(*string_read_ptr)( scr, eas, count );
	}
	else
	{
		if( getDF() )
		{
#ifdef BACK_M
			eas = eas + count - 1 - w;
#else
			eas = eas - count + 1 + w;
#endif
			ead = ead - count + 1 + w;
		}
	}

	if( getVideoplane_enable() & 1 )		/* plane 0, even addresses, enabled */
		ega_mode2_chn_move_guts( eas, ead, count, EGA_plane01, (ULONG) scr, 0, w, src_flag );

	if( getVideoplane_enable() & 2 )		/* plane 1, odd addresses, enabled */
		ega_mode2_chn_move_guts( eas, ead, count, EGA_plane01, (ULONG) scr, 1, w, src_flag );

	if( getVideoplane_enable() & 4 )		/* plane 2, even addresses, enabled */
		ega_mode2_chn_move_guts( eas, ead, count, EGA_plane23, (ULONG) scr, 2, w, src_flag );

	if( getVideoplane_enable() & 8 )		/* plane 3, odd addresses, enabled */
		ega_mode2_chn_move_guts( eas, ead, count, EGA_plane23, (ULONG) scr, 3, w, src_flag );

	update_alg.mark_string( (int) ead, (int) ead + count - 1 );
#endif  //NEC_98
}

VOID
ega_mode2_chn_b_move IFN4(ULONG, ead, ULONG, eas, ULONG, count,
	ULONG, src_flag)
{
#ifndef NEC_98
  note_entrance0("ega_mode2_chn_b_move");

  /* general function, 0 means byte write */

  ega_mode2_chn_move(0, (UTINY *) ead, (UTINY *) eas, count, src_flag);
#endif  //NEC_98
}

VOID
ega_mode2_chn_w_move IFN4(ULONG, ead, ULONG, eas, ULONG, count,
	ULONG, src_flag)
{
#ifndef NEC_98
  note_entrance0("ega_mode2_chn_w_move");

  /* general function, 1 means word write */

  ega_mode2_chn_move(1, (UTINY *)ead, (UTINY *)eas, count, src_flag);
#endif  //NEC_98
}

#endif

#endif	/* !NTVDM | (NTVDM & !X86GFX) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\gfx_updt.c ===
/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DOCUMENT 		: Display Update Algorithms

DESIGNER		: William Gulland

REVISION HISTORY	:
First version		: date, who

SccsID[]="@(#)gfx_update.c	1.82 06/30/95 Copyright Insignia Solutions Ltd.";

*/

/*
PURPOSE			: Keep the host screen up to date.
[1.INTERMODULE INTERFACE SPECIFICATION]

[1.1    INTERMODULE EXPORTS]

	DATA 	     :	give type and name
			struct _UPDATE_ALG update_alg

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]

	STRUCTURES/TYPEDEFS/ENUMS:

-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
None
-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]
None.
[1.4.2 EXPORTED OBJECTS]
=========================================================================
GLOBALS		  :	describe what exported data objects are
			accessed and how. Likewise for imported
			data objects.
			update_alg - pointers to update functions contained
			here or elsewhere - eg. host specific update stuff.

			text_update() - routine to do a text update, by comparing
			the adaptor regen area with video_copy.

			cga_graph_update() - routine to do a graphics update, by comparing
			the adaptor regen area with video_copy.

			text_scroll_up/down() - scroll portion of the screen in text mode.
			cga_graph_scroll_up/down() - scroll portion of the screen in cga graphics mode.
=========================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]						*/

#include "insignia.h"
#include "host_def.h"

#include <stdio.h>
#include StringH
#include "xt.h"
#include "sas.h"
#include "ios.h"
#include CpuH
#include "gmi.h"
#include "gvi.h"
#include "cga.h"
#include "error.h"
#include "config.h"	/* to get defn of MDA! */
#include "trace.h"
#include "debug.h"
#include "gfx_upd.h"
#include "host_gfx.h"
#include "video.h"

#ifdef EGG
#include "egacpu.h"
#include "egagraph.h"
#include "vgaports.h"
#include "egaports.h"
#endif /* EGG */

#ifdef GORE
#include "gore.h"
#endif /* GORE */

#include "ga_mark.h"
#include "ga_defs.h"

/*[3.2 INTERMODULE EXPORTS]						*/

/*
 * Terminal type.  This is initialised to a set default which is determined
 * in host_graph.h.
 */

int terminal_type = TERMINAL_TYPE_DEFAULT;

/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]						*/

/* [5.1.1 #DEFINES]							*/
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_GRAPHICS.seg"
#endif

#if defined(NEC_98)
#define init_dirty_recs()               dirty_next = 0
#else   //NEC_98
#if	defined(PROD) || (!defined(EGG))
#define	init_dirty_recs()		dirty_next = 0
#else
#define	init_dirty_recs()		{ dirty_next = 0 ; if (io_verbose & EGA_DISPLAY_VERBOSE) \
						trace("--- start collecting update records ---\n",0); }
#endif
#endif  //NEC_98

#define	get_dirty_rec_total()		(dirty_next)
#if defined(NEC_98)
#define add_dirty_rec(line,st,len,off)  { \
                      dirty[dirty_next].line_no = (line); \
                      dirty[dirty_next].start = (st); \
                      dirty[dirty_next].end = (st)+(len); \
                      dirty[dirty_next].video_copy_offset = (off); \
                      dirty_next++; \
                     }

#else   //NEC_98
#ifdef VGG
#if	defined(PROD) || (!defined(EGG))
#define	add_dirty_rec(line,st,len,off,fr)	{	dirty[dirty_next].line_no = (line); \
						dirty[dirty_next].start = (st); \
						dirty[dirty_next].end = (st) + (len); \
						dirty[dirty_next].video_copy_offset = (off); \
						dirty[dirty_next].v7frig = (fr); \
						dirty_next++; \
					}
#else
#define	add_dirty_rec(line,st,len,off,fr)	{	if (io_verbose & EGA_DISPLAY_VERBOSE) {\
							char	trace_string[80]; \
							sprintf(trace_string,"dirty[%d]line_no %d, start %d end %d", \
											dirty_next,(line),(st),(st)+(len));\
							trace(trace_string,0); \
						} \
						dirty[dirty_next].line_no = (line); \
						dirty[dirty_next].start = (st); \
						dirty[dirty_next].end = (st) + (len); \
						dirty[dirty_next].video_copy_offset = (off); \
						dirty[dirty_next].v7frig = (fr); \
						dirty_next++; \
					}
#endif
#else /* VGG */
#if	defined(PROD) || (!defined(EGG))
#define	add_dirty_rec(line,st,len,off)	{	dirty[dirty_next].line_no = (line); \
						dirty[dirty_next].start = (st); \
						dirty[dirty_next].end = (st) + (len); \
						dirty[dirty_next].video_copy_offset = (off); \
						dirty_next++; \
					}
#else
#define	add_dirty_rec(line,st,len,off)	{	if (io_verbose & EGA_DISPLAY_VERBOSE) {\
							char	trace_string[80]; \
							sprintf(trace_string,"dirty[%d]line_no %d, start %d end %d", \
											dirty_next,(line),(st),(st)+(len));\
							trace(trace_string,0); \
						} \
						dirty[dirty_next].line_no = (line); \
						dirty[dirty_next].start = (st); \
						dirty[dirty_next].end = (st) + (len); \
						dirty[dirty_next].video_copy_offset = (off); \
						dirty_next++; \
					}
#endif
#endif /* VGG */
#endif  //NEC_98

#define	get_dirty_line(ind)	(dirty[(ind)].line_no)
#define	get_dirty_start(ind)	(dirty[(ind)].start)
#define	get_dirty_end(ind)	(dirty[(ind)].end)
#define	get_dirty_offset(ind)	(dirty[(ind)].video_copy_offset)
#if defined(NEC_98)
#define clear_dirty()   { \
                         NEC98GLOBS->dirty_flag = 0;\
                         NEC98GLOBS->dirty_low = 0x80001;\
                         NEC98GLOBS->dirty_high = -1;\
                        }
#else   //NEC_98
#define clear_dirty()		{setVideodirty_total(0);setVideodirty_low(0x80001);setVideodirty_high(-1);}
#endif  //NEC_98

#ifdef	NO_STRING_OPERATIONS
#define	SET_VGLOBS_MARK_STRING(func)		/*nothing*/
#else
#define	SET_VGLOBS_MARK_STRING(func)	setVideomark_string(func);
#endif	/* NO_STRING_OPERATIONS */


/* Parts of update and paint routines assume start of screen memory is on
a 4-byte boundary. This macro makes this true and reports if it wasn't. */
#if defined(NEC_98)
#define ALIGN_SCREEN_START(start) (start &= ~3L)
#else   //NEC_98
#ifdef PROD
#define ALIGN_SCREEN_START(start) (start &= ~3L)
#else
#define ALIGN_SCREEN_START(start) if (start & 3L) \
	{ file_id; printf("Start of screen not 4-byte aligned"); newline; \
	start &= ~3L; }
#endif	/* PROD */
#endif  //NEC_98

GLOBAL LONG dirty_curs_offs = -1;		/* GLOBAL for JOKER */
GLOBAL LONG dirty_curs_x;
GLOBAL LONG dirty_curs_y;

#ifndef REAL_VGA

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]			*/

/* [5.1.3 PROCEDURE() DECLARATIONS]					*/

	LOCAL boolean simple_update IPT0();
	boolean	dummy_scroll IPT6(int,dummy1,int,dummy2,int,dummy3,
			int,dummy4,int,dummy5,int,dummy6);
#if defined(NTVDM) && defined(MONITOR)
	boolean mon_text_scroll_up IPT6(sys_addr, start, int, width, int, height, int, attr, int, lines, int, colour);
	boolean mon_text_scroll_down IPT6(sys_addr, start, int, width, int, height, int, attr, int, lines, int, colour);
#endif /* NTVDM & MONITOR */

	LOCAL VOID save_gfx_update_routines IPT0();
	LOCAL VOID inhibit_gfx_update_routines IPT0();

	/* Imports from v7_ports.c */

#ifdef V7VGA
	IMPORT  VOID    draw_v7ptr IPT0();
	IMPORT	VOID	remove_v7ptr IPT0();
	IMPORT	BOOL	v7ptr_between_lines IPT2(int,start_line,int,end_line);
#endif /* V7VGA */


#ifdef	HOST_SCREEN_UPDATES

IMPORT BOOL HostUpdatedVGA IPT0();	/* Called from vga_graph_update() */
IMPORT BOOL HostUpdatedEGA IPT0();	/* ega_graph_update() */

#else	/* HOST_SCREEN_UPDATES */

#define	HostUpdatedVGA()	FALSE
#define	HostUpdatedEGA()	FALSE

#endif	/* HOST_SCREEN_UPDATES */


/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS 					*/

#if defined(NEC_98)
        NEC98_VRAM_COPY *video_copy;
        unsigned char  *graph_copy;
        static  DIRTY_PARTS     dirty[25]; /* dirty data struc           */
        static  STRC_COMP_LINE  compline[25]; /* line top address data  */
        extern  void    set_the_vlt(void); /* host palette changed       */
        extern  BOOL    video_emu_mode; /* now display mode */
        extern  BOOL    compatible_font; /* now font mode */
        BOOLEAN fRefreshBrk=FALSE; /* NEC */
#else   //NEC_98
byte *video_copy;		/* video_copy is now allocated in host_init_screen()'s */

#ifndef macintosh
#ifdef VGG
#ifdef V7VGA
static	DIRTY_PARTS	dirty[768];
#else
static	DIRTY_PARTS	dirty[480];
#endif /* V7VGA */
#else
static	DIRTY_PARTS	dirty[350];
#endif
#else
DIRTY_PARTS	*dirty;	/* NB. Allocated as 350*4*sizeof(int) in applInit(). */
#endif
#endif  //NEC_98

IMPORT half_word bg_col_mask;
static	int	dirty_next=0;

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]				*/

static	int	search_video_copy IFN3(int, start_line,
	int, end_line, int, start_offset)
{
#ifndef NEC_98
	register	byte	*ptr,*k;
	register	int	j;
	register	int	quarter_opl = get_offset_per_line()>>2;
	byte	*vcopy = &video_copy[start_offset];
	byte save,*end_ptr;

	ptr = vcopy;
	end_ptr = ptr + quarter_opl*(end_line-start_line);
	save = *end_ptr;
	*end_ptr = 1;	/* End marker */
	while(ptr < end_ptr)
	{
		if(!*ptr)
			do {; } while (!(*++ptr));
		if(ptr >= end_ptr)break;
		/* Work out where in line we've reached */
		j = (int)((ptr - vcopy)%quarter_opl);
		/*
		 * Have found a dirty line. Find width
		 */
		for ( k= ptr+quarter_opl-j-1; *k == 0 ; k-- ) ; /* We know *ptr != 0, so k will stop at ptr */
#ifdef VGG
		add_dirty_rec((int)((ptr-vcopy)/quarter_opl)+start_line,
		              j<<2, (int)(k-ptr+1)<<2, ptr-video_copy-j,0);
#else
		add_dirty_rec((int)((ptr-vcopy)/quarter_opl)+start_line,
		              j<<2, (int)(k-ptr+1)<<2, ptr-video_copy-j);
#endif /* VGG */

		ptr += quarter_opl - j;
		/*
		 * Don't clear out the marked area in case the plane wraps
		 */
	}
	*end_ptr = save;
#endif  //NEC_98
	return( get_dirty_rec_total() );
}

#ifdef VGG

/*
 *	Special version of search_video_copy() for the Video 7 Extended Modes 60h & 61h
 *	and 'undocumented' VGA mode which have chars_per_line of 90 & 94 which don't seem
 *  to be multiples of 4.  Interestingly, Zany Golf ( EGA, Mode 14 ) also ends up
 *  calling this code.
 */

static	int	v7_search_video_copy IFN3(int, start_line,
	int, end_line, int, start_offset)
{
#ifndef NEC_98
	register	byte	*ptr,*k;
	register	int	j;
	register	int	half_opl = get_offset_per_line()>>1;
	register	int	quarter_opl = get_offset_per_line()>>2;
	byte	*vcopy = &video_copy[start_offset];
	byte save,*end_ptr;
	long length;
	int bodge = 0;

	if (start_line & 1)
		bodge = 2;
	ptr = vcopy;

	/*
	 * This calculation sets end_ptr slightly too high to
	 * ensure that all the dirty areas get found.
	 */

	end_ptr = ptr + (half_opl*(end_line-start_line+1))/2;

	save = *end_ptr;
	*end_ptr = 1;	/* End marker */
	while(ptr < end_ptr)
	{
		if(!*ptr)
		{
			while (!(*++ptr));
		}
		if(ptr >= end_ptr)break;
		/* Work out where in line we've reached */
		j = (int)((ptr - vcopy)%half_opl);
		/*
		 * Have found a dirty line. Find width
		 */
		for ( k= ptr+half_opl-j-1; *k == 0 ; k-- ) ; /* We know *ptr != 0, so k will stop at ptr */

		length = k-ptr+1;
		if (j <= quarter_opl)
		{	
			if (length > quarter_opl-j)
			{
				add_dirty_rec((int)(2*(ptr-vcopy)/half_opl)+start_line,
		              	j<<2, (int)(half_opl-2*j)<<1, ptr-video_copy-j,bodge);
				add_dirty_rec((int)(2*(ptr-vcopy)/half_opl)+start_line+1,
		              	0, ((int)(j+length-quarter_opl)<<2)-2, ptr-video_copy-j+quarter_opl,2+bodge);
			}
			else
			{
				add_dirty_rec((int)(2*(ptr-vcopy)/half_opl)+start_line,
		              	j<<2, (int)(length)<<2, ptr-video_copy-j,bodge);
			}
		}
		else
		{
			add_dirty_rec((int)(2*(ptr-vcopy)/half_opl)+start_line,
		             (j-quarter_opl-1)<<2, (int)((length)<<2), ptr-video_copy-j+quarter_opl,2+bodge);
		}

		ptr += half_opl - j;
		/*
		 * Don't clear out the marked area in case the plane wraps
		 */
	}
	*end_ptr = save;
#endif  //NEC_98
	return( get_dirty_rec_total() );
}
#endif /* VGG */

static	int	search_video_copy_aligned IFN3(int, start_line,
	int, end_line, int, start_offset)
{
#ifndef NEC_98
	register	unsigned int *ptr4;
	register	byte	*ptr,*k;
	register	int	j;
	register	int	quarter_opl = get_offset_per_line()>>2;
	byte	*vcopy = &video_copy[start_offset];
	byte save,*end_ptr;

	ptr = vcopy;
	end_ptr = ptr + quarter_opl*(end_line-start_line);
	save = *end_ptr;
	*end_ptr = 1;	/* End marker */
	while(ptr < end_ptr)
	{
		ptr4 = (unsigned int *)(ptr-4);
		do {; } while (!(*++ptr4));
		ptr = (byte *)ptr4;
		if(!*ptr)
			do {; } while (!(*++ptr));
		if(ptr >= end_ptr)break;
		/* Work out where in line we've reached */
		j = (int)((ptr - vcopy)%quarter_opl);
		/*
		 * Have found a dirty line. Find width
		 */
		for ( k= ptr+quarter_opl-j-1; *k == 0 ; k-- ) ; /* We know *ptr != 0, so k will stop at ptr */
#ifdef VGG
		add_dirty_rec((int)((ptr-vcopy)/quarter_opl)+start_line,
		              j<<2, (int)(k-ptr+1)<<2, ptr-video_copy-j,0);
#else
		add_dirty_rec((int)((ptr-vcopy)/quarter_opl)+start_line,
		              j<<2, (int)(k-ptr+1)<<2, ptr-video_copy-j);
#endif /* VGG */
		ptr += quarter_opl - j;
		/*
		 * Don't clear out the marked area in case the plane wraps
		 */
	}
	*end_ptr = save;
#endif  //NEC_98
	return( get_dirty_rec_total() );
}

static	void	paint_records IFN2(int, start_rec, int, end_rec)
{
#ifndef NEC_98
	register	DIRTY_PARTS	*i,*end_ptr;
#ifdef VGG
	int dirty_frig;
#endif /* VGG */

	i= &dirty[start_rec];
	end_ptr =  &dirty[end_rec];
	while (i<end_ptr) {
		register	int	last_line, cur_start, cur_end,max_width;
		int 	first_line;
		long	dirty_vc_offset;

		first_line = i->line_no;
		last_line = first_line;
		cur_start = i->start;
		cur_end = i->end;
		max_width = (cur_end-cur_start) << 1;	/* To split up diagonal lines */

		/*
		 * offset in bytes into video_copy, which is quarter offset into plane at start of this rectangle
		 */

		dirty_vc_offset = i->video_copy_offset;
#ifdef VGG
		dirty_frig = i->v7frig; /* for the V7 modes with chars_per_line not a multiple of 4 */
#endif /* VGG */
		i++;
		while (i < end_ptr) {
			if ( i->line_no - last_line < 3 ) {
				/*
				 * This entry can be included into the same paint
				 * as long as it doesn't make the rectangle too wide
				 */

				if ( i->end > cur_end ){
					if(i->end - cur_start > max_width)break;
					cur_end = i->end;
				}
				if ( i->start < cur_start ){
					if(cur_end - i->start > max_width)break;
					cur_start = i->start;
				}
				last_line = i->line_no;
				i++;
			}
			else
			  break;
		}
		/*
		 * paint the rectangle found
		 */

		/* do not paint beyond the right hand side of the screen;
		   these checks were put in to cope with the special
		   case of the brain-scan display in 'EGAWOW' */
		if (cur_end > get_bytes_per_line())
			cur_end = get_bytes_per_line();
#ifdef VGG
		if (cur_end > cur_start)
			(*paint_screen)((dirty_vc_offset<<2) + dirty_frig + cur_start,
			cur_start<<3, first_line, cur_end-cur_start,
			last_line-first_line+1);
#else
		if (cur_end > cur_start)
			(*paint_screen)((dirty_vc_offset<<2) + cur_start,
			cur_start<<3, first_line, cur_end-cur_start,
			last_line-first_line+1);
#endif /* VGG */
	}
	/* Clear out video copy */
	for(i = &dirty[start_rec];i<end_ptr;i++)
	{
		register byte *j,*end;
		end = &video_copy[ i->video_copy_offset+(i->end>>2)];
#ifdef VGG
		j =  &video_copy[ i->video_copy_offset+(i->start>>2)+i->v7frig];
#else
		j =  &video_copy[ i->video_copy_offset+(i->start>>2)];
#endif /* VGG */
		do *j++ = 0; while(j<end);
	}
#endif  //NEC_98
}

#ifdef BIGEND
#define get_char_attr(unsigned_long_ptr)     ((*(unsigned_long_ptr)) >> 16)
#else
#define get_char_attr(unsigned_long_ptr)     (((*(unsigned_long_ptr)) & 0xffff))
#endif

#ifdef EGG

#ifdef SEGMENTATION 		/* See note with first use of this flag */
#include "SOFTPC_EGA.seg"
#endif

static	int	ega_text_find_dirty_lines IFN5(byte *, vcopy, byte *, planes,
	int, start_line, int, end_line, int, screen_start)
{
#ifndef NEC_98
	register	int	i,j,k;
	register	unsigned short	shorts_per_line=(unsigned short)get_chars_per_line();
	register	int	offset,cur_y;
	register	int	char_height=get_host_char_height();
	register	int	opl=get_offset_per_line();
	register	IU32	*from;
	register	USHORT	*to;

	for(i=start_line,offset=0,cur_y=start_line*char_height; i<end_line;
						i++,offset += opl, cur_y += char_height )
	{
		to = (USHORT *) &vcopy[offset];
		from = (IU32 *) &planes[(offset<<1)];
		for(j=0;j<shorts_per_line;j++)
		{
			if(*to++ != get_char_attr(from++))
			{
				to--;from--;
				for(k=shorts_per_line-1-j;*(to+k) == get_char_attr(from+k);k--)
					;

				/*
				* Note: For text mode there is one char for every word.
				* no of bytes into screen=line*bytes_per_line + ints_into_line*4
				* x_coord=width_of_one_char*(no_of_ints_into_line*2)
				* y_coord=height_of_one_char*2*line
				* The host y co-ords are doubled
				*/

#ifdef VGG
				add_dirty_rec(cur_y,j<<2,(k<<1)+2,screen_start+(offset<<1),0);
#else
				add_dirty_rec(cur_y,j<<2,(k<<1)+2,screen_start+(offset<<1));
#endif /* VGG */
				break;	/* onto next line */
			}
		}
	}
#endif  //NEC_98
	return( get_dirty_rec_total() );
}

static	void	ega_text_paint_dirty_recs IFN2(int, start_rec, int, end_rec)
{
#ifndef NEC_98
	register	int	char_wid = get_pix_char_width()>>1;
	register	int	i;
	register	int	length;
	register 	USHORT *to,*from;

	for (i=start_rec;i<end_rec;i++)
	{
		length = get_dirty_end(i)-get_dirty_start(i);

		(*paint_screen)(get_dirty_offset(i)+get_dirty_start(i),
		(get_dirty_start(i)>>1)*char_wid,get_dirty_line(i), length, 1);

		length >>= 1;
		to = (USHORT *) &video_copy[(get_dirty_offset(i)+
									  get_dirty_start (i))>>1];

		from = (USHORT *)get_screen_ptr(get_dirty_offset(i)+get_dirty_start(i));

		while ( length-- > 0 )
		{
			*to++ = *from;		/* char and attribute bytes */
			from += 2;			/* skip over the planes 2,3 */
		}
	}
#endif  //NEC_98
}

#endif /* EGG */

#ifdef SEGMENTATION 			/* See note with first use of this flag */
#include "SOFTPC_GRAPHICS.seg"
#endif

#endif /* REAL_VGA */

VOID remove_old_cursor IFN0()
{
#ifndef NEC_98
	if( dirty_curs_offs >= 0 )
	{
		sub_note_trace2( ALL_ADAPT_VERBOSE,
				"remove_old_cursor x=%d, y=%d", dirty_curs_x, dirty_curs_y );

		(*paint_screen)( dirty_curs_offs, dirty_curs_x * get_pix_char_width(),
								dirty_curs_y * get_host_char_height(), 2 );

		dirty_curs_offs = -1;
	}
#endif  //NEC_98
}


GLOBAL VOID
simple_handler IFN0()
{
#ifndef NEC_98
	setVideodirty_total(getVideodirty_total() + 1);
#endif  //NEC_98
}

LOCAL	boolean simple_update IFN0()
{
#ifndef NEC_98
	setVideodirty_total(getVideodirty_total() + 1);
#endif  //NEC_98
	return( FALSE );
}

LOCAL VOID simple_update_b_move IFN4(UTINY *, laddr, UTINY *, haddr,
				UTINY *, src, UTINY, src_type)
{
	UNUSED(laddr);
	UNUSED(haddr);
	UNUSED(src);
	UNUSED(src_type);

#ifndef NEC_98
	setVideodirty_total(getVideodirty_total() + 1);
#endif  //NEC_98
}

MEM_HANDLERS vid_handlers =
{
	simple_handler,
	simple_handler,
	simple_handler,
	simple_handler,
	simple_update_b_move,
	simple_handler
};

GLOBAL void dummy_calc IFN0()
{
}

/*
[7.1 INTERMODULE DATA DEFINITIONS]				*/

UPDATE_ALG update_alg =
{
	(T_mark_byte)simple_update,
	(T_mark_word)simple_update,
	(T_mark_fill)simple_update,
	(T_mark_wfill)simple_update,
	(T_mark_string)simple_update,
	dummy_calc,
	dummy_scroll,
	dummy_scroll,
};

#ifndef REAL_VGA

/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]				*/


/*
==========================================================================
FUNCTION        :       flag_mode_change_required()
PURPOSE         :       Flag that a mode change is imminent and set the
                        scrolling routines to dummies to avoid scrolling
                        using routines for the wrong mode.
EXTERNAL OBJECTS:
RETURN VALUE    :       None
INPUT  PARAMS   :       None
RETURN PARAMS   :       None
==========================================================================
*/

void    flag_mode_change_required IFN0()
{
    set_mode_change_required(YES);

    update_alg.mark_byte = (T_mark_byte)simple_update;
    update_alg.mark_word = (T_mark_word)simple_update;
    update_alg.mark_fill = (T_mark_fill)simple_update;
    update_alg.mark_wfill = (T_mark_wfill)simple_update;
    update_alg.mark_string = (T_mark_string)simple_update;

    update_alg.scroll_up = dummy_scroll;
    update_alg.scroll_down = dummy_scroll;
}


/*
==========================================================================
FUNCTION	:	reset_paint_routines()
PURPOSE		:	Reset paint routines to dummies to ensure
                        there are no problems painting the screen
                        using incorrect routines during reboot.
EXTERNAL OBJECTS:	
RETURN VALUE	:	None
INPUT  PARAMS	:	None
RETURN PARAMS   :	None
==========================================================================
*/

void	reset_paint_routines IFN0()
{
    set_mode_change_required(YES);

    update_alg.calc_update = dummy_calc;
    update_alg.scroll_up = dummy_scroll;
    update_alg.scroll_down = dummy_scroll;
}

/*
 * Update the window to look like the regen buffer says it should
 */
#ifdef EGG

#ifdef SEGMENTATION 		/* See note with first use of this flag */
#include "SOFTPC_EGA.seg"
#endif

void	ega_wrap_split_text_update IFN0()
{
#ifndef NEC_98
	register int i;				/* Loop counter		*/
	register USHORT *from,*to;
	register int cur_ypos;
	int	lines_per_screen;
	int	offset;
	int	screen_start;
	int	split_line;

	if (getVideodirty_total() == 0 || get_display_disabled() )
		return;

	host_start_update();

	screen_start=get_screen_start() << 2;	

	ALIGN_SCREEN_START(screen_start);

	lines_per_screen = get_screen_length()/get_offset_per_line();
	split_line = (get_screen_split()+(get_char_height()>>1))/get_char_height();

	if (split_line>lines_per_screen)
		split_line=lines_per_screen;

	to = (USHORT *) &video_copy[screen_start >> 1];
	from = (USHORT *) get_screen_ptr(screen_start);

	if( getVideodirty_total() > 1500 )	/* paint the whole lot */
	{
		int	no_of_split_lines = lines_per_screen - split_line;
		int	limit;

		cur_ypos = 0;

		if( screen_start + (get_screen_length() << 1) > 4 * EGA_PLANE_DISP_SIZE )
		{
			note_display_state0("Split screen and wrapping !!");

			limit = (4 * EGA_PLANE_DISP_SIZE - screen_start) >> 2;

			for( i = 0; i < limit; i++ )
			{
				*to++ = *from;
				from += 2;
			}

			to = (USHORT *) &video_copy[0];
			from = (USHORT * ) get_screen_ptr(0);
			limit = (screen_start + ((get_screen_length() - 2 * EGA_PLANE_DISP_SIZE) << 1)) >> 2;

			for( i = 0; i < limit; i++ )
			{
				*to++ = *from;
				from += 2;
			}
			limit = 4 * EGA_PLANE_DISP_SIZE;
			for( i = 0, offset = screen_start; offset < limit;
				i++, offset += (get_offset_per_line() << 1 ))
			{
				(*paint_screen)(offset,0,cur_ypos,get_bytes_per_line(), 1);
				cur_ypos += get_host_char_height();
			}

			for( i = 0, offset = 0; i < split_line;
							i++, offset += (get_offset_per_line() << 1 ))
			{
				(*paint_screen)(offset,0,cur_ypos,get_bytes_per_line(), 1);
				cur_ypos += get_host_char_height();
			}
		}
		else
		{
			to = (USHORT *) &video_copy[screen_start >> 1];
			from = (USHORT * ) get_screen_ptr(screen_start);
			limit = (split_line * get_offset_per_line()) >> 1;

			for( i = 0; i < limit; i++ )
			{
				*to++ = *from;
				from += 2;
			}

			for( i = 0, offset = screen_start; i < split_line;
							i++, offset += (get_offset_per_line() << 1 ))
			{
				(*paint_screen)(offset,0,cur_ypos,get_bytes_per_line(), 1);
				cur_ypos += get_host_char_height();
			}
		}

		if( no_of_split_lines > 0 )
		{
			to = (USHORT *) &video_copy[0];
			from = (USHORT * ) get_screen_ptr(0);
			limit = (no_of_split_lines * get_offset_per_line()) >> 1;

			for( i = 0; i < limit; i++ )
			{
				*to++ = *from;
				from += 2;
			}

			for( i = split_line, offset = 0; i < lines_per_screen;
							i++, offset += (get_offset_per_line() << 1 ))
			{
				(*paint_screen)(offset,0,cur_ypos,get_bytes_per_line(), 1);
				cur_ypos += get_host_char_height();
			}
		}
	}
	else
	{
		if( screen_start + (get_screen_length() << 1) > 4 * EGA_PLANE_DISP_SIZE )
		{
			register	int	wrap_line =
					(4 * EGA_PLANE_DISP_SIZE - screen_start) / (get_offset_per_line() << 1);
			int	next,next1,next2;

			note_display_state0("Its a text wrap!");

			init_dirty_recs();

			next = ega_text_find_dirty_lines(&video_copy[screen_start >> 1],
							get_screen_ptr(screen_start), 0,
										wrap_line, screen_start );

			next1 = ega_text_find_dirty_lines(&video_copy[0],
						get_screen_ptr(0), wrap_line, split_line, 0 );

			next2 = ega_text_find_dirty_lines(&video_copy[0],
						get_screen_ptr(0), split_line, lines_per_screen, 0 );

			ega_text_paint_dirty_recs(0,next);
			ega_text_paint_dirty_recs(next,next1);
			ega_text_paint_dirty_recs(next1,next2);
		}
		else
		{
			int	next,next1;

			init_dirty_recs();
			next = ega_text_find_dirty_lines( &video_copy[screen_start >> 1],
					get_screen_ptr(screen_start), 0, split_line, screen_start );

			next1 = ega_text_find_dirty_lines( &video_copy[0], get_screen_ptr(0),
									split_line, lines_per_screen, 0 );

			ega_text_paint_dirty_recs(0,next);
			ega_text_paint_dirty_recs(next,next1);
		}
	}

	host_end_update();

	setVideodirty_total(0);
#endif  //NEC_98
}

void	ega_split_text_update IFN0()
{
#ifndef NEC_98
	register int i;				/* Loop counter		*/
	register USHORT *from,*to;
	register int cur_ypos;
	int	lines_per_screen;
	int	offset;
	int	screen_start;
	int	split_line;

	if (getVideodirty_total() == 0 || get_display_disabled() )
		return;

	host_start_update();

	screen_start = get_screen_start() << 2;	

	ALIGN_SCREEN_START(screen_start);

	lines_per_screen = get_screen_length()/get_offset_per_line();

	split_line = (get_screen_split()+(get_char_height()>>1))/get_char_height();

	if( split_line > lines_per_screen )
		split_line = lines_per_screen;

	to = (USHORT *) &video_copy[screen_start >> 1];
	from = (USHORT *) get_screen_ptr(screen_start);

	if( getVideodirty_total() > 1500 )	/* paint the whole lot */
	{
		int	no_of_split_lines = lines_per_screen - split_line;

		sub_note_trace2( EGA_DISPLAY_VERBOSE,
			"split line %d (lines_per_screen %d)", split_line, lines_per_screen);
		sub_note_trace1( EGA_DISPLAY_VERBOSE, "screen split %d", get_screen_split() );

		cur_ypos = 0;

		for( i = 0; i < (split_line * get_offset_per_line()) >> 1; i++ )
		{
			*to++ = *from;
			from += 2;
		}

		for( i = 0, offset = screen_start; i < split_line;
							i++, offset += ( get_offset_per_line() << 1 ))
		{
			(*paint_screen)( offset, 0, cur_ypos, get_bytes_per_line(), 1 );
			cur_ypos += get_host_char_height();
		}

		if( no_of_split_lines > 0 )
		{
			to = (USHORT *) &video_copy[0];
			from = (USHORT *) get_screen_ptr(0);

			for( i = 0; i < (no_of_split_lines * get_offset_per_line()) >> 1; i++ )
			{
				*to++ = *from;
				from += 2;
			}

			for( i = split_line, offset = 0; i < lines_per_screen;
									i++, offset += ( get_offset_per_line() << 1 ))
			{
				(*paint_screen)( offset, 0, cur_ypos, get_bytes_per_line(), 1);
				cur_ypos += get_host_char_height();
			}
		}
	}
	else
	{
		int	next,next1;

		assert0( FALSE, "ega_split_text - partial update" );

		init_dirty_recs();

		next = ega_text_find_dirty_lines( &video_copy[screen_start >> 1],
					get_screen_ptr(screen_start) , 0, split_line, screen_start );

		next1 = ega_text_find_dirty_lines( &video_copy[0], get_screen_ptr(0),
								split_line, lines_per_screen, 0 );

		ega_text_paint_dirty_recs(0,next);
		ega_text_paint_dirty_recs(next,next1);
	}

	host_end_update();

	setVideodirty_total(0);
#endif  //NEC_98
}

void ega_wrap_text_update IFN0()
{
#ifndef NEC_98
	register int i;				/* Loop counter		*/
	register USHORT *from,*to;
	register int cur_ypos;
	int	lines_per_screen;
	int	offset;
	int	screen_start;

	if (getVideodirty_total() == 0 || get_display_disabled() )
		return;

	host_start_update();

	screen_start=get_screen_start() << 2;	

	ALIGN_SCREEN_START(screen_start);

	lines_per_screen = get_screen_length()/get_offset_per_line();

	if( getVideodirty_total() > 1500 )	/* paint the whole lot */
	{
		to = (USHORT *) &video_copy[screen_start >> 1];
		from = (USHORT *) get_screen_ptr(screen_start);

		for( i = get_screen_length() >> 1; i > 0; i-- )
		{
			*to++ = *from;
			from += 2;
		}

		cur_ypos = 0;

		if( screen_start + (get_screen_length() << 1) > 4 * EGA_PLANE_DISP_SIZE )
		{
			register	int	leftover;
			int	limit;

			note_display_state0("Wrapping text");

			limit = 4 * EGA_PLANE_DISP_SIZE;
			for( offset = screen_start; offset < limit;
							offset+=(get_offset_per_line() << 1) )
			{
				(*paint_screen)(offset,0,cur_ypos,get_bytes_per_line(), 1);
				cur_ypos += get_host_char_height();
			}

			leftover = screen_start
				+ ((get_screen_length() - 2 * EGA_PLANE_DISP_SIZE) << 1);

			for( offset = 0; offset < leftover;
						offset += ( get_offset_per_line() << 1 ))
			{
				(*paint_screen)(offset,0,cur_ypos,get_bytes_per_line(), 1);
				cur_ypos += get_host_char_height();
			}
		}
		else
		{
			for( offset = screen_start;
					offset < screen_start + (get_screen_length() << 1);
								offset += ( get_offset_per_line() << 1 ))
			{
				(*paint_screen)( offset, 0, cur_ypos, get_bytes_per_line(), 1 );
				cur_ypos += get_host_char_height();
			}
		}
	}
	else
	{
		if( screen_start + (get_screen_length() << 1) > 4 * EGA_PLANE_DISP_SIZE )
		{
			int	next,next1;
			int	lines_left = (screen_start +
					((get_screen_length() - 2 * EGA_PLANE_DISP_SIZE) << 1)) /
										(get_offset_per_line() << 1);

			note_display_state0("Wrapping text");

			init_dirty_recs();
			next = ega_text_find_dirty_lines( &video_copy[screen_start >> 1],
						get_screen_ptr(screen_start), 0,
							lines_per_screen - lines_left, screen_start);

			next1 = ega_text_find_dirty_lines( video_copy, get_screen_ptr(0),
						lines_per_screen - lines_left, lines_per_screen, 0 );

			ega_text_paint_dirty_recs(0,next);
			ega_text_paint_dirty_recs(next,next1);
		}
		else
		{
			register	int	next;

			init_dirty_recs();
			next = ega_text_find_dirty_lines( &video_copy[screen_start >> 1],
						get_screen_ptr(screen_start), 0,
							lines_per_screen, screen_start);

			ega_text_paint_dirty_recs(0,next);
		}
	}

	host_end_update();

	setVideodirty_total(0);
#endif  //NEC_98
}

void ega_text_update IFN0()
{
#ifndef NEC_98
	register int i;				/* Loop counter		*/
	register USHORT *from,*to;
	register int cur_ypos;
	int	lines_per_screen;
	int	offset;
	int	screen_start;

	if (getVideodirty_total() == 0 || get_display_disabled() )
		return;

	host_start_update();

	screen_start=get_screen_start()<<2;	

	ALIGN_SCREEN_START(screen_start);

	lines_per_screen = get_screen_length()/get_offset_per_line();

	if(getVideodirty_total()>1500)	/* paint the whole lot */
	{
		to = (USHORT *)&video_copy[screen_start>>1];
		from = (USHORT *) get_screen_ptr(screen_start);

		for(i=get_screen_length()>>1;i>0;i--)
		{
			*to++ = *from;	/* char and attribute bytes */
			from += 2;		/* planes 2,3 interleaved */
		}

		cur_ypos = 0;
		for(offset=screen_start;offset<screen_start+(get_screen_length()<<1);
									offset+=(get_offset_per_line()<<1) )
		{
			(*paint_screen)(offset,0,cur_ypos,get_bytes_per_line(), 1);
			cur_ypos += get_host_char_height();
		}
	}
	else
	{
		register	int	next;

		init_dirty_recs();
		next = ega_text_find_dirty_lines( &video_copy[screen_start>>1],
			get_screen_ptr(screen_start), 0, lines_per_screen, screen_start);

		ega_text_paint_dirty_recs(0,next);

		remove_old_cursor();
	}

	setVideodirty_total(0);

	if (is_cursor_visible())
	{
		half_word attr;

		dirty_curs_x = get_cur_x();
		dirty_curs_y = get_cur_y();

		dirty_curs_offs = screen_start+dirty_curs_y * (get_offset_per_line()<<1) + (dirty_curs_x<<2);
		attr = *(get_screen_ptr(dirty_curs_offs + 1));

		host_paint_cursor( dirty_curs_x, dirty_curs_y, attr );
	}

	host_end_update();
#endif  //NEC_98
}
#endif /* EGG */

#ifdef SEGMENTATION 			/* See note with first use of this flag */
#include "SOFTPC_GRAPHICS.seg"
#endif

/*
 * Update the window to look like the regen buffer says it should
 */

void text_update IFN0()
{
#ifndef NEC_98

    register int i;	/* Loop counters		*/
    register int j,k;
    register IU32 *from,*to;
    register int ints_per_line = get_bytes_per_line()>>2;
    register int cur_ypos;
    int lines_per_screen;
    int	offset,len,x,screen_start;
    USHORT *wfrom;
    USHORT *wto;

    if (getVideodirty_total() == 0 || get_display_disabled() )
	return;

    lines_per_screen = get_screen_length()/get_bytes_per_line();

    host_start_update();
    screen_start=get_screen_start()<<1;
    ALIGN_SCREEN_START(screen_start);
    to = (IU32 *)&video_copy[screen_start];
    from = (IU32 *) get_screen_ptr(screen_start);

    if(getVideodirty_total()>1500)	/* paint the whole lot */
    {
	    for(i=get_screen_length()>>2;i>0;i--)*to++ = *from++;
	    cur_ypos = 0;
	    for(offset=0;offset<get_screen_length();offset+=get_bytes_per_line() )
	    {
		    (*paint_screen)(screen_start+offset,0,cur_ypos,get_bytes_per_line(), 1);
		    cur_ypos += get_host_char_height();
	    }
   }
   else
   {
	   for(i=0;i<lines_per_screen;i++)
	   {
	    for(j=0;j<ints_per_line;j++)
	    {
		if(*to++ != *from++)
		{
		    to--;from--;
		    for(k=ints_per_line-1-j;*(to+k)== *(from+k);k--){};
		    /*
		     * Note: For text mode there is one char for every word.
		     * no of bytes into screen=line*bytes_per_line + ints_into_line*4
		     * x_coord=width_of_one_char*(no_of_ints_into_line*2)
		     * y_coord=height_of_one_char*2*line
		     * length=no_of_ints*4+4     the plus 4 is to counteract the k--
		     * The host y co-ords are doubled
		     */

		    /* one or more ints of data are now selected
		       but refine difference to words (i.e. characters),
		       to avoid a glitch on the screen when typing in to
 		       a dumb terminal  */

		    offset = i * get_bytes_per_line() + (j<<2);
		    len    = (k<<2) + 4;
		    x      = (j<<1) * get_pix_char_width();
		    wfrom = (USHORT *)from;
		    wto   = (USHORT *)to;
		    if (*wfrom == *wto)
		    {
			offset += 2;
			x += get_pix_char_width();
			len -= 2;
		    }
		    wfrom += (k<<1) + 1;
		    wto   += (k<<1) + 1;
		    if (*wfrom == *wto)
		    {
			len -= 2;
		    }

		    (*paint_screen)(offset+screen_start,x,i*get_host_char_height(),len, 1);

		    for(k=j;k<ints_per_line;k++)
			*to++ = *from++;
		    break;	/* onto next line */
		}
	    }
	  }

	remove_old_cursor();
   }	/* end if(getVideodirty_total()>1500) */

    setVideodirty_total(0);

    if (is_cursor_visible())
    {
		half_word attr;

		dirty_curs_x = get_cur_x();
		dirty_curs_y = get_cur_y();

		dirty_curs_offs = screen_start+dirty_curs_y * get_offset_per_line() + (dirty_curs_x<<1);
		attr = *(get_screen_ptr(dirty_curs_offs + 1));

		host_paint_cursor( dirty_curs_x, dirty_curs_y, attr );
    }

    host_end_update();
#endif  //NEC_98
}

/*
 * Update the physical screen to reflect the CGA regen buffer
 */

LOCAL VOID
cga_graph_update_unchained IFN0()
{
#ifndef NEC_98
    LONG i, j, k, l;	/* Loop counters		*/
    IU32 *from,*to;
    LONG cur_ypos;
    LONG offs;

    if (getVideodirty_total() == 0 || get_display_disabled() ) return;

    host_start_update();

	/*
	 * Graphics mode
	 */

	to = (IU32 *)&video_copy[0];
	from = (IU32 *) get_screen_ptr(0);

	if (getVideodirty_total() > 5000)	
	{
	    /*
	     * Refresh the whole screen from the regen buffer
	     */

		for(i=4096;i>0;i--)
		{
			*to++ = *from++;
		}

	    for (cur_ypos = 0,offs=0; cur_ypos < 400; offs += SCAN_LINE_LENGTH, cur_ypos += 4)
	    {
		(*paint_screen)(offs,0,cur_ypos,SCAN_LINE_LENGTH,1);
		(*paint_screen)((offs+ODD_OFFSET),0,cur_ypos+2,SCAN_LINE_LENGTH,1);
	    }
	}
	else
	{
		/*
		 * Draw the dirtied blocks
		 */

		/* do even lines */

		for (i = 0; i < 100; i++ )
		{
			for(j=20;j>0;j--)
			{
				if(*to != *from)
				{
					for(k=j-1;*(to+k)== *(from+k);k--)
						;

				/*
				 * i is pc scanline no/2,
				 * so offset=(i*SCAN_LINE_LENGTH + bytes_into_line)*inc_count
				 * host_x = bytes_into_line*8	-- 8 pixels per byte
				 * host_y = i*2*2 		-- to convert pc scanlines to host ones
				 * length = k			-- plus one to counteract k-- in loop
				 */

					(*paint_screen)
						(((i*SCAN_LINE_LENGTH+((20-j)<<2))),
											(20-j)<<5,i<<2,(k<<2)+4,1);

					for(l=k+1;l>0;l--)
					{
						*to++ = *from++;
					}

					l = j - k - 1;
					to += l;
					from += l;

					break;	/* onto next line */
				}

				to++;
				from++;
			}
		}

		/* do odd  lines */

		from = (IU32 *) get_screen_ptr(ODD_OFFSET);
		to = (IU32 *)&video_copy[ODD_OFFSET];

		for (i = 0; i < 100; i++ )
		{
			for(j=20;j>0;j--)
			{
				if(*to != *from)
				{
					for(k=j-1;*(to+k)== *(from+k);k--)
						;
					/*
					 * i=line_no/2
					 * j=bytes_from_end => (80-j)=bytes from start of line
					 * k=no of bytes less 1 different => length in bytes=k+1
					 * offset=(i*SCAN_LINE_LENGTH+OFFSET_TO_ODD_BANK+
					 *						 (80-j))*inc_count
					 */

					(*paint_screen)(
					((i*SCAN_LINE_LENGTH+ODD_OFFSET+((20-j)<<2))),
											(20-j)<<5,(i<<2)+2,(k<<2)+4,1);

					for(l=k+1;l>0;l--)
					{
						*to++ = *from++;
					}

					l = j - k - 1;
					to += l;
					from += l;

					break;	/* onto next line */
				}

				to++;
				from++;
			}
		}
	}

    host_end_update();

    setVideodirty_total(0);
#endif  //NEC_98
}

#ifdef	EGG
LOCAL VOID
cga_graph_update_chain2 IFN0()
{
#ifndef NEC_98
    LONG i, j, k, l;	/* Loop counters		*/
    USHORT *from,*to;
    LONG cur_ypos;
    LONG offs;
	SHORT start_line, end_line;

	if (getVideodirty_total() == 0 || get_display_disabled() )
		return;

    host_start_update();

	/*
	 * Graphics mode
	 */

	to = (USHORT *)&video_copy[0];
	from = (USHORT *) get_screen_ptr(0);

	if (getVideodirty_total() > 5000)	
	{
		/*
		 * Refresh the whole screen from the regen buffer
		 */

		for(i=4096*2;i>0;i--)
		{
			*to++ = *from;
			from += 2;
		}

		for (cur_ypos = 0,offs=0; cur_ypos < 400;
			offs += SCAN_LINE_LENGTH, cur_ypos += 4)
		{
			(*paint_screen)(offs<<1,0,cur_ypos,SCAN_LINE_LENGTH,1);
			(*paint_screen)((offs+ODD_OFFSET)<<1,0,cur_ypos+2,
					SCAN_LINE_LENGTH,1);
		}
	}
	else
	{
		/*
		 * Draw the dirtied blocks
		 */

		/*
		 * Start and end line represent the lines within the 8 K video
		 * memory blocks, NOT the lines as they appear on screen.
		 */
		start_line = (short)(getVideodirty_low() / SCAN_LINE_LENGTH);
		end_line = (short)((getVideodirty_high() / SCAN_LINE_LENGTH) + 1);

		/* AJO 6/1/92
		 * Can get start/end lines past end of screen since video bank
		 * is larger than actally required for these modes; just ignore
		 * lines after end of screen. Not doing this check can cause
		 * incorrect screen update for programs that deliberately write
		 * into the memory between the end of that used for the screen
		 * display and the end of the bank (e.g. PCLABS).
		 */
		if (start_line <= 100)
		{
		    if (end_line > 100)
				end_line = 100;

		    to = (USHORT *)&video_copy[start_line * SCAN_LINE_LENGTH];
		    from = (USHORT *)get_screen_ptr((start_line *
						     SCAN_LINE_LENGTH) << 1);

			/* do even lines */
	
			for (i = start_line; i < end_line; i++ )
			{
				for(j=40;j>0;j--)
				{
					if(*to != *from)
					{
						for(k=j-1;*(to+k)== *(from+(k<<1));k--)
							;
	
	
/*
 * i is pc scanline no/2,
 * so offset=(i*SCAN_LINE_LENGTH + bytes_into_line)*inc_count
 * host_x = bytes_into_line*8	-- 8 pixels per byte
 * host_y = i*2*2 		-- to convert pc scanlines to host ones
 * length = k			-- plus one to counteract k-- in loop
 */
	
						(*paint_screen)(
							((i*SCAN_LINE_LENGTH+((40-j)<<1))<<1),
							(40-j)<<4,i<<2,(k<<1)+2,1);
	
						for(l=k+1;l>0;l--)
						{
							*to++ = *from;
							from += 2;
						}
	
						l = j - k - 1;
						to += l;
						from += l << 1;
	
						break;	/* onto next line */
					}
	
					to++;
					from += 2;
				}
			}
	
			/* do odd  lines */
	
			from = (USHORT *) get_screen_ptr((start_line * SCAN_LINE_LENGTH + ODD_OFFSET) << 1);
			to = (USHORT *)&video_copy[start_line * SCAN_LINE_LENGTH + ODD_OFFSET];
	
			for (i = start_line; i < end_line; i++ )
			{
				for(j=40;j>0;j--)
				{
					if(*to != *from)
					{
						for(k=j-1;*(to+k)== *(from+(k<<1));k--)
							;
	
/*
 * i=line_no/2
 * j=bytes_from_end => (80-j)=bytes from start of line
 * k=no of bytes less 1 different => length in bytes=k+1
 * offset=(i*SCAN_LINE_LENGTH+OFFSET_TO_ODD_BANK+(80-j))*inc_count
 */
	
						(*paint_screen)(
						((i*SCAN_LINE_LENGTH+ODD_OFFSET+((40-j)<<1))<<1),
												(40-j)<<4,(i<<2)+2,(k<<1)+2,1);
	
						for(l=k+1;l>0;l--)
						{
							*to++ = *from;
							from += 2;
						}
	
						l = j - k - 1;
						to += l;
						from += l << 1;
	
						break;	/* onto next line */
					}
	
					to++;
					from += 2;
				}
			}
		}
	}

	clear_dirty();

    host_end_update();
#endif  //NEC_98
}

LOCAL VOID
cga_graph_update_chain4 IFN0()
{
#ifndef NEC_98
    LONG i, j, k, l;		/* Loop counters		*/
    UTINY *from,*to;
    LONG cur_ypos;
    LONG	offs;
	SHORT start_line, end_line;

	if (getVideodirty_total() == 0 || get_display_disabled() )
		return;

    host_start_update();

	/*
	 * Graphics mode
	 */

	to = (UTINY *)&video_copy[0];
	from = (UTINY *) get_screen_ptr(0);

	if (getVideodirty_total() > 5000)	
	{
		/*
		 * Refresh the whole screen from the regen buffer
		 */

		for(i=4096*4;i>0;i--)
		{
			*to++ = *from;
			from += 4;
		}

		for (cur_ypos = 0,offs=0; cur_ypos < 400;
		 offs += SCAN_LINE_LENGTH, cur_ypos += 4)
		{
			(*paint_screen)(offs<<2,0,cur_ypos,SCAN_LINE_LENGTH,1);
			(*paint_screen)((offs+ODD_OFFSET)<<2,0,cur_ypos+2,
					SCAN_LINE_LENGTH,1);
		}
	}
	else
	{
		/*
	     * Draw the dirtied blocks
	     */

		/*
		 * start and end line represent the lines within the 8 K video
		 * memory blocks, NOT the lines as they appear on screen.
		 */
		start_line = (short)(getVideodirty_low() / SCAN_LINE_LENGTH);
		end_line = (short)((getVideodirty_high() / SCAN_LINE_LENGTH) + 1);
	
		/* AJO 6/1/92
		 * Can get start/end lines past end of screen since video bank
		 * is larger than actally required for these modes; just ignore
		 * lines after end of screen. Not doing this check can cause
		 * incorrect screen update for programs that deliberately write
		 * into the memory between the end of that used for the screen
		 * display and the end of the bank (e.g. PCLABS).
		 */
		if (start_line <= 100)
		{
		    if (end_line > 100)
			end_line = 100;

		    to = (UTINY *)&video_copy[start_line * SCAN_LINE_LENGTH];
		    from = (UTINY *) get_screen_ptr((start_line *
						     SCAN_LINE_LENGTH) << 2);

	    	    /* do even lines */

			for (i = start_line; i < end_line; i++ )
			{
				for(j=80;j>0;j--)
				{
					if(*to != *from)
					{
						for(k=j-1;*(to+k)== *(from+(k<<2));k--)
						;
					
/*
 * i is pc scanline no/2, so offset=(i*SCAN_LINE_LENGTH +
 *				     		bytes_into_line)*inc_count
 * host_x = bytes_into_line*8	-- 8 pixels per byte
 * host_y = i*2*2 		-- to convert pc scanlines to host ones
 * length = k			-- plus one to counteract k-- in loop
 */
					
						(*paint_screen)(
							(i*SCAN_LINE_LENGTH+(80-j))<<2,
							(80-j)<<3,i<<2,k+1,1);
					
					for(l=k+1;l>0;l--)
					{
						*to++ = *from;
						from += 4;
					}
					
					l = j - k - 1;
					to += l;
					from += l << 2;
					
						break;	/* onto next line */
					}
		
					to++;
					from += 4;
				}
			}
			/* do odd  lines */
	
			from = (UTINY *) get_screen_ptr(((start_line * SCAN_LINE_LENGTH) + ODD_OFFSET)<<2);
			to = (UTINY *)&video_copy[(start_line * SCAN_LINE_LENGTH) + ODD_OFFSET];
	
			for (i = start_line; i < end_line; i++ )
			{
				for(j=80;j>0;j--)
				{
					if(*to != *from)
					{
						for(k=j-1;*(to+k)== *(from+(k<<2));k--)
						;
/*
 * i=line_no/2
 * j=bytes_from_end => (80-j)=bytes from start of line
 * k=no of bytes less 1 different => length in bytes=k+1
 * offset=(i*SCAN_LINE_LENGTH+OFFSET_TO_ODD_BANK+(80-j))*inc_count
 */
					
						(*paint_screen)(
							(i*SCAN_LINE_LENGTH+(80-j)+ODD_OFFSET)<<2,
							(80-j)<<3,(i<<2)+2,k+1,1);
					
					for(l=k+1;l>0;l--)
					{
						*to++ = *from;
						from += 4;
					}
					
					l = j - k - 1;
					to += l;
					from += l << 2;
					
						break;	/* onto next line */
					}
	
					to++;
					from += 4;
				}
			}
		}
	}

	clear_dirty();

    host_end_update();
#endif  //NEC_98
}
#endif	/* EGG */

GLOBAL VOID
cga_med_graph_update IFN0()

{
#ifndef NEC_98

	/*
	 *	The med res CGA graphics mode ( mode 4 ) is an EGA CHAIN2 mode !!
	 *	It uses the simple ega copy routines that use an interleaved format
	 *	for the data.
	 */

#ifdef EGG
	if( video_adapter != CGA )
		cga_graph_update_chain2( );
	else
#endif
		cga_graph_update_unchained( );
#endif  //NEC_98
}

GLOBAL VOID
cga_hi_graph_update IFN0()

{
#ifndef NEC_98

	/*
	 *	The hi res CGA graphics mode ( mode 6 ) is an EGA CHAIN4 mode !!
	 *	It uses the simple ega copy routines that use an interleaved format
	 *	for the data.
	 */

#ifdef EGG
	if( video_adapter != CGA )
		cga_graph_update_chain4( );
	else
#endif
		cga_graph_update_unchained( );
#endif  //NEC_98
}

#ifdef EGG

#ifdef SEGMENTATION 		/* See note with first use of this flag */
#include "SOFTPC_EGA.seg"
#endif

void	ega_wrap_split_graph_update IFN0()
{
#ifndef NEC_98
	register	int	bpl;
	register	int	quarter_opl;
	register	int	screen_split;

	if ( getVideodirty_total() == 0 || get_display_disabled() )
		return;

	screen_split=get_screen_split();

	/*
	 * make sure don't fall off end of screen
	 */

	if (screen_split>get_screen_height())
		screen_split = get_screen_height();

	bpl = get_bytes_per_line();
	quarter_opl = get_offset_per_line()>>2;

	host_start_update();

	if (getVideodirty_total() > 20000 ) {
		int split_scanlines = get_screen_height() - screen_split;

		if ( get_screen_start() + screen_split*get_offset_per_line() > EGA_PLANE_DISP_SIZE ) {
			assert0(NO,"Panic he wants to do split screens and wrappig!!");

			/*
			 * Ignore wrapping for now
			 */

			memset(&video_copy[get_screen_start()>>2],0,screen_split*quarter_opl);
			(*paint_screen)( get_screen_start(), 0, 0, bpl, screen_split );
		}
		else {
			memset(&video_copy[get_screen_start()>>2],0,screen_split*quarter_opl);
			(*paint_screen)( get_screen_start(), 0, 0, bpl, screen_split );
		}
		if (split_scanlines>0) {
			memset(&video_copy[0],0,split_scanlines*quarter_opl);
			(*paint_screen)( 0, 0, screen_split, bpl, split_scanlines);
		}
	}
	else {
		int	next,next1;

		init_dirty_recs();

		if ( get_screen_start() + screen_split*get_offset_per_line() > EGA_PLANE_DISP_SIZE ) {
			assert0(NO, "Wrapping and spliting, its too much for my head");
			next = search_video_copy(0,screen_split,get_screen_start()>>2);
		}
		else {
			next = search_video_copy(0,screen_split,get_screen_start()>>2);
		}
		next1 = search_video_copy(screen_split,get_screen_height(),0);

		paint_records(0,next);
		paint_records(next,next1);
	}

	clear_dirty();

    	host_end_update();
#endif  //NEC_98
}

void	ega_split_graph_update IFN0()
{
#ifndef NEC_98
	register	int	bpl;
	register	int	quarter_opl;
	register	int	screen_split;
	register	int	screen_height;

	if ( getVideodirty_total() == 0 || get_display_disabled() )
		return;

	screen_split  = get_screen_split()/get_pc_pix_height();
	screen_height = get_screen_height()/get_pc_pix_height();

	/*
	 * make sure don't fall off end of screen
	 */

	if (screen_split > screen_height)
		screen_split = screen_height;

	bpl = get_bytes_per_line();
	quarter_opl = get_offset_per_line()>>2;

    	host_start_update();

	if (getVideodirty_total() > 20000 ) {
		int split_scanlines = screen_height - screen_split;

		memset(&video_copy[get_screen_start()>>2],0,screen_split*quarter_opl);
		(*paint_screen)( get_screen_start(), 0, 0, bpl, screen_split );
		if (split_scanlines>0) {
			memset(&video_copy[0],0,split_scanlines*quarter_opl);
			(*paint_screen)( 0, 0, screen_split, bpl, split_scanlines);
		}
	}
	else {
		int	next,next1;

		init_dirty_recs();

		next = search_video_copy(0,screen_split,get_screen_start()>>2);
		next1 = search_video_copy(screen_split,screen_height,0);

		paint_records(0,next);
		paint_records(next,next1);
	}

	clear_dirty();

    	host_end_update();
#endif  //NEC_98
}

#ifdef VGG
/* again v similar to ega version but works on 1 large plane instead of 4 */
static	void	vga_paint_records IFN2(int, start_rec, int, end_rec)
{
#ifndef NEC_98
	register	DIRTY_PARTS	*i,*end_ptr;
	int dirty_frig;

	i= &dirty[start_rec];
	end_ptr =  &dirty[end_rec];
	while (i<end_ptr) {
		register	int	last_line, cur_start, cur_end,max_width;
		int 	first_line;
		int	dirty_vc_offset;

		first_line = i->line_no;
		last_line = first_line;
		cur_start = i->start;
		cur_end = i->end;
		max_width = (cur_end-cur_start) << 1;	/* To split up diagonal lines */

		/*
		 * offset in bytes into video_copy, which is equivalent to off
		 * into 'large' vga plane
		 */

		dirty_vc_offset = i->video_copy_offset;
		dirty_frig = i->v7frig;
		i++;
		while (i < end_ptr) {
			if ( i->line_no - last_line < 3 ) {
                                /*
                                 * This entry can be included into the same paint
                                 * as long as it doesn't make the rectangle too wide
                                 */
                                if ( i->end > cur_end ){
                                        if(i->end - cur_start > max_width)break;
                                        cur_end = i->end;
                                }
                                if ( i->start < cur_start ){
                                        if(cur_end - i->start > max_width)break;
                                        cur_start = i->start;
                                }
				last_line = i->line_no;
				i++;
			}
			else
			  break;
		}
		/*
		 * paint the rectangle found
		 */

		/* do not paint beyond the right hand side of the screen;
		   these checks were put in to cope with the special
		   case of the brain-scan display in 'EGAWOW' */
		if (cur_end > get_bytes_per_line())
			cur_end = get_bytes_per_line();
		if (cur_end > cur_start)
			(*paint_screen)((dirty_vc_offset<<2) + dirty_frig + cur_start,
			cur_start, first_line, cur_end-cur_start,
			last_line-first_line+1);
	}
	/* Clear out video copy */
	for(i = &dirty[start_rec];i<end_ptr;i++)
	{
		register byte *j,*end;
		end = &video_copy[ i->video_copy_offset+(i->end>>2)];
		j =  &video_copy[ i->video_copy_offset+(i->start>>2) + i->v7frig];
		do *j++ = 0; while(j<end);
	}
#endif  //NEC_98
}


/* dramatically similar to ega graph update but calls vga-ish paint interface */
void	vga_graph_update IFN0()
{
#ifndef NEC_98
	register	int	opl = get_offset_per_line();
	register	int	bpl = get_bytes_per_line();
	int		screen_height = get_screen_height()/
					(get_char_height()*get_pc_pix_height());

	if ( getVideodirty_total() == 0 || get_display_disabled() )
		return;

    	host_start_update();

	if (!HostUpdatedVGA()) {
		if (getVideodirty_total() > 20000 )
		{
			register	byte	*vcopy = &video_copy[get_screen_start()>>2];
	
			memset(vcopy,0,get_screen_length()>>2);
			(*paint_screen)( get_screen_start(), 0, 0, bpl, screen_height );
	
#ifdef V7VGA
			draw_v7ptr();
#endif /* V7VGA */
		}
		else
		{
			register	int	next;
			register	int	start_line,end_line;
	
			start_line = ((getVideodirty_low()<<2) - get_screen_start())/opl;
			end_line = ((getVideodirty_high()<<2) - get_screen_start())/opl + 1;  /* changed from +2, but I'm not happy. WJG 24/5/89 */
	
			if(start_line<0)start_line = 0;
			if (end_line > screen_height)
				end_line = screen_height;
			if(start_line < end_line)	/* Sanity check - could be drawing to another page */
			{
		/*
		   6.4.92 MG
		   We remove the pointer before the update. Hits performance, but
		   makes the display work correctly.
		*/
	
#ifdef V7VGA
				if (v7ptr_between_lines(start_line,end_line))
					remove_v7ptr();
#endif /* V7VGA */
	
				init_dirty_recs();
				/* see if we can search the video copy by ints instead of bytes - need opl divisible by 16 */
				if(opl & 15)
#ifdef VGG
					if (opl & 3)
						next = v7_search_video_copy(start_line,end_line,(get_screen_start()+start_line*opl)>>2);
					else
#endif /* VGG */
						next = search_video_copy(start_line,end_line,(get_screen_start()+start_line*opl)>>2);
				else
					next = search_video_copy_aligned(start_line,end_line,(get_screen_start()+start_line*opl)>>2);
				vga_paint_records(0,next);
	
#ifdef V7VGA
		/*
		 * We might have just blatted over the V7 h/w graphics pointer.
		 * Hence redraw it. A more intelligent solution would be preferable.
		 *
		 * 6/4/92 MG We now have a somewhat more intelligent solution,
		 * checking if the pointer is in the update region before we
		 * draw it.
		 */
	
				if (v7ptr_between_lines(start_line,end_line))
					draw_v7ptr();
#endif /* V7VGA */
	
			}
		}
	}														/* Host didn't update screen itself */
	
	clear_dirty();

	host_end_update();
#endif  //NEC_98
}

void	vga_split_graph_update IFN0()
{
#ifndef NEC_98
	register	int	bpl;
	register	int	quarter_opl;
	register	int	screen_split;
	register	int	screen_height;

	if ( getVideodirty_total() == 0 || get_display_disabled() )
		return;

	screen_split = get_screen_split() /
		       (get_char_height() * get_pc_pix_height());
	screen_height = get_screen_height() /
			(get_char_height() * get_pc_pix_height());

	/*
	 * make sure don't fall off end of screen
	 */

	if (screen_split>screen_height)
		screen_split = screen_height;

	bpl = get_bytes_per_line();
	quarter_opl = get_offset_per_line()>>2;

    	host_start_update();

	if (getVideodirty_total() > 20000 ) {
		int split_scanlines = screen_height - screen_split;

		memset(&video_copy[get_screen_start()>>2],0,screen_split*quarter_opl);
		(*paint_screen)( get_screen_start(), 0, 0, bpl, screen_split );
		if (split_scanlines>0) {
			memset(&video_copy[0],0,split_scanlines*quarter_opl);
			(*paint_screen)( 0, 0, screen_split, bpl, split_scanlines);
		}
	}
	else {
		int	next,next1;

		init_dirty_recs();

		next = search_video_copy(0,screen_split,get_screen_start()>>2);
		next1 = search_video_copy(screen_split,screen_height,0);

		vga_paint_records(0,next);
		vga_paint_records(next,next1);
	}

	clear_dirty();

    	host_end_update();
#endif  //NEC_98
}

#endif /* VGG */

void	ega_graph_update IFN0()
{
#ifndef NEC_98
	register	int	opl = get_offset_per_line();
	register	int	bpl = get_bytes_per_line();

	if ( getVideodirty_total() == 0 || get_display_disabled() )
		return;

    host_start_update();

	if (!HostUpdatedEGA()) {
		if (getVideodirty_total() > 20000)
		{
			register	byte	*vcopy = &video_copy[get_screen_start()>>2];
	
			memset(vcopy,0,get_screen_length()>>2);
			(*paint_screen)( get_screen_start(), 0, 0, bpl, get_screen_height()/get_pc_pix_height());
		}
		else
		{
			register	int	next;
			register	int	start_line,end_line;
	
			start_line = ((getVideodirty_low()<<2) - get_screen_start())/opl;
			end_line = ((getVideodirty_high()<<2) - get_screen_start())/opl + 1;  /* changed from +2, but I'm not happy. WJG 24/5/89 */
			if(start_line<0)start_line = 0;
			if(end_line>(get_screen_height()/get_pc_pix_height()))end_line = get_screen_height()/get_pc_pix_height();
			if(start_line < end_line)	/* Sanity check - could be drawing to another page */
			{
				init_dirty_recs();
	
				/*
				 * See if we can search the video copy by ints instead of bytes
				 * - we need opl and the screen_start divisible by 16
				 */
	
				if(( opl & 15 ) || ( get_screen_start() & 15 ))
#ifdef VGG
					if (opl & 3)
						next = v7_search_video_copy( start_line,
								end_line, (get_screen_start()+start_line*opl) >> 2 );
					else
#endif /* VGG */
						next = search_video_copy( start_line,
								end_line, (get_screen_start()+start_line*opl) >> 2 );
				else
					next = search_video_copy_aligned( start_line,
								end_line, (get_screen_start()+start_line*opl) >> 2 );
	
				paint_records(0,next);
			}
		}
	}													/* Host updated EGA screen */
	
	clear_dirty();

#ifdef V7VGA
	/*
	 * We might have just blatted over the V7 h/w graphics pointer.
	 * Hence redraw it. A more intelligent solution would be preferable.
	 */

	draw_v7ptr();
#endif /* V7VGA */

	host_end_update();
#endif  //NEC_98
}


void	ega_wrap_graph_update IFN0()
{
#ifndef NEC_98
	register	int	opl = get_offset_per_line();
	register	int	bpl = get_bytes_per_line();

	if ( getVideodirty_total() == 0 || get_display_disabled() )
		return;

    	host_start_update();

	if (getVideodirty_total() > 20000 ) {
		register	byte	*vcopy = &video_copy[get_screen_start()>>2];

		if (get_screen_start()+get_screen_length()>EGA_PLANE_DISP_SIZE) {
			register	int	offset = (EGA_PLANE_DISP_SIZE - get_screen_start());
			register	int	left_over = offset % opl;
			register	int	ht1 = offset / opl;
			register	int	ht2 = get_screen_height() - ht1 - 1;
			register	int	quarter_opl = opl>>2;

			memset(vcopy,0,offset>>2);
			memset(&video_copy[0],0,(get_screen_length()-offset)>>2);
			(*paint_screen)( get_screen_start(), 0, 0, bpl, ht1 );

			/*
			 * Deal with line that is split by wrapping
			 */

			if ( left_over > bpl ) {
				(*paint_screen)( ht1*opl, 0, ht1, bpl, 1);
			}
			else {
				(*paint_screen)( get_screen_start()+ht1*opl, 0, ht1, left_over, 1);
				(*paint_screen)( 0, left_over<<3, ht1, bpl-left_over, 1);
			}

			(*paint_screen)( opl-left_over, 0, ht1+1, bpl, ht2 );
		}
		else {
			memset(vcopy,0,get_screen_length()>>2);
			(*paint_screen)( get_screen_start(), 0, 0, bpl, get_screen_height() );
		}
	}
	else {
		register	int	next;

		init_dirty_recs();
		if (get_screen_start()+get_screen_length()>EGA_PLANE_DISP_SIZE) {

			register	int	offset = (EGA_PLANE_DISP_SIZE - get_screen_start());
			register	int	left_over = offset % opl;
			register	int	ht1 = offset / opl;
			register	int	next1;
			register	int	wrapped_bytes = opl-left_over;


			/*
			 * Search video copy
			 */

			next = search_video_copy(0,ht1,get_screen_start()>>2);
			next1 = search_video_copy(ht1,get_screen_height(),wrapped_bytes>>2);

			paint_records(0,next);

			/*
			 * paint middle line anyway 'cos its too hard to work out whats happened
			 */

			if (left_over<bpl) {
				(*paint_screen)(EGA_PLANE_DISP_SIZE-left_over,0,ht1,left_over,1);
				(*paint_screen)(0,left_over<<3,ht1,bpl-left_over,1);
			}
			else {
				(*paint_screen)(EGA_PLANE_DISP_SIZE-left_over,0,ht1,bpl,1);
			}

			/*
			 * now do wrapped area
			 */

			paint_records(next,next1);
		}
		else {
			next = search_video_copy(0,get_screen_height(),get_screen_start()>>2);
			paint_records(0,next);
		}
	}

	clear_dirty();

    	host_end_update();
#endif  //NEC_98
}

#endif /* EGG */

#ifdef SEGMENTATION 		/* See note with first use of this flag */
#include "SOFTPC_GRAPHICS.seg"
#endif

/*---------------------  Scrolling routines --------------------------*/

#define UP	0
#define DOWN	1

LOCAL VOID
adjust_cursor IFN7(ULONG, dirn, ULONG, tlx, ULONG, tly, ULONG, width,
	ULONG, height, ULONG, lines, ULONG, bpl )
{
#ifndef NEC_98

	/*
	 * We must not adjust dirty_curs_offset here if it is -1, as this tells
	 * us that the cursor is not displayed. If dirty_curs_offs becomes
	 * positive, we fool remove_old_cursor into trying to replace the cursor
	 * with spurious data.  JJS - 29/6/95.
	 */
	if (dirty_curs_offs != -1)
		if(( dirty_curs_x >= (LONG)tlx ) && ( dirty_curs_x < (LONG)(( tlx + width ))))
			if(( dirty_curs_y >= (LONG)tly ) && ( dirty_curs_y < (LONG)(( tly + height ))))
			{
				switch( dirn )
				{
				case UP:
					dirty_curs_y -= lines;
					dirty_curs_offs -= lines * bpl * 2;
					break;

				case DOWN:
					dirty_curs_y += lines;
					dirty_curs_offs += lines * bpl * 2;
					break;
				}
				setVideodirty_total(getVideodirty_total() + 1);
			}
#endif  //NEC_98
}

/*ARGSUSED5*/
boolean text_scroll_up IFN6(int, start, int, width, int, height,
	int, attr, int, lines, int, dummy_arg)
{
#ifndef NEC_98
    short blank_word, *ptr, *top_left_ptr,*top_right_ptr, *bottom_right_ptr;
    unsigned short dummy;
    unsigned char *p;
    int words_per_line;
	int i,tlx,tly,htlx,htly,colour;
	int bpl = 2*get_chars_per_line();
	long start_offset;
	register half_word *src,*dest;
	register word *s_ptr,*d_ptr;
	register word data;
	register int j;
	boolean result;

	UNUSED(dummy_arg);

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
	if ( getVM() )
	   return FALSE;   /* Don't optimise in V86 Mode */
#endif

	if (video_adapter == MDA)
	{	
		/*
		 * The colour we fill with for MDA is either black or low intensity white,
		 * depending on whether the attribute byte specifies reverse video.
		 */
		colour = ((attr & 0x77) == 0x70)? 1 : 0;
	}
	else
	{
		/*
		 * The colour we fill with for colour text displays is controlled by
		 * bits 4-6 of attr, with bit 7 turning on blinking (which we don't support)
		 */
		colour = (attr & bg_col_mask) >> 4;
	}
/*
 * Reduce the width of the rectangle if any right hand area is completely
 * blank.
 *
 * Don't reduce the size of the scrolling region for a dumb terminal.
 * Dumb terminal uses line feeds to scroll up, but only if the whole
 * screen is to be scrolled.  Reducing the scroll region causes
 * the whole region to be redrawn.
 */

#ifdef DUMB_TERMINAL
        if (terminal_type != TERMINAL_TYPE_DUMB)
        {
#endif /* DUMB_TERMINAL */

		/* originally dummy was char [2] */
		/* unfortunately doing (short) *dummy */
		/* causes a bus error on M88K */
		p = (unsigned char *) &dummy;
		p [0] = ' ';
		p [1] = (unsigned char)attr;
	    blank_word = dummy;

	    words_per_line   = get_chars_per_line();
	    top_left_ptr = (short *) get_screen_ptr((start - gvi_pc_low_regen)<<1);
        top_right_ptr    = top_left_ptr + width - 2;
	    bottom_right_ptr = top_right_ptr + bpl * (height - 1);
	    ptr = bottom_right_ptr;
	    if (width > 2) /* dont want to get a zero rectangle for safetys sake */
	    {
	        while (*ptr == blank_word)
	        {
	            if (ptr == top_right_ptr) 	/* reached top of column? */
	            {
		        top_right_ptr -= 2;	/* yes go to bottom of next */
		        bottom_right_ptr -= 2;
		        if (top_right_ptr == top_left_ptr)
		            break;
		        ptr = bottom_right_ptr;
	            }
	            else
		        ptr -= bpl;	/* skipping interleaved planes */
	        }
	    }
	    width = (int)(top_right_ptr - top_left_ptr + 2) << 1;
#ifdef DUMB_TERMINAL
	}
#endif /* DUMB_TERMINAL */

	/* Do the host stuff */

	start_offset = start - sas_w_at_no_check(VID_ADDR) - gvi_pc_low_regen;

	tlx = (int)(start_offset%get_bytes_per_line());
	
	htlx = tlx	* get_pix_char_width()/2;

	tly = (int)(start_offset/get_bytes_per_line());
	htly = tly * get_host_char_height();

	result = host_scroll_up(htlx,htly,htlx+width/4*get_pix_char_width()-1,
				htly+height*get_host_char_height()-1, lines*get_host_char_height(),colour);

	if(!result)
		return FALSE;

	adjust_cursor( UP, tlx >> 1, tly, width >> 2, height, lines, bpl );

	/* Scroll up the video_copy */

	dest = video_copy + start - gvi_pc_low_regen;
	src = dest + lines * bpl;

	if( width == (2 * bpl))
	{
		/* Can do the whole thing in one go */

		memcpy(dest,src,(width>>1)*(height-lines));
		fwd_word_fill( (short)((' '<<8) | attr), dest+(width>>1)*(height-lines),(width>>1)*lines/2);
	}
	else
	{
		/* Not scrolling whole width of screen, so do each line seperately */
		for(i=0;i<height-lines;i++)
		{
			memcpy(dest,src,width>>1);
			dest += bpl;
			src += bpl;
		}

		/* Fill exposed area of video copy */

		for(i=0;i<lines;i++)
		{
			fwd_word_fill( (short)((' '<<8) | attr), dest,width>>2);
			dest += bpl;
		}
	}

	/* Update video buffer */

	dest = get_screen_ptr((start - gvi_pc_low_regen)<<1);
	src = dest + lines * bpl * 2;

	for(i=0;i<height-lines;i++)
	{
		j = width >> 2;
		d_ptr = (word *)dest;
		s_ptr = (word *)src;

		while( j-- > 0 )
		{
			*d_ptr = *s_ptr;		/* CHAR  and  ATTRIB */
			d_ptr += 2;			/* skip FONT and plane 3 */
			s_ptr += 2;
		}

		dest += bpl * 2;
		src += bpl * 2;
	}

	/* Fill exposed area of buffer */

#ifdef BIGEND
	data = (' ' << 8) | attr;
#else
	data = (attr << 8) | ' ';
#endif

	for(i=0;i<lines;i++)
	{
		j = width >> 2;
		d_ptr = (word *) dest;

		while( j-- > 0 )
		{
			*d_ptr = data;
			d_ptr += 2;
		}

		dest += bpl * 2;
	}

	host_scroll_complete();

#endif  //NEC_98
	return TRUE;
}

/*ARGSUSED5*/
boolean text_scroll_down IFN6(int, start, int, width, int, height,
	int, attr, int, lines,int,dummy_arg)
{
#ifndef NEC_98
	int i,tlx,tly,htlx,htly,colour;
	int bpl = 2*get_chars_per_line();
	long start_offset;
	register half_word *src,*dest;
	register word *d_ptr,*s_ptr;
	register word data;
	register int j;
	boolean result;

	UNUSED(dummy_arg);
	
#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
	if ( getVM() )
	   return FALSE;   /* Don't optimise in V86 Mode */
#endif

	if(video_adapter == MDA)
	{	
		/*
		 * The colour we fill with for MDA is either black or low intensity white,
		 * depending on whether the attribute byte specifies reverse video.
		 */
		colour = ((attr & 0x77) == 0x70)? 1 : 0;
	}
	else
	{
		/*
		 * The colour we fill with for colour text displays is controlled by
		 * bits 4-6 of attr, with bit 7 turning on blinking (which we don't support)
		 */
		colour = (attr & bg_col_mask) >>4;
	}

	width <<= 1;

	/* Do the host stuff */

	start_offset = start - get_screen_start() * 2 - gvi_pc_low_regen;

	tlx = (int)(start_offset%get_bytes_per_line());
	htlx = tlx	* get_pix_char_width()/2;

	tly = (int)(start_offset/get_bytes_per_line());
	htly = tly * get_host_char_height();

	result = host_scroll_down(htlx,htly,htlx+width/4*get_pix_char_width()-1,
			htly+height*get_host_char_height()-1, lines*get_host_char_height(),colour);

	if(!result)
		return FALSE;

	adjust_cursor( DOWN, tlx >> 1, tly, width >> 2, height, lines, bpl );

	/* Scroll down the video_copy */

	if( width == (2 * bpl))
	{
		/* Can do the whole thing in one go */
		src = video_copy + start - gvi_pc_low_regen;
		dest = src + lines * bpl;
		memcpy(dest,src,(width>>1)*(height-lines));
		fwd_word_fill( (short)((' '<<8) | attr), src,(width>>1)*lines/2);
	}
	else
	{
		/* Not scrolling whole width of screen, so do each line seperatly */
		dest = video_copy + start-gvi_pc_low_regen + (height-1) * bpl;
		src = dest - lines * bpl;
		for(i=0;i<height-lines;i++)
		{
			memcpy(dest,src,width>>1);
			dest -= bpl;
			src -= bpl;
		}

		/* Fill exposed area of video copy */

		for(i=0;i<lines;i++)
		{
			fwd_word_fill( (short)((' '<<8) | attr), dest,width>>2);
			dest -= bpl;
		}
	}

	/* Update video buffer */

	dest = get_screen_ptr((start - gvi_pc_low_regen)<<1) + (height-1) * bpl * 2;
	src = dest - lines * bpl * 2;

	for(i=0;i<height-lines;i++)
	{
		j = width >> 2;
		d_ptr = (word *) dest;
		s_ptr = (word *) src;

		while( j-- > 0 )
		{
			*d_ptr = *s_ptr;
			d_ptr += 2;
			s_ptr += 2;
		}

		dest -= bpl * 2;
		src -= bpl * 2;
	}

	/* Fill exposed area of buffer */

#ifdef BIGEND
	data = (' ' << 8) | attr;
#else
	data = (attr << 8) | ' ';
#endif

	for(i=0;i<lines;i++)
	{
		j = width >> 2;
		d_ptr = (word *) dest;

		while( j-- > 0 )
		{
			*d_ptr = data;
			d_ptr += 2;
		}

		dest -= bpl * 2;
	}

	host_scroll_complete();

#endif  //NEC_98
	return TRUE;
}

/*---------------------  CGA Scrolling routines --------------------------*/

/*ARGSUSED5*/
boolean cga_text_scroll_up IFN6(int, start, int, width, int, height,
	int, attr, int, lines,int,dummy_arg)
{
#ifndef NEC_98
    short blank_word, *ptr, *top_left_ptr,*top_right_ptr, *bottom_right_ptr;
    unsigned short dummy;
    unsigned char *p;
    int words_per_line;
	int i,tlx,tly,colour;
	int bpl = 2*get_chars_per_line();
	long start_offset;
	register half_word *src,*dest;
	boolean result;

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
	if ( getVM() )
	   return FALSE;   /* Don't optimise in V86 Mode */
#endif

	UNUSED(dummy_arg);
	
	if (video_adapter == MDA)
	{	
		/*
		 * The colour we fill with for MDA is either black or low intensity white,
		 * depending on whether the attribute byte specifies reverse video.
		 */
		colour = ((attr & 0x77) == 0x70)? 1 : 0;
	}
	else
	{
		/*
		 * The colour we fill with for colour text displays is controlled by
		 * bits 4-6 of attr, with bit 7 turning on blinking (which we don't support)
		 */
		colour = (attr & bg_col_mask) >>4;
	}
/*
 * Reduce the width of the rectangle if any right hand area is completely
 * blank.
 *
 * Don't reduce the size of the scrolling region for a dumb terminal.
 * Dumb terminal uses line feeds to scroll up, but only if the whole
 * screen is to be scrolled.  Reducing the scroll region causes
 * the whole region to be redrawn.
 */

#ifdef DUMB_TERMINAL
        if (terminal_type != TERMINAL_TYPE_DUMB)
        {
#endif /* DUMB_TERMINAL */

		/* originally dummy was char [2] */
		/* unfortunately doing (short) *dummy */
		/* causes a bus error on M88K */
		p = (unsigned char *) &dummy;
		p [0] = ' ';
		p [1] = (unsigned char)attr;
	    blank_word = dummy;

	    words_per_line   = get_chars_per_line();
	    top_left_ptr     = (short *) get_screen_ptr(start - gvi_pc_low_regen);
            top_right_ptr    = top_left_ptr + (width >> 1) - 1;
	    bottom_right_ptr = top_right_ptr + words_per_line * (height - 1);
	    ptr = bottom_right_ptr;
	    if (width > 2) /* dont want to get a zero rectangle for safetys sake */
	    {
	        while (*ptr == blank_word)
	        {
	            if (ptr == top_right_ptr) 	/* reached top of column? */
	            {
		        top_right_ptr--;	/* yes go to bottom of next */
		        bottom_right_ptr--;
		        if (top_right_ptr == top_left_ptr)
		            break;
		        ptr = bottom_right_ptr;
	            }
	            else
		        ptr -= words_per_line;
	        }
	    }
	    width = (int)(top_right_ptr - top_left_ptr + 1) << 1;
#ifdef DUMB_TERMINAL
	}
#endif /* DUMB_TERMINAL */

	/* do the host stuff */
	start_offset = start - get_screen_start()*2 - gvi_pc_low_regen;
	tlx = (int)(start_offset%get_bytes_per_line())*get_pix_char_width()/2;
	tly = (int)(start_offset/get_bytes_per_line())*get_host_char_height();
	result = host_scroll_up(tlx,tly,tlx+width/2*get_pix_char_width()-1,
				tly+height*get_host_char_height()-1, lines*get_host_char_height(),colour);

	if(!result)
		return FALSE;

	/* Adjust cursor */

	if(( dirty_curs_offs != -1 ) && ( dirty_curs_x < ( width >> 1 )))
	{
		dirty_curs_y -= lines;
		dirty_curs_offs -= lines * bpl;
		setVideodirty_total(getVideodirty_total() + 1);
	}

	/* Scroll up the video_copy */
	dest = video_copy + start-gvi_pc_low_regen;
	src = dest + lines * bpl;

	if(width == bpl)
	{
		/* Can do the whole thing in one go */
		memcpy(dest,src,width*(height-lines));
		fwd_word_fill( (short)((' '<<8) | attr), dest+width*(height-lines),width*lines/2);
	}
	else
	{
		/* Not scrolling whole width of screen, so do each line seperatly */
		for(i=0;i<height-lines;i++)
		{
			memcpy(dest,src,width);
			dest += bpl;
			src += bpl;
		}

		/* Fill exposed area of video copy */

		for(i=0;i<lines;i++)
		{
			fwd_word_fill( (short)((' '<<8) | attr), dest,width/2);
			dest += bpl;
		}
	}

	/* Update video buffer */

	dest = get_screen_ptr(start - gvi_pc_low_regen);
	src = dest + lines * bpl;
	for(i=0;i<height-lines;i++)
	{
		memcpy(dest,src,width);
		dest += bpl;
		src += bpl;
	}

	/* Fill exposed area of buffer */

	for(i=0;i<lines;i++)
	{
		fwd_word_fill( (short)((' '<<8) | attr), dest,width/2);
		dest += bpl;
	}

	host_scroll_complete();

	return TRUE;
#endif  //NEC_98
}

/*ARGSUSED5*/
boolean cga_text_scroll_down IFN6(int, start, int, width, int, height,
	int, attr, int, lines,int,dummy_arg)
{
#ifndef NEC_98
	int i,tlx,tly,colour;
	int bpl = 2*get_chars_per_line();
	long start_offset;
	register half_word *src,*dest;
	boolean result;

	UNUSED(dummy_arg);
	
#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
	if ( getVM() )
	   return FALSE;   /* Don't optimise in V86 Mode */
#endif

	if(video_adapter == MDA)
	{	
		/*
		 * The colour we fill with for MDA is either black or low intensity white,
		 * depending on whether the attribute byte specifies reverse video.
		 */
		colour = ((attr & 0x77) == 0x70)? 1 : 0;
	}
	else
	{
		/*
		 * The colour we fill with for colour text displays is controlled by
		 * bits 4-6 of attr, with bit 7 turning on blinking (which we don't support)
		 */
		colour = (attr & bg_col_mask) >>4;
	}

	/* do the host stuff */
	start_offset = start - get_screen_start() * 2 - gvi_pc_low_regen;
	tlx = (int)(start_offset%get_bytes_per_line())*get_pix_char_width()/2;
	tly = (int)(start_offset/get_bytes_per_line())*get_host_char_height();
	result = host_scroll_down(tlx,tly,tlx+width/2*get_pix_char_width()-1,
			tly+height*get_host_char_height()-1, lines*get_host_char_height(),colour);

	if(!result)
		return FALSE;

	/* Adjust cursor */

	if(( dirty_curs_offs != -1 ) && ( dirty_curs_x < ( width >> 1 )))
	{
		dirty_curs_y += lines;
		dirty_curs_offs += lines * bpl;
		setVideodirty_total(getVideodirty_total() + 1);
	}

	/* Scroll down the video_copy */

	if(width == bpl)
	{
		/* Can do the whole thing in one go */
		src = video_copy + start - gvi_pc_low_regen;
		dest = src + lines * bpl;
		memcpy(dest,src,width*(height-lines));
		fwd_word_fill( (short)((' '<<8) | attr), src,width*lines/2);
	}
	else
	{
		/* Not scrolling whole width of screen, so do each line seperatly */
		dest = video_copy + start-gvi_pc_low_regen + (height-1) * bpl;
		src = dest - lines * bpl;
		for(i=0;i<height-lines;i++)
		{
			memcpy(dest,src,width);
			dest -= bpl;
			src -= bpl;
		}

		/* Fill exposed area of video copy */

		for(i=0;i<lines;i++)
		{
			fwd_word_fill( (short)((' '<<8) | attr), dest,width/2);
			dest -= bpl;
		}
	}

	/* Update video buffer */

	dest = get_screen_ptr(start - gvi_pc_low_regen) + (height-1) * bpl;
	src = dest - lines * bpl;
	for(i=0;i<height-lines;i++)
	{
		memcpy(dest,src,width);
		dest -= bpl;
		src -= bpl;
	}

	/* Fill exposed area of buffer */

	for(i=0;i<lines;i++)
	{
		fwd_word_fill( (short)((' '<<8) | attr), dest,width/2);
		dest -= bpl;
	}

	host_scroll_complete();

#endif  //NEC_98
	return TRUE;
}

boolean cga_graph_scroll_up IFN6(int, start, int, width, int, height,
	int, attr, int, lines, int, colour)
{
#ifndef NEC_98
	int i,tlx,tly;
	long start_offset;
	half_word *src,*dest;
	boolean result;

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
	if ( getVM() )
	   return FALSE;   /* Don't optimise in V86 Mode */
#endif

	/* Do the host stuff */

	start_offset = start - gvi_pc_low_regen;
	tlx = (int)(start_offset%SCAN_LINE_LENGTH)*8;
	tly = (int)(start_offset/SCAN_LINE_LENGTH)*4;

	result = host_scroll_up(tlx,tly,tlx+width*8-1,tly+height*4-1,lines*4,colour);

	if(!result)return FALSE;

	/* scroll up the video_copy */
	dest = video_copy + start_offset;
	src = dest + lines*SCAN_LINE_LENGTH;

	if(width == SCAN_LINE_LENGTH)
	{
		/* Can do the whole thing in one go */
		memcpy(dest,src,width*(height-lines));
		memset( dest+width*(height-lines),attr,width*lines);
		memcpy(dest+(ODD_OFFSET),src+(ODD_OFFSET),width*(height-lines));
		memset( dest+width*(height-lines)+(ODD_OFFSET),attr,width*lines);
	}
	else
	{
		/* Not scrolling whole width of screen, so do each line seperatly */
		for(i=0;i<height-lines;i++)
		{
			memcpy(dest,src,width);
			memcpy(dest+(ODD_OFFSET),src+(ODD_OFFSET),width);
			dest += SCAN_LINE_LENGTH;
			src += SCAN_LINE_LENGTH;
		}

		/* clear the video_copy */
		for(i=0;i<lines;i++)
		{
			memset( dest,attr,width);
			memset( dest+(ODD_OFFSET),attr,width);
			dest += SCAN_LINE_LENGTH;
		}
	}
#ifdef EGG
	if(video_adapter == EGA || video_adapter == VGA)
	{
		int bpl = SCAN_LINE_LENGTH;
		int oof = ODD_OFFSET;

		if( sas_hw_at_no_check(vd_video_mode) == 6 )
		{
			/* Hi-res mode stored in interleaved format in 3.0 */

			start_offset <<= 2;
			bpl <<= 2;
			width <<= 2;
			oof <<= 2;
		}
		else
		{
			start_offset <<= 1;
			bpl <<= 1;
			width <<= 1;
			oof <<= 1;
		}

		dest = EGA_plane01 + start_offset;
		src = dest + lines*bpl;
		for(i=0;i<height-lines;i++)
		{
			memcpy(dest,src,width);
			memcpy(dest+oof,src+oof,width);
			dest += bpl;
			src += bpl;
		}

		/* clear the EGA plane */
		for(i=0;i<lines;i++)
		{
			memset( dest,attr,width);
			memset( dest+oof,attr,width);
			dest += bpl;
		}
	}
#endif /* EGG */

	host_scroll_complete();

#endif  //NEC_98
	return TRUE;
}

boolean cga_graph_scroll_down IFN6(int, start, int, width, int, height,
	int, attr, int, lines, int, colour)
{
#ifndef NEC_98
	int i,tlx,tly;
	long start_offset;
	register half_word *src,*dest;
	boolean result;

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
	if ( getVM() )
	   return FALSE;   /* Don't optimise in V86 Mode */
#endif

	/* Do the host stuff */

	start_offset = start - gvi_pc_low_regen;
	tlx = (int)(start_offset%SCAN_LINE_LENGTH)*8;
	tly = (int)(start_offset/SCAN_LINE_LENGTH)*4;

	result = host_scroll_down(tlx,tly,tlx+width*8-1,tly+height*4-1, lines*4,colour);

	if(!result)return FALSE;

	/* Scroll down the video_copy */

	if(width == SCAN_LINE_LENGTH)
	{
		/* Can do the whole thing in one go */
		src = video_copy + start - gvi_pc_low_regen;
		dest = src + lines*SCAN_LINE_LENGTH;
		memcpy(dest,src,width*(height-lines));
		memset(src,attr,width*lines);
		memcpy(dest+ODD_OFFSET,src+ODD_OFFSET,width*(height-lines));
		memset(src+ODD_OFFSET,attr,width*lines);
	}
	else
	{
		/* Not scrolling whole width of screen, so do each line seperatly */
		dest = video_copy + start - gvi_pc_low_regen + (height-1)*SCAN_LINE_LENGTH;
		src = dest - lines*SCAN_LINE_LENGTH;
		for(i=0;i<height-lines;i++)
		{
			memcpy(dest,src,width);
			memcpy(dest+ODD_OFFSET,src+ODD_OFFSET,width);
			dest -= SCAN_LINE_LENGTH;
			src -= SCAN_LINE_LENGTH;
		}

		/* clear the video_copy */
		for(i=0;i<lines;i++)
		{
			memset(dest,attr,width);
			memset(dest+ODD_OFFSET,attr,width);
			dest -= SCAN_LINE_LENGTH;
		}
	}
#ifdef EGG
	if(video_adapter == EGA || video_adapter == VGA)
	{
		register int bpl = SCAN_LINE_LENGTH;
		register int oof = ODD_OFFSET;

		if( sas_hw_at_no_check(vd_video_mode) == 6 )
		{
			/* Hi-res mode stored in interleaved format in 3.0 */

			start_offset <<= 2;
			bpl <<= 2;
			width <<= 2;
			oof <<= 2;
		}
		else
		{
			start_offset <<= 1;
			bpl <<= 1;
			width <<= 1;
			oof <<= 1;
		}

		dest = EGA_plane01 + start - gvi_pc_low_regen + (height-1)*bpl;
		src = dest - lines*bpl;
		for(i=0;i<height-lines;i++)
		{
			memcpy(dest,src,width);
			memcpy(dest+oof,src+oof,width);
			dest -= bpl;
			src -= bpl;
		}

		/* clear the EGA plane */
		for(i=0;i<lines;i++)
		{
			memset(dest,attr,width);
			memset(dest+oof,attr,width);
			dest -= bpl;
		}
	}
#endif /* EGG */

	host_scroll_complete();

#endif  //NEC_98
	return TRUE;
}

#ifdef VGG
/*ARGSUSED5*/
boolean vga_graph_scroll_up IFN6(int, start, int, width, int, height,
	int, attr, int, lines,int,dummy)
{
	int start_offset,tlx,tly;
	boolean status;
#if defined(NEC_98)
        status = TRUE;
#else   //NEC_98

	UNUSED(dummy);
	
#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
	if ( getVM() )
	   return FALSE;   /* Don't optimise in V86 Mode */
#endif

	(*update_alg.calc_update)();
	/* do the host stuff */
	start_offset = start - get_screen_start();
	tlx = (start_offset%get_offset_per_line())*2;
	tly = (start_offset/get_offset_per_line())*2;
	status = host_scroll_up(tlx,tly,tlx+width*2-1,tly+height*2-1,lines*2,attr);

	host_scroll_complete();

#endif  //NEC_98
	return(status);

}

/*ARGSUSED5*/
boolean vga_graph_scroll_down IFN6(int, start, int, width, int, height,
	int, attr, int, lines,int,dummy_arg)
{
	int start_offset,tlx,tly;
	boolean status;
#if defined(NEC_98)
        status = TRUE;
#else   //NEC_98

	UNUSED(dummy_arg);
	
#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
	if ( getVM() )
	   return FALSE;   /* Don't optimise in V86 Mode */
#endif

	(*update_alg.calc_update)();
	/* do the host stuff */
	start_offset = start - get_screen_start();
	tlx = (start_offset%get_offset_per_line())*2;
	tly = (start_offset/get_offset_per_line())*2;
	status =  host_scroll_down(tlx,tly,tlx+width*2-1,tly+height*2-1,lines*2,attr);

	host_scroll_complete();

#endif  //NEC_98
	return(status);

}

#ifdef V7VGA
/*ARGSUSED5*/
boolean v7vga_graph_scroll_up IFN6(int, start, int, width, int, height,
	int, attr, int, lines,int,dummy)
{
	int start_offset,tlx,tly;
	boolean status;
#ifndef NEC_98

	UNUSED(dummy);
	
#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
	if ( getVM() )
	   return FALSE;   /* Don't optimise in V86 Mode */
#endif

	(*update_alg.calc_update)();
	/* do the host stuff */
	start_offset = start - get_screen_start();
	tlx = (start_offset%get_offset_per_line());
	tly = (start_offset/get_offset_per_line());
	status = host_scroll_up(tlx,tly,tlx+width-1,tly+height-1,lines,attr);

	host_scroll_complete();

#endif  //NEC_98
	return(status);
}

/*ARGSUSED5*/
boolean v7vga_graph_scroll_down IFN6(int, start, int, width, int, height,
	int, attr, int, lines,int, dummy_arg)
{
	int start_offset,tlx,tly;
	boolean status;
#ifndef NEC_98

	UNUSED(dummy_arg);
	
#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
	if ( getVM() )
	   return FALSE;   /* Don't optimise in V86 Mode */
#endif

	(*update_alg.calc_update)();
	/* do the host stuff */
	start_offset = start - get_screen_start();
	tlx = (start_offset%get_offset_per_line());
	tly = (start_offset/get_offset_per_line());
	status = host_scroll_down(tlx,tly,tlx+width-1,tly+height-1,lines,attr);

	host_scroll_complete();

#endif  //NEC_98
	return(status);
}
#endif /* V7VGA */
#endif /* VGG */

#ifdef EGG

#ifdef SEGMENTATION 		/* See note with first use of this flag */
#if		defined(JOKER) && !defined(PROD)
#include "SOFTPC_GRAPHICS.seg"
#undef	SEGMENTATION		/* HeeHee! */
#else
#include "SOFTPC_EGA.seg"
#endif	/* DEV JOKER variants */
#endif

/*ARGSUSED5*/
boolean ega_graph_scroll_up IFN6(int, start, int, width, int, height,
	int, attr, int, lines,int,dummy)
{
	int start_offset,tlx,tly;
	boolean status;
#if defined(NEC_98)
        status = TRUE;
#else   //NEC_98

	UNUSED(dummy);
	
#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
	if ( getVM() )
	   return FALSE;   /* Don't optimise in V86 Mode */
#endif

	(*update_alg.calc_update)();
	/* do the host stuff */
	attr &= 0xf;
	start_offset = start - get_screen_start();
	tlx = (start_offset%get_offset_per_line())*8*get_pix_width();
	tly = (start_offset/get_offset_per_line())*get_pc_pix_height();
	status =  (host_scroll_up(tlx,tly,tlx+width*8*get_pix_width()-1,tly+height*get_pc_pix_height()-1,lines*get_pc_pix_height(),attr));

	host_scroll_complete();

#endif  //NEC_98
	return(status);

}

/*ARGSUSED5*/
boolean ega_graph_scroll_down IFN6(int, start, int, width, int, height,
	int, attr, int, lines,int,dummy_arg)
{
	int start_offset,tlx,tly;
	boolean status;
#if defined(NEC_98)
        status = TRUE;
#else   //NEC_98
	
	UNUSED(dummy_arg);
	
#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
	if ( getVM() )
	   return FALSE;   /* Don't optimise in V86 Mode */
#endif

	(*update_alg.calc_update)();

	/* do the host stuff */
	attr &= 0xf;
	start_offset = start - get_screen_start();
	tlx = (start_offset%get_offset_per_line())*8*get_pix_width();
	tly = (start_offset/get_offset_per_line())*get_pc_pix_height();
	status = (host_scroll_down(tlx,tly,tlx+width*8*get_pix_width()-1,tly+height*get_pc_pix_height()-1,lines*get_pc_pix_height(),attr));

	host_scroll_complete();

#endif  //NEC_98
	return(status);

}
#endif /* EGG */

#ifdef SEGMENTATION 		/* See note with first use of this flag */
#include "SOFTPC_GRAPHICS.seg"
#endif

#endif /* REAL_VGA */

/*ARGSUSED0*/
boolean	dummy_scroll IFN6(int,dummy1,int,dummy2,int,dummy3,int,
				dummy4,int,dummy5,int,dummy6)
{
	UNUSED(dummy1);
	UNUSED(dummy2);
	UNUSED(dummy3);
	UNUSED(dummy4);
	UNUSED(dummy5);
	UNUSED(dummy6);
	
	return FALSE;
}

#ifndef REAL_VGA

/*---------------------  End of scrolling routines --------------------------*/

#ifdef GORE

#ifdef GORE_PIG
GLOBAL UTINY gore_copy[0x80000];	/* Big enough for enormous Super7 VGA modes */
#endif /* GORE_PIG */

LOCAL VOID
gore_mark_byte_nch IFN0()
{
#ifdef GORE_PIG
	gore_copy[(Ead >> 2) + (v7_write_bank << 16)] = gd.gd_b_wrt.mark_type;
#endif /* GORE_PIG */

	(*gu_handler.b_wrt)(( Ead >> 2 ) + ( v7_write_bank << 16 ));
}

LOCAL VOID
gore_mark_word_nch IFN0()
{
#ifdef GORE_PIG
	gore_copy[(Ead >> 2 ) + 1 + (v7_write_bank << 16)] =
			gore_copy[(Ead >> 2) + (v7_write_bank << 16)] = gd.gd_w_wrt.mark_type;
#endif /* GORE_PIG */

	(*gu_handler.w_wrt)(( Ead >> 2 ) + ( v7_write_bank << 16 ));
}

LOCAL VOID
gore_mark_string_nch IFN0()
{
	ULONG temp =  ( Ead >> 2 ) + ( v7_write_bank << 16 );

#ifdef GORE_PIG
	memfill( gd.gd_b_str.mark_type, &gore_copy[temp], &gore_copy[temp+V3-1] );
#endif /* GORE_PIG */

	(*gu_handler.b_str)( temp, temp + V3 - 1, V3 );
}

LOCAL VOID
gore_mark_byte_ch4 IFN0()
{
	ULONG temp =  Ead + ( v7_write_bank << 16 );

#ifdef GORE_PIG
	if( temp < gd.dirty_low )
		gd.dirty_low = temp;

	if( temp > gd.dirty_high )
		gd.dirty_high = temp;

	gore_copy[temp] = gd.gd_b_wrt.mark_type;
#endif /* GORE_PIG */

	(*gu_handler.b_wrt)( temp );
}

LOCAL VOID
gore_mark_word_ch4 IFN0()
{
	ULONG temp =  Ead + ( v7_write_bank << 16 );

#ifdef GORE_PIG
	if( temp < gd.dirty_low )
		gd.dirty_low = temp;

	if(( temp + 1 ) > gd.dirty_high )
		gd.dirty_high = temp + 1;

	gore_copy[temp + 1] = gore_copy[temp] = gd.gd_w_wrt.mark_type;
#endif /* GORE_PIG */

	(*gu_handler.w_wrt)( Ead + ( v7_write_bank << 16 ));
}

LOCAL VOID
gore_mark_string_ch4 IFN0()
{
	ULONG temp =  Ead + ( v7_write_bank << 16 );
	ULONG temp2 =  temp + V3 - 1;

#ifdef GORE_PIG
	if( temp < gd.dirty_low )
		gd.dirty_low = temp;

	if( temp2 > gd.dirty_high )
		gd.dirty_high = temp2;

	memfill( gd.gd_b_str.mark_type, &gore_copy[temp], &gore_copy[temp2] );
#endif /* GORE_PIG */

	(*gu_handler.b_str)( temp, temp2, V3 );
}
#endif /* GORE */

#ifdef	EGG
/*
 * Given an offset into CGA memory return the offset
 * within an 8K bank of video memory.
 */
#define BANK_OFFSET(off) (off & 0xDFFF)

GLOBAL VOID cga_mark_byte IFN1(int, addr)
{
#ifndef NEC_98
	register	int	offset = BANK_OFFSET(addr);
	
	if(offset < getVideodirty_low())
		setVideodirty_low(offset);

	if(offset > getVideodirty_high())
		setVideodirty_high(offset);

	setVideodirty_total(getVideodirty_total() + 1);
#endif  //NEC_98
}

GLOBAL VOID cga_mark_word IFN1(int, addr)
{
#ifndef NEC_98
	register	int	offset1 = BANK_OFFSET(addr);
	register	int	offset2 = offset1 + 1;

	if(offset1 < getVideodirty_low())
		setVideodirty_low(offset1);

	if(offset2 > getVideodirty_high())
		setVideodirty_high(offset2);

	setVideodirty_total(getVideodirty_total() + 2);
#endif  //NEC_98
}

GLOBAL VOID cga_mark_string IFN2(int, laddr, int, haddr)
{
#ifndef NEC_98
	register	int	offset1 = BANK_OFFSET(laddr);
	register	int	offset2 = BANK_OFFSET(haddr);

	if(offset1 < getVideodirty_low())
		setVideodirty_low(offset1);

	if(offset2 > getVideodirty_high())
		setVideodirty_high(offset2);

	setVideodirty_total(getVideodirty_total() + offset2-offset1+1);
#endif  //NEC_98
}

#ifdef SEGMENTATION 		/* See note with first use of this flag */
#include "SOFTPC_EGA.seg"
#endif

GLOBAL VOID ega_mark_byte IFN1(int, off_in)
{
#ifndef NEC_98
#ifdef GORE
	(*gu_handler.b_wrt)( off_in );
#else
	register int offset = off_in>>2;

	video_copy[offset] = 1;

	if(offset < getVideodirty_low())
		setVideodirty_low(offset);

	if(offset > getVideodirty_high())
		setVideodirty_high(offset);

	setVideodirty_total(getVideodirty_total() + 1);
#endif /* GORE */
#endif  //NEC_98
}

GLOBAL VOID ega_mark_word IFN1(int, addr)
{
#ifndef NEC_98
#ifdef GORE
	(*gu_handler.w_wrt)( addr );
#else

	register	int	offset1 = addr >> 2;
	register	int	offset2 = (addr+1) >> 2;

	video_copy[offset1] = 1;
	video_copy[offset2] = 1;

	if(offset1 < getVideodirty_low())
		setVideodirty_low(offset1);

	if(offset2 > getVideodirty_high())
		setVideodirty_high(offset2);

	setVideodirty_total(getVideodirty_total() + 2);
#endif /* GORE */
#endif  //NEC_98
}

GLOBAL VOID ega_mark_wfill IFN3(int, laddr, int, haddr, int, col)
{
#ifndef NEC_98
#ifdef GORE
	(*gu_handler.w_fill)( laddr, haddr, haddr - laddr + 1, col );
#else

	register	int	offset1 = laddr >> 2;
	register	int	offset2 = haddr >> 2;

	UNUSED(col);
	
	memfill(1,&video_copy[offset1],&video_copy[offset2]);

	if(offset1 < getVideodirty_low())
		setVideodirty_low(offset1);

	if(offset2 > getVideodirty_high())
		setVideodirty_high(offset2);

	setVideodirty_total(getVideodirty_total() + offset2-offset1+1);
#endif /* GORE */
#endif  //NEC_98
}

GLOBAL VOID ega_mark_string IFN2(int, laddr, int, haddr)
{
#ifndef NEC_98
#ifdef GORE
	(*gu_handler.b_str)( laddr, haddr, haddr - laddr + 1 );
#else
	register	int	offset1 = laddr >> 2;
	register	int	offset2 = haddr >> 2;

	memfill(1,&video_copy[offset1],&video_copy[offset2]);

	if(offset1 < getVideodirty_low())
		setVideodirty_low(offset1);

	if(offset2 > getVideodirty_high())
		setVideodirty_high(offset2);

	setVideodirty_total(getVideodirty_total() + offset2-offset1+1);
#endif /* GORE */
#endif  //NEC_98
}

#endif /* EGG */

#ifdef SEGMENTATION 		/* See note with first use of this flag */
#include "SOFTPC_GRAPHICS.seg"
#endif

GLOBAL VOID screen_refresh_required IFN0()
{

#ifdef GORE
	(*gu_handler.b_str)( 0, get_screen_length(), get_screen_length() );
#endif /* GORE */

#if defined(NEC_98)
        if (NEC98GLOBS)
                NEC98GLOBS->dirty_flag = 1000000L;
#else   //NEC_98
#ifndef CPU_40_STYLE
	/*
         * This is to stop the VGA globals pointer being
         * dereferenced before it is set up in main.c.
         */

        if (VGLOBS)
                VGLOBS->dirty_flag = 1000000L;
#else
	setVideodirty_total(1000000L);
#endif	/* CPU_40_STYLE */
#endif  //      NEC_98
}

#ifdef EGG

#ifdef SEGMENTATION 		/* See note with first use of this flag */
#include "SOFTPC_EGA.seg"
#endif

LOCAL MARKING_TYPE curr_mark_type;

#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )	/* remove uneeded code */

GLOBAL VOID
set_mark_funcs IFN0()
{
	switch (curr_mark_type)
	{
		case	SIMPLE_MARKING:
			update_alg.mark_byte = (T_mark_byte)simple_update;
			update_alg.mark_word = (T_mark_word)simple_update;
			update_alg.mark_fill = (T_mark_fill)simple_update;
			update_alg.mark_wfill = (T_mark_wfill)simple_update;
			update_alg.mark_string = (T_mark_string)simple_update;

#ifndef NEC_98
#ifndef CPU_40_STYLE	/* EVID */
			setVideomark_byte(FAST_FUNC_ADDR(_simple_mark_sml));
			setVideomark_word(FAST_FUNC_ADDR(_simple_mark_sml));

			SET_VGLOBS_MARK_STRING(_simple_mark_lge);
#else	/* CPU_40_STYLE - EVID */
			SetMarkPointers(0);
#endif	/* CPU_40_STYLE - EVID */
#endif  //NEC_98
			break;

#ifndef NEC_98
		case	CGA_GRAPHICS_MARKING:
			update_alg.mark_byte = (T_mark_byte)cga_mark_byte;
			update_alg.mark_word = (T_mark_word)cga_mark_word;
			update_alg.mark_fill = (T_mark_fill)cga_mark_string;
			update_alg.mark_wfill = (T_mark_wfill)cga_mark_string;
			update_alg.mark_string = (T_mark_string)cga_mark_string;

#ifndef CPU_40_STYLE	/* EVID */
			setVideomark_byte(FAST_FUNC_ADDR(_cga_mark_byte));
			setVideomark_word(FAST_FUNC_ADDR(_cga_mark_word));

			SET_VGLOBS_MARK_STRING(_cga_mark_string);
#else	/* CPU_40_STYLE - EVID */
			SetMarkPointers(1);
#endif	/* CPU_40_STYLE - EVID */

			break;

		case	EGA_GRAPHICS_MARKING:
#ifdef GORE
			reset_gore_ptrs();
			gd.curr_line_diff = get_bytes_per_line();
			gd.max_vis_addr = get_screen_length() - 1 + ( v7_write_bank << 16 );
#ifdef	VGG
			gd.shift_count = get_256_colour_mode() ? 0 : 3;
#else
			gd.shift_count = 3;
#endif	/* VGG */
#endif /* GORE */

			update_alg.mark_byte = (T_mark_byte)ega_mark_byte;
			update_alg.mark_word = (T_mark_word)ega_mark_word;
			update_alg.mark_fill = (T_mark_fill)ega_mark_string;
			update_alg.mark_wfill = (T_mark_wfill)ega_mark_wfill;
			update_alg.mark_string = (T_mark_string)ega_mark_string;

			switch( EGA_CPU.chain )
			{
				case UNCHAINED:
#ifdef GORE
					setVideomark_byte(gore_mark_byte_nch);
					setVideomark_word(gore_mark_word_nch);

					SET_VGLOBS_MARK_STRING(gore_mark_string_nch);
#else
#ifndef CPU_40_STYLE	/* EVID */
					setVideomark_byte(FAST_FUNC_ADDR(_mark_byte_nch));
					setVideomark_word(FAST_FUNC_ADDR(_mark_word_nch));

					SET_VGLOBS_MARK_STRING(_mark_string_nch);
#else	/* CPU_40_STYLE - EVID */
					SetMarkPointers(2);
#endif	/* CPU_40_STYLE - EVID */
#endif /* GORE */
					break;

				case CHAIN2:
					assert0( NO, "CHAIN2 in graphics mode !!" );

					break;

#ifdef	VGG
				case CHAIN4:
#ifdef GORE
					setVideomark_byte(gore_mark_byte_ch4);
					setVideomark_word(gore_mark_word_ch4);

					SET_VGLOBS_MARK_STRING(gore_mark_string_ch4);
#else
#ifndef CPU_40_STYLE	/* EVID */
					setVideomark_byte(FAST_FUNC_ADDR(_mark_byte_ch4));
					setVideomark_word(FAST_FUNC_ADDR(_mark_word_ch4));

					SET_VGLOBS_MARK_STRING(_mark_string_ch4);
#else	/* CPU_40_STYLE - EVID */
					SetMarkPointers(3);
#endif	/* CPU_40_STYLE - EVID */
#endif /* GORE */
					break;
#endif	/* VGG */
			}

			break;

		default:
			assert1(NO,"Unknown marking type %d", (int) curr_mark_type);
			break;
#endif  //NEC_98
	}
}
#endif	/* !NTVDM | (NTVDM & !X86GFX) */

#ifdef SEGMENTATION 		/* See note with first use of this flag */
#include "SOFTPC_GRAPHICS.seg"
#endif

GLOBAL void set_gfx_update_routines IFN3(T_calc_update, update_routine,
		MARKING_TYPE, marking_type, SCROLL_TYPE, scroll_type)
{
	enable_gfx_update_routines();
	update_alg.calc_update = update_routine;
	switch (scroll_type) {
		case	NO_SCROLL:
			update_alg.scroll_up = dummy_scroll;
			update_alg.scroll_down = dummy_scroll;
			break;
#ifndef NEC_98
		case	TEXT_SCROLL:
#if defined(NTVDM) && defined(MONITOR)
			update_alg.scroll_up = (T_scroll_up)mon_text_scroll_up;
			update_alg.scroll_down = (T_scroll_down)mon_text_scroll_down;
#else
			update_alg.scroll_up = text_scroll_up;
			update_alg.scroll_down = text_scroll_down;
#endif	/* NTVDM & MONITOR */
			break;
#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )	/* remove unneeded code */
		case	CGA_GRAPH_SCROLL:
			update_alg.scroll_up = cga_graph_scroll_up;
			update_alg.scroll_down = cga_graph_scroll_down;
			break;
		case	EGA_GRAPH_SCROLL:
			update_alg.scroll_up = ega_graph_scroll_up;
			update_alg.scroll_down = ega_graph_scroll_down;
			break;
#ifdef VGG
		case	VGA_GRAPH_SCROLL:
			update_alg.scroll_up = vga_graph_scroll_up;
			update_alg.scroll_down = vga_graph_scroll_down;
			break;
#ifdef V7VGA
		case	V7VGA_GRAPH_SCROLL:
			update_alg.scroll_up = v7vga_graph_scroll_up;
			update_alg.scroll_down = v7vga_graph_scroll_down;
			break;
#endif /* V7VGA */
#endif /* VGG */
#endif /* !NTVDM | (NTVDM & !X86GFX) */
#endif  //NEC_98
	}

	curr_mark_type = marking_type;

	set_mark_funcs();

	/*
	 * The newly setup update routines will not be needed yet if the
	 * display is disabled, but must be saved in any case so that
	 * redundant enables (as in dosshell) restore the correct ones.
 	 * If the display is disabled we must also then install the dummy
	 * update routines as the current ones.
	 *
	 * AJO 23/4/93
	 * DON'T use disable_gfx_update_routines() here cos' it's a NOP
	 * if the display is already disabled which causes bizarre problems
	 * if a mode change is performed while disabled.
	 */
	save_gfx_update_routines();
	if (get_display_disabled())
		inhibit_gfx_update_routines();
}
#endif /* EGG */

#endif /* REAL_VGA */

#ifndef cursor_changed
void cursor_changed IFN2(int, x, int, y)
{
#ifndef REAL_VGA
	UNUSED(x);
	UNUSED(y);
	
#ifndef NEC_98
	setVideodirty_total(getVideodirty_total() + 1);
#endif  //NEC_98
#else
    IU32 offset;

    offset = (y * 2 * get_chars_per_line()) + (x << 1);
    offset += get_screen_start()<<1;	/* Because screen start is in WORDS */
    vga_card_place_cursor((word)offset);
#endif
}
#endif

void host_cga_cursor_has_moved IFN2(int, x, int, y)
{
	cursor_changed(x,y);
}

/* Called when the start & end of the cursor are changed. */

void base_cursor_shape_changed IFN0()
{
	cursor_changed(get_cur_x(),get_cur_y());
}

#ifndef REAL_VGA
#ifdef HERC

#define DIRTY ((unsigned char)-1)

void     herc_update_screen IFN0()
{
    register int    i, j, k, offs, y;
    register USHORT *from, *to;
    int        lines_per_screen = get_screen_length() / get_bytes_per_line();	
    /* lines of text on screen */
    half_word       begin[349], end[348];

    if(( getVideodirty_total() == 0 ) || get_display_disabled())
		return;

    host_start_update();

    if (get_cga_mode() == TEXT)
    {
	/*
	 * arbitrary limit over which we just repaint the whole screen in one operation, assuming
	 * this is more efficient than working out large minimum rectangles. This value should be
	 * tuned at some future point.
	 */
	to = (USHORT *) &video_copy[get_screen_start()];
	from = (USHORT *) get_screen_ptr((get_screen_start() << 1));

	if (getVideodirty_total() > 1500)
	{
	    for (i = get_screen_length() >> 1; i > 0; i--)
		*to++ = *from++;

		offs = 0;
		y = 0;

		for( i = 0; i < lines_per_screen; i++ )
		{
		    (*paint_screen) (offs, 0, y, get_bytes_per_line() );
			offs += get_bytes_per_line();
			y += get_host_char_height();
		}
	}
	else
	{
	    /*
	     * step through row/cols looking for a dirty bit then look for the last clear dirty bit,
	     * and draw the line of text
	     */
	    register int    ints_per_line = get_bytes_per_line() >> 1;

	    for (i = 0, offs = 0; i < lines_per_screen; i++, offs += get_bytes_per_line())
	    {
		for (j = 0; j < ints_per_line; j++)
		{
		    if (*to++ != *from++)
		    {
			to--;
			from--;
			for (k = ints_per_line - 1 - j; *(to + k) == *(from + k); k--)
			    ;

			(*paint_screen) (offs + (j << 1), j * get_pix_char_width(),
							i * get_host_char_height() , (k << 1) + 2 );

			for (k = j; k < ints_per_line; k++)
			    *to++ = *from++;
			break;			 /* onto next line */
		    }
		}
	    }
	}					 /* end else getVideodirty_total() > 1500  */

	remove_old_cursor();

	if (is_cursor_visible())
	{
		half_word attr;

		dirty_curs_x = get_cur_x();
		dirty_curs_y = get_cur_y();

		dirty_curs_offs = dirty_curs_y * get_bytes_per_line() + (dirty_curs_x << 1);
		attr = *(get_screen_ptr(dirty_curs_offs + 1));

		host_paint_cursor( dirty_curs_x, dirty_curs_y, attr );
	}
    }
    else					 /* GRAPHICS  MODE */
    {

	to = (USHORT *) &video_copy[0];
	from = (USHORT *) get_screen_ptr(get_screen_start());

	/*
	 * arbitrary limit over which we just repaint the whole screen in one operation, assuming
	 * this is more efficient than working out large minimum rectangles. This value should be
	 * tuned at some future point.
	 */

	if (getVideodirty_total() > 8000)
	{
	    for (i = 16384; i > 0; i--)
		*to++ = *from++;
	    (*paint_screen) (0, 0, 90, 348);
	}
	else
	{
	    for (i = 0; i < 348; i += 4)	 /* bank 0 */
	    {
		begin[i] = DIRTY;
		for (j = 0; j < 45; j++)
		{
		    if (*to++ != *from++)
		    {
			to--;
			from--;
			for (k = 44 - j; *(to + k) == *(from + k); k--)
			    ;
			begin[i] = j;
			end[i] = j + k;
			for (k = j; k < 45; k++)
			    *to++ = *from++;
			break;			 /* onto next scan line */
		    }
		}
	    }

	    to += 181;
	    from += 181;			 /* skip over the gap */

	    for (i = 1; i < 349; i += 4)	 /* bank 1 */
	    {
		begin[i] = DIRTY;
		for (j = 0; j < 45; j++)
		{
		    if (*to++ != *from++)
		    {
			to--;
			from--;
			for (k = 44 - j; *(to + k) == *(from + k); k--)
			    ;
			begin[i] = j;
			end[i] = j + k;
			for (k = j; k < 45; k++)
			    *to++ = *from++;
			break;			 /* onto next scan line */
		    }
		}
	    }

	    to += 181;
	    from += 181;			 /* skip over the gap */

	    for (i = 2; i < 348; i += 4)	 /* bank 2 */
	    {
		begin[i] = DIRTY;
		for (j = 0; j < 45; j++)
		{
		    if (*to++ != *from++)
		    {
			to--;
			from--;
			for (k = 44 - j; *(to + k) == *(from + k); k--)
			    ;
			begin[i] = j;
			end[i] = j + k;
			for (k = j; k < 45; k++)
			    *to++ = *from++;
			break;			 /* onto next scan line */
		    }
		}
	    }

	    to += 181;
	    from += 181;			 /* skip over the gap */

	    for (i = 3; i < 349; i += 4)	 /* bank 3 */
	    {
		begin[i] = DIRTY;
		for (j = 0; j < 45; j++)
		{
		    if (*to++ != *from++)
		    {
			to--;
			from--;
			for (k = 44 - j; *(to + k) == *(from + k); k--)
			    ;
			begin[i] = j;
			end[i] = j + k;
			for (k = j; k < 45; k++)
			    *to++ = *from++;
			break;			 /* onto next scan line */
		    }
		}
	    }

	    begin[348] = DIRTY;			 /* end marker */
	    for (i = 0; i < 348; i++)
	    {
		register int    beginx, endx, beginy;
		if (begin[i] != DIRTY)		 /* a dirty scan line */
		{
		    beginy = i;
		    beginx = begin[i];
		    endx = end[i];
		    while (begin[++i] != DIRTY)
		    {
			if (begin[i] < beginx)
			    beginx = begin[i];
			if (end[i] > endx)
			    endx = end[i];
		    }
		    (*paint_screen) (beginy, 2 * beginx, 2 * (endx - beginx + 1), i - beginy);
		}
	    }
	}					 /* end else (getVideodirty_total() > 8000) */
    }

    setVideodirty_total(0);

    host_end_update();
}
#endif

#if defined(VGG) || defined(EGG)

#ifdef SEGMENTATION 		/* See note with first use of this flag */
#include "SOFTPC_EGA.seg"
#endif

/* ============================================================================
 * The following routines enable and disable the GFX update routines
 * by saving/restoring the current routines and replacing them with
 * dummy routines that do nothing while update is disabled.
 *
 * AJO 23/4/93
 * Any sequence of enable/disable/mode change should now work as expected.
 * ============================================================================
 */

LOCAL UPDATE_ALG save_update_alg;
LOCAL IBOOL gfx_update_routines_inhibited = FALSE;

LOCAL VOID save_gfx_update_routines IFN0()
{
    /*
     * Save all current update functions so we can restore them later
     */
    save_update_alg.mark_byte 	= update_alg.mark_byte;
    save_update_alg.mark_word 	= update_alg.mark_word;
    save_update_alg.mark_fill 	= update_alg.mark_fill;
    save_update_alg.mark_wfill 	= update_alg.mark_wfill;
    save_update_alg.mark_string = update_alg.mark_string;
    save_update_alg.calc_update = update_alg.calc_update;
    save_update_alg.scroll_up 	= update_alg.scroll_up;
    save_update_alg.scroll_down = update_alg.scroll_down;
}

LOCAL VOID inhibit_gfx_update_routines IFN0()
{
    /*
     * Set all current update routines to dummy ones that do nothing.
     */
    gfx_update_routines_inhibited = TRUE;

    update_alg.mark_byte 	= (T_mark_byte)simple_update;
    update_alg.mark_word	= (T_mark_word)simple_update;
    update_alg.mark_fill 	= (T_mark_fill)simple_update;
    update_alg.mark_wfill 	= (T_mark_wfill)simple_update;
    update_alg.mark_string 	= (T_mark_string)simple_update;
    update_alg.calc_update 	= dummy_calc;
    update_alg.scroll_up 	= dummy_scroll;
    update_alg.scroll_down 	= dummy_scroll;
}

GLOBAL void disable_gfx_update_routines IFN0()
{
    /*
     * Disable GFX update routines; do nothing if update already disabled,
     * otherwise save the current routines and install dummy ones in their
     * place.
     */
    note_entrance0("disable gfx update routines");

    if (gfx_update_routines_inhibited)
	return;

    save_gfx_update_routines();
    inhibit_gfx_update_routines();
}

GLOBAL void enable_gfx_update_routines IFN0()
{
    /*
     * Reenable GFX update routines; copy the saved routines back to be
     * the current ones.
     */
    note_entrance0("enable gfx update routines");

    gfx_update_routines_inhibited = FALSE;

    update_alg.mark_byte 	= save_update_alg.mark_byte;
    update_alg.mark_word 	= save_update_alg.mark_word;
    update_alg.mark_fill 	= save_update_alg.mark_fill;
    update_alg.mark_wfill 	= save_update_alg.mark_wfill;
    update_alg.mark_string 	= save_update_alg.mark_string;
    update_alg.calc_update 	= save_update_alg.calc_update;
    update_alg.scroll_up 	= save_update_alg.scroll_up;
    update_alg.scroll_down 	= save_update_alg.scroll_down;
}

#endif /* VGG */
#ifdef SEGMENTATION 		/* See note with first use of this flag */
#include "SOFTPC_GRAPHICS.seg"
#endif

#ifdef NTVDM

void init_text_rect();
void add_to_rect(int screen_start,register int x, register int y, int len);
void paint_text_rect(int screen_start);

int RectDefined;
int RectTop, RectBottom, RectLeft, RectRight;

#ifdef MONITOR
/*
 * Update the window to look like the regen buffer says it should
 * and with no help from dirty_total.
 */

static int now_cur_x = -1, now_cur_y = -1;
/*
 * Reset the static cursor variables:
 */
GLOBAL void resetNowCur()
{
	now_cur_x = -1;
	now_cur_y = -1;
}

#ifdef JAPAN
void mon_text_update_03( void );

void mon_text_update_03()
{
#ifndef NEC_98

    register int i;	/* Loop counters		*/
    register int j,k;
    register unsigned short *from,*to;
    register int ints_per_line = get_offset_per_line()>>1;
    int lines_per_screen;
    int	len,x,screen_start;
    unsigned short *wfrom;
    unsigned short *wto;
    int dwords_to_compare;

    byte *pInt10Flag;
    static unsigned short save_char; /* save DBCS first byte */
    static unsigned short *save_pos;
    static NtInt10FlagUse = FALSE;

    /*::::::::::::::::::::::::::::::::::::::::::::::: Is the display disable */

    if(get_display_disabled()) return;

    /*::::::::::::::::::::::::::::::::: get screen size and location details */

    screen_start=get_screen_start()<<1;
    ALIGN_SCREEN_START(screen_start);

    // mode 73h support
    if ( *(byte *)DosvModePtr == 0x73 ) {
        to = (unsigned short *)&video_copy[screen_start*2];
        from = (unsigned short *) get_screen_ptr(screen_start*2);
    }
    else {
        to = (unsigned short *)&video_copy[screen_start];
        from = (unsigned short *) get_screen_ptr(screen_start);
    }

    /*::::::::::::::::::::::::::::::::::::::::::: Check for buffer overflows */

#ifndef PROD
    if(((int)to) & 3)		printf("Video copy not aligned on DWORD\n");
    if(get_screen_length() & 3) printf("Screen size incorrect\n");
#endif

    /*::::::::::::::::::::::::::::::::::::::::::::::: Has the screen changed */

#ifndef CPU_40_STYLE
#if defined(NTVDM)
    if( VGLOBS && VGLOBS->dirty_flag >= 1000000L ){
#else
    if( VGLOBS && VGLOBS->dirtyTotal >= 1000000L ){
#endif

#else
    if(getVideodirty_total() >= 1000000L ){
#endif

	/*
	** screen_refresh_required() has requested a complete screen
	** repaint by setting the dirtyTotal.
	**
	** When switching between display pages video copy and display
	** memory could be the same so our normal partial update algorithm
	** gets confused.
	** This scheme updates video copy and then forces a complete
	** repaint.
	** Another option would have been to splat video copy and then go
	** through the partial update code below, but this is quicker.
	**
	** Tim Jan 93.
	*/
	setVideodirty_total(0);

	/*
	** Copy the screen data to our video copy.
	*/
	dwords_to_compare = get_screen_length() / 4;
	_asm
	{
		push esi	//Save orginal values of registers used by the
		push edi	//complier
		push ecx

		mov edi,to	//Ptr to video copy
		mov esi,from	//Ptr to intel video memory

		mov ecx,dwords_to_compare
		rep movsd	//Move screen data to video copy.

		pop ecx
		pop edi
		pop esi
	}

	/*
	** Re-paint the whole screen.
	** Set up rectangle dimension globals here for paint_text_rect(),
	** instead of calling add_to_rect().
	*/
        while ( NtInt10FlagUse ) {
            DbgPrint( "NtInt10Flag busy\n" );
            Sleep( 100L );
        }
            NtInt10FlagUse = TRUE;
            memcpy( NtInt10Flag, Int10Flag, 80*50 );
        {
            register int i;
            register byte *p;

            for ( p = Int10Flag, i = 0; i < 80*50; i++ ) {
               *p++ &= (~INT10_CHANGED); // reset
            }
        }

        if (get_offset_per_line() == 0)    /* showing up in stress */
            lines_per_screen = 25;
        else
	    lines_per_screen = get_screen_length()/get_offset_per_line();
	RectTop = 0;
	RectLeft = 0;
	RectBottom = lines_per_screen - 1;
	RectRight = ints_per_line - 1;
	RectDefined = TRUE;
	host_start_update();
	paint_text_rect(screen_start);
	host_end_update();

        NtInt10FlagUse = FALSE;

    }else{

      /*
      ** Normal partial screen update.
      */

      /*::::::::::::::::::::::: Repaint parts of the screen that have changed */


      if (get_offset_per_line() == 0)    /* showing up in stress */
          lines_per_screen = 25;
      else
          lines_per_screen = get_screen_length()/get_offset_per_line();

      if( Int10FlagCnt )
      {
           Int10FlagCnt = 0;

	   host_start_update();
	   /* Screen changed, calculate position of first variation */

	   init_text_rect();

           while ( NtInt10FlagUse ) {
               DbgPrint( "NtInt10Flag busy\n" );
               Sleep( 100L );
           }
           NtInt10FlagUse = TRUE;
           memcpy( NtInt10Flag, Int10Flag, 80*50 );
        {
           register int i;
           register byte *p;

           for ( p = Int10Flag, i = 0; i < 80*50; i++ ) {
               *p++ &= (~INT10_CHANGED); // reset
           }
        }

           pInt10Flag = NtInt10Flag;

	   for( i = 0; i < lines_per_screen; i++, pInt10Flag += ints_per_line )
	   {
		for ( j = 0; j < ints_per_line; j++ ) {
                    if ( pInt10Flag[j] & INT10_CHANGED )
                        break;
                }
                if ( j == ints_per_line )
                    continue;             // not change goto next line

                for ( k = ints_per_line - 1; k >= j; k-- ) {
                    if ( pInt10Flag[k] & INT10_CHANGED )
                        break;
                }

		// ntraid:mskkbug#3297,3515: some character does not display
		// 11/6/93 yasuho
		// Repaint the incomplete DBCS character
		if (j && (pInt10Flag[j] & INT10_DBCS_TRAILING) &&
		    (pInt10Flag[j-1] == INT10_DBCS_LEADING)) {
			j--;
			pInt10Flag[j] |= INT10_CHANGED;
		}

                to += j;
                from += j;

                len = k - j + 1;
		x = j;

                add_to_rect(screen_start, x, i, len);

                /*.................. transfer data painted to video copy */

		for( k = j; k < ints_per_line; k++ )
		    *to++ = *from++;
	  }

	  /* End of screen, flush any outstanding text update rectangles */
	  paint_text_rect(screen_start);

          NtInt10FlagUse = FALSE;
	  host_end_update();

     } /* End of partial screen update */

    } /* End of if dirtyTotal stuff, which selects full or partial repaint */


    /*:::::::::::::::::::::::::::::::::::::: Does the cursor need repainting */

    if(is_cursor_visible())
    {
	half_word attr;

	dirty_curs_x = get_cur_x();
	dirty_curs_y = get_cur_y();

	if(dirty_curs_x == now_cur_x && dirty_curs_y == now_cur_y)
	{
	    host_end_update();
	    return;
	}

	now_cur_x = dirty_curs_x;
	now_cur_y = dirty_curs_y;
	dirty_curs_offs = screen_start+dirty_curs_y * get_offset_per_line() + (dirty_curs_x<<1);

	if(dirty_curs_offs < 0x8001)	/* no lookup in possible gap */
	    attr = *(get_screen_ptr(dirty_curs_offs + 1));
	else
	    attr = 0;	/* will be off screen anyway */

	host_paint_cursor(dirty_curs_x, dirty_curs_y, attr);
    }

#endif  //NEC_98
}  // mon_text_update_03()

#endif // JAPAN
#if defined(KOREA)
// For Text emulation
void mon_text_update_ko()
{
    register int i;     /* Loop counters                */
    register int j,k;
    register unsigned long *from,*to;
    register int ints_per_line = get_offset_per_line()>>2;
    int lines_per_screen;
    int	len,x,screen_start;
    unsigned short *wfrom;
    unsigned short *wto;
    int dwords_to_compare;

    unsigned char *flag_from, *flag_to;
    boolean  DBCSState1 = FALSE;
    boolean  DBCSState2 = FALSE;

    /*::::::::::::::::::::::::::::::::::::::::::::::: Is the display disable */

    if(get_display_disabled()) return;

    /*::::::::::::::::::::::::::::::::: get screen size and location details */

    screen_start=get_screen_start()<<1;
    ALIGN_SCREEN_START(screen_start);

    to = (unsigned long *)&video_copy[screen_start];
    from = (unsigned long *) get_screen_ptr(screen_start);

    /*::::::::::::::::::::::::::::::::::::::::::: Check for buffer overflows */

#ifndef PROD
    if(((int)to) & 3)		printf("Video copy not aligned on DWORD\n");
    if(get_screen_length() & 3) printf("Screen size incorrect\n");
#endif

    /*::::::::::::::::::::::::::::::::::::::::::::::: Has the screen changed */

#ifndef CPU_40_STYLE
#if defined(NTVDM)
    if( VGLOBS && VGLOBS->dirty_flag >= 1000000L ){
#else
    if( VGLOBS && VGLOBS->dirtyTotal >= 1000000L ){
#endif

#else
    if(getVideodirty_total() >= 1000000L ){
#endif

	/*
	** screen_refresh_required() has requested a complete screen
	** repaint by setting the dirtyTotal.
	**
	** When switching between display pages video copy and display
	** memory could be the same so our normal partial update algorithm
	** gets confused.
	** This scheme updates video copy and then forces a complete
	** repaint.
	** Another option would have been to splat video copy and then go
	** through the partial update code below, but this is quicker.
	**
	** Tim Jan 93.
	*/
	setVideodirty_total(0);

	/*
	** Copy the screen data to our video copy.
	*/
	dwords_to_compare = get_screen_length() / 4;
	_asm
	{
		push esi	//Save orginal values of registers used by the
		push edi	//complier
		push ecx

		mov edi,to	//Ptr to video copy
		mov esi,from	//Ptr to intel video memory

		mov ecx,dwords_to_compare
		rep movsd	//Move screen data to video copy.

		pop ecx
		pop edi
		pop esi
	}

	/*
	** Re-paint the whole screen.
	** Set up rectangle dimension globals here for paint_text_rect(),
	** instead of calling add_to_rect().
	*/
        if (get_offset_per_line() == 0)    /* showing up in stress */
            lines_per_screen = 25;
        else
	    lines_per_screen = get_screen_length()/get_offset_per_line();
	RectTop = 0;
	RectLeft = 0;
	RectBottom = lines_per_screen - 1;
	RectRight = (ints_per_line<<1) - 1;
	RectDefined = TRUE;
	host_start_update();
	paint_text_rect(screen_start);
	host_end_update();

    }else{

      /*
      ** Normal partial screen update.
      */

      dwords_to_compare = get_screen_length() / 4;

      _asm
      {
	push esi	//Save orginal values of registers used by the
	push edi	//complier
	push ecx

	mov esi,to	//Ptr to screen copy
	mov edi,from	//Ptr to intel video memory

	mov ecx,dwords_to_compare
	repe cmpsd	//Compare screen buffers

	mov dwords_to_compare,ecx
//	mov to,esi
//	mov from,edi

	pop ecx
	pop edi
	pop esi
      }

      /*::::::::::::::::::::::: Repaint parts of the screen that have changed */


      if (get_offset_per_line() == 0)    /* showing up in stress */
          lines_per_screen = 25;
      else
          lines_per_screen = get_screen_length()/get_offset_per_line();

      if(dwords_to_compare)
      {
	   host_start_update();
	   /* Screen changed, calculate position of first variation */

	   init_text_rect();

           flag_from = (unsigned char*)Int10Flag;
           flag_to   = (unsigned char*)NtInt10Flag;
           wfrom = (unsigned short *)from;
           wto   = (unsigned short *)to;
           for(i=0;i<lines_per_screen;i++)
           {
            for(j=0;j<ints_per_line*2;j++)
            {
                if (DBCSState1)
                {
                    *flag_from++ = INT10_DBCS_TRAILING;
                    DBCSState1 = FALSE;
                }
                else if (DBCSState1 = is_dbcs_first(LOBYTE(*wfrom)))
                    *flag_from++ = INT10_DBCS_LEADING;
                else
                    *flag_from++ = INT10_SBCS;
                wfrom++;

                if (DBCSState2)
                {
                    *flag_to++ = INT10_DBCS_TRAILING;
                    DBCSState2 = FALSE;
                }
                else if (DBCSState2 = is_dbcs_first(LOBYTE(*wto)))
                    *flag_to++ = INT10_DBCS_LEADING;
                else
                    *flag_to++ = INT10_SBCS;
                wto++;
            }
           }

           flag_from = (unsigned char*)Int10Flag;
           flag_to   = (unsigned char*)NtInt10Flag;

	   for(i=0;i<lines_per_screen;i++)
	   {
	    for(j=0;j<ints_per_line;j++)
	    {
                flag_from+=2;
                flag_to+=2;
		if(*to++ != *from++)
		{
		    to--;from--;
                    flag_to-=2;flag_from-=2;
		    for(k=ints_per_line-1-j;*(to+k)== *(from+k);k--){};
		    /*
		     * Note: For text mode there is one char for every word.
                     * no of bytes into screen=line*bytes_per_line + ints_into_line*4
		     * x_coord=width_of_one_char*(no_of_ints_into_line*2)
		     * y_coord=height_of_one_char*2*line
		     * length=no_of_ints*4+4     the plus 4 is to counteract the k--
		     * The host y co-ords are doubled
		     */

		    /* one or more ints of data are now selected
		       but refine difference to words (i.e. characters),
		       to avoid a glitch on the screen when typing in to
 		       a dumb terminal  */

		    len    = (k<<2) + 4;
		    x	   = (j<<1);

		    wfrom = (unsigned short *)from;
		    wto   = (unsigned short *)to;
		    if (*wfrom == *wto)
		    {
                        if (*flag_from & INT10_DBCS_TRAILING)
                        {
                            x--;
                            len += 2;
                        }
                        else if ( !(*flag_from & INT10_DBCS_LEADING) &&
                                  !(*flag_to   & INT10_DBCS_LEADING)   )
                        {
			    x++;
			    len -= 2;
                        }
		    }
                    else if ( (*flag_from & INT10_DBCS_TRAILING) ||
                              (*flag_to   & INT10_DBCS_TRAILING)   )
                    {
                        x--;
                        len += 2;
                    }

		    wfrom += (k<<1) + 1;
		    wto   += (k<<1) + 1;
		    if (*wfrom == *wto)
		    {
                        if (*(flag_from+(k<<1)+1) & INT10_DBCS_LEADING)
                        {
                            len += 2;
                        }
                        else if ( !(*(flag_from+(k<<1)+1) & INT10_DBCS_TRAILING) &&
                                  !(*(flag_to+(k<<1)+1)   & INT10_DBCS_TRAILING)   )
                        {
			    len -= 2;
                        }
                    }
                    else if ( (*(flag_from+(k<<1)+1) & INT10_DBCS_LEADING) ||
                              (*(flag_to+(k<<1)+1)   & INT10_DBCS_LEADING)   )
                    {
                        len += 2;
                    }

		    add_to_rect(screen_start, x, i, len/2);

		    /*.............................. transfer data painted to video copy */

		    for(k=j;k<ints_per_line;k++)
			*to++ = *from++;

                    flag_from += (ints_per_line-j) << 1;
                    flag_to   += (ints_per_line-j) << 1;

		    break;	/* onto next line */
		}
	    }
	  }

	  /* End of screen, flush any outstanding text update rectangles */
	  paint_text_rect(screen_start);

	  host_end_update();

     } /* End of partial screen update */

    } /* End of if dirtyTotal stuff, which selects full or partial repaint */


    /*:::::::::::::::::::::::::::::::::::::: Does the cursor need repainting */

    if(is_cursor_visible())
    {
	half_word attr;

	dirty_curs_x = get_cur_x();
	dirty_curs_y = get_cur_y();

	if(dirty_curs_x == now_cur_x && dirty_curs_y == now_cur_y)
	{
	    host_end_update();
	    return;
	}

	now_cur_x = dirty_curs_x;
	now_cur_y = dirty_curs_y;
	dirty_curs_offs = screen_start+dirty_curs_y * get_offset_per_line() + (dirty_curs_x<<1);

	if(dirty_curs_offs < 0x8001)	/* no lookup in possible gap */
	    attr = *(get_screen_ptr(dirty_curs_offs + 1));
	else
	    attr = 0;	/* will be off screen anyway */

	host_paint_cursor(dirty_curs_x, dirty_curs_y, attr);
    }


}
#endif

void mon_text_update()
{
#ifndef NEC_98

    register int i;	/* Loop counters		*/
    register int j,k;
    register unsigned long *from,*to;
    register int ints_per_line = get_offset_per_line()>>2;
    int lines_per_screen;
    int	len,x,screen_start;
    unsigned short *wfrom;
    unsigned short *wto;
    int dwords_to_compare;

#ifdef JAPAN
    if (BOPFromDispFlag && *(word *)DBCSVectorAddr) {
        if (*(byte *)DosvModePtr == 0x03 || *(byte *)DosvModePtr == 0x73) {
            mon_text_update_03();
            return;
        }
    }
#elif defined(KOREA) // JAPAN
    if (BOPFromDispFlag && *(word *)DBCSVectorAddr) {
        if (*(byte *)DosvModePtr == 0x03) {
            mon_text_update_ko();
            return;
        }
    }
#endif // KOREA
    /*::::::::::::::::::::::::::::::::::::::::::::::: Is the display disable */

    if(get_display_disabled()) return;

    /*::::::::::::::::::::::::::::::::: get screen size and location details */

    screen_start=get_screen_start()<<1;
    ALIGN_SCREEN_START(screen_start);

    to = (unsigned long *)&video_copy[screen_start];
    from = (unsigned long *) get_screen_ptr(screen_start);

    /*::::::::::::::::::::::::::::::::::::::::::: Check for buffer overflows */

#ifndef PROD
    if(((int)to) & 3)		printf("Video copy not aligned on DWORD\n");
    if(get_screen_length() & 3) printf("Screen size incorrect\n");
#endif

    /*::::::::::::::::::::::::::::::::::::::::::::::: Has the screen changed */

#ifndef CPU_40_STYLE
#if defined(NTVDM)
    if( VGLOBS && VGLOBS->dirty_flag >= 1000000L ){
#else
    if( VGLOBS && VGLOBS->dirtyTotal >= 1000000L ){
#endif

#else
    if(getVideodirty_total() >= 1000000L ){
#endif

	/*
	** screen_refresh_required() has requested a complete screen
	** repaint by setting the dirtyTotal.
	**
	** When switching between display pages video copy and display
	** memory could be the same so our normal partial update algorithm
	** gets confused.
	** This scheme updates video copy and then forces a complete
	** repaint.
	** Another option would have been to splat video copy and then go
	** through the partial update code below, but this is quicker.
	**
	** Tim Jan 93.
	*/
	setVideodirty_total(0);

	/*
	** Copy the screen data to our video copy.
	*/
	dwords_to_compare = get_screen_length() / 4;
	_asm
	{
		push esi	//Save orginal values of registers used by the
		push edi	//complier
		push ecx

		mov edi,to	//Ptr to video copy
		mov esi,from	//Ptr to intel video memory

		mov ecx,dwords_to_compare
		rep movsd	//Move screen data to video copy.

		pop ecx
		pop edi
		pop esi
	}

	/*
	** Re-paint the whole screen.
	** Set up rectangle dimension globals here for paint_text_rect(),
	** instead of calling add_to_rect().
	*/
        if (get_offset_per_line() == 0)    /* showing up in stress */
            lines_per_screen = 25;
        else
	    lines_per_screen = get_screen_length()/get_offset_per_line();
	RectTop = 0;
	RectLeft = 0;
	RectBottom = lines_per_screen - 1;
	RectRight = (ints_per_line<<1) - 1;
	RectDefined = TRUE;
	host_start_update();
	paint_text_rect(screen_start);
	host_end_update();

    }else{

      /*
      ** Normal partial screen update.
      */

      dwords_to_compare = get_screen_length() / 4;

      _asm
      {
	push esi	//Save orginal values of registers used by the
	push edi	//complier
	push ecx

	mov esi,to	//Ptr to screen copy
	mov edi,from	//Ptr to intel video memory

	mov ecx,dwords_to_compare
	repe cmpsd	//Compare screen buffers

	mov dwords_to_compare,ecx
//	mov to,esi
//	mov from,edi

	pop ecx
	pop edi
	pop esi
      }

      /*::::::::::::::::::::::: Repaint parts of the screen that have changed */


      if (get_offset_per_line() == 0)    /* showing up in stress */
          lines_per_screen = 25;
      else
          lines_per_screen = get_screen_length()/get_offset_per_line();

      if(dwords_to_compare)
      {
	   host_start_update();
	   /* Screen changed, calculate position of first variation */

	   init_text_rect();

	   for(i=0;i<lines_per_screen;i++)
	   {
	    for(j=0;j<ints_per_line;j++)
	    {
		if(*to++ != *from++)
		{
		    to--;from--;
		    for(k=ints_per_line-1-j;*(to+k)== *(from+k);k--){};
		    /*
		     * Note: For text mode there is one char for every word.
		     * no of bytes into screen=line*bytes_per_line + ints_into_line*4
		     * x_coord=width_of_one_char*(no_of_ints_into_line*2)
		     * y_coord=height_of_one_char*2*line
		     * length=no_of_ints*4+4     the plus 4 is to counteract the k--
		     * The host y co-ords are doubled
		     */

		    /* one or more ints of data are now selected
		       but refine difference to words (i.e. characters),
		       to avoid a glitch on the screen when typing in to
 		       a dumb terminal  */

		    len    = (k<<2) + 4;
		    x	   = (j<<1);

		    wfrom = (unsigned short *)from;
		    wto   = (unsigned short *)to;
		    if (*wfrom == *wto)
		    {
			x++;
			len -= 2;
		    }
		    wfrom += (k<<1) + 1;
		    wto   += (k<<1) + 1;
		    if (*wfrom == *wto)
		    {
			len -= 2;
		    }

		    add_to_rect(screen_start, x, i, len/2);

		    /*.............................. transfer data painted to video copy */

		    for(k=j;k<ints_per_line;k++)
			*to++ = *from++;

		    break;	/* onto next line */
		}
	    }
	  }

	  /* End of screen, flush any outstanding text update rectangles */
	  paint_text_rect(screen_start);

	  host_end_update();

     } /* End of partial screen update */

    } /* End of if dirtyTotal stuff, which selects full or partial repaint */


    /*:::::::::::::::::::::::::::::::::::::: Does the cursor need repainting */

    if(is_cursor_visible())
    {
	half_word attr;

	dirty_curs_x = get_cur_x();
	dirty_curs_y = get_cur_y();

	if(dirty_curs_x == now_cur_x && dirty_curs_y == now_cur_y)
	{
	    host_end_update();
	    return;
	}

	now_cur_x = dirty_curs_x;
	now_cur_y = dirty_curs_y;
	dirty_curs_offs = screen_start+dirty_curs_y * get_offset_per_line() + (dirty_curs_x<<1);

	if(dirty_curs_offs < 0x8001)	/* no lookup in possible gap */
	    attr = *(get_screen_ptr(dirty_curs_offs + 1));
	else
	    attr = 0;	/* will be off screen anyway */

	host_paint_cursor(dirty_curs_x, dirty_curs_y, attr);
    }

#endif  //NEC_98
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

boolean mon_text_scroll_up IFN6(sys_addr, start, int, width, int, height, int, attr, int, lines, int, colour)
{
#ifndef NEC_98
    short blank_word, *ptr, *top_left_ptr,*top_right_ptr, *bottom_right_ptr;
    unsigned short dummy;
    unsigned char *p;
    int words_per_line;
	int i,tlx,tly;
	int bpl = 2*get_chars_per_line();
	long start_offset;
	register half_word *src,*dest;
	boolean result;

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
	if ( getVM() )
	   return FALSE;   /* Don't optimise in V86 Mode */
#endif
#ifdef JAPAN
        // mode73h support
        if (!is_us_mode() && (*(byte *)DosvModePtr == 0x73)) {
            bpl = 4 * get_chars_per_line();
        }
#endif // JAPAN
	/*
	 * The colour we fill with for colour text displays is controlled by
	 * bits 4-6 of attr, with bit 7 turning on blinking (which we don't support)
	 */
	colour = ((half_word)attr>>4) & 7;

/*
 * Reduce the width of the rectangle if any right hand area is completely
 * blank.
 *
 * Don't reduce the size of the scrolling region for a dumb terminal.
 * Dumb terminal uses line feeds to scroll up, but only if the whole
 * screen is to be scrolled.  Reducing the scroll region causes
 * the whole region to be redrawn.
 */

	/* originally dummy was char [2] */
	/* unfortunately doing (short) *dummy */
	/* causes a bus error on M88K */
	p = (unsigned char *) &dummy;
	p [0] = ' ';
	p [1] = (unsigned char)attr;
	blank_word = dummy;

	words_per_line   = get_chars_per_line();
	top_left_ptr     = (short *) get_screen_ptr(start - gvi_pc_low_regen);
        top_right_ptr    = top_left_ptr + (width >> 1) - 1;
	bottom_right_ptr = top_right_ptr + words_per_line * (height - 1);
	ptr = bottom_right_ptr;
	if (width > 2) /* dont want to get a zero rectangle for safetys sake */
	{
	    while (*ptr == blank_word)
	    {
	        if (ptr == top_right_ptr) 	/* reached top of column? */
	        {
		    top_right_ptr--;	/* yes go to bottom of next */
		    bottom_right_ptr--;
		    if (top_right_ptr == top_left_ptr)
			break;
		    ptr = bottom_right_ptr;
	        }
	        else
		    ptr -= words_per_line;
	    }
	}
	width = (int)(top_right_ptr - top_left_ptr + 1) << 1;

	/* do the host stuff */
	start_offset = start - get_screen_start()*2 - gvi_pc_low_regen;
	tlx = (int)(start_offset%get_bytes_per_line())*get_pix_char_width()/2;
	tly = (int)(start_offset/get_bytes_per_line())*get_host_char_height();
	result = host_scroll_up(tlx,tly,tlx+width/2*get_pix_char_width()-1,
				tly+height*get_host_char_height()-1, lines*get_host_char_height(),colour);

	if(!result)
		return FALSE;


	adjust_cursor( UP, tlx, tly, width >> 1, height, lines, bpl );

	/* Scroll up the video_copy */
	dest = video_copy + start-gvi_pc_low_regen;
	src = dest + lines * bpl;

	if(width == bpl)
	{
		/* Can do the whole thing in one go */
		memcpy(dest,src,width*(height-lines));
		fwd_word_fill( (short)((' '<<8) | (half_word)attr), dest+width*(height-lines),width*lines/2);
	}
	else
	{
		/* Not scrolling whole width of screen, so do each line seperatly */
		for(i=0;i<height-lines;i++)
		{
			memcpy(dest,src,width);
			dest += bpl;
			src += bpl;
		}

		/* Fill exposed area of video copy */

		for(i=0;i<lines;i++)
		{
			fwd_word_fill( (short)((' '<<8) | (half_word)attr), dest,width/2);
			dest += bpl;
		}
	}

	/* Update video buffer */

	dest = get_screen_ptr(start - gvi_pc_low_regen);
	src = dest + lines * bpl;
	for(i=0;i<height-lines;i++)
	{
		memcpy(dest,src,width);
		dest += bpl;
		src += bpl;
	}

	/* Fill exposed area of buffer */

	for(i=0;i<lines;i++)
	{
		fwd_word_fill( (short)((' '<<8) | (half_word)attr), dest,width/2);
		dest += bpl;
	}

	host_scroll_complete();

#endif  //NEC_98
	return TRUE;
}

boolean mon_text_scroll_down IFN6(sys_addr, start, int, width, int, height, int, attr, int, lines, int, colour)
{
#ifndef NEC_98
	int i,tlx,tly;
	int bpl = 2*get_chars_per_line();
	long start_offset;
	register half_word *src,*dest;
	boolean result;

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
	if ( getVM() )
	   return FALSE;   /* Don't optimise in V86 Mode */
#endif
#ifdef JAPAN
        // mode73h support
        if (!is_us_mode() && (*(byte *)DosvModePtr == 0x73)) {
        bpl = 4 * get_chars_per_line();
        }
#endif /// JAPAN

	/*
	 * The colour we fill with for colour text displays is controlled by
	 * bits 4-6 of attr, with bit 7 turning on blinking (which we don't support)
	 */
	colour = ((half_word)attr>>4) & 7;


	/* do the host stuff */
	start_offset = start - get_screen_start() * 2 - gvi_pc_low_regen;
	tlx = (int)(start_offset%get_bytes_per_line())*get_pix_char_width()/2;
	tly = (int)(start_offset/get_bytes_per_line())*get_host_char_height();
	result = host_scroll_down(tlx,tly,tlx+width/2*get_pix_char_width()-1,
			tly+height*get_host_char_height()-1, lines*get_host_char_height(),colour);

	if(!result)
		return FALSE;

	adjust_cursor( DOWN, tlx, tly, width >> 1, height, lines, bpl );

	/* Scroll down the video_copy */

	if(width == bpl)
	{
		/* Can do the whole thing in one go */
		src = video_copy + start - gvi_pc_low_regen;
		dest = src + lines * bpl;
		memcpy(dest,src,width*(height-lines));
		fwd_word_fill( (short)((' '<<8) | (half_word)attr), src,width*lines/2);
	}
	else
	{
		/* Not scrolling whole width of screen, so do each line seperatly */
		dest = video_copy + start-gvi_pc_low_regen + (height-1) * bpl;
		src = dest - lines * bpl;
		for(i=0;i<height-lines;i++)
		{
			memcpy(dest,src,width);
			dest -= bpl;
			src -= bpl;
		}

		/* Fill exposed area of video copy */

		for(i=0;i<lines;i++)
		{
			fwd_word_fill( (short)((' '<<8) | (half_word)attr), dest,width/2);
			dest -= bpl;
		}
	}

	/* Update video buffer */

	dest = get_screen_ptr(start - gvi_pc_low_regen) + (height-1) * bpl;
	src = dest - lines * bpl;
	for(i=0;i<height-lines;i++)
	{
		memcpy(dest,src,width);
		dest -= bpl;
		src -= bpl;
	}

	/* Fill exposed area of buffer */

	for(i=0;i<lines;i++)
	{
		fwd_word_fill( (short)((' '<<8) | (half_word)attr), dest,width/2);
		dest -= bpl;
	}

	host_scroll_complete();

#endif  //NEC_98
	return TRUE;
}
#endif	/* MONITOR */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::: Text handling routines :::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#define MAX_LEFT_VARIATION  (2)
#define MAX_RIGHT_VARIATION (5)

#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define MIN(a,b) ((a) < (b) ? (a) : (b))

int ExpandCount;
int BaseL, BaseR;

/* Init text rect variables */

void init_text_rect()
{
#ifndef NEC_98
    RectDefined = FALSE;       /* No rectangle defined yet */
    ExpandCount = 0;
#endif  //NEC_98
}

/* Add coordinates to rectangle */

void add_to_rect(int screen_start, register int x, register int y, int len)
{
#ifndef NEC_98
    int endx = x + len - 1;

    /* printf("add rect - (%d,%d) len %d\n", x, y, len); */


    /* Is there an existing rectangle */
    if(RectDefined)
    {
	/* Validate X variation and Y coord */

#if defined(JAPAN) || defined(KOREA)
	if( ( BaseL == x ) &&
	    ( BaseR == endx )  &&
#else
	if(abs(BaseL - x) <= MAX_LEFT_VARIATION &&
	   abs(BaseR - endx) <= MAX_RIGHT_VARIATION &&
#endif
	   RectBottom+1 >= y)
	{
	    /* Expand rectangle */
	    ExpandCount++;
	    /* printf("Expanding rect\n"); */

	    RectLeft = MIN(RectLeft,x);
	    RectRight = MAX(RectRight,endx);
	    RectBottom = y;
	    return;
	}
	else
	{
	    paint_text_rect(screen_start);
	}
    }

    /* New rectangle */

    /* printf("Defining new rect\n"); */

    RectDefined = TRUE;     /* Rectangle defined */

    BaseL = x;		    /* Base Left/Right */
    BaseR = endx;

    RectTop = y;	    /* Define rectangle */
    RectLeft = x;

    RectBottom = y;
    RectRight = endx;
#endif  //NEC_98
}


/* Paint rectangle */

void paint_text_rect(int screen_start)
{
#ifndef NEC_98
#ifdef MONITOR
#ifdef JAPAN
    int offset;

    if (!is_us_mode() && (sas_hw_at_no_check(DosvModePtr) == 0x73))
        offset = (RectTop * (get_offset_per_line()<<1)) + (RectLeft<<2);
    else
        offset = RectTop * get_offset_per_line() + (RectLeft<<1);
#else // !JAPAN
    int offset = RectTop * get_offset_per_line() + (RectLeft<<1);
#endif // !JAPAN
#else
    int offset = (RectTop * (get_offset_per_line()<<1)) + (RectLeft<<2);
#endif

    /* Is there a rectangled defined */
    if(!RectDefined) return;

    /* Paint rectangle */

    /* printf("Paint rect (%d,%d) (%d,%d)  \t[%d]\n",RectLeft,RectTop,RectRight,RectBottom,ExpandCount); */

    (*paint_screen)(offset + screen_start,			/* Start Offset */
#ifdef MONITOR
		   RectLeft, RectTop,				/* Screen X,Y */
#else
		   RectLeft*get_pix_char_width(),RectTop*get_host_char_height(),
#endif
		    (RectRight - RectLeft +1)*2,		/* Len */
		    RectBottom - RectTop +1);			/* Height */

    RectDefined = FALSE;	/* Rectangle painted */
    ExpandCount = 0;
#endif  //NEC_98
}

#ifndef MONITOR
#ifdef JAPAN
// This routine provides the same functionality as mon_text_update_03().
void jazz_text_update_jp();

void jazz_text_update_jp()
{

    register int i;	/* Loop counters		*/
    register int j,k;
    register unsigned short *from,*to;
    register int chars_per_line = get_offset_per_line()>>1;
    int lines_per_screen;
    int	offset,len,x,screen_start;
    unsigned short *wfrom;
    unsigned short *wto;

    byte *pInt10Flag;
    static NtInt10FlagUse = FALSE;
    IMPORT sys_addr DosvVramPtr;
    register sys_addr ptr = DosvVramPtr;
    register int skip;


    if (getVideodirty_total() == 0 || get_display_disabled() )
	return;

    if ( get_offset_per_line() == 0 ){
        lines_per_screen = 25;
    }
    else {
        lines_per_screen = get_screen_length()/get_offset_per_line();
    }

    host_start_update();

    screen_start=get_screen_start()<<2;
    ALIGN_SCREEN_START(screen_start);

    // mode 03h and 73h use same plane  Aug. 6 TakeS
    to = (unsigned short *)&video_copy[get_screen_start()<<1];
    from = (unsigned short *) get_screen_ptr(screen_start);

    skip = 2;

    if(getVideodirty_total() >1500)	/* paint the whole lot */
    {
        for(i=get_screen_length()>>1;i>0;i--)
	{
	    *to++ = *from;	/* char and attribute bytes */
            from++;
	    sas_loadw(ptr, from);
	    from++;
	    ptr += skip;
	    // from += 2;		/* planes 2,3 interleaved */
	}

	while ( NtInt10FlagUse ) {
#ifdef JAPAN_DBG
	    DbgPrint( "NtInt10Flag busy\n" );
#endif
	    Sleep( 100L );
	}
        NtInt10FlagUse = TRUE;
	memcpy( NtInt10Flag, Int10Flag, 80*50 );
        {
	register int i = 80*50;
	register byte *p = Int10Flag;
	
	while(i--){
	  *p++ &= (~INT10_CHANGED); // reset
	  }
        }

        (*paint_screen)(screen_start, 0, 0, get_bytes_per_line(),
		        lines_per_screen);

        NtInt10FlagUse = FALSE;
    }
    else
    {
      if( Int10FlagCnt )
	{
	  Int10FlagCnt = 0;
	
	  /* Screen changed, calculate position of first variation */
	
	  init_text_rect();
	
	  while ( NtInt10FlagUse ) {
#ifdef JAPAN_DBG
	    DbgPrint( "NtInt10Flag busy\n" );
#endif
	    Sleep( 100L );
	  }
	  NtInt10FlagUse = TRUE;
	    memcpy( NtInt10Flag, Int10Flag, 80*50 );
	  {
	    register int i = 80*50;
	    register byte *p = Int10Flag;
	
	    while(i--){
	      *p++ &= (~INT10_CHANGED); // reset
	      }
	  }
	
	  pInt10Flag = NtInt10Flag;
	
	  for(i=0;i<lines_per_screen;i++, pInt10Flag += chars_per_line )
	    {
              for(j=0;j<chars_per_line;j++, to++, from +=2, ptr += skip )
		{
		  if ( pInt10Flag[j] & INT10_CHANGED )
		    break;
		}
	      if ( j == chars_per_line )
		continue;             // not change goto next line
		
		  for ( k = chars_per_line - 1; k >= j; k-- ) {
		    if ( pInt10Flag[k] & INT10_CHANGED )
		      break;
		  }
	
		// ntraid:mskkbug#3297,3515: some character does not display
		// 11/6/93 yasuho
		// Repaint the incomplete DBCS character
		if (j && (pInt10Flag[j] & INT10_DBCS_TRAILING) &&
		    (pInt10Flag[j-1] == INT10_DBCS_LEADING)) {
			j--;
			pInt10Flag[j] |= INT10_CHANGED;
		}

	      len = k - j + 1;
	      x = j;
	
		add_to_rect(screen_start, x, i, len);
	
	      /*.................. transfer data painted to video copy */
	
	      for( k = j; k < chars_per_line; k++ ){
		*to++ = *from;
		from++;
		sas_loadw(ptr, from);
		from++;
		ptr += skip;
		// from += 2;
	      }
	    }
	}
      /* End of screen, flush any outstanding text update rectangles */
	paint_text_rect(screen_start);

      NtInt10FlagUse = FALSE;
  }

  setVideodirty_total(0);

  /*:::::::::::::::::::::::::::::::::::::::::::::::::: Repaint cursor */

  if (is_cursor_visible())
    {
      half_word attr;

      dirty_curs_x = get_cur_x();
      dirty_curs_y = get_cur_y();

      dirty_curs_offs = screen_start+dirty_curs_y * (get_offset_per_line()<<1) + (dirty_curs_x<<2);
      attr = *(get_screen_ptr(dirty_curs_offs + 1));

      host_paint_cursor( dirty_curs_x, dirty_curs_y, attr );
    }

  host_end_update();
}
#endif // JAPAN
#if defined(KOREA)
void jazz_text_update_ko()
{

    register int i;	/* Loop counters		*/
    register int j,k;
    register unsigned short *from,*to;
    register int chars_per_line = get_offset_per_line()>>1;
    int lines_per_screen;
    int	offset,len,x,screen_start;
    unsigned short *wfrom;
    unsigned short *wto;

    unsigned char *flag_from, *flag_to;
    boolean  DBCSState1 = FALSE;
    boolean  DBCSState2 = FALSE;

    if (getVideodirty_total() == 0 || get_display_disabled() )
	return;

    lines_per_screen = get_screen_length()/get_offset_per_line();

    host_start_update();

    screen_start=get_screen_start()<<2;
    ALIGN_SCREEN_START(screen_start);

    to = (unsigned short *)&video_copy[get_screen_start()<<1];
    from = (unsigned short *) get_screen_ptr(screen_start);

    if(getVideodirty_total() >1500)	/* paint the whole lot */
    {
	for(i=get_screen_length()>>1;i>0;i--)
	{
	    *to++ = *from;	/* char and attribute bytes */
	    from += 2;		/* planes 2,3 interleaved */
	}

	(*paint_screen)(screen_start, 0, 0, get_bytes_per_line(),
			lines_per_screen);
    }
    else
    {
	init_text_rect();

        flag_from = (unsigned char*)Int10Flag;
        flag_to   = (unsigned char*)NtInt10Flag;
        wfrom = (unsigned short *)from;
        wto   = (unsigned short *)to;
        for(i=0;i<lines_per_screen;i++)
        {
         for(j=0;j<chars_per_line;j++)
         {
             if (DBCSState1)
             {
                 *flag_from++ = INT10_DBCS_TRAILING;
                 DBCSState1 = FALSE;
             }
             else if (DBCSState1 = is_dbcs_first(LOBYTE(*wfrom)))
                 *flag_from++ = INT10_DBCS_LEADING;
             else
                 *flag_from++ = INT10_SBCS;
             wfrom+=2;

             if (DBCSState2)
             {
                 *flag_to++ = INT10_DBCS_TRAILING;
                 DBCSState2 = FALSE;
             }
             else if (DBCSState2 = is_dbcs_first(LOBYTE(*wto)))
                 *flag_to++ = INT10_DBCS_LEADING;
             else
                 *flag_to++ = INT10_SBCS;
             wto++;
         }
        }

        flag_from = (unsigned char*)Int10Flag;
        flag_to   = (unsigned char*)NtInt10Flag;

	for(i=0;i<lines_per_screen;i++)
	{
	    for(j=0;j<chars_per_line;j++)
	    {
                flag_from++;
                flag_to++;
		if(*to != *from)
		{
		    k=chars_per_line-1-j;
		    wfrom = from + k*2;
		    wto   = to + k;

		    for(;*wto== *wfrom;k--,wto--,wfrom-=2){};
		    /*
		     * Note: For text mode there is one char for every word.
		     * no of bytes into screen=line*bytes_per_line + ints_into_line*4
		     * x_coord=width_of_one_char*(no_of_ints_into_line*2)
		     * y_coord=height_of_one_char*2*line
		     * length=no_of_ints*4+4     the plus 4 is to counteract the k--
		     * The host y co-ords are doubled
		     */

		    /* one or more ints of data are now selected
		       but refine difference to words (i.e. characters),
		       to avoid a glitch on the screen when typing in to
 		       a dumb terminal  */

		    offset = (i * (get_offset_per_line()<<1)) + (j<<2);
                    len    = (k<<2) + 4;
                    x      = j;

                    if ( (*flag_from & INT10_DBCS_TRAILING) ||
                         (*flag_to   & INT10_DBCS_TRAILING)   )
                    {
                        x--;
                        len += 4;
                    }

		    wfrom = from + (k<<1);
		    wto   = to + k;
		    if (*wfrom == *wto)
		    {
                        if (*(flag_from+k) & INT10_DBCS_LEADING)
                        {
                            len += 4;
                        }
                        else if ( !(*(flag_from+k) & INT10_DBCS_TRAILING) &&
                                  !(*(flag_to+k)   & INT10_DBCS_TRAILING)   )
                        {
			    len -= 4;
                        }
                    }
                    else if ( (*(flag_from+k) & INT10_DBCS_LEADING) ||
                              (*(flag_to+k)   & INT10_DBCS_LEADING)   )
                    {
                        len += 4;
                    }

                    add_to_rect(screen_start, x, i, len/4);

		    for(k=j;k<chars_per_line;k++)
		    {
			*to++ = *from;
			from+=2;
		    }

                    flag_from += (chars_per_line-j);
                    flag_to   += (chars_per_line-j);

		    break;	/* onto next line */
		}
		else
		{
		    to++; from +=2;
		}
	    }
	}
	  /* End of screen, flush any outstanding text update rectangles */
	  paint_text_rect(screen_start);
    }

	setVideodirty_total(0);

	/*:::::::::::::::::::::::::::::::::::::::::::::::::: Repaint cursor */

	if (is_cursor_visible())
	{
		half_word attr;

		dirty_curs_x = get_cur_x();
		dirty_curs_y = get_cur_y();

		dirty_curs_offs = screen_start+dirty_curs_y * (get_offset_per_line()<<1) + (dirty_curs_x<<2);
		attr = *(get_screen_ptr(dirty_curs_offs + 1));

		host_paint_cursor( dirty_curs_x, dirty_curs_y, attr );
	}

	host_end_update();
}
#endif // KOREA

void jazz_text_update()
{

    register int i;	/* Loop counters		*/
    register int j,k;
    register unsigned short *from,*to;
    register int chars_per_line = get_offset_per_line()>>1;
    int lines_per_screen;
    int	offset,len,x,screen_start;
    unsigned short *wfrom;
    unsigned short *wto;

#ifdef JAPAN
    byte vmode = sas_hw_at_no_check(DosvModePtr);
    if (BOPFromDispFlag &&
        (sas_w_at_no_check(DBCSVectorAddr) != 0) &&
        (vmode == 0x03 || vmode == 0x73)) {
        jazz_text_update_jp();
        return;
    }
#elif defined(KOREA) // JAPAN
    byte vmode = sas_hw_at_no_check(DosvModePtr);
    if (BOPFromDispFlag &&
        (sas_w_at_no_check(DBCSVectorAddr) != 0) &&
        (vmode == 0x03)) {
        jazz_text_update_ko();
        return;
    }
#endif // KOREA
    if (getVideodirty_total() == 0 || get_display_disabled() )
	return;

    lines_per_screen = get_screen_length()/get_offset_per_line();

    host_start_update();

    screen_start=get_screen_start()<<2;
    ALIGN_SCREEN_START(screen_start);

    to = (unsigned short *)&video_copy[get_screen_start()<<1];
    from = (unsigned short *) get_screen_ptr(screen_start);

    if(getVideodirty_total() >1500)	/* paint the whole lot */
    {
	for(i=get_screen_length()>>1;i>0;i--)
	{
	    *to++ = *from;	/* char and attribute bytes */
	    from += 2;		/* planes 2,3 interleaved */
	}

	(*paint_screen)(screen_start, 0, 0, get_bytes_per_line(),
			lines_per_screen);
    }
    else
    {
	init_text_rect();

	for(i=0;i<lines_per_screen;i++)
	{
	    for(j=0;j<chars_per_line;j++)
	    {
		if(*to != *from)
		{
		    k=chars_per_line-1-j;
		    wfrom = from + k*2;
		    wto   = to + k;

		    for(;*wto== *wfrom;k--,wto--,wfrom-=2){};
		    /*
		     * Note: For text mode there is one char for every word.
		     * no of bytes into screen=line*bytes_per_line + ints_into_line*4
		     * x_coord=width_of_one_char*(no_of_ints_into_line*2)
		     * y_coord=height_of_one_char*2*line
		     * length=no_of_ints*4+4     the plus 4 is to counteract the k--
		     * The host y co-ords are doubled
		     */

		    /* one or more ints of data are now selected
		       but refine difference to words (i.e. characters),
		       to avoid a glitch on the screen when typing in to
 		       a dumb terminal  */

		    offset = (i * (get_offset_per_line()<<1)) + (j<<2);
		    len    = (k<<2) + 4;
		    add_to_rect(screen_start, j, i, len/4);

		    for(k=j;k<chars_per_line;k++)
		    {
			*to++ = *from;
			from+=2;
		    }
		    break;	/* onto next line */
		}
		else
		{
		    to++; from +=2;
		}
	    }
	}
	  /* End of screen, flush any outstanding text update rectangles */
	  paint_text_rect(screen_start);
    }

	setVideodirty_total(0);

	/*:::::::::::::::::::::::::::::::::::::::::::::::::: Repaint cursor */

	if (is_cursor_visible())
	{
		half_word attr;

		dirty_curs_x = get_cur_x();
		dirty_curs_y = get_cur_y();

		dirty_curs_offs = screen_start+dirty_curs_y * (get_offset_per_line()<<1) + (dirty_curs_x<<2);
		attr = *(get_screen_ptr(dirty_curs_offs + 1));

		host_paint_cursor( dirty_curs_x, dirty_curs_y, attr );
	}

	host_end_update();
}
#endif /* MONITOR */
#endif /* NTVDM */
#endif /* REAL_VGA */

extern void host_stream_io_update(half_word *, word);

#ifndef NEC_98
#ifdef NTVDM
void stream_io_update(void)
{

#ifdef MONITOR
    if (sas_w_at_no_check(stream_io_bios_busy_sysaddr)) {
        return;

    }
#endif

    if (*stream_io_dirty_count_ptr) {
        host_start_update();
        host_stream_io_update(stream_io_buffer, *stream_io_dirty_count_ptr);
        host_end_update();
        *stream_io_dirty_count_ptr = 0;

    }

}
#endif
#endif // !NEC_98

#if defined(NEC_98)

// For PC-9801 Emulation related functions

DISPLAY_GLOBS   NEC98Display;            /* PC-9801 Display structure */

// Supported functions in this part
// 1) unsigned  short Cnv_NEC98_ToSjisLR( cell,flg )
//    Convert NEC98 VRAM format into Shift-JIS code.
// 2) NEC98_VRAM_COPY Get_NEC98_VramCellL( loc )
//    Get Cell(char+attr) located on given position
// 3) NEC98_VRAM_COPY Get_NEC98_VramCellA( addr )
//    Get Cell(char+attr) located on given 32 Adress

unsigned short Cnv_NEC98_ToSjisLR( cell, flg )
IN NEC98_VRAM_COPY  cell;
OUT unsigned short  *flg;
{
register unsigned short tmp;
register unsigned char upper,lower;
register unsigned short ch = cell.code;

        *flg = 0 ;
        if(!(HIBYTE(ch))) return ( ch );

//      *flg=(ch&NEC98_CODE_LR) ? NEC98_CODE_RIGHT : NEC98_CODE_LEFT ;
        *flg=(ch&0x0080) ? NEC98_CODE_RIGHT : NEC98_CODE_LEFT ;

        tmp=ch&NEC98_CODE_MASK;
        upper=LOBYTE( tmp )+NEC98_CODE_BIAS;
        lower=HIBYTE( tmp )+0x1f;

        if ( !(upper&0x01) ){
                upper/=2;
                upper--;
                lower+=0x5e;
        }else{
                upper/=2;
        }
        if ( lower>=0x7f )
                lower++;
        if ( upper>=0x2f )
                upper+=0xb1;
        else
                upper+=0x71;

        return((unsigned short)upper|(unsigned short)lower<<8);
}


NEC98_VRAM_COPY  Get_NEC98_VramCellL( loc )
IN      unsigned short  loc;    /* TVRAM position */
{
        NEC98_VRAM_COPY cell;
        unsigned short x;
        unsigned short *NEC98code;
        unsigned char *NEC98attr;
        register int i;
        int flg;
        unsigned int lines;
        unsigned int lines_per_screen;

        flg = 0;
        lines = 0;
        lines_per_screen=get_screen_length()/get_offset_per_line();
        loc *= 2;

        do{
            for (i=0;i<text_splits.nRegions;i++){
                x=(text_splits.split[i].lines)*OFFSET_PER_LINE;
                if ( loc<x ) {  /* This region ? */
                        NEC98code=(unsigned short *)(text_splits.split[i].addr+loc);
                        NEC98attr=(unsigned char  *)(text_splits.split[i].addr+loc+0x2000);
                        flg=1;
                        break;
                }
                lines+=text_splits.split[i].lines;
                if(lines>=lines_per_screen){
                        flg=2;
                        break;
                }
                loc-=x;
           }
        }while(flg==0);

        if(flg==2){
                cell.code=0x20;
                cell.attr=0x07;
        }else{
                cell.code=*NEC98code;
                cell.attr=*NEC98attr;
        }
        return( cell );
}


NEC98_VRAM_COPY  Get_NEC98_VramCellA( addr )
        IN unsigned     short   *addr;
{
        /* Local work variables */

    NEC98_VRAM_COPY cell;
    register int i;
    unsigned short *tmp_addr;
    unsigned short x;

        for( i=0 ; i<4 ; i++ ){
            x=(text_splits.split[i].lines)*OFFSET_PER_LINE;
            tmp_addr=(unsigned short *)((unsigned)text_splits.split[i].addr+x);
            if( addr >= text_splits.split[i].addr && addr <= tmp_addr ){
                    cell.code=*addr;
                    cell.attr=*((unsigned char *)(addr+0x2000));
                    break;
            }
        }
        return( cell );
}

/*
Convert NEC98 attributes into EGA's attr.
                        b0 : Secret'
                        b1 : Blinking
                        b2 : Reverse
                        b3 : Underline(IGNORED)
                        b4 : VerticalLine(IGNORED)
                        b5 : Blue
                        b6 : Red
                        b7 : Green

Outputs:   (return)     Converted attributes......
                        b0 : Foreground Blue
                        b1 : Foreground Green
                        b2 : Foreground Red
                        b3 : Intensity(ALWAYS'1')
                        b4 : Background Blue
                        b5 : Background Green
                        b6 : Background Red
                        b7 : Blinking
*/

unsigned char Cnv_NEC98_atr( attr )
IN unsigned char        attr;
{
        /* Local work variables */

        register unsigned short fg_color;       /* Fore color tmp.      */
        register unsigned short bg_color;       /* Back color tmp.      */
        unsigned char result  ;       /* Result tmp.  */

        /* Acquire color bits for PC/AT */

        fg_color=NEC98_get_color(attr) ;
        bg_color=NEC98_is_reverse(attr) ? fg_color : NEC98_ATR_BLACK ;
        if(NEC98_is_reverse(attr))
            fg_color=(NEC98_is_secret(attr)?fg_color:NEC98_ATR_BLACK);
        else
            fg_color=NEC98_is_secret(attr)?NEC98_ATR_BLACK:fg_color;

        /* Convert into EGA form and return     */

        result= ( NEC98_is_blink(attr) ? 0x80 : 0 )            /* Blink */
                        | NEC98_EGA_FGCOLOR(fg_color)          /* Foreground */
                        | NEC98_EGA_BGCOLOR(bg_color);              /* Background */

        return( result );
}

/* NEC98 GARAPHIC UPDATE LOGIC */

void NEC98_text_line_address_set(void);
void NEC98_nothing_update(void);
void NEC98_nothing_upgrap(void);
void NEC98_text_update(void);
void NEC98_graph_update(void);
void NEC98_text_graph_update(void);
void NEC98_text_paint_dirty_rect(int,int);
void NEC98_graph_paint_dirty_rect(int,int);
void NEC98_text_graph_paint_dirty_rect1(int,int);
void NEC98_text_graph_paint_dirty_rect2(int,int);
int  NEC98_text_find_dirty_line(void);
int  NEC98_graph_find_dirty_line(unsigned char *,unsigned char *);
int  NEC98_text_graph_find_dirty_line(unsigned char *,unsigned char *);

extern  void    host_display_disable();
extern  void    set_cursorpos();
extern  BOOL    select_disp_nothing;
extern  BOOL    cursor_move_required;
extern  BOOL    scroll_move_required;
extern  BOOL    once_pal; /* palette initialize */


void    NEC98_text_line_address_set(void)
{
    int count;     /* text line counter */
    int now;       /* text line counter */
    int i,j;       /* loop counter      */

    count = get_text_lines();
    now   = 0;       /* setting line address now pointer */

    for( i=0 ; i<4 ;i++){
        if(( now + text_splits.split[i].lines) > count ){
            for( j=0 ; now<count ; j++){
                compline[now].codeadr = &((text_splits.split[i].addr)[(get_offset_per_line())*j]);
                compline[now].attradr = &((compline[now].codeadr)[0x1000]) ;
                now++;
            }
            break;
        }else{
            for( j=0 ; j < text_splits.split[i].lines ; j++ ){
                compline[now].codeadr = &((text_splits.split[i].addr)[(get_offset_per_line())*j]);
                compline[now].attradr = &((compline[now].codeadr)[0x1000]) ;
                now++;
            }
        }
    }
}

/* NEC98 Timer Tick UPDATE ENTRY */

void    NEC98_nothing_update(void)
{
    host_start_update();
    if( select_disp_nothing == TRUE ){
        if((video_emu_mode==TRUE) || (compatible_font==TRUE)){
            set_the_vlt(); /* host palette changed */
            host_display_disable();
        }else{
            (*paint_screen)(0,0,0,get_bytes_per_line(),get_text_lines());
        }
        select_disp_nothing=FALSE;
    }

    if( cursor_move_required ){
        set_cursorpos();
        cursor_move_required = FALSE;
    }

    NEC98GLOBS->dirty_flag = 0; /* all  update end */
    host_end_update();         /* send update end */
}


void    NEC98_nothing_upgrap(void)
{
    host_start_update();
    if( select_disp_nothing == TRUE ){
        set_the_vlt(); /* host palette changed */
        host_display_disable();
        select_disp_nothing=FALSE;
    }

    if(cursor_move_required ){
        set_cursorpos();
        cursor_move_required = FALSE;
    }

    NEC98GLOBS->dirty_flag = 0; /* all  update end */
    host_end_update(); /* send update end */
}

void    NEC98_text_update(void)
{
    register int    loop;              /* loop counter              */
    register int    count;             /* loop counter              */
    register int    offset;            /* use paint offset          */
    register int    next;              /* count dirty line          */
    register int    ycoord;            /* y coordinate update       */
    register int    width;             /* y coordinate update       */
    unsigned char   *vram;             /* compare virtual vram area */
    unsigned char   *copy;             /* compare vram save area    */
    register unsigned char  *tmpvram;  /* compare virtual vram area */
    register unsigned char  *tmpcopy;  /* compare vram save area    */
    register NEC98_VRAM_COPY *txtcopy;
    BOOL graph_not_update;             /* graph is not update       */

    if( (video_emu_mode==TRUE) || (compatible_font==TRUE) ){
        if(once_pal == FALSE){
            set_the_vlt();
            once_pal=TRUE;
        }
    }

    if( cursor_move_required ){
        set_cursorpos();
        cursor_move_required = FALSE ;
    }

    if( NEC98GLOBS->dirty_flag == 0 ) return ;    /* nothing update ! */

    host_start_update();

    if( scroll_move_required ){
        NEC98_text_line_address_set();
        scroll_move_required = FALSE ;
    }

    if( NEC98GLOBS->dirty_flag > 10000L ){           /* screen refresh ! */
        note_display_state0("NEC98:text all update !!");

        txtcopy = (NEC98_VRAM_COPY *)video_copy;
        width   = get_offset_per_line()/2 ;

        for( loop=0 ; loop<get_text_lines() ; loop++ ){
            for( count=0 ; count<width ; count++ ){
                (txtcopy+(loop*width+count))->code = *(compline[loop].codeadr+count);
                (txtcopy+(loop*width+count))->attr = (unsigned char)*(compline[loop].attradr+count) ;
            }
        }
                /* redraw gvram displayed area( HOST call ) */
        (*paint_screen)(0,0,0,get_offset_per_line(),get_text_lines());

    }else{
        init_dirty_recs();
        next = NEC98_text_find_dirty_line();
        if(next) NEC98_text_paint_dirty_rect(0,next);
    }
    NEC98GLOBS->dirty_flag = 0; /* all  update end */
    host_end_update(); /* send update end */
}


void    NEC98_graph_update(void)
{
    register int    loop;              /* loop counter              */
    register int    count;             /* loop counter              */
    register int    offset;            /* use paint offset          */
    register int    next;              /* count dirty line          */
    register int    ycoord;            /* y coordinate update       */
    unsigned char   *vram;             /* compare virtual vram area */
    unsigned char   *copy;             /* compare vram save area    */
    register unsigned char  *tmpvram;  /* compare virtual vram area */
    register unsigned char  *tmpcopy;  /* compare vram save area    */

    if(once_pal==FALSE){
        set_the_vlt(); /* host palette changed */
        once_pal=TRUE;
    }

    if( cursor_move_required ){
        set_cursorpos();
        cursor_move_required = FALSE ;
    }

    if( NEC98GLOBS->dirty_flag == 0 ) return ;      /* nothing update ! */

    host_start_update();

    vram = &get_gvram_ptr()[get_gvram_start()]; /* vram area top address */
    copy = &get_gvram_copy()[get_gvram_start()];/* vram area top address */
    tmpvram = vram;
    tmpcopy = copy;

    if( NEC98GLOBS->dirty_flag > 20000L ){           /* screen refresh ! */
        note_display_state0("NEC98:only graph all update !!")    ;
        for( loop=0 ; loop<4 ; loop++ ){
            count = get_gvram_length()/4    ; /* compare count for dword */
            _asm
            {
                 push    esi             //save esi
                 push    edi             //save edi
                 push    ecx             //save ecx
                 mov     esi,tmpvram     //virtual vram area
                 mov     edi,tmpcopy     //gvram save area
                 mov     ecx,count       //moving 16K or 32K
                 rep     movsd           //copy gvram --> save
                 pop     ecx             //restore
                 pop     edi             //restore
                 pop     esi             //restore
            }
            tmpvram = &(tmpvram[0x8000]);
            tmpcopy = &(tmpcopy[0x8000]);
        }
                /* redraw gvram displayed area( HOST call ) */

        set_gvram_start_offset( 0 ) ;
        (*paint_screen)(0,0,0,get_offset_per_line(),get_text_lines());

    }else{

        for( loop=0 ; loop<4 ; loop++ ){
            count = get_gvram_length()/4; /* compare count for dword */
            _asm
            {
                 push  esi           //save esi
                 push  edi           //save edi
                 push  ecx           //save ecx
                 mov   esi,tmpvram   //virtual vram area
                 mov   edi,tmpcopy   //gvram save area
                 mov   ecx,count     //cmppare 16K or 32K
                 repe  cmpsd         //compare gvram --> save
                 mov   count,ecx     //save count
                 pop   ecx           //restore
                 pop   edi           //restore
                 pop   esi           //restore
            }
            if( count != 0 )break;
                tmpvram = &(tmpvram[0x8000]);
                tmpcopy = &(tmpcopy[0x8000]);
            }
            if( count == 0 ){
                host_end_update();
                return ;
            }
            init_dirty_recs();
            next = NEC98_graph_find_dirty_line(copy,vram);
            NEC98_graph_paint_dirty_rect(0,next);
    }

    NEC98GLOBS->dirty_flag = 0; /* all  update end */
    host_end_update(); /* send update end */
}


void    NEC98_text_graph_update(void)
{
    register int    loop;       /* loop counter */
    register int    count;      /* loop counter */
    register int    offset;     /* use paint offset */
    register int    next;       /* count dirty line */
    register int    ycoord;     /* y coordinate update */
    register int    width;      /* y coordinate update */
    unsigned char   *vram;   /* compare virtual vram area */
    unsigned char   *copy;   /* compare vram save area    */
    register unsigned char  *tmpvram;   /* compare virtual vram area */
    register unsigned char  *tmpcopy;   /* compare vram save area    */
    register NEC98_VRAM_COPY *txtcopy;
    BOOL     graph_not_update; /* graph is not update        */

    if(once_pal==FALSE){
        set_the_vlt(); /* host palette changed */
        once_pal=TRUE;
    }

    if( cursor_move_required ){
        set_cursorpos();
        cursor_move_required = FALSE ;
    }

    if( NEC98GLOBS->dirty_flag == 0 ) return ;   /* nothing update ! */

    vram = &get_gvram_ptr()[get_gvram_start()]; /* vram area top address */
    copy = &get_gvram_copy()[get_gvram_start()];/* vram area top address */

    host_start_update();

    if( scroll_move_required ){
        NEC98_text_line_address_set();
        scroll_move_required = FALSE ;
    }

    tmpvram = vram;
    tmpcopy = copy;

    if( NEC98GLOBS->dirty_flag > 20000L ){           /* screen refresh ! */
        note_display_state0("NEC98:text graph all update !!");

            /* gvram ---> copy data area ( GRAPHIC VRAM ) */

        for( loop=0 ; loop<4 ; loop++ ){
            count = get_gvram_length()/4; /* compare count for dword */
            _asm
            {
                push    esi          //save esi
                push    edi          //save edi
                push    ecx          //save ecx
                mov     esi,tmpvram  //virtual vram area
                mov     edi,tmpcopy  //gvram save area
                mov     ecx,count    //moving 16K or 32K
                rep     movsd        //copy gvram --> save
                pop     ecx          //restore
                pop     edi          //restore
                pop     esi          //restore
            }
            tmpvram = &tmpvram[0x8000];
            tmpcopy = &tmpcopy[0x8000];
        }
                /* tvram ---> copy data area ( TEXT VRAM ) */

        txtcopy = (NEC98_VRAM_COPY *)video_copy;
        width   = get_offset_per_line()/2 ;

        for( loop=0 ; loop<get_text_lines() ; loop++ ){
            for( count=0 ; count<width ; count++ ){
                (txtcopy+(loop*width+count))->code = *(compline[loop].codeadr+count) ;
                (txtcopy+(loop*width+count))->attr = (unsigned char)*(compline[loop].attradr+count) ;
                }
        }

                /* redraw gvram displayed area( HOST call ) */

        set_gvram_start_offset( 0 ) ;
        (*paint_screen)(0,0,0,get_offset_per_line(),get_text_lines());

    }else{

        for( loop=0 ; loop<4 ; loop++ ){
            count = get_gvram_length()/4; /* compare count for dword */
             _asm
             {
                push    esi          //save esi
                push    edi          //save edi
                push    ecx          //save ecx
                mov     esi,tmpvram  //virtual vram area
                mov     edi,tmpcopy  //gvram save area
                mov     ecx,count    //cmppare 16K or 32K
                repe    cmpsd        //compare gvram <-> save area
                mov     count,ecx    //save count
                pop     ecx          //restore
                pop     edi          //restore
                pop     esi          //restore
            }
            if( count != 0 )break;
            tmpvram = &(tmpvram[0x8000]);
            tmpcopy = &(tmpcopy[0x8000]);
        }
        if(count==0){
            init_dirty_recs();
            next = NEC98_text_find_dirty_line();
            if(next) NEC98_text_graph_paint_dirty_rect2(0,next);
        }else{
            init_dirty_recs();
            next = NEC98_text_graph_find_dirty_line(copy,vram);
            if(next) NEC98_text_graph_paint_dirty_rect1(0,next);
        }
    }

    NEC98GLOBS->dirty_flag = 0; /* all  update end */
    host_end_update(); /* send update end */
}


int     NEC98_graph_find_dirty_line(copy,vram)

        unsigned char   *copy;       /* gvram save area start address        */
        unsigned char   *vram;       /* virtual gvram area start address */
{
    register unsigned char  *tmpcopy;      /* for use data compare */
    register unsigned char  *tmpvram;      /* for use data compare */

    int nl;       /* loop counter( number byte left)      */
    int nr;       /* loop counter( number byte right)     */
    register int  count;       /* loop counter( outer loop )           */
    register int  ycoord;       /* line counter( y coordinate )         */
    register int  block;       /* next vram data blok(text size)       */
    register int  width;       /* next vram data scan line                     */
    int txtnxt;       /* change text vram address  */
    int txtoff;       /* tvram offset  */
    int line;       /* screen per line ( text line )        */

    width = get_gvram_width(); /* GVARM line size (80 bytes) */
    block = width*get_line_per_char(); /* Text  1Line = Graph ? lines */
    txtnxt  = get_offset_per_line(); /* next text address */
    line    = get_text_lines();

    for(count=0 ;count<line ; count++ ){
        tmpvram = &vram[block*count] ;
        tmpcopy = &copy[block*count] ;
        ycoord  = get_char_height() * count ;
        txtoff  = txtnxt * count ;
        if( NEC98_graph_find_both_side(tmpcopy,tmpvram,&nl,&nr) == 0 ){
            add_dirty_rec(ycoord,nl<<1,(nr<<1)-(nl<<1)+2,txtoff);
        }
    }
    return( get_dirty_rec_total() );
}


void    NEC98_graph_paint_dirty_rect(start_rect,end_rect)
        int             start_rect;
        int             end_rect;
{
    register int i,j,k;
    register int width;
    register int length;
    register int offset;
    register unsigned char  *tmpvram;
    register unsigned char  *tmpcopy;
    unsigned char *vram;
    unsigned char *copy;

    vram  = &get_gvram_ptr()[get_gvram_start()];/* vram area top address */
    copy  = &get_gvram_copy()[get_gvram_start()];/* vram area top address */
    width = get_gvram_width();

    for ( i=start_rect ; i<end_rect ; i++ ){

        offset = get_dirty_line(i)*get_gvram_scan()+get_dirty_start(i)/2;
        set_gvram_start_offset(offset);
        (*paint_screen)( get_dirty_offset(i)+get_dirty_start(i),
                         get_dirty_start(i)*get_pix_char_width()/2,
                         get_dirty_line(i),
                         get_dirty_end(i)-get_dirty_start(i),
                         1 );

        length  = (get_dirty_end(i)-get_dirty_start(i))/2 ;
        for( j=0 ; j<get_line_per_char() ; j++ ){
              for( k=0 ; k<length ; k++ ){
                   tmpcopy = &copy[offset+width*j+k] ;
                   tmpvram = &vram[offset+width*j+k] ;
                   *(tmpcopy) = *(tmpvram);  /* plane3 copy */
                   *(tmpcopy+0x08000) = *(tmpvram+0x08000) ;/* plane0 copy */
                   *(tmpcopy+0x10000) = *(tmpvram+0x10000) ;/* plane1 copy */
                   *(tmpcopy+0x18000) = *(tmpvram+0x18000) ;/* plane2 copy */
             }
        }
   }
}


int     NEC98_graph_find_both_side(copy,vram,offl,offr)

        unsigned char   *copy;       /* gvram save area start address        */
        unsigned char   *vram;       /* virtual gvram area start address */
        int *offl   ;   /* find left  side */
        int *offr   ;   /* find right side */
{
    register unsigned char *tmpcopy ;       /* for use data compare */
    register unsigned char *tmpvram ;       /* for use data compare */
    register int    width;       /* next vram data scan line   */
    register int    comp;       /* compare flag  0:NOT EQ 1:EQ          */
    register int    nl;       /* loop counter( number byte left )     */
    register int    nr;       /* loop counter( number byte right)     */
    register int    i;       /* loop counter( 0 -> char height ) */

    width = get_gvram_width() ; /* GVARM line size (80 bytes) */

    for( nl=0; nl<width; nl++ )     {
        for( i=0,comp=1;i<get_line_per_char();i++,comp=1 ){
            tmpcopy = &copy[nl+(width*i)];
            tmpvram = &vram[nl+(width*i)];
            if(*tmpcopy != *tmpvram ) break ; /* plane3 compare */
            if(*(tmpcopy+0x08000) != *(tmpvram+0x08000)) break ; /* plane0 compare */
            if(*(tmpcopy+0x10000) != *(tmpvram+0x10000)) break ; /* plane1 compare */
            if(*(tmpcopy+0x18000) != *(tmpvram+0x18000)) break ; /* plane2 compare */
                comp=0 ;
        }
        if(comp==1){    /* not equal data found search right side */
            for( nr=width-1 ; nr>(-1) ; nr-- ){
                for( i=0,comp=1;i<get_line_per_char();i++,comp=1 ){
                    tmpcopy = &copy[nr+(width*i)] ;
                    tmpvram = &vram[nr+(width*i)] ;
                    if(*tmpcopy != *tmpvram) break ; /* plane3 compare */
                    if(*(tmpcopy+0x08000) != *(tmpvram+0x08000)) break ; /* plane0 compare */
                    if(*(tmpcopy+0x10000) != *(tmpvram+0x10000)) break ; /* plane1 compare */
                    if(*(tmpcopy+0x18000) != *(tmpvram+0x18000)) break ; /* plane2 compare */
                    comp = 0;
                 }
                 if(comp==1){    /* not equal data found search right side */
                     *offl = nl ;
                     *offr = nr ;
                     return(0)  ;
                }
            }
        }
    }
    return(-1);
}


int     NEC98_text_graph_find_dirty_line(copy,vram)

        unsigned char   *copy;    /* gvram save area start address        */
        unsigned char   *vram;    /* virtual gvram area start address */
{
    register unsigned char  *tmpcopy;      /* for use data compare */
    register unsigned char  *tmpvram;      /* for use data compare */
    register NEC98_VRAM_COPY *tmptext;      /* for use data compare */
    register unsigned short *tmpcode ;      /* for use data compare */
    register unsigned short *tmpattr ;      /* for use data compare */

    int nl;       /* loop counter( number byte left)      */
    int nr;       /* loop counter( number byte right)     */
    register int    count;     /* loop counter( outer loop )           */
    register int    ycoord;    /* line counter( y coordinate )         */
    register int    block;     /* next vram data blok(text size)       */
    register int    width;     /* next vram data scan line             */
    int txtnxt;       /* change text vram address                     */
    int txtoff;       /* tvram offset                                         */
    int line;       /* screen per line ( text line )        */
    int comp;       /* screen per line ( text line )        */

    width   = get_gvram_width(); /* GVARM line size (80 bytes) */
    block   = width*get_line_per_char(); /* Text  1Line = Graph ? lines */
    txtnxt  = get_offset_per_line(); /* next text address */
    line    = get_text_lines();

    for(count=0 ;count<line ; count++ ){
        tmpcopy = &copy[block*count]  ;
        tmpvram = &vram[block*count]  ;
        tmptext = (NEC98_VRAM_COPY *)(&video_copy[get_offset_per_line()*count/2]);
        tmpcode = compline[count].codeadr ;
        tmpattr = compline[count].attradr ;
        ycoord  = get_char_height()*count ;
        txtoff  = txtnxt * count ;

        if( NEC98_text_graph_find_both_side(tmpcopy,tmpvram,tmptext,tmpcode,tmpattr,&nl,&nr)){
            add_dirty_rec(ycoord,nl<<1,(nr<<1)-(nl<<1)+2,txtoff);
        }
    }
    return( get_dirty_rec_total() );
}


int     NEC98_text_graph_find_both_side(copy,vram,text,code,attr,offl,offr)

    unsigned char   *copy;       /* gvram save area start address        */
    unsigned char   *vram;       /* virtual gvram area start address */
    NEC98_VRAM_COPY  *text;       /* for use data compare */
    unsigned short  *code;       /* for use data compare */
    unsigned short  *attr;       /* for use data compare */
    int *offl;   /* find left  side */
    int *offr;   /* find right side */
{
    register unsigned char  *tmpcopy  ;     /* for use data compare */
    register unsigned char  *tmpvram  ;     /* for use data compare */
    register NEC98_VRAM_COPY *tmptext  ;     /* for use data compare */
    register unsigned short *tmpcode  ; /* for use data compare     */
    register unsigned short *tmpattr  ; /* for use data compare     */

    register int    width;      /* next vram data scan line   */
    register int    comp;      /* compare flag  0:NOT EQ 1:EQ */
    register int    nl;      /* loop counter( number byte left )     */
    register int    nr;      /* loop counter( number byte right)     */
    register int    i,j;      /* loop counter( 0 -> char height ) */

        width   = get_gvram_width() ; /* GVARM line size (80 bytes) */

        for( nl=0 ; nl<width ; ){

                tmpcopy = &copy[nl];
                tmpvram = &vram[nl];
                tmptext = &text[nl];
                tmpcode = &code[nl];
                tmpattr = &attr[nl];

                if(((*tmpcode&0xFF00)==0)||(nl==width-1)){
                        /* code = ANK or last Kanji char then check 1block */
                        comp = NEC98_check_ank_char_size
                               (tmpcopy,tmpvram,tmptext,tmpcode,tmpattr);
                        if(comp==0){
                                nl++ ;
                        }else{
                                nr=nl ;
                        }
                }else{
                        /* code = Kanji char then check 2 block */
                        comp = NEC98_check_kanji_char_size(
                                                (unsigned short*)tmpcopy,
                                                (unsigned short*)tmpvram,
                                                 tmptext,tmpcode,tmpattr);
                        if(comp==0){
                                nl+=2;
                        }else{
                                nr=nl+1;
                        }
                }
                if(comp==1){    /* not equal data found search right side */
                        for( j=nr+1 ; j<width ; ){
                                tmpcopy = &copy[j];
                                tmpvram = &vram[j];
                                tmptext = &text[j];
                                tmpcode = &code[j];
                                tmpattr = &attr[j];
                                if(((*tmpcode&0xFF00)==0)||(j==width-1)){
                       /* code = ANK or last Kanji char then check 1block */
                                   comp = NEC98_check_ank_char_size
                                    (tmpcopy,tmpvram,tmptext,tmpcode,tmpattr);
                                   if(comp==0){ /* comp=0 all data equal */
                                           j++ ;
                                   }else{
                                           nr=j ;
                                           j++  ;
                                   }
                                }else{
                                  /* code = Kanji char then check 2 block */
                                   comp = NEC98_check_kanji_char_size(
                                                  (unsigned short*)tmpcopy,
                                                  (unsigned short*)tmpvram,
                                                  tmptext,tmpcode,tmpattr );
                                    if(comp==0){ /* comp=0 all data equal */
                                            j+=2;
                                    }else{
                                            nr=j+1;
                                            j+=2;
                                    }
                                }
                        }
                        *offl = nl ;
                        *offr = nr ;
                        return(1)  ;
                }
        }
        return(0);
}


int     NEC98_check_kanji_char_size(gcopy,gvram,text,tcode,tattr)
        unsigned short  *gcopy;       /* gvram save area start address */
        unsigned short  *gvram;       /* virtual gvram area start address */
        NEC98_VRAM_COPY  *text;       /* for use data compare */
        unsigned short  *tcode;       /* for use data compare */
        unsigned short  *tattr;       /* for use data compare */
{
        register unsigned short *tmpcopy; /* gvram save area start address */
        register unsigned short *tmpvram;/* virtual gvram area start address */
        register int    i;
        register int    width;
        register int    comp;
        width = get_gvram_width()/2 ; /* now char count --> short count */

        if( (text)->code != *tcode ) return(1);
        if( (text)->attr != (unsigned char)*tattr ) return(1);
        if( (text+1)->attr != (unsigned char)*(tattr+1))   return(1);

        for( i=0 ;i<get_line_per_char();i++ ){
                        comp=1 ;
                        tmpcopy = &gcopy[width*i] ;
                        tmpvram = &gvram[width*i] ;
                        if(*tmpcopy != *tmpvram ) break ; /* plane3 compare */
                        if(*(tmpcopy+0x04000) != *(tmpvram+0x04000)) break ; /* plane0 compare */
                        if(*(tmpcopy+0x08000) != *(tmpvram+0x08000)) break ; /* plane1 compare */
                        if(*(tmpcopy+0x0C000) != *(tmpvram+0x0C000)) break ; /* plane2 compare */
                        comp=0 ;
        }
        return(comp);
}


int     NEC98_check_ank_char_size(gcopy,gvram,text,tcode,tattr)
        unsigned char   *gcopy;     /* gvram save area start address */
        unsigned char   *gvram;     /* virtual gvram area start address */
        NEC98_VRAM_COPY  *text;      /* for use data compare */
        unsigned short  *tcode;     /* for use data compare */
        unsigned short  *tattr;     /* for use data compare */
{
        register unsigned char *tmpcopy; /* gvram save area start address */
        register unsigned char *tmpvram; /* virtual gvram area start address */
        register int    i;
        register int    width;
        register int    comp;
        width = get_gvram_width() ; /* now char count */

        if( (text)->code != *tcode )    return(1);
        if( (text)->attr != (unsigned char)*tattr )     return(1);
        for( i=0 ;i<get_line_per_char();i++ ){
                        comp=1;
                        tmpcopy = &(gcopy[width*i]) ;
                        tmpvram = &(gvram[width*i]) ;
                        if(*tmpcopy != *tmpvram ) break; /* plane3 compare */
                        if(*(tmpcopy+0x08000) != *(tmpvram+0x08000)) break ; /* plane0 compare */
                        if(*(tmpcopy+0x10000) != *(tmpvram+0x10000)) break ; /* plane1 compare */
                        if(*(tmpcopy+0x18000) != *(tmpvram+0x18000)) break ; /* plane2 compare */
                        comp=0 ;
        }
        return(comp);
}


void    NEC98_text_graph_paint_dirty_rect1(start_rect,end_rect)
        int             start_rect;
        int             end_rect;
{
        register int i,j,k   ;
        register int width   ;
        register int length  ;
        register int offset  ;
        register int txtline ;

        register unsigned char  *tmpvram;
        register unsigned char  *tmpcopy;
        register NEC98_VRAM_COPY *tmptext;
        register unsigned short *tmpcode;
        register unsigned short *tmpattr;

        unsigned char *vram   ;
        unsigned char *copy   ;
        register NEC98_VRAM_COPY *text   ;
        register unsigned short *tcode  ;
        register unsigned short *tattr  ;

        vram = &get_gvram_ptr()[get_gvram_start()]; /* vram area top address */
        copy = &get_gvram_copy()[get_gvram_start()];/* vram area top address */
        text = (NEC98_VRAM_COPY *)video_copy ;
        width = get_gvram_width()       ;

        for ( i=start_rect ; i<end_rect ; i++ ){

                offset = (get_dirty_line(i)*get_gvram_scan())+(get_dirty_start(i)/2);
                set_gvram_start_offset(offset);
                (*paint_screen)( get_dirty_offset(i)+get_dirty_start(i),
                                                 get_dirty_start(i)*get_pix_char_width()/2,
                                                 get_dirty_line(i),
                                                 get_dirty_end(i)-get_dirty_start(i),
                                                 1 );

                length  = (get_dirty_end(i)-get_dirty_start(i))/2 ;
                for( j=0 ; j<get_line_per_char() ; j++ ){
                        for( k=0 ; k<length ; k++ ){
                                tmpcopy = &copy[offset+width*j+k] ;
                                tmpvram = &vram[offset+width*j+k] ;
                                *(tmpcopy) = *(tmpvram); /* plane3 copy */
                                *(tmpcopy+0x08000) = *(tmpvram+0x08000) ;/* plane0 copy */
                                *(tmpcopy+0x10000) = *(tmpvram+0x10000) ;/* plane1 copy */
                                *(tmpcopy+0x18000) = *(tmpvram+0x18000) ;/* plane2 copy */
                        }
                }

                txtline = (get_dirty_line(i)/get_host_char_height()) ;
                tmptext = &text[(txtline*get_offset_per_line()+get_dirty_start(i))/2];
                tmpcode = &(compline[txtline].codeadr[get_dirty_start(i)/2]);
                tmpattr = &(compline[txtline].attradr[get_dirty_start(i)/2]);
                for( j=0 ; j<length ; j++ ){
                        (tmptext+j)->code = *(tmpcode+j);
                        (tmptext+j)->attr = (unsigned char)*(tmpattr+j);
                }
        }
}


int     NEC98_text_find_dirty_line(void)
{
        NEC98_VRAM_COPY *tmptext ;       /* for use data compare */
        unsigned short *tmpcode ;       /* for use data compare */
        unsigned short *tmpattr ;       /* for use data compare */

        int nl;       /* loop counter( number byte left)      */
        int nr;       /* loop counter( number byte right)     */
        int count;       /* loop counter( outer loop )           */
        int ycoord;       /* line counter( y coordinate )         */
        int txtnxt;      /* change text vram address */
        int txtoff  ;       /* tvram offset                                         */
        int line    ;       /* screen per line ( text line )        */
        int comp    ;       /* screen per line ( text line )        */

        txtnxt  = get_offset_per_line(); /* next text address */
        line    = get_text_lines();

        for(count=0 ;count<line ; count++ ){
                tmptext = (NEC98_VRAM_COPY *)(&video_copy[get_offset_per_line()*count/2]);
                tmpcode = compline[count].codeadr ;
                tmpattr = compline[count].attradr ;
                ycoord  = get_char_height()*count ;
                txtoff  = txtnxt * count ;

                if( NEC98_text_find_both_side(tmptext,tmpcode,tmpattr,&nl,&nr)){
                        add_dirty_rec(ycoord,nl<<1,(nr<<1)-(nl<<1)+2,txtoff);
                }
        }
        return( get_dirty_rec_total() );
}


int     NEC98_text_find_both_side(tmptext,tmpcode,tmpattr,offl,offr)

        NEC98_VRAM_COPY  *tmptext        ;       /* for use data compare */
        unsigned short  *tmpcode        ;       /* for use data compare */
        unsigned short  *tmpattr        ;       /* for use data compare */
        int *offl   ;   /* find left  side */
        int *offr   ;   /* find right side */
{

        register int    width;      /* next vram data scan line */
        register int    comp;      /* compare flag  0:NOT EQ 1:EQ       */
        register int    nl;      /* loop counter( number byte left )     */
        register int    nr;      /* loop counter( number byte right)     */
        register int    i,j;      /* loop counter( 0 -> char height ) */

        comp    = 0     ;
        width   = get_gvram_width() ; /* GVARM line size (80 bytes) */
        for( nl=0 ; nl<width ; ){

                if(((*(tmpcode+nl)&0xFF00)==0)||(nl==width-1)){
                        /* code = ANK or last Kanji char then check 1block */

                        if( (tmptext+nl)->code == *(tmpcode+nl) &&
                                (tmptext+nl)->attr == (unsigned char)*(tmpattr+nl) )
                        {
                                nl++    ;
                        }else{
                                comp=1  ;
                                nr=nl   ;
                        }
                }else{
                        /* code = Kanji char then check 2 block */

                        if( (tmptext+nl)->code  == *(tmpcode+nl) &&
                                (tmptext+nl)->attr == (unsigned char)*(tmpattr+nl) &&
                                (tmptext+(nl+1))->attr  == (unsigned char)*(tmpattr+(nl+1)) )
                        {
                                nl+=2   ;
                        }else{
                                comp=1  ;
                                nr=nl+1 ;
                        }
                }
                if(comp==1){    /* not equal data found search right side */
                        for( j=nr+1 ; j<width ; ){
                                if(((*(tmpcode+j)&0xFF00)==0)||(j==width-1)){
                                        /* code = ANK or last Kanji char then check 1block */
                                        if( (tmptext+j)->code != *(tmpcode+j) ||
                                                (tmptext+j)->attr != (unsigned char)*(tmpattr+j) )
                                        {
                                                nr=j    ;
                                        }
                                        j++     ;
                                }else{
                                        /* code = Kanji char then check 2 block */
                                        if( (tmptext+j)->code           != *(tmpcode+j) ||
                                                (tmptext+j)->attr               != (unsigned char)*(tmpattr+j) ||
                                                (tmptext+(j+1))->attr   != (unsigned char)*(tmpattr+(j+1)) )
                                        {
                                                nr=j+1;
                                        }
                                        j+=2;
                                }
                        }
                        *offl = nl ;
                        *offr = nr ;
                        return(1)  ;
                }
        }
        return(0);
}


void    NEC98_text_graph_paint_dirty_rect2(start_rect,end_rect)
        int             start_rect;
        int             end_rect;
{
        register int i,j;
        register int length;
        register int offset;
        register int txtline;

        register NEC98_VRAM_COPY *text   ;
        register NEC98_VRAM_COPY *tmptext;
        register unsigned short *tmpcode;
        register unsigned short *tmpattr;

        text = (NEC98_VRAM_COPY *)video_copy ;

        for ( i=start_rect ; i<end_rect ; i++ ){

                offset = (get_dirty_line(i)*get_gvram_scan())+(get_dirty_start(i)/2);
                set_gvram_start_offset(offset);
                (*paint_screen)( get_dirty_offset(i)+get_dirty_start(i),
                                                 get_dirty_start(i)*get_pix_char_width()/2,
                                                 get_dirty_line(i),
                                                 get_dirty_end(i)-get_dirty_start(i),
                                                 1 );

                length  = (get_dirty_end(i)-get_dirty_start(i))/2 ;
                txtline = (get_dirty_line(i)/get_host_char_height()) ;
                tmptext = &text[(txtline*get_offset_per_line()+get_dirty_start(i))/2];
                tmpcode = &(compline[txtline].codeadr[get_dirty_start(i)/2]);
                tmpattr = &(compline[txtline].attradr[get_dirty_start(i)/2]);
                for( j=0 ; j<length ; j++ ){
                        (tmptext+j)->code = *(tmpcode+j);
                        (tmptext+j)->attr = (unsigned char)*(tmpattr+j);
                }
        }
}


void    NEC98_text_paint_dirty_rect(start_rect,end_rect)
        int             start_rect;
        int             end_rect;
{
        register int i,j             ;
        register int length  ;
        register int txtline ;

        register NEC98_VRAM_COPY *text   ;
        register NEC98_VRAM_COPY *tmptext;
        register unsigned short *tmpcode;
        register unsigned short *tmpattr;

        text = (NEC98_VRAM_COPY *)video_copy ;

        for ( i=start_rect ; i<end_rect ; i++ ){

                (*paint_screen)( get_dirty_offset(i)+get_dirty_start(i),
                                                 get_dirty_start(i)*get_pix_char_width()/2,
                                                 get_dirty_line(i),
                                                 get_dirty_end(i)-get_dirty_start(i),
                                                 1 );

                length  = (get_dirty_end(i)-get_dirty_start(i))/2 ;
                txtline = (get_dirty_line(i)/get_host_char_height()) ;
                tmptext = &text[(txtline*get_offset_per_line()+get_dirty_start(i))/2];
                tmpcode = &(compline[txtline].codeadr[get_dirty_start(i)/2]);
                tmpattr = &(compline[txtline].attradr[get_dirty_start(i)/2]);
                for( j=0 ; j<length ; j++ ){
                        (tmptext+j)->code = *(tmpcode+j);
                        (tmptext+j)->attr = (unsigned char)*(tmpattr+j);
                }
        }
}
#endif  //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\ggdc.c ===
#if defined(NEC_98)

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::    NEC98 Graphic Emulation Routine    :::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#include "insignia.h"
#include "host_def.h"
#include "xt.h"
#include "ios.h"
#include "ica.h"
#include "gvi.h"
#include "gmi.h"
#include "debug.h"
#include "gfx_upd.h"
#include "egacpu.h"
#include "ggdc.h"
#include "tgdc.h"


void    (*ggdc_param_out )(half_word);
void    (*ggdc_data_in   )(half_word*);
void    (*palette_A8H_out)(half_word);
void    (*palette_AAH_out)(half_word);
void    (*palette_ACH_out)(half_word);
void    (*palette_AEH_out)(half_word);
void    (*ggdc_texte_com )(void);
void    NEC98_graph_init(void);
void    NEC98_graph_post(void);
void    NEC98_graph_outb(io_addr,half_word);
void    NEC98_graph_inb(io_addr,half_word*);
void    mode_ff2_out(half_word);
void    vram_disp_out(half_word);
void    vram_draw_out(half_word);
void    set_palette8_37(half_word);
void    set_palette8_15(half_word);
void    set_palette8_26(half_word);
void    set_palette8_04(half_word);
void    set_palette8_data(unsigned char,unsigned char,unsigned char,half_word);
void    set_palette16_index(half_word);
void    set_palette16_green(half_word);
void    set_palette16_red(half_word);
void    set_palette16_blue(half_word);
void    modeff_palette_change(void);
void    grcg_mode_out(half_word);
void    grcg_tile_out(half_word);
void    ggdc_command_out(half_word);
void    ggdc_status_in(half_word*);
void    ggdc_data_dummy(half_word*);
void    ggdc_param_dummy(half_word);
void    ggdc_reset_com(half_word);
void    ggdc_sync_com(half_word);
void    ggdc_sync_param(half_word);
void    ggdc_start_com(void);
void    ggdc_stop_com(void);
void    ggdc_zoom_com(void);
void    ggdc_zoom_param(half_word);
void    ggdc_scroll_com(half_word);
void    ggdc_scroll_param1(half_word);
void    ggdc_scroll_param2(half_word);
void    ggdc_scroll_param3(half_word);
void    ggdc_scroll_param4(half_word);
void    ggdc_scroll_param5(half_word);
void    ggdc_scroll_param6(half_word);
void    ggdc_scroll_param7(half_word);
void    ggdc_scroll_param8(half_word);
void    ggdc_csrform_com(void);
void    ggdc_csrform_param(half_word);
void    ggdc_pitch_com(void);
void    ggdc_pitch_param(half_word);
void    ggdc_vectw_com(void);
void    ggdc_vectw_param(half_word);
void    ggdc_textw_com(half_word);
void    ggdc_textw_param1(half_word);
void    ggdc_textw_param2(half_word);
void    ggdc_textw_param3(half_word);
void    ggdc_textw_param4(half_word);
void    ggdc_textw_param5(half_word);
void    ggdc_textw_param6(half_word);
void    ggdc_textw_param7(half_word);
void    ggdc_textw_param8(half_word);
void    ggdc_csrw_com(void);
void    ggdc_csrw_param(half_word);
void    ggdc_csrr_com(void);
void    ggdc_csrr_data1(half_word*);
void    ggdc_csrr_data2(half_word*);
void    ggdc_csrr_data3(half_word*);
void    ggdc_csrr_data4(half_word*);
void    ggdc_csrr_data5(half_word*);
void    ggdc_mask_com(void);
void    ggdc_mask_param(half_word);
void    ggdc_write_com(half_word);
void    ggdc_write_word_low(half_word);
void    ggdc_write_word_high(half_word);
void    ggdc_write_byte_low(half_word);
void    ggdc_write_byte_high(half_word);
void    ggdc_read_com(half_word);
void    ggdc_read_word_low(half_word*);
void    ggdc_read_word_high(half_word*);
void    ggdc_read_byte_low(half_word*);
void    ggdc_read_byte_high(half_word*);
void    ggdc_draw_pixel(void);
void    ggdc_draw_line(void);
void    ggdc_draw_gchar(void);
void    ggdc_draw_circle(void);
void    ggdc_draw_rect(void);
void    ggdc_draw_slgchar(void);
void    ggdc_draw_nothing(void);
void    ggdc_init_vectw_param(void);
void    ggdc_read_back_data(void);
void    video_freeze_change(BOOL);
BOOL    host_dummy(void);
void    recalc_ggdc_draw_parameter(void);

extern  PVOID   host_NEC98_vram_init(void);
extern  void    host_NEC98_vram_change(unsigned char);
//extern  void    host_freeze(void);
extern  BOOL    hostChangeMode(void);
extern  void    set_the_vlt(void);
extern  boolean choose_NEC98_display_mode(void);
extern  boolean choose_NEC98_graph_mode(void);
extern  BOOL    video_emu_mode;
extern  unsigned char   *graph_copy;

extern  void    ggdc_send_c_asm(unsigned long *);
extern  void    ggdc_mod_select(unsigned char *);
extern  void    ggdc_drawing_line(void);
extern  void    ggdc_drawing_pixel(void);
extern  void    ggdc_drawing_arc(void);
extern  void    ggdc_drawing_rect(void);
extern  void    ggdc_drawing_text(void);
extern  void    ggdc_read_back(unsigned long *);
extern  void    ggdc_writing(unsigned short *);
extern  void    ggdc_reading(unsigned short *);

static  unsigned char   palette16change[]={
        0x00,0x10,0x20,0x30,    
        0x40,0x50,0x60,0x70,    
        0x80,0x90,0xA0,0xB0,    
        0xC0,0xD0,0xE0,0xFF             /* use 16 colors mode palette change */
};

static  unsigned char palette16init[16][3]={
        0x00,0x00,0x00,
        0x00,0x00,0x07,
        0x00,0x07,0x00,
        0x00,0x07,0x07,
        0x07,0x00,0x00,
        0x07,0x00,0x07,
        0x07,0x07,0x00,
        0x07,0x07,0x07,
        0x04,0x04,0x04,
        0x00,0x00,0x0F,
        0x00,0x0F,0x00,
        0x00,0x0F,0x0F,
        0x0F,0x00,0x00,
        0x0F,0x00,0x0F,
        0x0F,0x0F,0x00,
        0x0F,0x0F,0x0F          /* 16 colors mode palette initialize data */
};

static  unsigned char palette8index[]={ 3,1,2,0 }; /* palette NO! */

static  unsigned char   ggdc_drawing    = 0;   /* GGDC status use      */
static  unsigned char   ggdc_dataready  = 0;   /* GGDC status use      */
static  unsigned char   ggdc_flipflop   = 0;   /* GGDC status use      */
static  unsigned char   ggdc_status     = 4;   /* GGDC status use      */
static  unsigned char   *drawaddress;       /* draw address         */
static  GGDC_C_TO_ASM   drawing_data;       /* send asm struct      */
static  GGDC_CSRR_BACK  readcsrr;       /* read back data       */

STRC_GGDC_GLOBALS               ggdcglobs;
STRC_PALETTE_GLOBALS    paletteglobs;
STRC_GRCG_GLOBALS               grcgglobs;
STRC_EGC_REGS egc_regs;                                 // EGC register 940325

/*--------------------      NEC NEC98 ADD 930611     --------------------*/

void    (*ggdc_param_out )(half_word  value);
void    (*ggdc_data_in   )(half_word *value);
void    (*palette_A8H_out)(half_word  value);
void    (*palette_AAH_out)(half_word  value);
void    (*palette_ACH_out)(half_word  value);
void    (*palette_AEH_out)(half_word  value);
void    (*ggdc_texte_com )(void);
void    (*ggdc_vecte_com )(void);
BOOL    (*pif_freeze_mode)(void);

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::    NEC98 Graphic Emulation Entry     ::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void    NEC98_graph_init(void)
{
        unsigned char *gvram_offset;

        io_define_inb (GRAPHIC_ADAPTOR,NEC98_graph_inb );
        io_define_outb(GRAPHIC_ADAPTOR,NEC98_graph_outb);

        io_connect_port( GGDC_PARAMETER,GRAPHIC_ADAPTOR,IO_READ_WRITE );
        io_connect_port( GGDC_COMMAND  ,GRAPHIC_ADAPTOR,IO_READ_WRITE );
        io_connect_port( MODE_FF2          ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( VRAM_DISPLAY  ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( VRAM_DRAW     ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( PALETTE_A8    ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( PALETTE_AA    ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( PALETTE_AC    ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( PALETTE_AE    ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( GRCG_MODE     ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( GRCG_TILE     ,GRAPHIC_ADAPTOR,IO_WRITE      );

        gvram_offset = (unsigned char *)host_NEC98_vram_init();

        /*      Mapping GGDC address area       */

        NEC98GLOBS->gvram_p30_ptr  = gvram_offset;      /* palne 00 */
        NEC98GLOBS->gvram_p00_ptr  = gvram_offset + 0x00008000; /* palne 01 */
        NEC98GLOBS->gvram_p10_ptr  = gvram_offset + 0x00010000; /* palne 02 */
        NEC98GLOBS->gvram_p20_ptr  = gvram_offset + 0x00018000; /* palne 03 */
        NEC98GLOBS->gvram_p31_ptr  = gvram_offset + 0x00020000; /* palne 10 */
        NEC98GLOBS->gvram_p01_ptr  = gvram_offset + 0x00028000; /* palne 11 */
        NEC98GLOBS->gvram_p11_ptr  = gvram_offset + 0x00030000; /* palne 12 */
        NEC98GLOBS->gvram_p21_ptr  = gvram_offset + 0x00038000; /* palne 13 */

        NEC98GLOBS->gvram_p30_copy = &graph_copy[0x00000];
        NEC98GLOBS->gvram_p00_copy = &graph_copy[0x08000];
        NEC98GLOBS->gvram_p10_copy = &graph_copy[0x10000];
        NEC98GLOBS->gvram_p20_copy = &graph_copy[0x18000];
        NEC98GLOBS->gvram_p31_copy = &graph_copy[0x20000];
        NEC98GLOBS->gvram_p01_copy = &graph_copy[0x28000];
        NEC98GLOBS->gvram_p11_copy = &graph_copy[0x30000];
        NEC98GLOBS->gvram_p21_copy = &graph_copy[0x38000];
}

/*----------------------------------------------------------------------*/
void    NEC98_graph_post(void)
{

    unsigned char   loop,port_a;

/*      (1)MODE_FF2             */
                inb(0x31,&port_a);

        NEC98Display.modeff2.colorsel    = FALSE;
        NEC98Display.modeff2.regwrite    = FALSE;
        NEC98Display.modeff2.egcext      = FALSE;
        NEC98Display.modeff2.lcd1mode    = FALSE;
        NEC98Display.modeff2.lcd2mode    = FALSE;
        NEC98Display.modeff2.lsiinit     = FALSE;
        NEC98Display.modeff2.gdcclock    = (port_a&0x80) ? FALSE : TRUE;

        modeffglobs.modeff2_data[FF2_COLORSEL]  = FF2_8COLOR;
        modeffglobs.modeff2_data[FF2_REGWRITE]  = FF2_DISENB;
        modeffglobs.modeff2_data[FF2_EGCEXT]    = FF2_GRCG;
        modeffglobs.modeff2_data[FF2_LCD1MODE]  = FF2_GT1DOT;
        modeffglobs.modeff2_data[FF2_LCD2MODE]  = FF2_GR640;
        modeffglobs.modeff2_data[FF2_LSIINIT]   = FF2_INIOFF;
        modeffglobs.modeff2_data[FF2_GDCCLOCK1] = (port_a&0x80) ? FF2_GDC25_1 : FF2_GDC50_1;
        modeffglobs.modeff2_data[FF2_GDCCLOCK2] = (port_a&0x80) ? FF2_GDC25_2 : FF2_GDC50_2;

/*      (2)VRAM_SELECT  */

        NEC98GLOBS->read_bank   = FORE_BANK;
        NEC98GLOBS->select_bank = FORE_BANK;

/*      (3)PALETTE              */

        palette_A8H_out = set_palette8_37;
        palette_AAH_out = set_palette8_15;
        palette_ACH_out = set_palette8_26;
        palette_AEH_out = set_palette8_04;

        set_palette8_37(0x37);
        set_palette8_15(0x15);
        set_palette8_26(0x26);
        set_palette8_04(0x04);

        for( loop = 0 ; loop < 16 ; loop++){
                set_palette16_index(loop);
                set_palette16_green(palette16init[loop][0]);
                set_palette16_red  (palette16init[loop][1]);
                set_palette16_blue (palette16init[loop][2]);
        }
        paletteglobs.pal_16_index = 0   ;

/*      (4)GRCG                 */

        grcgglobs.grcg_mode     = 0;
        grcgglobs.grcg_count    = 0;
        grcgglobs.grcg_tile[0]  = 0;
        grcgglobs.grcg_tile[1]  = 0;
        grcgglobs.grcg_tile[2]  = 0;
        grcgglobs.grcg_tile[3]  = 0;

/*      (4-1)EGC        1994/03/25      */
        egc_regs.Reg0 = 0xFFF0;
        egc_regs.Reg1 = 0x40FF;
        egc_regs.Reg2 = 0x0CAC;
        egc_regs.Reg3 = 0x0000;
        egc_regs.Reg4 = 0xFFFF;
        egc_regs.Reg5 = 0x0000;
        egc_regs.Reg6 = 0x0000;
        egc_regs.Reg7 = 0x0000;
        egc_regs.Reg3fb = 0x0000;
        egc_regs.Reg5fb = 0x0000;


/*      (5)GRAPH GDC    */

        ggdc_drawing    = 0;
        ggdc_dataready  = 0;
        ggdc_flipflop   = 0;
        ggdc_status     = 4;
        ggdc_param_out  = ggdc_param_dummy;
        ggdc_data_in    = ggdc_data_dummy;
        ggdc_vecte_com  = ggdc_draw_nothing;
        ggdc_texte_com  = ggdc_draw_nothing;
        ggdc_init_vectw_param();

        ggdcglobs.sync_param[0] = 0x16;
        ggdcglobs.sync_param[1] = 0x26;
        ggdcglobs.sync_param[2] = 0x03;
        ggdcglobs.sync_param[3] = 0x11;
        ggdcglobs.sync_param[4] = 0x83;
        ggdcglobs.sync_param[5] = 0x07;
        ggdcglobs.sync_param[6] = 0x90;
        ggdcglobs.sync_param[7] = 0x65;

        NEC98Display.ggdcemu.vh  = FALSE;
        NEC98Display.ggdcemu.cr  = 0x26;
        NEC98Display.ggdcemu.lf  = 0x0190;

        ggdcglobs.csrform_param[0] = 0x01;
        NEC98Display.ggdcemu.lr     = 0x01;

        ggdcglobs.zoom_param      = 0x00;
        NEC98Display.ggdcemu.zw    = 0x00;

        ggdcglobs.pitch_param     = (port_a&0x80) ?   0x28 :   0x50;
        NEC98Display.ggdcemu.p     = (port_a&0x80) ? 0x0028 : 0x0050;

        ggdcglobs.scroll_param[0] = 0x00;
        ggdcglobs.scroll_param[1] = 0x00;
        ggdcglobs.scroll_param[2] = 0xF0;
        ggdcglobs.scroll_param[3] = 0x1F;
        ggdcglobs.scroll_param[4] = 0x00;
        ggdcglobs.scroll_param[5] = 0x00;
        ggdcglobs.scroll_param[6] = 0x10;
        ggdcglobs.scroll_param[7] = 0x00;

        NEC98Display.ggdcemu.sad1  = 0x0000;
        NEC98Display.ggdcemu.sl1   = 0x01FF;
        NEC98Display.ggdcemu.im1   = FALSE;
        NEC98Display.ggdcemu.sad2  = 0x0000;
        NEC98Display.ggdcemu.sl2   = 0x0001;
        NEC98Display.ggdcemu.im2   = FALSE;

        ggdcglobs.textw_param[0]  = 0x00;
        ggdcglobs.textw_param[1]  = 0x00;
        ggdcglobs.textw_param[2]  = 0x00;
        ggdcglobs.textw_param[3]  = 0x00;
        ggdcglobs.textw_param[4]  = 0x00;
        ggdcglobs.textw_param[5]  = 0x00;
        ggdcglobs.textw_param[6]  = 0x00;
        ggdcglobs.textw_param[7]  = 0x00;

        NEC98Display.ggdcemu.txt[0] = 0x00;
        NEC98Display.ggdcemu.txt[1] = 0x00;
        NEC98Display.ggdcemu.txt[2] = 0x00;
        NEC98Display.ggdcemu.txt[3] = 0x00;
        NEC98Display.ggdcemu.txt[4] = 0x00;
        NEC98Display.ggdcemu.txt[5] = 0x00;
        NEC98Display.ggdcemu.txt[6] = 0x00;
        NEC98Display.ggdcemu.txt[7] = 0x00;
        NEC98Display.ggdcemu.ptn    = 0x0000;

        ggdcglobs.write = 0x20;
        ggdcglobs.start_stop = 0x0C;
        NEC98Display.ggdcemu.mod = 0x00;

        drawaddress = NEC98GLOBS->gvram_p30_ptr;
        NEC98Display.gvram_copy = NEC98GLOBS->gvram_p30_copy;
        NEC98Display.gvram_ptr  = NEC98GLOBS->gvram_p30_ptr;
        if( video_emu_mode ){
                modeff_palette_change();
/*                      choose_NEC98_display_mode();             del 900828 check */
        }
}
/*----------------------------------------------------------------------*/

void    NEC98_graph_outb(io_addr port, half_word value)
{
        switch(port) {
                case MODE_FF2:
                        mode_ff2_out(value);
                        break;
                case GGDC_PARAMETER:
                        (*ggdc_param_out)(value);
                        pif_freeze_mode();
                        break;
                case GGDC_COMMAND:
                        ggdc_command_out(value);
                        pif_freeze_mode();
                        break;
                case VRAM_DISPLAY:
                        vram_disp_out(value);
                        break;
                case VRAM_DRAW:
                        vram_draw_out(value);
                        break;
                case PALETTE_A8:
                        (*palette_A8H_out)(value);
                        break;
                case PALETTE_AA:
                        (*palette_AAH_out)(value);
                        break;
                case PALETTE_AC:
                        (*palette_ACH_out)(value);
                        break;
                case PALETTE_AE:
                        (*palette_AEH_out)(value);
                        break;
                case GRCG_MODE:
                        grcg_mode_out(value);
                        pif_freeze_mode();
                        break;
                case GRCG_TILE:
                        grcg_tile_out(value);
                        pif_freeze_mode();
                        break;
                case EGC_ACTIVE :
                case EGC_MODE   :
                case EGC_ROP    :
                case EGC_FORE   :
                case EGC_MASK   :
                case EGC_BACK   :
                case EGC_BITAD  :
                case EGC_LENGTH :
                        //host_freeze();
                        hostModeChange();
                        break;
                default:
                        assert1(FALSE,"unkown NEC98 graphic out port %x",port);
        }
}

/*----------------------------------------------------------------------*/

void    NEC98_graph_inb(io_addr port, half_word *value)
{
        switch(port) {
                case GGDC_PARAMETER:
                        ggdc_status_in(value);
                        break;
                case GGDC_COMMAND:
                        (*ggdc_data_in)(value);
                        break;
                default:
                        assert1(FALSE,"unkown NEC98 graphic in port %x",port);
        }
}

/*----------------------------------------------------------------------*/
void    video_freeze_change(BOOL pifmode)
{
        if(pifmode){
                pif_freeze_mode = host_dummy            ; /* select dummy logic */
        }else{
//              pif_freeze_mode = host_freeze           ; /* freeze 98 emulator */
                pif_freeze_mode = hostModeChange        ; /* Change to Full-Screen Mode */
        }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::    NEC98 Emulation mode FF2     ::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void    mode_ff2_out(half_word value)
{
        switch( value ){
                case FF2_8COLOR :
                case FF2_16COLOR:
                        NEC98Display.modeff2.colorsel = (value&1) ? TRUE:FALSE ;
                        modeffglobs.modeff2_data[FF2_COLORSEL] = value ;
                        modeff_palette_change() ;
                        break;
                case FF2_DISENB :
                case FF2_ENABLE :
                        NEC98Display.modeff2.regwrite = (value&1) ? TRUE:FALSE ;
                        modeffglobs.modeff2_data[FF2_REGWRITE] = value ;
                        break;
                case FF2_GT1DOT :
                case FF2_GTEQ   :
                        NEC98Display.modeff2.lcd1mode = (value&1) ? TRUE:FALSE ;
                        modeffglobs.modeff2_data[FF2_LCD1MODE] = value ;
                        break;
                case FF2_GR640  :
                case FF2_GR641  :
                        NEC98Display.modeff2.lcd2mode = (value&1) ? TRUE:FALSE ;
                        modeffglobs.modeff2_data[FF2_LCD2MODE] = value ;
                        break;
                case FF2_INIOFF :
                case FF2_INION  :
                        NEC98Display.modeff2.lsiinit = (value&1) ? TRUE:FALSE ;
                        modeffglobs.modeff2_data[FF2_LSIINIT] = value ;
                        break;
                case FF2_GDC25_1:
                        NEC98Display.modeff2.gdcclock = FALSE ;
                        modeffglobs.modeff2_data[FF2_GDCCLOCK1] = value ;
                        break;
                case FF2_GDC25_2:
                        NEC98Display.modeff2.gdcclock = FALSE ;
                        modeffglobs.modeff2_data[FF2_GDCCLOCK2] = value ;
                        break;
                case FF2_GDC50_1:
                        modeffglobs.modeff2_data[FF2_GDCCLOCK1] = value ;
                        if(modeffglobs.modeff2_data[FF2_GDCCLOCK2]==FF2_GDC50_2){
                                NEC98Display.modeff2.gdcclock = TRUE     ;
                        }else{
                                NEC98Display.modeff2.gdcclock = FALSE;
                        }
                        break;
                case FF2_GDC50_2:
                        modeffglobs.modeff2_data[FF2_GDCCLOCK2] = value ;
                        if(modeffglobs.modeff2_data[FF2_GDCCLOCK1]==FF2_GDC50_1){
                                NEC98Display.modeff2.gdcclock = TRUE     ;
                        }else{
                                NEC98Display.modeff2.gdcclock = FALSE;
                        }
                        break;
                default :
                        if( NEC98Display.modeff2.regwrite ){
                                switch( value ){
                                        case FF2_GRCG   :
                                        case FF2_EGC    :
                                                NEC98Display.modeff2.egcext
                                                        = (value&1) ? TRUE:FALSE ;
                                                modeffglobs.modeff2_data[FF2_EGCEXT] = value ;
                                                break;
                                        default :
                                                assert1(FALSE,"unkown mode FF2 value = %x",value);
                                }
                        }else{
                                switch( value ){
                                        case FF2_GRCG   :
                                        case FF2_EGC    :
                                                assert1(FALSE,"DISNABLE FF2 EGC MODE = %x",value);
                                        default :
                                                assert1(FALSE,"unkown mode FF2 value = %x",value);
                                }
                        }
        }
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::  NEC98 Emulation VRAM select reg   :::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void    vram_disp_out(half_word value)
{
        switch( value ){
                case FORE_BANK:
                        NEC98GLOBS->read_bank = value ;
                        if( video_emu_mode ){
                                set_mode_change_required(TRUE);
                        }
                        break;
                case BACK_BANK:
                        NEC98GLOBS->read_bank = value ;
                        if( video_emu_mode ){
                                set_mode_change_required(TRUE);
                        }
                        break;
                default :
                        assert1(FALSE,"unkown vram disp bank select value %x",value);
        }
}

/*----------------------------------------------------------------------*/

void    vram_draw_out(half_word value)
{
        switch( value ){
                case FORE_BANK:
                        NEC98GLOBS->select_bank = value;
                        host_NEC98_vram_change(value);
                        drawaddress = NEC98GLOBS->gvram_p30_ptr;
                        break;
                case BACK_BANK:
                        NEC98GLOBS->select_bank = value;
                        host_NEC98_vram_change(value);
                        drawaddress = NEC98GLOBS->gvram_p31_ptr;
                        break;
                default :
                        assert1(FALSE,"unkown vram draw bank select value %x",value);
        }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::      NEC98 Emulation palette       :::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

/*:::::::::::::::::::           8 colors mode           ::::::::::::::::::::::::*/

void set_palette8_37(half_word value){ set_palette8_data(0,3,7,value); }
void set_palette8_15(half_word value){ set_palette8_data(1,1,5,value); }
void set_palette8_26(half_word value){ set_palette8_data(2,2,6,value); }
void set_palette8_04(half_word value){ set_palette8_data(3,0,4,value); }

/*----------------------------------------------------------------------*/

void set_palette8_data( unsigned char   portno , 
                        unsigned char   regno1 ,
                        unsigned char   regno2 ,
                        half_word       value  )
{
        unsigned char   palBL ;         /* palette exchange BLUE (BIT 0) */
        unsigned char   palRL ;         /* palette exchange RED  (BIT 1) */
        unsigned char   palGL ;         /* palette exchange GREEN(BIT 2) */
        unsigned char   palBH ;         /* palette exchange BLUE (BIT 4) */
        unsigned char   palRH ;         /* palette exchange RED  (BIT 5) */
        unsigned char   palGH ;         /* palette exchange GREEN(BIT 6) */

        NEC98Display.palette.flag = TRUE ;                /* palette changed */
        paletteglobs.pal_8_data[portno] = value ; /* save port A8,AA,AC,AEH */

        if(NEC98Display.modeff.graphmode){        /* TRUE  = mono  mode  */
            palBL = palRL = palGL = (value& 4) ? 0xFF:0x00 ;
            palBH = palRH = palGH = (value&64) ? 0xFF:0x00 ;
        }else{                                                   /* FALSE = color mode  */
            palBL = (value& 1) ? 0xFF:0x00 ;
            palRL = (value& 2) ? 0xFF:0x00 ;
            palGL = (value& 4) ? 0xFF:0x00 ;
            palBH = (value&16) ? 0xFF:0x00 ;
            palRH = (value&32) ? 0xFF:0x00 ;
            palGH = (value&64) ? 0xFF:0x00 ;
        }

        /* set new palette data --> UPDATE Logic --> HOST */

        NEC98Display.palette.data[regno2+8].peBlue       = (BYTE)palBL;
        NEC98Display.palette.data[regno2+8].peGreen      = (BYTE)palGL;
        NEC98Display.palette.data[regno2+8].peRed        = (BYTE)palRL;
        NEC98Display.palette.data[regno2+8].peFlags      = (BYTE)0x00 ;

        NEC98Display.palette.data[regno2  ].peBlue       = (BYTE)palBL;
        NEC98Display.palette.data[regno2  ].peGreen      = (BYTE)palGL;
        NEC98Display.palette.data[regno2  ].peRed        = (BYTE)palRL;
        NEC98Display.palette.data[regno2  ].peFlags      = (BYTE)0x00 ;

        NEC98Display.palette.data[regno1+8].peBlue       = (BYTE)palBH;
        NEC98Display.palette.data[regno1+8].peGreen      = (BYTE)palGH;
        NEC98Display.palette.data[regno1+8].peRed        = (BYTE)palRH;
        NEC98Display.palette.data[regno1+8].peFlags      = (BYTE)0x00 ;

        NEC98Display.palette.data[regno1  ].peBlue       = (BYTE)palBH;
        NEC98Display.palette.data[regno1  ].peGreen      = (BYTE)palGH;
        NEC98Display.palette.data[regno1  ].peRed        = (BYTE)palRH;
        NEC98Display.palette.data[regno1  ].peFlags      = (BYTE)0x00;
}

/*:::::::::::::::::::           16 colors mode          ::::::::::::::::::::::::*/

void set_palette16_index(half_word value)
{
        if( value >= 0 && value <= 0x0F ){
                paletteglobs.pal_16_index = value ;     /* save last palette index */
                NEC98Display.palette.data[value].peFlags = 0x00 ;
        }else{  
                assert1(FALSE,"16 color palette index value miss !!! %x",value);
        }
}

/*----------------------------------------------------------------------*/

void set_palette16_green(half_word value)
{
        if(  value >= 0 && value <= 0x0F ){
                NEC98Display.palette.flag = TRUE ;               /* palette changed */
                paletteglobs.pal_16_data[paletteglobs.pal_16_index][NEC98PALG]
                        = value ;
                if(NEC98Display.modeff.graphmode){       /* TRUE  = mono  mode  */
                        NEC98Display.palette.data[paletteglobs.pal_16_index].peBlue      =
                        NEC98Display.palette.data[paletteglobs.pal_16_index].peGreen     =
                        NEC98Display.palette.data[paletteglobs.pal_16_index].peRed       =
                                (value&8) ? (BYTE)0xFF : (BYTE)0x00 ;
                }else{                                       /* FALSE = color mode  */
                        NEC98Display.palette.data[paletteglobs.pal_16_index].peGreen =
                                (BYTE)(palette16change[value]) ;
                }
        }else{
                assert1(FALSE,"16 color palette green value miss !!! %x",value);
        }
}

/*----------------------------------------------------------------------*/

void set_palette16_red(half_word value)
{
        if(  value >= 0 && value <= 0x0F  ){
                paletteglobs.pal_16_data[paletteglobs.pal_16_index][NEC98PALR]
                        = value ;
                if(!NEC98Display.modeff.graphmode){       /* TRUE  = color mode  */
                        NEC98Display.palette.flag = TRUE ;               /* palette changed */
                        NEC98Display.palette.data[paletteglobs.pal_16_index].peRed
                                = (BYTE)(palette16change[value]) ;
                }
        }else{
                assert1(FALSE,"16 color palette red value miss !!! %x",value);
        }
}

/*----------------------------------------------------------------------*/

void set_palette16_blue(half_word value)
{
        if(  value >= 0 && value <= 0x0F  ){
                paletteglobs.pal_16_data[paletteglobs.pal_16_index][NEC98PALB]
                        = value ;
                if(!NEC98Display.modeff.graphmode){       /* TRUE  = color mode  */
                        NEC98Display.palette.flag = TRUE ;               /* palette changed */
                        NEC98Display.palette.data[paletteglobs.pal_16_index].peBlue
                                = (BYTE)(palette16change[value]) ;
                }
        }else{
                assert1(FALSE,"16 color palette blue value miss !!! %x",value);
        }
}

/*----------------------------------------------------------------------*/

void modeff_palette_change(void)
{
        unsigned char loop      ;       /* work for loop counter        */
        unsigned char index     ;       /* work for 8 palette index */
        NEC98Display.palette.flag = TRUE ;                /* palette changed */
        if(NEC98Display.modeff2.colorsel){       /* 16 color mode */
            palette_A8H_out = set_palette16_index ;
            palette_AAH_out = set_palette16_green ;
            palette_ACH_out = set_palette16_red   ;
            palette_AEH_out = set_palette16_blue  ;

            if(NEC98Display.modeff.graphmode){       /* mono mode */
                for( loop=0 ; loop<16 ; loop++ ){
                     NEC98Display.palette.data[loop].peBlue   =
                     NEC98Display.palette.data[loop].peGreen  =
                     NEC98Display.palette.data[loop].peRed    =
                         (paletteglobs.pal_16_data[loop][NEC98PALG]&8) ? (BYTE)0xFF : (BYTE)0x00 ;
                     NEC98Display.palette.data[loop].peFlags=(BYTE)0x00;
                }
            }else{                                                          /* color mode */
                for( loop=0 ; loop<16 ; loop++ ){
                        NEC98Display.palette.data[loop].peBlue=
                                (BYTE)palette16change[paletteglobs.pal_16_data[loop][NEC98PALB]];
                        NEC98Display.palette.data[loop].peGreen=
                                (BYTE)palette16change[paletteglobs.pal_16_data[loop][NEC98PALG]];
                        NEC98Display.palette.data[loop].peRed=
                                (BYTE)palette16change[paletteglobs.pal_16_data[loop][NEC98PALR]];
                        NEC98Display.palette.data[loop].peFlags= (BYTE)0x00 ;
                }
            }
        }else{                                                          /*  8 color mode */

            palette_A8H_out = set_palette8_37 ;
            palette_AAH_out = set_palette8_15 ;
            palette_ACH_out = set_palette8_26 ;
            palette_AEH_out = set_palette8_04 ;

            if(NEC98Display.modeff.graphmode){       /* mono mode */
                for( loop=0 ; loop < 4 ; loop++ ){
                    index = palette8index[loop]     ;

                    NEC98Display.palette.data[index   ].peBlue       =
                    NEC98Display.palette.data[index   ].peGreen      =
                    NEC98Display.palette.data[index   ].peRed        =
                    NEC98Display.palette.data[index+ 8].peBlue       =
                    NEC98Display.palette.data[index+ 8].peGreen      =
                    NEC98Display.palette.data[index+ 8].peRed        =
                        (paletteglobs.pal_8_data[loop]&64) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index+ 4].peBlue       =
                    NEC98Display.palette.data[index+ 4].peGreen      =
                    NEC98Display.palette.data[index+ 4].peRed        =
                    NEC98Display.palette.data[index+12].peBlue       =
                    NEC98Display.palette.data[index+12].peGreen      =
                    NEC98Display.palette.data[index+12].peRed        =
                        (paletteglobs.pal_8_data[loop]& 4) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index   ].peFlags      =
                    NEC98Display.palette.data[index+ 4].peFlags      =
                    NEC98Display.palette.data[index+ 8].peFlags      =
                    NEC98Display.palette.data[index+12].peFlags      = (BYTE)0x00 ;
                }
            }else{                                                          /* color mode */
                for( loop=0 ; loop < 4 ; loop++ ){
                    index = palette8index[loop]     ;

                    NEC98Display.palette.data[index   ].peBlue       =
                    NEC98Display.palette.data[index+ 8].peBlue       =
                        (paletteglobs.pal_8_data[loop]&16) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index   ].peRed        =
                    NEC98Display.palette.data[index+ 8].peRed        =
                        (paletteglobs.pal_8_data[loop]&32) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index   ].peGreen      =
                    NEC98Display.palette.data[index+ 8].peGreen      =
                        (paletteglobs.pal_8_data[loop]&64) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index+ 4].peBlue       =
                    NEC98Display.palette.data[index+12].peBlue       =
                        (paletteglobs.pal_8_data[loop]& 1) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index+ 4].peRed        =
                    NEC98Display.palette.data[index+12].peRed        =
                        (paletteglobs.pal_8_data[loop]& 2) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index+ 4].peGreen      =
                    NEC98Display.palette.data[index+12].peGreen      =
                        (paletteglobs.pal_8_data[loop]& 4) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index   ].peFlags      =
                    NEC98Display.palette.data[index+ 4].peFlags      =
                    NEC98Display.palette.data[index+ 8].peFlags      =
                    NEC98Display.palette.data[index+12].peFlags      = (BYTE)0x00 ;
                }
            }
        }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::       NEC98 Emulation GRCG      ::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void    grcg_mode_out(half_word value)
{
        grcgglobs.grcg_mode  = value    ; 
        grcgglobs.grcg_count = 0                ; /* GRCG Tile count clear */
        if( video_emu_mode ){
            if(value&0x80){
                //host_freeze();
                hostModeChange();
            }
        }
}

void    grcg_tile_out(half_word value)
{
        switch(grcgglobs.grcg_count){
                case 0:
                        grcgglobs.grcg_tile[0] = value ;
                        grcgglobs.grcg_count++;
                        break;
                case 1:
                        grcgglobs.grcg_tile[1] = value ;
                        grcgglobs.grcg_count++;
                        break;
                case 2:
                        grcgglobs.grcg_tile[2] = value ;
                        grcgglobs.grcg_count++;
                        break;
                case 3:
                        grcgglobs.grcg_tile[3] = value ;
                        grcgglobs.grcg_count=0;
                        break;
                default:
                        assert1(FALSE,"GRCG TILE-REG count miss !!! %d",value);
        }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::    NEC98 Emulation Graph-GDC    ::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void    ggdc_command_out(half_word value)
{
        ggdc_param_out  = ggdc_param_dummy      ; /* clear param out */
        ggdc_data_in    = ggdc_data_dummy       ; /* clear param in  */

        switch(value) {
                case GGDC_RESET1:
                case GGDC_RESET2:
                case GGDC_RESET3:
                        ggdc_reset_com(value);
                        break;
                case GGDC_SYNC_OFF:
                case GGDC_SYNC_ON :
                        ggdc_sync_com(value);
                        ggdcglobs.ggdc_now.command = value ; /* last ggdc command */
                        ggdcglobs.ggdc_now.count   = 0     ; /* ggdc param count  */
                case GGDC_SLAVE :
                case GGDC_MASTER:
                        break;                          /* G-GDC must drive slave mode !!! */
                case GGDC_START1:
                case GGDC_START2:
                        ggdc_start_com();
                        ggdcglobs.ggdc_now.command = value ;
                        ggdcglobs.ggdc_now.count   = 0     ;
                        break;
                case GGDC_STOP1:
                case GGDC_STOP2:
                        ggdc_stop_com();
                        ggdcglobs.ggdc_now.command = value ;
                        ggdcglobs.ggdc_now.count   = 0     ;
                        break;
                case GGDC_ZOOM:
                        ggdc_zoom_com();
                        ggdcglobs.ggdc_now.command = value ;
                        ggdcglobs.ggdc_now.count   = 0     ;
                        break;
                case GGDC_SCROLL1:
                case GGDC_SCROLL2:
                case GGDC_SCROLL3:
                case GGDC_SCROLL4:
                case GGDC_SCROLL5:
                case GGDC_SCROLL6:
                case GGDC_SCROLL7:
                case GGDC_SCROLL8:
                        ggdc_scroll_com(value);
                        ggdcglobs.ggdc_now.command = value ;
                        ggdcglobs.ggdc_now.count   = 0     ;
                        break;
                case GGDC_CSRFORM:
                        ggdc_csrform_com();
                        ggdcglobs.ggdc_now.command = value ;
                        ggdcglobs.ggdc_now.count   = 0     ;
                        break;
                case GGDC_PITCH:
                        ggdc_pitch_com();
                        ggdcglobs.ggdc_now.command = value ;
                        ggdcglobs.ggdc_now.count   = 0     ;
                        break;
                case GGDC_LPEN:
                        break;
                case GGDC_VECTW:
                        ggdc_vectw_com();
                        ggdcglobs.ggdc_now.command = value ;
                        ggdcglobs.ggdc_now.count   = 0     ;
                        break;
                case GGDC_VECTE:
                        (*ggdc_vecte_com)();
                        break;
                case GGDC_TEXTW1:
                case GGDC_TEXTW2:
                case GGDC_TEXTW3:
                case GGDC_TEXTW4:
                case GGDC_TEXTW5:
                case GGDC_TEXTW6:
                case GGDC_TEXTW7:
                case GGDC_TEXTW8:
                        ggdc_textw_com(value);
                        ggdcglobs.ggdc_now.command = value ; /* last ggdc command */
                        ggdcglobs.ggdc_now.count   = 0     ; /* ggdc param count  */
                        break;
                case GGDC_TEXTE:
                        (*ggdc_texte_com)();
                        break;
                case GGDC_CSRW:
                        ggdc_csrw_com();
                        ggdcglobs.ggdc_now.command = value ; /* last ggdc command */
                        ggdcglobs.ggdc_now.count   = 0     ; /* ggdc param count  */
                        break;
                case GGDC_CSRR:
                        ggdc_csrr_com();
                        break;
                case GGDC_MASK:
                        ggdc_mask_com();
                        ggdcglobs.ggdc_now.command = value ; /* last ggdc command */
                        ggdcglobs.ggdc_now.count   = 0     ; /* ggdc param count  */
                        break;
                case GGDC_WRITE1:
                case GGDC_WRITE2:
                case GGDC_WRITE3:
                case GGDC_WRITE4:
                case GGDC_WRITE5:
                case GGDC_WRITE6:
                case GGDC_WRITE7:
                case GGDC_WRITE8:
                case GGDC_WRITE9:
                case GGDC_WRITE10:
                case GGDC_WRITE11:
                case GGDC_WRITE12:
                case GGDC_WRITE13:
                case GGDC_WRITE14:
                case GGDC_WRITE15:
                case GGDC_WRITE16:
                        ggdc_write_com(value);
                        ggdcglobs.ggdc_now.command = value ; /* last ggdc command */
                        ggdcglobs.ggdc_now.count   = 0     ; /* ggdc param count  */
                        break;
                case GGDC_READ1:
                case GGDC_READ2:
                case GGDC_READ3:
                case GGDC_READ4:
                case GGDC_READ5:
                case GGDC_READ6:
                case GGDC_READ7:
                case GGDC_READ8:
                case GGDC_READ9:
                case GGDC_READ10:
                case GGDC_READ11:
                case GGDC_READ12:
                case GGDC_READ13:
                case GGDC_READ14:
                case GGDC_READ15:
                case GGDC_READ16:
                        ggdc_read_com(value);
                        break;
                case GGDC_DMAW1:
                case GGDC_DMAW2:
                case GGDC_DMAW3:
                case GGDC_DMAW4:
                case GGDC_DMAW5:
                case GGDC_DMAW6:
                case GGDC_DMAW7:
                case GGDC_DMAW8:
                case GGDC_DMAW9:
                case GGDC_DMAW10:
                case GGDC_DMAW11:
                case GGDC_DMAW12:
                case GGDC_DMAW13:
                case GGDC_DMAW14:
                case GGDC_DMAW15:
                case GGDC_DMAW16:
                case GGDC_DMAR1:
                case GGDC_DMAR2:
                case GGDC_DMAR3:
                case GGDC_DMAR4:
                case GGDC_DMAR5:
                case GGDC_DMAR6:
                case GGDC_DMAR7:
                case GGDC_DMAR8:
                case GGDC_DMAR9:
                case GGDC_DMAR10:
                case GGDC_DMAR11:
                case GGDC_DMAR12:
                case GGDC_DMAR13:
                case GGDC_DMAR14:
                case GGDC_DMAR15:
                case GGDC_DMAR16:
                        ggdc_param_out = ggdc_param_dummy ;
                        break;
                default:
                        assert1(FALSE,"unkown GGDC command = %x",value);
        }
}

/*----------------------------------------------------------------------*/

void    ggdc_status_in(half_word *value)
{
        if(ggdc_dataready == 0){
                ggdc_status &= 0xFE;
        }else{
                ggdc_status |= 0x01;
        }
        if(ggdc_drawing == 0){
                ggdc_status &= 0xF7;
        }else{
                ggdc_status |= 0x08;
        }
        if(ggdc_flipflop == 0){
                ggdc_status &= 0x9F;
        }else{
                ggdc_status |= 0x60;
        }
        ggdc_flipflop  =  ( ggdc_flipflop + 1 ) & 1;
        *value         =  ggdc_status;
}

void    ggdc_data_dummy(half_word *value)
{
        *value = 0xFF;
}

void    ggdc_param_dummy(half_word value)
{
        /*      Opps!!! do nothing !!! */
}

BOOL    host_dummy(void)
{
        /*      Opps!!! do nothing !!! */
        return(0);
}

/*:::::::::::::::::::::::   G-GDC RESET Command   ::::::::::::::::::::::*/

void    ggdc_reset_com(half_word value)
{
/*      (1) GGDC STATUS FLAG CLEAR */
        ggdc_drawing    = 0;
        ggdc_dataready  = 0;
        ggdc_flipflop   = 0;
        ggdc_status     = 4;

/* (2) GGDC DRAW ROUTINE CONNECT CLEAR */
        ggdc_param_out  = ggdc_param_dummy;
        ggdc_data_in    = ggdc_data_dummy;

/* (3) GGDC VECTW PARAM CLEAR */
        ggdc_init_vectw_param();

/* (4) GGDC START STOP */
        ggdc_param_out = ggdc_sync_param;

        if( value == GGDC_RESET3 ){
                ggdc_start_com();
        }else{
                ggdc_stop_com();
        }
}

/*:::::::::::::::::::::::   G-GDC SYNC Command    ::::::::::::::::::::::*/

void    ggdc_sync_com(half_word value)
{
        ggdc_param_out = ggdc_sync_param ;
        if( value == GGDC_SYNC_OFF ){
                ggdc_stop_com();
        }else{
                ggdc_start_com();
        }
}
/*----------------------------------------------------------------------*/
void    ggdc_sync_param(half_word value)
{

        ggdcglobs.sync_param[ggdcglobs.ggdc_now.count]     = value;
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;

        switch(ggdcglobs.ggdc_now.count++){
                case 0:
                        break;
                case 1:
                        NEC98Display.ggdcemu.cr = value ;
                        break;
                case 2:
                        break;
                case 3:
                        break;
                case 4:
                        if(value&0x40){
                                NEC98Display.ggdcemu.p |= 0x0100;
                        }else{
                                NEC98Display.ggdcemu.p &= 0x00FF;
                        }
                        break;
                case 5:
                        NEC98Display.ggdcemu.vh = (value&0x80) ? TRUE : FALSE;
                        break;
                case 6:
                        NEC98Display.ggdcemu.lf &= 0xFF00;
                        NEC98Display.ggdcemu.lf |= (unsigned short)value;
                        break;
                case 7:
                        NEC98Display.ggdcemu.lf &= 0x00FF;
                        NEC98Display.ggdcemu.lf |= ((unsigned short)(value&3))<<8;
                        ggdc_param_out = ggdc_param_dummy;
                        break;
                default:
                        assert1(FALSE,"GGDC SYNC param count error = %d",
                                ggdcglobs.ggdc_now.count);
        }
}

/*:::::::::::::::::::::::   G-GDC START Command   ::::::::::::::::::::::*/

void    ggdc_start_com(void)
{
        NEC98Display.ggdcemu.startstop = TRUE;
        ggdcglobs.start_stop = GGDC_START2;
        if( video_emu_mode ){
                set_mode_change_required(TRUE);
        }
}

/*:::::::::::::::::::::::   G-GDC STOP Command   :::::::::::::::::::::::*/

void    ggdc_stop_com(void)
{
        NEC98Display.ggdcemu.startstop = FALSE;
        ggdcglobs.start_stop = GGDC_STOP2;
        if( video_emu_mode ){
                set_mode_change_required(TRUE);
        }
}

/*:::::::::::::::::::::::   G-GDC ZOOM Command   :::::::::::::::::::::::*/

void    ggdc_zoom_com(void)
{
        ggdc_param_out = ggdc_zoom_param;
}
/*----------------------------------------------------------------------*/
void    ggdc_zoom_param(half_word value)
{
        ggdcglobs.zoom_param        = value;
        ggdcglobs.ggdc_now.param[0] = value;
        NEC98Display.ggdcemu.zw      = value & 0x0F;
        ggdc_param_out              = ggdc_param_dummy;
        ggdcglobs.ggdc_now.count    = 1;
}

/*::::::::::::::::::::::   G-GDC SCROLL Command   ::::::::::::::::::::::*/

void    ggdc_scroll_com(half_word value)
{
        switch( value ){
                case GGDC_SCROLL1:
                        ggdc_param_out = ggdc_scroll_param1;
                        break ;
                case GGDC_SCROLL2:
                        ggdc_param_out = ggdc_scroll_param2;
                        break ;
                case GGDC_SCROLL3:
                        ggdc_param_out = ggdc_scroll_param3;
                        break ;
                case GGDC_SCROLL4:
                        ggdc_param_out = ggdc_scroll_param4;
                        break ;
                case GGDC_SCROLL5:
                        ggdc_param_out = ggdc_scroll_param5;
                        break ;
                case GGDC_SCROLL6:
                        ggdc_param_out = ggdc_scroll_param6;
                        break ;
                case GGDC_SCROLL7:
                        ggdc_param_out = ggdc_scroll_param7;
                        break ;
                case GGDC_SCROLL8:
                        ggdc_param_out = ggdc_scroll_param8;
                        break ;
                default:
                        assert1(FALSE,"GGDC SCROLL bad command = %x",value);
        }
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param1(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[0] = value;
        NEC98Display.ggdcemu.sad1 &= 0xFFFFFF00;
        NEC98Display.ggdcemu.sad1 |= (unsigned long)(value);
        ggdc_param_out = ggdc_scroll_param2;
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param2(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[1] = value;
        NEC98Display.ggdcemu.sad1 &= 0xFFFF00FF;
        NEC98Display.ggdcemu.sad1 |= ((unsigned long)(value)<<8);
        ggdc_param_out = ggdc_scroll_param3;
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param3(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[2] = value;
        NEC98Display.ggdcemu.sad1 &= 0xFF00FFFF;
        NEC98Display.ggdcemu.sad1 |= (((unsigned long)(value&0x03))<<16);
        NEC98Display.ggdcemu.sl1  &= 0xFFF0;
        NEC98Display.ggdcemu.sl1  |= (((unsigned short)(value&0xF0))>>4);
        ggdc_param_out = ggdc_scroll_param4;
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param4(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[3] = value;
        NEC98Display.ggdcemu.im1   = (value&0x40) ? TRUE : FALSE;
        NEC98Display.ggdcemu.sl1  &= 0xC0FF;
        NEC98Display.ggdcemu.sl1  |= (((unsigned short)(value&0x3F))<<4);
        ggdc_param_out = ggdc_scroll_param5;
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param5(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[4] = value;
        NEC98Display.ggdcemu.sad2 &= 0xFFFFFF00;
        NEC98Display.ggdcemu.sad2 |= (unsigned long)(value);
        ggdc_param_out = ggdc_scroll_param6;
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param6(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[5] = value;
        NEC98Display.ggdcemu.sad2 &= 0xFFFF00FF;
        NEC98Display.ggdcemu.sad2 |= ((unsigned long)(value)<<8);
        ggdc_param_out = ggdc_scroll_param7;
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param7(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[6] = value;
        NEC98Display.ggdcemu.sad2 &= 0xFF00FFFF;
        NEC98Display.ggdcemu.sad2 |= (((unsigned long)(value&0x03))<<16);
        NEC98Display.ggdcemu.sl2  &= 0xFFF0;
        NEC98Display.ggdcemu.sl2  |= (((unsigned short)(value&0xF0))>>4);
        ggdc_param_out = ggdc_scroll_param8;
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param8(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[7] = value;
        NEC98Display.ggdcemu.im2   = (value&0x40) ? TRUE : FALSE;
        NEC98Display.ggdcemu.sl2  &= 0xC0FF;
        NEC98Display.ggdcemu.sl2  |= (((unsigned short)(value&0x3F))<<4);
        ggdc_param_out = ggdc_param_dummy;
}

/*::::::::::::::::::::::   G-GDC CSRFORM Command   :::::::::::::::::::::*/

void    ggdc_csrform_com(void)
{
        ggdc_param_out = ggdc_csrform_param;
}

/*----------------------------------------------------------------------*/

void    ggdc_csrform_param(half_word value)
{

        ggdcglobs.csrform_param[ggdcglobs.ggdc_now.count]   = value;
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;

        switch(ggdcglobs.ggdc_now.count++){
                case 0:
                        NEC98Display.ggdcemu.lr = value & 0x1F;
                        if( video_emu_mode ){
                                set_mode_change_required(TRUE);
                        }
                        break;
                case 1:
                        break;
                case 2:
                        ggdc_param_out = ggdc_param_dummy;
                        break;
                default:        
                        assert1(FALSE,"GGDC CSRFORM param count error = %d",
                                ggdcglobs.ggdc_now.count);
        }
}

/*:::::::::::::::::::::::   G-GDC PITCH Command   ::::::::::::::::::::::*/

void    ggdc_pitch_com(void)
{
        ggdc_param_out = ggdc_pitch_param;
}

/*----------------------------------------------------------------------*/

void    ggdc_pitch_param(half_word value)
{
        ggdcglobs.pitch_param         = value;
        ggdcglobs.ggdc_now.param[0]  = value;
        NEC98Display.ggdcemu.p       &= 0xFF00;
        NEC98Display.ggdcemu.p       |= (unsigned short)value;
        ggdc_param_out               = ggdc_param_dummy;
        ggdcglobs.ggdc_now.count     = 1;
}

/*::::::::::::::::::::::   G-GDC VECTW Command   :::::::::::::::::::::::*/

void    ggdc_vectw_com(void)
{
        ggdc_param_out = ggdc_vectw_param;
}

/*----------------------------------------------------------------------*/

void    ggdc_vectw_param(half_word value)
{
        ggdcglobs.vectw_param[ggdcglobs.ggdc_now.count]     = value;
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;

        switch(ggdcglobs.ggdc_now.count++){
                case  0:
                        NEC98Display.ggdcemu.slrctl = (value&0xF8)>>3;
                        NEC98Display.ggdcemu.dir    = (value&0x07);
                        switch(NEC98Display.ggdcemu.slrctl){
                                case 0x00:      /* PIXEL */
                                        ggdc_vecte_com = ggdc_draw_pixel;
                                        ggdc_texte_com = ggdc_draw_nothing;
                                        break;
                                case 0x01:      /* LINE */
                                        ggdc_vecte_com = ggdc_draw_line;
                                        ggdc_texte_com = ggdc_draw_nothing;
                                        break;
                                case 0x02:      /* GRAPHIC CHAR */
                                        ggdc_vecte_com = ggdc_draw_nothing;
                                        ggdc_texte_com = ggdc_draw_gchar;
                                        break;
                                case 0x04:      /* CIRCLE */
                                        ggdc_vecte_com = ggdc_draw_circle;
                                        ggdc_texte_com = ggdc_draw_nothing;
                                        break;
                                case 0x08:      /* RECT */
                                        ggdc_vecte_com = ggdc_draw_rect;
                                        ggdc_texte_com = ggdc_draw_nothing;
                                        break;
                                case 0x12:      /* SLINE GRAPHIC CHAR */
                                        ggdc_vecte_com = ggdc_draw_nothing;
                                        ggdc_texte_com = ggdc_draw_slgchar;
                                        break;
                                default:
                                        ggdc_vecte_com = ggdc_draw_nothing;
                                        ggdc_texte_com = ggdc_draw_nothing;
                                        assert1(FALSE,"GGDC draw mode error = %x",
                                            NEC98Display.ggdcemu.slrctl);
                        }
                        break;
                case  1:
                        NEC98Display.ggdcemu.dc &= 0xFF00;
                        NEC98Display.ggdcemu.dc |= (unsigned short)value;
                        break;
                case  2:
                        NEC98Display.ggdcemu.dgd = (value&0x40) ? TRUE : FALSE;
                        NEC98Display.ggdcemu.dc &= 0x00FF;
                        NEC98Display.ggdcemu.dc |= ((unsigned short)(value&0x3F))<<8;
                        break;
                case  3:
                        NEC98Display.ggdcemu.d  &= 0xFF00;
                        NEC98Display.ggdcemu.d  |= (unsigned short)value;
                        break;
                case  4:
                        NEC98Display.ggdcemu.d  &= 0x00FF;
                        NEC98Display.ggdcemu.d  |= ((unsigned short)(value&0x3F))<<8;
                        break;
                case  5:
                        NEC98Display.ggdcemu.d2 &= 0xFF00;
                        NEC98Display.ggdcemu.d2 |= (unsigned short)value;
                        break;
                case  6:
                        NEC98Display.ggdcemu.d2 &= 0x00FF;
                        NEC98Display.ggdcemu.d2 |= ((unsigned short)(value&0x3F))<<8;
                        break;
                case  7:
                        NEC98Display.ggdcemu.d1 &= 0xFF00;
                        NEC98Display.ggdcemu.d1 |= (unsigned short)value;
                        break;
                case  8:
                        NEC98Display.ggdcemu.d1 &= 0x00FF;
                        NEC98Display.ggdcemu.d1 |= ((unsigned short)(value&0x3F))<<8;
                        break;
                case  9:
                        NEC98Display.ggdcemu.dm &= 0xFF00;
                        NEC98Display.ggdcemu.dm |= (unsigned short)value;
                        break;
                case 10:
                        NEC98Display.ggdcemu.dm &= 0x00FF;
                        NEC98Display.ggdcemu.dm |= ((unsigned short)(value&0x3F))<<8;
                        ggdc_param_out = ggdc_param_dummy;
                        break;
                default:        
                        assert1(FALSE,"GGDC VECTW param count error = %d",
                                ggdcglobs.ggdc_now.count);
        }
}

/*::::::::::::::::::::::   G-GDC TEXTW Command   :::::::::::::::::::::::*/

void    ggdc_textw_com(half_word value)
{
        switch( value ){
                case GGDC_TEXTW1:
                        ggdc_param_out = ggdc_textw_param1;
                        break;
                case GGDC_TEXTW2:
                        ggdc_param_out = ggdc_textw_param2;
                        break;
                case GGDC_TEXTW3:
                        ggdc_param_out = ggdc_textw_param3;
                        break;
                case GGDC_TEXTW4:
                        ggdc_param_out = ggdc_textw_param4;
                        break;
                case GGDC_TEXTW5:
                        ggdc_param_out = ggdc_textw_param5;
                        break;
                case GGDC_TEXTW6:
                        ggdc_param_out = ggdc_textw_param6;
                        break;
                case GGDC_TEXTW7:
                        ggdc_param_out = ggdc_textw_param7;
                        break;
                case GGDC_TEXTW8:
                        ggdc_param_out = ggdc_textw_param8;
                        break;
                default:
                        assert1(FALSE,"GGDC TEXTW bad command = %x",value);
        }
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param1(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[0] = value;
        NEC98Display.ggdcemu.ptn &= 0xFF00;
        NEC98Display.ggdcemu.ptn |= (unsigned short)value;
        NEC98Display.ggdcemu.txt[0] = value;
        ggdc_param_out = ggdc_textw_param2;
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param2(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[1] = value;
        NEC98Display.ggdcemu.ptn &= 0x00FF;
        NEC98Display.ggdcemu.ptn |= ((unsigned short)value)<<8;
        NEC98Display.ggdcemu.txt[1] = value;
        ggdc_param_out = ggdc_textw_param3;
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param3(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[2] = value;
        NEC98Display.ggdcemu.txt[2] = value;
        ggdc_param_out = ggdc_textw_param4;
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param4(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[3] = value;
        NEC98Display.ggdcemu.txt[3] = value;
        ggdc_param_out = ggdc_textw_param5;
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param5(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[4] = value;
        NEC98Display.ggdcemu.txt[4] = value;
        ggdc_param_out = ggdc_textw_param6;
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param6(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[5] = value;
        NEC98Display.ggdcemu.txt[5] = value;
        ggdc_param_out = ggdc_textw_param7;
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param7(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[6] = value;
        NEC98Display.ggdcemu.txt[6] = value;
        ggdc_param_out = ggdc_textw_param8;
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param8(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[7] = value;
        NEC98Display.ggdcemu.txt[7] = value;
        ggdc_param_out = ggdc_param_dummy;
}

/*:::::::::::::::::::::::   G-GDC CSRW Command   :::::::::::::::::::::::*/

void    ggdc_csrw_com(void)
{
        ggdc_param_out = ggdc_csrw_param;
}

/*----------------------------------------------------------------------*/

void    ggdc_csrw_param(half_word value)
{

        ggdcglobs.csrw_param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;

        switch(ggdcglobs.ggdc_now.count++){
                case 0:
                        NEC98Display.ggdcemu.ead &= 0xFFFFFF00;
                        NEC98Display.ggdcemu.ead |= (unsigned long)value;
                        break;
                case 1:
                        NEC98Display.ggdcemu.ead &= 0xFFFF00FF;
                        NEC98Display.ggdcemu.ead |= ((unsigned long)value)<<8;
                        break;
                case 2:
                        NEC98Display.ggdcemu.ead &= 0xFF00FFFF;
                        NEC98Display.ggdcemu.ead |= ((unsigned long)(value&0x03))<<16;
                        NEC98Display.ggdcemu.wg   = (value&0x08) ? TRUE : FALSE;
                        NEC98Display.ggdcemu.dad  = 0x0001 << ((value&0xF0)>>4);
                        ggdcglobs.mask_param[0]  = 
                                (unsigned char)(NEC98Display.ggdcemu.dad&0x00FF);
                        ggdcglobs.mask_param[1]  = 
                                (unsigned char)((NEC98Display.ggdcemu.dad&0xFF00)>>4);
                        ggdc_param_out = ggdc_param_dummy;
                        break;
                default:        
                        assert1(FALSE,"GGDC CSRW param count error = %d",
                                ggdcglobs.ggdc_now.count);
        }
}

/*:::::::::::::::::::::::   G-GDC CSRR Command   :::::::::::::::::::::::*/

void    ggdc_csrr_com(void)
{
        ggdc_param_out  = ggdc_param_dummy;
        ggdc_data_in    = ggdc_csrr_data1;     /* read data routine set  */
        ggdc_dataready  = 1;                           /* set ggdc data read OK! */
}
/*----------------------------------------------------------------------*/
void    ggdc_csrr_data1(half_word *value)
{
        ggdc_data_in = ggdc_csrr_data2;
        *value = ggdcglobs.csrw_param[0];
}
/*----------------------------------------------------------------------*/
void    ggdc_csrr_data2(half_word *value)
{
        ggdc_data_in = ggdc_csrr_data3;
        *value = ggdcglobs.csrw_param[1];
}
/*----------------------------------------------------------------------*/
void    ggdc_csrr_data3(half_word *value)
{
        ggdc_data_in = ggdc_csrr_data4;
        *value = (ggdcglobs.csrw_param[2] & 0x03);
}
/*----------------------------------------------------------------------*/
void    ggdc_csrr_data4(half_word *value)
{
        ggdc_data_in = ggdc_csrr_data5;
        *value = ggdcglobs.mask_param[0];
}
/*----------------------------------------------------------------------*/
void    ggdc_csrr_data5(half_word *value)
{
        ggdc_data_in = ggdc_data_dummy;
        *value = ggdcglobs.mask_param[1];
        ggdc_dataready = 0;                            /* set ggdc data read END! */
}

/*:::::::::::::::::::::::   G-GDC MASK Command   :::::::::::::::::::::::*/

void    ggdc_mask_com(void)
{
        ggdc_param_out = ggdc_mask_param;
}
/*----------------------------------------------------------------------*/
void    ggdc_mask_param(half_word value)
{

        ggdcglobs.mask_param[ggdcglobs.ggdc_now.count]   = value;
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;

        switch(ggdcglobs.ggdc_now.count++){
                case 0:
                        NEC98Display.ggdcemu.dad &= 0xFF00;
                        NEC98Display.ggdcemu.dad |= (unsigned short)value;
                        break;
                case 1:
                        NEC98Display.ggdcemu.dad &= 0x00FF;
                        NEC98Display.ggdcemu.dad |= ((unsigned short)value)<<8;
                        ggdc_param_out = ggdc_param_dummy;
                        break;
        default:        
                        assert1(FALSE,"GGDC MASK param count error = %d",
                                ggdcglobs.ggdc_now.count);
        }
}

/*----------------------------------------------------------------------*/
static  unsigned short  write_data;
static  unsigned short  read_data ;
/*----------------------------------------------------------------------*/

/*:::::::::::::::::::::::   G-GDC WRITE Command   ::::::::::::::::::::::*/


void    ggdc_write_com(half_word value)
{
        ggdcglobs.write = value;       /* save last WRITE Command */
        NEC98Display.ggdcemu.whl =  (value&0x18)>>3;
        NEC98Display.ggdcemu.mod =  (value&0x03);
        ggdc_mod_select(&NEC98Display.ggdcemu.mod);

        if(NEC98Display.ggdcemu.slrctl==0){
                switch(NEC98Display.ggdcemu.whl){
                        case 0x00:
                                ggdc_param_out = ggdc_write_word_low;
                                break;
                        case 0x02:
                                ggdc_param_out = ggdc_write_byte_low;
                                break;
                        case 0x03:
                                ggdc_param_out = ggdc_write_byte_high;
                                break;
                        default:
                                ggdc_param_out = ggdc_param_dummy;
                                assert1(FALSE,"GGDC WRITE WHL error = %d",
                                NEC98Display.ggdcemu.whl);
                }
        }else{
                ggdc_param_out = ggdc_param_dummy;
        }
}
/*----------------------------------------------------------------------*/
void    ggdc_write_word_low(half_word value)
{
        ggdc_drawing = DRAWING;
        ggdc_param_out = ggdc_write_word_high;
        write_data = (unsigned short)value;
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_write_word_high(half_word value)
{
        write_data &= 0x00FF;
        write_data |= ((unsigned short)value) << 8;

        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_writing((unsigned short *)&write_data);
        ggdc_read_back_data();

        if(NEC98Display.ggdcemu.dc != 0 ){
                ggdc_param_out = ggdc_write_word_low;
                NEC98Display.ggdcemu.dc --;
        }else{
                ggdc_param_out = ggdc_param_dummy;
                ggdc_init_vectw_param();
        }
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_write_byte_low(half_word value)
{
        write_data = (unsigned short)value;
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_writing((unsigned short *)&write_data);
        ggdc_read_back_data();

        if(NEC98Display.ggdcemu.dc != 0 ){
                NEC98Display.ggdcemu.dc --;
        }else{
                ggdc_param_out = ggdc_param_dummy;
                ggdc_init_vectw_param();
        }
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_write_byte_high(half_word value)
{
        write_data = ((unsigned short)value) << 8;
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_writing((unsigned short *)&write_data);
        ggdc_read_back_data();

        if(NEC98Display.ggdcemu.dc != 0 ){
                NEC98Display.ggdcemu.dc --;
        }else{
                ggdc_param_out = ggdc_param_dummy;
                ggdc_init_vectw_param();
        }
        ggdc_drawing = NOTDRAW;
}

/*:::::::::::::::::::::::   G-GDC READ Command   :::::::::::::::::::::::*/

void    ggdc_read_com(half_word value)
{
        NEC98Display.ggdcemu.whl =  (value&0x18)>>3;
        NEC98Display.ggdcemu.mod =  (value&0x03);
        ggdcglobs.write &= 0xFC;
        ggdcglobs.write |= NEC98Display.ggdcemu.mod; /* save GGDC mod param */
        ggdc_mod_select(&NEC98Display.ggdcemu.mod);

        if(NEC98Display.ggdcemu.slrctl==0){
                switch(NEC98Display.ggdcemu.whl){
                        case 0x00:
                                ggdc_data_in = ggdc_read_word_low;
                                break;
                        case 0x02:
                                ggdc_data_in = ggdc_read_byte_low;
                                break;
                        case 0x03:
                                ggdc_data_in = ggdc_read_byte_high;
                                break;
                        default:
                                ggdc_data_in = ggdc_data_dummy;
                                assert1(FALSE,"GGDC READ WHL error = %d",
                                NEC98Display.ggdcemu.whl);
                }
        }else{
                ggdc_data_in = ggdc_data_dummy;
        }
}

/*----------------------------------------------------------------------*/
void    ggdc_read_word_low(half_word *value)
{
        ggdc_drawing = DRAWING;
        ggdc_data_in = ggdc_read_word_high;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_reading((unsigned short *)&read_data);
        ggdc_read_back_data();
        *value = (half_word)(read_data&0x00FF);
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_read_word_high(half_word *value)
{

        ggdc_drawing = DRAWING;
        *value = (half_word)((read_data&0xFF00)>>8);
        if(NEC98Display.ggdcemu.dc != 0 ){
                ggdc_data_in = ggdc_read_word_low;
                NEC98Display.ggdcemu.dc --;
        }else{
                ggdc_data_in = ggdc_data_dummy;
                ggdc_init_vectw_param();
        }
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_read_byte_low(half_word *value)
{
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_reading((unsigned short *)&read_data);
        ggdc_read_back_data();
        *value = (half_word)(read_data&0x00FF);
        if(NEC98Display.ggdcemu.dc != 0 ){
                NEC98Display.ggdcemu.dc --;
        }else{
                ggdc_data_in = ggdc_data_dummy;
                ggdc_init_vectw_param();
        }
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_read_byte_high(half_word *value)
{
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_reading((unsigned short *)&read_data);
        ggdc_read_back_data();
        *value = (half_word)((read_data&0xFF00)>>8);
        if(NEC98Display.ggdcemu.dc != 0 ){
                NEC98Display.ggdcemu.dc --;
        }else{
                ggdc_data_in = ggdc_data_dummy;
                ggdc_init_vectw_param();
        }
        ggdc_drawing = NOTDRAW;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::    G-GDC DRAW ROUTINE CALL     ::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void    ggdc_draw_pixel(void)
{
        ggdc_param_out = ggdc_param_dummy;
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_drawing_pixel();
        ggdc_read_back_data();
        ggdc_init_vectw_param();
        ggdc_drawing = NOTDRAW;
        
}
/*----------------------------------------------------------------------*/
void    ggdc_draw_line(void)
{
        ggdc_param_out = ggdc_param_dummy;
        ggdc_drawing = DRAWING;        /*      set drawing start flag  */
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_drawing_line();
        ggdc_read_back_data();
        ggdc_init_vectw_param();
        ggdc_drawing = NOTDRAW;        /* reset drawing start flag */
}
/*----------------------------------------------------------------------*/
void    ggdc_draw_gchar(void)
{
        ggdc_param_out = ggdc_param_dummy;
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_drawing_text();
        ggdc_read_back_data();
        ggdc_init_vectw_param();
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_draw_circle(void)
{
        ggdc_param_out = ggdc_param_dummy;
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_drawing_arc();
        ggdc_read_back_data();
        ggdc_init_vectw_param();
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_draw_rect(void)
{
        ggdc_param_out = ggdc_param_dummy;
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_drawing_rect();
        ggdc_read_back_data();
        ggdc_init_vectw_param();
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_draw_slgchar(void)
{
        ggdc_param_out = ggdc_param_dummy;
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_drawing_text();
        ggdc_read_back_data();
        ggdc_init_vectw_param();
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_draw_nothing(void)
{
        ggdc_param_out = ggdc_param_dummy;
        ggdc_drawing = DRAWING;
        ggdc_read_back_data();
        ggdc_init_vectw_param();
        ggdc_drawing = NOTDRAW;
}

/*----------------------------------------------------------------------*/
void    recalc_ggdc_draw_parameter(void)
{
        unsigned char   loop;  /* use loop counter */

        drawing_data.asm_vram = (unsigned long)&drawaddress[0];
        drawing_data.asm_ead = NEC98Display.ggdcemu.ead;
        drawing_data.asm_pitch  = (NEC98Display.modeff2.gdcclock) ? 
                                  (unsigned short)(NEC98Display.ggdcemu.p/2) :
                                  (unsigned short)(NEC98Display.ggdcemu.p  );
        drawing_data.asm_dir = (unsigned long)NEC98Display.ggdcemu.dir;
        drawing_data.asm_dc = NEC98Display.ggdcemu.dc+1;
        drawing_data.asm_d = NEC98Display.ggdcemu.d;
        drawing_data.asm_d2 = NEC98Display.ggdcemu.d2;
        drawing_data.asm_d1 = NEC98Display.ggdcemu.d1;
        drawing_data.asm_dm = NEC98Display.ggdcemu.dm;
        drawing_data.asm_ptn = NEC98Display.ggdcemu.ptn;
        drawing_data.asm_zoom = NEC98Display.ggdcemu.zw+1;
        drawing_data.asm_sl = (NEC98Display.ggdcemu.slrctl==0x12) ? 1 : 0;
        drawing_data.asm_wg = (NEC98Display.ggdcemu.wg) ? 1 : 0;
        drawing_data.asm_maskgdc = NEC98Display.ggdcemu.dad;

        for( loop=0 ; loop<8 ; loop++){
            drawing_data.asm_txt[loop] = NEC98Display.ggdcemu.txt[loop];
        }
}
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::     G-GDC INIT FUNCTIONS     :::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void    ggdc_init_vectw_param(void)
{
        NEC98Display.ggdcemu.dc  =  0x0000; /* DC =  0 */
        NEC98Display.ggdcemu.d   =  0x0008; /* D  =  8 */
        NEC98Display.ggdcemu.d2  =  0x0008; /* D2 =  8 */
        NEC98Display.ggdcemu.d1  =  0x3FFF; /* D1 = -1 */
        NEC98Display.ggdcemu.dm  =  0x3FFF; /* DM = -1 */

        ggdcglobs.vectw_param[ 1]  = 0x00; 
        ggdcglobs.vectw_param[ 2] &= 0x40; 
        ggdcglobs.vectw_param[ 3]  = 0x08; 
        ggdcglobs.vectw_param[ 4]  = 0x00; 
        ggdcglobs.vectw_param[ 5]  = 0x08; 
        ggdcglobs.vectw_param[ 6]  = 0x00; 
        ggdcglobs.vectw_param[ 7]  = 0xFF; 
        ggdcglobs.vectw_param[ 8]  = 0x3F; 
        ggdcglobs.vectw_param[ 9]  = 0xFF; 
        ggdcglobs.vectw_param[10]  = 0x3F; 
}

/*----------------------------------------------------------------------*/
void    ggdc_read_back_data(void)
{
        ggdc_read_back((unsigned long *)&readcsrr);
        NEC98Display.ggdcemu.ead  = readcsrr.lastead;
        NEC98Display.ggdcemu.dad  = readcsrr.lastdad;

        ggdcglobs.csrw_param[0]  = readcsrr.lastcsrr[0];
        ggdcglobs.csrw_param[1]  = readcsrr.lastcsrr[1];
        ggdcglobs.csrw_param[2] &= 0xFC;
        ggdcglobs.csrw_param[2] |= readcsrr.lastcsrr[2];
        ggdcglobs.mask_param[0]  = readcsrr.lastcsrr[3];
        ggdcglobs.mask_param[1]  = readcsrr.lastcsrr[4];
}
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=video
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc;$(WINDOWS_INC_PATH)

SOURCES=  \
    ..\ega_mode.c      \
    ..\ega_prts.c      \
    ..\ega_vide.c      \
    ..\gfx_updt.c      \
    ..\video.c         \
    ..\gvi.c           \
    ..\video_io.c      \
    ..\v7_ports.c      \
    ..\v7_video.c      \
    ..\vga_mode.c      \
    ..\vga_prts.c      \
    ..\vga_vide.c      \
    ..\ega_read.c      \
    ..\ega_writ.c      \
    ..\ega_dmmy.c      \
    ..\ega_trcr.c      \
    ..\egawrtm0.c      \
    ..\egwrtm12.c      \
    ..\cga.c           \
    ..\tgdc.c          \
    ..\crtc.c          \
    ..\cg.c            \
    ..\ggdc.c

i386_SOURCES=           ..\i386\ggdcdraw.asm

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC

SOURCES_USED=..\sources.inc

!INCLUDE $(SOFTPC_TREE)\base\condincl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\gvi.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title	: gvi 
 *
 * Description	: Generic Video Interface Module internal descriptions.
 *
 * Author	: Henry Nash
 *
 * Notes	: The following functions are defined 
 *
 *                gvi_init              - Set up gvi variables
 *                gvi_term              - Close down current video adaptor
 *
 *		  Note that all addresses used by these routines are
 *		  in host address space NOT 8088 address space.		
 *
 *		  The data itself is not passed as a parameter in the
 *		  GVI calls since the 8088 memory to which the calls
 *		  refer may be accessed to obtain the new data.
 *
 *                The default video adapter is CGA.
 *
 * Mods: (r3.4) : The Mac II running MultiFinder and MPW C has a few
 *                problems. One is the difficulty in initialising
 *                static variables of the form:
 *
 *                host_addr x = (host_addr)M;
 *
 *                This is fixed by initialising variables of this type
 *                in in-line code. A crock, but what else can I do?
 */

/*
 * static char SccsID[]="@(#)gvi.c	1.22 8/25/93 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_BIOS.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */

#include "xt.h"
#include "bios.h"
#include "sas.h"
#include "error.h"
#include "config.h"
#include "gvi.h"
#include "gmi.h"
#include "cga.h"
#ifdef HERC
#include "herc.h"
#endif
#include "debug.h"
#include "gfx_upd.h"
#ifdef EGG
#include "egagraph.h"
#include "egacpu.h"
#endif /* EGG */
#include "host_gfx.h"

/*
 * External variables
 */

extern int soft_reset;  /* Defined in reset.c                       */

/*
 * Global variables reflecting the state of the currently selected adapter
 * These should be integrated with the new EGA stuff
 */

#if defined(NEC_98)
DISPLAY_GLOBS   NEC98Display;
#else   //NEC_98
DISPLAY_GLOBS	PCDisplay;
#endif  //NEC_98
int text_blk_size;	/* In TEXT mode the size of a dirty block   */

/*
 * Other globals
 */

/*
 * These 4 variables are used by the BIOS & host stuff to indicate where the active
 * adaptor is. NB. The EGA can move!!
 */

host_addr gvi_host_low_regen;
host_addr gvi_host_high_regen;
sys_addr gvi_pc_low_regen;
sys_addr gvi_pc_high_regen;

half_word video_adapter    = NO_ADAPTOR;	/* No adaptor initially */


/*
 * Global routines
 */

void	recalc_screen_params IFN0()
{
#ifdef VGG
	if (get_doubleword_mode())
		set_bytes_per_line(get_chars_per_line()<<3);
	else
#endif
	    if (get_word_addressing())
		set_bytes_per_line(get_chars_per_line()<<1);
	    else
#ifdef V7VGA
		if (get_seq_chain4_mode())
			set_bytes_per_line(get_chars_per_line()<<3);
		else
/*
 * The V7VGA proprietary text modes fall through here, because the V7 card
 * uses so-called byte-mode for them.  This does not affect the PC's
 * view of things, therefore assure that for text modes
 * 	bytes_per_line = 2 * chars_per_line 	
 * always holds.
 */
			if ( is_it_text() )
				set_bytes_per_line(get_chars_per_line()<<1);
			else
#endif /* V7VGA */
#ifdef VGG
				/* Caters for the 'undocumented' VGA modes */
				if (get_256_colour_mode())
					set_bytes_per_line(get_chars_per_line()<<1);
				else
#endif /* VGG */
					set_bytes_per_line(get_chars_per_line());
	/*
	 * This is pretty tacky, but...
	 */
	if (video_adapter==EGA || video_adapter == VGA)
		set_screen_length(get_offset_per_line()*get_screen_height()/get_char_height());
	else
		set_screen_length(get_bytes_per_line()*get_screen_height()/get_char_height());
	set_char_width(8);
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

#if defined(NEC_98)
void gvi_init()
{
    video_adapter = 1;  // '1' means NEC98.
    NEC98_init();
    host_clear_screen();
}

void gvi_term IFN0(){}

#else   //NEC_98
void gvi_init IFN1(half_word, v_adapter)
{
    int screen_height;

    /*
     * If this is second or subsequent reset, switch off old video adapter
     * ports before initialising new one.
     */

    if (soft_reset)
        switch (video_adapter) {
#ifdef DUMB_TERMINAL
        case MDA:
            mda_term();
            break;
#endif /* DUMB_TERMINAL */
        case CGA:
#ifdef CGAMONO 
	case CGA_MONO: 
#endif 
            cga_term();
            break;
#ifdef EGG
        case EGA:
	    ega_term();
	    break;
#endif
#ifdef VGG
        case VGA:
	    vga_term();
	    break;
#endif
#ifdef HERC
	case HERCULES:
	    herc_term();
	    break;
#endif
        default:
#ifndef PROD
            fprintf(trace_file, "gvi_term: invalid video adaptor: %d\n",
                    video_adapter);
#endif
	    break;
        }

    /*
     * Set up GVI variables, depending on v_adapter.
     */

    switch (v_adapter) {
    case MDA:
    case CGA:
#ifdef CGAMONO  
    case CGA_MONO:  
#endif
	screen_height = CGA_HEIGHT;
        video_adapter = v_adapter;
        break;
#ifdef HERC
    case HERCULES:
	screen_height = HERC_HEIGHT;
	video_adapter = v_adapter;
	break;
#endif
#ifdef EGG
    case EGA:
	screen_height = EGA_HEIGHT;
        video_adapter = v_adapter;
        break;
#endif
#ifdef VGG
    case VGA:
	screen_height = VGA_HEIGHT;
        video_adapter = v_adapter;
        break;
#endif
    default:
	screen_height = CGA_HEIGHT;
        video_adapter = CGA;    /* Default video adapter */
    }

#ifdef GORE
	/*
	 *	GORE variables must be set up before doing any other
	 *	graphics.
	 */

    init_gore_update();
#endif /* GORE */

/* Setting all these variables should be done in the appropriate xxx_init() */
    switch (video_adapter) {
#ifdef DUMB_TERMINAL
    case MDA:
        mda_init();
        break;
#endif /* DUMB_TERMINAL */
    case CGA:
#ifdef CGAMONO  
    case CGA_MONO:  
#endif
        cga_init();
        break;
#ifdef HERC
    case HERCULES:
	herc_init();
	break;
#endif
#ifdef EGG
    case EGA:
	ega_init();
        break;
#endif
#ifdef VGG
    case VGA:
	vga_init();
        break;
#endif
    default:
        break;
    }

#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )
    host_init_adaptor(video_adapter,screen_height);
    host_clear_screen();
#endif	/* !NTVDM | (NTVDM & !X86GFX) */

#ifdef EGA_DUMP
	dump_init(host_getenv( "EGA_DUMP_FILE" ), video_adapter);
#endif
}


void gvi_term IFN0()
{
    switch (video_adapter) {
#ifdef DUMB_TERMINAL
    case MDA:
        mda_term();
        break;
#endif /* DUMB_TERMINAL */
    case CGA:
#ifdef CGAMONO  
    case CGA_MONO:  
#endif
        cga_term();
        break;
#ifdef HERC
    case HERCULES:
	herc_term();
	break;
#endif
#ifdef EGG
    case EGA:
	ega_term();
	break;
#endif
#ifdef VGG
    case VGA:
	vga_term();
	break;
#endif
    case NO_ADAPTOR: /* Do nothing if video_adaptor not initialised */
	break;
    default:
#ifndef PROD
        fprintf(trace_file, "gvi_term: invalid video adaptor: %d\n",
                video_adapter);
#endif
	break;
    }

#ifdef GORE
    term_gore_update();
#endif /* GORE */
}
#endif  //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\vga_mode.c ===
#include "insignia.h"
#include "host_def.h"
/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DESIGNER		: S.Frost

REVISION HISTORY	:
First version		: Feb/Mar 1990. Simon Frost

SOURCE FILE NAME	: vga_mode.c

PURPOSE			: To decide which mode the VGA is in according to
			  variables set via vga_ports.c and to choose the
			  appropriate update and paint routines accordingly.
			  Borrows heavily from ega_mode.c...

static char SccsID[]="@(#)vga_mode.c	1.35 06/01/95 Copyright Insignia Solutions Ltd.";




[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

	INCLUDE FILE : ega_mode.gi

[1.1    INTERMODULE EXPORTS]

	PROCEDURES() :	choose_vga_display_mode

	DATA 	     :	uses EGA_GRAPH.display_state which is set via vga_ports.c, to
			determine what memory organisation the display side is in, and
			hence what sort of update and paint routines to use.

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]

	STRUCTURES/TYPEDEFS/ENUMS:

uses	enum DISPLAY_STATE which is declared in ega_graph.pi.

uses	EGA_GRAPH structure for global variables set by the ports and
	used by the display.

-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
     (not o/s objects or standard libs)

	PROCEDURES() : vote_vga_mode()
			host_set_paint_routine(DISPLAY_MODE)

	DATA 	     : EGA_GRAPH struct.

-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

[1.4.2 EXPORTED OBJECTS]

=========================================================================
PROCEDURE	  : 	choose_vga_display_mode

PURPOSE		  : 	To decide which memory organisation is being used by
			the vga, and to pick the best update and paint routines
			accordingly.  The paint routines are host specific,
			and so the memory organisation is indicated by an enum
			(called DISPLAY_MODE), describing each sort of memory
			organisation.

PARAMETERS	  :	none

GLOBALS		  :	uses EGA_GRAPH struct, specially display_state to
			decide which mode is being used.

=========================================================================


/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]						*/


#ifndef REAL_VGA
#ifdef	VGG

/* [3.1.1 #INCLUDES]                                                    */

#include	"xt.h"
#include	"error.h"
#include	"config.h"
#include	"gvi.h"
#include	"gmi.h"
#include	"gfx_upd.h"
#include	"egagraph.h"
#include	"vgaports.h"
#include	"egacpu.h"
#include	"egaports.h"
#include	"debug.h"
#include	"host_gfx.h"

#ifdef GORE
#include	"gore.h"
#endif /* GORE */

/* [3.1.2 DECLARATIONS]                                                 */

/* [3.2 INTERMODULE EXPORTS]						*/

#include	"egamode.h"

#ifdef GISP_SVGA
#include HostHwVgaH
#include "hwvga.h"
#endif /* GISP_SVGA */

/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]						*/

/* [5.1.1 #DEFINES]							*/
#ifdef SEGMENTATION
/*
 * The following #define specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_VGA.seg"
#endif

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]			*/

/* [5.1.3 PROCEDURE() DECLARATIONS]					*/

/*
=========================================================================
PROCEDURE	  : 	set_up_screen_ptr()

PURPOSE		  : 	Decide which plane the information must come from for displaying

PARAMETERS	  :	none

GLOBALS		  :	uses EGA_GRAPH struct, plane_mask to decide which planes are enabled

=========================================================================
*/

LOCAL VOID
set_up_screen_ptr()
{
#if defined(NEC_98)
        set_screen_ptr(0x00000L);
#else   //NEC_98
	if( get_chain4_mode() )
	{
		if (all_planes_enabled())
			set_screen_ptr(EGA_plane0123);
		else
			assert0(NO,"No planes enabled for chain-4 mode\n");
	}
	else
		if( get_memory_chained() )
		{
			if( plane01_enabled() )
				set_screen_ptr(EGA_plane01);
			else
				if( plane23_enabled() )
					set_screen_ptr(EGA_plane23);
				else
					assert0(NO,"No planes enabled for chain mode");
		}
		else
			set_screen_ptr(EGA_planes);
#endif  //NEC_98
}

/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS 					*/

IMPORT	DISPLAY_MODE	choose_mode[];

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]				*/

#ifdef GISP_SVGA
	    extern void mon_text_update();
#endif /* GISP_SVGA */

static	void	set_update_routine(mode)
DISPLAY_MODE	mode;
{
	static int last_height = 200;

	if (last_height != get_screen_height()) {
		last_height = get_screen_height();
	}
	note_display_state1("VGA set_update_routine(%s)", get_mode_string(mode) );

#if defined(NTVDM) && defined(MONITOR)
	{
#if defined(NEC_98)
            extern void NEC98_text_update();
            set_gfx_update_routines( NEC98_text_update, SIMPLE_MARKING, NO_SCROLL );
            return;

#else   //NEC_98
	    extern void mon_text_update(void);

	    switch (mode)
	    {
	    case EGA_TEXT_40_SP_WR:
	    case EGA_TEXT_80_SP_WR:
	    case CGA_TEXT_40_SP_WR:
	    case CGA_TEXT_80_SP_WR:
	    case EGA_TEXT_40_SP:
	    case EGA_TEXT_80_SP:
	    case CGA_TEXT_40_SP:
	    case CGA_TEXT_80_SP:
	    case EGA_TEXT_40_WR:
	    case EGA_TEXT_80_WR:
	    case EGA_TEXT_40:
	    case EGA_TEXT_80:
	    case CGA_TEXT_40_WR:
	    case CGA_TEXT_80_WR:
	    case CGA_TEXT_40:
	    case CGA_TEXT_80:
	    case TEXT_40_FUN:
	    case TEXT_80_FUN:
		set_gfx_update_routines(mon_text_update, SIMPLE_MARKING,
					TEXT_SCROLL);
		return;
	    default:
		break;
	}

#endif  //NEC_98
	}

#endif	/* MONITOR */
/* NTVDM monitor: All text monitor cases dealt with. For frozen graphics */
/* now fall through to do decode to correct paint routines per mode */

#ifndef NEC_98
	switch (mode) {
		case EGA_TEXT_40_SP_WR:
		case EGA_TEXT_80_SP_WR:
		case CGA_TEXT_40_SP_WR:
		case CGA_TEXT_80_SP_WR:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = TEXT;
			set_gfx_update_routines( mon_text_update, SIMPLE_MARKING, NO_SCROLL );
#else /* GISP_SVGA */
			set_gfx_update_routines( ega_wrap_split_text_update, SIMPLE_MARKING, NO_SCROLL );
#endif /* GISP_SVGA */
			host_update_fonts();
			break;
		case EGA_TEXT_40_SP:
		case EGA_TEXT_80_SP:
		case CGA_TEXT_40_SP:
		case CGA_TEXT_80_SP:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = TEXT;
			set_gfx_update_routines( mon_text_update, SIMPLE_MARKING, NO_SCROLL );
#else /* GISP_SVGA */
			set_gfx_update_routines( ega_split_text_update, SIMPLE_MARKING, NO_SCROLL );
#endif /* GISP_SVGA */
			host_update_fonts();
			break;
		case EGA_TEXT_40_WR:
		case EGA_TEXT_80_WR:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = TEXT;
			set_gfx_update_routines( mon_text_update, SIMPLE_MARKING, NO_SCROLL );
#else /* GISP_SVGA */
			set_gfx_update_routines( ega_wrap_text_update, SIMPLE_MARKING, NO_SCROLL );
#endif /* GISP_SVGA */
			host_update_fonts();
			break;
		case EGA_TEXT_40:
		case EGA_TEXT_80:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
#if defined(NTVDM) && !defined(MONITOR)   /* Only get here for NTVDM Riscs */
			{
	    		    extern void jazz_text_update(void);
	    		    set_gfx_update_routines( jazz_text_update, SIMPLE_MARKING, TEXT_SCROLL );
			}
#else
#ifdef GISP_SVGA
			videoInfo.modeType = TEXT;
			set_gfx_update_routines( mon_text_update, SIMPLE_MARKING, TEXT_SCROLL );
#else /* GISP_SVGA */
			set_gfx_update_routines( ega_text_update, SIMPLE_MARKING, TEXT_SCROLL );
#endif /* GISP_SVGA */
			host_update_fonts();
#endif	/* NTVDM */
			break;
		case CGA_TEXT_40_WR:
		case CGA_TEXT_80_WR:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = TEXT;
#endif /* GISP_SVGA */
			set_gfx_update_routines( ega_wrap_text_update, SIMPLE_MARKING, NO_SCROLL );
			host_update_fonts();
			break;
		case CGA_TEXT_40:
		case CGA_TEXT_80:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = TEXT;
#endif /* GISP_SVGA */
			assert1( get_screen_height() == 200, "screen height %d for text mode", get_screen_height() );
			set_gfx_update_routines( text_update, SIMPLE_MARKING, TEXT_SCROLL );
			host_update_fonts();
			break;
		case CGA_MED:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
			videoInfo.numPlanes = 2;
#endif /* GISP_SVGA */
			set_gfx_update_routines( cga_med_graph_update, CGA_GRAPHICS_MARKING, CGA_GRAPH_SCROLL );
			break;
		case CGA_HI:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
			videoInfo.numPlanes = 4;
#endif /* GISP_SVGA */
			set_gfx_update_routines( cga_hi_graph_update, CGA_GRAPHICS_MARKING, CGA_GRAPH_SCROLL );
			break;
		case EGA_HI_WR:
		case EGA_MED_WR:
		case EGA_LO_WR:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
			videoInfo.numPlanes = 4;
#endif /* GISP_SVGA */
			set_gfx_update_routines( ega_wrap_graph_update, EGA_GRAPHICS_MARKING, NO_SCROLL );
			break;
		case EGA_HI:
		case EGA_MED:
		case EGA_LO:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
			videoInfo.numPlanes = 4;
#endif /* GISP_SVGA */
#ifdef GORE
			if (get_256_colour_mode())
			    set_gfx_update_routines( process_object_list, EGA_GRAPHICS_MARKING, VGA_GRAPH_SCROLL );
			else
			    set_gfx_update_routines( process_object_list, EGA_GRAPHICS_MARKING, EGA_GRAPH_SCROLL );
#else
			if (get_256_colour_mode())
			    set_gfx_update_routines( vga_graph_update, EGA_GRAPHICS_MARKING, VGA_GRAPH_SCROLL );
			else
			    set_gfx_update_routines( ega_graph_update, EGA_GRAPHICS_MARKING, EGA_GRAPH_SCROLL );
#endif /* GORE */
			break;
		case EGA_HI_SP_WR:
		case EGA_MED_SP_WR:
		case EGA_LO_SP_WR:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
			videoInfo.numPlanes = 4;
#endif /* GISP_SVGA */
			set_gfx_update_routines( ega_wrap_split_graph_update, EGA_GRAPHICS_MARKING, NO_SCROLL );
			break;

		case EGA_HI_SP:
		case EGA_MED_SP:
		case EGA_LO_SP:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
#endif /* GISP_SVGA */
			if (get_256_colour_mode())
				set_gfx_update_routines(vga_split_graph_update,
					EGA_GRAPHICS_MARKING, NO_SCROLL);
			else
				set_gfx_update_routines(ega_split_graph_update,
					EGA_GRAPHICS_MARKING, NO_SCROLL);
			break;

		case TEXT_40_FUN:
		case TEXT_80_FUN:
			assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
#ifdef GISP_SVGA
			videoInfo.modeType = TEXT;
#endif /* GISP_SVGA */
			do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
			set_gfx_update_routines( text_update, SIMPLE_MARKING, NO_SCROLL );
			host_update_fonts();
			break;
		case CGA_HI_FUN:
			assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
#endif /* GISP_SVGA */
			do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
			set_gfx_update_routines( cga_hi_graph_update, CGA_GRAPHICS_MARKING, NO_SCROLL );
			break;
		case CGA_MED_FUN:
			assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
			videoInfo.numPlanes = 4;
#endif /* GISP_SVGA */
			do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
			set_gfx_update_routines( cga_med_graph_update, CGA_GRAPHICS_MARKING, NO_SCROLL );
			break;
		case EGA_HI_FUN:
		case EGA_MED_FUN:
		case EGA_LO_FUN:
			assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
			videoInfo.numPlanes = 4;
#endif /* GISP_SVGA */
			do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
#ifdef GORE
			set_gfx_update_routines( process_object_list, EGA_GRAPHICS_MARKING, NO_SCROLL );
#else
			set_gfx_update_routines( ega_graph_update, EGA_GRAPHICS_MARKING, NO_SCROLL );
#endif /* GORE */
			break;
		case DUMMY_FUN:
			assert0(NO,"Using the dummy mode!!");
#ifdef GISP_SVGA
			videoInfo.modeType = UNIMP;
#endif /* GISP_SVGA */
			set_gfx_update_routines( dummy_calc, SIMPLE_MARKING, NO_SCROLL );
			break;
		default:
			assert1(NO,"Bad display mode %d", (int) mode );
#ifdef GISP_SVGA
			videoInfo.modeType = UNIMP;
#endif /* GISP_SVGA */
			break;
	}
#endif  //NEC_98
}


/*
7.INTERMODULE INTERFACE IMPLEMENTATION :

[7.1 INTERMODULE DATA DEFINITIONS]				*/

/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]				*/



boolean	choose_vga_display_mode()
{
#ifndef NEC_98
	DISPLAY_MODE	mode;

	note_entrance0("choose vga display mode");

	/*
	 * offset_per_line depends upon whether chained addressing is being
	 * used. This is because we interleave the planes, rather than
	 * anything the EGA does.
	 */

	if( get_chain4_mode() )
	{
		set_offset_per_line_recal(get_actual_offset_per_line() << 2);
	}
	else
		if( get_memory_chained() )
		{
			set_offset_per_line_recal(get_actual_offset_per_line() << 1);
		}
		else
		{
			set_offset_per_line_recal(get_actual_offset_per_line());
		}

	/*
	 * It is possible that the display hardware will wrap the plane addressing. This occurs
	 * when the screen_start plus the screen_length are longer than the plane length.
	 * When in chained mode there is two planes length before wrapping occurs.
	 * When in chain 4 mode there is 4 planes length before wrapping occurs.
	 *
	 * V7VGA: No wrapping can occur with either of the sequential chain variants.
	 */

#ifdef V7VGA
	if( !( get_seq_chain4_mode() || get_seq_chain_mode() ))
#endif /* V7VGA */
		if (get_chain4_mode() )
		{
			set_screen_can_wrap( (get_screen_start()<<2)
						+ get_screen_length() > 4*EGA_PLANE_DISP_SIZE );
		}
		else
			if ( get_memory_chained() )
			{
				set_screen_can_wrap( (get_screen_start()<<1)
							+ get_screen_length() > 2*EGA_PLANE_DISP_SIZE );
			}
			else
			{
				set_screen_can_wrap( get_screen_start()
							+ get_screen_length() > EGA_PLANE_DISP_SIZE );
			}

	/*
	 * split screen comes into operation when screen_split is less than screen height
	 * split screen used is used as part of munge_index.
	 */

	set_split_screen_used( get_screen_split() < get_screen_height() );

	/*
	 * For the purposes of choosing a mode set up boolean values for chars per line (to help
	 * select the correct text mode), and screen height (to select EGA resolution).
	 */

	set_200_scan_lines( (get_screen_height()/get_pc_pix_height()) == 200 );

	/*
	 * Set up the appropriate update routine according to the memory organisation selected
	 * and return an indication of whether more than 1 plane can be used by the display.
	 *
	 * Note that in chained mode plane01 is considered to be one plane. Similarly for plane23
	 *
	 * We have to be careful that a nasty program, such as EGA-PICS, hasn't set up a ridiculously big
	 * screen size for the CGA modes (presumably caused by us being unlucky when the timer tick goes off).
	 */
	if(is_it_cga() && get_screen_length() > 0x4000)
#ifdef V7VGA
		/* For the 2 & 4 colour modes 63h & 64h */
		mode = EGA_HI;
#else
		mode = DUMMY_FUN;
#endif /* V7VGA */
	else
		mode = choose_mode[get_munged_index()];

	/*
	 * Now set up screen pointers appropriately.
	 */

	set_up_screen_ptr();

	set_update_routine(mode);

	/*
	 * set up the paint routine to correspond with the memory organisation and the update routine
	 * (this bit is host specific)
	 */

	host_set_paint_routine(mode,get_screen_height());

	/*
	 * The screen needs refreshing, because the update and paint routines have changed.
	 * Indicate to the update routines that the next time they are called, they must update
	 * the whole screen
	 */

	screen_refresh_required();
#endif  //NEC_98
	return TRUE;
}

#endif /* EGG */
#endif /* REAL_VGA */

#if defined(NEC_98)

// NEC98 GARAPHIC UPDATE LOGIC

extern  void    NEC98_graph_update();
extern  void    NEC98_text_graph_update();
extern  void    NEC98_nothing_update();
extern  void    NEC98_nothing_upgrap();
extern  BOOL    compatible_font;
BOOL    select_disp_nothing;
BOOL    once_pal;

boolean choose_NEC98_graph_mode(void)
{
        DISPLAY_MODE    mode;

        select_disp_nothing = FALSE ;
        once_pal = FALSE ;
        if( NEC98GLOBS->read_bank & 1 ){
                set_gvram_ptr ( NEC98GLOBS->gvram_p31_ptr  );
                set_gvram_copy( NEC98GLOBS->gvram_p31_copy );
        }else{
                set_gvram_ptr ( NEC98GLOBS->gvram_p30_ptr  );
                set_gvram_copy( NEC98GLOBS->gvram_p30_copy );
        }
        if( NEC98Display.ggdcemu.lr == 1 ){
                set_gvram_start( (int)(NEC98Display.ggdcemu.sad1*2) );
        }else{
                set_gvram_start( 0x00000000 );
        }
        set_gvram_width( 80 );

        if( get_char_height() == 20 ){
                set_text_lines(20);
        }else{
                set_text_lines(25);
        }

        if( NEC98Display.modeff.dispenable  == FALSE || (NEC98Display.crt_on  == FALSE &&
                 NEC98Display.ggdcemu.startstop  == FALSE ))
        {
                set_gfx_update_routines( NEC98_nothing_upgrap, SIMPLE_MARKING, NO_SCROLL );
                select_disp_nothing = TRUE ;
                mode = NEC98_T25L_G400 ;
                host_set_paint_routine(mode,get_screen_height()) ;
        }else{
                if( NEC98Display.crt_on == TRUE && NEC98Display.ggdcemu.startstop == FALSE )
                {
                set_gfx_update_routines( NEC98_text_update, SIMPLE_MARKING, NO_SCROLL );
                        if( get_char_height() == 20 ){
                                mode = NEC98_TEXT_20L;
                        }else{
                                mode = NEC98_TEXT_25L;
                        }
                }else if( NEC98Display.crt_on  == FALSE && NEC98Display.ggdcemu.startstop == TRUE )
                {
                set_gfx_update_routines( NEC98_graph_update, SIMPLE_MARKING, NO_SCROLL );
                        if( NEC98Display.ggdcemu.lr == 1 ){
                                if(NEC98Display.modeff.graph88==TRUE){
                                        mode = NEC98_GRAPH_200_SLT;
                                }else{
                                        mode = NEC98_GRAPH_200;
                                }
                                set_gvram_length( 0x4000 );
                                set_gvram_height( 200 );
                                set_line_per_char( 200 / get_text_lines());
                        }else{
                                mode = NEC98_GRAPH_400 ;
                                set_gvram_length( 0x8000 );
                                set_gvram_height( 400 );
                                set_line_per_char( 400 / get_text_lines());
                        }
                }else{
                set_gfx_update_routines( NEC98_text_graph_update, SIMPLE_MARKING, NO_SCROLL );
                        if( NEC98Display.ggdcemu.lr==1 ){
                                if(get_char_height()==20){
                                        if(NEC98Display.modeff.graph88==TRUE){
                                                mode = NEC98_T20L_G200_SLT ;
                                        }else{
                                                mode = NEC98_T20L_G200 ;
                                        }
                                        set_line_per_char(10);
                                }else{
                                        if(NEC98Display.modeff.graph88==TRUE){
                                                mode = NEC98_T25L_G200_SLT ;
                                        }else{
                                                mode = NEC98_T25L_G200 ;
                                        }
                                        set_line_per_char(8);
                                }
                                set_gvram_length(0x4000);
                                set_gvram_height(200)   ;
                        }else{
                                if(get_char_height()==20){
                                        mode = NEC98_T20L_G400 ;
                                        set_line_per_char(20);
                                }else{
                                        mode = NEC98_T25L_G400 ;
                                        set_line_per_char(16);
                                }
                                set_gvram_length(0x8000);
                                set_gvram_height(400)   ;
                        }
                }
                host_set_paint_routine(mode,get_screen_height()) ;
                set_gvram_scan((get_gvram_width()*get_gvram_height())/get_screen_height());
                set_screen_length(get_offset_per_line()*get_screen_height()/get_char_height());
        }
        screen_refresh_required() ;
        return(TRUE);
}


boolean choose_NEC98_display_mode(void)
{
        DISPLAY_MODE mode;

        select_disp_nothing = FALSE ;
        once_pal = FALSE ;

        if( get_char_height() == 20 ){
                set_text_lines(20);
        }else{
                set_text_lines(25);
        }

        if( NEC98Display.modeff.dispenable == FALSE ||  NEC98Display.crt_on == FALSE )
        {
                if( compatible_font == FALSE ) set_crt_on(FALSE);
                set_gfx_update_routines( NEC98_nothing_update, SIMPLE_MARKING, NO_SCROLL );
                select_disp_nothing = TRUE;
                if( get_char_height() == 20 ){
                        mode = NEC98_TEXT_20L;
                }else{
                        mode = NEC98_TEXT_25L;
                }
        }else{
                if( compatible_font == FALSE ) set_crt_on(TRUE);
            set_gfx_update_routines( NEC98_text_update, SIMPLE_MARKING, NO_SCROLL );
                if( get_char_height() == 20 ){
                        mode = NEC98_TEXT_20L;
                }else{
                        mode = NEC98_TEXT_25L;
                }
        }
        if( compatible_font == FALSE )  mode = NEC98_TEXT_80;
        set_gvram_width( 80 );
        set_screen_length(get_offset_per_line()*get_screen_height()/get_char_height());
        host_set_paint_routine(mode,get_screen_height());
        screen_refresh_required();
        return(TRUE);
}
#endif  //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\vga_prts.c ===
#include "insignia.h"
#include "host_def.h"
/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DOCUMENT 		: name and number

RELATED DOCS		: include all relevant references

DESIGNER		:

REVISION HISTORY	:
First version		: February 1990, S. Frost

SUBMODULE NAME		: vga		

SOURCE FILE NAME	: vga_ports.c

PURPOSE			: emulation of VGA registers (ports).
			  Calls lower levels of the VGA emulation (or EGA
			  emulation) to do the real work.

SccsID[]="@(#)vga_ports.c	1.67 07/18/94 Copyright Insignia Solutions Ltd.";


[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

	INCLUDE FILE :

[1.1    INTERMODULE EXPORTS]

	PROCEDURES() :
			VOID vga_init()
			VOID vga_term()
			VOID vga_seq_inb()
			VOID vga_crtc_outb()
			VOID vga_crtc_inb()
			VOID vga_gc_outb()
			VOID vga_gc_inb()
			VOID vga_ac_outb()
			VOID vga_ac_inb()
			VOID vga_misc_outb()
			VOID vga_misc_inb()
			VOID vga_feat_outb()
			VOID vga_feat_inb()
			VOID vga_ipstat0_inb()
			VOID vga_dac_outb()
			VOID vga_dac_inb()
			LONG vga_get_line_compare()	(* hunter only *)
			LONG vga_get_max_scan_lines()	(* hunter only *)
	DATA 	     :	

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]
-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
     (not o/s objects or standard libs)

	PROCEDURES() :
			io_define_inb
			io_define_outb
			io_redefine_inb
			io_redefine_outb
			io_connect_port
			io_disconnect_port
			flag_mode_change_required()
			set_index_state()
			in_index_state()

	DATA 	     : 	give name, and source module name

-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

DATA OBJECTS	  :	specify in following procedure descriptions
			how these are accessed (read/modified)

FILES ACCESSED    :	NONE

DEVICES ACCESSED  :	NONE

SIGNALS CAUGHT	  :	NONE

SIGNALS ISSUED	  :	NONE


[1.4.2 EXPORTED OBJECTS]
=========================================================================
PROCEDURE	  : 	vga_init

PURPOSE		  : 	initialize VGA.

PARAMETERS	  :	none

GLOBALS		  :	none

DESCRIPTION	  : 	establish vga ports.
			initialize vga code to sensible state.

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_term

PURPOSE		  : 	terminate VGA.

PARAMETERS	  :	none

GLOBALS		  :	none

DESCRIPTION	  : 	remove vga ports.
			free up allocated memory etc.

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_seq_inb((io_addr) port, (half_word) *value)

PURPOSE		  : 	deal with an attempt to read a byte from one of the
			sequencers's register ports, and gets info from
			appropriate vga sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	pointer to memory byte where value read from port should go.

GLOBALS		  :	none
DESCRIPTION	  : 	
ERROR INDICATIONS :	none.
ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_crtc_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to the sequencer chip's ports, and pass
			appropriate info to vga sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_crtc_inb((io_addr) port, (half_word) *value)

PURPOSE		  : 	deal with an attempt to read a byte from one of the crtc's register ports,
			and gets info from appropriate vga sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	pointer to memory byte where value read from port should go.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_gc_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to the graphics controller chip's ports,
			and pass appropriate info to ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_gc_inb((io_addr) port, (half_word) *value)

PURPOSE		  : 	deal with an attempt to read a byte from one of the
			graphics controller's register ports, and gets info from
			appropriate vga sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	pointer to memory byte where value read from port should go.

GLOBALS		  :	none
DESCRIPTION	  : 	
ERROR INDICATIONS :	none.
ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_ac_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to the attribute controller chip's ports, and pass
			appropriate info to vga sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_ac_inb((io_addr) port, (half_word) *value)

PURPOSE		  : 	deal with an attempt to read a byte from one of the
			attribute controller's register ports, and gets info
			from appropriate vga sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	pointer to memory byte where value read from port should go.

GLOBALS		  :	none
DESCRIPTION	  : 	
ERROR INDICATIONS :	none.
ERROR RECOVERY	  :	none.
=========================================================================
=========================================================================
PROCEDURE	  : 	vga_misc_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to the miscellaneous register's port, and pass
			appropriate info to ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_ipstat0_inb((io_addr) port, (half_word) *value)

PURPOSE		  : 	deal with an attempt to read a byte from the input status register 0 port,
			and gets info from appropriate ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	pointer to memory byte where value read from port should go.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_dac_inb((io_addr) port, (half_word) *value)

PURPOSE		  : 	deal with an attempt to read a byte from one of the
			DAC's register ports, and gets info from appropriate
			vga sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	pointer to memory byte where value read from port should go.

GLOBALS		  :	none
DESCRIPTION	  : 	
ERROR INDICATIONS :	none.
ERROR RECOVERY	  :	none.
=========================================================================
=========================================================================
PROCEDURE	  : 	vga_dac_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to one of the DAC register
			ports, and pass appropriate info to ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none
DESCRIPTION	  : 	
ERROR INDICATIONS :	none.
ERROR RECOVERY	  :	none.
=========================================================================


/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]						*/

/* [3.1.1 #INCLUDES]                                                    */

#ifndef REAL_VGA	/* ega port handling moved to host for REAL_VGA */
#ifdef VGG

#include	"xt.h"
#include	CpuH
#include	"debug.h"
#include  	"timer.h"
/* both timer.h & gvi.h define HIGH & LOW - ensure we get gvi definitions */
#undef HIGH
#undef LOW
#include	"sas.h"
#include	"gmi.h"
#include	"gvi.h"
#include	"ios.h"
#include  	"ica.h"
#include  	"gfx_upd.h"
#include	"egacpu.h"
#include	"egagraph.h"
#include	"video.h"
#include	"egaread.h"
#include	"egamode.h"
#include	"vgaports.h"
#include	"error.h"
#include	"config.h"

#include	"host_gfx.h"

/* [3.1.2 DECLARATIONS]                                                 */

/* [3.2 INTERMODULE EXPORTS]						*/

#include	"egaports.h"

#ifdef GISP_SVGA
#include "hwvgaio.h"
#endif 	/* GISP_SVGA */

/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]						*/

VOID vote_vga_mode IPT0();

/* [5.1.1 #DEFINES]							*/
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_VGA.seg"
#endif


/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]			*/
#ifdef V7VGA
GLOBAL struct extensions_controller extensions_controller;
#endif /* V7VGA */
GLOBAL struct crt_controller crt_controller;
GLOBAL struct sequencer sequencer;
GLOBAL struct attribute_controller attribute_controller;
GLOBAL struct graphics_controller graphics_controller;

/* Registers not contained in an LSI device */

GLOBAL MISC_OUTPUT_REG	miscellaneous_output_register;

GLOBAL FEAT_CONT_REG	feature_control_register;

GLOBAL INPUT_STAT_REG0	input_status_register_zero;

GLOBAL INPUT_STAT_REG1	input_status_register_one;

typedef	enum { DAC_RED, DAC_GREEN, DAC_BLUE }	RGB;
LOCAL	RGB 	DAC_rgb_state = DAC_RED;
LOCAL	byte	DAC_wr_addr;
LOCAL	byte	DAC_rd_addr;
LOCAL	byte	DAC_state;

/* 31.3.92 MG For windows 3.1 we must emulate the DAC correctly, storing
   6 or 8 bit data depending on the value in the video-7 C1 extension
   register. */

GLOBAL	byte	DAC_data_mask=0x3f;
#ifdef V7VGA
GLOBAL	int	DAC_data_bits=6;
#endif

byte	crtc_0_7_protect	= FALSE;
#ifdef V7VGA
byte	crtc_0_8_protect	= FALSE;
byte	crtc_9_b_protect	= FALSE;
byte	crtc_c_protect	= FALSE;
#endif /* V7VGA */


IMPORT half_word bg_col_mask; /* Used to work out the background colour */

VOID vga_ipstat1_inb IPT2(io_addr,port,half_word *,value);

/* Declarations for new sequencer code */
VOID vga_seq_outb_index IPT2(io_addr,port,half_word,value);
VOID vga_seq_clock IPT2(io_addr,port,half_word,value);
VOID vga_seq_char_map IPT2(io_addr,port,half_word,value);
VOID vga_seq_mem_mode IPT2(io_addr,port,half_word,value);
#ifdef V7VGA
IMPORT VOID vga_seq_extn_control IPT2(io_addr,port,half_word,value);
IMPORT VOID vga_extn_outb IPT2(io_addr,port,half_word,value);
IMPORT VOID vga_extn_inb IPT2(io_addr,port,half_word *,value);
#endif /* V7VGA */
VOID vga_seq_inb IPT2(io_addr,port,half_word *,value);
/* Same as EGA */
VOID vga_seq_map_mask IPT2(io_addr,port,half_word,value);

IMPORT VOID (*ega_seq_regs[]) IPT2(io_addr, port, half_word, value);
IMPORT VOID ega_seq_reset IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_seq_clock IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_seq_map_mask IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_seq_char_map IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_seq_mem_mode IPT2(io_addr,port,half_word,value);

/* Declarations for VGA graphics controller code */
/* VGA differing versions */
VOID vga_gc_mode IPT2(io_addr,port,half_word,value);
VOID vga_gc_inb IPT2(io_addr,port,half_word *,value);
VOID vga_gc_outb IPT2(io_addr,port,half_word,value);
/* Same as EGA but needed as static struct has changed - shame */
VOID vga_gc_outb_index IPT2(io_addr,port,half_word,value);
VOID vga_gc_outw IPT2(io_addr,port,word,value);
VOID vga_gc_set_reset IPT2(io_addr,port,half_word,value);
VOID vga_gc_enable_set IPT2(io_addr,port,half_word,value);
VOID vga_gc_compare IPT2(io_addr,port,half_word,value);
VOID vga_gc_rotate IPT2(io_addr,port,half_word,value);
VOID vga_gc_read_map IPT2(io_addr,port,half_word,value);
VOID vga_gc_misc IPT2(io_addr,port,half_word,value);
VOID vga_gc_dont_care IPT2(io_addr,port,half_word,value);
VOID vga_gc_mask IPT2(io_addr,port,half_word,value);
VOID vga_gc_mask_ff IPT2(io_addr,port,half_word,value);


/* extern decls to put redirection array back */
IMPORT VOID (*ega_gc_regs[]) IPT2(io_addr,port,half_word,value);
#ifndef A2CPU
IMPORT VOID (*ega_gc_regs_cpu[]) IPT2(io_addr,port,half_word,value);
#endif
IMPORT VOID ega_gc_set_reset IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_enable_set IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_compare IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_rotate IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_read_map IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_mode IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_misc IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_set_reset IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_dont_care IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_mask_ff IPT2(io_addr,port,half_word,value);

IMPORT VOID _vga_gc_outb_index IPT2(io_addr,port,half_word,value);
IMPORT VOID _ega_gc_outb_mask IPT2(io_addr,port,half_word,value);
IMPORT VOID _ega_gc_outb_mask_ff IPT2(io_addr,port,half_word,value);

/* Declarations for VGA DAC code */
VOID vga_dac_inb IPT2(io_addr,port,half_word *,value);
VOID vga_dac_outb IPT2(io_addr,port,half_word,value);
VOID vga_dac_data_outb IPT2(io_addr,port,half_word,value);
VOID vga_dac_data_inb IPT2(io_addr,port,half_word *,value);

VOID vga_ac_inb IPT2(io_addr,port,half_word *,value);
VOID vga_ac_outb IPT2(io_addr,port,half_word,value);
VOID vga_crtc_inb IPT2(io_addr,port,half_word *,value);
VOID vga_crtc_outb IPT2(io_addr,port,half_word,value);
VOID vga_misc_outb IPT2(io_addr,port,half_word,value);
VOID vga_misc_inb IPT2(io_addr,port,half_word *,value);
VOID vga_feat_outb IPT2(io_addr,port,half_word,value);
VOID vga_feat_inb IPT2(io_addr,port,half_word *,value);
VOID vga_ipstat0_inb IPT2(io_addr,port,half_word *,value);
/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]				*/

void set_index_state(void);
boolean in_index_state(void);

/* copy of ega routines needed to access correct copy of structs */
LOCAL VOID	do_chain_majority_decision IFN0()
{
#ifndef NEC_98
	SAVED	SHORT	current_votes=0;
	SHORT		new_votes;

	new_votes = sequencer.memory_mode.as_bfld.not_odd_or_even ? 0 : 1 ;	/* 0 - chained */
	new_votes += (SHORT)graphics_controller.mode.as_bfld.odd_or_even ;	/* 1 - chained */
	new_votes += (SHORT)graphics_controller.miscellaneous.as_bfld.odd_or_even ;	/* 1 - chained */

	if(( new_votes == 1 ) && ( current_votes > 1 ) && ( EGA_CPU.chain != CHAIN4 ))
	{
		/*
		 * Transition from chained to unchained
		 */

		EGA_CPU.chain  = UNCHAINED;
		setVideochain(EGA_CPU.chain);
		ega_read_routines_update();
		ega_write_routines_update(CHAINED);
		set_memory_chained(NO);
		flag_mode_change_required();
	}
	else
	{
		if(( new_votes > 1 ) && ( current_votes == 1 ))
		{
			/*
			 * Transition from unchained to chained
			 */

			EGA_CPU.chain = CHAIN2;
			setVideochain(EGA_CPU.chain);
			ega_read_routines_update();
			ega_write_routines_update(CHAINED);
			set_memory_chained(YES);
			flag_mode_change_required();
		}
	}

	current_votes = new_votes;
#endif  //NEC_98
}

#ifdef	NTVDM
/*
 * NTVDM uses do_new_cursor() to sync the emulation.
 */
GLOBAL VOID	do_new_cursor IFN0()
#else
LOCAL VOID	do_new_cursor IFN0()
#endif
{
#ifndef NEC_98

	note_entrance0("do_new_cursor()");

	if (crt_controller.cursor_start.as_bfld.cursor_start >= (unsigned)get_char_height() ) {
		note_entrance0("No cursor");
		set_cursor_visible(FALSE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start | 0x20,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
	else if (crt_controller.cursor_end.as_bfld.cursor_end == 0) {
		note_entrance0("cursor from start to bum");
		set_cursor_start1(0);
		set_cursor_height1(0);
		set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_height(get_char_height() - get_cursor_start());
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
	else if (crt_controller.cursor_end.as_bfld.cursor_end < crt_controller.cursor_start.as_bfld.cursor_start) {
		note_entrance0("2 cursors");
		set_cursor_start1(0);
		set_cursor_height1(crt_controller.cursor_end.as_bfld.cursor_end);
		set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_height(get_char_height() - get_cursor_start());
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
	else if (crt_controller.cursor_end.as_bfld.cursor_end == crt_controller.cursor_start.as_bfld.cursor_start) {
		note_entrance0("One line cursor");
		set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_height(1);
		set_cursor_start1(0);
		set_cursor_height1(0);
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
	else if (crt_controller.cursor_end.as_bfld.cursor_end - 1 >= (unsigned)get_char_height()) {
		note_entrance0("block cursor");
		set_cursor_start(0);
		set_cursor_height(get_char_height());
		set_cursor_start1(0);
		set_cursor_height1(0);
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
	else {
		assert2(((crt_controller.cursor_end.as_bfld.cursor_end - 1) >= crt_controller.cursor_start.as_bfld.cursor_start),
				"cursor values do not match default set Start %d, End %d",
				crt_controller.cursor_end.as_bfld.cursor_end,
				crt_controller.cursor_start.as_bfld.cursor_start);
		note_entrance0("normal cursor");
		set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_height(crt_controller.cursor_end.as_bfld.cursor_end - crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_start1(0);
		set_cursor_height1(0);
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}

	if(( get_cur_y() < 0 ) ||
			((( get_cur_y() + 1 ) * get_char_height()) > get_screen_height() ))
	{
		set_cursor_visible( FALSE );
	}

	base_cursor_shape_changed();
#endif  //NEC_98
}
/*
7.INTERMODULE INTERFACE IMPLEMENTATION :

/*
[7.1 INTERMODULE DATA DEFINITIONS]				*/

PC_palette *DAC;

/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]				*/

GLOBAL UTINY *vga_gc_outb_index_addr;

#if defined(NEC_98)
extern  BOOL    video_emu_mode ;        /* NEC NEC98 PIF FILE INFORMATION */
GLOBAL VOID     NEC98_init()
{
        note_entrance0("NEC98_init");

        if( video_emu_mode ){
                choose_display_mode = choose_NEC98_graph_mode;
        }else{
                choose_display_mode = choose_NEC98_display_mode;
        }

        set_pc_pix_height(1);
        set_host_pix_height(1);

        init_NEC98_globals();

        NEC98_CPU.fun_or_protection = 1;       /* assume complicated until we know it's easy */
        NEC98GLOBS->bit_prot_mask = 0xffffffff;

        gvi_pc_low_regen  = NEC98_TEXT_P0_PTR ;
        gvi_pc_high_regen = NEC98_TEXT_P0_PTR + NEC98_REGEN_END;

        set_pix_width(1);
        set_pix_char_width(8);
        set_display_disabled(FALSE);

        set_char_height(16);
        set_screen_height(399);
        set_screen_start(0);
        set_word_addressing(YES);
        set_actual_offset_per_line(80);
        set_offset_per_line(160);       /* chained */
        set_horiz_total(80);    /* calc screen params from this and prev 3 */
        set_screen_split(511);  /* make sure there is no split screen to start with ! */

        set_prim_font_index(0);
        set_sec_font_index(0);
        set_regen_ptr(0,EGA_planes);////for Graphics

        /* prevent copyright message mysteriously disappearing */
        timer_video_enabled = TRUE;

}
#endif  //NEC_98

GLOBAL VOID	vga_init IFN0()
{
#ifndef NEC_98
	note_entrance0("vga_init");
	/*
	 * Define sequencer's ports
	 */

	ega_seq_regs[1] = FAST_FUNC_ADDR(vga_seq_clock);
	ega_seq_regs[2] = FAST_FUNC_ADDR(vga_seq_map_mask);
	ega_seq_regs[3] = FAST_FUNC_ADDR(vga_seq_char_map);
	ega_seq_regs[4] = FAST_FUNC_ADDR(vga_seq_mem_mode);
#ifdef V7VGA
	ega_seq_regs[6] = vga_seq_extn_control;
#endif /* V7VGA */

	io_define_outb(EGA_SEQ_ADAP_INDEX,vga_seq_outb_index);
	io_define_outb(EGA_SEQ_ADAP_DATA,ega_seq_reset);
        io_define_inb(EGA_SEQ_ADAP_INDEX,vga_seq_inb);
        io_define_inb(EGA_SEQ_ADAP_DATA,vga_seq_inb);
	io_connect_port(EGA_SEQ_INDEX,EGA_SEQ_ADAP_INDEX,IO_READ_WRITE);
	io_connect_port(EGA_SEQ_DATA,EGA_SEQ_ADAP_DATA,IO_READ_WRITE);

	/*
	 * Define CRTC's ports
	 */

	io_define_outb(EGA_CRTC_ADAPTOR,vga_crtc_outb);
	io_define_inb(EGA_CRTC_ADAPTOR,vga_crtc_inb);
	io_connect_port(EGA_CRTC_INDEX,EGA_CRTC_ADAPTOR,IO_READ_WRITE);
	io_connect_port(EGA_CRTC_DATA,EGA_CRTC_ADAPTOR,IO_READ_WRITE);

	/*
	 * Define Graphics Controller's ports
	 */

	ega_gc_regs[0] = FAST_FUNC_ADDR(vga_gc_set_reset);
	ega_gc_regs[1] = FAST_FUNC_ADDR(vga_gc_enable_set);
	ega_gc_regs[2] = FAST_FUNC_ADDR(vga_gc_compare);
	ega_gc_regs[3] = FAST_FUNC_ADDR(vga_gc_rotate);
	ega_gc_regs[4] = FAST_FUNC_ADDR(vga_gc_read_map);
	ega_gc_regs[5] = FAST_FUNC_ADDR(vga_gc_mode);
	ega_gc_regs[6] = FAST_FUNC_ADDR(vga_gc_misc);
	ega_gc_regs[7] = FAST_FUNC_ADDR(vga_gc_dont_care);
	ega_gc_regs[8] = FAST_FUNC_ADDR(vga_gc_mask_ff);

	vga_gc_outb_index_addr = (UTINY *) &graphics_controller.address;

	io_define_out_routines(EGA_GC_ADAP_INDEX, vga_gc_outb_index, vga_gc_outw, NULL, NULL);

#ifndef CPU_40_STYLE	/* TEMPORARY */
	Cpu_define_outb(EGA_GC_ADAP_INDEX,_vga_gc_outb_index);
#endif

	io_define_outb(EGA_GC_ADAP_DATA,ega_gc_set_reset);
	Cpu_define_outb(EGA_GC_ADAP_DATA,NULL);
#ifndef A2CPU
	ega_gc_regs_cpu[8] = NULL;
#endif

	io_define_inb(EGA_GC_ADAP_INDEX,vga_gc_inb);
	io_define_inb(EGA_GC_ADAP_DATA,vga_gc_inb);

	io_connect_port(EGA_GC_INDEX,EGA_GC_ADAP_INDEX,IO_READ_WRITE);
	io_connect_port(EGA_GC_DATA,EGA_GC_ADAP_DATA,IO_READ_WRITE);

	/*
	 * Define Attribute controller's ports
	 */

	io_define_outb(EGA_AC_ADAPTOR,vga_ac_outb);
	io_define_inb(EGA_AC_ADAPTOR,vga_ac_inb);
	io_connect_port(EGA_AC_INDEX_DATA,EGA_AC_ADAPTOR,IO_READ_WRITE);
	io_connect_port(EGA_AC_SECRET,EGA_AC_ADAPTOR,IO_READ);

	/*
	 * Define Miscellaneous register's port
	 */

	io_define_outb(EGA_MISC_ADAPTOR,vga_misc_outb);
	io_define_inb(EGA_MISC_ADAPTOR,vga_misc_inb);
	io_connect_port(EGA_MISC_REG,EGA_MISC_ADAPTOR,IO_WRITE);
	io_connect_port(VGA_MISC_READ_REG,EGA_MISC_ADAPTOR,IO_READ);

	/*
	 * Define Feature controller's port
	 */

	io_define_outb(EGA_FEAT_ADAPTOR,vga_feat_outb);
	io_define_inb(EGA_FEAT_ADAPTOR,vga_feat_inb);
	io_connect_port(EGA_FEAT_REG,EGA_FEAT_ADAPTOR,IO_WRITE);
	io_connect_port(VGA_FEAT_READ_REG,EGA_FEAT_ADAPTOR,IO_READ);

	/*
	 * Define Input Status Register 0 port
	 */

	io_define_inb(EGA_IPSTAT0_ADAPTOR,vga_ipstat0_inb);
	io_connect_port(EGA_IPSTAT0_REG,EGA_IPSTAT0_ADAPTOR,IO_READ);

	/*
	 * Define Input Status Register 1 port
	 */

	io_define_inb(EGA_IPSTAT1_ADAPTOR,vga_ipstat1_inb);
	io_connect_port(EGA_IPSTAT1_REG,EGA_IPSTAT1_ADAPTOR,IO_READ);

        /*
         * Define VGA DAC register port
         */
        io_define_inb(VGA_DAC_INDEX_PORT,vga_dac_inb);
        io_define_outb(VGA_DAC_INDEX_PORT,vga_dac_outb);
        io_connect_port(VGA_DAC_MASK,VGA_DAC_INDEX_PORT,IO_READ_WRITE);
        io_connect_port(VGA_DAC_RADDR,VGA_DAC_INDEX_PORT,IO_READ_WRITE);
        io_connect_port(VGA_DAC_WADDR,VGA_DAC_INDEX_PORT,IO_READ_WRITE);
        io_define_inb(VGA_DAC_DATA_PORT,vga_dac_data_inb);
        io_define_outb(VGA_DAC_DATA_PORT,vga_dac_data_outb);
        io_connect_port(VGA_DAC_DATA,VGA_DAC_DATA_PORT,IO_READ_WRITE);

	/*
	 * Initialise internals of VGA
	 * +++++++++++++++++++++++++++
	 */

	choose_display_mode = choose_vga_display_mode;

	miscellaneous_output_register.as.abyte = 0;

	set_pc_pix_height(1); /* set by bit 7 of the crtc max scanline reg */
	set_host_pix_height(1);

	/* Initialize address map */

	graphics_controller.miscellaneous.as.abyte = 0;
	graphics_controller.read_map_select.as_bfld.map_select = 0;

	/* Looking for bright white */

	graphics_controller.color_compare.as_bfld.color_compare = 0xf;

	/* All planes significant */

	graphics_controller.color_dont_care.as_bfld.color_dont_care = 0xf;

	/* Initialise palette source */

	attribute_controller.address.as_bfld.palette_address_source = 1;

	/* Initialise crtc screen height fields and set screen height to be consistent */

	crt_controller.vertical_display_enable_end = 0;
	crt_controller.crtc_overflow.as_bfld.vertical_display_enab_end_bit_8 = 0;
	crt_controller.crtc_overflow.as_bfld.vertical_display_enab_end_bit_9 = 0;
	/* JOKER: Avoid video BIOS dividing by zero.. */
	crt_controller.horizontal_display_end = (IU8)400;
	set_screen_height(0);

	init_vga_globals();
	EGA_CPU.fun_or_protection = 1;	/* assume complicated until we know it's easy */

	setVideobit_prot_mask(0xffffffff);

#ifdef V7VGA
	/* Initialise V7VGA Extensions Registers */
	extensions_controller.pointer_pattern = 0xff;
	extensions_controller.clock_select.as.abyte = 0;
	extensions_controller.cursor_attrs.as.abyte = 0;
	extensions_controller.emulation_control.as.abyte = 0;
	extensions_controller.masked_write_control.as_bfld.masked_write_enable = 0;
	extensions_controller.ram_bank_select.as.abyte = 0;
	extensions_controller.clock_control.as.abyte &= 0xe4;
	extensions_controller.page_select.as.abyte = 0;
	extensions_controller.compatibility_control.as.abyte &= 0x2;
	extensions_controller.timing_select.as.abyte = 0;
	extensions_controller.fg_bg_control.as.abyte &= 0xf3;
	extensions_controller.interface_control.as.abyte &= 0xe0;
	extensions_controller.foreground_latch_1 = 0;

	/* 31.3.92 MG Default to six-bit palette */

	extensions_controller.dac_control.as.abyte=0;
	DAC_data_bits=6;
#endif /* V7VGA */
	DAC_data_mask=0x3f;

	ega_write_init();
	ega_read_init();
	ega_mode_init();

	/*
	 * Some parts of input status register always return 1, so set fields accordingly
	 */
	input_status_register_zero.as.abyte = 0x70 ;

	/*
	 * set up some variables to get us going (They may have to be changed in the fullness of time)
	 */

	gvi_pc_low_regen  = CGA_REGEN_START;
	gvi_pc_high_regen = CGA_REGEN_END;

	set_pix_width(1);
	set_pix_char_width(8);
	set_display_disabled(FALSE);

	set_char_height(8);
#ifdef V7VGA
	set_screen_limit(0x20000);
#else
	set_screen_limit(0x8000);
#endif /* V7VGA */
	set_screen_start(0);
	set_word_addressing(YES);
	set_actual_offset_per_line(80);
	set_offset_per_line(160);	/* chained */
	set_horiz_total(80);	/* calc screen params from this and prev 3 */
#ifdef NTVDM
	set_screen_split(0x3FF);	/* 10 bits for VGA line compare register */
#else
	set_screen_split(511);	/* make sure there is no split screen to start with ! */
#endif

	set_prim_font_index(0);
	set_sec_font_index(0);

	set_regen_ptr(0,EGA_planes);

	/* prevent copyright message mysteriously disappearing */
	timer_video_enabled = TRUE;

#endif  //NEC_98
}

GLOBAL VOID	vga_term IFN0()
{
#ifndef NEC_98
SHORT	index;

	note_entrance0("vga_term");

	/*
	 * Disconnect sequencer's ports
	 */

	ega_seq_regs[1] = FAST_FUNC_ADDR(ega_seq_clock);
	ega_seq_regs[2] = FAST_FUNC_ADDR(ega_seq_map_mask);
	ega_seq_regs[3] = FAST_FUNC_ADDR(ega_seq_char_map);
	ega_seq_regs[4] = FAST_FUNC_ADDR(ega_seq_mem_mode);
	io_disconnect_port(EGA_SEQ_INDEX,EGA_SEQ_ADAP_INDEX);
	io_disconnect_port(EGA_SEQ_DATA,EGA_SEQ_ADAP_DATA);

	/*
	 * Disconnect CRTC's ports
	 */

	io_disconnect_port(EGA_CRTC_INDEX,EGA_CRTC_ADAPTOR);
	io_disconnect_port(EGA_CRTC_DATA,EGA_CRTC_ADAPTOR);

	/*
	 * Disconnect Graphics Controller's ports
	 */

	ega_gc_regs[0] = FAST_FUNC_ADDR(ega_gc_set_reset);
	ega_gc_regs[1] = FAST_FUNC_ADDR(ega_gc_enable_set);
	ega_gc_regs[2] = FAST_FUNC_ADDR(ega_gc_compare);
	ega_gc_regs[3] = FAST_FUNC_ADDR(ega_gc_rotate);
	ega_gc_regs[4] = FAST_FUNC_ADDR(ega_gc_read_map);
	ega_gc_regs[5] = FAST_FUNC_ADDR(ega_gc_mode);
	ega_gc_regs[6] = FAST_FUNC_ADDR(ega_gc_misc);
	ega_gc_regs[7] = FAST_FUNC_ADDR(ega_gc_dont_care);
	ega_gc_regs[8] = FAST_FUNC_ADDR(ega_gc_mask_ff);
	io_disconnect_port(EGA_GC_INDEX,EGA_GC_ADAP_INDEX);
	io_disconnect_port(EGA_GC_DATA,EGA_GC_ADAP_DATA);

	/*
	 * Disconnect Attribute controller's ports
	 */

	io_disconnect_port(EGA_AC_INDEX_DATA,EGA_AC_ADAPTOR);
	io_disconnect_port(EGA_AC_SECRET,EGA_AC_ADAPTOR);

	/*
	 * Disconnect Miscellaneous register's port
	 */

	io_disconnect_port(EGA_MISC_REG,EGA_MISC_ADAPTOR);
	io_disconnect_port(VGA_MISC_READ_REG,EGA_MISC_ADAPTOR);

	/*
	 * Disconnect Feature controller port
	 */

	io_disconnect_port(EGA_FEAT_REG,EGA_MISC_ADAPTOR);
	io_disconnect_port(VGA_FEAT_READ_REG,EGA_MISC_ADAPTOR);

	/*
	 * Disconnect Input Status Register 0 port
	 */

	io_disconnect_port(EGA_IPSTAT0_REG,EGA_IPSTAT0_ADAPTOR);

	/*
	 * Disconnect Input Status Register 1 port
	 */

	io_disconnect_port(EGA_IPSTAT1_REG,EGA_IPSTAT1_ADAPTOR);

        /*
         * Disconnect DAC ports
         */

        io_disconnect_port(VGA_DAC_MASK,VGA_DAC_INDEX_PORT);
        io_disconnect_port(VGA_DAC_RADDR,VGA_DAC_INDEX_PORT);
        io_disconnect_port(VGA_DAC_WADDR,VGA_DAC_INDEX_PORT);
        io_disconnect_port(VGA_DAC_DATA,VGA_DAC_DATA_PORT);

	/*
	 * Free internals of VGA
	 */

	/* free the font files */
	for (index = 0; index < MAX_NUM_FONTS; index++)
		host_free_font(index);

	EGA_CPU.chain = UNCHAINED;
	setVideochain(EGA_CPU.chain);
	set_chain4_mode(NO);
	EGA_CPU.doubleword = FALSE;
	set_doubleword_mode(NO);
	set_graph_shift_reg(NO);
	set_256_colour_mode(NO);

	/* Disable CPU read processing */
	ega_read_term();
	ega_write_term();
#endif  //NEC_98
}

GLOBAL VOID	vga_seq_dummy_outb IFN2(io_addr,port,half_word,value)
{
	UNUSED(port);
#ifdef PROD
	UNUSED(value);
#endif

	assert2(NO,"Output to bad seq reg %#x with data %#x\n",sequencer.address.as.abyte,value);
}

GLOBAL VOID	vga_seq_outb_index IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("vga_seq_outb_index(%x,%x)", port, value);
#ifdef V7VGA
	if (sequencer.extensions_control.as_bfld.extension_enable && (value & 0x80))
	{
		sequencer.address.as.abyte = value;
		io_redefine_inb(EGA_SEQ_ADAP_DATA, vga_extn_inb);
		io_redefine_outb(EGA_SEQ_ADAP_DATA, vga_extn_outb);
		return;
	}
	io_redefine_inb(EGA_SEQ_ADAP_DATA, vga_seq_inb);
#endif /* V7VGA */
	
	sequencer.address.as.abyte = ( value & 0x07 );

#ifndef V7VGA
	if (value > 4)
	{
		/* a bad port index value, so ignore any data sent to it */
		io_redefine_outb(EGA_SEQ_ADAP_DATA,vga_seq_dummy_outb);
		return;
	}
#endif /* !V7VGA */
	io_redefine_outb(EGA_SEQ_ADAP_DATA,ega_seq_regs[value & 0x07]);
#endif  //NEC_98
}


GLOBAL VOID	vga_seq_clock IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
	unsigned dot_clock;
	unsigned screen_off;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"seq(1,%x)\n",value);)
	note_entrance2("vga_seq_clock(%x,%x)", port, value);
	/* clock mode register */
	dot_clock = sequencer.clocking_mode.as_bfld.dot_clock;
	screen_off = sequencer.clocking_mode.as_bfld.screen_off;
	sequencer.clocking_mode.as.abyte = value;
	if (sequencer.clocking_mode.as_bfld.dot_clock != dot_clock) {
		/*
		** Switch to/from double width pixels
		*/
		if (sequencer.clocking_mode.as_bfld.dot_clock==1) {
			set_pix_width(2);
			set_double_pix_wid(YES);
			set_pix_char_width(16);
		} else {
			set_pix_width(1);
			set_double_pix_wid(NO);
			set_pix_char_width(8);
		}
		flag_mode_change_required();
	}
	if (sequencer.clocking_mode.as_bfld.screen_off != screen_off) {
	    if (sequencer.clocking_mode.as_bfld.screen_off) {
		set_display_disabled(TRUE);
		timer_video_enabled = 0;
		disable_gfx_update_routines();
	    }
	    else {
		set_display_disabled(FALSE);
		timer_video_enabled = 1;
		enable_gfx_update_routines();
		screen_refresh_required();
	    }
	}
#endif  //NEC_98
}

/* the vga supports 4 fonts maps to the ega's 4 */
GLOBAL VOID	vga_seq_char_map IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
unsigned map_selects;
FAST TINY select_a, select_b;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"seq(3,%#x)\n",value);)
	note_entrance2("vga_seq_char_map(%x,%x)", port, value);
	/* char map select reg */
	map_selects = sequencer.character_map_select.character.map_selects;
	sequencer.character_map_select.as.abyte = value;
	if (sequencer.character_map_select.character.map_selects != map_selects)
	{
		/*
		** character mapping attributes have changed.
		**
		** If fonts selected are different bit 3 of attribute byte in alpha mode
		** selects which of the two fonts to use (giving 512 chars).
		*/


		select_a = sequencer.character_map_select.as_bfld.character_map_select_a | (sequencer.character_map_select.as_bfld.ch_map_select_a_hi << 2);
		select_b = sequencer.character_map_select.as_bfld.character_map_select_b | (sequencer.character_map_select.as_bfld.ch_map_select_b_hi << 2);
		EGA_GRAPH.attrib_font_select = (select_a != select_b);
		set_prim_font_index(select_a);
		set_sec_font_index(select_b);

		host_select_fonts(get_prim_font_index(), get_sec_font_index());
		flag_mode_change_required();
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_seq_mem_mode IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
    unsigned now_chain4;

#ifdef PROD
	UNUSED(port);
#endif
    NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"seq(4,%#x)\n",value);)
    note_entrance2("vga_seq_mem_mode(%x,%x)", port, value);

    now_chain4 = sequencer.memory_mode.as_bfld.chain4;
    /* mem mode register */
    sequencer.memory_mode.as.abyte = value ;

    if( now_chain4 != sequencer.memory_mode.as_bfld.chain4 )
    {
		if( sequencer.memory_mode.as_bfld.chain4 == 0 )
		{
			EGA_CPU.chain = UNCHAINED;
			setVideochain(EGA_CPU.chain);
			set_chain4_mode(NO);
			do_chain_majority_decision();
			if (EGA_CPU.chain != CHAIN2)
			{
				ega_read_routines_update();
				ega_write_routines_update(CHAINED);
				flag_mode_change_required();
			}
		}
		else
		{
			EGA_CPU.chain = CHAIN4;
			setVideochain(EGA_CPU.chain);
			set_chain4_mode(YES);
			set_memory_chained(NO);
			ega_read_routines_update();
			ega_write_routines_update(CHAINED);
			flag_mode_change_required();
		}

    }
    else
    {
		do_chain_majority_decision();
    }

    assert1(sequencer.memory_mode.as_bfld.extended_memory == 1,
			    "Someone is trying to set extended memory to 0 (reg=%x)",value);
#endif  //NEC_98
}

GLOBAL VOID	vga_seq_inb IFN2(io_addr,port,half_word *,value)
{
#ifndef NEC_98
	note_entrance1("vga_seq_inb(%x)", port);
	if (port == EGA_SEQ_INDEX) {
	    *value = (half_word)sequencer.address.as.abyte;
	    note_entrance1("returning %x",*value);
	    return;
	}
	if (port == EGA_SEQ_DATA) {
	    switch(sequencer.address.as.abyte) {

	    case 0:
		*value = 3;
		break;
	    case 1:
		*value = (half_word)sequencer.clocking_mode.as.abyte;
		break;
	    case 2:
		*value = (half_word)getVideoplane_enable();
		break;
	    case 3:
		*value = (half_word)sequencer.character_map_select.as.abyte;
		break;
	    case 4:
		*value = (half_word)sequencer.memory_mode.as.abyte;
		break;
#ifdef V7VGA
	    case 6:
		*value = (half_word)sequencer.extensions_control.as.abyte;
		break;
#endif /* V7VGA */
	    default:
		assert1(NO,"Bad sequencer index %d\n",sequencer.address.as.abyte);
		*value = IO_EMPTY_PORT_BYTE_VALUE;
	    }
	    note_entrance1("returning %x",*value);
	}
	else {
	    assert1(NO,"Bad seq port %d",port);
	    *value = IO_EMPTY_PORT_BYTE_VALUE;
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_crtc_outb IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
	SHORT offset;
	struct
	{	/* aVOID alignment problems with casts */
		unsigned value : 8;
	} new;


	note_entrance2("vga_crtc_outb(%x,%x)", port, value);
	switch (port) {
		case 0x3d4:
			note_entrance1("New crtc index %d",value);
			crt_controller.address.as.abyte = value;
			break;
		case 0x3d5:
			note_entrance1( "Index %d", crt_controller.address.as_bfld.index );
			NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE) if (crt_controller.address.as_bfld.index != 0xe && crt_controller.address.as_bfld.index != 0xf)fprintf(trace_file,"crtc(%#x,%#x)\n",crt_controller.address.as_bfld.index,value);)
			/*
			 * We have to save all values in the VGA, even if we
			 * dont support the reg, as all values are read/write.
			 */
			switch (crt_controller.address.as_bfld.index) {
				case 0:
					note_entrance0("horiz total");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE && crtc_0_7_protect == FALSE)
#else
					if (crtc_0_7_protect == FALSE)
#endif /* V7VGA */
						crt_controller.horizontal_total = value;
					break;
				case 1:
					note_entrance0("horiz display end");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE && crtc_0_7_protect == FALSE)
#else
					if (crtc_0_7_protect == FALSE)
#endif /* V7VGA */
					{
						crt_controller.horizontal_display_end = value+1;
						if (get_256_colour_mode())
						{
							set_horiz_total(crt_controller.horizontal_display_end>>1);
						}
						else
						{
							set_horiz_total(crt_controller.horizontal_display_end);
						}
					}
					break;
				case 2:
					note_entrance0("start horiz blank");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE && crtc_0_7_protect == FALSE)
#else
					if (crtc_0_7_protect == FALSE)
#endif /* V7VGA */
						crt_controller.start_horizontal_blanking = value;
					break;
				case 3:
					note_entrance0("end horiz blank");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE && crtc_0_7_protect == FALSE)
#else
					if (crtc_0_7_protect == FALSE)
#endif /* V7VGA */
						crt_controller.end_horizontal_blanking.as.abyte = value;
					break;
				case 4:
					note_entrance0("start horiz retrace");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE && crtc_0_7_protect == FALSE)
#else
					if (crtc_0_7_protect == FALSE)
#endif /* V7VGA */
						crt_controller.start_horizontal_retrace = value;
					break;
				case 5:
					note_entrance0("end horiz retrace");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE && crtc_0_7_protect == FALSE)
#else
					if (crtc_0_7_protect == FALSE)
#endif /* V7VGA */
						crt_controller.end_horizontal_retrace.as.abyte = value;
					break;
				case 6:
					note_entrance0("vert tot");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE && crtc_0_7_protect == FALSE)
#else
					if (crtc_0_7_protect == FALSE)
#endif /* V7VGA */
						crt_controller.vertical_total = value;
					break;
				case 7:
					note_entrance0("overflow");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE)
					{
#endif /* V7VGA */
						new.value = value;
						if (crtc_0_7_protect) {
							byte temp_line_cmp;
							temp_line_cmp = (byte) ((CRTC_OVERFLOW*)&new)->as_bfld.line_compare_bit_8;
							((CRTC_OVERFLOW*)&new)->as.abyte = crt_controller.crtc_overflow.as.abyte;
							((CRTC_OVERFLOW*)&new)->as_bfld.line_compare_bit_8 = temp_line_cmp;
						}
						if (crt_controller.crtc_overflow.as_bfld.vertical_display_enab_end_bit_8 !=
								((CRTC_OVERFLOW*)&new)->as_bfld.vertical_display_enab_end_bit_8)
						{
							/*
							 * Screen height changed
							 */

							set_screen_height_med_recal(
								((CRTC_OVERFLOW*)&new)->as_bfld.vertical_display_enab_end_bit_8 );

							flag_mode_change_required();
						}
						if (crt_controller.crtc_overflow.as_bfld.line_compare_bit_8 !=
							((CRTC_OVERFLOW*)&new)->as_bfld.line_compare_bit_8)
						{
							/*
							 * split screen height changed
							 */

							EGA_GRAPH.screen_split.as_bfld.med_bit =
									((CRTC_OVERFLOW*)&new)->as_bfld.line_compare_bit_8;

							if( !get_split_screen_used() )
								flag_mode_change_required();

							screen_refresh_required();
						}
						if (crt_controller.crtc_overflow.as_bfld.vertical_display_enab_end_bit_9 !=
							((CRTC_OVERFLOW*)&new)->as_bfld.vertical_display_enab_end_bit_9)
						{
							/*
							 * split screen height changed
							 */
							set_screen_height_hi_recal(((CRTC_OVERFLOW*)&new)->as_bfld.vertical_display_enab_end_bit_9);
							flag_mode_change_required();
						}
#ifdef NTVDM
						crt_controller.crtc_overflow.as.abyte = new.value;
#else
						crt_controller.crtc_overflow.as.abyte = value;
#endif
#ifdef V7VGA
					}
#endif /* V7VGA */
					break;
				case 8:
					note_entrance0("preset row scan");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE)
#endif /* V7VGA */
						crt_controller.preset_row_scan.as.abyte = value;
					break;
				case 9:
					note_entrance0("max scan line");
#ifdef V7VGA
					if (crtc_9_b_protect == FALSE)
					{
#endif /* V7VGA */
						new.value = value;
						if (crt_controller.maximum_scan_line.as_bfld.maximum_scan_line
							!= ((MAX_SCAN_LINE*)&new)->as_bfld.maximum_scan_line)
						{
							set_char_height_recal(
								(((MAX_SCAN_LINE*)&new)->as_bfld.maximum_scan_line)+1);
							do_new_cursor();
							flag_mode_change_required();
						}

						if( crt_controller.maximum_scan_line.as_bfld.double_scanning
								!= ((MAX_SCAN_LINE*)&new)->as_bfld.double_scanning)
						{
							set_pc_pix_height(1 <<
								((MAX_SCAN_LINE*)&new)->as_bfld.double_scanning);

							flag_mode_change_required();
						}

						if (crt_controller.maximum_scan_line.as_bfld.line_compare_bit_9
							!= ((MAX_SCAN_LINE*)&new)->as_bfld.line_compare_bit_9)
						{
							/*
							 * split screen height changed
							 */

							EGA_GRAPH.screen_split.as_bfld.top_bit =
							    ((MAX_SCAN_LINE*)&new)->as_bfld.line_compare_bit_9;

							if( !get_split_screen_used() )
								flag_mode_change_required();

							screen_refresh_required();
						}
						crt_controller.maximum_scan_line.as.abyte = value;
#ifdef V7VGA
					}
#endif /* V7VGA */
					break;
				case 0xa:
					note_entrance0("cursor start");
#ifdef V7VGA
					if (crtc_9_b_protect == FALSE)
					{
#endif /* V7VGA */
						new.value = value;
						if (crt_controller.cursor_start.as_bfld.cursor_off)
							set_cursor_visible(FALSE);
						else
							set_cursor_visible(TRUE);

						if (crt_controller.cursor_start.as_bfld.cursor_start !=
							((CURSOR_START*)&new)->as_bfld.cursor_start)
						{
							crt_controller.cursor_start.as.abyte = value;
						}

						do_new_cursor();
#ifdef V7VGA
					}
#endif /* V7VGA */
					break;
				case 0xb:
					note_entrance0("cursor end");
#ifdef V7VGA
					if (crtc_9_b_protect == FALSE)
					{
#endif /* V7VGA */
						new.value = value;
						if (crt_controller.cursor_end.as_bfld.cursor_end !=
							((CURSOR_END*)&new)->as_bfld.cursor_end)
						{
							crt_controller.cursor_end.as.abyte = value;
							assert0(crt_controller.cursor_end.as_bfld.cursor_skew_control == 0,
									"Someone is trying to use cursor skew");
							do_new_cursor();
						}
#ifdef V7VGA
					}
#endif /* V7VGA */
					break;
				case 0xc:
					note_entrance0("start address high");
#ifdef V7VGA
					if (crtc_c_protect == FALSE)
					{
#endif /* V7VGA */
						if (crt_controller.start_address_high != value)
						{
							set_screen_start((value << 8) + crt_controller.start_address_low);
							host_screen_address_changed(value, crt_controller.start_address_low);
							/* check if it wraps now */
#ifdef V7VGA
							if( !( get_seq_chain4_mode() || get_seq_chain_mode() ))
#endif /* V7VGA */
								if (get_chain4_mode() )
								{
									if( (get_screen_start()<<2)
												+ get_screen_length() > 4*EGA_PLANE_DISP_SIZE )
										choose_vga_display_mode();
								}
								else
									if ( get_memory_chained() )
									{
										if( (get_screen_start()<<1)
													+ get_screen_length() > 2*EGA_PLANE_DISP_SIZE )
											choose_vga_display_mode();
									}
									else
									{
										if( get_screen_start()
													+ get_screen_length() > EGA_PLANE_DISP_SIZE )
											choose_vga_display_mode();
									}
							screen_refresh_required();
						}
						crt_controller.start_address_high = value;
#ifdef V7VGA
					}
#endif /* V7VGA */
					break;
				case 0xd:
					note_entrance0("start address low");
					if (crt_controller.start_address_low != value)
					{
						set_screen_start((crt_controller.start_address_high << 8) + value);
						host_screen_address_changed(crt_controller.start_address_high, value);
						/* check if it wraps now */
#ifdef V7VGA
						if( !( get_seq_chain4_mode() || get_seq_chain_mode() ))
#endif /* V7VGA */
							if (get_chain4_mode() )
							{
								if( (get_screen_start()<<2)
											+ get_screen_length() > 4*EGA_PLANE_DISP_SIZE )
									choose_vga_display_mode();
							}
							else
								if ( get_memory_chained() )
								{
									if( (get_screen_start()<<1)
												+ get_screen_length() > 2*EGA_PLANE_DISP_SIZE )
										choose_vga_display_mode();
								}
								else
								{
									if( get_screen_start()
												+ get_screen_length() > EGA_PLANE_DISP_SIZE )
										choose_vga_display_mode();
								}
						screen_refresh_required();
					}
					crt_controller.start_address_low = value;
					break;
				case 0xe:
					note_entrance0("cursor loc high");
					if (crt_controller.cursor_location_high != value)
					{
						crt_controller.cursor_location_high = value;

						offset = (value<<8) | crt_controller.cursor_location_low;
						offset -= (SHORT)get_screen_start();

						set_cur_x(offset % crt_controller.horizontal_display_end);
						set_cur_y(offset / crt_controller.horizontal_display_end);

						do_new_cursor();

						if(!get_mode_change_required() && is_it_text())
							cursor_changed(get_cur_x(), get_cur_y());
					}
					break;
				case 0xf:
					note_entrance0("cursor loc lo");
					if (crt_controller.cursor_location_low != value)
					{
						crt_controller.cursor_location_low = value;

						offset = value | (crt_controller.cursor_location_high<<8);
						offset -= (SHORT)get_screen_start();

						set_cur_x(offset % crt_controller.horizontal_display_end);
						set_cur_y(offset / crt_controller.horizontal_display_end);

						do_new_cursor();

						if(!get_mode_change_required() && is_it_text())
							cursor_changed(get_cur_x(), get_cur_y());
					}
					break;
				case 0x10:
					note_entrance0("vert retrace start");
					crt_controller.vertical_retrace_start = value;
					break;
				case 0x11:
					note_entrance0("vert retrace end");
					crt_controller.vertical_retrace_end.as.abyte = value;
                                        if ((value & 32) == 32)
                                           ega_int_enable = 0;
                                        else
					{
                                           ega_int_enable = 1;
                                           input_status_register_zero.as_bfld.crt_interrupt = 1;        /* = !VS */
					}
                                        if ((value & 16) != 16)
                                        {
                                           ica_clear_int(AT_EGA_VTRACE_ADAPTER,AT_EGA_VTRACE_INT);
                                           /*
                                            * clear status latch
                                            */
                                           input_status_register_zero.as_bfld.crt_interrupt = 0;        /* = !VS */
                                        }
			/* ??? */
					if (crt_controller.vertical_retrace_end.as_bfld.crtc_protect)
						crtc_0_7_protect = TRUE;
					else
						crtc_0_7_protect = FALSE;
					break;
				case 0x12:
					note_entrance0("vert disp enable end");
					if (crt_controller.vertical_display_enable_end != value)
					{
						crt_controller.vertical_display_enable_end = value;
						set_screen_height_lo_recal(value);
						flag_mode_change_required();
					}
					break;
				case 0x13:
					note_entrance0("offset");
					if (crt_controller.offset != value)
					{
						crt_controller.offset = value;
						set_actual_offset_per_line(value<<1);	/* actual offset into plane in bytes */
						flag_mode_change_required();
					}
					break;
				case 0x14:
					note_entrance0("underline loc");
					crt_controller.underline_location.as.abyte = value;
					set_underline_start(crt_controller.underline_location.as_bfld.underline_location);
					if (crt_controller.underline_location.as_bfld.doubleword_mode) {
					    assert0(crt_controller.underline_location.as_bfld.count_by_4 == 1,"count by 4 not set in doubleword mode");
					    EGA_CPU.doubleword = TRUE;
					    set_doubleword_mode(YES);
					}
					else {
					    assert0(crt_controller.underline_location.as_bfld.count_by_4 == 0,"count by 4 set when doubleword clear");
					    EGA_CPU.doubleword = FALSE;
					    set_doubleword_mode(NO);
					}
					break;
				case 0x15:
					note_entrance0("start vert blank");
					crt_controller.start_vertical_blanking = value;
					break;
				case 0x16:
					note_entrance0("end vert blank");
					crt_controller.end_vertical_blanking = value;
					break;
				case 0x17:
					note_entrance0("mode control");
					new.value = value;
					if (crt_controller.mode_control.as_bfld.compatibility_mode_support !=
						((MODE_CONTROL*)&new)->as_bfld.compatibility_mode_support)
					{
						if ( (((MODE_CONTROL*)&new)->as_bfld.compatibility_mode_support) == 0)
							set_cga_mem_bank(YES);
						else	set_cga_mem_bank(NO);
						flag_mode_change_required();
					}
					if (crt_controller.mode_control.as_bfld.word_or_byte_mode !=
						((MODE_CONTROL*)&new)->as_bfld.word_or_byte_mode)
					{
						set_word_addressing_recal(
							(((MODE_CONTROL*)&new)->as_bfld.word_or_byte_mode) == 0 );
					}
#ifdef V7VGA
					if (crt_controller.mode_control.as_bfld.horizontal_retrace_select !=
						((MODE_CONTROL*)&new)->as_bfld.horizontal_retrace_select)
					{
						EGA_GRAPH.multiply_vert_by_two = ((MODE_CONTROL*)&new)->as_bfld.horizontal_retrace_select;
						flag_mode_change_required();
						screen_refresh_required();

					}
#endif
					crt_controller.mode_control.as.abyte = value;
					assert0(crt_controller.mode_control.as_bfld.select_row_scan_counter == 1,"Row scan 0");
					assert0(crt_controller.mode_control.as_bfld.horizontal_retrace_select == 0,
														"retrace select 1");
					assert0(crt_controller.mode_control.as_bfld.hardware_reset == 1,"hardware reset cleared");
					break;
				case 0x18:
					note_entrance0("line compare reg");
					if (crt_controller.line_compare != value)
					{
						crt_controller.line_compare = value;
						EGA_GRAPH.screen_split.as_bfld.low_byte = value;

						if( !get_split_screen_used() )
							flag_mode_change_required();

						screen_refresh_required();
					}
					break;
				default:
					assert1(NO,"Bad crtc index %d",crt_controller.address.as_bfld.index);
					break;
			}
			break;
		default:
			assert1(NO,"Bad port passed %x", port );
			break;
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_crtc_inb IFN2(io_addr,port,half_word *,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance3("ega_crtc_inb(%x,%x) index %d", port, value, crt_controller.address.as_bfld.index);
	switch(crt_controller.address.as_bfld.index) {
		case	0:
			*value = crt_controller.horizontal_total;
			break;
		case	1:
			*value = crt_controller.horizontal_display_end - 1;
			break;
		case	2:
			*value = crt_controller.start_horizontal_blanking;
			break;
		case	3:
			*value =(half_word)crt_controller.end_horizontal_blanking.as.abyte;
			break;
		case	4:
			*value = crt_controller.start_horizontal_retrace;
			break;
		case	5:
			*value = (half_word)crt_controller.end_horizontal_retrace.as.abyte;
			break;
		case	6:
			*value = crt_controller.vertical_total;
			break;
		case	7:
			*value = (half_word)crt_controller.crtc_overflow.as.abyte;
			break;
		case	8:
			*value = (half_word)crt_controller.preset_row_scan.as.abyte;
			break;
		case	9:
			*value = (half_word)crt_controller.maximum_scan_line.as.abyte;
			break;
		case	0xa:
			*value = (half_word)crt_controller.cursor_start.as.abyte ;
			note_entrance1("cursor start %d",*value);
			break;
		case	0xb:
			*value = (half_word)crt_controller.cursor_end.as.abyte ;
			note_entrance1("cursor end %d",*value);
			break;
		case	0xc:
			*value = crt_controller.start_address_high ;
			note_entrance1("start address high %x",*value);
			break;
		case	0xd:
			*value = crt_controller.start_address_low ;
			note_entrance1("start address low %x",*value);
			break;
		case	0xe:
			*value = crt_controller.cursor_location_high ;
			note_entrance1("cursor location high %x",*value);
			break;
		case	0xf:
			*value = crt_controller.cursor_location_low ;
			note_entrance1("cursor location low %x",*value);
			break;
		case	0x10:
			*value = crt_controller.vertical_retrace_start;
			break;
		case	0x11:
			*value = crt_controller.vertical_retrace_end.as.abyte & ~0x20;
			break;
		case	0x12:
			*value = (half_word)crt_controller.vertical_display_enable_end;
			break;
		case	0x13:
			*value = crt_controller.offset;
			break;
		case	0x14:
			*value = (half_word)crt_controller.underline_location.as.abyte;
			break;
		case	0x15:
			*value = crt_controller.start_vertical_blanking;
			break;
		case	0x16:
			*value = crt_controller.end_vertical_blanking;
			break;
		case	0x17:
			*value = (half_word)crt_controller.mode_control.as.abyte;
			break;
		case	0x18:
			*value = crt_controller.line_compare;
			break;
#ifdef V7VGA
		case	0x1f:
			*value = crt_controller.start_address_high ^ 0xea;
			break;
		case	0x22:
			switch(graphics_controller.read_map_select.as_bfld.map_select)
			{
				case 0:
					*value = get_latch0;
					break;
				case 1:
					*value = get_latch1;
					break;
				case 2:
					*value = get_latch2;
					break;
				case 3:
					*value = get_latch3;
					break;
			}
			break;
		case 	0x24:
			*value = (half_word)attribute_controller.address.as.abyte;
			break;
#endif /* V7VGA */
		default:
			assert1(crt_controller.address.as_bfld.index>24,"inb from bad crtc index %d",crt_controller.address.as_bfld.index);
			*value = IO_EMPTY_PORT_BYTE_VALUE;
			break;
	}
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"RD crtc %#x = %#x\n",crt_controller.address.as_bfld.index,*value);)
#endif  //NEC_98
}


GLOBAL VOID	vga_gc_mode IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
MODE new_mode;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(5,%#x)\n",value);)
	note_entrance2("vga_gc_mode(%x,%x)", port, value);
	new_mode.as.abyte = value;
	if (graphics_controller.mode.as_bfld.write_mode != new_mode.as_bfld.write_mode)
	{
		/*
		 * write mode change
		 */

		EGA_CPU.write_mode = (unsigned char)new_mode.as_bfld.write_mode;
		setVideowrmode(EGA_CPU.write_mode);
		ega_write_routines_update(WRITE_MODE);
	}

	if (graphics_controller.mode.as_bfld.read_mode != new_mode.as_bfld.read_mode)
	{
		/*
		 * read mode change
		 */
		read_state.mode = new_mode.as_bfld.read_mode;
		ega_read_routines_update();
	}

	if (graphics_controller.mode.as_bfld.shift_register_mode != new_mode.as_bfld.shift_register_mode)
	{

	    switch(new_mode.as_bfld.shift_register_mode) {

	    case 0:		/* EGA mode */
		set_graph_shift_reg(NO);
		set_256_colour_mode(NO);
		set_horiz_total(crt_controller.horizontal_display_end);
		break;
	    case 1:		/* CGA med res mode */
		set_graph_shift_reg(YES);
		set_256_colour_mode(NO);
		set_horiz_total(crt_controller.horizontal_display_end);
		break;
	    case 2:		/* VGA 256 colour mode */
	    case 3:		/* Bottom bit ignored, if top bit set */
		set_graph_shift_reg(NO);
		set_256_colour_mode(YES);
		/* Need to halve horiz display end for 256 cols */
		set_horiz_total(crt_controller.horizontal_display_end>>1);
		flag_palette_change_required();
		break;
	    }
	    flag_mode_change_required();
	}

	graphics_controller.mode.as.abyte = new_mode.as.abyte;

	/*
	 * Check for any change to chained mode rule by having an election
	 * (Note: EGA registers must be updated before calling election)
	 */

	do_chain_majority_decision();
#endif  //NEC_98
}

/*
 * note: identical to ega routines, but needed in this module to ensure
 * correct struct set
 */

GLOBAL VOID	vga_gc_outb_index IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("vga_gc_outb_index(%x,%x)", port, value);
	value &= 0xf;
	graphics_controller.address.as.abyte = value;
	assert2(value<9,"Bad gc index %#x port %#x",value,port);

	io_redefine_outb(EGA_GC_ADAP_DATA,ega_gc_regs[value]);
	Cpu_define_outb(EGA_GC_ADAP_DATA,ega_gc_regs_cpu[value]);
#endif  //NEC_98
}


/*( vga_gc_outw
**	Most PC programs do an "OUT DX, AX" which sets up the GC index
**	register with the AL and the GC data register with AH.
**	Avoid going through generic_outw() by doing it all here!
**	See also: ega_gc_outw() in "ega_ports.c"
)*/
GLOBAL VOID vga_gc_outw IFN2(io_addr, port, word, outval)
{
#ifndef NEC_98
	reg		temp;
	INT		value;

	temp.X = outval;

	value = temp.byte.low & 0xf;
	graphics_controller.address.as.abyte = value;

	assert2(value<9,"Bad gc index %#x port %#x",value,port);

	io_redefine_outb(EGA_GC_ADAP_DATA,ega_gc_regs[value]);

	Cpu_define_outb(EGA_GC_ADAP_DATA,ega_gc_regs_cpu[value]);

	(*(ega_gc_regs[value]))((io_addr)(port+1), temp.byte.high);
#endif  //NEC_98
}


GLOBAL VOID	vga_gc_set_reset IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
unsigned set_reset;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(0,%x)\n",value);)
	note_entrance2("vga_gc_set_reset(%x,%x)", port, value);
	set_reset = graphics_controller.set_or_reset.as_bfld.set_or_reset;
	graphics_controller.set_or_reset.as.abyte = value;
	if (graphics_controller.set_or_reset.as_bfld.set_or_reset != set_reset)
	{
		EGA_CPU.set_reset = graphics_controller.set_or_reset.as_bfld.set_or_reset;
		ega_write_routines_update(SET_RESET);
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_gc_enable_set IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
unsigned en_set_reset;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(1,%x)\n",value);)
	note_entrance2("vga_gc_enable_set(%x,%x)", port, value);
	en_set_reset = graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset;
	graphics_controller.enable_set_or_reset.as.abyte = value;
	if (graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset != en_set_reset)
	{
		EGA_CPU.sr_enable = graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset;
		write_state.sr = graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset==0?0:1;
		setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);
		ega_write_routines_update(ENABLE_SET_RESET);
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_gc_compare IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
unsigned colour_compare;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(2,%x)\n",value);)
	note_entrance2("vga_gc_compare(%x,%x)", port, value);
	colour_compare = graphics_controller.color_compare.as_bfld.color_compare;
	graphics_controller.color_compare.as.abyte = value;
	if (graphics_controller.color_compare.as_bfld.color_compare != colour_compare)
	{
		read_state.colour_compare = (unsigned char)graphics_controller.color_compare.as_bfld.color_compare;
		if (read_state.mode == 1) ega_read_routines_update();
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_gc_rotate IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
	struct {
		unsigned value : 8;
	} new;

	UNUSED(port);
	
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(3,%x)\n",value);)
	new.value = value;
	if (graphics_controller.data_rotate.as_bfld.rotate_count != ((DATA_ROTATE*)&new)->as_bfld.rotate_count )
	{
		setVideorotate(((DATA_ROTATE*)&new)->as_bfld.rotate_count);
		ega_write_routines_update(ROTATION);
	}
	if (graphics_controller.data_rotate.as_bfld.function_select != ((DATA_ROTATE*)&new)->as_bfld.function_select)
	{
		write_state.func = ((DATA_ROTATE*)&new)->as_bfld.function_select;
		setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);
		ega_write_routines_update(FUNCTION);
	}
	EGA_CPU.fun_or_protection = (value != 0) || write_state.bp;
	graphics_controller.data_rotate.as.abyte = value;
#endif  //NEC_98
}

GLOBAL VOID	vga_gc_read_map IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(4,%x)\n",value);)

	note_entrance2("vga_gc_read_map(%x,%x)", port, value);

	setVideoread_mapped_plane(value & 3);

	update_shift_count();
#endif  //NEC_98
}

GLOBAL VOID	vga_gc_misc IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
unsigned memory_map;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(6,%x)\n",value);)
	note_entrance2("vga_gc_misc(%x,%x)", port, value);
	memory_map = graphics_controller.miscellaneous.as_bfld.memory_map;
	graphics_controller.miscellaneous.as.abyte = value;
	if (graphics_controller.miscellaneous.as_bfld.memory_map != memory_map)
	{
		/*
		 * Where EGA appears in PC memory space changed.
		*/
		
#ifndef GISP_SVGA
		if (miscellaneous_output_register.as_bfld.enable_ram)
			sas_disconnect_memory(gvi_pc_low_regen,gvi_pc_high_regen);
#endif		/* GISP_SVGA */

		switch (graphics_controller.miscellaneous.as_bfld.memory_map)
		{
			case 0:
				gvi_pc_low_regen = 0xA0000;
				gvi_pc_high_regen = 0xBFFFF;
				break;
			case 1:
				gvi_pc_low_regen = 0xA0000;
				gvi_pc_high_regen = 0xAFFFF;
				break;
			case 2:
				gvi_pc_low_regen = 0xB0000;
				gvi_pc_high_regen = 0xB7FFF;
				break;
			case 3:
				gvi_pc_low_regen = 0xB8000;
				gvi_pc_high_regen = 0xBFFFF;
				break;
		}

		if (miscellaneous_output_register.as_bfld.enable_ram)
			sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);

		/*
		 * Tell cpu associated modules that regen area has moved
		 */

		ega_read_routines_update();
		ega_write_routines_update(RAM_MOVED);
	}

	/* Decide alpha/graphics mode by voting. */
	vote_vga_mode();

	/*
	 * Check for any change to chained mode rule by having an election
	 * (Note: EGA registers must be updated before calling election)
	 */

	do_chain_majority_decision();
#endif  //NEC_98
}

GLOBAL VOID	vga_gc_dont_care IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
unsigned colour_dont_care;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(7,%x)\n",value);)
	note_entrance2("vga_gc_dont_care(%x,%x)", port, value);
	colour_dont_care = graphics_controller.color_dont_care.as_bfld.color_dont_care;
	graphics_controller.color_dont_care.as.abyte = value;
	if (graphics_controller.color_dont_care.as_bfld.color_dont_care != colour_dont_care)
	{
		read_state.colour_dont_care = (unsigned char)graphics_controller.color_dont_care.as_bfld.color_dont_care;
		if (read_state.mode == 1) ega_read_routines_update();
	}
#endif  //NEC_98
}




/*
 * The EGA mask register is written to more times than all other ports added together!
 * To help make this register fast, we have two different routines to handle it:
 * ega_gc_mask for when the register's current value is not 0xFF, ie. masking is active
 * ega_gc_mask_ff for when the mask register = 0xFF, so masking is disabled.
 */


/*(
** vga_mask_register_changed
**	This gets called whenever the mask register gets changed, and
**	updates the internals appropriately. Since the mask registers
**	are hit more than any other registers, this should do the job!
**
**	Rather than calling the monster ega_write_routines_update() (in "ega_write.c"),
**	we do as little as we possibly can here!
**	In particular, all we do is set the video write pointer handlers
**	to the appropriate one and update the internal EGA_CPU state...
**
**	We DON'T do anything about altering the marking funcs, etc.
**
**	See also "ega_mask_register_changed" in "ega_ports.c".
**
**  NB: GLOBAL for JOKER.
)*/
#include	"cpu_vid.h"
IMPORT void Glue_set_vid_wrt_ptrs(WRT_POINTERS * handler );

GLOBAL VOID vga_mask_register_changed IFN1(BOOL, gotBitProtection)
{
#ifndef NEC_98
	ULONG				state;
	SAVED IU8			masks[] = {0x1f, 0x01, 0x0f, 0x0f};
	IMPORT WRT_POINTERS	*mode_chain_handler_table[];
#ifdef V7VGA
	IMPORT	UTINY		Last_v7_fg_bg, fg_bg_control;
#endif


	write_state.bp = gotBitProtection;
	setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);
	EGA_CPU.fun_or_protection = (gotBitProtection || (graphics_controller.data_rotate.as.abyte != 0));

	/* Check that we're not trying to handle any pathological cases here...
	** This means we chicken out for Chain2 and V7VGA dithering.
	*/

	if ((EGA_CPU.chain == CHAIN2)
#ifdef V7VGA
		|| ( Last_v7_fg_bg != fg_bg_control)
#endif /* V7VGA */
		)
	{
		ega_write_routines_update(BIT_PROT);

		return;
	}

	/* the "mode_0" union variant has the largest "lookup" field (5 bits.) */

	state = EGA_CPU.ega_state.mode_0.lookup & masks[EGA_CPU.write_mode];

#ifdef A3CPU
#ifdef C_VID
	Glue_set_vid_wrt_ptrs(&mode_chain_handler_table[EGA_CPU.saved_mode_chain][state]);
#else
	Cpu_set_vid_wrt_ptrs(&mode_chain_handler_table[EGA_CPU.saved_mode_chain][state]);	
#endif /* C_VID */
#else
#if !(defined(NTVDM) && defined(X86GFX))
	Glue_set_vid_wrt_ptrs(&mode_chain_handler_table[EGA_CPU.saved_mode_chain][state]);
#endif /* !(NTVDM && X86GFX) */
#endif /* A3CPU */

	EGA_CPU.saved_state = state;
#endif  //NEC_98
}


/* this is the one that is usually called */
GLOBAL VOID	vga_gc_mask IFN2(USHORT,port,FAST UTINY,value)
{
#ifndef NEC_98
	FAST ULONG  mask;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(8,%x)\n",value);)
	note_entrance2("vga_gc_mask(%x,%x)", port, value);

	/*
	 * Update video routine according to new bit protection
	 */

	mask = value | (value << 8);
	mask |= (mask << 16);	/* replicate the mask into 4 bytes */
	setVideobit_prot_mask(mask);
	setVideodata_xor_mask(~(EGA_CPU.calc_data_xor & mask));
	setVideolatch_xor_mask(EGA_CPU.calc_latch_xor & mask);

	if(value == 0xff)
	{
#ifndef	USE_OLD_MASK_CODE
		vga_mask_register_changed(/*bit protection :=*/0);
#else
		write_state.bp = 0;
		setVideowrstate(EGA_CPU.ega_state.mode_0.lookup);
		EGA_CPU.fun_or_protection = (graphics_controller.data_rotate.as.abyte != 0);
		ega_write_routines_update(BIT_PROT);
#endif	/* USE_OLD_MASK_CODE */

		/* Alter the function table used by ega_gc_index */
		ega_gc_regs[8] = FAST_FUNC_ADDR(vga_gc_mask_ff);

#ifndef CPU_40_STYLE	/* TEMPORARY */
#ifndef A2CPU
		/* Alter the function table used by assembler ega_gc_index */
		ega_gc_regs_cpu[8] = FAST_FUNC_ADDR(_ega_gc_outb_mask_ff);
#endif
#endif

		io_redefine_outb(EGA_GC_ADAP_DATA,vga_gc_mask_ff);

#ifndef CPU_40_STYLE	/* TEMPORARY */
		Cpu_define_outb(EGA_GC_ADAP_DATA,_ega_gc_outb_mask_ff);
#endif
	}
#endif  //NEC_98
}

/* This version isn't called so often */
GLOBAL VOID	vga_gc_mask_ff IFN2(USHORT,port,FAST UTINY,value)
{
#ifndef NEC_98
	FAST ULONG mask;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(8,%x)\n",value);)
	note_entrance2("vga_gc_mask(%x,%x)", port, value);

	/*
	 * Update video routine according to new bit protection
	 */

	if(value != 0xff)
	{
		mask = value | (value << 8);
		mask |= (mask << 16);	/* replicate the mask into 4 bytes */
		setVideobit_prot_mask(mask);
		setVideodata_xor_mask(~(EGA_CPU.calc_data_xor & mask));
		setVideolatch_xor_mask(EGA_CPU.calc_latch_xor & mask);

#ifndef	USE_OLD_MASK_CODE
		vga_mask_register_changed(/*bit protection :=*/1);
#else
		write_state.bp = 1;
		setVideowrstate(EGA_CPU.ega_state.mode_0.lookup);
		EGA_CPU.fun_or_protection = TRUE;
		ega_write_routines_update(BIT_PROT);
#endif	/* USE_OLD_MASK_CODE*/

		/* Alter the function table used by ega_gc_index */
		ega_gc_regs[8] = FAST_FUNC_ADDR(vga_gc_mask);

#ifndef CPU_40_STYLE	/* TEMPORARY */
#ifndef A2CPU
		/* Alter the function table used by assembler ega_gc_index */
		ega_gc_regs_cpu[8] = FAST_FUNC_ADDR(_ega_gc_outb_mask);
#endif
#endif

		io_redefine_outb(EGA_GC_ADAP_DATA,vga_gc_mask);

#ifndef CPU_40_STYLE	/* TEMPORARY */
		Cpu_define_outb(EGA_GC_ADAP_DATA,_ega_gc_outb_mask);
#endif
	}
#endif  //NEC_98
}
/* end of 'same as EGA' gc routines */

/*
 * copy of ega routine to place in correct module to update static struct.
 */
GLOBAL VOID	vga_seq_map_mask IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"seq(2,%x)\n",value);)
	note_entrance2("vga_seq_map_mask(%x,%x)", port, value);

	/* map mask register */
	/*
	 * Different display plane(s) have been enabled. Update the video
	 * routines to deal with this
	 */

	value &= 0xf;			/* 4 planes ==> lower 4 bits valid */

	setVideoplane_enable(value);
	setVideoplane_enable_mask(sr_lookup[value]);
	write_state.pe = (value == 0xf);				/* 1 or 0 */
	setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);
	ega_write_routines_update(PLANES_ENABLED);
#endif  //NEC_98
}
/* end of 'same as EGA' seq routines */

/*
 * copy of ega routine to place in correct module to update static struct.
 */

SAVED TINY vga_ip0_state = 0;	/* current ega status state */
SAVED TINY vga_ip0_state_count = 1;     /* position in that state */

GLOBAL VOID	v_ret_intr_status IFN0()
{
#ifndef NEC_98
    vga_ip0_state = 3;
    vga_ip0_state_count = 6;
#endif  //NEC_98
}


/*
	The following routine should not return a value with top bit set
	until we emulate a Rev4 Video7 card.
*/

/*
 * Some programs synchronise with the display by waiting for the
 * next vertical retrace.
 *
 * We attempt to follow the following waveform:
 *          _____                                               _____
 * VS _____|     |_____________________________________________|     |___
 *       ____________     _     _               _     _     _____________
 * DE __|            |___| |___| |_  .......  _| |___| |___|             |_
 *
 * State   |  3  | 0 |            1                        | 2 |
 *
 */

#if defined(NTVDM) || defined(host_get_time_ms) || defined(host_get_count_ms)

 /*
  * end of periods for each state
  * Units are 100 usec (0.1 ms) to match GetPerfCounter() resolution
  * Total period is based on 70 Hz for NTVDM and 50Hz otherwise
  */
#ifdef NTVDM
#define IPSTAT1_STATE_0    	(25)
#define IPSTAT1_STATE_1     	(IPSTAT1_STATE_0 + 75)
#define IPSTAT1_STATE_2     	(IPSTAT1_STATE_1 + 25)
#define IPSTAT1_STATE_3     	(IPSTAT1_STATE_2 + 10)
#define IPSTAT1_CYCLE_TIME  	IPSTAT1_STATE_3
#else	/* NTVDM */
#define IPSTAT1_STATE_0		(4)			/* End of state 0, ms */
#define IPSTAT1_STATE_1		(IPSTAT1_STATE_0 + 9)	/* End of state 1, ms */
#define IPSTAT1_STATE_2		(IPSTAT1_STATE_1 + 4)	/* End of state 2, ms */
#define IPSTAT1_STATE_3		(IPSTAT1_STATE_2 + 3)	/* End of state 3, ms */
#define IPSTAT1_CYCLE_TIME	IPSTAT1_STATE_3		/* Cycle time, ms */
#endif	/* NTVDM */

GLOBAL VOID  vga_ipstat1_inb IFN2(io_addr,port,half_word *,value)
{
#ifndef NEC_98
   IMPORT ULONG GetPerfCounter(void);
   SAVED ULONG RefreshStartTime=0;
   ULONG cycles;
   ULONG CurrTime;


#if defined(X86GFX)
/* Silly programs (especially editors) that are concerned that they might
 * be running on CGA's will read this port like crazy before each screen
 * access. This frig catches the common case:
 *     in
 *     test al,80
 *     j{e,ne} back to the in
 * and moves IP to beyond the test. So far this hasn't broken anything(!!)
 * but has made good speedups in a variety of apps.
 */
   sys_addr off;
   word cs, ip;
   ULONG dwat;
   IMPORT word getCS(), getIP();
#endif

#ifdef PROD
	UNUSED(port);
#endif

#ifdef X86GFX
    cs = getCS();
    ip = getIP();
    off = (cs << 4) + ip;
    dwat = sas_dw_at(off);
    if (dwat == 0xfb7401a8 || dwat == 0xfb7501a8)
    {
	ip += 4;
	setIP(ip);
	*value = 5;	/* anything really */
    	return;
    }
#endif

    note_entrance2("vga_ipstat1_inb(%x,%x)", port, value);

#ifdef V7VGA
	attribute_controller.address.as_bfld.index_state = 0;
#else
    set_index_state();	/* Initialize the Attribute register flip-flop (EGA tech ref, p 56) */
#endif /* V7VGA */

#if defined(NTVDM) || defined(host_get_count_ms)

#ifdef NTVDM
   CurrTime = GetPerfCounter();
#else
   CurrTime = host_get_count_ms();
#endif

   cycles = CurrTime >= RefreshStartTime
               ? CurrTime - RefreshStartTime
               : 0xFFFFFFFF - RefreshStartTime + CurrTime;

        /*  If app hasn't checked the status for a long time (for at least
         *  one Display Refresh Cycle). start the app at end of state 0.
         */
   if (cycles > IPSTAT1_CYCLE_TIME) {
       RefreshStartTime = CurrTime;
       cycles = 0;
   }

#else 	/* host_get_time_ms */

    cycles = host_get_time_ms() % IPSTAT1_CYCLE_TIME;

#endif	/* host_get_time_ms */

   if (cycles < IPSTAT1_STATE_0)
   {
       *value = 0x05;
	input_status_register_zero.as_bfld.crt_interrupt = 0;	/* = !VS */
   }
   else if (cycles < IPSTAT1_STATE_1)
   {
       *value = 0x04;
       if (((cycles - IPSTAT1_STATE_0) % 3) == 0)
           *value |= 0x01;
       input_status_register_zero.as_bfld.crt_interrupt = 0;   /* = !VS */
   }
   else if (cycles < IPSTAT1_STATE_2)
   {
	*value = 0x05;
       input_status_register_zero.as_bfld.crt_interrupt = 0;   /* = !VS */
   }
   else /* IPSTAT1_STATE_3 */
   {
       *value = 0x0d;
       input_status_register_zero.as_bfld.crt_interrupt = 1;   /* = VS */
   }
#endif  //NEC_98
}

#else   /* !(NTVDM || host_get_time_ms || host_get_count_ms) */

GLOBAL VOID	vga_ipstat1_inb IFN2(io_addr,port,half_word *,value)
{
#ifndef NEC_98

	/*
	 * The whole of this routine has been nicked from the cga without modification
	 * The s_lengths array should probably be altered for the ega timings, and somewhere
	 * an interrupt should be fired off.
	 */

	SAVED TINY sub_state = 0;	/* sub state for ega state 2 */

     SAVED ULONG gmfudge = 17; /* Random number seed for pseudo-random
						bitstream generator to give the state
						lengths below that 'genuine' feel to
						progs that require it! */
     FAST ULONG h;

    /*
     * relative 'lengths' of each state. State 2 is *3 as it has 3 sub states
     */

	SAVED TINY s_lengths[] = { 8, 18, 8, 6 };


#ifdef PROD
	UNUSED(port);
#endif
    note_entrance2("vga_ipstat1_inb(%x,%x)", port, value);

#ifdef V7VGA
	attribute_controller.address.as_bfld.index_state = 0;
#else
    set_index_state();	/* Initialize the Attribute register flip-flop (EGA tech ref, p 56) */
#endif /* V7VGA */

    vga_ip0_state_count --;	/* attempt relative 'timings' */
    switch (vga_ip0_state) {

    case 0:
	if (vga_ip0_state_count == 0) {	/* change to next state ? */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
	    vga_ip0_state_count = s_lengths[1] + (gmfudge & 3);
	    vga_ip0_state = 1;
	}
	input_status_register_zero.as_bfld.crt_interrupt = 0;	/* = !VS */
	*value = 0x05;
	break;

    case 1:
	if (vga_ip0_state_count == 0) {	/* change to next state ? */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
	    vga_ip0_state_count = s_lengths[2] + (gmfudge & 3);
	    vga_ip0_state = 2;
	    sub_state = 2;
	}
	switch (sub_state) {	/* cycle through 0,0,1 sequence */
	case 0:		/* to represent DE toggling */
	    *value = 0x04;
	    sub_state = 1;
	    break;
	case 1:
	    *value = 0x04;
	    sub_state = 2;
	    break;
	case 2:
	    *value = 0x05;
	    sub_state = 0;
	    break;
        }
	input_status_register_zero.as_bfld.crt_interrupt = 0;	/* = !VS */
	break;

    case 2:
	if (vga_ip0_state_count == 0) {	/* change to next state ? */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
	    vga_ip0_state_count = s_lengths[3] + (gmfudge & 3);
	    vga_ip0_state = 3;
	}
	*value = 0x05;
	input_status_register_zero.as_bfld.crt_interrupt = 0;	/* = !VS */
	break;

    case 3:
	if (vga_ip0_state_count == 0) {	/* wrap back to first state */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
	    vga_ip0_state_count = s_lengths[0] + (gmfudge & 3);
	    vga_ip0_state = 0;
	}
	input_status_register_zero.as_bfld.crt_interrupt = 1;	/* = !VS */
	*value = 0x0d;
	break;
    }
    note_entrance1("returning %x",*value);
#endif  //NEC_98
}

#endif /* !(NTVDM || host_get_time_ms || host_get_count_ms) */

GLOBAL VOID	vga_gc_inb IFN2(io_addr,port,half_word *, value)
{
#ifndef NEC_98
	note_entrance1("vga_gc_inb(%x)", port);
	if (port == EGA_GC_INDEX) {
	    *value = (half_word)graphics_controller.address.as.abyte;
	    note_entrance1("returning %x",*value);
	    return;
	}
	if (port == EGA_GC_DATA) {
	    switch(graphics_controller.address.as.abyte) {

	    case 0:
		*value = (half_word)graphics_controller.set_or_reset.as.abyte;
		break;
	    case 1:
		*value = (half_word)graphics_controller.enable_set_or_reset.as.abyte;
		break;
	    case 2:
		*value = (half_word)graphics_controller.color_compare.as.abyte;
		break;
	    case 3:
		*value = (half_word)graphics_controller.data_rotate.as.abyte;
		break;
	    case 4:
		*value = (half_word)getVideoread_mapped_plane();
		break;
	    case 5:
		*value = (half_word)graphics_controller.mode.as.abyte;
		break;
	    case 6:
		*value = (half_word)graphics_controller.miscellaneous.as.abyte;
		break;
	    case 7:
		*value = (half_word)graphics_controller.color_dont_care.as.abyte;
		break;
	    case 8:
		*value = (half_word)getVideobit_prot_mask() & 0xff;
		break;
	    default:
		assert1(NO,"Bad gc index %d",graphics_controller.address.as.abyte);
		*value = IO_EMPTY_PORT_BYTE_VALUE;
	    }
	    note_entrance1("returning %x",*value);
	}
	else {
	    assert1(NO,"Bad gc port %d",port);
	    *value = IO_EMPTY_PORT_BYTE_VALUE;
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_ac_outb IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
	struct {
		unsigned value : 8;
	} new;

#ifdef PROD
	UNUSED(port);
#endif

	note_entrance2("vga_ac_outb(%x,%x)", port, value);
	assert1( port == EGA_AC_INDEX_DATA, "Bad port %x", port);
	new.value = value;
#ifdef V7VGA
	attribute_controller.address.as_bfld.index_state = !attribute_controller.address.as_bfld.index_state;
	if (attribute_controller.address.as_bfld.index_state) {
#else
	if ( in_index_state() ) {
#endif /* V7VGA */
		note_entrance1("Setting index to %d", value);
		if ((unsigned)(((value & 0x20) >> 5)) != attribute_controller.address.as_bfld.palette_address_source)
		{
			if (value & 0x20)
			{
				set_display_disabled(FALSE);
				timer_video_enabled = 1;
				enable_gfx_update_routines();
				screen_refresh_required();
			}
			else
			{
				/*
				 * not strictly accurate, since we are meant to fill the screen with
				 * the current overscan colour. However that is normally black so this
				 * will do.
				 */
				set_display_disabled(TRUE);
				timer_video_enabled = 0;
				disable_gfx_update_routines();
			}
		}
#ifdef V7VGA
		attribute_controller.address.as.abyte = (attribute_controller.address.as_bfld.index_state << 7) | (value & 0x3f);
#else
		attribute_controller.address.as.abyte = value;
#endif /* V7VGA */
	} else {
		NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"attr(%#x,%#x)\n",attribute_controller.address.as_bfld.index,value);)
		switch (attribute_controller.address.as_bfld.index) {
		case 0:
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 0xa:
		case 0xb:
		case 0xc:
		case 0xd:
		case 0xe:
		case 0xf:
			note_entrance1("Change palette %d",attribute_controller.address.as_bfld.index);
			attribute_controller.palette[attribute_controller.address.as_bfld.index].as.abyte = value;
			set_palette_val(attribute_controller.address.as_bfld.index, value);

			flag_palette_change_required();
			break;
		case 0x10:
			note_entrance0("mode control reg");
			if (attribute_controller.mode_control.as_bfld.background_intensity_or_blink !=
				((AC_MODE_CONTROL*)&new)->as_bfld.background_intensity_or_blink)
			{
				set_intensity( ((AC_MODE_CONTROL*)&new)->as_bfld.background_intensity_or_blink );
			}
			if (attribute_controller.mode_control.as_bfld.select_video_bits !=
				((AC_MODE_CONTROL*)&new)->as_bfld.select_video_bits)
			{
				set_colour_select(((AC_MODE_CONTROL*)&new)->as_bfld.select_video_bits);
				flag_palette_change_required();
			}
			attribute_controller.mode_control.as.abyte = value;

     			if (attribute_controller.mode_control.as_bfld.background_intensity_or_blink)
				/* blinking - not supported */
				bg_col_mask = 0x70;
			else
				/* using blink bit to provide 16 background colours */
				bg_col_mask = 0xf0;

			/* Vote on alpha/graphics mode */
        		vote_vga_mode();
			assert0(attribute_controller.mode_control.as_bfld.display_type == 0, "Mono display selected");
			assert0(attribute_controller.mode_control.as_bfld.enable_line_graphics_char_codes == 0,
											"line graphics enabled");
			break;
		case 0x11:
			note_entrance0("set border");
			attribute_controller.overscan_color.as.abyte = value;
			EGA_GRAPH.border[RED] = get_border_color(red_border,secondary_red_border);
			EGA_GRAPH.border[GREEN] = get_border_color(green_border,secondary_green_border);
			EGA_GRAPH.border[BLUE] = get_border_color(blue_border,secondary_blue_border);
			host_set_border_colour(value);
			break;
		case 0x12:
			note_entrance1("color plane enable %x",value);
			if ( attribute_controller.color_plane_enable.as_bfld.color_plane_enable !=
					((COLOR_PLANE_ENABLE*)&new)->as_bfld.color_plane_enable ) {
				set_plane_mask(((COLOR_PLANE_ENABLE*)&new)->as_bfld.color_plane_enable);
				host_change_plane_mask(get_plane_mask());	/* Update Host palette */
			}
			attribute_controller.color_plane_enable.as.abyte = value;
			break;
		case 0x13:
			note_entrance0("horiz pel panning");
			attribute_controller.horizontal_pel_panning.as.abyte = value;
			break;
		case 0x14:
			note_entrance0("pixel padding register");
			if (attribute_controller.pixel_padding.as_bfld.color_top_bits !=
				((PIXEL_PAD*)&new)->as_bfld.color_top_bits)
			{
				set_top_pixel_pad(((PIXEL_PAD*)&new)->as_bfld.color_top_bits);
				flag_palette_change_required();
			}
			if (attribute_controller.pixel_padding.as_bfld.color_mid_bits !=
				((PIXEL_PAD*)&new)->as_bfld.color_mid_bits)
			{
				set_mid_pixel_pad(((PIXEL_PAD*)&new)->as_bfld.color_mid_bits);
				flag_palette_change_required();
			}
			attribute_controller.pixel_padding.as.abyte = value;
			break;
		default:
			assert1(NO,"Bad ac index %d", attribute_controller.address.as_bfld.index);
			break;
		}
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_ac_inb IFN2(io_addr,port,half_word *, value)
{
#ifndef NEC_98
    note_entrance1("vga_ac_inb(%x)", port);
    if (port == EGA_AC_INDEX_DATA) {	/* 3c0 */
	*value = (half_word)attribute_controller.address.as.abyte;
	note_entrance1("returning %x",*value);
	return;
    }
    if (port == EGA_AC_SECRET) {	/* 3c1 */
	switch (attribute_controller.address.as_bfld.index) {
	case 0:
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
	case 9:
	case 0xa:
	case 0xb:
	case 0xc:
	case 0xd:
	case 0xe:
	case 0xf:
		*value = (half_word)attribute_controller.palette[attribute_controller.address.as_bfld.index].as.abyte;
		break;
	case 0x10:
		*value = (half_word)attribute_controller.mode_control.as.abyte;
		break;
	case 0x11:
		*value = (half_word)attribute_controller.overscan_color.as.abyte;
		break;
	case 0x12:
		*value = (half_word)attribute_controller.color_plane_enable.as.abyte;
		break;
	case 0x13:
		*value = (half_word)attribute_controller.horizontal_pel_panning.as.abyte;
		break;
	case 0x14:
		*value = (half_word)attribute_controller.pixel_padding.as.abyte;
		break;
	}
	note_entrance1("returning %x",*value);
    }
    else {
        assert1(NO,"Bad ac port %d",port);
        *value = IO_EMPTY_PORT_BYTE_VALUE;
    }
#endif  //NEC_98
}
	
GLOBAL VOID	vga_misc_outb IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
MISC_OUTPUT_REG new;

#ifdef PROD
	UNUSED(port);
#endif

	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"misc %#x\n",value);)

	note_entrance2("vga_misc_outb(%x,%x)", port, value);

	assert1(port==EGA_MISC_REG,"Bad port %x",port);
	new.as.abyte = value;

	if (miscellaneous_output_register.as_bfld.enable_ram != new.as_bfld.enable_ram)
	{
		/*
		 * writes to plane memory en/disabled
		 */

		note_entrance0("Ram enabled");

#ifndef GISP_SVGA
		if(new.as_bfld.enable_ram)
			sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);
		else
			sas_disconnect_memory(gvi_pc_low_regen,gvi_pc_high_regen);
#endif		/* GISP_SVGA */
		EGA_CPU.ram_enabled = new.as_bfld.enable_ram;
		ega_read_routines_update();
		ega_write_routines_update(RAM_ENABLED);
	}

	miscellaneous_output_register.as.abyte = new.as.abyte;

	update_banking();
#endif  //NEC_98
}

GLOBAL VOID	vga_misc_inb IFN2(io_addr,port,half_word *, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	assert1(port==VGA_MISC_READ_REG,"Bad port %x",port);
	*value = (half_word)miscellaneous_output_register.as.abyte;
#endif  //NEC_98
}

GLOBAL VOID	vga_ipstat0_inb IFN2(io_addr,port,half_word *, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance1("vga_ipstat0_inb(%x)", port);
	*value = (half_word)input_status_register_zero.as.abyte;
	note_entrance1("returning %x",*value);
#endif  //NEC_98
}

GLOBAL VOID	vga_feat_outb IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_feat_outb(%x,%x)", port, value);
	feature_control_register.as.abyte = value;
#endif  //NEC_98
}

GLOBAL VOID	vga_feat_inb IFN2(io_addr,port,half_word *, value)
{
#ifndef NEC_98
	UNUSED(port);
	*value = (half_word)feature_control_register.as.abyte;
#endif  //NEC_98
}

GLOBAL VOID	vga_dac_outb IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
    note_entrance1("vga_dac_outb %#x",port);
    switch(port) {

    case VGA_DAC_MASK:
	if (get_DAC_mask() != value) {
	    set_DAC_mask(value);
	    flag_palette_change_required();
	}
	break;

    case VGA_DAC_RADDR:
	DAC_rd_addr = value;
	DAC_state = 3;		/* show 3c7 status read in read mode */
	assert0(DAC_rgb_state == DAC_RED, "DAC rd addr change when state not RED");
	DAC_rgb_state = DAC_RED;
	break;

    case VGA_DAC_WADDR:
	DAC_wr_addr = value;
	DAC_state = 0;		/* show 3c7 status read in write mode */
	assert0(DAC_rgb_state == DAC_RED, "DAC wr addr change when state not RED");
	DAC_rgb_state = DAC_RED;
	break;

    default:
	assert1(NO,"Bad DAC port %d",port);
    }
#endif  //NEC_98
}

/*
 * as this poor little port is hammered, we split it off from it's DAC siblings
 * for (hoped) efficiency.
 */
GLOBAL VOID	vga_dac_data_outb IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif

    note_entrance1("vga_dac_data_outb %#x",port);
    switch(DAC_rgb_state) {

    case DAC_RED:
	DAC[DAC_wr_addr].red = value & DAC_data_mask;
	DAC_rgb_state = DAC_GREEN;
	break;

    case DAC_GREEN:
	DAC[DAC_wr_addr].green = value & DAC_data_mask;
	DAC_rgb_state = DAC_BLUE;
	break;

    case DAC_BLUE:
	DAC[DAC_wr_addr].blue = value & DAC_data_mask;
	DAC_rgb_state = DAC_RED;
	/*
	 * very important side affect - many progs dont touch the DAC
	 * index reg after setting it to the start of a group.
	 */
	DAC_wr_addr++;
	break;

    default:
	assert1(NO,"unknown DAC state %d",DAC_rgb_state);
    }

    flag_palette_change_required();
#endif  //NEC_98
}

GLOBAL VOID	vga_dac_inb IFN2(io_addr,port,half_word *,value)
{
#ifndef NEC_98
    note_entrance1("vga_dac_inb %#x",port);
    switch(port) {

    case VGA_DAC_MASK:
	*value = get_DAC_mask();
	break;

    case VGA_DAC_RADDR:
	*value= DAC_state;	/* either 0 - write mode or 3 - read mode */
	break;

    case VGA_DAC_WADDR:
	*value = DAC_wr_addr;
	break;

    default:
	assert1(NO,"Bad DAC port read %d",port);
    }
    note_entrance1("returning %#x",*value);
#endif  //NEC_98
}

GLOBAL VOID	vga_dac_data_inb IFN2(io_addr,port,half_word *,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance1("vga_dac_data_inb %#x",port);
    switch(DAC_rgb_state) {

    case DAC_RED:
	    *value = DAC[DAC_rd_addr].red;
	    DAC_rgb_state = DAC_GREEN;
	    break;

    case DAC_GREEN:
	    *value = DAC[DAC_rd_addr].green;
	    DAC_rgb_state = DAC_BLUE;
	    break;

    case DAC_BLUE:
	    *value = DAC[DAC_rd_addr].blue;
	    DAC_rgb_state = DAC_RED;
	    /* NB important side affect of 3rd read */
	    DAC_rd_addr++;
	    break;

    default:
	    assert1(NO,"bad DAC state %d",DAC_rgb_state);
    }
    note_entrance1("returning %#x",*value);
#endif  //NEC_98
}

#if defined(NTVDM) && defined(X86GFX)
/*
 * There is no way of obtaining the DAC read address via a port access
 * (that we know of). Thus save/restore stuff etc needs this interface.
 */
half_word get_vga_DAC_rd_addr()
{
    return DAC_rd_addr;
}
#endif	/* NTVDM & X86GFX */

VOID    vote_vga_mode IFN0()
{
#ifndef NEC_98
        int     votes;

        votes = graphics_controller.miscellaneous.as_bfld.graphics_mode;
        votes += attribute_controller.mode_control.as_bfld.graphics_mode;
        switch(votes) {
        case 0:
                if (!is_it_text())
                {
                        /* switch to text mode */
                        set_text_mode(YES);
                        flag_mode_change_required();
                }
                break;

        case 2:
                if (is_it_text())
                {
                        /* switch to graphics mode */
                        set_text_mode(NO);
                        flag_mode_change_required();
                }
                break;

        case 1:
                if (graphics_controller.miscellaneous.as_bfld.graphics_mode)
                {
                        if (is_it_text())
                        {
                                assert0(NO,"Forcing mode to be graphics cos graphics controller sez so");
                                set_text_mode(NO);
                                flag_mode_change_required();
                        }
                }
                else
                {
                        if (!is_it_text())
                        {
                                assert0(NO,"Forcing mode to be alpha cos graphics controller sez so");
                                set_text_mode(YES);
                                flag_mode_change_required();
                        }
                }
                break;

        default:
                assert1(NO,"Wierd vote result %d in vote_vga_mode",votes);
        }
#endif //NEC_98
}       /* vote_vga_mode */

#ifdef GISP_SVGA
/*(
 *	function	:	mapRealIOPorts( )
 *
 *	purpose		:	mapping of real io functions for HW
 *				vga on ccpu
 *
 *	inputs		:	none
 *	outputs		:	none
 *	returns		:	void
 *	globals		:	none
 *	
 *	
)*/

void
mapRealIOPorts IFN0( )
{
#ifndef NEC_98
	always_trace0("mapping vga ports to _real_ IN/OUT");
	/*
	 * Define sequencer's ports
	 */

	io_define_outb(EGA_SEQ_ADAP_INDEX, hostRealOUTB );
	io_define_outb(EGA_SEQ_ADAP_DATA, hostRealOUTB );
        io_define_inb(EGA_SEQ_ADAP_INDEX, hostRealINB );
        io_define_inb(EGA_SEQ_ADAP_DATA, hostRealINB );

	/*
	 * Define CRTC's ports
	 */

	io_define_outb(EGA_CRTC_ADAPTOR, hostRealOUTB );
	io_define_inb(EGA_CRTC_ADAPTOR, hostRealINB );

	/*
	 * Define Graphics Controller's ports
	 */

	io_define_outb(EGA_GC_ADAP_INDEX, hostRealOUTB );
	Cpu_define_outb(EGA_GC_ADAP_INDEX, NULL );

	io_define_outb(EGA_GC_ADAP_DATA, hostRealOUTB );
	Cpu_define_outb(EGA_GC_ADAP_DATA,NULL);

	io_define_inb(EGA_GC_ADAP_INDEX, hostRealINB );
	io_define_inb(EGA_GC_ADAP_DATA, hostRealINB );

	/*
	 * Define Attribute controller's ports
	 */

	io_define_outb(EGA_AC_ADAPTOR, hostRealOUTB );
	io_define_inb(EGA_AC_ADAPTOR, hostRealINB );

	/*
	 * Define Miscellaneous register's port
	 */

	io_define_outb(EGA_MISC_ADAPTOR, hostRealOUTB );
	io_define_inb(EGA_MISC_ADAPTOR, hostRealINB );

	/*
	 * Define Feature controller's port
	 */

	io_define_outb(EGA_FEAT_ADAPTOR, hostRealOUTB );
	io_define_inb(EGA_FEAT_ADAPTOR, hostRealINB );

	/*
	 * Define Input Status Register 0 port
	 */

	io_define_inb(EGA_IPSTAT0_ADAPTOR, hostRealINB );

	/*
	 * Define Input Status Register 1 port
	 */

	io_define_inb(EGA_IPSTAT1_ADAPTOR, hostRealINB );

        /*
         * Define VGA DAC register port
         */
        io_define_inb(VGA_DAC_INDEX_PORT, hostRealINB );
        io_define_outb(VGA_DAC_INDEX_PORT, hostRealOUTB );
        io_define_inb(VGA_DAC_DATA_PORT, hostRealINB );
        io_define_outb(VGA_DAC_DATA_PORT, hostRealOUTB );

#endif //NEC_98
}


/*(
 *	function	:	mapEmulatedIOPorts( )
 *
 *	purpose		:	mapping of emulated io functions for HW
 *				vga on ccpu
 *
 *	inputs		:	none
 *	outputs		:	none
 *	returns		:	void
 *	globals		:	none
 *	
 *	
)*/

void
mapEmulatedIOPorts IFN0( )
{
#ifndef NEC_98
	always_trace0( "Mapping vga ports to Emulation" );

	/*
	 * Define sequencer's ports
	 */

	io_define_outb(EGA_SEQ_ADAP_INDEX,vga_seq_outb_index);
	io_define_outb(EGA_SEQ_ADAP_DATA,ega_seq_reset);
        io_define_inb(EGA_SEQ_ADAP_INDEX,vga_seq_inb);
        io_define_inb(EGA_SEQ_ADAP_DATA,vga_seq_inb);
	io_connect_port(EGA_SEQ_INDEX,EGA_SEQ_ADAP_INDEX,IO_READ_WRITE);
	io_connect_port(EGA_SEQ_DATA,EGA_SEQ_ADAP_DATA,IO_READ_WRITE);

	/*
	 * Define CRTC's ports
	 */

	io_define_outb(EGA_CRTC_ADAPTOR,vga_crtc_outb);
	io_define_inb(EGA_CRTC_ADAPTOR,vga_crtc_inb);
	io_connect_port(EGA_CRTC_INDEX,EGA_CRTC_ADAPTOR,IO_READ_WRITE);
	io_connect_port(EGA_CRTC_DATA,EGA_CRTC_ADAPTOR,IO_READ_WRITE);

	/*
	 * Define Graphics Controller's ports
	 */

	vga_gc_outb_index_addr = (UTINY *) &graphics_controller.address;

	io_define_outb(EGA_GC_ADAP_INDEX,vga_gc_outb_index);
	Cpu_define_outb(EGA_GC_ADAP_INDEX,_vga_gc_outb_index);

	io_define_outb(EGA_GC_ADAP_DATA,ega_gc_set_reset);
	Cpu_define_outb(EGA_GC_ADAP_DATA,NULL);

	io_define_inb(EGA_GC_ADAP_INDEX,vga_gc_inb);
	io_define_inb(EGA_GC_ADAP_DATA,vga_gc_inb);

	io_connect_port(EGA_GC_INDEX,EGA_GC_ADAP_INDEX,IO_READ_WRITE);
	io_connect_port(EGA_GC_DATA,EGA_GC_ADAP_DATA,IO_READ_WRITE);

	/*
	 * Define Attribute controller's ports
	 */

	io_define_outb(EGA_AC_ADAPTOR,vga_ac_outb);
	io_define_inb(EGA_AC_ADAPTOR,vga_ac_inb);
	io_connect_port(EGA_AC_INDEX_DATA,EGA_AC_ADAPTOR,IO_READ_WRITE);
	io_connect_port(EGA_AC_SECRET,EGA_AC_ADAPTOR,IO_READ);

	/*
	 * Define Miscellaneous register's port
	 */

	io_define_outb(EGA_MISC_ADAPTOR,vga_misc_outb);
	io_define_inb(EGA_MISC_ADAPTOR,vga_misc_inb);
	io_connect_port(EGA_MISC_REG,EGA_MISC_ADAPTOR,IO_WRITE);
	io_connect_port(VGA_MISC_READ_REG,EGA_MISC_ADAPTOR,IO_READ);

	/*
	 * Define Feature controller's port
	 */

	io_define_outb(EGA_FEAT_ADAPTOR,vga_feat_outb);
	io_define_inb(EGA_FEAT_ADAPTOR,vga_feat_inb);
	io_connect_port(EGA_FEAT_REG,EGA_FEAT_ADAPTOR,IO_WRITE);
	io_connect_port(VGA_FEAT_READ_REG,EGA_FEAT_ADAPTOR,IO_READ);

	/*
	 * Define Input Status Register 0 port
	 */

	io_define_inb(EGA_IPSTAT0_ADAPTOR,vga_ipstat0_inb);
	io_connect_port(EGA_IPSTAT0_REG,EGA_IPSTAT0_ADAPTOR,IO_READ);

	/*
	 * Define Input Status Register 1 port
	 */

	io_define_inb(EGA_IPSTAT1_ADAPTOR,vga_ipstat1_inb);
	io_connect_port(EGA_IPSTAT1_REG,EGA_IPSTAT1_ADAPTOR,IO_READ);

        /*
         * Define VGA DAC register port
         */
        io_define_inb(VGA_DAC_INDEX_PORT,vga_dac_inb);
        io_define_outb(VGA_DAC_INDEX_PORT,vga_dac_outb);
        io_connect_port(VGA_DAC_MASK,VGA_DAC_INDEX_PORT,IO_READ_WRITE);
        io_connect_port(VGA_DAC_RADDR,VGA_DAC_INDEX_PORT,IO_READ_WRITE);
        io_connect_port(VGA_DAC_WADDR,VGA_DAC_INDEX_PORT,IO_READ_WRITE);
        io_define_inb(VGA_DAC_DATA_PORT,vga_dac_data_inb);
        io_define_outb(VGA_DAC_DATA_PORT,vga_dac_data_outb);
        io_connect_port(VGA_DAC_DATA,VGA_DAC_DATA_PORT,IO_READ_WRITE);

#endif //NEC_98
}

#endif 		/* GISP_SVGA */


#ifdef HUNTER

/* Get line compare value */

LONG vga_get_line_compare  IFN0()

    {
    LONG		return_value;

    return_value = crt_controller.line_compare;
    if (crt_controller.crtc_overflow.as_bfld.line_compare_bit_8 != 0)
	return_value += 0x100;
    return (return_value);
    }			/* ega_get_line_compare */

/* Get maximum scan lines value */

LONG vga_get_max_scan_lines  IFN0()

    {
    return (crt_controller.maximum_scan_line.as_bfld.maximum_scan_line);
    }			/* ega_get_max_scan_lines */

/* Set line compare value */

VOID vga_set_line_compare  IFN1(LONG,lcomp_val)

/* lcomp_val ----> new value for line compare */

    {
#ifndef NEC_98
    CRTC_OVERFLOW	new_overflow;

    new_overflow.as.abyte = crt_controller.crtc_overflow.as.abyte;
    if (lcomp_val >= 0x100)
	new_overflow.as_bfld.line_compare_bit_8 = 1;
    else
	new_overflow.as_bfld.line_compare_bit_8 = 0;

    outb(EGA_CRTC_INDEX, 7);
    outb(EGA_CRTC_DATA, new_overflow.as.abyte);
    outb(EGA_CRTC_INDEX, 24);
    outb(EGA_CRTC_DATA, lcomp_val & 0xff);
#endif //NEC_98
    }

#endif /* HUNTER */
#endif /* VGG */
#endif /* REAL_VGA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\vga_vide.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title        : vga_video.c
 *
 * Description  : BIOS video internal routines.
 *
 * Author       : William Gulland
 *
 * Notes        : The following functions are defined in this module:
 *
 *
 *
 */

/*
 *      static char SccsID[]="@(#)vga_video.c   1.37 06/26/95 Copyright Insignia Solutions Ltd.";
 */


#ifdef VGG

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "VIDEO_BIOS_VGA.seg"
#endif

/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH
#include FCntlH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "bios.h"
#include "ios.h"
#include "gmi.h"
#include "sas.h"
#include "gvi.h"
#include "timer.h"
#include "gfx_upd.h"
#include "host.h"
#include "egacpu.h"
#include "egaports.h"
#include "egagraph.h"
#include "egaread.h"
#include "video.h"
#include "egavideo.h"
#include "equip.h"
#include "vga_dac.h"
#include "vgaports.h"
#include "debug.h"

#ifndef PROD
#include "trace.h"
#endif

#include "host_gfx.h"

/*
 * ============================================================================
 * Global data
 * ============================================================================
 */


/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */

#define DISABLE_REFRESH         0x20
/* the bit in the vga seq clock register that disables screen refresh */

#define VGA_COLOUR 8    /* Display Code */
typedef struct _rgb
{
        byte red;
        byte green;
        byte blue;
} rgb_struct;

/* internal function declarations */

/* To convert to grey, set all components to 30% r, 59% g and 11% b. */
static void greyify(rgb)
rgb_struct *rgb;
{
        unsigned int grey;

        grey = (30*rgb->red+59*rgb->green+11*rgb->blue)/100;
        rgb->red = rgb->green = rgb->blue = (unsigned char)grey;
}

static void set_dac(dac,rgb)
half_word dac;
rgb_struct *rgb;
{
        if(is_GREY())greyify(rgb);
#ifndef NEC_98
        outb(VGA_DAC_WADDR,dac);
        outb(VGA_DAC_DATA,rgb->red);
        outb(VGA_DAC_DATA,rgb->green);
        outb(VGA_DAC_DATA,rgb->blue);
#endif  //NEC_98
}

static void get_dac(dac,rgb)
half_word dac;
rgb_struct *rgb;
{
#ifndef NEC_98
        outb(VGA_DAC_RADDR,dac);
        inb(VGA_DAC_DATA,&(rgb->red));
        inb(VGA_DAC_DATA,&(rgb->green));
        inb(VGA_DAC_DATA,&(rgb->blue));
#endif  //NEC_98
}


/*
 * ============================================================================
 * External functions
 * ============================================================================
 */


void init_vga_dac(table)
int table;      /* Which table to use */
{
#ifndef NEC_98
    int loop;
    byte *dac;
    rgb_struct rgb;

#ifdef  macintosh

        /* load the required DAC in */
        dac = host_load_vga_dac (table);

        /* check it worked */
        if (!dac)
                return;

#else   /* macintosh */

    switch (table)
    {
        case 0:
          dac = vga_dac;
          break;
        case 1:
          dac = vga_low_dac;
          break;
        case 2:
          dac = vga_256_dac;
          break;
        default:
          assert1(FALSE,"Bad VGA DAC table %d",table);
    }

#endif  /* macintosh */

    for(loop = 0; loop < 0x100; loop++)
        {
                rgb.red = *dac; rgb.green = dac[1]; rgb.blue = dac[2];
                set_dac(loop,&rgb);
                dac+=3;
    }

#ifdef  macintosh

        /* and dump the DAC back into the heap */
        host_dump_vga_dac ();

#endif  /* macintosh */
#endif  //NEC_98
}

/***** Routines to handle VGA 256 colour modes, called from video.c **********/
GLOBAL VOID vga_graphics_write_char
        IFN6( LONG, col, LONG, row, LONG, ch, IU8, colour, LONG, page, LONG, nchs)
{
#ifndef NEC_98
        register sys_addr char_addr;
        register long screen_offset;
        register int i,j,k,char_height,len;
        register int scan_length = 8*sas_w_at_no_check(VID_COLS);
        register byte mask, val, bank;

        UNUSED(page);

        char_height = sas_hw_at_no_check(ega_char_height);
        char_addr = follow_ptr(EGA_FONT_INT*4)+char_height*ch;

/* VGA 256 colour mode has only one page, so ignore 'page' */

        /*
         * Set read/write banks to zero to optimise the update_alg call
         */

        set_banking( 0, 0 );

        screen_offset = row*scan_length*char_height+8*col;
        len = ( nchs << 3 ) - 1;

        for(i=0;i<char_height;i++)
        {
                (*update_alg.mark_fill)( screen_offset, screen_offset + len );

                val = sas_hw_at_no_check(char_addr);
                char_addr++;

                for(j=0;j<nchs;j++)
                {
                        mask = 0x80;

                        for(k=0;k<8;k++)
                        {
                                if( val & mask )
                                        *(IU8 *)(getVideowplane() + screen_offset) = colour;
                                else
                                        *(IU8 *)(getVideowplane() + screen_offset) = 0;

                                screen_offset++;
                                mask = mask >> 1;
                        }
                }

                screen_offset += scan_length - ( nchs << 3 );
        }

        /*
         * Set read/write banks to last value in case someone relies on this side-effect
         */

        bank = (byte)(( screen_offset - ( scan_length - ( nchs << 3 ))) >> 16);
        set_banking( bank, bank );
#endif  //NEC_98
}

GLOBAL VOID vga_write_dot
        IFN4(LONG, colour, LONG, page, LONG, pixcol, LONG, row)
{
#ifndef NEC_98
#ifdef REAL_VGA
        register sys_addr screen_offset;

        screen_offset = video_pc_low_regen+8*row*sas_w_at_no_check(VID_COLS)+pixcol;
        sas_store(screen_offset, colour); /* WOW - that's easy!! */
#else
        long screen_offset;
        UTINY bank;

        UNUSED(page);

        screen_offset = (8*row*sas_w_at_no_check(VID_COLS)+pixcol);

        bank = (UTINY)(screen_offset >> 16);
        set_banking( bank, bank );

        EGA_plane0123[screen_offset] = (UCHAR)colour;
        (*update_alg.mark_byte)(screen_offset);
#endif  /* REAL_VGA */
#endif  //NEC_98
}

GLOBAL VOID vga_sensible_graph_scroll_up
        IFN6( LONG, row, LONG, col, LONG, rowsdiff, LONG, colsdiff, LONG, lines, LONG, attr)
{
#ifndef NEC_98
        register int col_incr = 8*sas_w_at_no_check(VID_COLS);
        register int i;
        register long source,dest;
        register byte char_height;
        boolean screen_updated;

        col *= 8; colsdiff *= 8; /* 8 bytes per character */
        char_height = sas_hw_at_no_check(ega_char_height);
        rowsdiff *= char_height;
        lines *= char_height;
#ifdef REAL_VGA
        /* Not done for back M */
        dest = video_pc_low_regen+sas_loadw(VID_ADDR)+
                row*col_incr*char_height+col;
        source = dest+lines*col_incr;
        for(i=0;i<rowsdiff-lines;i++)
        {
                memcpy_16(dest,source,colsdiff);
                source += col_incr;
                dest += col_incr;
        }
        while(lines--)
        {
                memset_16(dest,attr,colsdiff);
                dest += col_incr;
        }
#else
        dest = sas_w_at_no_check(VID_ADDR)+ row*col_incr*char_height+col;
        source = dest+lines*col_incr;
        screen_updated = (col+colsdiff) <= col_incr;  /* Check for silly scroll */
        if(screen_updated)
                screen_updated = (*update_alg.scroll_up)(dest,colsdiff,rowsdiff,attr,lines,0);
        for(i=0;i<rowsdiff-lines;i++)
        {
                memcpy(&EGA_plane0123[dest],&EGA_plane0123[source],colsdiff);
                if(!screen_updated)
                        (*update_alg.mark_string)(dest,dest+colsdiff-1);
                source += col_incr;
                dest += col_incr;
        }
        while(lines--)
        {
                memset(&EGA_plane0123[dest],attr,colsdiff);
                if(!screen_updated)
                        (*update_alg.mark_fill)(dest,dest+colsdiff-1);
                dest += col_incr;
        }
#endif  /* REAL_VGA */
#endif  //NEC_98
}

GLOBAL VOID vga_sensible_graph_scroll_down
        IFN6( LONG, row, LONG, col, LONG, rowsdiff, LONG, colsdiff, LONG, lines, LONG, attr)
{
#ifndef NEC_98
        register int col_incr = 8*sas_w_at_no_check(VID_COLS);
        register int i;
        register long source,dest;
        register byte char_height;
        boolean screen_updated;

        col *= 8; colsdiff *= 8; /* 8 bytes per character */
        char_height = sas_hw_at_no_check(ega_char_height);
        rowsdiff *= char_height;
        lines *= char_height;
#ifdef REAL_VGA
        /* Not done for back M */
        dest = video_pc_low_regen+sas_loadw(VID_ADDR)+
                row*col_incr*char_height+col;
        dest += (rowsdiff-1)*col_incr;
        source = dest-lines*col_incr;
        for(i=0;i<rowsdiff-lines;i++)
        {
                memcpy_16(dest,source,colsdiff);
                source -= col_incr;
                dest -= col_incr;
        }
        while(lines--)
        {
                memset_16(dest,attr,colsdiff);
                dest -= col_incr;
        }
#else
        dest = sas_w_at_no_check(VID_ADDR)+ row*col_incr*char_height+col;
        screen_updated = (col+colsdiff) <= col_incr;  /* Check for silly scroll */
        if(screen_updated)
                screen_updated = (*update_alg.scroll_down)(dest,colsdiff,rowsdiff,attr,lines,0);
        dest += (rowsdiff-1)*col_incr;
        source = dest-lines*col_incr;
        for(i=0;i<rowsdiff-lines;i++)
        {
                memcpy(&EGA_planes[dest],&EGA_planes[source],colsdiff);
                if(!screen_updated)
                        (*update_alg.mark_string)(dest,dest+colsdiff-1);
                source -= col_incr;
                dest -= col_incr;
        }
        while(lines--)
        {
                memset(&EGA_planes[dest],attr,colsdiff);
                if(!screen_updated)
                        (*update_alg.mark_fill)(dest,dest+colsdiff-1);
                dest -= col_incr;
        }
#endif  /* REAL_VGA */
#endif  //NEC_98
}

GLOBAL VOID vga_read_attrib_char IFN3(LONG, col, LONG, row, LONG, page)
{
#ifndef NEC_98
        byte the_char[256];
        register host_addr screen;
        register int i,k;
        register int scan_length = 8*sas_w_at_no_check(VID_COLS);
    register byte mask;
        byte char_height = sas_hw_at_no_check(ega_char_height);

        UNUSED(page);

/*printf("vga_read_attrib_char(%d,%d,%d)\n",
        col,row,page);*/
/* VGA 256 colour mode has only one page, so ignore 'page' */
#ifdef REAL_VGA
        screen = video_pc_low_regen+row*scan_length*char_height+8*col;
#else
        screen = &EGA_plane0123[row*scan_length*char_height+8*col];
#endif  /* REAL_VGA */
        for(i=0;i<char_height;i++)
        {
                mask = 0x80;
                the_char[i]=0;
                for(k=0;k<8;k++)
                {
                        if(*screen++)
                                the_char[i] |= mask;
                        mask = mask >> 1;
                }
                screen += scan_length - 8;
        }
        search_font((char *)the_char,(int)char_height);
#endif  //NEC_98
}

GLOBAL VOID vga_read_dot IFN3(LONG, page, LONG, pixcol, LONG, row)
{
#ifndef NEC_98
        register host_addr screen;

        UNUSED(page);

/*printf("vga_read_dot(%d,%d,%d)\n",page,col,row);*/
#ifdef REAL_VGA
        screen = video_pc_low_regen+8*row*sas_w_at_no_check(VID_COLS)+pixcol;
#else
        screen = &EGA_plane0123[8*row*sas_w_at_no_check(VID_COLS)+pixcol];
#endif  /* REAL_VGA */
        setAL(*screen) ; /* WOW - that's easy!! */
#endif  //NEC_98
}

/****** Routines to handle BIOS functions new to VGA *******/
void vga_set_palette()
{
#ifndef NEC_98
        /*
         * Called via INT 10 AH=10, AL='not understood by ega_set_palette()'
         * Sets/reads VGA DACs.
         */
        UCHAR i;
    word i2;
    int dac;
        byte temp; /* For inb()s. */
        byte mode_reg;
        rgb_struct rgb_dac;
        sys_addr ptr;
        switch(getAL())
        {
                case 7:         /* Read attribute register */
                        outb(EGA_AC_INDEX_DATA,getBL()); /* set index */
                        inb(EGA_AC_SECRET,&temp);
                        setBH(temp);
                        inb(EGA_IPSTAT1_REG,&temp);
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        break;
                case 8:         /* Read overscan register */
                        outb(EGA_AC_INDEX_DATA,17); /* overscan index */
                        inb(EGA_AC_SECRET,&temp);
                        setBH(temp);
                        inb(EGA_IPSTAT1_REG,&temp);
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        break;
                case 9:         /* Read all palette regs. + overscan */
                        ptr = effective_addr(getES(),getDX());
                        for(i=0;i<16;i++)
                        {
                                outb(EGA_AC_INDEX_DATA,i); /* set index */
                                inb(EGA_AC_SECRET,&temp);
                                sas_store(ptr, temp);
                                inb(EGA_IPSTAT1_REG,&temp);
                                ptr++;
                        }
                        outb(EGA_AC_INDEX_DATA,17); /* overscan index */
                        inb(EGA_AC_SECRET,&temp);
                        sas_store(ptr, temp);
                        inb(EGA_IPSTAT1_REG,&temp);
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        break;
                case 0x10:      /* Set one DAC */
                        rgb_dac.red = getDH();
                        rgb_dac.green = getCH();
                        rgb_dac.blue = getCL();
                        set_dac(getBX(),&rgb_dac);
                        break;
                case 0x12:      /* Set block of DACs */
                        ptr = effective_addr(getES(),getDX());
                        dac = getBX();
                        for(i2=0;i2<getCX();i2++)
                        {
                           rgb_dac.red = sas_hw_at_no_check(ptr);
                           rgb_dac.green = sas_hw_at_no_check(ptr+1);
                           rgb_dac.blue = sas_hw_at_no_check(ptr+2);
                           set_dac(dac,&rgb_dac);
                           dac++;ptr += 3;
                        }
                        break;
                case 0x13:      /* Set paging mode
                                 * see Prog Guide to Video Systems, pp60-63]
                                 * and IBM ROM BIOS pp26-27.
                                 */
                        outb(EGA_AC_INDEX_DATA,16); /* mode control index */
                        inb(EGA_AC_SECRET,&mode_reg);  /* Old value */
                        if(getBL()==0)
                        {  /* Select paging mode */
                           outb(EGA_AC_INDEX_DATA,
                                (IU8)((mode_reg & 0x7f) | (getBH()<<7)));
                        }
                        else /* Select a palette page */
                        {
                           inb(EGA_IPSTAT1_REG,&temp);
                           outb(EGA_AC_INDEX_DATA,20); /* pixel padding index */
                           if(mode_reg & 0x80)
                            /* 16 entry palettes
                             *  bits 0-3of the pad register relevant */
                             outb(EGA_AC_INDEX_DATA,getBH());
                           else
                            /* 64 entry palette - only bits 2-3 relevent */
                             outb(EGA_AC_INDEX_DATA,(IU8)(getBH()<<2));
                        }
                        inb(EGA_IPSTAT1_REG,&temp);
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        break;

                case 0x15:      /* Get value of one DAC */
                        get_dac(getBX(),&rgb_dac);
                        setDH(rgb_dac.red);
                        setCH(rgb_dac.green);
                        setCL(rgb_dac.blue);
                        break;
                case 0x17:
                        ptr = effective_addr(getES(),getDX());
                        dac = getBX();
                        for(i2=0;i2<getCX();i2++)
                        {
                           get_dac(dac,&rgb_dac);
                           sas_store(ptr, rgb_dac.red);
                           sas_store(ptr+1, rgb_dac.green);
                           sas_store(ptr+2, rgb_dac.blue);
                           dac++;
                           ptr += 3;
                        }
                        break;
                case 0x18:
                        /* Set the VGA DAC mask. */
                        outb(VGA_DAC_MASK,getBL());
                        break;
                case 0x19:
                        /* Get the VGA DAC mask. */
                        inb(VGA_DAC_MASK,&temp);
                        setBL(temp);
                        break;
                case 0x1a:
                        /* Return current mode control & pixel padding */
                        outb(EGA_AC_INDEX_DATA,16); /* mode control index */
                        inb(EGA_AC_SECRET,&mode_reg);
                        if(mode_reg & 0x80)
                                setBL(1);
                        else
                                setBL(0);
                        inb(EGA_IPSTAT1_REG,&temp);
                        outb(EGA_AC_INDEX_DATA,20); /* pixel padding index */
                        inb(EGA_AC_SECRET,&temp);
                        setBH(temp);
                        inb(EGA_IPSTAT1_REG,&temp);
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        break;
                case 0x1b:      /* Convert set of DACs to grey scale. */
                        dac = getBX();
                        for(i2=0;i2<getCX();i2++)
                        {
                                get_dac(dac,&rgb_dac);
                                greyify(&rgb_dac);
                                set_dac(dac,&rgb_dac);
                                dac++;
                        }
                        break;
                default:
                        assert1(FALSE,"Bad set palette submode %#x",getAL());
                        break;
        }
#endif  //NEC_98
}

/*
 * Various miscellaneous flags can be set using
 * INT 10, AH 12, AL flag.
 * Called from ega_alt_sel().
 */
void vga_func_12()
{
#ifndef NEC_98
        half_word       seq_clock;

        switch(getBL())
        {
                case 0x30:      /* Set number of scan lines */
                        if(getAL() == 0)
                                set_VGA_lines(S200);
                        else if(getAL() == 1)
                                set_VGA_lines(S350);
                        else
                                set_VGA_lines(S400);
                        setAL(0x12);    /* We did it */
                        break;
                case 0x33:      /* Enable/Disable Grey-Scale Summing */
                        if(getAL())
                                set_GREY(0);
                        else
                                set_GREY(GREY_SCALE);
                        setAL(0x12);    /* We did it */
                        break;
                case 0x34:      /* Enable/disable Cursor Emulation */
                        set_EGA_cursor_no_emulate(getAL() & 1);
                        setAL(0x12);    /* We did it */
                        break;

                case 0x36:      /* Enable/Disable Screen Refresh */
                        if (getAL() == 0)
                        {
                                outb(EGA_SEQ_INDEX, 1);
                                inb(EGA_SEQ_DATA, &seq_clock);
                                outb(EGA_SEQ_DATA, (IU8)(seq_clock & ~DISABLE_REFRESH));
                        }
                        else
                        {
                                outb(EGA_SEQ_INDEX, 1);
                                inb(EGA_SEQ_DATA, &seq_clock);
                                outb(EGA_SEQ_DATA, (IU8)(seq_clock | DISABLE_REFRESH));
                        }
                        setAL(0x12);
                        break;
                case 0x31:      /* Enable/Disable Default Palette Loading */
                case 0x32:      /* Enable/Disable Video */
                case 0x35:      /* Switch active display */
                        /* do not set code that means it worked */
                default:
                        setAL(0);       /* Function not supported */
                        break;
        }
#endif  //NEC_98
}
void vga_disp_comb()
{
#ifndef NEC_98
        /* check that we really are a VGA */
        if (video_adapter != VGA)
        {
                /* we are not -so this function is not implemented */
                not_imp();
                return;
        }

        /*
         * On a PS/2, AL=1 is (I believe) used to switch active displays.
         * We ignore this.
         * AL=0 returns the current display, which we can cope with.
         */
        if(getAL() == 0)
        {
                setBH(0);          /* Only one display, so no inactive one! */
                setBL(VGA_COLOUR); /* VGA with colour monitor. (7 for mono) */
        }
        setAX(0x1A); /* Tell him we coped. */
#endif  //NEC_98
}

void vga_disp_func()
{
#ifndef NEC_98
        /*
         * This function returns masses of info. about the current
         * display and screen mode.
         * One of the things returned is a pointer to the display info.
         * This is stored in the VGA ROM, so all we need to do is set
         * the pointer up.
         *
         */
        sys_addr buf = effective_addr(getES(),getDI());
        byte temp,mode_reg, video_mode;

#if defined(NTVDM) && defined(X86GFX)
        IMPORT word vga1b_seg, vga1b_off;
#endif  /* NTVDM & X86GFX */

        /* check that we really are a VGA */
#ifndef HERC
        if (video_adapter != VGA)
#else
        if ( (video_adapter != VGA) && (video_adapter != HERCULES))
#endif  /* HERC */
        {
                /* we are not -so this function is not implemented */
                not_imp();
                return;
        }

#ifdef HERC
     if( video_adapter == VGA)
     {
#endif  /* HERC */
        video_mode = sas_hw_at_no_check(vd_video_mode);
#ifdef V7VGA
        if ((video_mode == 1) && extensions_controller.foreground_latch_1)
                video_mode = extensions_controller.foreground_latch_1;
        else if (video_mode > 0x13)
                video_mode += 0x4c;
#endif /* V7VGA */

/*
 * Store VGA capability table pointer. Usually lives in Insignia ROM, on NT
 * x86 it has to live in ntio.sys.
 */
#if defined(NTVDM) && defined(X86GFX)
        sas_storew(buf, vga1b_off);
        sas_storew(buf+2, vga1b_seg);
#else
        sas_storew(buf,INT10_1B_DATA);
        sas_storew(buf+2,EGA_SEG);
#endif  /* NTVDM & X86GFX */

        sas_store(buf+0x4, video_mode); /* Current video mode */
        sas_storew(buf+5,sas_w_at_no_check(VID_COLS)); /* Cols on screen */
        sas_storew(buf+7,sas_w_at_no_check(VID_LEN));  /* Size of screen */
        sas_storew(buf+9,sas_w_at_no_check(VID_ADDR)); /* Address of screen */
        sas_move_bytes_forward(VID_CURPOS,buf+0xB,16);      /* Cursor positions */
        sas_storew(buf+0x1b,sas_w_at_no_check(VID_CURMOD)); /* Cursor type */
        sas_store(buf+0x1D, sas_hw_at_no_check(vd_current_page));
        sas_storew(buf+0x1E,sas_w_at_no_check(VID_INDEX));
        sas_store(buf+0x20, sas_hw_at_no_check(vd_crt_mode));
        sas_store(buf+0x21, sas_hw_at_no_check(vd_crt_palette));
        sas_store(buf+0x22, (IU8)(sas_hw_at_no_check(vd_rows_on_screen)+1));
        sas_storew(buf+0x23,sas_w_at_no_check(ega_char_height));
        sas_store(buf+0x25, VGA_COLOUR);        /* Active display */
        sas_store(buf+0x26, 0);         /* Inactive display (none) */
#ifdef V7VGA
        if (video_mode >= 0x60)
        {
                sas_storew(buf+0x27,vd_ext_graph_table[video_mode-0x60].ncols);
                sas_store(buf+0x29, vd_ext_graph_table[video_mode-0x60].npages);
        }
        else if (video_mode >= 0x40)
        {
                sas_storew(buf+0x27,vd_ext_text_table[video_mode-0x40].ncols);
                sas_store(buf+0x29, vd_ext_text_table[video_mode-0x40].npages);
        }
        else
        {
                sas_storew(buf+0x27,vd_mode_table[video_mode].ncols);
                sas_store(buf+0x29, vd_mode_table[video_mode].npages);
        }
#else
        sas_storew(buf+0x27,vd_mode_table[video_mode].ncols);
        sas_store(buf+0x29, vd_mode_table[video_mode].npages);
#endif /* V7VGA */
        sas_store(buf+0x2A, (IU8)(get_scanlines()));

        outb(EGA_SEQ_INDEX,3);
        inb(EGA_SEQ_DATA,&temp);        /* Character Font select reg. */
        sas_store(buf+0x2B, (IU8)((temp & 3)|((temp & 0x10)>>2)));
                         /* extract bits 410 - font B */
        sas_store(buf+0x2C, (IU8)(((temp & 0xC)>>2)|((temp & 0x20)>>3)));
                        /* extract bits 532 - font A */

        temp = 1;                       /* All modes on all displays active */
        if(is_GREY())temp |= 2;
        if(is_MONO())temp |= 4;
        if(is_PAL_load_off())temp |=8;
        if(get_EGA_cursor_no_emulate())temp |= 0x10;
        inb(EGA_IPSTAT1_REG,&mode_reg); /* Clear Attribute flip-flop */
        outb(EGA_AC_INDEX_DATA,16); /* mode control index */
        inb(EGA_AC_SECRET,&mode_reg);
        if(mode_reg & 8)temp |= 0x20;
        inb(EGA_IPSTAT1_REG,&mode_reg); /* Clear Attribute flip-flop */
        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
        sas_store(buf+0x2D, temp);
        sas_store(buf+0x31, 3);         /* 256KB video memory */
        setAX(0x1B); /* We did it! */
#ifdef HERC
       } /* if VGA */
    if( video_adapter == HERCULES)
     {
        video_mode = sas_hw_at(vd_video_mode);
        sas_storew(buf,INT10_1B_DATA);
        sas_storew(buf+2,EGA_SEG);
        sas_store(buf+0x4, video_mode);                         /* Current video mode */
        sas_storew(buf+5,sas_w_at(VID_COLS));                   /* Cols on screen */
        sas_storew(buf+7,sas_w_at(VID_LEN));                    /* Size of screen */
        sas_storew(buf+9,sas_w_at(VID_ADDR));                   /* Address of screen */
        sas_move_bytes_forward(VID_CURPOS,buf+0xB,16);          /* Cursor positions */
        sas_store(buf+0x1b, HERC_CURS_START+HERC_CURS_HEIGHT);  /* Cursor end line */
        sas_store(buf+0x1c, HERC_CURS_START);                   /* Cursor start line */
        sas_store(buf+0x1D, sas_hw_at(vd_current_page));
        sas_storew(buf+0x1E,sas_w_at(VID_INDEX));
        sas_store(buf+0x20, sas_hw_at(vd_crt_mode));
        sas_store(buf+0x21, sas_hw_at(vd_crt_palette));
        sas_store(buf+0x22, sas_hw_at(vd_rows_on_screen)+1);
        sas_storew(buf+0x23, 14);                               /* char height is 14 */
        sas_store(buf+0x25,0x01 );      /* 01=MDA with monochrome display as Active display */
        sas_store(buf+0x26, 0);         /* Inactive display (none) */

        vd_mode_table[video_mode].ncols= 2;                     /* Black & White 2 colors */
        sas_storew(buf+0x27,vd_mode_table[video_mode].ncols);
        vd_mode_table[video_mode].npages= 2;                    /* support 2 pages  */
        sas_store(buf+0x29, vd_mode_table[video_mode].npages);

        sas_store(buf+0x2A, get_scanlines());

        sas_store(buf+0x2B,0x00);       /* Primary Font select always 0 */
        sas_store(buf+0x2C,0x00);       /* Secondary Font select always 0 */


        sas_store(buf+0x2D, 0x30);      /* MDA with Monochrome Display */
        sas_store(buf+0x31, 0);         /* 64KB video memory */
        setAX(0x1B); /* We did it! */
       } /* if HERCULES */
#endif  /* HERC */
#endif  //NEC_98
}

void vga_int_1C()
{
#ifndef NEC_98
sys_addr buff = effective_addr(getES(),getBX());
UCHAR i;
int i2;
word states;
half_word temp;
rgb_struct rgb_dac;
static word buff_sizes[] = { 0,2,2,3,0x0d,0x0e,0x0e,0x0f };
static byte const1[] = { 2,0x18,6,0x20 };
static byte const2[] = { 0xd4,3,0x20,7,0,0 };
static byte const3[] = { 0x20 };
static byte const4[] = { 0x68,0x15,0x20,0x0a,0x85,0,0,0xc0,0,0x0c,0,0xc0,0,8,0,0xc0 };
static byte const5[] = { 1,0,0xff };

        /* check that we really are a VGA */
        if (video_adapter != VGA)
        {
                /* we are not -so this function is not implemented */
                not_imp();
                return;
        }
        states = getCX() & 7;
        switch (getAL())
        {
        case 00:  /* buffer sizes into bx */
                setBX(buff_sizes[states]);
                setAL(0x1c);
                break;

        case 01:  /* Save video states to es:bx */
                if( states&1 )  /* Video hardware state */
                        sas_storew(buff, 0x0064); /* ID words. DODGY! */
                if( states&2 )  /* Video BIOS state */
                        sas_storew(buff+2, 0x0064);
                if( states&4 )  /* Video DAC state */
                        sas_storew(buff+4, 0x0064);
                buff += 0x20;

                if( states&1 )  /* Video hardware state */
                {
                        for(i=0;i<sizeof(const1);i++)
                                sas_store(buff++, const1[i]);
                        for(i=0;i<5;i++)
                        {
                                outb(EGA_SEQ_INDEX,i);
                                inb(EGA_SEQ_DATA,&temp);
                                sas_store(buff++, temp);
                        }
                        inb(VGA_MISC_READ_REG,&temp);
                        sas_store(buff++, temp);
                        for(i=0;i<0x19;i++)
                        {
                                outb(EGA_CRTC_INDEX,i);
                                inb(EGA_CRTC_DATA,&temp);
                                sas_store(buff++, temp);
                        }
                        for(i=0;i<20;i++)
                        {
                                inb(EGA_IPSTAT1_REG,&temp); /*clear attribute flipflop*/
                                outb(EGA_AC_INDEX_DATA,i);
                                inb(EGA_AC_SECRET,&temp);
                                sas_store(buff++, temp);
                        }
                        /* now ensure video reenabled. First ensure
                         * AC reg is in 'index' state by reading Status reg 1
                         */
                        inb(EGA_IPSTAT1_REG,&temp);
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        for(i=0;i<9;i++)
                        {
                                outb(EGA_GC_INDEX,i);
                                inb(EGA_GC_DATA,&temp);
                                sas_store(buff++, temp);
                        }
                        for(i=0;i<sizeof(const2);i++)
                                sas_store(buff++, const2[i]);
                }
                if( states&2 )  /* Video BIOS state  */
                {
                        for(i=0;i<sizeof(const3);i++)
                                sas_store(buff++, const3[i]);
                        sas_store(buff++, sas_hw_at_no_check(vd_video_mode));
                        sas_storew(buff,sas_w_at_no_check(VID_COLS));
                        buff += 2;
                        sas_storew(buff,sas_w_at_no_check(VID_LEN));
                        buff += 2;
                        sas_storew(buff,sas_w_at_no_check(VID_ADDR));
                        buff += 2;
                        sas_move_bytes_forward(VID_CURPOS, buff, 16);
                        buff += 16;
                        outb(EGA_CRTC_INDEX,R11_CURS_END);
                        inb(EGA_CRTC_DATA,&temp);
                        sas_store(buff++, (IU8)(temp & 0x1F));
                        outb(EGA_CRTC_INDEX,R10_CURS_START);
                        inb(EGA_CRTC_DATA,&temp);
                        sas_store(buff++, (IU8)(temp & 0x1F));
                        sas_store(buff++, sas_hw_at_no_check(vd_current_page));
                        sas_storew(buff,sas_w_at_no_check(VID_INDEX));
                        buff += 2;
                        sas_store(buff++, sas_hw_at_no_check(vd_crt_mode));
                        sas_store(buff++, sas_hw_at_no_check(vd_crt_palette));
                        sas_store(buff++, sas_hw_at_no_check(vd_rows_on_screen));
                        sas_storew(buff, sas_w_at_no_check(ega_char_height));
                        buff += 2;
                        sas_store(buff++, sas_hw_at_no_check(ega_info));
                        sas_store(buff++, sas_hw_at_no_check(ega_info3));
                        sas_store(buff++, sas_hw_at_no_check(VGA_FLAGS));
                        sas_store(buff++, sas_hw_at_no_check(0x48a)); /* DCC */
                        sas_move_bytes_forward(EGA_SAVEPTR, buff, 4);
                        buff += 4;

                        for(i=0;i<sizeof(const4);i++)
                                sas_store(buff++, const4[i]);
                }
                if( states&4 )  /* VGA DAC values  */
                {
                        for(i=0;i<sizeof(const5);i++)
                                sas_store(buff++, const5[i]);
                        for(i2=0;i2<256;i2++)
                        {
                                get_dac(i2, &rgb_dac);
                                sas_store(buff++, rgb_dac.red);
                                sas_store(buff++, rgb_dac.green);
                                sas_store(buff++, rgb_dac.blue);
                        }
                }
                break;

        case 02:  /* Restore video states from es:bx */
                buff += 0x20;
                if( states&1 )  /* Video hardware state */
                {
                        buff += sizeof(const1);
                        for(i=0;i<5;i++)
                        {
                                outb(EGA_SEQ_INDEX,i);
                                outb(EGA_SEQ_DATA,sas_hw_at_no_check(buff++));
                        }
                        outb(VGA_MISC_READ_REG,sas_hw_at_no_check(buff++));
                        for(i=0;i<0x19;i++)
                        {
                                outb(EGA_CRTC_INDEX,i);
                                outb(EGA_CRTC_DATA,sas_hw_at_no_check(buff++));
                        }
                        inb(EGA_IPSTAT1_REG,&temp); /* clear attribute flip flop */
                        for(i=0;i<20;i++)
                        {
                                outb(EGA_AC_INDEX_DATA,i);
                                outb(EGA_AC_INDEX_DATA,sas_hw_at_no_check(buff++));
                        }
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        for(i=0;i<9;i++)
                        {
                                outb(EGA_GC_INDEX,i);
                                outb(EGA_GC_DATA,sas_hw_at_no_check(buff++));
                        }
                        buff += sizeof(const2);
                }
                if( states&2 )  /* Video BIOS state  */
                {
                        buff += sizeof(const3);
                        sas_store_no_check(vd_video_mode, sas_hw_at_no_check(buff++));
                        sas_storew_no_check(VID_COLS,sas_w_at_no_check(buff));
                        buff += 2;
                        sas_storew_no_check(VID_LEN,sas_w_at_no_check(buff));
                        buff += 2;
                        sas_storew_no_check(VID_ADDR,sas_w_at_no_check(buff));
                        buff += 2;
                        sas_move_bytes_forward(buff, VID_CURPOS, 16);
                        buff += 16;
                        outb(EGA_CRTC_INDEX,R11_CURS_END);
                        temp = sas_hw_at_no_check(buff++) & 0x1F;
                        outb(EGA_CRTC_DATA,temp);
                        outb(EGA_CRTC_INDEX,R10_CURS_START);
                        temp = sas_hw_at_no_check(buff++) & 0x1F;
                        outb(EGA_CRTC_DATA,temp);
                        sas_store_no_check(vd_current_page, sas_hw_at_no_check(buff++));
                        sas_storew_no_check(VID_INDEX,sas_w_at_no_check(buff));
                        buff += 2;
                        sas_store_no_check(vd_crt_mode, sas_hw_at_no_check(buff++));
                        sas_store_no_check(vd_crt_palette, sas_hw_at_no_check(buff++));
                        sas_store_no_check(vd_rows_on_screen, sas_hw_at_no_check(buff++));
                        sas_storew_no_check(ega_char_height, sas_w_at_no_check(buff));
                        buff += 2;
                        sas_store_no_check(ega_info, sas_hw_at_no_check(buff++));
                        sas_store_no_check(ega_info3, sas_hw_at_no_check(buff++));
                        sas_store_no_check(VGA_FLAGS, sas_hw_at_no_check(buff++));
                        sas_store_no_check(0x48a, sas_hw_at_no_check(buff++)); /* DCC */
                        sas_move_bytes_forward(buff, EGA_SAVEPTR, 4);
                        buff += 4;
                        buff += sizeof(const4);
                }
                if( states&4 )  /* VGA DAC values  */
                {
                        buff += sizeof(const5);
                        for(i2=0;i2<256;i2++)
                        {
                                rgb_dac.red = sas_hw_at_no_check(buff++);
                                rgb_dac.green = sas_hw_at_no_check(buff++);
                                rgb_dac.blue = sas_hw_at_no_check(buff++);
                                set_dac(i2,&rgb_dac);
                        }
                }
                break;

        default:
                not_imp();
                break;
        }
#endif  //NEC_98
}

#endif  /* VGG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\tgdc.c ===
/*      TGDC Emulation File                                                        */
/*                                                                       NEC_98    */

#if defined(NEC_98)
#include "insignia.h"
#include "host_def.h"
#include "xt.h"
#include "ios.h"
#include "tgdc.h"
#include "ica.h"
#include "gvi.h"
#include "gmi.h"
#include "debug.h"
#include "gfx_upd.h"
#include "egacpu.h"
#include "cg.h"

void set_cursorpos();
void tgdc_reset_func IPT0();
void tgdc_sync_func IPT1(half_word,value);
void tgdc_start_func IPT0();
void tgdc_stop_func IPT0();
void tgdc_scroll_func IPT1(half_word,value);
void tgdc_csrform_func IPT1(half_word,value);
void tgdc_pitch_func IPT1(half_word, value);
void tgdc_csrw_func IPT1(half_word, value);
void tgdc_csrr_func IPT1(half_word *,value);
void tgdc_write_command IPT1(half_word, value);
void tgdc_write_param IPT1(half_word, value);
void tgdc_write_mode1 IPT1(half_word, value);
void tgdc_write_border IPT1(half_word,value);
void tgdc_read_status IPT1(half_word *,value);
void tgdc_read_data IPT1(half_word *,value);

int FIFOCount;
unsigned char   status_flag;
unsigned short  cur_offset_low  = 0;
unsigned short  cur_offs,old_cur_offs=0;
unsigned char   tmpcommand;
BOOL crtv_int_request;
BOOL cursor_move_required = TRUE;
BOOL scroll_move_required = TRUE;
short read_stat_count;
BOOL fontselchanged = FALSE;

extern modeff_palette_change();
extern void host_set_mode_ff();
extern VOID RequestVsync();
extern  DISPLAY_GLOBS   NEC98Display;
extern  BOOL    video_emu_mode;        /* ADD 930720 */

TGDC_GLOBS tgdcglobs;
MODEFF_GLOBS modeffglobs;

void set_cursorpos()
{
    unsigned char *vram_NEC98,*attr_NEC98;
//      unsigned        linepos,colmnpos;
    unsigned linecount;
    int i,num;
    BOOL curs_set;

    vram_NEC98=( unsigned char *)cur_offs+NEC98_TEXT_P0_OFF;
    attr_NEC98=( unsigned char *)cur_offs+NEC98_ATTR_P0_OFF;
    curs_set=FALSE;
//      if (get_doubleword_mode())
//              num=4;
//      else
            num=2;
    if (vram_NEC98 < NEC98_ATTR_P0_OFF) {
        for (i=0,linecount=0;i<text_splits.nRegions;
            linecount+=text_splits.split[i].lines,i++) {
            if (linecount > LINES_PER_SCREEN)
                break;
            else {
                if (( vram_NEC98<((text_splits.split[i].lines*get_bytes_per_line())
                    +text_splits.split[i].addr )) && ( vram_NEC98>=text_splits.split[i].addr) ){
                    set_cur_y((vram_NEC98-text_splits.split[i].addr)/(get_bytes_per_line())+linecount);
                    set_cur_x((vram_NEC98-text_splits.split[i].addr)%(get_bytes_per_line())/num);
                    if (get_cur_y() < LINES_PER_SCREEN) {
                        if (curs_set == FALSE) {
                            curs_set=TRUE;
//                                                      set_cur_x(colmnpos);
//                                                      set_cur_y(linepos);
                            host_paint_cursor(get_cur_x(),get_cur_y(),*attr_NEC98);
                        }
                    }
                }
            }
        }
    }
}


/*             TEXT GDC Command Emulator                                            */

void tgdc_reset_func IFN0()
{
    set_crt_on(FALSE);
    set_mode_change_required(TRUE);
    if ((tmpcommand == GDC_RESET0) || (tmpcommand == GDC_RESET1)) {
            tgdc_write_command(GDC_SYNC0);
    } else {
            tgdc_write_command(GDC_SYNC1);
    }
}

void tgdc_sync_func IFN1(half_word,value) 
{
int src,dst,cnt;

    cnt =tgdcglobs.now.count;
    if (cnt > 7) {
            assert1(FALSE,"NEC98:Illegal Parameter on SYNC %#x",value);
    } else {
            switch(cnt) {
                case 0:
                    if (tmpcommand == GDC_SYNC1)
                        tgdcglobs.startstop = TRUE;
                    else
                        tgdcglobs.startstop = FALSE;
                    break;
                case 1:
                    set_chars_per_line(value+2);
                    set_bytes_per_line(get_chars_per_line()*2);
                    set_offset_per_line(get_chars_per_line()*2);
                    break;
                case 4:
                    src = (int)((value >>6)<<7);
//                              dst = get_pitch_width();
//                              set_pitch_width((src <<1) | (dst & 0x0ff));
                    set_pitch_width(src <<1);
                    break;
                case 6:
                    src = (int)(value);
//                              dst = get_screen_height();
//                              set_screen_height(src | (dst & 0xff00));
                    set_screen_height(src-1);
                    break;
                case 7:
                    src = (int)((value & 0x03)<<6);
                    dst = get_screen_height();
                    set_screen_height((src<<2) | (dst & 0x00ff)-1);
                    set_mode_change_required(TRUE);
                    if (tgdcglobs.now.command & GDC_SYNC1)
                        set_crt_on(TRUE);
                    else
                        set_crt_on(FALSE);
                    break;
            }
            tgdcglobs.sync[tgdcglobs.now.count] = (unsigned char)value;
    }
}

void tgdc_start_func IFN0() {
        set_crt_on(TRUE);
        tgdcglobs.startstop = TRUE;
        set_mode_change_required(TRUE);
}

void tgdc_stop_func IFN0() {
        set_crt_on(FALSE);
        tgdcglobs.startstop = FALSE;
        set_mode_change_required(TRUE);
}

void tgdc_scroll_func IFN1(half_word,value) {
        int count,qcount;
        int src,dst;
        count = tgdcglobs.now.count;
        if (count > 15) {
                assert1(FALSE,"NEC98:Illegal Parameter on SCROLL %#x",value);
         } else {
                qcount = count>>2;
                switch(count & 0x03) {
                    case 0:
                        src = (int)(value);
//                              dst = text_splits.split[qcount].addr;
//                              text_splits.split[qcount].addr = src | (dst & 0xFF00);
                        text_splits.split[qcount].addr = src;
                        break;
                    case 1:
                        src = (int)(value);
                        dst = text_splits.split[qcount].addr;
                        text_splits.split[qcount].addr = (((src << 8) | (dst & 0x00FF)) << 1)
                            + NEC98_TEXT_P0_OFF;
                        break;
                    case 2:
                        src = (int)(value);
//                              dst = text_splits.split[qcount].lines;
//                              text_splits.split[qcount].lines = (src >> 4) | (dst & 0xFFF0);
                        text_splits.split[qcount].lines = src >> 4;
                        break;
                    case 3:
                        src = (int)(value);
                        dst = text_splits.split[qcount].lines;
                        text_splits.split[qcount].lines = (src << 4) | (dst & 0x000F);
                        text_splits.split[qcount].lines /= get_char_height();
                        assert2(FALSE,"NEC98:SCROLL %#x Lines  %#x Height",
                            text_splits.split[qcount].lines,get_char_height());
                        break;
                }
                text_splits.nRegions = qcount + 1;
                tgdcglobs.scroll[count] = (unsigned char) value;
                scroll_move_required = TRUE;
        }
}

void tgdc_csrform_func IFN1(half_word,value)
{
    int src,dst,cnt;

    cnt = tgdcglobs.now.count;
    if (cnt > 2) {
        assert1(FALSE,"NEC98:Illegal Parameter on CSRFORM %#x",value);
    } else {
        switch(cnt) {
            case 0:
                if (value>>7)
                    set_cursor_visible(TRUE);
                else
                    set_cursor_visible(FALSE);
//                              set_char_height(((value) & 0x1f)+1);
                cursor_move_required = TRUE; // 950414 bugfix
                                             // WX2 cursor illegal blink
                break;
            case 1:
                src = value >> 6;
                dst = get_blink_rate();
//                              set_blink_rate(src | (dst & 0xfc));
                set_blink_rate(src);
                if (value & 0x20)
                    set_blink_disable(TRUE);
                else
                    set_blink_disable(FALSE);
                set_cursor_start(value & 0x1f);
                break;
            case 2:
                src = value << 5;
                dst = get_blink_rate();
                set_blink_rate(((src>>3) | (dst & 0x03))*4);
                set_cursor_height((value >> 3) - get_cursor_start()+1);
                host_cursor_size_changed(get_cursor_start(),(int)(value));
                break;
        }
        tgdcglobs.csrform[tgdcglobs.now.count] = (unsigned char) value;
    }
}

void tgdc_pitch_func IFN1(half_word, value)
{
    int src,dst;

    if (tgdcglobs.now.count > 0) {
        assert1(FALSE,"NEC98:Illegal Parameter on PITCH %#x",value);
    } else {
        src = (int) value;
        dst = get_pitch_width();
        set_pitch_width(src | (dst & 0x100));
        tgdcglobs.pitch = (unsigned char)value;
    }
}

void tgdc_csrw_func IFN1(half_word, value)
{
    unsigned short src,dst,cnt;

    cnt = tgdcglobs.now.count;
    switch(cnt) {
        case 0:
            cur_offset_low = (unsigned short) value;
            break;
        case 1:
            cur_offs = (((value & 0x1f)<<8)+(cur_offset_low & 0xff))*2;
            if (cur_offs != old_cur_offs){
                cursor_move_required = TRUE;
                old_cur_offs = cur_offs;
//                              set_cursorpos();
            }
            break;
        default:
            assert1(FALSE,"NEC98:Illegal Parameter on CSRW%#x",value);
    }
}

void tgdc_csrr_func IFN1(half_word *,value)
{
    unsigned short  tmp;
 
    switch(FIFOCount) {
        case 0:
            tmp = (old_cur_offs >> 1) & 0x00ff;
            *value = (half_word) tmp;
            break;
        case 1:
            tmp = (old_cur_offs >> 1) & 0x1f00;
            *value = (half_word)(tmp >> 8);
            break;
        default:
            assert1(FALSE,"NEC98:Illegal Parameter on CSRR %#x",*value);
            FIFOCount--;
    }
    FIFOCount++;
}

/*              TEXT GDC Port                                                      */

void tgdc_write_command IFN1(half_word, value)
{
    tmpcommand = value;
    if ((tmpcommand <= 0x70) && (tmpcommand >= 0x7f))
            tmpcommand = 0x70;
    FIFOCount = 0;
    status_flag &= 0xFE;
    tgdcglobs.now.count = 0;
    switch(tmpcommand) {
        case GDC_RESET0:
        case GDC_RESET1:
        case GDC_RESET2:
            tgdc_reset_func();
            break;
        case GDC_START0:
        case GDC_START1:
            tgdc_start_func();
            break;
        case GDC_STOP0:
        case GDC_STOP1:
            tgdc_stop_func();
            break;
        case GDC_CSRR:
            status_flag |= 0x01;
            break;
        case GDC_SCROLL:
            tgdcglobs.now.count = (int) (value & 0x0f);
        case GDC_SYNC0:
        case GDC_SYNC1:
        case GDC_CSRFORM:
        case GDC_PITCH:
        case GDC_CSRW:
            tgdcglobs.now.command = tmpcommand;
            break;
        default:
            assert1(FALSE,"NEC98:Illegal Command %#x",value);
    }
}

void tgdc_write_param IFN1(half_word, value)
{
    tgdcglobs.now.param[tgdcglobs.now.count]=(unsigned char)value;
    switch(tmpcommand) {
        case GDC_SYNC0:
        case GDC_SYNC1:
            tgdc_sync_func(value);
            break;
        case GDC_SCROLL:
            tgdc_scroll_func(value);
            break;
        case GDC_CSRFORM:
            tgdc_csrform_func(value);
            break;
        case GDC_PITCH:
            tgdc_pitch_func(value);
            break;
        case GDC_CSRW:
            tgdc_csrw_func(value);
            break;
        default:
            assert1(FALSE,"NEC98:Illegal Command or Parameter %#x",value);
            tgdcglobs.now.param[tgdcglobs.now.count]=(unsigned char)0xff;
            return;
    }
    tgdcglobs.now.count++;
}

void tgdc_write_mode1 IFN1(half_word, value)
{
    half_word       ffvalue = (value & 0x0F);
    BOOL    *pff = &NEC98Display.modeff.atrsel;

    switch(ffvalue >> 1) {
        case 0:
            modeffglobs.modeff_data[0] = ffvalue;
            if (ffvalue & 0x01)
                NEC98Display.modeff.atrsel = TRUE;
            else
                NEC98Display.modeff.atrsel = FALSE;
            break;
        case 1:
            modeffglobs.modeff_data[1] = ffvalue;
            modeff_palette_change();
            if (ffvalue & 0x01)
                NEC98Display.modeff.graphmode = TRUE;
            else
                NEC98Display.modeff.graphmode = FALSE;
            break;
        case 2:
            modeffglobs.modeff_data[2] = ffvalue;
            if (ffvalue & 0x01)
                NEC98Display.modeff.width = TRUE;
            else
                NEC98Display.modeff.width = FALSE;
            break;
        case 3:
            modeffglobs.modeff_data[3] = ffvalue;
            fontselchanged = TRUE;
            outb(CG_WRITE_SECOND,(unsigned char)(cgglobs.code & 0x00FF));
            fontselchanged = FALSE;
           if (ffvalue & 0x01)
               NEC98Display.modeff.fontsel = TRUE;
           else
               NEC98Display.modeff.fontsel = FALSE;
           break;
       case 4:
           modeffglobs.modeff_data[4] = ffvalue;
           if (ffvalue & 0x01){
               NEC98Display.modeff.graph88 = TRUE;
           }else{
               NEC98Display.modeff.graph88 = FALSE;
           }
           set_mode_change_required(TRUE);
           break;
       case 5:
           modeffglobs.modeff_data[5] = ffvalue;
           if (ffvalue & 0x01)
               NEC98Display.modeff.kacmode = TRUE;
           else
               NEC98Display.modeff.kacmode = FALSE;
           break;
       case 6:
           modeffglobs.modeff_data[6] = ffvalue;
           if (ffvalue & 0x01)
               NEC98Display.modeff.nvmwpermit = TRUE;
           else
               NEC98Display.modeff.nvmwpermit = FALSE;
           break;
       case 7:
           modeffglobs.modeff_data[7] = ffvalue;
           if (ffvalue & 0x01){
               NEC98Display.modeff.dispenable = TRUE;
           }else{
               NEC98Display.modeff.dispenable = FALSE;
           }
           set_mode_change_required(TRUE);
           break;
    }
#ifdef VSYNC                                                //      VSYNC
    if ((ffvalue >>1) != 5)
        host_set_mode_ff(ffvalue);
#endif                                                      //      VSYNC
}

void tgdc_write_border IFN1(half_word,value)
{
        tgdcglobs.border = (unsigned char)value;
}

void tgdc_read_status IFN1(half_word *,value)
{
//      status_flag ^= 0x20;
        if (status_flag & 0x20) {
                if (read_stat_count > 2) {
                        status_flag ^= 0x20;
                        read_stat_count = 0;
                } else
                        read_stat_count++;
        }
        status_flag ^= 0x40;
        *value = status_flag;
}

void tgdc_read_data IFN1(half_word *,value)
{
    if (status_flag & 0x01) {
        switch (tmpcommand) {
            case GDC_CSRR:
                if (FIFOCount >4 )
                    ;
                else {
                    tgdc_csrr_func(value);
                }
                break;
            default:
                assert1(FALSE,"NEC98:Illegal Command %#x",tmpcommand);
        }
    }
}



GLOBAL void text_gdc_inb IFN2(io_addr, port, half_word *, value)
{
    switch(port) {
        case TGDC_READ_STATUS:
            tgdc_read_status(value);
            break;
        case TGDC_READ_DATA:
            tgdc_read_data(value);
            break;
        default:
            assert1(FALSE,"NEC98:Illegal Port %#x",port);
    }
}

GLOBAL void text_gdc_outb IFN2(io_addr, port, half_word, value)
{
    switch(port) {
        case TGDC_WRITE_PARAMETER:
            tgdc_write_param(value);
            break;
        case TGDC_WRITE_COMMAND:
            tgdc_write_command(value);
            break;
        case TGDC_CRT_INTERRUPT:
//                  DbgPrint("NTVDM: Vsync Request!!\n");
//                  ica_hw_interrupt(ICA_MASTER, CPU_CRTV_INT, 1);
//                      crtv_int_request = TRUE;
            RequestVsync();
            break;
        case TGDC_WRITE_MODE1:
            tgdc_write_mode1(value);
            break;
        case TGDC_WRITE_BORDER:
            tgdc_write_border(value);
            break;
        default:
            assert1(FALSE,"NEC98:Illegal Port %#x",port);
    }
}

GLOBAL void text_gdc_init IFN0()
{
    io_define_inb(TEXT_GDC_ADAPTOR,text_gdc_inb);
    io_define_outb(TEXT_GDC_ADAPTOR,text_gdc_outb);
        io_connect_port(TGDC_WRITE_PARAMETER,TEXT_GDC_ADAPTOR,IO_READ_WRITE);
        io_connect_port(TGDC_WRITE_COMMAND,TEXT_GDC_ADAPTOR,IO_READ_WRITE);
    io_connect_port(TGDC_CRT_INTERRUPT, TEXT_GDC_ADAPTOR, IO_WRITE);
        io_connect_port(TGDC_WRITE_MODE1,TEXT_GDC_ADAPTOR,IO_WRITE);
        io_connect_port(TGDC_WRITE_BORDER,TEXT_GDC_ADAPTOR,IO_WRITE);
}

GLOBAL void text_gdc_post IFN0()
{
        int i;
        unsigned short  ffpost[] = { 0, 2, 4, 7, 8, 0x0a, 0x0c, 0x0f};

        FIFOCount = 0;
        status_flag = 0x04;
//      cur_offs = (get_cur_y()*get_bytes_per_line()+(get_cur_x()<<1));
        cur_offs = 0;
        tmpcommand = 0xff;
        crtv_int_request=FALSE;
        read_stat_count = 0;
        set_doubleword_mode(FALSE);
        NEC98GLOBS->screen_ptr = 0xA0000;

        text_gdc_outb(TGDC_WRITE_COMMAND,GDC_SYNC0);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x10);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x4e);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x07);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x25);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x07);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x07);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x90);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x65);

        text_gdc_outb(TGDC_WRITE_COMMAND,GDC_PITCH);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x50);

        text_gdc_outb(TGDC_WRITE_COMMAND,GDC_CSRFORM);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x0f);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x7b);

        text_gdc_outb(TGDC_WRITE_COMMAND,GDC_SCROLL);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0xf0);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x1f);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x10);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x10);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x10);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);

        text_gdc_outb(TGDC_WRITE_COMMAND,GDC_START1);

        for ( i=0 ; i<8 ; i++)
                text_gdc_outb(TGDC_WRITE_MODE1,ffpost[i]);
}

GLOBAL void VSYNC_beats IFN0()
{
        status_flag ^= 0x20;
}

GLOBAL void TgdcStatusChange IFN0()
{
        status_flag != 0x20;
        read_stat_count = 0;
}
#endif //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\video.c ===
#if (defined(JAPAN) || defined(KOREA)) && !defined(i386)
#include <windows.h>
#endif // (JAPAN || KOREA)&& !i386
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title	: video.c
 *
 * Description	: BIOS video internal routines.
 *
 * Author	: Henry Nash
 *
 * Notes	: The following functions are defined in this module:
 *
 *                video_init()
 *
 *		  vd_set_mode()
 *		  vd_set_cursor_mode()
 *		  vd_set_cursor_position()
 *		  vd_get_cursor_position()
 *		  vd_get_light_pen()
 *		  vd_set_active_page()
 *		  vd_scroll_up()
 *		  vd_scroll_down()
 *		  vd_read_attrib_char()
 *		  vd_write_char_attrib()
 *		  vd_write_char()
 *		  vd_set_colour_palette()
 *		  vd_write_dot()
 *		  vd_read_dot()
 *		  vd_write_teletype()
 *		  vd_get_mode()
 *		  vd_write_string()
 *
 *		  The above vd_ functions are called by the video_io()
 *		  function via a function table.
 *
 */

/*
 * static char SccsID[]="@(#)video.c	1.61 07/03/95 Copyright Insignia Solutions Ltd.";
 */


#ifndef NEC_98
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "VIDEO_BIOS.seg"
#endif
#endif // !NEC_98


/*
 *    O/S include files.
 */
#include <stdio.h>
#include <malloc.h>
#include StringH
#include TypesH
#include FCntlH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "sas.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "bios.h"
#include "ios.h"
#include "gmi.h"
#include "gvi.h"
#include "gfx_upd.h"
#include "host.h"
#include "video.h"
#include "cga.h"
#ifdef	EGG
#include "egacpu.h"
#include "egaports.h"
#endif	/* EGG */
#include "equip.h"
#include "debug.h"
#include "timer.h"
#ifndef PROD
#include "trace.h"
#endif
#include "egavideo.h"
#include "host_gfx.h"
#include "cpu_vid.h"
#include "ga_defs.h"
#if defined(JAPAN) || defined(KOREA)
#include <conapi.h>
#include "nt_graph.h" // for SetConsoleEUDC()
#include "egagraph.h" // for SetVram()
#endif // JAPAN || KOREA

#if defined(NEC_98)
#include "tgdc.h"
#endif // NEC_98

#ifdef	EGG
#define	VD_ROWS_ON_SCREEN	sas_hw_at_no_check(vd_rows_on_screen)
#else
#define VD_ROWS_ON_SCREEN	vd_rows_on_screen
#endif	/* EGG */


#ifndef NEC_98
#ifdef NTVDM
short		stream_io_dirty_count_32 = 0;
half_word  *	stream_io_buffer = NULL;
boolean 	stream_io_enabled = FALSE;
word		stream_io_buffer_size = 0;
word  * 	stream_io_dirty_count_ptr = NULL;
#ifdef MONITOR
sys_addr	stream_io_bios_busy_sysaddr;
#endif

#endif
#endif // !NEC_98



/*
 * ============================================================================
 * Global data
 * ============================================================================
 *
 * These variables are basically the same as the corresponding gvi_.. variables,
 * but reflect where the BIOS thinks the screen is, rather than where it really is.
 * This was done to fix "dots on screen" problem with EGA-PICS, which changes screen
 * mode behind the BIOS's back.
 */
#if defined(NEC_98)
extern  BOOL HIRESO_MODE;
#else  // !NEC_98
GLOBAL sys_addr video_pc_low_regen,video_pc_high_regen;
#endif // !NEC_98

#if defined(JAPAN) || defined(KOREA)
GLOBAL byte Int10Flag[80*50];
GLOBAL byte NtInt10Flag[80*50];

GLOBAL word DosvVramSeg;
GLOBAL word DosvVramOff;
GLOBAL word DosvModeSeg;
GLOBAL word DosvModeOff;
GLOBAL word NtConsoleFlagSeg;
GLOBAL word NtConsoleFlagOff;
GLOBAL word DispInitSeg;
GLOBAL word DispInitOff;
GLOBAL word FullScreenResumeOff;
GLOBAL word FullScreenResumeSeg;
GLOBAL sys_addr DosvVramPtr;
GLOBAL sys_addr DosvModePtr;
GLOBAL sys_addr NtConsoleFlagPtr;
GLOBAL sys_addr SetModeFlagPtr;
GLOBAL int PrevCP = 437;                  // default CP
GLOBAL int DosvVramSize;
#define DOSV_VRAM_SIZE 8000               // 8/6/1993 V-KazuyS
GLOBAL word textAttr;                   // for screen attributes
#endif

#ifdef JAPAN
GLOBAL int  Int10FlagCnt = 0;

// #4183: status line of oakv(DOS/V FEP) doesn't disappear -yasuho
GLOBAL half_word IMEStatusLines;
#endif

/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */

/* internal function declarations */
#if defined(NEC_98)
LOCAL void vd_NEC98_dummy();

void (*video_func_h[]) () = {
                keyboard_io,            /* 00h routed to KB BIOS         */
                keyboard_io,            /* 01h routed to KB BIOS         */
                keyboard_io,            /* 02h routed to KB BIOS         */
                keyboard_io,            /* 03h routed to KB BIOS         */
                keyboard_io,            /* 04h routed to KB BIOS         */
                keyboard_io,            /* 05h routed to KB BIOS         */
                keyboard_io,            /* 06h routed to KB BIOS         */
                keyboard_io,            /* 07h routed to KB BIOS         */
                keyboard_io,            /* 08h routed to KB BIOS         */
                keyboard_io,            /* 09h routed to KB BIOS         */
                vd_NEC98_set_mode,          /* 0ah Set mode                  */
                vd_NEC98_get_mode,          /* 0bh Get mode                  */
                vd_NEC98_start_display,     /* 0ch Start display             */
                vd_NEC98_stop_display,      /* 0dh Stop display              */
                vd_NEC98_single_window,     /* 0eh Set single window         */
                vd_NEC98_multi_window,      /* 0fh Set multi window          */
                vd_NEC98_set_cursor,        /* 10h Set cursor type           */
                vd_NEC98_show_cursor,       /* 11h Show cursor               */
                vd_NEC98_hide_cursor,       /* 12h Hide cursor               */
                vd_NEC98_set_cursorpos,     /* 13h Set cursor position       */
                vd_NEC98_dummy,             /* 14h dummy for NEC98    /H      */
                vd_NEC98_dummy,             /* 15h dummy for NEC98    /H      */
                vd_NEC98_init_textvram,     /* 16h Initialize text vram      */
                vd_NEC98_start_beep,        /* 17h Start beep sound          */
                vd_NEC98_stop_beep,         /* 18h Stop beep sound           */
                vd_NEC98_dummy,             /* 19h dummy for NEC98    /H      */
                vd_NEC98_dummy,             /* 1ah dummy for NEC98    /H      */
                vd_NEC98_set_kcgmode,       /* 1bh Set KCG access mode       */
                vd_NEC98_init_crt,          /* 1ch Initialize CRT    /H      */
                vd_NEC98_set_disp_width,    /* 1dh Set display size  /H      */
                vd_NEC98_set_cursor_type,   /* 1eh Set cursor type   /H      */
                vd_NEC98_get_font,          /* 1fh Get font          /H      */
                vd_NEC98_set_font,          /* 20h Set user font     /H      */
                vd_NEC98_get_mswitch,       /* 21h Get memory switch /H      */
                vd_NEC98_set_mswitch,       /* 22h Set memory switch /H      */
                vd_NEC98_set_beep_rate,     /* 23h Set beep rate     /H      */
                vd_NEC98_set_beep_time,     /* 24h Set beep time&ring/H      */
                };
void (*video_func_n[]) () = {
                keyboard_io,            /* 00h routed to KB BIOS         */
                keyboard_io,            /* 01h routed to KB BIOS         */
                keyboard_io,            /* 02h routed to KB BIOS         */
                keyboard_io,            /* 03h routed to KB BIOS         */
                keyboard_io,            /* 04h routed to KB BIOS         */
                keyboard_io,            /* 05h routed to KB BIOS         */
                keyboard_io,            /* 06h routed to KB BIOS         */
                keyboard_io,            /* 07h routed to KB BIOS         */
                keyboard_io,            /* 08h routed to KB BIOS         */
                keyboard_io,            /* 09h routed to KB BIOS         */
                vd_NEC98_set_mode,          /* 0ah Set mode                  */
                vd_NEC98_get_mode,          /* 0bh Get mode                  */
                vd_NEC98_start_display,     /* 0ch Start display             */
                vd_NEC98_stop_display,      /* 0dh Stop display              */
                vd_NEC98_single_window,     /* 0eh Set single window         */
                vd_NEC98_multi_window,      /* 0fh Set multi window          */
                vd_NEC98_set_cursor,        /* 10h Set cursor type           */
                vd_NEC98_show_cursor,       /* 11h Show cursor               */
                vd_NEC98_hide_cursor,       /* 12h Hide cursor               */
                vd_NEC98_set_cursorpos,     /* 13h Set cursor position       */
                vd_NEC98_get_font,          /* 14h Get font         /N       */
                vd_NEC98_get_pen,           /* 15h Get lightpen status       */
                vd_NEC98_init_textvram,     /* 16h Initialize text vram      */
                vd_NEC98_start_beep,        /* 17h Start beep sound          */
                vd_NEC98_stop_beep,         /* 18h Stop beep sound           */
                vd_NEC98_init_pen,          /* 19h Initialize lightpen       */
                vd_NEC98_set_font,          /* 1ah Set user font    /N       */
                vd_NEC98_set_kcgmode,       /* 1bh Set KCG access mode       */
                };
boolean is_disp_cursor=0;               /* Set if cursor on              */
static boolean  cursor_flag=TRUE;
extern void nt_set_beep();

NEC98_TextSplits text_splits;            /* CRT split data structure      */

#else  // !NEC_98
LOCAL sys_addr 	extend_addr IPT1(sys_addr,addr);
LOCAL half_word fgcolmask IPT1(word, rawchar);
LOCAL word 	expand_byte IPT1(word, lobyte);
GLOBAL void 	graphics_write_char IPT5(half_word, x, half_word, y, half_word, wchar, half_word, attr, word, how_many);
LOCAL void 	M6845_reg_init IPT2(half_word, mode, word, base);
LOCAL void 	vd_dummy IPT0();

#ifdef HERC
GLOBAL void herc_alt_sel IPT0();
GLOBAL void herc_char_gen IPT0();
GLOBAL void herc_video_init IPT0();
#endif /* HERC */

void (*video_func[]) () = {
				vd_set_mode,
				vd_set_cursor_mode,
				vd_set_cursor_position,
				vd_get_cursor_position,
		 		vd_get_light_pen,
				vd_set_active_page,
				vd_scroll_up,
				vd_scroll_down,
				vd_read_attrib_char,
				vd_write_char_attrib,
				vd_write_char,
				vd_set_colour_palette,
				vd_write_dot,
				vd_read_dot,
				vd_write_teletype,
				vd_get_mode,
				vd_dummy,
#ifdef HERC
				herc_char_gen,
				herc_alt_sel,
#else /* !HERC */
				vd_dummy,
				vd_dummy,
#endif /* HERC */
				vd_write_string,
				vd_dummy,
				vd_dummy,
				vd_dummy,
				vd_dummy,
				vd_dummy,
				vd_dummy,
				vd_dummy,
#ifdef VGG
				vga_disp_func,
#else /* !VGG */
				vd_dummy,
#endif /* VGG */
				vd_dummy,
			   };
#endif // !NEC_98

#ifndef NEC_98
unsigned char   valid_modes[] =
        {
                ALL_MODES,              /* Mode 0. */
                ALL_MODES,              /* Mode 1. */
                ALL_MODES,              /* Mode 2. */
                ALL_MODES,              /* Mode 3. */
                ALL_MODES,              /* Mode 4. */
                ALL_MODES,              /* Mode 5. */
                ALL_MODES,              /* Mode 6. */
                ALL_MODES,              /* Mode 7. */
                NO_MODES,               /* Mode 8. */
                NO_MODES,               /* Mode 9. */
                NO_MODES,               /* Mode 10. */
                EGA_MODE | VGA_MODE,    /* Mode 11. */
                EGA_MODE | VGA_MODE,    /* Mode 12. */
                EGA_MODE | VGA_MODE,    /* Mode 13. */
                EGA_MODE | VGA_MODE,    /* Mode 14. */
                EGA_MODE | VGA_MODE,    /* Mode 15. */
                EGA_MODE | VGA_MODE,    /* Mode 16. */
                VGA_MODE,               /* Mode 17. */
                VGA_MODE,               /* Mode 18. */
                VGA_MODE,               /* Mode 19. */
        };

MODE_ENTRY vd_mode_table[] = {
	0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,    0x2C,40,16,8,/*Blink|BW*/
	0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,    0x28,40,16,8,/*Blink*/
	0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,    0x2D,80,16,8,/*Blink|BW|80x25*/
	0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,    0x29,80,16,8,/*Blink|80x25*/
	0xB8000L, 0xBFFFFL, VD_CLEAR_GRAPHICS,0x2A,40,4,1,/*Blink|graph*/
	0xB8000L, 0xBFFFFL, VD_CLEAR_GRAPHICS,0x2E,40,4,1,/*Blink|graph|BW*/
	0xB8000L, 0xBFFFFL, VD_CLEAR_GRAPHICS,0x1E,80,2,1,/*640x200|graph|BW*/
	0xB0000L, 0xB7FFFL, VD_CLEAR_TEXT,    0x29,80,0,8,/*MDA:Blink|80x25*/
	0L, 0L, 0,		VD_BAD_MODE,	0,0,0,	/* Never a valid mode */
	0L, 0L ,0,		VD_BAD_MODE,	0,0,0,	/* Never a valid mode */
	0,0,0,			VD_BAD_MODE,	0,0,0,	/* Never a valid mode */
	0xA0000L, 0xAFFFFL, 0,VD_BAD_MODE,0,0,0,/* Mode B - EGA colour font load */
	0xA0000L, 0xAFFFFL, 0,VD_BAD_MODE,0,0,0,/* Mode C - EGA monochrome font load */
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,40,16,8,/* 320x200 EGA graphics */
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,80,16,4,/* 640x200 EGA graphics */
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,80,2,2,/* 640x350 EGA 'mono' */
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,80,16,2,/* 640x350 EGA 16 colour */
#ifdef VGG
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,80,2,1,/* 640x480 EGA++ 2 colour */
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,80,16,1,/* 640x480 EGA++ 16 colour */
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,40,256,1,/* 320x200 VGA 256 colour */
#endif
	};

#ifdef V7VGA
MODE_ENTRY vd_ext_text_table[] = {
	0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,VD_BAD_MODE,80,16,8,/* 80x43 V7VGA 16 colour */
	0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,VD_BAD_MODE,132,16,8,/* 132x25 V7VGA 16 colour */
	0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,VD_BAD_MODE,132,16,8,/* 132x43 V7VGA 16 colour */
	0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,VD_BAD_MODE,80,16,8,/* 80x60 V7VGA 16 colour */
	0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,VD_BAD_MODE,100,16,8,/* 100x60 V7VGA 16 colour */
	0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,VD_BAD_MODE,132,16,8,/* 132x28 V7VGA 16 colour */
	};

MODE_ENTRY vd_ext_graph_table[] = {
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,94,16,2,/* 752x410 V7VGA 16 colour */
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,90,16,2,/* 720x540 V7VGA 16 colour */
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,100,16,2,/* 800x600 V7VGA 16 colour */
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,128,2,2,/* 1024x768 V7VGA 2 colour */
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,128,4,2,/* 1024x768 V7VGA 4 colour */
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,128,16,2,/* 1024x768 V7VGA 16 colour */
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,80,256,1,/* 640x400 V7VGA 256 colour */
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,80,256,1,/* 640x480 V7VGA 256 colour */
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,90,256,1,/* 720x540 V7VGA 256 colour */
	0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,100,256,1,/* 800x600 V7VGA 256 colour */
	};
#endif /* V7VGA */

/*
 * Macros to calculate the offset from the start of the screen buffer
 * and start of page for a given row and column.
 */

#define vd_page_offset(col, row)       ( ((row) * vd_cols_on_screen + (col))<<1)

#define vd_regen_offset(page, col, row)					  \
		((page) * sas_w_at_no_check(VID_LEN) + vd_page_offset((col), (row)) )

#define vd_high_offset(col, row)   (((row) * ONELINEOFF)+(col))

#define vd_medium_offset(col, row)   (((row) * ONELINEOFF)+(col<<1))

#define vd_cursor_offset(page)						  \
		( vd_regen_offset(page, sas_hw_at_no_check(VID_CURPOS+2*page), sas_hw_at_no_check(VID_CURPOS+2*page+1)) )

#define GET_CURSOR_POS 3
#define SET_CURSOR_POS 2
#define WRITE_A_CHAR 10

/*
 * Static function declarations.
 */

LOCAL void sensible_text_scroll_down IPT6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr);
LOCAL void sensible_text_scroll_up IPT6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr);
LOCAL void sensible_graph_scroll_up IPT6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr);
LOCAL void sensible_graph_scroll_down IPT6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr);
LOCAL void kinky_scroll_up IPT7(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr, int, vd_cols_on_screen);
LOCAL void kinky_scroll_down IPT7(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr, int, vd_cols_on_screen);
#endif // !NEC_98

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */

#ifdef JAPAN
GLOBAL int dbcs_first[0x100] = {
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 0x
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 1x
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 2x
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 3x
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 4x
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 5x
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 6x
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 7x
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // 8x
		TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
		TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // 9x
		TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // Ax
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // Bx
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // Cx
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // Dx
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
#if defined(NEC_98)
                TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Ex
                TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  //
#else  // !NEC_98
		TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Ex
		TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
#endif // !NEC_98
		TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Fx
		TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE
	};
#elif defined(KOREA) // JAPAN
GLOBAL int dbcs_first[0x100] = {
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 0x
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 1x
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 2x
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 3x
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 4x
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 5x
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 6x
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
		FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 7x
                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 8x
                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 9x
                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
                FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Ax
                TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
                TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Bx
                TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
                TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Cx
                TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
                TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Dx
                TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
                TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Ex
                TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
                TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Fx
                TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  FALSE
        };
#endif // KOREA

#if defined(JAPAN) || defined(KOREA)
GLOBAL int BOPFromDispFlag = FALSE;
GLOBAL int BOPFromNtDisp1Flag = FALSE;
GLOBAL sys_addr DBCSVectorAddr = 0;
GLOBAL word SaveDBCSVector[20];
GLOBAL int DBCSVectorLen = 0;

int is_us_mode()
{
#if defined(NEC_98)
    return(FALSE);
#else  // !NEC_98
    if ( ( BOPFromDispFlag == TRUE ) &&  DBCSVectorAddr != 0 &&
	 ( sas_w_at_no_check(DBCSVectorAddr) != 0x00 ) )
        return FALSE;   // Not US mode
    else
        return TRUE;    // US mode
#endif // !NEC_98
}

#ifndef NEC_98
void SetDBCSVector( int CP )
{
    int i, j;
    sys_addr ptr;

#ifdef JAPAN_DBG
    DbgPrint( " SetDBCSVector(%d) BOPFromDispFlag=%d, BOPFromNtDisp1Flag=%d\n", CP, BOPFromDispFlag, BOPFromNtDisp1Flag );
#endif

    if ( !BOPFromDispFlag && !BOPFromNtDisp1Flag )
        return;

    ptr = DBCSVectorAddr;

    if ( CP == 437 ) {
        for ( i = 0; i < DBCSVectorLen; i++ ) {
	    sas_storew_no_check( ptr, 0x0000 );
            ptr += 2;
        }
        for ( i = 0; i < 0x100; i++ ) {
            dbcs_first[i] = FALSE;
        }
        // Set cursor mode
        if ( !SetConsoleCursorMode( sc.OutputHandle,
                                    TRUE,             // Bringing
                                    FALSE             //  No double byte cursor
                                         ) ) {
            DbgPrint( "NTVDM: SetConsoleCursorMode Error\n" );
        }
    }
    else { // CP == 932
        for ( i = 0; i < DBCSVectorLen; i++ ) {
            sas_storew_no_check( ptr, SaveDBCSVector[i] );
            ptr += 2;
        }
        for ( i = 0, j = 0; i < DBCSVectorLen; i++ ) {
            //DbgPrint( "...%02x.", LOBYTE(SaveDBCSVector[i]) );
            for ( ; j < LOBYTE(SaveDBCSVector[i]); j++ ) {
                dbcs_first[j] = FALSE;
            }
            //DbgPrint( "...%02x.", HIBYTE(SaveDBCSVector[i]) );
            for ( ; j <= HIBYTE(SaveDBCSVector[i]); j++ ) {
                dbcs_first[j] = TRUE;
            }
        }
        for ( ; j < 0x100; j++ ) {
            dbcs_first[j] = FALSE;
        }
        // Set cursor mode
        if ( !SetConsoleCursorMode( sc.OutputHandle,
                                    FALSE,            //  No bringing
                                    FALSE             //  No double byte cursor
                                         ) ) {
            DbgPrint( "NTVDM: SetConsoleCursorMode Error\n" );
        }
    }

}

void SetVram()
{

#ifdef i386
    if ( !is_us_mode() ) {
        // set_up_screen_ptr() vga_mode.c
        set_screen_ptr( (byte *)DosvVramPtr );
        // low_set_mode() ega_vide.c
        video_pc_low_regen = DosvVramPtr;
        video_pc_high_regen = DosvVramPtr + DosvVramSize - 1;
        // vga_gc_misc() vga_prts.c
        gvi_pc_low_regen = DosvVramPtr;
        gvi_pc_high_regen = DosvVramPtr + DosvVramSize - 1;
        sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);
        // recalc_screen_params() gvi.c
        set_screen_length( DosvVramSize );

#ifdef JAPAN_DBG
        DbgPrint( "NTVDM: SetVram() video_pc_low_regen %x, high %x, gvi_pc_low_regen %x, high %x len%d\n", video_pc_low_regen, video_pc_high_regen, gvi_pc_low_regen, gvi_pc_high_regen, get_screen_length() );
#endif
    }
    else {
        // set_up_screen_ptr() vga_mode.c
        set_screen_ptr( (IU8*)0xB8000 );
        // low_set_mode() ega_vide.c
        video_pc_low_regen = vd_mode_table[sas_hw_at_no_check(vd_video_mode)].start_addr;
        video_pc_high_regen = vd_mode_table[sas_hw_at_no_check(vd_video_mode)].end_addr;
        // vga_gc_misc() vga_prts.c
        gvi_pc_low_regen = 0xB8000;
        gvi_pc_high_regen = 0xBFFFF;
        sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);
        // recalc_screen_params() gvi.c
        set_screen_length(get_offset_per_line()*get_screen_height()/get_char_height());

#ifdef JAPAN_DBG
        DbgPrint( "NTVDM: SetVram() video_pc_low_regen %x, high %x, gvi_pc_low_regen %x, high %x len%d\n", video_pc_low_regen, video_pc_high_regen, gvi_pc_low_regen, gvi_pc_high_regen, get_screen_length() );
#endif
    }
#endif // i386
}

// IME will change status line with set mode
void SetModeForIME()
{
    word CS_save, IP_save, AX_save;
    half_word video_mode;
    extern UINT ConsoleOutputCP;
#ifdef X86GFX
    extern word int10_seg, int10_caller;
#endif // X86GFX

    if (!BOPFromDispFlag)
        return;

    video_mode = sas_hw_at_no_check(vd_video_mode);

    if (video_mode == 0x03 && (UINT)PrevCP != ConsoleOutputCP) {

        /* Call int10 handler */
        CS_save = getCS();          /* Save current CS,IP settings */
        IP_save = getIP();
        AX_save = getAX();
        sas_store_no_check( SetModeFlagPtr, 1 );
        setAX((word)video_mode);    /* IME expects setmode */
#ifdef X86GFX
        exec_sw_interrupt( int10_seg, int10_caller );
#else // !X86GFX
        setCS(VIDEO_IO_SEGMENT);
        setIP(VIDEO_IO_RE_ENTRY);
        host_simulate();
#endif // !X86GFX
        sas_store_no_check( SetModeFlagPtr, 0 );
        setCS(CS_save);             /* Restore CS,IP */
        setIP(IP_save);
        setAX(AX_save);
    }
    PrevCP = ConsoleOutputCP;
}
#endif // !NEC_98
#endif // JAPAN || KOREA

#ifndef NEC_98
GLOBAL VOID
simple_bios_byte_wrt IFN2(ULONG, ch, ULONG, ch_addr)
{
	*(IU8 *)(getVideoscreen_ptr() + ch_addr) = (UTINY)ch;
#if !defined(EGG) && !defined(C_VID) && !defined(A_VID)
	setVideodirty_total(getVideodirty_total() + 1);
#endif	/* not EGG or C_VID or A_VID */
}

GLOBAL VOID
simple_bios_word_wrt IFN2(ULONG, ch_attr, ULONG, ch_addr)
{
	*(IU8 *)(getVideoscreen_ptr() + ch_addr) = (UTINY)ch_attr;
	*(IU8 *)(getVideoscreen_ptr() + ch_addr + 1) = (UTINY)(ch_attr >> 8);
#if !defined(EGG) && !defined(C_VID) && !defined(A_VID)
	setVideodirty_total(getVideodirty_total() + 1);
#endif	/* not EGG or C_VID or A_VID */
}

/*
 * It is possible for the Hercules to attempt text in graphics mode,
 * relying on our int 10 handler to call itself recursively so a user
 * handler can intercept the write character function.
 */

GLOBAL void vd_set_mode IFN0()
{
    half_word card_mode = 0;
    half_word pag;
    EQUIPMENT_WORD equip_flag;
    word page_size,vd_addr_6845,vd_cols_on_screen;
    UCHAR current_video_mode = getAL();

    if (is_bad_vid_mode(current_video_mode))
    {
	always_trace1("Bad video mode - %d.\n", current_video_mode);
	return;
    }

    /*
     * Set the Video mode to the value in AL
     */
    equip_flag.all = sas_w_at_no_check(EQUIP_FLAG);
    if ((half_word)current_video_mode > VD_MAX_MODE ||
	vd_mode_table[current_video_mode].mode_control_val == VD_BAD_MODE) {
#ifndef PROD
	trace(EBAD_VIDEO_MODE, DUMP_REG);
#endif
        return;
    }
    if (equip_flag.bits.video_mode == VIDEO_MODE_80X25_BW) {
        vd_addr_6845 = 0x3B4;    /* Index register for B/W M6845 chip */
        sas_store_no_check (vd_video_mode , 7);       /* Force B/W mode */
        card_mode++;
    }
    else {
        vd_addr_6845 = 0x3D4;
	if (current_video_mode == 7) {
	    /*
	     * Someone has tried to set the monochrome mode without
	     * the monochrome card installed - this can be generated by
	     * a 'mode 80' from medium res graphics mode.
	     * Take 'I am very confused' type actions by clearing the
	     * screen and then disabling video - this is v. similar to
	     * the action taken by the PC but with less snow!
	     */

	    /*
	     * Clear the video area
	     */
#ifdef REAL_VGA
	    sas_fillsw_16(video_pc_low_regen,
				vd_mode_table[sas_hw_at_no_check(vd_video_mode)].clear_char,
				 (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#else
	    sas_fillsw(video_pc_low_regen,
				vd_mode_table[sas_hw_at_no_check(vd_video_mode)].clear_char,
				 (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#endif

	    /*
	     * Force a redraw
	     */
	    outb(M6845_MODE_REG, card_mode);
	    outb(M6845_MODE_REG,
		(IU8)(vd_mode_table[sas_hw_at_no_check(vd_video_mode)].mode_control_val | VIDEO_ENABLE));
	    /*
	     * Turn off the video until another mode command is given
	     */
	    outb(M6845_MODE_REG,
		(IU8)(vd_mode_table[sas_hw_at_no_check(vd_video_mode)].mode_control_val & ~VIDEO_ENABLE));
	    return;
	}
        sas_store_no_check (vd_video_mode , current_video_mode);
    }

#ifdef EGG
    sas_store_no_check(vd_rows_on_screen, 24);
#endif
    sas_store_no_check (vd_current_page , 0);

    /*
     * Initialise the Control Register
     */

    outb(M6845_MODE_REG, card_mode);

    /*
     * Set up M6845 registers for this mode
     */

    M6845_reg_init(sas_hw_at_no_check(vd_video_mode), vd_addr_6845);

    /*
     * ... now overwrite the dynamic registers, eg cursor position
     */

    outb(M6845_INDEX_REG, R14_CURS_ADDRH);
    outb(M6845_DATA_REG, 0);
    outb(M6845_INDEX_REG, R15_CURS_ADDRL);
    outb(M6845_DATA_REG, 0);
    /*
     * Clear the video area
     */
#ifdef REAL_VGA
    sas_fillsw_16(video_pc_low_regen, vd_mode_table[sas_hw_at_no_check(vd_video_mode)].clear_char,
				 (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#else
    sas_fillsw(video_pc_low_regen, vd_mode_table[sas_hw_at_no_check(vd_video_mode)].clear_char,
				 (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#endif

    /*
     * re-enable video for this mode
     */
    outb(M6845_MODE_REG, vd_mode_table[sas_hw_at_no_check(vd_video_mode)].mode_control_val);

    if (sas_hw_at_no_check(vd_video_mode) != 7) {
        if (sas_hw_at_no_check(vd_video_mode) != 6)
            sas_store_no_check (vd_crt_palette , 0x30);
        else
            sas_store_no_check (vd_crt_palette , 0x3F);
        outb(CGA_COLOUR_REG, sas_hw_at_no_check(vd_crt_palette));
    }

    vd_cols_on_screen = vd_mode_table[sas_hw_at_no_check(vd_video_mode)].mode_screen_cols;


    /*
     * Update BIOS data variables
     */

    sas_storew_no_check((sys_addr)VID_COLS, vd_cols_on_screen);
    sas_storew_no_check((sys_addr)VID_ADDR, 0);
    sas_storew_no_check((sys_addr)VID_INDEX, vd_addr_6845);
    sas_store_no_check (vd_crt_mode , vd_mode_table[sas_hw_at_no_check(vd_video_mode)].mode_control_val);
    for(pag=0; pag<8; pag++)
	sas_storew_no_check(VID_CURPOS + 2*pag, 0);
    if(sas_hw_at_no_check(vd_video_mode) == 7)
    	page_size = 4096;
    else
	page_size = sas_w_at_no_check(VID_LENS+(sas_hw_at_no_check(vd_video_mode) & 0xE));	/* sneakily divide mode by 2 and use as word address! */
    sas_storew_no_check(VID_LEN,page_size);
}


GLOBAL void vd_set_cursor_mode IFN0()
{
    /*
     * Set cursor mode
     * Parameters:
     *  CX - cursor value (CH - start scanline, CL - stop scanline)
     */
    io_addr vd_addr_6845;

    vd_addr_6845 = sas_w_at_no_check(VID_INDEX);
    outb(M6845_INDEX_REG, R10_CURS_START);
    outb(M6845_DATA_REG, getCH());
    outb(M6845_INDEX_REG, R11_CURS_END);
    outb(M6845_DATA_REG, getCL());

    /*
     * Update BIOS data variables
     */
    sure_sub_note_trace2(CURSOR_VERBOSE,"setting bios cursor vbl to start=%d, end=%d",getCH(),getCL());

    sas_storew_no_check((sys_addr)VID_CURMOD, getCX());
    setAH(0);
}


GLOBAL void vd_set_cursor_position IFN0()
{
    /*
     * Set cursor variables to new values and update the display
     * adaptor registers.
     * The parameters are held in the following registers:
     *
     * DX - row/column of new cursor position
     * BH - page number
     *
     */

    word cur_pos,vd_addr_6845,vd_cols_on_screen;

    /* Load internal variables with the values stored in BIOS
     * data area.
     */

    vd_addr_6845 = sas_w_at_no_check(VID_INDEX);
    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);

#if defined(JAPAN) || defined(KOREA)
    // for assist calc installer
    // assist calc installer doesn't set BH register to 0
    // In MS-DOS/V it was only support page number == 0
    // I think $DISP.SYS check to see if BH == 0 or to set BH=0
    // in all Int10 function.
    // Therefore you must check BH register value.

    if ( !is_us_mode() )
        sas_storew_no_check(VID_CURPOS, getDX()); // same as BH == 0
    else
        sas_storew_no_check(VID_CURPOS+(getBH()*2), getDX());
#else // !JAPAN && !KOREA
    sas_storew_no_check(VID_CURPOS+(getBH()*2), getDX());
#endif // !JAPAN && !KOREA

    if (sas_hw_at_no_check(vd_current_page) == getBH()) {           /* display if this page */

        /*
         * Calculate position in regen buffer, ignoring attribute bytes
         */

        cur_pos = vd_regen_offset(getBH(), getDL(), getDH());
        cur_pos /= 2;		/* not interested in attributes */

        /*
         * tell the 6845 all about the change
         */
        outb(M6845_INDEX_REG, R14_CURS_ADDRH);
        outb(M6845_DATA_REG,  (IU8)(cur_pos >> 8));
        outb(M6845_INDEX_REG, R15_CURS_ADDRL);
        outb(M6845_DATA_REG,  (IU8)(cur_pos & 0xff));
    }
}


GLOBAL void vd_get_cursor_position IFN0()
{
    /* Load internal variables with the values stored in BIOS
     * data area.
     */
    word vd_cursor_mode;
    half_word vd_cursor_col, vd_cursor_row;

    vd_cursor_mode = sas_w_at_no_check(VID_CURMOD);
    vd_cursor_col = sas_hw_at_no_check(VID_CURPOS + getBH()*2);
    vd_cursor_row = sas_hw_at_no_check(VID_CURPOS + getBH()*2 + 1);

    /*
     * Return the cursor coordinates and mode
     */
    sure_sub_note_trace4(CURSOR_VERBOSE,"returning bios cursor info; start=%d, end=%d, row=%#x, col=%#x",(vd_cursor_mode>>8) & 0xff,vd_cursor_mode & 0xff, vd_cursor_row, vd_cursor_col);

    setDH(vd_cursor_row);
    setDL(vd_cursor_col);
    setCX(vd_cursor_mode);
    setAH(0);
}


GLOBAL void vd_get_light_pen IFN0()
{
    /*
     * Read the current position  of the light pen. Tests light pen switch
     * & trigger & returns AH == 0 if not triggered. (This should always be
     * true in this version) If set (AH == 1) then returns:
     *  DH, DL - row, column of char lp posn.
     *  CH  -  raster line (0-199)
     *  BX  -  pixel column (0-319,639)
     */

    half_word status;

    if (sas_hw_at_no_check(vd_video_mode) == 7) {
        setAX(0x00F0);    /* Returned by real MDA */
        return;           /* MDA doesn't support a light pen */
    }

    inb(CGA_STATUS_REG, &status);
    if ((status & 0x6) == 0) {	/* Switch & trigger */
	setAH(0);		/* fail */
	return;
    }
    else {		        /* not supported */
#ifndef PROD
	trace("call to light pen - trigger | switch was on!", DUMP_REG);
#endif
    }
}


GLOBAL void vd_set_active_page IFN0()
{
    /*
     * Set active display page from the 8 (4) available from the adaptor.
     * Parameters:
     * 	AL - New active page #
     */

    word cur_pos,vd_addr_6845,vd_crt_start,vd_cols_on_screen;
    half_word vd_cursor_col, vd_cursor_row;
#ifdef V7VGA
    UTINY bank;
#endif

    /* Load internal variables with the values stored in BIOS
     * data area.
     */

    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);
    vd_addr_6845 = sas_w_at_no_check(VID_INDEX);

    /*	redundancy check against BIOS page number variable removed as it
	was redundant (more checks in the outbs) and caused a bug in
	"image.exe", a 3D drawing package for EGA which itself sets the
	BIOS variable before using this routine to set the active page */

    if (sas_hw_at_no_check(vd_video_mode) >3 && sas_hw_at_no_check(vd_video_mode)<8)return;	/* Only one page for MDA * CGA graphics */
    sas_store_no_check (vd_current_page , getAL());

#ifdef V7VGA
	/*
	 *	This function is used by the Video 7 to set the bank for the
	 *	hi-res V7 graphics modes.
	 *	For this case, the setting of vd_crt_start etc. seems to be
	 *	inappropriate.
	 */

	if (sas_hw_at_no_check(vd_video_mode) >= 0x14)
	{
		bank = sas_hw_at_no_check(vd_current_page);
		set_banking( bank, bank );

		return;
	}
#endif /* V7VGA */

    /* start of screen */
    vd_crt_start = sas_w_at_no_check(VID_LEN) * sas_hw_at_no_check(vd_current_page);
    /*
     * Update BIOS data variables
     */
    sas_storew_no_check((sys_addr)VID_ADDR, vd_crt_start);

    if(alpha_num_mode())vd_crt_start /= 2; /* WORD address for text modes */

    /*
     * set the start address into the colour adaptor
     */

    outb(CGA_INDEX_REG, CGA_R12_START_ADDRH);
    outb(CGA_DATA_REG, (IU8)(vd_crt_start >> 8));
    outb(CGA_INDEX_REG, CGA_R13_START_ADDRL);
    outb(CGA_DATA_REG, (IU8)(vd_crt_start  & 0xff));

    /*
     * Swap to cursor for this page
     */

    vd_cursor_col = sas_hw_at_no_check(VID_CURPOS + sas_hw_at_no_check(vd_current_page)*2);
    vd_cursor_row = sas_hw_at_no_check(VID_CURPOS + sas_hw_at_no_check(vd_current_page)*2 + 1);

   /*
    * Calculate position in regen buffer, ignoring attribute bytes
    */

    cur_pos = (sas_w_at_no_check(VID_ADDR)+vd_page_offset( vd_cursor_col, vd_cursor_row)) / 2;

    outb(M6845_INDEX_REG, R14_CURS_ADDRH);
    outb(M6845_DATA_REG,  (IU8)(cur_pos >> 8));
    outb(M6845_INDEX_REG, R15_CURS_ADDRL);
    outb(M6845_DATA_REG,  (IU8)(cur_pos & 0xff));

}

GLOBAL void vd_scroll_up IFN0()
{
    /*
     * Scroll up a block of text.  The parameters are held in the following
     * registers:
     *
     * AL - Number of rows to scroll. NB. if AL == 0 then the whole region
     *      is cleared.
     * CX - Row/col of upper left corner
     * DX - row/col of lower right corner
     * BH - attribute to be used on blanked line(s)
     *
     * IMPORTANT MESSAGE TO ALL VIDEO HACKERS:
     * vd_scroll_up() and vd_scroll_down() are functionally identical
     * except for the sense of the scroll - if you find and fix a bug
     * in one, then please do the same for the other
     */
    word vd_cols_on_screen;
    int t_row,b_row,l_col,r_col,lines,attr;
    int rowsdiff,colsdiff;
#ifdef JAPAN
    int text_flag = 0;
#endif // JAPAN

    /* Load internal variables with the values stored in BIOS
     * data area.
     */
    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);

    t_row = getCH();
    b_row = getDH();
    l_col = getCL();
    r_col = getDL();
    lines = getAL();
    attr = getBH();

#ifdef	JAPAN
    // #4183: status line of oakv(DOS/V FEP) doesn't disappear -yasuho
    // $disp.sys is also be able to scroll in IME status lines.
    if (!is_us_mode()) {
	if(b_row > VD_ROWS_ON_SCREEN + IMEStatusLines)
	    b_row = VD_ROWS_ON_SCREEN + IMEStatusLines;
	if(t_row > VD_ROWS_ON_SCREEN + IMEStatusLines)
	    t_row = VD_ROWS_ON_SCREEN + IMEStatusLines;
    } else {
	if(b_row > VD_ROWS_ON_SCREEN)
	    b_row = VD_ROWS_ON_SCREEN;
	if(t_row > VD_ROWS_ON_SCREEN)
	    t_row = VD_ROWS_ON_SCREEN;
    }
#else // !JAPAN
    if(b_row > VD_ROWS_ON_SCREEN)
		b_row = VD_ROWS_ON_SCREEN; /* trim to screen size */

    if(t_row > VD_ROWS_ON_SCREEN)
		t_row = VD_ROWS_ON_SCREEN; /* trim to screen size */
#endif // !JAPAN

    if (r_col < l_col)		/* some dipstick has got their left & right mixed up */
    {
	colsdiff = l_col;	/* use colsdiff as temp */
	l_col = r_col;
	r_col = colsdiff;
    }

#ifdef JAPAN
    // for HANAKO v2 installer, it sets DL to 0x80 ( >=vd_cols_on_screen)
    // And when app set DL=0x4f, text_scroll should be run
    if ( r_col == 0x80 || r_col == 0x4f)
        text_flag = 1;
#endif // JAPAN
    if ( r_col >= vd_cols_on_screen )
    	r_col = vd_cols_on_screen-1;

    colsdiff = r_col-l_col+1;
    rowsdiff = b_row-t_row+1;

    if (lines == 0)	/* clear region */
    {
	lines = rowsdiff;
    }
#ifdef JAPAN
    // for HANAKO v2 installer, it sets DL to 0x80 ( >=vd_cols_on_screen )
    if(r_col == vd_cols_on_screen-1 && !text_flag)
#else // !JAPAN
    if(r_col == vd_cols_on_screen-1)
#endif // !JAPAN
    {
#ifdef EGG
	if(ega_mode())
    		ega_sensible_graph_scroll_up(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#  ifdef VGG
	else if(vga_256_mode())
    		vga_sensible_graph_scroll_up(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#  endif
	else
#endif
    	kinky_scroll_up(t_row,l_col,rowsdiff,colsdiff,lines,attr,vd_cols_on_screen);
    }
    else
    {
	if(alpha_num_mode())
    		sensible_text_scroll_up(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#ifdef EGG
#  ifdef VGG
	else if(vga_256_mode())
    		vga_sensible_graph_scroll_up(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#  endif
	else if(ega_mode())
    		ega_sensible_graph_scroll_up(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#endif
	else
    		sensible_graph_scroll_up(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#ifdef EGA_DUMP
	dump_scroll(sas_hw_at_no_check(vd_video_mode),0,video_pc_low_regen,sas_w_at_no_check(VID_ADDR),sas_w_at_no_check(VID_COLS),
    		t_row,l_col,rowsdiff,colsdiff,lines,attr);
#endif
    /*
     * re-enable video for this mode, if on a CGA adaptor (fixes ROUND42 bug).
     */
	if(video_adapter == CGA)
    	outb(CGA_CONTROL_REG, vd_mode_table[sas_hw_at_no_check(vd_video_mode)].mode_control_val);
    }
#ifdef	JAPAN
    // mskkbug#2757 works2.5 garbage remains after exiting install -yasuho
    // We need flush screen when scroll the screen.
    Int10FlagCnt++;
#endif // JAPAN
}

/*
 * Functions to scroll sensible areas of the screen. This routine will try to use
 * host scrolling and clearing.
 */
LOCAL void sensible_text_scroll_up IFN6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr)
{
    register sys_addr	source, dest;
#if !defined(i386) && defined(JAPAN)
    register sys_addr sourceV, destV;
    int                 linesdiff;
    word attrW = (word)((attr << 8)|' ');
#endif // !i386 && JAPAN
    register int	col_incr,i;
    boolean 		screen_updated = FALSE;
    int			vd_cols_on_screen = sas_w_at_no_check(VID_COLS);
#ifdef JAPAN
    // for mskkbug #875
    byte *p = &Int10Flag[t_row * vd_cols_on_screen + l_col];
#endif // JAPAN


	/* Set origin of data movement for calculating screen refresh */

#if defined(JAPAN) && defined(i386)
    // mode73h support
    if ( !is_us_mode() && ( sas_hw_at_no_check (DosvModePtr) == 0x73 ) ) {
       source = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row)*2 + video_pc_low_regen;

       col_incr = sas_w_at_no_check(VID_COLS) * 4;	/* offset to next line */
    }
    else {
       source = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row) + video_pc_low_regen;
       col_incr = sas_w_at_no_check(VID_COLS) * 2;	/* offset to next line */
    }
#else // !JAPAN || !i386
    source = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row) + video_pc_low_regen;
#if !defined(i386) && defined(JAPAN)
    sourceV = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row) + DosvVramPtr;
#endif // !i386 && JAPAN
    col_incr = sas_w_at_no_check(VID_COLS) * 2;	/* offset to next line */
#endif // !JAPAN || !i386

	/* Try to scroll the adaptor memory & host screen. */

	if( source >= get_screen_base() )
	{
#if defined(JAPAN) && defined(i386)
	    // mode73h support
	    if ( !is_us_mode() && ( sas_hw_at_no_check (DosvModePtr) == 0x73 ) ) {
                screen_updated = (*update_alg.scroll_up)(source,4*colsdiff,rowsdiff,attr,lines,0);
            }
            else {
                screen_updated = (*update_alg.scroll_up)(source,2*colsdiff,rowsdiff,attr,lines,0);
            }
#else // !JAPAN || !i386
	    screen_updated = (*update_alg.scroll_up)(source,2*colsdiff,rowsdiff,attr,lines,0);
#endif // !JAPAN || i386
	}

    dest = source;
#if !defined(i386) && defined(JAPAN)
    destV = sourceV;
#endif // !i386 && JAPAN
/*
 * We dont need to move data which would be scrolled off the
 * window. So point source at the first line which needs to
 * be retained.
 *
 * NB if we are just doing a clear, the scroll for loop will
 * terminate immediately.
 */
    source += lines*col_incr;	
#if !defined(i386) && defined(JAPAN)
    sourceV += lines*col_incr;
    linesdiff = vd_cols_on_screen * lines;
#endif // !i386 && JAPAN
    for(i = 0; i < rowsdiff-lines; i++)
    {
#ifdef REAL_VGA
		VcopyStr(&M[dest],&M[source], colsdiff*2);
#else
#ifdef JAPAN
		// for RAID #875
		if( !screen_updated ) {
		    // mode73h support
#ifdef i386
		    if ( !is_us_mode() && (sas_hw_at_no_check(DosvModePtr) == 0x73 ) ) {
	  	        sas_move_bytes_forward (source, dest, colsdiff*4);
                    }
                    else {
	  	        sas_move_bytes_forward (source, dest, colsdiff*2);
                    }

#else // !i386
	    sas_move_bytes_forward (source, dest, colsdiff*2);
	    if ( !is_us_mode() )
	      sas_move_bytes_forward (sourceV, destV, colsdiff*2);
#endif // !i386
                    {
                        register int i;

                        for ( i = 0; i < colsdiff; i++ ) {
#ifdef i386
                            p[i] = ( p[i+vd_cols_on_screen] | INT10_CHANGED );
#else // !i386
//I think this is correct!!
                            p[i] = ( p[i+linesdiff] | INT10_CHANGED );
#endif // !i386
                        }
                    }
                }
#else // !JAPAN
		if( !screen_updated )
			sas_move_bytes_forward (source, dest, colsdiff*2);
#endif // !JAPAN
#endif

		/* next line */
		source += col_incr;
		dest += col_incr;
#ifdef JAPAN
#if !defined(i386)
		sourceV += col_incr;
		destV += col_incr;
#endif // !i386
                p += vd_cols_on_screen;
#endif // JAPAN
    }

/* moved all the data we were going to move - blank the cleared region */

#if !defined(i386) && defined(JAPAN)
    if( sas_hw_at_no_check(DosvModePtr) == 0x73 )
      attrW = 0;
#endif // !i386 && JAPAN

    while(lines--)
    {
#ifdef REAL_VGA
		sas_fillsw_16(dest, (attr << 8)|' ', colsdiff);
#else
#ifdef JAPAN
		// for mskkbug #875
		if( !screen_updated ) {
		// mode73h support
#ifdef i386
		    if ( !is_us_mode() && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ) ) {
                        unsigned long *destptr = (unsigned long *)dest;
                        int i;

                        for ( i = 0; i < colsdiff; i++ ) {
                            *destptr++ = (attr << 8)|' ';
                        }
                    }
                    else {
		        sas_fillsw(dest, (attr << 8)|' ', colsdiff);
                    }
#else // !i386
                    sas_fillsw(dest, (attr << 8)|' ', colsdiff);
		    //add Apr. 18 1994 DosvVram holds extended attributes
		    if ( !is_us_mode() )
		      sas_fillsw(destV, attrW, colsdiff);
#endif // !i386
#ifdef i386
// "p" (Int10Flag) is on 32 bit address space, so we must no use "sas" function
// to access 32 bit address.
                    sas_fills( (sys_addr)p, ( INT10_SBCS | INT10_CHANGED ), colsdiff );
#else // !i386
                    {
		      register int i = colsdiff;
		      register byte *pp = p;
		      while( i-- ){
			*pp++ = ( INT10_SBCS | INT10_CHANGED );
		      }
		    }
#endif // !i386
                }
#else // !JAPAN
		if( !screen_updated )
			sas_fillsw(dest, (IU16)((attr << 8)|' '), colsdiff);
#endif // !JAPAN
#endif
		dest += col_incr;
#ifdef JAPAN
#if !defined(i386)
		destV += col_incr;
#endif // !i386
                p += vd_cols_on_screen;
#endif // JAPAN
    }
}

LOCAL void sensible_graph_scroll_up IFN6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr)
{
    sys_addr	source, dest;
    int		i,colour;
    boolean 	screen_updated;

	rowsdiff *= 4;		/* 8 scans per char - 4 per bank */
	lines *= 4;		/* scan lines */

    /* Set origin of data movement for calculating screen refresh */

	if( sas_hw_at_no_check(vd_video_mode) != 6)
	{
		colour = attr & 0x3;
		colsdiff *= 2;		/* 4 pixels/byte */

		source = vd_medium_offset(l_col, t_row) + video_pc_low_regen;
	}
	else
	{
		colour = attr & 0x1;
		source = vd_high_offset(l_col, t_row) + video_pc_low_regen;
	}

	/* Try to scroll the adaptor memory & host screen */

    screen_updated = (*update_alg.scroll_up)(source,colsdiff,rowsdiff,attr,lines,colour);

    if( screen_updated && (video_adapter != CGA ))
		return;

    dest = source;

	/*
	 * We dont need to move data which would be scrolled off the
	 * window. So point source at the first line which needs to
	 * be retained.
	 *
	 * NB if we are just doing a clear, the scroll for loop will
	 * terminate immediately.
	 */

	source += lines*SCAN_LINE_LENGTH;	

	for(i = 0; i < rowsdiff-lines; i++)
	{
#ifdef REAL_VGA
		VcopyStr(&M[dest],&M[source], colsdiff);
#else
		sas_move_bytes_forward (source,dest, colsdiff);
#endif
		/*
		 * graphics mode has to cope with odd bank as well
		 */
#ifdef REAL_VGA
		VcopyStr(&M[dest+ODD_OFF],&M[source+ODD_OFF], colsdiff);
#else
		sas_move_bytes_forward (source+ODD_OFF,dest+ODD_OFF, colsdiff);
#endif
		source += SCAN_LINE_LENGTH;
		dest += SCAN_LINE_LENGTH;
	}

    /* Moved all the data we were going to move - blank the cleared region */

	while( lines-- )
	{
#ifdef REAL_VGA
		sas_fills_16(dest, attr, colsdiff);
		sas_fills_16(dest+ODD_OFF, attr, colsdiff);
#else
		sas_fills(dest, (IU8)attr, colsdiff);
		sas_fills(dest+ODD_OFF, (IU8)attr, colsdiff);
#endif
		dest += SCAN_LINE_LENGTH;
	}
}

/*
 * Handle silly case where the wally programmer is scrolling a daft window.
 * We must be careful not to scribble off the end of the video page, to avoid
 * nasty things like dead MacIIs.
 */
LOCAL void kinky_scroll_up IFN7(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr, int, vd_cols_on_screen)
{
    register sys_addr	source, dest;
    register int	col_incr;
    register int	i;
    half_word is_alpha;

    switch (sas_hw_at_no_check(vd_video_mode)) {

    case 0: case 1: case 2:		/* text */
    case 3: case 7:
	is_alpha = TRUE;
	/* set origin of data movement for calculating screen refresh */
	source = sas_w_at_no_check(VID_ADDR)+vd_page_offset(l_col, t_row) + video_pc_low_regen;
	col_incr = vd_cols_on_screen * 2;	/* offset to next line */
	break;

    case 6: case 4: case 5:
	is_alpha = FALSE;
	rowsdiff *= 4;		/* 8 scans per char - 4 per bank */
	lines *= 4;		/* scan lines */
#ifdef NTVDM
	/* mode 4 and 5 have 40 rows with 4 pixels/byte while
	 * mode 6 has 80 rows with 8 pixels/byte.
	 * They have the same line increment value
	 */
	col_incr = SCAN_LINE_LENGTH;
#endif
	if (sas_hw_at_no_check(vd_video_mode) != 6) {
	    colsdiff *= 2;		/* 4 pixels/byte */
	    /* set origin of data movement for calculating screen refresh */
	    source = vd_medium_offset(l_col, t_row) + video_pc_low_regen;
	}
	else
	    source = vd_high_offset(l_col, t_row) + video_pc_low_regen;

	break;

    default:
#ifndef PROD
	trace("bad video mode\n",DUMP_REG);
#endif
	;
    }

    dest = source;
/*
 * We dont need to move data which would be scrolled off the
 * window. So point source at the first line which needs to
 * be retained. AL lines ( = lines ) are to be scrolled so
 * add lines*<width> to source pointer - apg
 *
 * NB if we are just doing a clear, the scroll for loop will
 * terminate immediately.
 */
    source += lines*col_incr;	
    if (is_alpha) {
	    for(i = 0; i < rowsdiff-lines; i++) {
#ifdef REAL_VGA
	        VcopyStr(&M[dest],&M[source], colsdiff*2);
#else
		sas_move_bytes_forward (source,dest, colsdiff*2);
#endif
	        /* next line */
	        source += col_incr;
	        dest += col_incr;
	    }
     }
     else {
	    for(i = 0; i < rowsdiff-lines; i++) {
#ifdef REAL_VGA
	        VcopyStr(&M[dest],&M[source], colsdiff);
#else
		sas_move_bytes_forward (source,dest, colsdiff);
#endif
	        /*
	         * graphics mode has to cope with odd bank as well
	         */
#ifdef REAL_VGA
	        VcopyStr(&M[dest+ODD_OFF],&M[source+ODD_OFF], colsdiff);
#else
		sas_move_bytes_forward (source+ODD_OFF,dest+ODD_OFF, colsdiff);
#endif
	        source += SCAN_LINE_LENGTH;
	        dest += SCAN_LINE_LENGTH;
	    }
     }
    /* moved all the data we were going to move - blank the cleared region */
    if (is_alpha) {

	while(lines--) {
	    if((dest + 2*colsdiff) > video_pc_high_regen+1)
	    {
		colsdiff = (int)((video_pc_high_regen+1-dest)/2);
		lines = 0; /* force termination */
	    }
#ifdef REAL_VGA
	    sas_fillsw_16(dest, (attr << 8)|' ', colsdiff);
#else
	    sas_fillsw(dest, (IU16)((attr << 8)|' '), colsdiff);
#endif
	    dest += col_incr;
        }
    }
    else {

	while( lines-- ) {
#ifdef REAL_VGA
	    sas_fills_16(dest, attr, colsdiff);
	    sas_fills_16(dest+ODD_OFF, attr, colsdiff);
#else
	    sas_fills(dest, (IU8)attr, colsdiff);
	    sas_fills(dest+ODD_OFF, (IU8)attr, colsdiff);
#endif
	    dest += SCAN_LINE_LENGTH;
	}
    }

}


GLOBAL void vd_scroll_down IFN0()
{
    /*
     * Scroll down a block of text.  The parameters are held in the following
     * registers:
     *
     * AL - Number of rows to scroll. NB. if AL == 0 then the whole region
     *      is cleared.
     * CX - Row/col of upper left corner
     * DX - row/col of lower right corner
     * BH - attribute to be used on blanked line(s)
     *
     * IMPORTANT MESSAGE TO ALL VIDEO HACKERS:
     * vd_scroll_up() and vd_scroll_down() are functionally identical
     * except for the sense of the scroll - if you find and fix a bug
     * in one, then please do the same for the other
     */
    word vd_cols_on_screen;
    int t_row,b_row,l_col,r_col,lines,attr;
    int rowsdiff,colsdiff;
#ifdef JAPAN
    int text_flag = 0;
#endif // JAPAN

    /* Load internal variables with the values stored in BIOS
     * data area.
     */
    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);

    t_row = getCH();
    b_row = getDH();
    l_col = getCL();
    r_col = getDL();
    lines = getAL();
    attr = getBH();

#ifdef	JAPAN
    // #4183: status line of oakv(DOS/V FEP) doesn't disappear 12/11/93 yasuho
    // $disp.sys is also be able to scroll in IME status lines.
    if (!is_us_mode()) {
	if(b_row > VD_ROWS_ON_SCREEN + IMEStatusLines)
	    b_row = VD_ROWS_ON_SCREEN + IMEStatusLines;
	if(t_row > VD_ROWS_ON_SCREEN + IMEStatusLines)
	    t_row = VD_ROWS_ON_SCREEN + IMEStatusLines;
    } else {
	if(b_row > VD_ROWS_ON_SCREEN)
	    b_row = VD_ROWS_ON_SCREEN;
	if(t_row > VD_ROWS_ON_SCREEN)
	    t_row = VD_ROWS_ON_SCREEN;
    }
#else // !JAPAN
    if(b_row > VD_ROWS_ON_SCREEN)
		b_row = VD_ROWS_ON_SCREEN; /* trim to screen size */

    if(t_row > VD_ROWS_ON_SCREEN)
		t_row = VD_ROWS_ON_SCREEN; /* trim to screen size */
#endif // !JAPAN

    if (r_col < l_col)		/* some dipstick has got their left & right mixed up */
    {
	colsdiff = l_col;	/* use colsdiff as temp */
	l_col = r_col;
	r_col = colsdiff;
    }

#ifdef JAPAN
    // for HANAKO v2 installer, it sets DL to 0x80 ( >=vd_cols_on_screen)
    // And when app set DL=0x4f, text_scroll should be run
    if ( r_col == 0x80 || r_col == 0x4f)
        text_flag = 1;
#endif // JAPAN
    if ( r_col >= vd_cols_on_screen )
    	r_col = vd_cols_on_screen-1;

    colsdiff = r_col-l_col+1;
    rowsdiff = b_row-t_row+1;

    if (lines == 0)	/* clear region */
    {
	lines = rowsdiff;
    }
#ifdef JAPAN
    // for HANAKO v2 installer
    if(r_col == vd_cols_on_screen-1 && !text_flag)
#else // !JAPAN
    if(r_col == vd_cols_on_screen-1)
#endif // !JAPAN
#ifdef EGG
	if(ega_mode())
    		ega_sensible_graph_scroll_down(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#  ifdef VGG
	else if(vga_256_mode())
    		vga_sensible_graph_scroll_down(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#  endif
	else
#endif
    	kinky_scroll_down(t_row,l_col,rowsdiff,colsdiff,lines,attr,vd_cols_on_screen);
    else
    {
	if(alpha_num_mode())
    		sensible_text_scroll_down(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#ifdef EGG
	else if(ega_mode())
    		ega_sensible_graph_scroll_down(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#  ifdef VGG
	else if(vga_256_mode())
    		vga_sensible_graph_scroll_down(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#  endif
#endif
	else
    		sensible_graph_scroll_down(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#ifdef EGA_DUMP
	dump_scroll(sas_hw_at_no_check(vd_video_mode),1,video_pc_low_regen,sas_w_at_no_check(VID_ADDR),sas_w_at_no_check(VID_COLS),
    		t_row,l_col,rowsdiff,colsdiff,lines,attr);
#endif
    /*
     * re-enable video for this mode, if on a CGA adaptor (fixes ROUND42 bug).
     */
	if(video_adapter == CGA)
    	outb(CGA_CONTROL_REG, vd_mode_table[sas_hw_at_no_check(vd_video_mode)].mode_control_val);
    }
#ifdef	JAPAN
    // mskkbug#2757: works2.5: garbage remains after exiting install -yasuho
    // We need flush screen when scroll the screen.
    Int10FlagCnt++;
#endif // JAPAN
}

LOCAL void sensible_text_scroll_down IFN6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr)
{
    register sys_addr	source, dest;
#if !defined(i386) && defined(JAPAN)
    register sys_addr	sourceV, destV;
    int                 linesdiff;
    word attrW = (word)((attr << 8)|' ');
#endif // !i386 && JAPAN
    register int	col_incr;
    register int	i;
    boolean		screen_updated;
    int			vd_cols_on_screen = sas_w_at_no_check(VID_COLS);
#ifdef JAPAN
    // for mskkbug #875
    byte *p = &Int10Flag[ (t_row+rowsdiff-1) * vd_cols_on_screen + l_col];
#endif // JAPAN

#if defined(JAPAN) && defined(i386)
    // mode73h support
    if ( !is_us_mode() && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ) ) {
       source = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row)*2 + video_pc_low_regen;

       col_incr = sas_w_at_no_check(VID_COLS) * 4;	/* offset to next line */
    }
    else {
       source = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row) + video_pc_low_regen;
       col_incr = sas_w_at_no_check(VID_COLS) * 2;	/* offset to next line */
    }
#else // !JAPAN || !i386
	source = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row) + video_pc_low_regen;
	col_incr = sas_w_at_no_check(VID_COLS) * 2;
#if !defined(i386) && defined(JAPAN)
	sourceV = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row) + DosvVramPtr;
#endif // !i386 && JAPAN
#endif // !386 || !JAPAN

	/* Try to scroll the adaptor memory & host screen. */

	if( source >= get_screen_base() )
	{
#if defined(JAPAN) && defined(i386)
            // mode73h support
	    if ( !is_us_mode() && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ) ) {
                screen_updated = (*update_alg.scroll_up)(source,4*colsdiff,rowsdiff,attr,lines,0);
            }
            else {
                screen_updated = (*update_alg.scroll_up)(source,2*colsdiff,rowsdiff,attr,lines,0);
            }
#else // !JAPAN || !i386
	    screen_updated = (*update_alg.scroll_down)(source,2*colsdiff,rowsdiff,attr,lines,0);
#endif // !JAPAN || !i386
	}

    dest = source + (rowsdiff-1)*col_incr;
    source = dest - lines*col_incr;
#if !defined(i386) && defined(JAPAN)
    destV = sourceV + (rowsdiff-1)*col_incr;
    sourceV = destV - lines*col_incr;
    linesdiff = vd_cols_on_screen * lines;
#endif // !i386 && JAPAN
/*
 * NB if we are just doing a clear area, the scrolling 'for' loop will terminate immediately
 */

	for(i = 0; i < rowsdiff-lines; i++)
	{
#ifdef REAL_VGA
		VcopyStr(&M[dest],&M[source], colsdiff*2);
#else
#ifdef JAPAN
		// for mskkbug #875
		if( !screen_updated ) {
		// mode73h support
#ifdef i386
		    if ( !is_us_mode() && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ) ) {
	  	        sas_move_bytes_forward (source, dest, colsdiff*4);
                    }
                    else {
		        sas_move_bytes_forward (source, dest, colsdiff*2);
                    }

#else // !i386
		    sas_move_bytes_forward (source, dest, colsdiff*2);
		    if ( !is_us_mode())
		      sas_move_bytes_forward( sourceV, destV, colsdiff*2);
#endif // !i386
                    {
                        register int i;

                        for ( i = 0; i < colsdiff; i++ ) {
#ifdef i386
                            p[i] = ( p[i - vd_cols_on_screen] | INT10_CHANGED );
#else // !i386
			    //I think this is correct!!
                            p[i] = ( p[i - linesdiff] | INT10_CHANGED );
#endif // !i386
                        }
                    }
                }
#else // !JAPAN
		if( !screen_updated )
			sas_move_bytes_forward (source, dest, colsdiff*2);
#endif // !JAPAN
#endif
		source -= col_incr;
		dest -= col_incr;
#ifdef JAPAN
#if !defined(i386)
		sourceV -= col_incr;
		destV -= col_incr;
#endif // !i386
                p -= vd_cols_on_screen;
#endif // JAPAN
	}

    /* moved all the data we were going to move - blank the cleared region */

#if !defined(i386) && defined(JAPAN)
    if( sas_hw_at_no_check(DosvModePtr) == 0x73 )
      attrW = 0;
#endif // !i386 && JAPAN

	while(lines--)
	{
#ifdef REAL_VGA
		sas_fillsw_16(dest, (attr << 8)|' ', colsdiff);
#else
#ifdef JAPAN
		// for mskkbug #875
		if( !screen_updated ) {
		// mode73h support
#ifdef i386
//"dest" is on DOS address space, so we must use "sas" function to access it.
		    if ( !is_us_mode() && (sas_hw_at_no_check(DosvModePtr) == 0x73 ) ) {
                        unsigned long *destptr = (unsigned long*)dest;
                        int i;

                        for ( i = 0; i < colsdiff; i++ ) {
                            *destptr++ = (attr << 8)|' ';
                        }
                    }
                    else {
 		        sas_fillsw(dest, (attr << 8)|' ', colsdiff);
                    }
#else // !i386
		        sas_fillsw(dest, (attr << 8)|' ', colsdiff);
                    if ( !is_us_mode() )
		        sas_fillsw(destV, attrW, colsdiff);
#endif // !i386
#ifdef i386
// "p" (Int10Flag) is on 32 bit address space, so we must no use "sas" function
// to access 32 bit address.
                    sas_fills( (sys_addr)p, ( INT10_SBCS | INT10_CHANGED ), colsdiff );
#else // !i386
                    {	
		      register int i = colsdiff;
		      register byte *pp = p;
		      while( i-- ){
			*pp++ = ( INT10_SBCS | INT10_CHANGED );
		      }
		    }
#endif // !i386
                }
#else // !JAPAN
		if( !screen_updated )
			sas_fillsw(dest, (IU16)((attr << 8)|' '), colsdiff);
#endif // !JAPAN
#endif
		dest -= col_incr;
#ifdef JAPAN
#if !defined(i386)
		destV -= col_incr;
#endif // !i386
                p -= vd_cols_on_screen;
#endif // JAPAN
	}
}

LOCAL void sensible_graph_scroll_down IFN6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr)
{
    sys_addr	source, dest;
    int		i,colour;
    boolean		screen_updated;

	rowsdiff *= 4;		/* 8 scans per char, 4 per bank */
	lines *= 4;

	if( sas_hw_at_no_check(vd_video_mode) != 6 )
	{
		colour = attr & 0x3;
		colsdiff *= 2;		/* 4 pixels/byte */

		source = vd_medium_offset(l_col, t_row)+video_pc_low_regen;
	}
	else
	{
		colour = attr & 0x1;
		source = vd_high_offset(l_col, t_row)+video_pc_low_regen;
	}

	/* Try to scroll the host screen */

    screen_updated = (*update_alg.scroll_down)(source,colsdiff,rowsdiff,attr,lines,colour);

	if( screen_updated && ( video_adapter != CGA ))
		return;

    dest = source + (rowsdiff-1)*SCAN_LINE_LENGTH;
    source = dest - lines*SCAN_LINE_LENGTH;

	/*
	 * NB if we are just doing a clear area, the scrolling 'for' loop
	 * will terminate immediately
	 */

	for( i = 0; i < rowsdiff-lines; i++ )
	{
		/*
		 * graphics mode has to do odd & even banks
		 */

#ifdef REAL_VGA
		VcopyStr(&M[dest],&M[source], colsdiff);
		VcopyStr(&M[dest+ODD_OFF],&M[source+ODD_OFF], colsdiff);
#else
		sas_move_bytes_forward (source, dest, colsdiff);
		sas_move_bytes_forward (source+ODD_OFF, dest+ODD_OFF, colsdiff);
#endif
		source -= SCAN_LINE_LENGTH;
		dest -= SCAN_LINE_LENGTH;
	}

	/* moved all the data we were going to move - blank the cleared region */

	while( lines-- )
	{
#ifdef REAL_VGA
		sas_fills_16(dest, attr, colsdiff);
		sas_fills_16(dest+ODD_OFF, attr, colsdiff);
#else
		sas_fills(dest, (IU8)attr, colsdiff);
		sas_fills(dest+ODD_OFF, (IU8)attr, colsdiff);
#endif
		dest -= SCAN_LINE_LENGTH;
	}
}

LOCAL void kinky_scroll_down IFN7(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr, int, vd_cols_on_screen)
{
    register sys_addr	source, dest;
    register int	col_incr;
    register int	i;
    half_word is_alpha;

    switch (sas_hw_at_no_check(vd_video_mode)) {

    case 0: case 1: case 2:
    case 3: case 7:
	is_alpha = TRUE;
	col_incr = vd_cols_on_screen * 2;
	source = sas_w_at_no_check(VID_ADDR)+vd_page_offset(l_col, t_row)+video_pc_low_regen;	/* top left */
	break;

    case 4: case 5: case 6:
	is_alpha = FALSE;
	rowsdiff *= 4;		/* 8 scans per char, 4 per bank */
	lines *= 4;
	col_incr = SCAN_LINE_LENGTH;
	if(sas_hw_at_no_check(vd_video_mode) != 6) {
	    colsdiff *= 2;		/* 4 pixels/byte */
	    source = vd_medium_offset(l_col, t_row)+video_pc_low_regen;
	}
	else
	    source = vd_high_offset(l_col, t_row)+video_pc_low_regen;
	break;

    default:
#ifndef PROD
	trace("bad video mode\n",DUMP_REG);
#endif
	;
    }

    /* set origin of data movement for calculating screen refresh */
    dest = source + (rowsdiff-1)*col_incr;
    source = dest -lines*col_incr;

	/*
	 * NB if we are just doing a clear area, the scrolling 'for' loop
	 * will terminate immediately
	 */

	if (is_alpha) {
	    for(i = 0; i < rowsdiff-lines; i++) {
#ifdef REAL_VGA
	        VcopyStr(&M[dest],&M[source], colsdiff*2);
#else
		sas_move_bytes_forward (source, dest, colsdiff*2);
#endif
	        source -= col_incr;
	        dest -= col_incr;
	    }
	}
	else {
	    for(i = 0; i < rowsdiff-lines; i++) {
#ifdef REAL_VGA
	        VcopyStr(&M[dest],&M[source], colsdiff);
#else
		sas_move_bytes_forward (source, dest, colsdiff);
#endif
	        /*
	         * graphics mode has to do odd & even banks
	         */
#ifdef REAL_VGA
	        VcopyStr(&M[dest+ODD_OFF],&M[source+ODD_OFF], colsdiff);
#else
		sas_move_bytes_forward (source+ODD_OFF, dest+ODD_OFF, colsdiff);
#endif
	        source -= col_incr;
	        dest -= col_incr;
	    }
	}

    /* moved all the data we were going to move - blank the cleared region */

    if (is_alpha) {		/* alpha blank */
	while(lines--) {
#ifdef REAL_VGA
	    sas_fillsw_16(dest, (attr << 8)|' ', colsdiff);
#else
	    sas_fillsw(dest, (IU16)((attr << 8)|' '), colsdiff);
#endif
	    dest -= col_incr;
        }
    }
    else {			/* graphics blank */

	while(lines--) {
#ifdef REAL_VGA
	    sas_fills_16(dest, attr, colsdiff);
	    sas_fills_16(dest+ODD_OFF, attr, colsdiff);
#else
	    sas_fills(dest, (IU8)attr, colsdiff);
	    sas_fills(dest+ODD_OFF, (IU8)attr, colsdiff);
#endif
	    dest -= col_incr;
	}
    }
}


GLOBAL void vd_read_attrib_char IFN0()
{
    /*
     * Routine to read character and attribute from the current cursor
     * position.
     * Parameters:
     *  AH - current video mode
     *  BH - display page (alpha modes)
     * Returns:
     *  AL - character read
     *  AH - attribute read
     */

    register sys_addr   cpos, cgen;
    register half_word	i, ext_no;
    word	        chattr;      /* unfortunately want to take addr */
    word		vd_cols_on_screen;
    half_word	        match[CHAR_MAP_SIZE], tmp[CHAR_MAP_SIZE];
    half_word vd_cursor_col, vd_cursor_row;

    /* Load internal variables with the values stored in BIOS
     * data area.
     */

    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);
    vd_cursor_col = sas_hw_at_no_check(VID_CURPOS + getBH()*2);
    vd_cursor_row = sas_hw_at_no_check(VID_CURPOS + getBH()*2 + 1);

   if (alpha_num_mode()) {		/* alpha */
#if defined(JAPAN) && defined(i386)
      // mode73h support
      if ( ( !is_us_mode() ) && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ) )
        cpos = video_pc_low_regen + vd_cursor_offset(getBH()) * 2;
      else
#endif // JAPAN && i386
	cpos = video_pc_low_regen + vd_cursor_offset(getBH());
#ifdef A2CPU
	(*read_pointers.w_read)( (ULONG)get_byte_addr(cpos) );
	chattr = (*get_byte_addr (cpos));
	chattr |= (*get_byte_addr (cpos+1)) << 8;
#else
	sas_loadw(cpos,&chattr);
#endif /* A2CPU */
	setAX(chattr);			/* hmm that was easy */
    }
#ifdef EGG
    else if(ega_mode())
	ega_read_attrib_char(vd_cursor_col,vd_cursor_row,getBH());
#  ifdef VGG
    else if(vga_256_mode())
	vga_read_attrib_char(vd_cursor_col,vd_cursor_row,getBH());
#  endif
#endif
    else {
	/*
	 * graphics not so easy - have to build 8 byte string with all
	 * colour attributes masked out then match that in the character
	 * generator table (and extended character set if necessary)
	 */
	if (sas_hw_at_no_check(vd_video_mode) != 6)
	    cpos = video_pc_low_regen
            + 2 * (((vd_cursor_row * vd_cols_on_screen) << 2) + vd_cursor_col);
	else
	    cpos = video_pc_low_regen
              + vd_high_offset(vd_cursor_col,vd_cursor_row);
	if (sas_hw_at_no_check(vd_video_mode) == 6) {	/* high res */
	    for(i = 0; i < 4; i++) {	/* build 8 byte char string */
		sas_load(cpos, &match[i*2]);
		sas_load(cpos+ODD_OFF, &match[i*2+1]);
		cpos += 80;
	    }
	}
        else {				/* med res */
            /*
             * Note that in the following, the attribute byte must end
             * up in the LOW byte. That's why the bytes are swapped after the
             * sas_loadw().
             */
	    for(i = 0; i < 4; i++) {		/* to build char string, must */
		sas_loadw(cpos,&chattr);
		chattr = ((chattr>>8) | (chattr<<8)) & 0xffff;

		/* mask out foreground colour */
		match[i*2] = fgcolmask(chattr);

		sas_loadw(cpos+ODD_OFF,&chattr);
		chattr = ((chattr>>8) | (chattr<<8)) & 0xffff;

		/* mask out foreground colour */
		match[i*2+1] = fgcolmask(chattr);
		cpos += 80;
	    }
	}
#ifdef EGG
	if(video_adapter == EGA || video_adapter == VGA)
	    cgen = extend_addr(EGA_FONT_INT*4);
	else
	    cgen = CHAR_GEN_ADDR;			/* match in char generator */
#else
	cgen = CHAR_GEN_ADDR;			/* match in char generator */
#endif
	if (cgen != 0)
		for(i = 0; i < CHARS_IN_GEN; i++) {
			sas_loads (cgen, tmp, sizeof(tmp));
		    if (memcmp(tmp, match, sizeof(match)) == 0)	/* matched */
				break;
		    cgen += CHAR_MAP_SIZE;	/* next char string */
		}
	else
		i = CHARS_IN_GEN;

	if (i < CHARS_IN_GEN)				/* char found */
	    setAL(i);
	else {
	    /*
	     * look for char in extended character set
	     */
	    if ((cgen = extend_addr(BIOS_EXTEND_CHAR*4)) != 0)
	    	for(ext_no = 0; ext_no < CHARS_IN_GEN; ext_no++) {
			sas_loads (cgen, tmp, sizeof(tmp));
		    if (memcmp(tmp, match, sizeof(match)) == 0)	/* matched */
		    		break;
			cgen += CHAR_MAP_SIZE;	/* still valid char len */
	    	}
	    else
		ext_no = CHARS_IN_GEN;

	    if (ext_no < CHARS_IN_GEN)		/* match found... */
		setAL((UCHAR)(ext_no + CHARS_IN_GEN));
	    else
		setAL(0);			/* no match, return 0 */
	}
    }
}


GLOBAL void vd_write_char_attrib IFN0()
{
/*
* Routine to write character and attribute from the current cursor
* position.
* Parameters:
*  AH - current video mode
*  BH - display page (alpha & EGA modes)
*  CX - # of characters to write
*  AL - Character to write
*  BL - attribute of character to write. If in graphics mode then
*       attribute is foreground colour. In that case if bit 7 of BL
*       is set then char is XOR'ed into buffer.
*/

    register word i, cpos;
    word vd_cols_on_screen;
    half_word vd_cursor_col, vd_cursor_row;
#ifdef JAPAN
    word vram_addr;
    static int DBCSState = FALSE;
#endif // JAPAN

    /* Load internal variables with the values stored in BIOS
     * data area.
     */
    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);
    vd_cursor_col = sas_hw_at_no_check(VID_CURPOS + getBH()*2);
    vd_cursor_row = sas_hw_at_no_check(VID_CURPOS + getBH()*2 + 1);

    if (alpha_num_mode())
    {
#ifdef JAPAN
	    // stress test sets cursor over 25line
            if ( !is_us_mode() ) {
                if ( vd_cursor_row > 25 )
                    return; // we can't write VRAM!!
            }
#ifdef i386
	    // mode73h support
	    if ( ( !is_us_mode() ) && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ) )
                cpos = vd_cursor_offset(getBH()) * 2;
            else
#endif // !i386
#endif // JAPAN
		cpos = vd_cursor_offset(getBH());

#ifdef JAPAN
		// Int10Flag set
                Int10FlagCnt++;
                vram_addr = vd_page_offset(vd_cursor_col,vd_cursor_row)/2;
#endif // JAPAN
		/* place in memory */

#ifdef REAL_VGA
		sas_fillsw_16(video_pc_low_regen + cpos, (getBL() << 8) | getAL(), getCX());
#else
		for(i = 0; i < getCX(); i++)
		{
#if ( defined(NTVDM) && defined(MONITOR) ) || defined(GISP_SVGA)/* No Ega planes... */
                        *((unsigned short *)( video_pc_low_regen + cpos)) = (getBL() << 8) | getAL();
#else
#ifdef	EGG
			if ( ( (video_adapter != CGA) && (EGA_CPU.chain != CHAIN2) )
#ifdef CPU_40_STYLE
				|| (getVM())	/* if we are in V86 mode, the memory may be mapped... */
#endif
				)
				sas_storew(video_pc_low_regen + cpos, (getBL() << 8) | getAL());
			else
#endif	/* EGG */
				(*bios_ch2_word_wrt_fn)( (getBL() << 8) | getAL(), cpos );
#endif	/* NTVDM & MONITOR */
#if defined(JAPAN) && defined(i386)
		    // mode73h support
		    if ( ( !is_us_mode() ) && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ) )
                        cpos += 4;
                    else
#endif // JAPAN && i386
			cpos += 2;
#ifdef JAPAN
		        // Int10Flag set
#if 0
                        DbgPrint( "vd_write_char_attrib: Int10Flag Offset=%04X\n", vram_addr );
#endif
                        if ( DBCSState ) {
                            Int10Flag[vram_addr] = INT10_DBCS_TRAILING | INT10_CHANGED;
                            DBCSState = FALSE;
                        }
                        else if ( DBCSState = is_dbcs_first( getAL() ) ) {
                            Int10Flag[vram_addr] = INT10_DBCS_LEADING | INT10_CHANGED;
                        }
                        else {
                            Int10Flag[vram_addr] = INT10_SBCS | INT10_CHANGED;
                        }
                        vram_addr++;
#endif // JAPAN
		}
#endif
    }
#ifdef EGG
    else if(ega_mode())
	ega_graphics_write_char(vd_cursor_col,vd_cursor_row,getAL(),getBL(),getBH(),getCX());
#  ifdef VGG
    else if(vga_256_mode())
	vga_graphics_write_char(vd_cursor_col,vd_cursor_row,getAL(),getBL(),getBH(),getCX());
#  endif
#endif
    else
	/* rather more long winded - call common routine as vd_write_char() */
	graphics_write_char(vd_cursor_col, vd_cursor_row, getAL(), getBL(), getCX());
}


GLOBAL void vd_write_char IFN0()
{
    /*
     * Write a character a number of times starting from the current cursor
     * position.  Parameters are held in the following registers.
     *
     * AH - Crt Mode
     * AL - Character to write
     * CX - Number of characters
     * BH - display page
     *
     */

    register word i, cpos;
    word vd_cols_on_screen;
    half_word vd_cursor_col, vd_cursor_row;
#ifdef JAPAN
    static int DBCSState = FALSE;
    word vram_addr;
#endif // JAPAN

    /* Load internal variables with the values stored in BIOS
     * data area.
     */
    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);
    vd_cursor_col = sas_hw_at_no_check(VID_CURPOS + getBH()*2);
    vd_cursor_row = sas_hw_at_no_check(VID_CURPOS + getBH()*2 + 1);

    /*
     * handle alphanumeric here:
     */

	if (alpha_num_mode())
	{
#ifdef JAPAN
	    // stress test sets cursor over 25line
            if ( !is_us_mode() ) {
                if ( vd_cursor_row > 25 )
                    return; // we can't write VRAM!!
            }
#ifdef i386
	    // mode73h support
	    if ( ( !is_us_mode() ) && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ) )
                cpos = vd_cursor_offset(getBH()) * 2;
            else
#endif // i386
#endif // JAPAN
		cpos = vd_cursor_offset(getBH());
#ifdef JAPAN
	        // Int10Flag set
                Int10FlagCnt++;
                //vram_addr = vd_cursor_offset(getBH()) >> 1;
                vram_addr = vd_page_offset(vd_cursor_col,vd_cursor_row)/2; //7/23/1993 V-KazuyS
#endif // JAPAN

		/* store in memory, skipping attribute bytes */

		for(i = 0; i < getCX(); i++)
		{
#if ( defined(NTVDM) && defined(MONITOR) ) || defined( GISP_SVGA )
                        *((unsigned char *)( video_pc_low_regen + cpos)) =  getAL();
#else
#ifdef	EGG
			if ( ( (video_adapter != CGA) && (EGA_CPU.chain != CHAIN2) )
#ifdef CPU_40_STYLE
				|| (getVM())	/* if we are in V86 mode, the memory may be mapped... */
#endif
				)
				sas_store(video_pc_low_regen + cpos, getAL());
			else
#endif	/* EGG */
				(*bios_ch2_byte_wrt_fn)( getAL(), cpos );
#endif	/* NTVDM & MONITOR */
#if defined(JAPAN) && defined(i386)
		    // mode73h support
		    if ( ( !is_us_mode() ) && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ) )
                        cpos += 4;
                    else
#endif // JAPAN && i386
			cpos += 2;
#ifdef JAPAN
			// Int10Flag set
#if 0
                        DbgPrint( "vd_write_char(%d,%d): Int10Flag Offset=%04X\n", vd_cursor_row, vd_cursor_col, vram_addr );
#endif
                        if ( DBCSState ) {
                            Int10Flag[vram_addr] = INT10_DBCS_TRAILING | INT10_CHANGED;
                            DBCSState = FALSE;
                        }
                        else if ( DBCSState = is_dbcs_first( getAL() ) ) {
                            Int10Flag[vram_addr] = INT10_DBCS_LEADING | INT10_CHANGED;
                        }
                        else {
                            Int10Flag[vram_addr] = INT10_SBCS | INT10_CHANGED;
                        }
                        vram_addr++;
#endif // JAPAN
		}
	}

    /*
     * handle graphics seperately - I know what you're thinking - why pass
     * BL as the attribute when this routine is meant to leave the attribute
     * well alone. Well this is the way it's done in the bios! If it causes
     * problems then we'll need to do a vd_read_char_attr here and then pass the
     * attribute gleaned from that.
     */
#ifdef EGG
    else if(ega_mode())
	ega_graphics_write_char(vd_cursor_col,vd_cursor_row,getAL(),getBL(),getBH(),getCX());
#  ifdef VGG
    else if(vga_256_mode())
	vga_graphics_write_char(vd_cursor_col,vd_cursor_row,getAL(),getBL(),getBH(),getCX());
#  endif
#endif
    else
	graphics_write_char(vd_cursor_col, vd_cursor_row, getAL(), getBL(), getCX());
}


GLOBAL void vd_set_colour_palette IFN0()
{
    /*
     * Set Colo[u]r Palette. Established background, foreground & overscan
     * colours.
     * Parameters:
     *   BH - Colour Id
     *   BL - Colour to set
     *      if BH == 0 background colour set from low bits of BL
     *      if BH == 1 selection made based on low bit of BL
     */

    /* Load internal variables with the values stored in BIOS
     * data area.
     */

    if (getBH() == 1) {		/* use low bit of BL */
	sas_store_no_check (vd_crt_palette, (IU8)(sas_hw_at_no_check(vd_crt_palette) & 0xDF));
	if (getBL() & 1)
	    sas_store_no_check (vd_crt_palette, (IU8)(sas_hw_at_no_check(vd_crt_palette) | 0x20));
    }
    else
	sas_store_no_check (vd_crt_palette, (IU8)((sas_hw_at_no_check(vd_crt_palette) & 0xE0) | (getBL() & 0x1F)));

    /* now tell the 6845 */
    outb(CGA_COLOUR_REG, sas_hw_at_no_check(vd_crt_palette));

}


GLOBAL void vd_write_dot IFN0()
{
    /*
     * Write dot
     * Parameters:
     *  DX - row (0-349)
     *  CX - column (0-639)
     *  BH - page
     *  AL - dot value; right justified 1,2 or 4 bits mode dependant
     *       if bit 7 of AL == 1 then XOR the value into mem.
     */

    half_word	dotval, data;
    int	dotpos, lsb;			/* dot posn in memory */
    half_word  right_just, bitmask;

#ifdef EGG
    if(ega_mode())
    {
	ega_write_dot(getAL(),getBH(),getCX(),getDX());
	return;
    }
#  ifdef VGG
    else if(vga_256_mode())
    {
	vga_write_dot(getAL(),getBH(),getCX(),getDX());
	return;
    }
#  endif
#endif
    dotpos = getDL();			/* row */

    if (dotpos & 1)			/* set up for odd or even banks */
		dotpos = ODD_OFF-40 + 40 * dotpos;
    else
		dotpos *= 40;

    /*
     * different pixel memory sizes for different graphics modes. Mode 6
     * is high res, mode 4,5 medium res
     */

    dotval = getAL();

    if (sas_hw_at_no_check(vd_video_mode) < 6)
    {
		/*
		 * Modes 4 & 5 (medium res)
		 */
		dotpos += getCX() >> 2;		/* column offset */
		right_just = (getCL() & 3) << 1;/* displacement in byte */
		dotval = (dotval & 3) << (6-right_just);
		bitmask = (0xC0 >> right_just); /* bits of interest */

#ifdef EGG
		/*
		 * EGA & VGA can be told which byte has changed, CGA is
		 * only told that screen has changed.
		 */
		if ( video_adapter != CGA )
    			(*update_alg.mark_byte) ( dotpos );
		else
#endif
			setVideodirty_total(getVideodirty_total() + 2);

		/*
		 * if the top bit of the value to write is set then value is xor'ed
		 * onto the screen, otherwise it is or'ed on.
		 */

		if( getAL() & 0x80 )
		{
#ifdef	EGG
			if( video_adapter != CGA )
			{
				lsb = dotpos & 1;
				dotpos = (dotpos >> 1) << 2;
				dotpos |= lsb;

				data = EGA_planes[dotpos];
				EGA_planes[dotpos] =  data ^ dotval;
			}
			else
#endif	/* EGG */
			{
				data = *(UTINY *) get_screen_ptr( dotpos );	
				*(UTINY *) get_screen_ptr( dotpos ) =
					data ^ dotval;
			}
		}
		else
		{
#ifdef	EGG
			if( video_adapter != CGA )
			{
				lsb = dotpos & 1;
				dotpos = (dotpos >> 1) << 2;
				dotpos |= lsb;

				data = EGA_planes[dotpos];
				EGA_planes[dotpos] = (data & ~bitmask) |
					dotval;
			}
			else
#endif	/* EGG */
			{
				data = *(UTINY *) get_screen_ptr( dotpos );	
				*(UTINY *) get_screen_ptr( dotpos ) =
					(data & ~bitmask) | dotval;
			}
		}
    }
    else
    {
		/*
		 * Mode 6 (hi res)
		 */
		dotpos += getCX() >> 3;
		right_just = getCL() & 7;
		dotval = (dotval & 1) << (7-right_just);
		bitmask = (0x80 >> right_just);

#ifdef EGG
		/*
		 * EGA & VGA can be told which byte has changed, CGA is
		 * only told that screen has changed.
		 */
		if ( video_adapter != CGA )
    			(*update_alg.mark_byte) ( dotpos );
		else
#endif
			setVideodirty_total(getVideodirty_total() + 2);

		/*
		 * if the top bit of the value to write is set then value is xor'ed
		 * onto the screen, otherwise it is or'ed on.
		 */

		if( getAL() & 0x80 )
		{
#ifdef	EGG
			if( video_adapter != CGA )
			{
				data = EGA_planes[dotpos << 2];
				EGA_planes[dotpos << 2] =  data ^ dotval;
			}
			else
#endif	/* EGG */
			{
				data = *(UTINY *) get_screen_ptr( dotpos );	
				*(UTINY *) get_screen_ptr( dotpos ) =
					data ^ dotval;
			}
		}
		else
		{
#ifdef	EGG
			if( video_adapter != CGA )
			{
				data = EGA_planes[dotpos << 2];
				EGA_planes[dotpos << 2] = (data & ~bitmask) |
					dotval;
			}
			else
#endif	/* EGG */
			{
				data = *(UTINY *) get_screen_ptr( dotpos );	
				*(UTINY *) get_screen_ptr( dotpos ) =
					(data & ~bitmask) | dotval;
			}
		}
    }
}

extern void ega_read_dot (int, int, int);

GLOBAL void vd_read_dot IFN0()
{
    /*
     * Read dot
     * Parameters:
     *  DX - row (0-349)
     *  CX - column (0-639)
     * Returns
     *  AL - dot value read, right justified, read only
     */

    int	dotpos;			/* dot posn in memory */
    half_word  right_just, bitmask, data;

#ifdef EGG
    if(ega_mode())
    {
	ega_read_dot(getBH(),getCX(),getDX());
	return;
    }
#  ifdef VGG
    else if(vga_256_mode())
    {
	vga_read_dot(getBH(),getCX(),getDX());
	return;
    }
#  endif
#endif
    dotpos = getDL();			/* row */
    if (dotpos & 1)			/* set up for odd or even banks */
	dotpos = ODD_OFF-40 + 40 * dotpos;
    else
	dotpos *= 40;
    /*
     * different pixel memory sizes for different graphics modes. Mode 6
     * is high res, mode 4,5 medium res
     */

    if (sas_hw_at_no_check(vd_video_mode) < 6) {
	dotpos += getCX() >> 2;		/* column offset */
	right_just = (3 - (getCL() & 3)) << 1;/* displacement in byte */
	bitmask = 3; 			/* bits of interest */
    }
    else {
	dotpos += getCX() >> 3;
	right_just = 7 - (getCL() & 7);
	bitmask = 1;
    }
    /*
     * get value of memory at that position, shifted down to bottom of byte
     * Result returned in AL.
     */

	sas_load(video_pc_low_regen+dotpos, &data);	
    setAL((UCHAR)(( data >> right_just) & bitmask));
}


#ifdef CPU_40_STYLE

/* Optimisations are not possible, IO virtualisation may be active. */
#define OUTB(port, val) outb(port, val)

#else

#ifdef NTVDM
#define OUTB( port, val ) {  hack=get_outb_ptr(port); \
                             (**hack)(port,val); }
#else
#define OUTB( port, val )	(**get_outb_ptr( port ))( port, val )
#endif /* NTVDM */

#endif /* CPU_40_STYLE */

GLOBAL void vd_write_teletype IFN0()
{
    /*
     * Provide a teletype interface.  Put a character to the screen
     * allowing for scrolling etc.  The parameters are
     *
     * AL - Character to write
     * BL - Foreground colour in graphics mode
     */

    register char	ch;
    register sys_addr	ch_addr;
    int			cur_pos;
    word vd_addr_6845 = sas_w_at_no_check(VID_INDEX);
    half_word		scroll_required = FALSE;
    half_word		attrib;
    register half_word	vd_cursor_row,vd_cursor_col;
    word 		vd_cols_on_screen;
#ifdef ANSI
     IMPORT VOID (**get_outb_ptr(io_addr))(io_addr address, half_word value);
#else
     IMPORT VOID (**get_outb_ptr())();
#endif
#ifdef NTVDM
     void (** hack)(io_addr address, half_word value);
#endif

    unsigned short savedAX, savedBX, savedCX, savedIP, savedCS, savedDX;
    unsigned short re_entrant = FALSE;
#ifdef JAPAN
    static short dbcs_status = FALSE;
    half_word	 move_cursor_lines = 0;
#endif // JAPAN

    /* Load internal variables with the values stored in BIOS
     * data area.
     */
    ch = getAL();
    if (stream_io_enabled) {
	if (*stream_io_dirty_count_ptr >= stream_io_buffer_size)
	    stream_io_update();
	stream_io_buffer[(*stream_io_dirty_count_ptr)++] = ch;
	return;
    }

    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);

#if defined(NTVDM) && defined(MONITOR)
        /*
        ** Tim August 92, Microsoft. Need to change this test, cos INT 10
        ** vector now points into the NTIO.SYS driver on X86.
        */
        {
                extern word int10_seg;

                re_entrant = (sas_w_at_no_check(0x42) != int10_seg);
        }
#else
#if defined(JAPAN)
    // In case of loading msimei.sys drivers by "devicehigh",
    // re_entrant will be FALSE because msimei.sys hucked Int10 vector.
    // If re_entrant is FALSE ntvdm cannot handle DBCS string correctly.
    {
      register word  SegInt10 = sas_w_at_no_check(0x42);
      re_entrant = ((SegInt10 < 0xa000) || (SegInt10 >= 0xc800));
    }
#else // !JAPAN
    re_entrant = (sas_w_at_no_check(0x42) < 0xa000);
#endif // !JAPAN
#endif

    vd_cursor_col = sas_hw_at_no_check(current_cursor_col);
    vd_cursor_row = sas_hw_at_no_check(current_cursor_row);

#ifdef JAPAN
	if ( dbcs_status == FALSE ) {
	    if ( is_dbcs_first(ch) ) {
		if ( vd_cursor_col + 1 == vd_cols_on_screen ) {
		    savedAX = getAX();
		    savedBX = getBX();
		    setAL( 0x20 );            /* space */
		    vd_write_teletype();
		    setBX( savedBX );
		    setAX( savedAX );
		    // get new col and row
		    vd_cursor_col = sas_hw_at_no_check(current_cursor_col);
		    vd_cursor_row = sas_hw_at_no_check(current_cursor_row);
	        }
		dbcs_status = TRUE;
		goto write_char;
	    }
	}
	else {			/* if kanji second byte then write */
	    dbcs_status = FALSE;
	    goto write_char;
	}

#endif // JAPAN
    /*
     * First check to see if it is a control character and if so action
     * it here rather than call the write char function.
     */

    switch (ch)
    {
    case VD_BS:  			/* Backspace	*/
	if (vd_cursor_col != 0) {
	    vd_cursor_col--;
	}
	break;

    case VD_CR:			/* Return	*/
        vd_cursor_col = 0;
	break;

    case VD_LF:			/* Line feed	*/
	/* Row only should be checked for == (25-1), so in principle
	 * it ignores LF off the top of the screen.
	 */
#ifdef JAPAN
	// scroll problem when start VDM 24line with $IAS.SYS
#ifdef JAPAN_DBG
// DbgPrint("LF---vd_row=%d, VD_ROWS=%d\n", vd_cursor_row, VD_ROWS_ON_SCREEN );
#endif
	if (vd_cursor_row > VD_ROWS_ON_SCREEN) {
                move_cursor_lines = vd_cursor_row - VD_ROWS_ON_SCREEN;
                if ( move_cursor_lines >= VD_ROWS_ON_SCREEN )   // 8/28/1993
                    move_cursor_lines =  0; //VD_ROWS_ON_SCREEN - 1; // Stress test
                vd_cursor_row = VD_ROWS_ON_SCREEN;
		scroll_required = TRUE;
        }
        else
#endif // JAPAN
	if (vd_cursor_row == VD_ROWS_ON_SCREEN)
		scroll_required = TRUE;
	else
		vd_cursor_row++;
	break;

    case VD_BEL:			/* Bell		*/
        host_ring_bell(BEEP_LENGTH);
        return;			/* after all, shouldn't cause a scroll */

    default:
#ifdef JAPAN
write_char:
#endif // JAPAN
        /*
         * It's a real character, place it in the regen buffer.
         */
        if(alpha_num_mode())
	{
	    if(re_entrant)
            {
                 savedAX = getAX();
                 savedBX = getBX();
                 savedCX = getCX();
                 savedIP = getIP();
                 savedCS = getCS();

                 setAH(WRITE_A_CHAR);
                 setBH(sas_hw_at_no_check(vd_current_page));
                 setCX(1);

#if defined(NTVDM) && defined(X86GFX)
                /*
                ** Tim August 92 Microsoft. INT 10 caller code is now
                ** in NTIO.SYS
                */
                {
                        extern word int10_seg, int10_caller;

                        exec_sw_interrupt( int10_seg, int10_caller );
                }
#else
                 setCS(VIDEO_IO_SEGMENT);
                 setIP(VIDEO_IO_RE_ENTRY);
                 host_simulate();

#endif	/* NTVDM & MONITOR */

		/*
		 * Note: Always make sure CS comes before IP
		 */
                 setCS(savedCS);
                 setIP(savedIP);
                 setCX(savedCX);
                 setBX(savedBX);
                 setAX(savedAX);
            }
            else
	    {
#if defined(JAPAN) && defined(i386)
	// alpha always uses EGA plane.
	// mode73h support
	if( !is_us_mode() && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ) ) {
#ifdef JAPAN_DBG
                 DbgPrint( "@" );
#endif
	         ch_addr = sas_w_at_no_check(VID_ADDR) +
                              vd_page_offset(vd_cursor_col,vd_cursor_row) * 2;
        }
        else {
	         ch_addr = sas_w_at_no_check(VID_ADDR) +
                              vd_page_offset(vd_cursor_col,vd_cursor_row);
        }
#else // !JAPAN || !i386
	         ch_addr = sas_w_at_no_check(VID_ADDR) +
                              vd_page_offset(vd_cursor_col,vd_cursor_row);
#endif // !JAPAN && !i386

		/*
		 *	Call the C code to do the biz rather than brothel
		 *	around in SAS.
		 */

#if ( defined(NTVDM) && defined(MONITOR) ) || defined( GISP_SVGA )
                *((unsigned char *)( video_pc_low_regen + ch_addr)) = ch;
#else
#ifdef	EGG
			if ( ( (video_adapter != CGA) && (EGA_CPU.chain != CHAIN2) )
#ifdef CPU_40_STYLE
				|| (getVM())	/* if we are in V86 mode, the memory may be mapped... */
#endif
				)
				sas_store(video_pc_low_regen + ch_addr, ch);
			else
#endif	/* EGG */
				(*bios_ch2_byte_wrt_fn)( ch, ch_addr );
#endif	/* ( NTVDM & MONITOR ) | GISP_SVGA */
	    }
	}
#ifdef EGG
	else if(ega_mode())
            ega_graphics_write_char(vd_cursor_col, vd_cursor_row, ch, getBL(),sas_hw_at_no_check(vd_current_page), 1);
#  ifdef VGG
	else if(vga_256_mode())
            vga_graphics_write_char(vd_cursor_col, vd_cursor_row, ch, getBL(),sas_hw_at_no_check(vd_current_page), 1);
#  endif
#endif
        else
            graphics_write_char(vd_cursor_col, vd_cursor_row, ch, getBL(), 1);

        vd_cursor_col++;
        /*
         * Now see if we have gone off the edge of the screen
         */

        if (vd_cursor_col == vd_cols_on_screen)
        {
            vd_cursor_col = 0;

	    /* Row only should be checked for == (25-1) and
	     * only if there was a line wrap.
	     */
#ifdef JAPAN
	    // scroll problem when start VDM 24line with $IAS.SYS
#ifdef JAPAN_DBG
// DbgPrint("col==80 --vd_row=%d, VD_ROWS=%d\n", vd_cursor_row, VD_ROWS_ON_SCREEN );
#endif
	    if (vd_cursor_row > VD_ROWS_ON_SCREEN) {
                move_cursor_lines = vd_cursor_row - VD_ROWS_ON_SCREEN;
                if ( move_cursor_lines >= VD_ROWS_ON_SCREEN )   // 8/28/1993
                    move_cursor_lines =  0; //VD_ROWS_ON_SCREEN - 1; // Stress test
                vd_cursor_row = VD_ROWS_ON_SCREEN;
		scroll_required = TRUE;
            }
            else
#endif // JAPAN
	    if (vd_cursor_row == VD_ROWS_ON_SCREEN)
		scroll_required = TRUE;
	    else
          	vd_cursor_row++;
        }

        /* cursor_row validity actually never checked unless processing a
         * Line Feed or a wrapping at the end of line.
	 *
	 * The BYTE "text" benchmark program contains an off-by-one error
	 * which causes it to set the cursor position off the end of the
	 * screen: SoftPC was incorrectly deciding to scroll, with consequent
	 * horrendous time penalties...
	 */
    }

    /*
     * By this point we have calculated the new cursor position
     * so output the cursor position and the character
     */

    if(alpha_num_mode())
    {
#ifdef REAL_VGA
        /*
         * tell the 6845 all about the change
         */
	cur_pos = (sas_w_at_no_check(VID_ADDR)+vd_page_offset(vd_cursor_col,
		vd_cursor_row))>>1; /* Word address, not byte */
        outb(vd_addr_6845, R14_CURS_ADDRH);
        outb(vd_addr_6845+1,  cur_pos >> 8);
        outb(vd_addr_6845, R15_CURS_ADDRL);
        outb(vd_addr_6845+1,  cur_pos & 0xff);
	/*
	 * save the current cursor position in the bios
	 */
	sas_store_no_check(current_cursor_col, vd_cursor_col);
	sas_store_no_check(current_cursor_row , vd_cursor_row);
#else
	if(re_entrant)
        {
             savedAX = getAX();
             savedBX = getBX();
             savedDX = getDX();
             savedIP = getIP();
             savedCS = getCS();

             setAH(SET_CURSOR_POS);
             setBH(sas_hw_at_no_check(vd_current_page));
             setDH(vd_cursor_row);
             setDL(vd_cursor_col);

#if defined(NTVDM) && defined(X86GFX)
                /*
                ** Tim August 92 Microsoft. INT 10 caller code is now
                ** in NTIO.SYS
                */
                {
                        extern word int10_seg, int10_caller;

                        exec_sw_interrupt( int10_seg, int10_caller );
                }
#else
             setCS(VIDEO_IO_SEGMENT);
             setIP(VIDEO_IO_RE_ENTRY);
             host_simulate();

#endif	/* NTVDM & MONITOR */

		/*
		 * Note: Always make sure CS comes before IP
		 */

             setCS(savedCS);
             setIP(savedIP);
             setDX(savedDX);
             setBX(savedBX);
             setAX(savedAX);
        }
        else
        {
        /*
		** tell the 6845 all about the change
		*/

		/* Set the current position - word address, not byte */
		cur_pos = (sas_w_at_no_check(VID_ADDR) +
			vd_page_offset(vd_cursor_col, vd_cursor_row)) >> 1;

		OUTB(M6845_INDEX_REG, R14_CURS_ADDRH);
		OUTB(M6845_DATA_REG,  (IU8)(cur_pos >> 8));
		OUTB(M6845_INDEX_REG, R15_CURS_ADDRL);
		OUTB(M6845_DATA_REG,  (IU8)(cur_pos & 0xff));

		/*
		* store the new cursor position in the
		* bios vars (this should be done by the re-entrant
		* code called above)
		*/
		sas_store_no_check (current_cursor_col , vd_cursor_col);
		sas_store_no_check (current_cursor_row , vd_cursor_row);

        }
#endif
    }
    else {
		/*
		* store the new cursor position in the
		* bios vars for graphics mode
		*/
		sas_store_no_check (current_cursor_col , vd_cursor_col);
		sas_store_no_check (current_cursor_row , vd_cursor_row);
    }

    if (scroll_required)
    {
	/*
	 * Update the memory to be scrolled
	 */
	if (alpha_num_mode()) {
#ifdef A2CPU
		ch_addr = video_pc_low_regen + sas_w_at_no_check(VID_ADDR)+vd_page_offset(vd_cursor_col,vd_cursor_row) + 1;
		(*read_pointers.b_read)( (ULONG)get_byte_addr(ch_addr) );
		attrib = (*get_byte_addr (ch_addr));
#else
		sas_load( video_pc_low_regen + sas_w_at_no_check(VID_ADDR)+vd_page_offset(vd_cursor_col,vd_cursor_row) + 1, &attrib);
#endif /* A2CPU */

#ifdef JAPAN
#ifdef JAPAN_DBG
//               DbgPrint("Scroll_required!!!\n" );
#endif
		sensible_text_scroll_up( 0, 0,
                                    VD_ROWS_ON_SCREEN + 1 + move_cursor_lines,
                                    vd_cols_on_screen,
                                    1 + move_cursor_lines,
                                    attrib);
		// #3920: CR+LFs are needed when using 32bit cmd in command.com
		// 12/9/93 yasuho
		Int10FlagCnt++;
#else // !JAPAN
		sensible_text_scroll_up(0,0, VD_ROWS_ON_SCREEN+1,vd_cols_on_screen,1,attrib);
#endif // !JAPAN

	}
#ifdef EGG
	else if(ega_mode())
		ega_sensible_graph_scroll_up(0,0, VD_ROWS_ON_SCREEN+1,vd_cols_on_screen,1,0);
#  ifdef VGG
	else if(vga_256_mode())
		vga_sensible_graph_scroll_up(0,0, VD_ROWS_ON_SCREEN+1,vd_cols_on_screen,1,0);
#  endif
#endif
	else 	/* graphics mode */

		sensible_graph_scroll_up(0,0, VD_ROWS_ON_SCREEN+1,vd_cols_on_screen,1,0);

#ifdef EGA_DUMP
	if(!alpha_num_mode())attrib=0;
	dump_scroll(sas_hw_at_no_check(vd_video_mode),0,video_pc_low_regen,sas_w_at_no_check(VID_ADDR),sas_w_at_no_check(VID_COLS),
		0,0,vd_rows_on_screen+1,vd_cols_on_screen,1,attrib);
#endif

    }
}

GLOBAL void vd_write_string IFN0()
{
    /*
     * AL = write mode (0-3)
     *      Specical for NT: if AL = 0xff then write character string
     *      with existing attributes.
     * BH = page
     * BL = attribute (if AL=0 or 1)
     * CX = length
     * DH = Y coord
     * DL = x coord
     * ES:BP = pointer to string.
     *
     *  NB. This routine behaves very strangely wrt line feeds etc -
     *  These ALWAYS affect the current page!!!!!
     */
	int i,op;
    UCHAR col,row;
    USHORT len;
	UCHAR save_col,save_row;
	sys_addr ptr;
	boolean ctl;
#ifdef NTVDM
	word	count, avail;
#endif
#ifdef JAPAN
	// Big fix for multiplan
	// ntraid:mskkbug#2784: Title of VJE-PEN is strange
	// ntraid:mskkbug#3014: VJE-PEN: function keys don't work on windowed
	// 11/5/93 yasuho
	// Don't broken AX, BX, DX register !!
        IU16 saveAX, saveBX, saveDX;
#endif // JAPAN

	op = getAL();

#ifdef NTVDM
        if (op == 0xff)                 /* Special for MS */
        {

	    if (stream_io_enabled){
		count = getCX();
		avail = stream_io_buffer_size - *stream_io_dirty_count_ptr;
		ptr = effective_addr(getES(), getDI());
		if (count <= avail) {
		    sas_loads(ptr, stream_io_buffer + *stream_io_dirty_count_ptr, count);
		    *stream_io_dirty_count_ptr += count;
		}
		else {	/* buffer overflow */
		    if (*stream_io_dirty_count_ptr) {
			stream_io_update();
		    }
		    while (count) {
			if (count >= stream_io_buffer_size) {
			    sas_loads(ptr, stream_io_buffer, stream_io_buffer_size);
			    *stream_io_dirty_count_ptr = stream_io_buffer_size;
			    stream_io_update();
			    count -= stream_io_buffer_size;
			    ptr += stream_io_buffer_size;
			}
			else {
			    sas_loads(ptr, stream_io_buffer, count);
			    *stream_io_dirty_count_ptr = count;
			    break;
			}
		    }
		}

		setAL(1);
		return;
	    }

            if (sas_hw_at_no_check(vd_video_mode) < 4)  /* text mode */
            {
		ptr = effective_addr(getES(), getDI());
		/* sudeepb 28-Sep-1992 taken out for int10h/13ff fix */
		/* vd_set_cursor_position(); */	 /* set to start from DX */
                for(i = getCX(); i > 0; i--)
                {
                    setAL(sas_hw_at_no_check(ptr));
                    vd_write_teletype();
                    ptr++;
                }
                setAL(1);       /* success - string printed */
            }
            else
            {
                setAL(0);       /* failure */
            }
            return;
        }

#ifdef X86GFX
    else if (op == 0xfe) {
	    disable_stream_io();
	    return;
	}
#endif

#endif	/* NTVDM */

#ifdef JAPAN
	// DOS/V function support
	if ( op == 0x10 ) {
	    unsigned short *Offset;
	    int i;
	    unsigned long addr;

	    // DbgPrint( "\nNTVDM: INT 10 AH=13, AL=%02x\n", op );
	    addr = ( getES() << 4 ) + getBP();
	    col = getDL();
	    row = getDH();
	    len = getCX();

            // mode73h support
#ifdef i386
	    if ( !is_us_mode() && (sas_hw_at_no_check(DosvModePtr) == 0x73) )
                Offset = (unsigned short*)get_screen_ptr( row * get_bytes_per_line()*2 + (col * 4) );
            else
                Offset = (unsigned short*)get_screen_ptr( row * get_bytes_per_line() + (col * 2) );
#else // !i386
	    if( is_us_mode() )
	      return;          //In us mode, do nothing

	    Offset = get_screen_ptr( row * get_bytes_per_line()*2 + (col * 4) );
#endif  // !i386

	    //assert1( len >= 0, "vd_write_string len=%x\n", len );
	    //DbgPrint( "\nread_str len=%d ADDR:%04x ", len, addr );
	    for ( i = len; i > 0; i-- ) {
		sas_storew_no_check( addr, *Offset );
		//DbgPrint( " %04x", (*Offset) );
		addr += 2;
#ifdef i386
		if ( !is_us_mode() && (sas_hw_at_no_check(DosvModePtr) == 0x73) )
                    Offset += 2;
                else
		    Offset++;
#else // !i386
                Offset += 2;
#endif  // !i386
	    }
	    return;
	}
	else if ( op == 0x11 ) {
	    // copy from op == 0x10
	    unsigned short *Offset;
	    int i;
	    unsigned long addr;

#ifdef i386
	    if ( sas_hw_at_no_check(DosvModePtr) != 0x73 || is_us_mode() )
#else // !i386
            if ( is_us_mode() )
	        // In us mode, videomode 73h has no meaning.
#endif  // !i386     REAL DOS/V acts like this.
                return;

	    // DbgPrint( "\nNTVDM: INT 10 AH=13, AL=%02x\n", op );
	    addr = ( getES() << 4 ) + getBP();
	    col = getDL();
	    row = getDH();
	    len = getCX();

	    Offset = (unsigned short*) get_screen_ptr( row * (get_bytes_per_line()*2) + (col * 4) );
	    assert1( len >= 0, "vd_write_string len=%x\n", len );
	    //DbgPrint( "\nread_str len=%d ADDR:%04x ", len, addr );
	    for ( i = len; i > 0; i-- ) {
		sas_storew_no_check( addr, *Offset ); // char, attr1
		addr += 2;
		Offset++;
		sas_storew_no_check( addr, *Offset ); // attr2, attr3
		addr += 2;
		Offset++;
	    }
	    return;
	}
	else if ( op == 0x20 ) {
	    // copy from original routine, and delete ctl check
#ifndef i386
	    if( is_us_mode() )
	      return;        // In us mode, do nothing.

#endif // !i386
	    ptr = effective_addr( getES(), getBP() );
	    col = getDL();
	    row = getDH();
	    len = getCX();
            saveAX = getAX();
            saveBX = getBX();
	    saveDX = getDX();
	    vd_get_cursor_position();
	    save_col = getDL(); save_row = getDH();
	    setCX( 1 );
	    setDL( col ); setDH( row );
	    for( i = len; i > 0; i-- ) {
		vd_set_cursor_position();
		setAL( sas_hw_at_no_check( ptr++ ) );
		setBL( sas_hw_at_no_check( ptr++ ) );
		vd_write_char_attrib();

		if( ++col >= sas_w_at_no_check(VID_COLS) ) {
			if(++row > VD_ROWS_ON_SCREEN ) {
				//setAL( 0xa );
				//vd_write_teletype();
				row--;
			}
			col = 0;
		}
		setDL( col ); setDH( row );
	    }
	    // restore cursor position
	    setDL( save_col ); setDH( save_row );
	    vd_set_cursor_position();
            setCX( len );
	    setDX( saveDX );
            setAX( saveAX );
            setBX( saveBX );
	    return;
	}
	else if ( op == 0x21 ) {
	    // 5/27/1993 V-KazuyS
	    // copy from 0x20 routine

	    unsigned short *Offset;

#ifdef i386
	    if ( sas_hw_at_no_check(DosvModePtr) != 0x73 || is_us_mode() )
	        return;
#else // !i386
	    register sys_addr Vptr = DosvVramPtr;
	    if( is_us_mode() ) //In us mode, videomode 73h is meanless.
                return;
#endif // !i386

	    ptr = effective_addr( getES(), getBP() );
	    col = getDL();
	    row = getDH();
	    len = getCX();
            saveAX = getAX();
            saveBX = getBX();
	    saveDX = getDX();
	    Offset = (unsigned short*)get_screen_ptr( row * (get_bytes_per_line()*2) + (col * 4) );
#ifndef i386
	    // we now use DosvVram to hold extended attribute
	    Vptr += row * get_bytes_per_line() + (col *2);
#endif // !i386
	    vd_get_cursor_position();
	    save_col = getDL(); save_row = getDH();
	    setCX( 1 );
	    setDL( col ); setDH( row );
	    for( i = len; i > 0; i-- ) {
		vd_set_cursor_position();
		setAL( sas_hw_at_no_check( ptr++ ) );
		setBL( sas_hw_at_no_check( ptr++ ) );
		vd_write_char_attrib();

                // V-KazuyS copy ext. attrib
                Offset++;
                *Offset = sas_w_at_no_check( ptr );
#ifndef i386
		sas_move_bytes_forward(ptr, Vptr, 2);
		Vptr += 2;
#endif // !i386
                ptr += 2;                      // Attrib 2 byte
                Offset++;

		if( ++col >= sas_w_at_no_check(VID_COLS) ) {
			if(++row > VD_ROWS_ON_SCREEN ) {
				row--;
			}
			col = 0;
		}
		setDL( col ); setDH( row );
	    }
	    // restore cursor position
	    setDL( save_col ); setDH( save_row );
	    vd_set_cursor_position();
            setCX( len );
	    setDX( saveDX );
            setAX( saveAX );
            setBX( saveBX );
            return;
	}
#endif // JAPAN
	ptr =  effective_addr(getES(),getBP()) ;
	col = getDL();
	row = getDH();
	len = getCX();
	vd_get_cursor_position();
	save_col = getDL(); save_row = getDH();
	setCX(1);
	setDL(col); setDH(row);
	vd_set_cursor_position();
	for(i=len;i>0;i--)
	{
		ctl = sas_hw_at_no_check(ptr) == 7 || sas_hw_at_no_check(ptr) == 8 || sas_hw_at_no_check(ptr) == 0xa || sas_hw_at_no_check(ptr) == 0xd;
		setAL(sas_hw_at_no_check(ptr++));
		if(op > 1)setBL(sas_hw_at_no_check(ptr++));
		if(ctl)
		{
			vd_write_teletype();
			vd_get_cursor_position();
			col = getDL(); row = getDH();
			setCX(1);
		}
		else
		{
			vd_write_char_attrib();
			if(++col >= sas_w_at_no_check(VID_COLS))
			{

				if(++row > VD_ROWS_ON_SCREEN)
				{
					setAL(0xa);
					vd_write_teletype();
					row--;
				}
				col = 0;
			}
			setDL(col); setDH(row);
		}
		vd_set_cursor_position();
	}
	if(op==0 || op==2)
	{
		setDL(save_col); setDH(save_row);
		vd_set_cursor_position();
	}
}


GLOBAL void vd_get_mode IFN0()
{
    /*
     * Returns the current video mode.  Registers are set up viz:
     *
     * AL - Video mode
     * AH - Number of columns on screen
     * BH - Current display page
     */

    word vd_cols_on_screen;
	half_word	video_mode;

    /* Load internal variables with the values stored in BIOS
     * data area.
     */
    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);
	video_mode = sas_hw_at_no_check(vd_video_mode);

    setAL(video_mode);
    setAH((UCHAR)vd_cols_on_screen);
    setBH(sas_hw_at_no_check(vd_current_page));
}


/*
 * ============================================================================
 * Internal functions
 * ============================================================================
 */

/*
 * function to return the (host) address stored at Intel address 'addr'
 * or 0 if not present
 */
LOCAL sys_addr extend_addr IFN1(sys_addr,addr)
{
	word	ext_seg, ext_off;	/* for segment & offset addrs */

	/* get vector */
	ext_off = sas_w_at_no_check(addr);
	ext_seg = sas_w_at_no_check(addr+2);
	/* if still defaults then no extended chars */
	if (ext_seg == EXTEND_CHAR_SEGMENT && ext_off == EXTEND_CHAR_OFFSET)
		return(0);	/* no user set char gen table */
	else
		return( effective_addr( ext_seg , ext_off ) );
}


/*
* routine to establish the foreground colour mask for the appropriate
* medium res. word forming part (1/8th) of the char.
* See vd_read_attrib_char() above.
*/
LOCAL half_word fgcolmask IFN1(word, rawchar)
{
    	register word mask, onoff = 0;

	mask = 0xC000;		/* compare with foreground colour */
	onoff = 0;
	do {
	    if ((rawchar & mask) == 0) /* not this bit, shift */
		onoff <<= 1;
	    else
		onoff = (onoff << 1) | 1;	/* set this bit */
	    mask >>= 2;
	} while(mask);		/* 8 times thru loop */
	return((half_word)onoff);
}


/*
* double all bits in lower byte of 'lobyte' into word.
* Have tried to speed this up using ffs() to only look at set bits but
* add overhead while calculating result shifts
*/
LOCAL word expand_byte IFN1(word, lobyte)
{
    register word mask = 1, res = 0;

    while(mask) {
	res |= lobyte & mask;	/* set res bit if masked bit in lobyte set*/
	lobyte <<= 1;
	mask <<= 1;
	res |= lobyte & mask;	/* and duplicate */
	mask <<= 1;		/* next bit */
    }
    return(res);
}


/*
* Routine to do 'how_many' char writes of 'wchar' with attribute 'attr' from
* position (x,y) in graphics mode
*/
GLOBAL void graphics_write_char IFN5(half_word, x, half_word, y, half_word, wchar, half_word, attr, word, how_many)
{
    register sys_addr	gpos;	/* gpos holds character address &...*/
    register sys_addr   cpos;	/*cpos steps through scanlines for char*/
    register word	j, colword,  colmask;
    register sys_addr	iopos, char_addr;
    register half_word	i, xor;
    half_word		current;

    /*
     * if the high bit of the attribute byte is set then xor the char
     * onto the display
     */
    xor = (attr & 0x80) ? 1 : 0;
    if (wchar >= 128)
    {   /* must be in user installed extended char set */
        if ( (char_addr = extend_addr(4*BIOS_EXTEND_CHAR)) == 0)
        {
#ifndef PROD
            trace("want extended char but no ex char gen set \n",DUMP_REG);
#endif
            return;
        }
        else
            char_addr += (wchar - 128) * CHAR_MAP_SIZE;
    }
#ifdef EGG
    else if(video_adapter == EGA || video_adapter == VGA)
	char_addr = extend_addr(EGA_FONT_INT*4)+ CHAR_MAP_SIZE *wchar;
#endif
    else
        char_addr = CHAR_GEN_ADDR+ CHAR_MAP_SIZE *wchar;	/* point to entry in std set */

    if (sas_hw_at_no_check(vd_video_mode) == 6) {			/* high res */

	gpos = vd_high_offset(x, y);	/* sys & host memory offsets */
	gpos += video_pc_low_regen;

        for(j = 0; j < how_many; j++) {		/* number of chars to store */
	    cpos = gpos++;			/* start of this character */
	    for(i = 0; i < 4; i++) {		/* 8 bytes per char */
		if (xor) {		/* XOR in char */
		    sas_load(cpos, &current);	/* even bank */
		    sas_store(cpos, (IU8)(current ^ sas_hw_at_no_check(char_addr + i*2)));
		    sas_load(cpos+ODD_OFF, &current);
		    current ^= sas_hw_at_no_check(char_addr + i*2+1);
		}
		else {				/* just store new char */
		    sas_store(cpos, sas_hw_at_no_check(char_addr + i*2));
		    current = sas_hw_at_no_check(char_addr + i*2+1);
		}
		sas_store(cpos+ODD_OFF, current);	/* odd bank */
		cpos += SCAN_LINE_LENGTH;			/* next scan line */
	    }
	}
    }

    else {				/* medium res */

	gpos = vd_medium_offset(x, y);	/* sys & host memory offsets */
	gpos += video_pc_low_regen;

	/* build colour mask from attribute byte */
	attr &= 3;			/* only interested in low bits */
	colmask = attr;			/* replicate low bits across word */
	for(i = 0; i < 3; i++)
	    colmask = (colmask << 2) | attr;
	colmask = (colmask << 8) | colmask;

	for(j = 0; j < how_many; j++) {
	    cpos = gpos;
	    gpos += 2;
	    for(i = 0; i < 8; i++) {		/* 16 bytes per char */

		if ((i & 1) == 0)		/* setup for odd/even bank */
		    iopos = cpos;
		else {
		    iopos = cpos+ODD_OFF;
		    cpos += SCAN_LINE_LENGTH;	/* next scan line */
		}

		colword = expand_byte(sas_hw_at_no_check(char_addr + i));  /*char in fg colour*/
		colword &= colmask;
		if (xor) {			          /* XOR in char */
		    sas_load(iopos, &current);
		    sas_store(iopos++, (IU8)(current ^ (colword >> 8)));
		    sas_load(iopos, &current);
		    sas_store(iopos, (IU8)(current ^ (colword & 0xFF)));
		}
		else {					  /* just store char */
		    sas_store(iopos++, (IU8)((colword >> 8)));
		    sas_store(iopos, (IU8)((colword & 0xFF)));
		}
	    }
	}
	how_many *= 2;
    }
}


/*
 * Initialise the M6845 registers for the given mode.
 */

LOCAL void M6845_reg_init IFN2(half_word, mode, word, base)
{
    UCHAR i, table_index;

    switch(mode)
    {
    case 0:
    case 1:  table_index = 0;
	     break;
    case 2:
    case 3:  table_index = NO_OF_M6845_REGISTERS;
	     break;
    case 4:
    case 5:
    case 6:  table_index = NO_OF_M6845_REGISTERS * 2;
	     break;
    default: table_index = NO_OF_M6845_REGISTERS * 3;
	     break;
    }

    for (i = 0; i < NO_OF_M6845_REGISTERS; i++)
    {
	/*
	 * Select the register in question via the index register (== base)
	 * and then output the actual value.
	 */

	outb(base, i);
	outb((IU16)(base + 1), (IU8)(sas_hw_at_no_check(VID_PARMS+table_index + i)));
    }
}

LOCAL void vd_dummy IFN0()
{
}

#ifdef REAL_VGA
/* STF */
GLOBAL sas_fillsw_16 IFN3(sys_addr, address, word, value, sys_addr, length)
{
    register word *to;

    to = (word *)&M[address];
    while(length--)
	*to++ = value;
}

GLOBAL sas_fills_16 IFN3(sys_addr, address, half_word, value, sys_addr, length)
{
    register half_word *to;

    to = (half_word *)&M[address];
    while(length--)
	*to++ = value;
}
/* STF */

GLOBAL VcopyStr IFN3(half_word *, to, half_word *, from, int, len)
{
    while(len--)
	*to++ = *from++;
}
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

GLOBAL void video_init IFN0()
{
    UCHAR mode;
    word vd_addr_6845;
    word curmod;
#ifdef HERC
    EQUIPMENT_WORD equip_flag;
#endif /* HERC */


    /*
     * Initialise BIOS data area variables
     */

    curmod = 0x607;	/* default cursor is scans 6-7 */

    switch (video_adapter)
    {
	case MDA:
        	mode = 0x7;
        	vd_addr_6845  = 0x3B4;
		video_pc_low_regen = MDA_REGEN_START;
		video_pc_high_regen = MDA_REGEN_END;
		break;
#ifdef HERC
	case HERCULES:
		/* put the BW card in the equipment list */
                equip_flag.all = sas_w_at_no_check(EQUIP_FLAG);
                equip_flag.bits.video_mode = VIDEO_MODE_80X25_BW;
		sas_storew_no_check(EQUIP_FLAG, equip_flag.all);
        	mode = 0x7;
        	vd_addr_6845  = 0x3B4;
		video_pc_low_regen = HERC_REGEN_START;
		video_pc_high_regen = HERC_REGEN_END;
		herc_video_init();
		curmod = 0xb0c;	/* cursor is scans 11-12 */
		break;
#endif /* HERC */
#ifdef EGG
    	case EGA:
    	case VGA:
        	mode = 0x3;
        	vd_addr_6845  = 0x3D4;
    		sas_storew_no_check(VID_INDEX, vd_addr_6845);
		sure_sub_note_trace0(CURSOR_VERBOSE,"setting bios vbls start=6, end=7");
    		sas_storew_no_check(VID_CURMOD, 0x607);
    		setAL(mode);
		ega_video_init();
		return;
		break;
#endif
	default:	/* Presumably CGA */
		video_pc_low_regen = CGA_REGEN_START;
		video_pc_high_regen = CGA_REGEN_END;
        	mode = 0x3;
        	vd_addr_6845  = 0x3D4;
    }

    sas_storew_no_check(VID_INDEX, vd_addr_6845);
    sure_sub_note_trace2(CURSOR_VERBOSE,"setting bios vbls start=%d, end=%d",
	(curmod>>8)&0xff, curmod&0xff);
    sas_storew_no_check(VID_CURMOD, curmod);

    /* Call vd_set_mode() to set up 6845 chip */
    setAL(mode);
    (video_func[SET_MODE])();
}

#ifdef HERC
GLOBAL void herc_video_init IFN0()
{

/* Initialize the INTs */
	sas_storew(BIOS_EXTEND_CHAR*4, EGA_INT1F_OFF);
	sas_storew(BIOS_EXTEND_CHAR*4+2, EGA_SEG);
	sas_move_bytes_forward(BIOS_VIDEO_IO*4, 0x42*4, 4);  /* save old INT 10 as INT 42 */
#ifdef GISP_SVGA
	if((ULONG) config_inquire(C_GFX_ADAPTER, NULL) == CGA )
		sas_storew(int_addr(0x10), CGA_VIDEO_IO_OFFSET);
	else
#endif      /* GISP_SVGA */
	sas_storew(BIOS_VIDEO_IO*4, VIDEO_IO_OFFSET);
	sas_storew(BIOS_VIDEO_IO*4+2, VIDEO_IO_SEGMENT);


/* Now set up the EGA BIOS variables */
	sas_storew(EGA_SAVEPTR,VGA_PARMS_OFFSET);
	sas_storew(EGA_SAVEPTR+2,EGA_SEG);
	sas_store(ega_info, 0x00);   /* Clear on mode change, 64K, EGA active, emulate cursor */
	sas_store(ega_info3, 0xf9);  /* feature bits = 0xF, EGA installed, use 8*14 font */
	set_VGA_flags(S350 | VGA_ACTIVE | VGA_MONO);
	host_memset(EGA_planes, 0, 4*EGA_PLANE_SIZE);
	host_mark_screen_refresh();
	init_herc_globals();
	load_herc_font(EGA_CGMN,256,0,0,14);	/* To initialize font */
}


GLOBAL void herc_char_gen IFN0()
{
	switch (getAL())
	{
		case 3:
			break;
		case 0:
		case 0x10:
			load_herc_font(effective_addr(getES(),getBP()),getCX(),getDX(),getBL(),getBH());
			if(getAL()==0x10)
				recalc_text(getBH());
			break;
		case 1:
		case 0x11:
			load_herc_font(EGA_CGMN,256,0,getBL(),14);
			if(getAL()==0x11)
				recalc_text(14);
			break;

		case 0x30:
			setCX(sas_hw_at(ega_char_height));
			setDL(VD_ROWS_ON_SCREEN);
			switch (getBH())
			{
				case 0:
					setBP(sas_w_at(BIOS_EXTEND_CHAR*4));
					setES(sas_w_at(BIOS_EXTEND_CHAR*4+2));
					break;
				case 1:
					setBP(sas_w_at(EGA_FONT_INT*4));
					setES(sas_w_at(EGA_FONT_INT*4+2));
					break;
				case 2:
					setBP(EGA_CGMN_OFF);
					setES(EGA_SEG);
					break;

				default:
					assert2(FALSE,"Illegal char_gen subfunction %#x %#x",getAL(),getBH());
			}
			break;
		default:
			assert1(FALSE,"Illegal char_gen %#x",getAL());
	}
}

GLOBAL load_herc_font IFN5(sys_addr, table, int, count, int, char_off, int, font_no, int, nbytes)
{
	register int i, j;
	register host_addr font_addr;
	register sys_addr data_addr;
	SAVED word font_off[] = { 0, 0x4000, 0x8000, 0xc000, 0x2000, 0x6000, 0xa000, 0xe000 };

	/*
	 * Work out where to put the font. We know where
	 * it's going to end up in the planes so ...
	 */

	font_addr = &EGA_planes[FONT_BASE_ADDR] +
					(font_off[font_no] << 2) + (FONT_MAX_HEIGHT*char_off << 2);
	data_addr = table;

	assert2( FALSE, "Font No. = %4d, No. of Bytes/char. def. = %4d", font_no, nbytes );

	for(i=0; i<count; i++) {

		for(j=0; j<nbytes; j++) {
			*font_addr = sas_hw_at(data_addr++);
			font_addr += 4;
		}

		font_addr += ((FONT_MAX_HEIGHT - nbytes) << 2);
	}

	host_update_fonts();
}

GLOBAL void herc_alt_sel IFN0()
{
        /*
         * The code previously here caused *ALL* Hercules Display AutoDetect
	 * programs to fail and to believe that the adaptor is an EGA Mono -vs-
	 * Hercules. It was designed to allow International Code Pages for DOS
	 * under Herc Mode. Removing it makes AutoDetect programs work and Herc
	  Mono CodePages still work ok for dos versions 4.01 and 5.00
         */
}
#endif /* HERC */

#ifdef NTVDM
void enable_stream_io(void)
{
#ifdef MONITOR
/* for non RISC machine the buffer is from 16bits code bop from spckbd.asm */
    host_enable_stream_io();
    stream_io_enabled = TRUE;
#else
    stream_io_buffer = (half_word *)malloc(STREAM_IO_BUFFER_SIZE_32);
    if (stream_io_buffer != NULL) {
	host_enable_stream_io();
	stream_io_dirty_count_ptr = &stream_io_dirty_count_32;
	stream_io_buffer_size = STREAM_IO_BUFFER_SIZE_32;
	stream_io_enabled = TRUE;
	*stream_io_dirty_count_ptr = 0;
    }
#endif

}

void disable_stream_io(void)
{

    stream_io_update();
    stream_io_enabled = FALSE;
    host_disable_stream_io();
#ifndef MONITOR
    free(stream_io_buffer);
#endif
}
#endif

#if defined(JAPAN) || defined(KOREA)

//;;;;;;;;;;;;;;;;;;; MS-DOS/V BOP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#ifdef i386
#define CONSOLE_BUFSIZE (80*50*2*2)
GLOBAL byte FromConsoleOutput[CONSOLE_BUFSIZE];

GLOBAL int FromConsoleOutputFlag=FALSE;

GLOBAL byte SaveDosvVram[DOSV_VRAM_SIZE];
#endif // i386

// use GetStringBitmap()
#define BITMAPBUFSIZ 128
extern HDC hdcVDM;
extern HFONT hFont24;
extern HFONT hFont16;

extern BOOL VDMForWOW;

// For GetStringBitmap()
typedef struct tagSTRINGBITMAP
{
    UINT uiWidth;
    UINT uiHeight;
    BYTE ajBits[1];
} STRINGBITMAP, *LPSTRINGBITMAP;

typedef struct
{
    BYTE ajBits[19];
} FONTBITMAP8x19;

typedef struct
{
    BYTE ajBits[16];
} FONTBITMAP8x16;

typedef struct
{
    BYTE ajBits[48];
} FONTBITMAP12x24;

typedef struct
{
    BYTE ajBits[32];
} FONTBITMAP16x16;

typedef struct
{
    BYTE ajBits[72];
} FONTBITMAP24x24;

typedef struct
{
    BYTE is_used[189];
    FONTBITMAP16x16 font16x16[189];
} FONT16CACHE, *PFONT16CACHE;

typedef struct
{
    BYTE is_used[189];
    FONTBITMAP24x24 font24x24[189];
} FONT24CACHE, *PFONT24CACHE;

FONTBITMAP8x19  font8x19[256];
FONTBITMAP8x16  font8x16[256];
FONTBITMAP12x24  font12x24[256];

BYTE            font16table[256];
HLOCAL          hFont16mem[128];
HLOCAL          hFont24mem[128];

#define USED (1)
#define NOT_USED (0)

void GetVerticallineFlag( int *VFlag );

UINT
GetStringBitmapA(
    HDC             hdc,
    LPSTR           pc,
    UINT            cch,
    UINT            cbData,
    LPSTRINGBITMAP  pSB
);

void LoadBitmapFont()
{
    char code[3];
    static char sb[BITMAPBUFSIZ];
    LPSTRINGBITMAP psb;
    int i, j;
    int n;
    int VFlag[256];

    // first 8x16, 8x19 font
#ifdef JAPAN_DBG
    DbgPrint( "NTVDM:Loading NTFONT 8x16,8x19\n" );
#endif
    GetVerticallineFlag( VFlag );
    SelectObject( hdcVDM, hFont16 );
    psb = (LPSTRINGBITMAP)sb;
    code[1] = '\0';
    for ( i = 0; i < 256; i++ ) {
        code[0] = (char)i;

        GetStringBitmapA( hdcVDM, code, 1, BITMAPBUFSIZ, psb );

        RtlCopyMemory( &(font8x16[i].ajBits[0]), &(psb->ajBits[0]), 16 );

        for ( j = 0; j < (19-18) * 1; j++ ) {
            if ( VFlag[i] )
                font8x19[i].ajBits[0] = psb->ajBits[0];
            else
                font8x19[i].ajBits[0] = 0x00;
        }
        RtlCopyMemory( &(font8x19[i].ajBits[1]), &(psb->ajBits[0]), 18 );
    }

    // second 12x24 font
#ifdef JAPAN_DBG
    DbgPrint( "NTVDM:Loading NTFONT 12x24\n" );
#endif
    SelectObject( hdcVDM, hFont24 );
    psb = (LPSTRINGBITMAP)sb;
    code[1] = '\0';
    for ( i = 0; i < 256; i++ ) {
        code[0] = (char)i;
        GetStringBitmapA( hdcVDM, code, 1, BITMAPBUFSIZ, psb );

        // 12x24 dot font is console 12x27 font.
        RtlCopyMemory( &(font12x24[i].ajBits[0]), &(psb->ajBits[2]), 48 );
    }



    // make table
    for ( i = 0, n = 0; i < 256; i++ ) {  // Leading byte
        if ( is_dbcs_first(i) ) {
            font16table[i] = n++;
        }
    }
#ifdef JAPAN_DBG
    DbgPrint( "NTVDM:Loading font... end\n" );
#endif
}

// This is only stub routine
// finally, this information gets from registry
void GetVerticallineFlag( int *VFlag )
{
    int i;

    for ( i = 0; i < 256; i++ ) {
        VFlag[i] = FALSE;
    }
    VFlag[0x03] = TRUE;
    VFlag[0x04] = TRUE;
    VFlag[0x05] = TRUE;
    VFlag[0x10] = TRUE;
    VFlag[0x15] = TRUE;
    VFlag[0x17] = TRUE;
    VFlag[0x19] = TRUE;
    VFlag[0x1d] = TRUE;

    return;
}



void GetBitmap()
{
    sys_addr ptr;
    int i;
    int width, height;
    char code[3];
    static char sb[BITMAPBUFSIZ];
    LPSTRINGBITMAP psb;
    int index;
    PFONT16CACHE pCache16;
    PFONT24CACHE pCache24;

#ifdef JAPAN_DBG
    DbgPrint( "NTFONT BOP 02\n" );
    DbgPrint( "ES:SI=%x:%x\n", getES(), getSI() );
    DbgPrint( "BH,BL=%x,%x\n", getBH(), getBL() );
    DbgPrint( "CH,CL=%x,%x\n", getCH(), getCL() );
#endif

    width = getBH();
    height = getBL();
    ptr =  effective_addr(getES(),getSI());

    if ( getCH() == 0 ) {
        if ( ( width == 8 ) && ( height == 16 ) ) {
	    sas_stores_from_transbuf(ptr,
				     (host_addr)&(font8x16[getCL()].ajBits[0]),
				     (sys_addr)16 );
            setAX(0);
        }
        else if ( ( width == 8 ) && ( height == 19 ) ) {
	    sas_stores_from_transbuf(ptr,
				     (host_addr)&(font8x19[getCL()].ajBits[0]),
				     (sys_addr)19 );
            setAX(0);
        }
        else if ( ( width == 12 ) && ( height == 24 ) ) {
	    sas_stores_from_transbuf(ptr,
				     (host_addr)&(font12x24[getCL()].ajBits[0]),
				     (sys_addr)48 );
            setAX(0);
        }
        else {
            DbgPrint( "Illegal Fontsize %xh, %xh\n", getBH(), getBL() );
            setAH(1);
        }
    }
    else {
        if ( !is_dbcs_first( getCH() ) ) {
            setAH( 5 );
            return;
        }
        if ( getCL() < 0x40 || getCL() > 0xfc || getCL() == 0x7f ) {
            setAH( 5 );
            return;
        }
        if (width == 16 && height == 16) {
            index = font16table[getCH()];

            if (!hFont16mem[index])
                hFont16mem[index] = LocalAlloc(LHND, sizeof(FONT16CACHE));

            pCache16 = LocalLock( hFont16mem[index] );
            if (pCache16->is_used[getCL()-0x40] != USED) {
                 code[0] = getCH();
                 code[1] = getCL();
                 code[2] = '\0';
                 psb = (LPSTRINGBITMAP)sb;
                 SelectObject( hdcVDM, hFont16 );
                 GetStringBitmapA(hdcVDM, code, 2, BITMAPBUFSIZ, psb);

                 RtlCopyMemory(&(pCache16->font16x16[getCL()-0x40].ajBits[0]),
                               &(psb->ajBits[0]),
                               32);
                 pCache16->is_used[getCL()-0x40] = USED;
            }
            sas_stores_from_transbuf(ptr,
                   (host_addr)&(pCache16->font16x16[getCL()-0x40].ajBits[0]),
                                     (sys_addr)32);
            LocalUnlock( hFont16mem[index] );

            setAX(0);
        }
        else if (width == 24 && height == 24) {
            index = font16table[getCH()];
            if (!hFont24mem[index])
                hFont24mem[index] = LocalAlloc(LHND, sizeof(FONT24CACHE));

            pCache24 = LocalLock( hFont24mem[index] );
            if (pCache24->is_used[getCL()-0x40] != USED) {
                code[0] = getCH();
                code[1] = getCL();
                code[2] = '\0';
                psb = (LPSTRINGBITMAP)sb;
                SelectObject( hdcVDM, hFont24 );
                GetStringBitmapA( hdcVDM, code, 2, BITMAPBUFSIZ, psb );

                RtlCopyMemory(&(pCache24->font24x24[getCL()-0x40].ajBits[0]),
                              &(psb->ajBits[0]),
                              72 );
                pCache24->is_used[getCL()-0x40] = USED;
            }
            sas_stores_from_transbuf(ptr,
                     (host_addr)&(pCache24->font24x24[getCL()-0x40].ajBits[0]),
				     (sys_addr)72 );
            LocalUnlock( hFont24mem[index] );

            setAX(0);
        }
        else {
            DbgPrint("Illegal Fontsize %xh, %xh\n", getBH(), getBL());
            setAH(1);
        }
    } // bouble byte case
}

// SetBitmap() save the font image to cache,
// and call SetConsoleLocalEUDC() to display in windowed.
void SetBitmap()
{
    sys_addr ptr;
    int i;
    SHORT width, height;
    int index;
    PFONT16CACHE pCache16;
    PFONT24CACHE pCache24;
    COORD cFontSize;

#ifdef JAPAN_DBG
    DbgPrint( "NTFONT BOP 03\n" );
    DbgPrint( "ES:SI=%x:%x\n", getES(), getSI() );
    DbgPrint( "BH,BL=%x,%x\n", getBH(), getBL() );
    DbgPrint( "CH,CL=%x,%x\n", getCH(), getCL() );
#endif

    width = getBH();
    height = getBL();
    ptr =  effective_addr(getES(),getSI());

    if ( getCH() == 0 ) {
        if ( ( width == 8 ) && ( height == 16 ) ) {
	    sas_loads_to_transbuf(ptr,
				  (host_addr)&(font8x16[getCL()].ajBits[0]),
				  (sys_addr)16 );
            setAL(0);
        }
        else if ( ( width == 8 ) && ( height == 19 ) ) {
	    sas_loads_to_transbuf(ptr,
				  (host_addr)&(font8x19[getCL()].ajBits[0]),
				  (sys_addr)19 );
            setAL(0);
        }
        else if ( ( width == 12 ) && ( height == 24 ) ) {
	    sas_loads_to_transbuf(ptr,
		(host_addr)&(font12x24[getCL()].ajBits[0]),
	        (sys_addr)48 );
            setAL(0);
        }
        else {
            DbgPrint( "Illegal Fontsize %xh, %xh\n", getBH(), getBL() );
            setAL(1);
        }
    }
    else {
        if ( !is_dbcs_first( getCH() ) ) {
            setAL( 5 );
            return;
        }
        if ( getCL() < 0x40 || getCL() > 0xfc || getCL() == 0x7f ) {
            setAL( 5 );
            return;
        }
        if ((width == 16) && (height == 16)) {
            index = font16table[getCH()];
            if (!hFont16mem[index])
                hFont16mem[index] = LocalAlloc(LHND, sizeof(FONT16CACHE));

            pCache16 = LocalLock(hFont16mem[index]);
            sas_loads_to_transbuf(ptr,
                    (host_addr)&(pCache16->font16x16[getCL()-0x40].ajBits[0]),
		    (sys_addr)32);
            pCache16->is_used[getCL()-0x40] = USED;
            LocalUnlock(hFont16mem[index]);
            cFontSize.X = width;
            cFontSize.Y = height;

            if (!SetConsoleLocalEUDC(sc.OutputHandle,
                                     getCX(),
                                     cFontSize,
                      (PCHAR)(pCache16->font16x16[getCL()-0x40].ajBits)))
                DbgPrint("NTVDM: SetConsoleEUDC() Error. CodePoint=%04x\n",
                         getCX());
            setAL(0);
        }
        else if ((width == 24) && (height == 24)) {
            index = font16table[getCH()];
            if (!hFont24mem[index])
                hFont24mem[index] = LocalAlloc(LHND, sizeof(FONT24CACHE));

            pCache24 = LocalLock(hFont24mem[index]);
            sas_loads_to_transbuf(ptr,
                    (host_addr)&(pCache24->font24x24[getCL()-0x40].ajBits[0]),
                    (sys_addr)72 );
            pCache24->is_used[getCL()-0x40] = USED;
            LocalUnlock( hFont24mem[index] );
            cFontSize.X = width;
            cFontSize.Y = height;

            if (!SetConsoleLocalEUDC(sc.OutputHandle,
                                     getCX(),
                                     cFontSize,
                       (PCHAR)(pCache24->font24x24[getCL()-0x40].ajBits)))
                DbgPrint("NTVDM: SetConsoleEUDC() Error. CodePoint=%04x\n",
                         getCX() );
            setAL(0);
        }
        else {
            DbgPrint("Illegal Fontsize %xh, %xh\n", getBH(), getBL());
            setAL(1);
        }
    }
}

// ntraid:mskkbug#3167: works2.5: character corrupted -yasuho
// generate single byte charset
void GenerateBitmap()
{
	sys_addr	ptr;
	int		size, nchars, offset;
	char		mode;

	mode = sas_hw_at_no_check(DosvModePtr);
	if (is_us_mode() || (mode != 0x03 && mode != 0x73))
		return;
	ptr =  effective_addr(getES(), getBP());
	size = getBH();
	nchars = getCX();
	offset = getDX();
	if (nchars + offset > 0x100) {
		setCF(1);
		return;
	}
        if (size == 16) {
                sas_loads_to_transbuf(ptr,
				      (host_addr)&(font8x16[offset].ajBits[0]),
				      (sys_addr)(nchars * size));
		setCF(0);
        } else if (size == 19) {
                sas_loads_to_transbuf(ptr,
				      (host_addr)&(font8x19[offset].ajBits[0]),
				      (sys_addr)(nchars * size));
		setCF(0);
        } else if (size == 24) {
                sas_loads_to_transbuf(ptr,
				      (host_addr)&(font12x24[offset].ajBits[0]),
				      (sys_addr)(nchars * size));
		setCF(0);
        } else {
		DbgPrint("Illegal Fontsize %xh\n", size);
		setCF(1);
        }
}


/*
 * MS_DosV_bop()
 *
 * The type of operation is coded into the AH register.
 *
 *  AH = 00 - ff 	for $NTFONT.SYS
 *     = 10		DBCS vector adress(DS:SI)
 *     = 11 - 1f	reserved
 *     = 20		Window information packet adress(DS:SI)
 *     = 21		Text Vram save & restore
 *     = 22		palette and DAC registers operations
 *     = 23		monitoring IME status lines
 *     = 24 - ff     reserved
 *
 */
#if defined(JAPAN)
void MS_DosV_bop IFN0()
#else // JAPAN
void MS_HDos_bop IFN0()
#endif // KOREA
{
    int op;

    op = getAH();
    switch ( op ) {
	case 0x00:

// inquery font type
//
// input
//   ES:SI pointer of buffer
//   CX    buffersize
// output
//   CX    number of font element
//   AL    if CX < N(number of element) then 1
//   ES:SI --> x0, y0(byte)  -- font size
//             x1, y1
//             ......
//             x(N-1), y(N-1)

	    {
		sys_addr ptr;
                int bufsize;
                int N;
                int i;
#ifdef JAPAN_DBG
                DbgPrint( "NTFONT BOP 00\n" );
                DbgPrint( "ES:SI=%x:%x\n", getES(), getSI() );
                DbgPrint( "CX=%x\n", getCX() );
#endif
                if ( VDMForWOW ) {
                    setCF(1);
                    return;
                }
		ptr =  effective_addr(getES(),getSI());
                bufsize = getCX();

                // now only 8x16, 8,19, 16x16 font -- July 13 V-KazuyS
                N = 5;

                if ( N > bufsize ) {
                    N = bufsize;
                    setAL(1);
                }
                else {
                    setAL(0);
                }
                setCX((IU16)N);

                sas_store_no_check( ptr++,  8 );  // x
                sas_store_no_check( ptr++, 16 );  // y
                sas_store_no_check( ptr++,  8 );  // x
                sas_store_no_check( ptr++, 19 );  // y
                sas_store_no_check( ptr++, 12 );  // x
                sas_store_no_check( ptr++, 24 );  // y
                sas_store_no_check( ptr++, 16 );  // x
                sas_store_no_check( ptr++, 16 );  // y
                sas_store_no_check( ptr++, 24 );  // x
                sas_store_no_check( ptr++, 24 );  // y
            }
            break;

	case 0x01:
	    // Load font image from Gre
#ifdef JAPAN_DBG
            DbgPrint( "NTFONT BOP 01\n" );
#endif
            if ( VDMForWOW ) {
                setCF(1);
                return;
            }
            LoadBitmapFont();
            break;

	case 0x02:
	    // Read font image
            if ( VDMForWOW ) {
                setCF(1);
                return;
            }
            GetBitmap();
            break;

	case 0x03:
#ifdef JAPAN_DBG
            //DbgPrint( "NTFONT BOP 03 CH:CL=%02x:%02x\n", getCH(), getCL() );
#endif
            if ( VDMForWOW ) {
                setCF(1);
                return;
            }
            SetBitmap();
            break;


	case 0x10:
#ifdef JAPAN_DBG
	    DbgPrint( "NTVDM: DBCS vector address=%04x:%04x\n", getDS(), getSI() );
#endif
	    {
		// NOTE: This routine is called ONLY ONE from $NtDisp1.sys !
		sys_addr ptr;
		word vector;
		extern UINT ConsoleInputCP;
		extern UINT ConsoleOutputCP;

   	    	DBCSVectorAddr =  effective_addr(getDS(),getSI());
	    	// Save DBCS vector
		DBCSVectorLen = 0;
	   	for ( ptr = DBCSVectorAddr;
			vector = sas_w_at_no_check( ptr ); ptr += 2 ) {
	            SaveDBCSVector[DBCSVectorLen] = vector;
	            DBCSVectorLen++;
	        }
                assert0( ConsoleInputCP == ConsoleOutputCP, "InputCP != OutputCP" );

	        BOPFromNtDisp1Flag = TRUE;

#ifdef JAPAN_DBG
                DbgPrint( "BOP from $NTDISP1\n" );
#endif
	    }
	    break;

	case 0x20:
#ifdef JAPAN_DBG
	    DbgPrint( "NTVDM: Information packet address=%04x:%04x\n", getDS(), getSI() );
#endif
	    /* information packet is
	     *
	     *   offset	bytes	mode	information
	     *   +0x0	2       r	packet length
	     *   +0x2   4   	r	virtual text VRAM address seg:off
	     *   +0x6   4   	r	MS-DOS/V display mode address seg:off
	     *   +0xa   4	w	Windowed or Fullscreen flag address seg:	     *   +0xe   4	r	NT console mode flag address seg:off
	     *                          when VDM terminate, this flag == 1
	     *   +0x12  4	r	Switch to FullScreen subroutine address seg:	     */
	    {
		sys_addr ptr;
		extern UINT ConsoleInputCP;
		extern UINT ConsoleOutputCP;
#ifdef i386
		extern word useHostInt10;
		extern word int10_seg;
#endif

		ptr =  effective_addr(getDS(),getSI());

                DosvVramOff = sas_w_at_no_check( ptr+0x02 );
                DosvVramSeg = sas_w_at_no_check( ptr+0x04 );
                DosvVramPtr = effective_addr( DosvVramSeg, DosvVramOff );

		// disp_win.sys don't know VramSize.
		// because $disp.sys doesn't have get_vram_size function, now.
                DosvVramSize = DOSV_VRAM_SIZE;
#ifdef JAPAN_DBG
                DbgPrint( "NTVDM:DosvVirtualTextVRAM addr = %04x:%04x\n", DosvVramSeg, DosvVramOff );
#endif

                DosvModeOff = sas_w_at_no_check( ptr+0x06 );
                DosvModeSeg = sas_w_at_no_check( ptr+0x08 );
                DosvModePtr = effective_addr( DosvModeSeg, DosvModeOff );
#ifdef JAPAN_DBG
                DbgPrint( "NTVDM:DosvVideoMode addr = %04x:%04x\n", DosvModeSeg, DosvModeOff );
#endif

#ifndef i386	// !!! remeber to change DISP_WIN.SYS since it relies on this.
		sas_storew_no_check( ptr+0x0a, 0 );
		sas_storew_no_check( ptr+0x0c, 0 );
#else
	        sas_storew_no_check( ptr+0x0a, useHostInt10 );
	        sas_storew_no_check( ptr+0x0c, int10_seg );
#endif


                NtConsoleFlagOff = sas_w_at_no_check( ptr+0x0e );
                NtConsoleFlagSeg = sas_w_at_no_check( ptr+0x10 );
                NtConsoleFlagPtr = effective_addr( NtConsoleFlagSeg, NtConsoleFlagOff );
#ifdef JAPAN_DBG
                DbgPrint( "NTVDM:ConsoleFlagAddr = %04x:%04x\n", NtConsoleFlagSeg, NtConsoleFlagOff );
#endif

#ifdef i386
// RISC never use following value.
// Swtich to fullscreen, call these address..
                DispInitOff = sas_w_at_no_check( ptr+0x12 );
                DispInitSeg = sas_w_at_no_check( ptr+0x14 );
#ifdef JAPAN_DBG
                DbgPrint( "NTVDM:Disp Init Addr = %04x:%04x\n", DispInitSeg, DispInitOff );
#endif

		FullScreenResumeOff = sas_w_at_no_check(ptr + 0x16);
		FullScreenResumeSeg = sas_w_at_no_check(ptr + 0x18);
#endif // !i386
                SetModeFlagPtr = effective_addr(
                                       sas_w_at_no_check( ptr+0x1c ),
                                       sas_w_at_no_check( ptr+0x1a ));
		if ( BOPFromNtDisp1Flag )
		    BOPFromDispFlag = TRUE;

                SetDBCSVector( ConsoleInputCP );
                PrevCP = ConsoleOutputCP;

#ifdef JAPAN_DBG
                DbgPrint( "BOP from $NTDISP2\n" );
#endif
	    }
	    break;

#ifdef i386
        case 0x21:
		// Vram save restore function
		// AL == 00 save
		// AL == 01 restore
		// AL == 02 GetConsoleBuffer
		// AL == 03 Get FromConsoleOutput
            {
		sys_addr ptr;
                int op;
                int count;
                int i;

                op = getAL();
		ptr =  effective_addr(getES(),getDI());
                count = getCX();

                if ( op == 0x02 ) {
                    if ( count > DOSV_VRAM_SIZE )
                        count = DOSV_VRAM_SIZE;
                    //for ( i = 0; i < 2; i++ ) {
                        if ( FromConsoleOutputFlag ) {
#ifdef JAPAN_DBG
                            DbgPrint( "NTVDM: MS-DOS/V BOP 21\n" );
#endif
#ifdef i386
//FromConsoleOutput is on 32bit address space not on DOS address space.
			    sas_move_bytes_forward((sys_addr) FromConsoleOutput,
						   (sys_addr) ptr,
						   (sys_addr) count
						  );
#else
			    sas_stores_from_transbuf(ptr,
					       (host_addr) FromConsoleOutput,
					       (sys_addr) count
						  );
#endif
                            FromConsoleOutputFlag = FALSE;
                            break;
                        }
                        else {
                            DbgPrint( "NTVDM: MS-DOS/V BOP 21 can't get console screen data!! \n" );
                            //Sleep( 1000L );
                        }
                    //}
                    break;
                }

                if ( count > DOSV_VRAM_SIZE )
                    count = DOSV_VRAM_SIZE;

                if ( op == 0x00 ) {       // save function
#ifdef JAPAN_DBG
                    DbgPrint( "NTVDM:MS_DOSV_BOP 0x21, %02x %04x:%04x(%04x)\n", op, getES(), getDI(), count );
#endif
//SaveDosvVram is on 32bit address space not on DOS address space.
		    sas_loads_to_transbuf(ptr,
					  (host_addr)SaveDosvVram,
					  (sys_addr)count
					  );

                }
                else if ( op == 0x01 ) {  // restore function
#ifdef JAPAN_DBG
                    DbgPrint( "NTVDM:MS_DOSV_BOP 0x21, %02x %04x:%04x(%04x)\n", op, getES(), getDI(), count );
#endif
// DEC-J comment
// SaveDosvVram is on 32bit address space not on DOS address space.
// for C7 PWB.
// This is internal bop
// It doesn't need check memory type.
		    RtlCopyMemory( (void*)ptr,
				   (void*)SaveDosvVram,
				   (unsigned long)count
				 );
                }
		// #3086: VDM crash when exit 16bit apps of video mode 11h
		// 12/2/93 yasuho
		else if ( op == 0x03 ) { // Get from FromConsoleOutput
		    RtlCopyMemory( (void*)ptr,
				   (void*)FromConsoleOutput,
					     (unsigned long) count
					     );
                }
            }
            break;
#endif // i386

	case 0x22:
	    // #3176: vz display white letter on white screen
	    // 12/1/93 yasuho (reviewed by williamh)
	    // palette and DAC registers operations
	    // Input	AH = 22H
	    //		AL = 00H : get from simulated value for windowed
	    //		ES:DI = ptr to palette/DAC buffer
	    {
		sys_addr	ptr;
		byte		op;
		static void	get_cur_pal_and_DAC(sys_addr);

		op = getAL();
		ptr = effective_addr(getES(), getDI());
#ifdef	VGG
		if (op == 0x00) { // get from simulated value for windowed
			get_cur_pal_and_DAC(ptr);
		}
#endif	//VGG
	    }
	    break;

#if !defined(KOREA)
	case 0x23:
	    // #4183: status line of oakv(DOS/V FEP) doesn't disappear
	    // 12/11/93 yasuho
	    // monitoring IME status lines
	    // Input	AH = 23H
	    //		AL = number of IME status lines
	    {
		IMEStatusLines = getAL();
	    }
	    break;
#endif

        // kksuzuka #6168 screen attributes for DOS fullscreen
	case 0x24:
	    // set console attributes for fullscreen
            // Input	AH = 23H
	    //		AL = none
            // Output	AL 4-7 bit = back ground color
	    //		AL 0-3 bit = fore ground color
	    {
		setAX(textAttr);
	    }
	    break;

#if !defined(KOREA)
        case 0xff:
            // Int10 Function FF
            // ES: Vram seg, DI: Vram Off, CX:counter
            {
                register int i;
                register int vram_addr;
                int DBCSState = FALSE;
                register  char *p;
#ifndef i386
	        register sys_addr V_vram = effective_addr(getES(),getDI());
#endif // !i386

                if ( is_us_mode() ) {
                    setCF(1);
                    return;
                }
		if ( sas_hw_at_no_check(DosvModePtr) != 0x03 ) {
#ifdef JAPAN_DBG
                    DbgPrint( "NTVDM: mode != 0x03, int10 FF not support\n" );
#endif
                    setCF(1);
                    return;
                }
#if 0
                DbgPrint( "Addr %04x:%04x, CX=%x, ", getES(), getDI(), getCX() );
                DbgPrint( "%d, %d, CX=%d\n", getDI() < 160 ? 0 : getDI()/160,
                      getDI() < 160 ? 0 : (getDI() - (getDI()/160)*160)/2, getCX() );
#endif
                Int10FlagCnt++;
                vram_addr = getDI() >> 1;
#ifdef i386
                p = get_screen_ptr( getDI() );
#else // !i386 uses the EGA plane.
                p = get_screen_ptr( getDI()<<1 );

		// for speed up!!
                i = getCX();
                if( vram_addr + i > DOSV_VRAM_SIZE / 2 ){
                    i = DOSV_VRAM_SIZE / 2 - vram_addr;
#ifdef JAPAN_DBG
                    DbgPrint("NTVDM:Int10 FF over VRAM(DI)=%04x\n", getDI() );
#endif
                }
#endif // !i386

#ifdef i386
                for ( i = 0; i < getCX(); i++ ) {
                        if ( vram_addr >= DOSV_VRAM_SIZE/2 ) {
                            DbgPrint("NTVDM:Int10 FF over VRAM(DI)=%04x\n", getDI() );
                            break;
                        }
                        else if ( DBCSState ) {
#else // !i386
		//for speed up!!
                while( i-- ) {
		  sas_loadw(V_vram++, (word *)p);
		  V_vram++;
		  setVideodirty_total(getVideodirty_total() + 2);
                        if ( DBCSState ) {
#endif // !i386
                            Int10Flag[vram_addr] = INT10_DBCS_TRAILING | INT10_CHANGED;
                            DBCSState = FALSE;
                        }
                        else if ( DBCSState = is_dbcs_first( *p ) ) {
                            Int10Flag[vram_addr] = INT10_DBCS_LEADING | INT10_CHANGED;
                        }
                        else {
                            Int10Flag[vram_addr] = INT10_SBCS | INT10_CHANGED;
                        }
                        vram_addr++;
#ifdef i386
                        p += 2;
#else // !i386 uses the EGA plane.
			p += 4;
#endif  // !i386
                }
                // Last char check! for Vz
                if ( DBCSState && ( vram_addr % 80 != 0 ) )
                    Int10Flag[vram_addr] = INT10_DBCS_TRAILING | INT10_CHANGED;

            }
            break;
#endif

	default:
		DbgPrint("NTVDM: Not support MS-DOS/V BOP:%d\n", op );
	        setCF(1);
		return;
    }
    setCF(0);
}

// mskkbug #3176 vz display white letter on white screen -yasuho
#ifdef	VGG
static void get_cur_pal_and_DAC(ptr)
	sys_addr	ptr;
{
	register	i;
	byte		temp;
	struct _rgb {
		byte	red, green, blue;
	} rgb;

	// get palette and overscan
	for(i = 0; i < 16; i++) {
		outb(EGA_AC_INDEX_DATA, (IU8)i); /* set index */
		inb(EGA_AC_SECRET, &temp);
		sas_store(ptr, temp);
		inb(EGA_IPSTAT1_REG, &temp);
		ptr++;
	}
	outb(EGA_AC_INDEX_DATA, 17); /* overscan index */
	inb(EGA_AC_SECRET, &temp);
	sas_store(ptr++, temp);
	inb(EGA_IPSTAT1_REG, &temp);
	outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
	// get DAC registers
	for(i = 0; i < 256; i++)
	{
		outb(VGA_DAC_RADDR, (IU8)i);
		inb(VGA_DAC_DATA, &rgb.red);
		inb(VGA_DAC_DATA, &rgb.green);
		inb(VGA_DAC_DATA, &rgb.blue);
		sas_store(ptr++, rgb.red);
		sas_store(ptr++, rgb.green);
		sas_store(ptr++, rgb.blue);
	}
}
#endif	//VGG

//;;;;;;;;;;;;;;;;;;; end of MS-DOS/V BOP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#endif // JAPAN

#endif // !NEC_98
#if defined(NEC_98)
GLOBAL void video_init IFN0()
{
#ifdef  DBG
//      DbgPrint( "NEC98 : Video PC-98 initiated\n" );
#endif
        set_mode_change_required(TRUE);
        set_word_addressing(TRUE);
        set_offset_per_line(160);
//      set_cur_x(0);
//      set_cur_y(0);
//      set_cursor_visible(TRUE);
        set_doubleword_mode(FALSE);
        set_display_disabled(FALSE);
        set_bytes_per_line(160);
        set_chars_per_line(80);
        set_screen_length(OFFSET_PER_LINE*25);
        set_screen_start(0);
        set_crt_on(TRUE);
        set_beep_on(FALSE);
        set_beep_rate(2000);
        set_pc_pix_height(1);
        set_host_pix_height(1);
        set_pix_char_width(8);
        if (HIRESO_MODE) {              // H-mode video_init
                set_screen_height(599);
                set_char_width(14);
                set_char_height(24);
                set_cursor_start(0);
                set_cursor_height(24);
                set_screen_ptr(0xe0000);
//              sas_store(BIOS_NEC98_CRT_RASTER,0x00);
//              sas_store(BIOS_NEC98_CRT_FLAG,0x00);
//              sas_store(BIOS_NEC98_CRT_CNT,0x00);
//              sas_storew(BIOS_NEC98_CRT_PRM_OFST,0x0000);
//              sas_storew(BIOS_NEC98_CRT_PRM_SEG,0x0000);
//              sas_storew(BIOS_NEC98_CRTV_OFST,0x0000);
//              sas_storew(BIOS_NEC98_CRTV_SEG,0x0000);
//              sas_store(BIOS_NEC98_CRT_W_NO,0x00);
//              sas_storew(BIOS_NEC98_CRT_W_ADR,0x0000);
//              sas_storew(BIOS_NEC98_CRT_W_RASTER,0x0000);
        } else {                        // N-mode video_init
                set_screen_height(399);
                set_char_width(8);
                set_char_height(16);
                set_cursor_start(0);
                set_cursor_height(16);
                set_screen_ptr(0xa0000);
//              sas_store(BIOS_NEC98_CR_RASTER,0x00);
//              sas_store(BIOS_NEC98_CR_STS_FLAG,0x80);
//              sas_store(BIOS_NEC98_CR_CNT,0x00);
//              sas_storew(BIOS_NEC98_CR_OFST,0x0000);
//              sas_storew(BIOS_NEC98_CR_SEG_ADR,0x0000);
//              sas_storew(BIOS_NEC98_CR_V_INT_OFST,0x0000);
//              sas_storew(BIOS_NEC98_CR_V_INT_SEG,0x0000);
//              sas_store(BIOS_NEC98_CR_FONT,0x00);
//              sas_store(BIOS_NEC98_CR_WINDW_NO,0x00);
//              sas_storew(BIOS_NEC98_CR_W_VRAMADR,0x0000);
//              sas_storew(BIOS_NEC98_CR_W_RASTER,0x0000);
        }
        text_splits.nRegions=1;
        text_splits.split[0].addr=NEC98_TEXT_P0_OFF;
        text_splits.split[0].lines=(int)LINES_PER_SCREEN;
//      setDX(0x0020);
//      vd_NEC98_init_textvram();
}

GLOBAL void vd_NEC98_set_mode IFN0(){       /* 0ah Set mode              */
/* Function abstructions:                                            */
/*              Set CRT mode given in AL                             */
/*              Init EGA to mode 3 (80*25) mode,update CRT           */
/*              concerned BIOS_NEC98 work areas.                         */
/*              CRT type is 88 CRT(FIXED).                           */
/*              Display mode is 40*20 mode (FIXED at PROT)           */
/* Inputs:      NONE                                                 */
/*      AL :    Crt mode                                             */
/*              b0: Lines per screen 0=25,1=20                       */
/*              b1:     Chars per Line   0=80,1=40                   */
/*              b2:     Attribute type   0=Virtical Line,1=Graph     */
/*              b3: KCG access mode      0=Code,1=Dot                */
/*              b4-b6:  not used                                     */
/*              b7:     CRT type         0=80 CRT,88CRT              */
/* Outputs:     NONE                                                 */
/*      all emulated registers should be protected.                  */
/* Localvariables:                                                   */
        unsigned        save_ax;        // AX reg save area

#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetMode %#x\n",getAH());
#endif
        save_ax=getAX();                // Save AX
        if (HIRESO_MODE) {
                if (sas_hw_at(BIOS_NEC98_CRT_FLAG)==(getAL()|0x80)) {
                                        // Mode non_changed?
                        return;
                } else {
//                      vd_NEC98_stop_display();
                        sas_store(BIOS_NEC98_CRT_FLAG,(getAL()&0x18)|0x80);
                        if (getAL()&0x10) {
                                set_screen_length(OFFSET_PER_LINE*31);
                                set_screen_height(749);
                        } else {
                                set_screen_length(OFFSET_PER_LINE*25);
                                set_screen_height(599);
                        }
                }
        } else {
                if (sas_hw_at(BIOS_NEC98_CR_STS_FLAG)==(getAL()|0x80)) {
                                        // Mode non_changed ?
                        return;
                } else {
//                      vd_NEC98_stop_display();
                        sas_store(BIOS_NEC98_CR_STS_FLAG,(getAL()&0x0f)|0x80);
                                        // Set MODE 88crt
                        if (getAL()&0x02) {
                                vd_NEC98_stop_display();
                                (void)(*update_alg.calc_update)();
                                set_chars_per_line(40);
                                set_doubleword_mode(TRUE);
                                set_word_addressing(FALSE);
                                vd_NEC98_start_display();
                        } else {
                                set_chars_per_line(80);
                                set_doubleword_mode(FALSE);
                                set_word_addressing(TRUE);
                        }
                        if (getAL()&0x01) {
                                set_screen_length(OFFSET_PER_LINE*20);
                                set_screen_height(319);
                        } else {
                                set_screen_length(OFFSET_PER_LINE*25);
                                set_screen_height(399);
                        }
                }
        }
        set_mode_change_required(TRUE);
        setAX(save_ax);                 // Restore AX
        NEC98GLOBS->dirty_flag=10000;
        (void)(*update_alg.calc_update)();
//      vd_NEC98_start_display();
}

GLOBAL void vd_NEC98_get_mode IFN0(){       /* 0bh Get mode              */
/* Function abstructions:                                            */
/*              Get CRT mode returned in AL                          */
/*              Get CR_STS_FLAG from BIOS_NEC98 work area and            */
/*              store it into AL register.                           */
/* Inputs:      NONE                                                 */
/* Outputs:     NONE                                                 */
/*              AL : CR_STS_FLAG contents.                           */
/*       all other emulated registers should be protected.           */
/* Localvariables:      NONE                                         */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT GetMode %#x\n",getAH());
#endif
        if (HIRESO_MODE) {
                setAL( sas_hw_at(BIOS_NEC98_CRT_FLAG));
        } else {
                setAL( sas_hw_at(BIOS_NEC98_CR_STS_FLAG) );
        }
}

GLOBAL void vd_NEC98_start_display IFN0(){  /* 0ch Start display         */
/* Function abstructions:                                            */
/*              Start display                                        */
/*              Force graphics_tick routine to refresh next          */
/* Inputs:      NONE                                                 */
/* Outputs:     NONE                                                 */
/*      all emulated registers should be protected.                  */
/* Localvariables:      NONE                                         */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT StartDisplay %#x\n",getAH());
#endif
        set_crt_on(TRUE);
        NEC98GLOBS->dirty_flag=10000;    // Causes whole screen refresh
        set_cursor_visible(cursor_flag);
        is_disp_cursor=cursor_flag;     // Show it!
}

GLOBAL void vd_NEC98_stop_display IFN0(){   /* 0dh Stop display          */
/* Function abstructions:                                            */
/*              Stop display                                         */
/* Inputs:      NONE                                                 */
/* Outputs:     NONE                                                 */
/*       all emulated registers should be protected.                 */
/* Localvariables:      NONE                                         */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT StopDisplay %#x\n",getAH());
#endif
        set_crt_on(FALSE);
        cursor_flag=is_cursor_visible();
        is_disp_cursor=0;               // Show it!
        set_cursor_visible(FALSE);
}

GLOBAL void vd_NEC98_single_window IFN0(){  /* 0eh Set single window     */
/* Function abstructions:                                            */
/*              Set single window area                               */
/*              Update BIOS_NEC98 works CR_W_VRAMADDR/RASTER             */
/*              Update emulation works text_splits                   */
/*              Force graphics_tick routine to refresh next          */
/* Inputs:      NONE                                                 */
/*              DX :    Display addr(relative to TX-VRAM area.)      */
/* Outputs:     NONE                                                 */
/*       all emulated registers should be protected.                 */
/* Localvariables:      NONE                                         */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetSingleWindow %#x\n",getAH());
#endif
        if ((getDX() >= 0) && (getDX() < 0x4000)) {
                text_splits.nRegions=1; // Single window
                text_splits.split[0].addr=NEC98_TEXT_P0_OFF+getDX();
                                        // Set Addr
                if (HIRESO_MODE) {
                        sas_storew(BIOS_NEC98_CRT_W_ADR,getDX());
                                        // Set VRAM addr
                        sas_storew(BIOS_NEC98_CRT_W_RASTER,0x0000);
                                        // Set VRAM raster
                } else {
                        sas_storew(BIOS_NEC98_CR_W_VRAMADR,getDX());
                                        // Set VRAM addr
                        sas_storew(BIOS_NEC98_CR_W_RASTER,0x1900);
                                        // Set VRAM raster
                }
                text_splits.split[0].lines=(int)LINES_PER_SCREEN;
                NEC98GLOBS->dirty_flag=10000;
                                        // Causes whole screen refresh
        } else {
#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetSingleWindow(BadNum!!)\n",getAH());
#endif
        }
}

GLOBAL void vd_NEC98_multi_window IFN0(){   /* 0fh Set multi window      */
/* Function abstructions:                                            */
/*              Set multi window area                                */
/*              Update BIOS_NEC98 works CR_W_VRAMADDR/RASTER             */
/*              Update emulation works text_splits                   */
/*              Force graphics_tick routine to refresh next          */
/* Inputs:      NONE                                                 */
/*              BX :    Display region list addr(SEG).               */
/*              CX :    Display region list addr(OFF).               */
/*              DH :    First element of display region(0-3).        */
/*              DL :    Number of elements to be displayed(1-4).     */
/* NOTE: Display region list structure...                            */
/*      (offset)(Meanings)                                           */
/*      +0      Start address (0):Address Text VRAM in GDC offset address.*/
/*              (Half of CPU Address)                                */
/*      +2      Number of lines(0):Number of lines in the region.    */
/*              maximum more 3 lists can be specified.               */
/* Outputs:     NONE                                                 */
/*      all emulated registers should be protected.                  */
/* Localvariables:                                                   */
        unsigned short  *ListAddr;      // Display list addr in VDM space
        int             Cnt;            // Counter

#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetMultiWindow %#x\n",getAH());
#endif
        ListAddr=(getBX()<<4)+getCX();  // List addr
        if ((getDH()+getDL() < 5) && (*ListAddr < 0x2000)
                && (getDH() >= 0) && (getDL() > 0)) {
//              text_splits.nRegions=getDH()+getDL();
                                        // Set emulator work
                if ((getDH()+getDL()) > text_splits.nRegions)
                        text_splits.nRegions=getDH()+getDL();
                if (getDH() == 0) {
                        if (HIRESO_MODE) {
                                sas_storew(BIOS_NEC98_CRT_W_ADR,*ListAddr);
                                        // Store first addr
                        } else {
                                sas_storew(BIOS_NEC98_CR_W_VRAMADR,*ListAddr);
                                        // Store first addr
                        }
                }

                for ( Cnt=0;Cnt<getDL();Cnt++ ) {
                        if (*ListAddr < 0x2000) {
                                text_splits.split[getDH()+Cnt].addr=
                                        NEC98_TEXT_P0_OFF+(*ListAddr);
                        } else {
                                text_splits.nRegions-=(4-Cnt);
                                break;
                        }
                        ListAddr++;
                        text_splits.split[getDH()+Cnt].lines=*ListAddr;
                        ListAddr++;
                }
                if (HIRESO_MODE) {
                        sas_storew(BIOS_NEC98_CRT_W_RASTER,0x0000);
                } else {
                        sas_storew(BIOS_NEC98_CR_W_RASTER,0x1900);
                }
                NEC98GLOBS->dirty_flag=10000;
                                        // Causes whole screen refresh
        } else {
#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetMultiWindow(BadNum!!)\n",getAH());
#endif
        }
}

GLOBAL void vd_NEC98_set_cursor IFN0(){     /* 10h Set cursor type       */
/* Function abstructions:                                            */
/*              Set cursor type                                      */
/* Inputs:      NONE                                                 */
/*              AL :    Cursor blinking switch 0:blink 1:Not blink   */
/*              Ignored for pure-ega/vga                             */
/* NOTE: Cursor form is determined automatically by current CRT mode */
/*      CRT     Lines   CursorRasters   RasterSize      BlinkingRate     */
/*      88CRT   25      16              0-15            12           */
/*              20      20              0-19            12           */
/*      80CRT   25      8               0-7             12           */
/*              20      10              0-9             12           */
/*      80CRT no longer needed........................               */
/*      But these values translated into 0-7 for CGA texts...        */
/* Outputs:     NONE                                                 */
/*      all emulated registers should be protected.                  */
/* Localvariables:      NONE                                         */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetCursor %#x\n",getAH());
#endif
}

GLOBAL void vd_NEC98_show_cursor IFN0(){    /* 11h Show cursor           */
/* Function abstructions:                                            */
/*              Set cursor show                                      */
/* Inputs:      NONE                                                 */
/* Outputs:     NONE                                                 */
/*      all emulated registers should be protected.                  */
/* Localvariables:      NONE                                         */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT ShowCursor %#x\n",getAH());
#endif
        is_disp_cursor=1;               // Show it!
        set_cursor_visible(TRUE);
        cursor_flag=TRUE;
}

GLOBAL void vd_NEC98_hide_cursor IFN0(){    /* 12h Hide cursor           */
/* Function abstructions:                                            */
/*              Set cursor hide                                      */
/* Inputs:      NONE                                                 */
/* Outputs:     NONE                                                 */
/*      all emulated registers should be protected.                  */
/* Localvariables:      NONE                                         */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT HideCursor %#x\n",getAH());
#endif
        is_disp_cursor=0;               // Show it!
        set_cursor_visible(FALSE);
        cursor_flag=FALSE;
}

GLOBAL void vd_NEC98_set_cursorpos IFN0(){  /* 13h Set cursor position   */
/* Function abstructions:                                            */
/*              Set cursor position                                  */
/* Inputs:      NONE                                                 */
/*              DX      :       Cursor Position (Offset)             */
/* Outputs:     NONE                                                 */
/*      all emulated registers should be protected.                  */
/* Localvariables:                                                   */
#if 0
        unsigned char *vram_NEC98,*attr_NEC98;
        unsigned linepos,colmnpos;
        unsigned linecount;
        int     i,num;
        BOOL    curs_set;
#ifdef  DBG
//      DbgPrint("NEC98:KBCRT SetCursorPos %#x\n",getAH());
#endif

        vram_NEC98=( unsigned char *)getDX()+NEC98_TEXT_P0_OFF;
                                        // Vaddr in VDM
        attr_NEC98=( unsigned char *)getDX()+NEC98_ATTR_P0_OFF;
                                        // Vaddr in VDM
        curs_set=FALSE;
        if (get_word_addressing()) {
                num=2;
        } else {
                num=4;
        }
        // Convert NEC_98 VRAM CPU address into EGA CPU address
//      for (i=0,linepos=0;i<text_splits.nRegions;
//              linepos+=text_splits.split[i].lines,i++)
        if (vram_NEC98 < NEC98_ATTR_P0_OFF) {
                for (i=0,linecount=0;i<text_splits.nRegions;
                        linecount+=text_splits.split[i].lines,i++) {
                        if (( vram_NEC98<   // If the region contains new pos
                                ((text_splits.split[i].lines*OFFSET_PER_LINE)
                                +text_splits.split[i].addr )) &&(
                                ( vram_NEC98>=
                                text_splits.split[i].addr)) ){
//                              linepos+=(vram_NEC98-text_splits.split[i].addr)
//                                      /(OFFSET_PER_LINE);
                                linepos=(vram_NEC98-text_splits.split[i].addr)
                                        /(OFFSET_PER_LINE)+linecount;
                                colmnpos=((vram_NEC98-text_splits.split[i].addr)
                                        %(OFFSET_PER_LINE))/num;
                                if (curs_set == FALSE) {
                                        curs_set=TRUE;
                                        set_cur_x(colmnpos);
                                        set_cur_y(linepos);
                                        host_paint_cursor(colmnpos,linepos,*attr_NEC98);

                                }
                        }
//                      break;
                }
        }
//      if ( linepos>(unsigned)LINES_PER_SCREEN ) {
                                        // If exceeds display limit
//#ifdef DBG
//              DbgPrint("NEC98:KBCRT SetCursorPos(BadPos!!)\n",getAH());
//#endif

//              return;
//      }
//      set_cur_x(colmnpos);
//      set_cur_y(linepos);
//      host_paint_cursor(colmnpos,linepos,*attr_NEC98);
#else
        unsigned char param;
        outb(TGDC_WRITE_COMMAND,GDC_CSRW);
        param = (unsigned char)((getDX() >> 1)&0x00FF);
        outb(TGDC_WRITE_PARAMETER,param);
        param = (unsigned char)((getDX() >> 9)&0x001F);
        outb(TGDC_WRITE_PARAMETER,param);
#endif
}

GLOBAL void vd_NEC98_get_font IFN0(){       /* 14h(N) 1fh(H) Get font    */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT GetFont %#x\n",getAH());
#endif
}

GLOBAL void vd_NEC98_get_pen IFN0(){        /* 15h Get lightpen status   */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT GetLightPen %#x\n",getAH());
#endif
}

GLOBAL void vd_NEC98_init_textvram IFN0(){  /* 16h Initialize text vram  */
/* Function abstructions:                                            */
/*              Clear all vram area                                  */
/*              Force screen to refresh                              */
/* Inputs:      NONE                                                 */
/*              DH :    Blank attribute.                             */
/*              DL :    Blank character.                             */
/* Outputs:     NONE                                                 */
/*      all emulated registers should be protected.                  */
/* Localvariables:                                                   */
        char unsigned   *to;
        word    cnt;
#ifdef  DBG
        DbgPrint("NEC98:KBCRT InitTextVram %#x\n",getAH());
#endif
        cnt=0x3fe2;
        for ( to=NEC98_REGEN_START+NEC98_TEXT_P0_OFF
                        ;to<=NEC98_REGEN_END+NEC98_TEXT_P0_OFF
                        ; to +=2 ){
                if ( to>=NEC98_ATTR_P0_OFF ) {
                        if (to==cnt+NEC98_TEXT_P0_OFF)
                                cnt+=4;
                        else
                                to[0]=getDH();
                }
                else to[0]=getDL();
                to[1]=0;
        }
}

GLOBAL void vd_NEC98_start_beep IFN0(){     /* 17h Start beep sound      */
/* Function abstructions:                                            */
/*              Start beep sound                                     */
/* Inputs:      NONE                                                 */
/* Outputs:     NONE                                                 */
/*      all emulated registers should be protected.                  */
/* Localvariables:      NONE                                         */

#ifdef  DBG
        DbgPrint("NEC98:KBCRT StartBeep %#x\n",getAH());
#endif
        set_beep_on(TRUE);
        set_beep_changed(TRUE);
}

GLOBAL void vd_NEC98_stop_beep IFN0(){      /* 18h Stop beep sound       */
/* Function abstructions:                                            */
/*              Stop beep sound                                      */
/* Inputs:      NONE                                                 */
/* Outputs:     NONE                                                 */
/*      all emulated registers should be protected.                  */
/* Localvariables:      NONE                                         */

#ifdef  DBG
        DbgPrint("NEC98:KBCRT StopBeep %#x\n",getAH());
#endif
        set_beep_on(FALSE);
        set_beep_changed(TRUE);
}

GLOBAL void vd_NEC98_init_pen IFN0(){       /* 19h Initialize lightpen   */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT InitLightpen %#x\n",getAH());
#endif
}

GLOBAL void vd_NEC98_set_font IFN0(){       /* 1ah(N) 20h(H) Set user font   */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetUserFont %#x\n",getAH());
#endif
}

GLOBAL void vd_NEC98_set_kcgmode IFN0(){    /* 1bh Set KCG access mode   */
/* Function abstructions:                                            */
/*              Set KCG access mode                                  */
/* Inputs:      NONE                                                 */
/*              AL      :       ACCESS MODE                          */
/*              0       :       KCG     Code Access                  */
/*              1       :       KCG Dot  Access                      */
/* Outputs:     NONE                                                 */
/*      all other emulated registers should be protected.            */
/* Localvariables:                                                   */
        int     kcgm;
#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetKCGMode %#x\n",getAH());
#endif
        if (getAL() == 1) {
                if (HIRESO_MODE){
                        kcgm=sas_hw_at(BIOS_NEC98_CRT_FLAG);
                        sas_store(BIOS_NEC98_CRT_FLAG,(kcgm| 0x08));
                } else {
                        kcgm=sas_hw_at(BIOS_NEC98_CR_STS_FLAG);
                        sas_store(BIOS_NEC98_CR_STS_FLAG,(kcgm | 0x08));
                }
        } else {
                if (getAL() == 0) {
                        if (HIRESO_MODE){
                                kcgm=sas_hw_at(BIOS_NEC98_CRT_FLAG);
                                sas_store(BIOS_NEC98_CRT_FLAG,(kcgm & 0xF7));
                        } else {
                                kcgm=sas_hw_at(BIOS_NEC98_CR_STS_FLAG);
                                sas_store(BIOS_NEC98_CR_STS_FLAG,(kcgm & 0xF7));
                        }
                }
        }
}

GLOBAL void vd_NEC98_init_crt IFN0(){       /* 1ch Initialize CRT /H     */
/* Function abstructions:       Initialize CRT H-mode only           */
/* Inputs:      NONE                                                 */
/*              AL      :       Cursor Control Info.                 */
/*              b7      :       Blink           0=Non-Brink 1=Brink  */
/*              b6      :       Disp.           0=Hide  1:Show       */
/*              b5      :       KCG code        0=Code  1:Dot        */
/*              b4-b0:  Blink Rate      01h-1Fh (00h=0Ch Default)    */
/*              DH      :       Cursor Start Line                    */
/*              DL      :       Cursor End   Line                    */
/* Outputs:     NONE                                                 */
/*      all emulated registers should be protected.                  */
/* Localvariables:                                                   */
        unsigned        saveAX;
#ifdef  DBG
        DbgPrint("NEC98:KBCRT InitCRT %#x\n",getAH());
#endif
        video_init();
        saveAX=getAX();
        if (getAX() & 0x40) {
                vd_NEC98_show_cursor();
        } else {
                vd_NEC98_hide_cursor();
        }
        if (getAX() & 0x20) {
                setAL(1);
        } else {
                setAL(0);
        }
        vd_NEC98_set_kcgmode();
        setAX(saveAX);
        vd_NEC98_set_cursor_type();
        setAX(saveAX);
}

GLOBAL void vd_NEC98_set_disp_width IFN0(){ /* 1dh Set Display Width /H  */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetDispWidth %#x\n",getAH());
#endif
}

GLOBAL void vd_NEC98_set_cursor_type IFN0(){/* 1eh Set Cursor Type   /H  */
/* Function abstructions:                                            */
/*              Set Cursor Type  H-mode only                         */
/* Inputs:      NONE                                                 */
/*              AL      :       Cursor Control Info.                 */
/*              b7      :       Blink           0=Non-Brink     1=Brink  */
/*              b4-b0   :       Blink Rate      01h-1Fh (00h=0Ch Default)  */
/*              DH      :       Cursor Start Line                    */
/*              DL      :       Cursor End   Line                    */
/* Outputs:     NONE                                                 */
/*      all emulated registers should be protected.                  */
/* Localvariables:                                                   */
        unsigned        saveAX;
#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetCursorType %#x\n",getAH());
#endif
        saveAX=getAX();
        if (getAX() & 0x20) {
                setAL(1);
        } else {
                setAL(0);
        }
        vd_NEC98_set_cursor();
        set_cursor_start(getDH());
        set_cursor_height(getDL()-getDH());
        host_cursor_size_changed(getDH(),getDL());
        setAX(saveAX);
}

GLOBAL void vd_NEC98_get_mswitch IFN0(){/* 21h Get Memory Switch /H      */
/* Function abstructions:                                            */
/*              Get Memory Switch       H-mode only                  */
/* Inputs:      NONE                                                 */
/*              AL      :       Switch Number(1-8)                   */
/* Outputs:     NONE                                                 */
/*              DL      :       Switch Info.                         */
/*      all emulated registers should be protected.                  */
/* Localvariables:      NONE                                         */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT GetMemSwitch %#x\n",getAH());
#endif
        if (getAL() > 0 && getAL() < 9) {
                setDL( sas_hw_at(0xE3FDE+4*getAL()) );
        } else {
#ifdef  DBG
        DbgPrint("NEC98:KBCRT GetMemorySwitch(BadNum!!)\n",getAH());
#endif
        }
}

GLOBAL void vd_NEC98_set_mswitch IFN0(){/* 22h Set Memory Switch /H      */
/* Function abstructions:                                            */
/*              Set Memory Switch       H-mode only                  */
/* Inputs:      NONE                                                 */
/*              AL      :       Switch Number(1-8)                   */
/*              DL      :       Switch Info.                         */
/* Outputs:     NONE                                                 */
/*      all emulated registers should be protected.                  */
/* Localvariables:      NONE                                         */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetMemSwitch %#x\n",getAH());
#endif
        if (getAL() > 0 && getAL() < 9) {
                sas_store(0xE3FDE+4*getAL(),getDL());
        } else {
#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetMemorySwitch(BadNum!!)\n",getAH());
#endif
        }
}

GLOBAL void vd_NEC98_set_beep_rate IFN0(){  /* 23h Set Beep rate /H      */
/* Function abstructions:                                            */
/*              Set Beep Sound Frequency H-mode only                 */
/* Inputs:      NONE                                                 */
/*              DX      :       Frequency of BEEP Sound              */
/* Outputs:     NONE                                                 */
/*      all emulated registers should be protected.                  */
/* Localvariables:      NONE                                         */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetBeepRate %#x\n",getAH());
#endif
        if (getDX() > 0x19 && getDX() < 0x8001) {
                set_beep_rate(getDX());
        } else {
#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetBeepRate(BadRate!!)\n",getAH());
#endif
        }
}

GLOBAL void vd_NEC98_set_beep_time IFN0(){/* 24h Set Beep Time       /H  */
/* Function abstructions:                                            */
/*              Set Beep Sound Duration H-mode only                  */
/* Inputs:      NONE                                                 */
/*              CX      :       Duration  of BEEP Sound              */
/*              DX      :       Frequency of BEEP Sound              */
/* Outputs:     NONE                                                 */
/*       all emulated registers should be protected.                 */
/* Localvariables:      NONE                                         */
#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetBeepTime & Ring %#x\n",getAH());
#endif
        if (getCX() > 0) {
                if (getDX() > 0x19 && getDX() < 0x8001) {
                        set_beep_rate(getDX());
                        nt_set_beep((DWORD) getDX(),(DWORD) (getCX()*10));
                } else {
#ifdef  DBG
        DbgPrint("NEC98:KBCRT SetBeepTime(BadRate!!)\n",getAH());
#endif
                }
        }
}

LOCAL void vd_NEC98_dummy IFN0(){           /* dummy for NEC98            */
#ifdef  DBG
        DbgPrint("NEC98:Illegal KBCRT call %#x\n",getAH());
#endif
}

#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\biosbop.inc ===
bop     MACRO   callid
        db      0c4h,0c4h,callid
        endm

BIOS_PRINTER_IO equ     17h
PRNIO_EXECUTE   equ     -1
PRNIO_FLUSH     equ     0
PRNIO_OPEN      equ     1
PRNIO_CLOSE     equ     2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\biosseg.inc ===
; BIOSSEG.INC
;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.


datagrp	group	Bios_Data,Bios_Data_Init


Bios_Data	segment	word public 'Bios_Data'
Bios_Data	ends

Bios_Data_Init	segment word public 'Bios_Data_Init'
Bios_Data_Init	ends

Filler		segment para public 'Filler'
Filler		ends

Bios_Code	segment word public 'Bios_Code'
Bios_Code	ends

Filler2		segment para public 'Filler2'
Filler2         ends

sysinitgrp group sysinitseg, SpcKbdSeg, SpcMseSeg, SpcEmmSeg

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

SpcKbdSeg       segment para public 'SoftpcKeyboard'
SpcKbdSeg       ends

SpcMseSeg       segment para public 'SoftpcMouse'
SpcMseSeg       ends

SpcEmmSeg       segment para public 'SoftpcEmm'
SpcEmmSeg       ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\v7_ports.c ===
#include "insignia.h"
#include "host_def.h"
/*[
======================================================================

				 SoftPC Revision 3.0

 Title:
		v7_ports.c

 Description:
		Code for the extended registers of the Video 7 VGA.
		Based on the V7 VGA Technical Reference Manual.

 Author:
		Phil Taylor

 Date:
		26 September 1990

 SccsID	"@(#)v7_ports.c	1.19 01/13/95 Copyright Insignia Solutions Ltd."

======================================================================
]*/


#ifdef V7VGA

#include "xt.h"
#include "gvi.h"
#include "gmi.h"
#include "ios.h"
#include "gfx_upd.h"
#include "debug.h"
#include "egacpu.h"
#include "egaports.h"
#include "egagraph.h"
#include "egaread.h"
#include "vgaports.h"


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_VGA.seg"
#endif


IMPORT	byte	crtc_0_7_protect;
IMPORT	byte	crtc_0_8_protect;
IMPORT	byte	crtc_9_b_protect;
IMPORT	byte	crtc_c_protect;

FORWARD void    draw_v7ptr();

GLOBAL ULONG fg_latches;
GLOBAL UTINY fg_bg_control;

GLOBAL	void	remove_v7ptr IPT0();

SAVED	word	curr_v7ptr_x;
SAVED	word	curr_v7ptr_y;

/*(
----------------------------------------------------------------------

Function:	
		vga_seq_extn_control( io_addr port, half_word value )

Purpose:
		To emulate writing to the Extensions Control Register.

Input:
		port	- the V7VGA I/O port (should always be 0x3c5)
		value	- the value to be written to the register

Output:
		The Extensions Control Register is set to the correct value.

----------------------------------------------------------------------
)*/

GLOBAL VOID
vga_seq_extn_control(port, value)
io_addr         port;
half_word       value;

{
#ifndef NEC_98
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"seq(6,%#x)\n",value);)
	note_entrance2("vga_seq_extn_control(%x,%x)", port, value);

	if (value == 0xea)
		sequencer.extensions_control.as_bfld.extension_enable = 1;
	else if (value == 0xae)
		sequencer.extensions_control.as_bfld.extension_enable = 0;
#endif  //NEC_98
}

GLOBAL VOID
v7_get_banks( rd_bank, wrt_bank )

UTINY *rd_bank;
UTINY *wrt_bank;

{
#ifndef NEC_98
	if( get_seq_chain4_mode() && get_chain4_mode() ) {
		set_v7_bank_for_seq_chain4( rd_bank, wrt_bank );
	}
	else {

	/*
	   1.4.92 MG
	   Note that we and off the top bit of the bank selects. This means
	   that accesses to the top 512k (which we don't have) get mapped into
	   the bottom 512k, rather than being thrown away. This prevents SEGVs
	   and saves complications in the write routines, but causes other
	   problems.

	   Further explanation is in draw_v7ptr() at the end of this file.
	*/

		*rd_bank=(extensions_controller.ram_bank_select.as_bfld.cpu_read_bank_select&1);
		*wrt_bank=(extensions_controller.ram_bank_select.as_bfld.cpu_write_bank_select&1);
	}
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		vga_extn_outb( io_addr port, half_word value )

Purpose:
		To emulate writing to the V7VGA Extension Registers

Input:
		port	- the V7VGA I/O port (should always be 0x3c5)
		value	- the value to be written to the register

Output:
		The Extension Registers are set to the correct value, and
		any other required actions are emulated.

----------------------------------------------------------------------
)*/

GLOBAL VOID
vga_extn_outb(port, value)
io_addr         port;
half_word       value;

{
#ifndef NEC_98
	half_word	old_value;

	note_entrance2("vga_extn_outb(%x,%x)", port, value);
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"seq ext (%#x,%#x)\n",
		sequencer.address.as.abyte,value);)

	switch (sequencer.address.as.abyte) {

		case 0x83:
			note_entrance0("attribute controller index");
			attribute_controller.address.as.abyte = value;
			break;
		case 0x94:
			note_entrance0("pointer pattern");
			extensions_controller.pointer_pattern = value;
			host_start_update ();
			(*clear_v7ptr)(curr_v7ptr_x, curr_v7ptr_y);
			draw_v7ptr();
			host_end_update ();
			break;
		case 0x9c:
			note_entrance0("pointer horiz position hi");
			extensions_controller.ptr_horiz_posn_hi.as.abyte = value;
			break;
		case 0x9d:
			note_entrance0("pointer horiz position lo");
			extensions_controller.ptr_horiz_posn_lo = value;
			break;
		case 0x9e:
			note_entrance0("pointer vert position hi");
			extensions_controller.ptr_vert_posn_hi.as.abyte = value;
			break;
		case 0x9f:
			note_entrance0("pointer vert position lo");
			extensions_controller.ptr_vert_posn_lo = value;
			host_start_update ();
			(*clear_v7ptr)(curr_v7ptr_x, curr_v7ptr_y);
			draw_v7ptr();
			host_end_update ();
			break;
		case 0xa0:
			note_entrance0("graphics controller mem latch 0");
			/* Direct access to memory data latch 0 */
			put_latch0(value);
			break;
		case 0xa1:
			note_entrance0("graphics controller mem latch 1");
			/* Direct access to memory data latch 1 */
			put_latch1(value);
			break;
		case 0xa2:
			note_entrance0("graphics controller mem latch 2");
			/* Direct access to memory data latch 2 */
			put_latch2(value);
			break;
		case 0xa3:
			note_entrance0("graphics controller mem latch 3");
			/* Direct access to memory data latch 3 */
			put_latch3(value);
			break;
		case 0xa4:
			note_entrance0("clock select");
			extensions_controller.clock_select.as.abyte = value;
			/* Typically set to 0x10 for extended hi-res modes */
			break;
		case 0xa5:
			note_entrance0("cursor attributes");
			old_value=(half_word)extensions_controller.cursor_attrs.as.abyte;
			extensions_controller.cursor_attrs.as.abyte = value;

			/*
			   8.6.92 MG
			   We need to check that the pointer was disabled
			   before we redraw it when it is enabled. Otherwise
			   we can get old pointers left on the screen in
			   Windows.
			*/

			/* Not doing cursor mode stuff (whatever that means) */

                        if ((value&0x80) != (old_value&0x80)) {
				host_start_update ();
				if (value & 0x80) {
					/* Enable hardware graphics pointer */
					draw_v7ptr();
				}
				else {
					/* Disable hardware graphics pointer */
					(*clear_v7ptr)(curr_v7ptr_x, curr_v7ptr_y);
				}
				host_end_update ();
			}
			break;

		/*
		   31.3.92 MG Register c1 is an undocumented DAC control
		   register, bit 0 switches between 6 and 8 bit data in
		   the DAC.
		*/

		case 0xc1:
			extensions_controller.dac_control.as.abyte=value;
			if (extensions_controller.dac_control.as_bfld.dac_8_bits) {
				DAC_data_bits=8;
				DAC_data_mask=0xff;
			}
			else {
				DAC_data_bits=6;
				DAC_data_mask=0x3f;
			}
			break;
		case 0xea:
			note_entrance0("switch strobe");
			/* loads up switch readback with some CPU data lines */
			extensions_controller.switch_readback = 0xff;
			/* This is hard coded for the jumper/switch settings, and might not be right */
			break;
		case 0xeb:
			note_entrance0("emulation_control");
			extensions_controller.emulation_control.as.abyte = value;
			if (extensions_controller.emulation_control.as_bfld.write_prot_2)
				crtc_0_8_protect = TRUE;
			else
				crtc_0_8_protect = FALSE;
			if (extensions_controller.emulation_control.as_bfld.write_prot_1)
				crtc_9_b_protect = TRUE;
			else
				crtc_9_b_protect = FALSE;
			if (extensions_controller.emulation_control.as_bfld.write_prot_0)
				crtc_c_protect = TRUE;
			else
				crtc_c_protect = FALSE;
			break;
		case 0xec:
			note_entrance0("foreground latch 0");
			extensions_controller.foreground_latch_0 = value;
			SET_FG_LATCH( 0, value );
			break;
		case 0xed:
			note_entrance0("foreground latch 1");
			extensions_controller.foreground_latch_1 = value;
			SET_FG_LATCH( 1, value );
			break;
		case 0xee:
			note_entrance0("foreground latch 2");
			extensions_controller.foreground_latch_2 = value;
			SET_FG_LATCH( 2, value );
			break;
		case 0xef:
			note_entrance0("foreground latch 3");
			extensions_controller.foreground_latch_3 = value;
			SET_FG_LATCH( 3, value );
			break;
		case 0xf0:
			note_entrance0("fast foreground latch load");
			switch (extensions_controller.fast_latch_load_state.as_bfld.fg_latch_load_state)
			{
				case 0:
					extensions_controller.foreground_latch_0 = value;
					extensions_controller.fast_latch_load_state.as_bfld.fg_latch_load_state = 1;
					SET_FG_LATCH( 0, value );
					break;
				case 1:
					extensions_controller.foreground_latch_1 = value;
					extensions_controller.fast_latch_load_state.as_bfld.fg_latch_load_state = 2;
					SET_FG_LATCH( 1, value );
					break;
				case 2:
					extensions_controller.foreground_latch_2 = value;
					extensions_controller.fast_latch_load_state.as_bfld.fg_latch_load_state = 3;
					SET_FG_LATCH( 2, value );
					break;
				case 3:
					extensions_controller.foreground_latch_3 = value;
					extensions_controller.fast_latch_load_state.as_bfld.fg_latch_load_state = 0;
					SET_FG_LATCH( 3, value );
					break;
			}
			break;
		case 0xf1:
			note_entrance0("fast latch load state");
			extensions_controller.fast_latch_load_state.as.abyte = value;
			break;
		case 0xf2:
			note_entrance0("fast background latch load");
			switch (extensions_controller.fast_latch_load_state.as_bfld.bg_latch_load_state)
			{
				case 0:
					put_latch0(value);
					extensions_controller.fast_latch_load_state.as_bfld.bg_latch_load_state = 1;
					break;
				case 1:
					put_latch1(value);
					extensions_controller.fast_latch_load_state.as_bfld.bg_latch_load_state = 2;
					break;
				case 2:
					put_latch2(value);
					extensions_controller.fast_latch_load_state.as_bfld.bg_latch_load_state = 3;
					break;
				case 3:
					put_latch3(value);
					extensions_controller.fast_latch_load_state.as_bfld.bg_latch_load_state = 0;
					break;
			}
			break;
		case 0xf3:
			note_entrance0("masked write control");
			extensions_controller.masked_write_control.as.abyte = value;
			break;
		case 0xf4:
			note_entrance0("masked write mask");
			extensions_controller.masked_write_mask = value;
			break;
		case 0xf5:
			note_entrance0("foreground/background pattern");
			extensions_controller.fg_bg_pattern = value;
			break;
		case 0xf6:
			note_entrance0("1Mb RAM bank select");
			extensions_controller.ram_bank_select.as.abyte = value;
			update_banking();
			break;
		case 0xf7:
			note_entrance0("switch readback");
			extensions_controller.switch_readback = value;
			break;
		case 0xf8:
			note_entrance0("clock control");
			extensions_controller.clock_control.as.abyte = value;
			/* Hope we don't have to do anything here */
			break;
		case 0xf9:
			note_entrance0("page select");
			extensions_controller.page_select.as.abyte = value;
			update_banking();
			break;
		case 0xfa:
			note_entrance0("foreground color");
			extensions_controller.foreground_color.as.abyte = value;
			break;
		case 0xfb:
			note_entrance0("background color");
			extensions_controller.background_color.as.abyte = value;
			break;
		case 0xfc:
			note_entrance0("compatibility control");
			{
				BOOL now_seqchain4;
				BOOL now_seqchain;

				now_seqchain4 = get_seq_chain4_mode();
				now_seqchain = get_seq_chain_mode();
				extensions_controller.compatibility_control.as.abyte = value;
				set_seq_chain4_mode(extensions_controller.compatibility_control.as_bfld.sequential_chain4);
				set_seq_chain_mode(extensions_controller.compatibility_control.as_bfld.sequential_chain);
				if (get_chain4_mode() && (now_seqchain4 != (BOOL)get_seq_chain4_mode()))
				{
					/* do we need to change the read/write routines here?? */
					ega_read_routines_update();
					ega_write_routines_update( CHAINED );
				}
			}
			break;
		case 0xfd:
			note_entrance0("timing select");
			extensions_controller.timing_select.as.abyte = value;
			/* Used to select timing states for V-RAM hi-res modes */
			/* Hope we don't have to do anything here */
			break;
		case 0xfe:
			note_entrance0("foreground/background control");
			extensions_controller.fg_bg_control.as.abyte = value;
			fg_bg_control = value;
			ega_read_routines_update();
			ega_write_routines_update( WRITE_MODE );

			/***
			set_fg_bg_mode();
			***/
			break;
		case 0xff:
			note_entrance0("16-bit interface control");
			extensions_controller.interface_control.as.abyte = value;

			/***
			sort_out_memory_stuff();
			sort_out_interface_stuff();
			***/
			break;
		default:
			NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)
			        fprintf(trace_file,"Bad extensions index %x\n",
			        sequencer.address.as.abyte);)
			break;
	}
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		vga_extn_inb( io_addr port, half_word *value )

Purpose:
		To emulate reading from the V7VGA Extension Registers

Input:
		port	- the V7VGA I/O port (should always be 0x3c5)

Output:
		value	- the value read from the register
		Any other required actions are emulated.

----------------------------------------------------------------------
)*/

GLOBAL VOID
vga_extn_inb(port, value)
io_addr         port;
half_word       *value;
{
#ifndef NEC_98
	note_entrance1("vga_extn_inb(%x)", port);

	switch (sequencer.address.as.abyte) {

		case 0x83:
			*value = (half_word)attribute_controller.address.as.abyte;
			break;
		case 0x8e:
		case 0x8f:
			/* chip revision 3 */
			*value = 0x70;
			break;
		case 0x94:
			*value = extensions_controller.pointer_pattern;
			break;
		case 0x9c:
			*value = (half_word)extensions_controller.ptr_horiz_posn_hi.as.abyte;
			break;
		case 0x9d:
			*value = extensions_controller.ptr_horiz_posn_lo;
			break;
		case 0x9e:
			*value = (half_word)extensions_controller.ptr_vert_posn_hi.as.abyte;
			break;
		case 0x9f:
			*value = extensions_controller.ptr_vert_posn_lo;
			break;
		case 0xa0:
			/* Direct access to memory data latch 0 */
			*value = get_latch0;
			break;
		case 0xa1:
			/* Direct access to memory data latch 1 */
			*value = get_latch1;
			break;
		case 0xa2:
			/* Direct access to memory data latch 2 */
			*value = get_latch2;
			break;
		case 0xa3:
			/* Direct access to memory data latch 3 */
			*value = get_latch3;
			break;
		case 0xa4:
			*value = (half_word)extensions_controller.clock_select.as.abyte;
			break;
		case 0xa5:
			*value = extensions_controller.cursor_attrs.as.abyte & 0x89;
			break;

		/*
		   31.3.92 MG Register C1 controls 6/8 bit data in the DAC.
		*/

		case 0xc1:
			*value = (half_word)extensions_controller.dac_control.as.abyte;	
			break;
		case 0xeb:
			*value = (half_word)extensions_controller.emulation_control.as.abyte;
			break;
		case 0xec:
			*value = extensions_controller.foreground_latch_0;
			break;
		case 0xed:
			*value = extensions_controller.foreground_latch_1;
			break;
		case 0xee:
			*value = extensions_controller.foreground_latch_2;
			break;
		case 0xef:
			*value = extensions_controller.foreground_latch_3;
			break;
		case 0xf0:
			switch (extensions_controller.fast_latch_load_state.as_bfld.fg_latch_load_state)
			{
				case 0:
					*value = extensions_controller.foreground_latch_0;
					break;
				case 1:
					*value = extensions_controller.foreground_latch_1;
					break;
				case 2:
					*value = extensions_controller.foreground_latch_2;
					break;
				case 3:
					*value = extensions_controller.foreground_latch_3;
					break;
			}
			extensions_controller.fast_latch_load_state.as_bfld.fg_latch_load_state = 0;
			break;
		case 0xf1:
			*value = (half_word)extensions_controller.fast_latch_load_state.as.abyte;
			break;
		case 0xf2:
			switch (extensions_controller.fast_latch_load_state.as_bfld.bg_latch_load_state)
			{
				case 0:
					*value = get_latch0;
					break;
				case 1:
					*value = get_latch1;
					break;
				case 2:
					*value = get_latch2;
					break;
				case 3:
					*value = get_latch3;
					break;
			}
			extensions_controller.fast_latch_load_state.as_bfld.bg_latch_load_state = 0;
			break;
		case 0xf3:
			*value = extensions_controller.masked_write_control.as.abyte & 3;
			break;
		case 0xf4:
			*value = extensions_controller.masked_write_mask;
			break;
		case 0xf5:
			*value = extensions_controller.fg_bg_pattern;
			break;
		case 0xf6:
			*value = (half_word)extensions_controller.ram_bank_select.as.abyte;
			break;
		case 0xf7:
			*value = extensions_controller.switch_readback;
			break;
		case 0xf8:
			*value = (half_word)extensions_controller.clock_control.as.abyte;
			break;
		case 0xf9:
			*value = (half_word)extensions_controller.page_select.as_bfld.extended_page_select;
			break;
		case 0xfa:
			*value = (half_word)extensions_controller.foreground_color.as.abyte;
			break;
		case 0xfb:
			*value = (half_word)extensions_controller.background_color.as.abyte;
			break;
		case 0xfc:
			*value = (half_word)extensions_controller.compatibility_control.as.abyte;
			break;
		case 0xfd:
			*value = (half_word)extensions_controller.timing_select.as.abyte;
			break;
		case 0xfe:
			*value = extensions_controller.fg_bg_control.as.abyte & 0xe;
			break;
		case 0xff:
			*value = (half_word)extensions_controller.interface_control.as.abyte;
			break;
		default:
			NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)
			        fprintf(trace_file,"Bad extensions index %x\n",
			        sequencer.address.as.abyte);)

		/* 31.3.92 MG This used to return 0xFF, but a real card
		   returns zero. */

			*value = 0;
			break;

	}
	note_entrance1("returning %x",*value);
#endif //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		draw_v7ptr()

Purpose:
		To emulate the V7 hardware pointer on the screen.

Input:
		None.

Output:
		The pointer is displayed on the screen.

----------------------------------------------------------------------
)*/

GLOBAL VOID
draw_v7ptr()
{
#ifndef NEC_98
	sys_addr pattern;

	if (extensions_controller.cursor_attrs.as_bfld.pointer_enable)
	{
		curr_v7ptr_x = extensions_controller.ptr_horiz_posn_lo +
			(extensions_controller.ptr_horiz_posn_hi.as_bfld.ptr_horiz_position << 8);


		if (get_seq_chain4_mode() && get_chain4_mode())
		{
			/*
			 * In the extended 256 col modes we seem to need to halve
			 * the x coordinate to get the pointer in the right place.
			 */
			curr_v7ptr_x >>= 1;
		}

		curr_v7ptr_y = extensions_controller.ptr_vert_posn_lo +
			(extensions_controller.ptr_vert_posn_hi.as_bfld.ptr_vert_position << 8);

		/*
		 * I have never seen the pointer bank select bits used, so
		 * this is a guess as to their meaning.
		 */

	/*
	   1.4.92 MG
	   Sadly, this guess isn't correct - the pointer_bank_select bits are
	   used to select which 256k bank the pointer data is read from. Now
	   we have a problem, as if a program writes the data to the third
	   bank then it actually ends up in the first because the bank
	   selection routines for memory access and off the top bit.

	   As a result, we also need to lose the top bit here. The correct
	   way to do this would be to either support nonexistent VGA memory
	   correctly, or to add another 512k to the memory we already use.
	
	   This fix is mainly to make Windows 3.1 work with its video-7
	   driver. It stuffs bytes into the last few k of the 1Mb space on
	   the video-7 to see if the memory exists. As we just map this
	   access to 512k lower, it thinks we have 1Mb of RAM rather than
	   512k, so puts the pointer at the top of the 1Mb.

	   Programs which call the VGA BIOS to determine the memory size
	   will not have this problem.
	*/

		pattern = (((extensions_controller.interface_control.as_bfld.pointer_bank_select&1) << 16)
			+ (0xc000 + (extensions_controller.pointer_pattern << 6))) << 2;

		(*paint_v7ptr)(pattern, curr_v7ptr_x, curr_v7ptr_y);
	}
#endif  //NEC_98
}

GLOBAL	VOID	remove_v7ptr IFN0()

{
	(*clear_v7ptr)(curr_v7ptr_x, curr_v7ptr_y);
}

GLOBAL	BOOL	v7ptr_between_lines IFN2(int, start_line, int, end_line)

{
	if (curr_v7ptr_y+32<start_line||curr_v7ptr_y>end_line)
		return FALSE;
	return TRUE;
}

#ifdef CPU_40_STYLE
/*
 * 4.0 video support moves v7 fg latch value from variable 'fg_latches'
 * int CPU variable accessed by interface fn to get/set all 4 bytes of
 * latches. Take byte index and value and update v7 latch via interface
 */
GLOBAL void set_v7_fg_latch_byte IFN2(IU8, index, IU8, value)
{
#ifndef NEC_98
	IU32 v7latch;

	/* get current value */
	v7latch = getVideov7_fg_latches();

	/* change byte 'index' to 'value */
	switch(index)
	{
	case 0:
		v7latch = (v7latch & 0xffffff00) | value;
		break;

	case 1:
		v7latch = (v7latch & 0xffff00ff) | (value << 8);
		break;

	case 2:
		v7latch = (v7latch & 0xff00ffff) | (value << 16);
		break;

	case 3:
		v7latch = (v7latch & 0x00ffffff) | (value << 24);
		break;

	default:
		always_trace1("set_v7_fg_latch_byte: index > 3 (%d)", index);
	}

	/* update v7 latches */
	setVideov7_fg_latches(v7latch);
#endif  //NEC_98
}
#endif	/* CPU_40_STYLE */

#endif /* V7VGA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\video_io.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title	: Bios Virtual Screen Interface
 *
 * Description	: Top level call to the video interface.  Uses a function
 *		  jump table to call the lower level functions.
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 * SCCS ID	: @(#)video_io.c	1.8 08/19/94
 *
 */


#ifndef NEC_98
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "VIDEO_BIOS.seg"
#endif
#endif // !NEC_98


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "bios.h"
#include "video.h"

#include "debug.h"
#include "idetect.h"

#if defined(NEC_98)
BOOL check_video_func(num)
unsigned num;
{            
        if (HIRESO_MODE) {
                if (num < 0x25) {
                        return(TRUE); 
                } else {
                        return(FALSE); 
                }
        } else {
                if (num < 0x1c) {
                        return(TRUE);
                } else {
                        return(FALSE); 
                }
        }
}

void video_io()
{
#if 0
// STREAM_IO codes are disabled.
#else  // 
#if defined(NTVDM) && !defined(X86GFX)
    if (stream_io_enabled && getAH()!= 0x0E &&	getAX() != 0x13FF)
	disable_stream_io();
#endif
#endif // zero
    /*
     * The type of operation is coded into the AH register.  Some PC code
     * calls AH functions that are for other more advanced cards - so we
     * ignore these.
     */

    assert1(check_video_func(getAH()),"Illegal VIO:%#x",getAH());
    if (check_video_func(getAH()))
    {
                IDLE_video();
                if (HIRESO_MODE) {
                        (*video_func_h[getAH()])();/* H-mode CRT BIOS */
                } else {
                        (*video_func_n[getAH()])();/* N-mode CRT BIOS */
                }
        }
}

#else  // !NEC_98

#define check_video_func(AH)	(AH < EGA_FUNC_SIZE)

void video_io()
{


#if defined(NTVDM) && !defined(X86GFX)
    if (stream_io_enabled && getAH()!= 0x0E &&  getAX() != 0x13FF)
        disable_stream_io();
#endif


    /*
     * The type of operation is coded into the AH register.  Some PC code
     * calls AH functions that are for other more advanced cards - so we
     * ignore these.
     */

    assert1(check_video_func(getAH()),"Illegal VIO:%#x",getAH());
    if (check_video_func(getAH()))
    {
	IDLE_video();
	(*video_func[getAH()])();
    }
}
#endif // !NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\v7_video.c ===
#include "insignia.h"
#include "host_def.h"
/*[
======================================================================

				 SoftPC Revision 3.0

 Title:
		v7_video.c

 Description:
		Code for the BIOS extended functions of the Video 7 VGA.

 Author:
		Phil Taylor

 Date:
		12 October 1990

 SccsID       "@(#)v7_video.c	1.21 07/04/95 Copyright Insignia Solutions Ltd."

======================================================================
]*/


#ifdef VGG
#ifdef V7VGA

#include "xt.h"
#include "gvi.h"
#include "gmi.h"
#include "gfx_upd.h"
#include "error.h"
#include "config.h"
#include "ios.h"
#include "bios.h"
#include "debug.h"
#include "egagraph.h"
#include "video.h"
#include "egavideo.h"
#include "egacpu.h"
#include "egaports.h"
#include "vgaports.h"
#include CpuH
#include "sas.h"

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "VIDEO_BIOS_VGA.seg"
#endif


IMPORT	struct	sequencer sequencer;
IMPORT	struct	crt_controller crt_controller;
IMPORT	struct	graphics_controller graphics_controller;
IMPORT	struct	attribute_controller attribute_controller;
IMPORT  IU8     Currently_emulated_video_mode;

IMPORT	void	low_set_mode();
IMPORT	void	load_font();
IMPORT	void	recalc_text();

FORWARD	void	v7vga_inquire();
FORWARD	void	v7vga_get_info();
FORWARD	void	v7_not_imp();
FORWARD	void	v7vga_get_mode_and_screen_res();
FORWARD	void	v7vga_extended_set_mode();
FORWARD	void	v7vga_select_autoswitch_mode();
FORWARD	void	v7vga_get_memory_configuration();

GLOBAL	void		(*v7vga_video_func[]) () =
{
	v7vga_inquire,
	v7vga_get_info,
	v7_not_imp,
	v7_not_imp,
	v7vga_get_mode_and_screen_res,
	v7vga_extended_set_mode,
	v7vga_select_autoswitch_mode,
	v7vga_get_memory_configuration
};

/*(
----------------------------------------------------------------------

Function:	
		v7vga_func_6f()

Purpose:
		Perform the int 10 extended BIOS function 6F

Input:
		None

Output:
		If invalid subfunction, AH = 2

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7vga_func_6f()
{
#ifndef NEC_98
	byte al;

	note_entrance0("v7vga_func_6f");
	al = getAL();
	if (al >= 0 && al < 8)
		(*v7vga_video_func[al])();
	else
		setAH(2);
		/* setCF(1) ?? */
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		v7vga_inquire()

Purpose:
		Perform the int 10 extended BIOS function 6F - Subfunction 0

Input:
		None

Output:
		BX is set to 'V7' (indicates extensions are present)

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7vga_inquire()
{
#ifndef NEC_98
	note_entrance0("v7vga_inquire");

	setAX(0x6f6f);
	setBX(0x5637);
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		v7vga_get_info()

Purpose:
		Perform the int 10 extended BIOS function 6F - Subfunction 1

Input:
		None

Output:
		AL = reserved
		AH = status register information

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7vga_get_info()
{
#ifndef NEC_98
	note_entrance0("v7vga_get_info");

	/* Reserved */
	setAL(0x10); /* This is what our V7VGA puts there */
	/* Status register information */
	setAH(0x04); /* Bit 5 = 0 -> colour. Bit 4 = 0 -> hi-res. Bit 0 = 0 -> display enabled. */
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		v7_not_imp()

Purpose:
		Emulate the unimplemented int 10 extended BIOS functions 6F - Subfunctions 2 & 3

Input:
		None

Output:
		None

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7_not_imp()
{
	note_entrance0("v7_not_imp");
}

/*(
----------------------------------------------------------------------

Function:	
		v7vga_get_mode_and_screen_res()

Purpose:
		Perform the int 10 extended BIOS function 6F - Subfunction 4

Input:
		None

Output:
		AL = current video mode
		BX = horizontal columns/pixels (text/graphics)
		CX = vertical   rows/pixels    (text/graphics)

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7vga_get_mode_and_screen_res()
{
#ifndef NEC_98
	half_word video_mode;

	note_entrance0("v7vga_get_mode_and_screen_res");

	video_mode = sas_hw_at_no_check(vd_video_mode);
	if ((video_mode == 1) && extensions_controller.foreground_latch_1)
		video_mode = extensions_controller.foreground_latch_1;
	else if (video_mode > 0x13)
		video_mode += 0x4c;

	setAL(video_mode);

	if (alpha_num_mode())
	{
		setBX(sas_w_at_no_check(VID_COLS));
		setCX(sas_w_at_no_check(vd_rows_on_screen)+1);
	}
	else
	{
		setBX(get_chars_per_line()*get_char_width());
		if (sas_hw_at_no_check(vd_video_mode) > 0x10)
			setCX(get_screen_height()/get_pc_pix_height()/get_char_height());
		else
			setCX(get_screen_height()/get_pc_pix_height());
	}
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		v7vga_extended_set_mode()

Purpose:
		Perform the int 10 extended BIOS function 6F - Subfunction 5

Input:
		BL = mode value

Output:
		None

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7vga_extended_set_mode()
{
#ifndef NEC_98
	UTINY pag;
	sys_addr save_addr,font_addr;
	half_word temp_word;
	byte mode_byte;
	byte video_mode;
	ULONG font_offset;
	word clr_char;
#ifndef PROD
	trace("setting video mode", DUMP_REG);
#endif
	set_host_pix_height(1);
	set_banking( 0, 0 );

	if (is_bad_vid_mode(getBL()) && !is_v7vga_mode(getBL()))
		return;

	video_mode = getBL() & 0x7F; /* get rid of top bit - indicates clear or not */

	/*
	 * The method of storing an extended video mode according to a real BIOS is
	 * if it is an text mode then put 1 in the BIOS mode variable and store
	 * the video mode in the extensions foreground latch register 1 (Index EC).
	 * If it is a graphics mode then store (mode - 4C) in the mode variable.
	 */

	if (video_mode < 0x40)
	{
		sas_store_no_check(vd_video_mode, video_mode);
		extensions_controller.foreground_latch_1 = 0;
	}
	else if (video_mode < 0x46)
	{
		sas_store_no_check(vd_video_mode, 1);
		extensions_controller.foreground_latch_1 = video_mode;
	}
	else 
	{
		sas_store_no_check(vd_video_mode, video_mode - 0x4c);
	}

	Currently_emulated_video_mode = video_mode;

   	sas_store_no_check(ega_info, (sas_hw_at_no_check(ega_info) & 0x7F ) | (getBL() & 0x80)); /* update screen clear flag in ega_info */ 

	save_addr = follow_ptr(EGA_SAVEPTR);
	if(alpha_num_mode())
	{
		/* load_font will do the mode change for us */
		if (video_adapter == VGA)
		{
		    switch (get_VGA_lines())
		    {
			case S350:
				load_font(EGA_CGMN,256,0,0,14);
				break;
			case S400:
				switch (video_mode)
				{
					case 0x42:
					case 0x40:
					case 0x43:
					case 0x44:
					case 0x46:
						load_font(EGA_CGDDOT,256,0,0,8);
						if (video_mode == 0x42)
							set_host_pix_height(2);
						break;
					case 0x41:
					case 0x45:
						load_font(EGA_CGMN,256,0,0,14);
						set_host_pix_height(2);
						break;
					default:
						load_font(EGA_HIFONT,256,0,0,16);
				}
				break;
			default:
				load_font(EGA_CGDDOT,256,0,0,8);
		    }
		}
		else
		{
		    if(get_EGA_switches() & 1)
			load_font(EGA_CGMN,256,0,0,14);
		    else
			load_font(EGA_CGDDOT,256,0,0,8);
		}
		/* Now see if we have a nasty font to load */
		font_addr = follow_ptr(save_addr+ALPHA_FONT_OFFSET);
		if(font_addr != 0)
		{
			/* See if it applies to us */
			font_offset = 11;
			do
			{
				mode_byte = sas_hw_at_no_check(font_addr+font_offset);
				if (mode_byte == video_mode)
				{
					load_font(follow_ptr(font_addr+6),sas_w_at_no_check(font_addr+2),
						sas_w_at_no_check(font_addr+4), sas_hw_at_no_check(font_addr+1),
							sas_hw_at_no_check(font_addr));
					recalc_text(sas_hw_at_no_check(font_addr));
					if(sas_hw_at_no_check(font_addr+10) != 0xff)
						sas_store_no_check(vd_rows_on_screen, sas_hw_at_no_check(font_addr+10)-1);
					break;
				}
				font_offset++;
			} while (mode_byte != 0xff);
		}
	}
	else
	{
		/* graphics mode. No font load, so do mode change ourselves */
		low_set_mode(video_mode);
		/* Set up default graphics font */
		sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
		if(video_mode == 16)
			sas_storew_no_check(EGA_FONT_INT*4,EGA_CGMN_OFF);
		else
		    if (video_mode == 17 || video_mode == 18 || video_mode == 0x66 || video_mode == 0x67)
				sas_storew_no_check(EGA_FONT_INT*4,EGA_HIFONT_OFF);
		    else
				sas_storew_no_check(EGA_FONT_INT*4,EGA_CGDDOT_OFF);
		/* Now see if we have a nasty font to load */
		font_addr = follow_ptr(save_addr+GRAPH_FONT_OFFSET);
		if(font_addr != 0)
		{
		/* See if it applies to us */
			font_offset = 7;
			do
			{
				mode_byte = sas_hw_at_no_check(font_addr+font_offset);
				if (mode_byte == video_mode)
				{
					sas_store_no_check(vd_rows_on_screen, sas_hw_at_no_check(font_addr)-1);
					sas_store_no_check(ega_char_height, sas_hw_at_no_check(font_addr)+1);
					sas_move_bytes_forward(font_addr+3, 4*EGA_FONT_INT,4);
					break;
				}
				font_offset++;
			} while (mode_byte != 0xff);
		}
	}

    sas_store_no_check(vd_current_page, 0);
    sas_storew_no_check((sys_addr)VID_ADDR, 0);
    sas_storew_no_check((sys_addr)VID_INDEX, EGA_CRTC_INDEX);
/*
 * CGA bios fills this entry in 'vd_mode_table' with 'this is a bad mode'
 * value, so make one up for VGA - used in VGA bios disp_func
 */
	if(video_mode < 8)
		sas_store_no_check(vd_crt_mode, vd_mode_table[video_mode].mode_control_val);
    else
	if(video_mode < 0x10)
	    sas_store_no_check(vd_crt_mode, 0x29);
	else
	    sas_store_no_check(vd_crt_mode, 0x1e);
    if(video_mode == 6)
		sas_store_no_check(vd_crt_palette, 0x3f);
    else
		sas_store_no_check(vd_crt_palette, 0x30);

	for(pag=0; pag<8; pag++)
		sas_storew_no_check(VID_CURPOS + 2*pag, 0);
/* Clear screen */
    if(!get_EGA_no_clear())
    {
		if (video_mode >= 0x60)
			clr_char = vd_ext_graph_table[video_mode-0x60].clear_char;
		else if (video_mode >= 0x40)
			clr_char = vd_ext_text_table[video_mode-0x40].clear_char;
		else
			clr_char = vd_mode_table[video_mode].clear_char;
#ifdef REAL_VGA
   		sas_fillsw_16(video_pc_low_regen, clr_char,
				 	(video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#else
    	sas_fillsw(video_pc_low_regen, clr_char,
				 (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#endif
    }
    inb(EGA_IPSTAT1_REG,&temp_word);
    outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);	/* re-enable video */
#ifndef PROD
    trace("end of video set mode", DUMP_NONE);
#endif
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		v7vga_select_autoswitch_mode()

Purpose:
		Perform the int 10 extended BIOS function 6F - Subfunction 6

Input:
		BL = autoswitch mode select
		BH = enable/disable

Output:
		None

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7vga_select_autoswitch_mode()
{
#ifndef NEC_98
	note_entrance0("v7vga_select_autoswitch_mode");

/***
	I reckon we shouldn't support this
***/
	setAH(0x2);
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		v7vga_get_memory_configuration()

Purpose:
		Perform the int 10 extended BIOS function 6F - Subfunction 7

Input:
		None

Output:
		AL = 6Fh
		AH = 82h - 2 x 256K blocks of V-RAM video memory
		BH = 70h - chip revision 3
		BL = 70h - chip revision 3
		CX = 0

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7vga_get_memory_configuration()
{
#ifndef NEC_98
	note_entrance0("v7vga_get_memory_configuration");

	setAX(0x826f);
	setBX(0x7070);
	setCX(0x0);
#endif  //NEC_98
}

#endif /* V7VGA */
#endif /* VGG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\msequ.inc ===
ftoobig 	equ	80h
fbig		equ	40h
romstatus	equ	1
romread 	equ	2
romwrite	equ	3
romverify	equ	4
romformat	equ	5


rsinit	=	0a3h	;rs232 initialization
			;9600 baud:no parity:1 stop:8 bit word

lf	=	10	;line feed
cr	=	13	;carriage return
backsp	=	8	;backspace
brkadr	=	1bh * 4	;006c	1bh break vector address
timadr	=	1ch * 4	;0070	1ch timer interrupt
dskadr	=	1eh * 4	;address of ptr to disk parameters
sec9	=	522h	;address of disk parameters
headsettle=	sec9+9	;address of head settle time
normsettle=	15	;normal head settle
speedsettle=	0	;speed up settle time
initspot=	534h	;ibm wants 4 zeros here
akport	=	20h
eoi	=	20h

cmdlen	=	0	;length of this command
unit	=	1	;sub unit specifier
cmd	=	2	;command code
status	=	3	;status
media	=	13	;media descriptor
trans	=	14	;transfer address
count	=	18	;count of blocks or characters
start	=	20	;first block to transfer
extra	=	22	;usually a pointer to vol id for error 15
start_l =	26	; extended start sector (low)
start_h =	28	; extended start sector (high)


chrout	=	29h
maxerr	=	5
lstdrv	=	504h

bootbias	=	200h
notbusystatus	=	10000000b	; not busy
ackstatus	=	01000000b	; acknowledge (for what?)
nopaperstatus	=	00100000b	; no more paper
.selectedstatus	=	00010000b	; the printer said it was selected
ioerrstatus	=	00001000b	; some kinda error
reserved	=	00000110b	; nops
timeoutstatus	=	00000001b	; time out.
error_unknown_media = 7			; for use in build bpb call



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\msgroup.inc ===
tocode	macro
Bios_Data	ends
Bios_Code	segment
	assume	cs:Bios_Code
	endm

todata	macro
Bios_Code	ends
Bios_Data	segment
	assume	cs:Bios_Data
	endm

;align the segment on word boundary to allow for even alignment of data

Bios_Data	segment
	assume	cs:Bios_Data

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\msend.asm ===
page	,160
;
;----------------------------------------------------------------------------
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;
;----------------------------------------------------------------------------

;	Define end labels for each segment in
;	   IO.SYS.  Make the segments paragraph aligned
;	   to save the trouble of rounding up at run-time.
;
;	also defines a special segment called dos_load_seg which is
;	  used to figure out where to load MSDOS (after sysinit)

Bios_Data	segment	para public 'Bios_Data'
	assume	cs:Bios_Data
	public	BData_end
BData_end:
Bios_Data	ends

Bios_Code	segment para public 'Bios_Code'
	assume	cs:Bios_Code
	public	BCode_end
BCode_end:
Bios_Code       ends

sysinitseg      segment para public 'system_init'
	assume	cs:sysinitseg
sysinitseg     ends

SpcKbdSeg       segment para public 'SoftpcKeyboard'
        assume  cs:SpcKbdSeg
SpcKbdSeg      ends

SpcMseSeg       segment para public 'SoftpcMouse'
        assume  cs:SpcMseSeg
SpcMseSeg       ends

SpcEmmSeg       segment para public 'SoftpcEmm'
        assume  cs:SpcEmmSeg
        public  SI_end
SI_end:
SpcEmmSeg      ends


dos_load_seg    segment para public 'dos_load_seg'
dos_load_seg	ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\msint13.asm ===
page	,160
	title	MS-DOS BIOS int 2f handler
; 
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------

; THIS FILE SHOULD BE NAMED INT2f.ASM RATHER THAN INT13.ASM AS I HAVE RIPPED
; THE INT 13 SUPPORT. TO REDUCE CONFUSION WHEN PICKING FIXES FROM DOS 5.1
; THE NAME IS RETAINED AS IT IS.

	include version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

	include	msequ.inc
	include	biostruc.inc

        include msgroup.inc     ; establish Bios_Data segment
        include vint.inc

multMULT		equ	4ah
multMULTGETHMAPTR	equ	1
multMULTALLOCHMA	equ	2


Win386_RelTS	equ	80h
NT_WAIT_BOP	equ	5Ah

bop MACRO callid
    db 0c4h,0c4h,callid
endm

;SR;
; Include file for WIN386 support
;
	include win386.inc


	extrn	SysinitPresent:byte
	extrn	FreeHMAPtr:word
	extrn	MoveDOSIntoHMA:dword

;SR; 
;New variables for Win386 support
;
	extrn	IsWin386:byte
	extrn	Win386_SI:byte
	extrn	SI_Next:dword


; close data, open Bios_code segment

	tocode

	extrn	Bios_Data_Word:word

; Int 2f functions to support communication of external block device
; drivers with msdisk are not supported. It also does'nt support
; function 13h which replaces the int 13 vector.
;

	public	i2f_handler
i2f_handler proc far
	assume	ds:nothing,es:nothing

	cmp	ah,13h
	jz	i2f_iret
	cmp	ah,8
	jz	i2f_iret

;
;Check for WIN386 startup and return the BIOS instance data
;
	cmp	ah,MULTWIN386
	jz	win386call

	cmp	ah, multMULT
	jne	i2f_iret
	jmp	handle_multmult

i2f_iret:
        FIRET


;WIN386 startup stuff is done here. If starting up we set our WIN386 present
;flag and return instance data. If exiting, we reset the WIN386 present flag
;NOTE: We assume that the BIOS int 2fh is at the bottom of the chain.

win386call:
	push	ds
	mov	ds,cs:Bios_Data_Word
	assume	ds:Bios_Data

	cmp	al, Win386_Init		; is it win386 initializing?
	je	Win386Init
	cmp	al, Win386_Exit		; is it win386 exiting?
	je	Win386Exit
	cmp	al, Win386_RelTS	; is it app release timeslice call?
	jne	win_iret		; if not, continue int2f chain

	push	ax			; It's the idling case - call MS BOP A
	xor	ax,ax			; with AX = 0
	bop	NT_WAIT_BOP
	pop	ax
	xor	al, al
	jmp	short win_iret

Win386Exit:
	test	dx, 1			; is it win386 or win286 dos extender?
	jnz	win_iret		; if not win386, then continue
	and	[IsWin386], 0		; indicate that win386 is not present
	jmp	short win_iret

Win386Init:
	test	dx, 1			; is it win386 or win286 dos extender?
	jnz	win_iret		; if not win386, then continue

	or	[IsWin386], 1		; Indicate WIN386 present
	mov	word ptr [SI_Next], bx	; Hook our structure into chain
	mov	word ptr [SI_Next + 2], es
	mov	bx, offset Win386_SI	; point ES:BX to Win386_SI
	push	ds
	pop	es

win_iret:
	pop	ds
	assume 	ds:nothing
        jmp     i2f_iret                ;return back up the chain

handle_multmult:
	cmp	al, multMULTGETHMAPTR
	jne	try_2

	push	ds
	call	HMAPtr			; get offset of free HMA
	mov	bx, 0ffffh
	mov	es, bx			; seg of HMA
	mov	bx, di
	not	bx
	or	bx, bx
	jz	@f
	inc	bx
@@:
	pop	ds
	jmp	i2f_iret
try_2:
	cmp	al, multMULTALLOCHMA
	jne	try_3

	push	ds
	mov	di, 0ffffh		; assume not enough space
	mov	es, di
	call	HMAPtr			; get offset of free HMA
	assume	ds:Bios_Data
	cmp	di, 0ffffh
	je	InsuffHMA		
	neg	di			; free space in HMA
	cmp	bx, di
	jbe	@f
	mov	di, 0ffffh
	jmp	short InsuffHMA
@@:
	mov	di, FreeHMAPtr
	add	bx, 15
	and	bx, 0fff0h
	add	FreeHMAPtr, bx		; update the free pointer
	jnz	InsuffHMA
	mov	FreeHMAPtr, 0ffffh	; no more HMA if we have wrapped
InsuffHMA:
	pop	ds
	assume	ds:nothing
	jmp	i2f_iret
try_3:
	jmp	i2f_iret
i2f_handler endp

;
;--------------------------------------------------------------------------
;
; procedure : HMAPtr
;
;		Gets the offset of the free HMA area ( with respect to
;							seg ffff )
;		If DOS has not moved high, tries to move DOS high.
;		In the course of doing this, it will allocate all the HMA
;		and set the FreeHMAPtr to past the end of the BIOS and 
;		DOS code.  The call to MoveDOSIntoHMA (which is a pointer)
;		enters the routine in sysinit1 called FTryToMoveDOSHi.
;
;	RETURNS : offset of free HMA in DI
;		  BIOS_DATA, seg in DS
;
;--------------------------------------------------------------------------
;
HMAPtr	proc	near
	mov	ds, Bios_Data_Word
	assume	ds:Bios_Data
	mov	di, FreeHMAPtr
	cmp	di, 0ffffh
	jne	@f
	cmp	SysinitPresent, 0
	je	@f
	call	MoveDOSIntoHMA
	mov	di, FreeHMAPtr
@@:
	ret
HMAPtr	endp


Bios_Code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\spcemm.asm ===
;
; spcemm.asm,
;
; 10-Dec-1992 Jonle , adapted from em_drvr.asm from Insignia solutions
;
; This code serves as a stub device driver for emm memory manager.
; Its sole purpose is for apps to be able to identify that an emm driver is
; loaded and that LIM services are available. This code is linked into the
; device driver chain contains a strategy, interrupt and device header
;
; The driver should only be loaded if emm memory is available
; from NTVDM.
;

BOP     MACRO   callid
        db      0c4h, 0c4h, callid
endm


;
; Request Header, for initialization
;
REQHEAD  STRUC
ReqLen   DB      ?               ; Length in bytes of request block
ReqUnit  DB      ?               ; Block Device unit number
ReqFunc  DB      ?               ; Type of request
ReqStat  DW      ?               ; Status Word
REQHEAD  ENDS

;
; Segment definitions for ntio.sys,
;
include biosseg.inc
include vint.inc

SpcEmmSeg    segment

        assume  cs:SpcEmmSeg,ds:nothing,es:nothing

;
; SpcEmmBeg - SpcEmmEnd
;
; Marks the resident code, anything outside of these markers
; is discarded after intialization
; 11-Dec-1992 Jonle
;

        public SpcEmmBeg

SpcEmmBeg    label  byte


;
; character device Header
; must be first in the .sys file
;
        dd      -1               ;pointer to next device driver
        dw      8000H            ;attribute (plain character device)
        dw      offset STRATEGY  ;pointer to device "strategy" routine
        dw      offset Interrupt ;pointer to device "interrupt" routine
        db      'EMMXXXX0'       ;8 byte name DO NOT CHANGE THE NAME

;
; Request Header address, saved here by strategy routine
;
pReqHdr   dd ?


;
; Device "strategy" entry point, save request header address
;
Strategy proc far
         mov     word ptr cs:pReqHdr, bx
         mov     word ptr cs:pReqHdr+2, es
         ret
Strategy endp


; EmmIsr  - int 67h isr
;
EmmIsr:          ; LIM Isr
        bop     67h
emmiret:
        FIRET

; ret trap for em function 'alter page map & call'
EmmRet:
        bop     68h
        jmp     emmiret



;----------------------------------------------------------------------
; 	Device "interrupt" entry point
;----------------------------------------------------------------------
Interrupt PROC FAR

        push    es
        push    di

        les     di, cs:pReqHdr           ; check for valid commands
        cmp     es:[di.ReqFunc], 0ah
        je      validcmd
        cmp     es:[di.ReqFunc], 0
        je      validcmd

        mov     ax, 8003h                ; we don't handle anything else
        jmp     short irptexit

validcmd:
        xor     ax,ax

irptexit:
        or      ax, 0100h          ;tell em we finished
        mov     es:[di.ReqStat],AX ;store status in request header

        pop    di
        pop    es
        ret

Interrupt ENDP

          public SpcEmmEnd
SpcEmmEnd label  byte

          public InitSpcEmm
;
; InitSpcEmm  Initializes Spc 32 bit memory manager
;             returns ax=0 for success
;
; Inputs:  ds is expected seg for drv code, cs is temporary sysinitseg
; Outputs: ax zero for success
;
InitSpcEmm  proc near

           ; BOP 66 - initialize LIM memory
           ; pass the address of bop 68 to the em manager
           ; in ds:dx and to return the number of em pages in BX
           ;
           ; NOTE: All EMM options come from pif file
           ;       There are NO command line options
           xor     bx, bx
           mov     dx, offset EmmRet
           bop     66h
           cmp     bx, 0ffffh     ;ffff means incorrect config (eg no 64K gap)
           je      fail
           cmp     bx, 0          ;check expanded memory is available
           je      fail

           ; set up IVT for INT 67h
           FCLI
           xor     ax, ax
           mov     es, ax
           mov     bx, offset EmmIsr
           mov     word ptr es:[67h*4], bx
           mov     word ptr es:[(67h*4)+2], ds
           FSTI

           ret
fail:
           mov ax, 0ffffh
           ret

InitSpcEmm endp

SpcEmmSeg  ends
           end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\devmark.inc ===
;structure, equtes for devmark for mem command.

devmark struc
devmark_id	  db	  0
devmark_seg	  dw	  0
devmark_size	  dw	  0
devmark_dum	  db	  3 dup (?)
devmark_filename  db	  8 dup (' ')
devmark ends

devmark_stk	equ	'S'
devmark_device	equ	'D'
devmark_ifs	equ	'I'
devmark_buf	equ	'B'
devmark_cds	equ	'L' ;lastdrive
devmark_files	equ	'F'
devmark_fcbs	equ	'X'
devmark_inst    equ     'T' ;used for sysinit base for install= command.

devmark_spc     equ     'Q' ;used for spckbd,spcmse

setbrkdone	equ	00000001b
for_devmark	equ	00000010b
not_for_devmark equ	11111101b
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\video\i386\ggdcdraw.asm ===
;ifdef  NEC98                    /*      #endif position = EOF */

;/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
;/*::::::::::::::::    NEC98 GGDC Graphic Draw Emulation  :::::::::::::::*/
;/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

;/*             add making start        NEC NEC98 930623 KBNES 1OA       */

.386p

include ks386.inc
include callconv.inc

_TEXT   SEGMENT DWORD USE32 PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING
_TEXT   ENDS

_DATA   SEGMENT  DWORD USE32 PUBLIC 'DATA'

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
write_one_word  label   dword
        dd      offset  draw_mov        ; replace

draw_one_pixel  label   dword
        dd      offset  draw_and        ; replace
        dd      offset  draw_or         ; replace

draw_one_word   label   dword
        dd      offset  draw_mov        ; replace
        dd      offset  draw_xor        ; complement
        dd      offset  draw_and        ; clear
        dd      offset  draw_or         ; set

draw_0_pixel    label   dword
        dd      offset  draw_and        ; replace
        dd      offset  draw_nop        ; complement
        dd      offset  draw_nop        ; clear
        dd      offset  draw_nop        ; set

draw_1_pixel    label   dword
        dd      offset  draw_or         ; replace
        dd      offset  draw_xor        ; complement
        dd      offset  draw_and        ; clear
        dd      offset  draw_or         ; set

ggdc_dir_func_pixel             label   dword
        dd      offset  pixel_dir_0
        dd      offset  pixel_dir_1
        dd      offset  pixel_dir_2
        dd      offset  pixel_dir_3
        dd      offset  pixel_dir_4
        dd      offset  pixel_dir_5
        dd      offset  pixel_dir_6
        dd      offset  pixel_dir_7

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
ggdc_dir_func_word              label   dword
        dd      offset  word_dir_0
        dd      offset  word_dir_1
        dd      offset  word_dir_2
        dd      offset  word_dir_3
        dd      offset  word_dir_4
        dd      offset  word_dir_5
        dd      offset  word_dir_6
        dd      offset  word_dir_7

ggdc_VRAM       dd      00000000H
ggdc_EAD        dd      00000000H
ggdc_PITCH      dd      00000000H
ggdc_DIR        dd      00000000H
ggdc_DC         dw      0000H
ggdc_D          dw      0000H
ggdc_D2         dw      0000H
ggdc_D1         dw      0000H
ggdc_DM         dw      0000H
ggdc_PTN        dw      0000H
ggdc_ZOOM       dw      0000H
ggdc_SL         dw      0000H
ggdc_WG         dw      0000H
ggdc_MASKGDC    dw      0000H
ggdc_TXT        label   byte
                db      00H
                db      00H
                db      00H
                db      00H
                db      00H
                db      00H
                db      00H
                db      00H

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
ggdc_MASKCPU    dw      0000H
ggdc_READ       dw      0000H
ZOOM1           dw      0000H
ZOOM2           dw      0000H
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
ggdc_read_back_EAD      dd      00000000H
ggdc_read_back_DAD      dw      0000H
ggdc_CSRR_1             db      00H
ggdc_CSRR_2             db      00H
ggdc_CSRR_3             db      00H
ggdc_CSRR_4             db      00H
ggdc_CSRR_5             db      00H
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
_DATA   ENDS


_TEXT   SEGMENT

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::       NEC98 GGDC Graphic DATA SET      ::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc _ggdc_mod_select,1

        push    ebp                     ; save ebp
        mov     ebp,esp                 ; set up stack frame
                                        ; ebp - n = local data area
                                        ; ebp + 0 = save ebp
                                        ; ebp + 4 = return address
        pushad
;       push    eax                     ; save eax reg
;       push    ebx                     ; save ebx reg

        xor     ebx,ebx                 ; ebx = 0
        mov     eax,[ebp+8]             ; parameter 1 = mod data address
        mov     bl,byte ptr[eax]        ; set mode
        mov     eax,draw_0_pixel[ebx*4] ; select logic
        mov     [draw_one_pixel][0],eax ; save 1dot 0bit
        mov     eax,draw_1_pixel[ebx*4] ; select logic
        mov     [draw_one_pixel][4],eax ; save 1dot 1bit
        mov     eax,draw_one_word[ebx*4]; select logic
        mov     [write_one_word],eax    ; save 1dot 1bit
;       pop     ebx                     ; restore ebx
;       pop     eax                     ; restore eax
        popad

        mov     esp,ebp                 ; restore stack frame
        pop     ebp                     ; restore ebp
        stdRET  _ggdc_mod_select

stdENDP  _ggdc_mod_select

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_send_c_asm,1

        push    ebp
        mov     ebp,esp
        pushad
        mov     esi,[ebp+8]                     ; c   data area
        mov     edi,offset ggdc_VRAM            ; asm data area
        mov     ecx,11                          ; move count
        rep     movsd                           ; 44 bytes data move

        mov     ecx,16                          ;
        mov     dx,[ggdc_MASKGDC]               ; GGDC mask data
@@:     rcr     dx,1                            ; reverse right <-> left
        rcl     ax,1                            ;
        loop    short   @b                      ;
        mov     [ggdc_MASKCPU],ax               ; use CPU drawing

        popad
        pop     ebp
        stdRET          _ggdc_send_c_asm

stdENDP _ggdc_send_c_asm
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_read_back,1

        push    ebp
        mov     ebp,esp
        pushad
        mov     esi,offset ggdc_read_back_EAD   ; copy back data
        mov     edi,[ebp+8]                     ; asm data area
        mov     ecx,11                          ; move count
        rep     movsb                           ; 11 bytes data move
        popad
        pop     ebp
        stdRET  _ggdc_read_back

stdENDP _ggdc_read_back

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::    NEC98 GGDC Graphic Draw LINE       :::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_drawing_line,0

        pushad                                  ; save all reg

        mov     esi,[ggdc_EAD]                  ; esi = ggdc start address
        mov     ebp,[ggdc_VRAM]                 ; ebp = vram start address
        mov     ebx,[ggdc_DIR]                  ; ebx = direction next
        mov     cx ,[ggdc_PTN]                  ; cx  = line pattern
        mov     dx ,[ggdc_D]                    ; dx  = vectw param D

draw_line_loop:
        movzx   eax,cx                          ; line pattern set
        and     eax,1                           ; select logic
        ror     cx,1                            ; next pattern
        mov     eax,draw_one_pixel[eax*4]       ; address set
        call    eax                             ; drawing 1 dot

        test    dx, 2000h                       ; D >= 0 ? check bit 13
        jz      short draw_line_pos             ; Yes jump!
        add     dx,[ggdc_D1]                    ; D = D + D1
        movzx   eax,bx                          ; ax = DIR
        test    al,1                            ; DIR LSB = 0 ?
        jnz     short draw_line_inc             ; No!  DIR = DIR + 1
        jmp     short draw_line_dir             ; Yes  DIR = DIR
draw_line_pos:
        add     dx,[ggdc_D2]                    ; D  = D + D2
        movzx   eax,bx                          ; ax = DIR
        test    al,1                            ; DIR LSB = 0 ?
        jnz     short draw_line_dir             ; No! DIR = DIR
draw_line_inc:
        inc     ax                              ; DIR = DIR + 1
        and     ax,7                            ; bound dir 0-->7

draw_line_dir:
        mov     eax,ggdc_dir_func_pixel[eax*4]  ; select dir function
        call    eax                             ; next pixel position

        dec     word ptr[ggdc_DC]               ; loop-1
        jnz     draw_line_loop                  ; 0 ?? next pixel

        call    save_ead_dad                    ; last position save
        popad                                   ; restore all reg
        stdRET _ggdc_drawing_line

stdENDP _ggdc_drawing_line


;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::    NEC98 GGDC Graphic Draw ARC        :::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_drawing_arc,0

        pushad                                  ; save all reg

        mov     esi,[ggdc_EAD]                  ; esi = ggdc start address
        mov     ebp,[ggdc_VRAM]                 ; ebp = vram start address
        mov     ebx,[ggdc_DIR]                  ; bx  = direction next
        mov     cx ,[ggdc_PTN]                  ; cx  = mask pattern
        mov     dx ,[ggdc_D]                    ; dx  = vectw param D

        inc     word ptr [ggdc_DM]              ; DM = DM + 1
draw_arc_loop:
        dec     word ptr [ggdc_DM]              ; DM = DM - 1
        jnz     short @f                        ; DM = 0 ? No! jump
        inc     word ptr [ggdc_DM]

        movzx   eax,cx                          ; ax is PTN
        and     ax,1                            ; pattern set
        mov     eax,draw_one_pixel[eax*4]       ; address set
        call    eax                             ; drawing 1 dot
@@:
        ror     cx,1                            ; next pattern
        add     dx,[ggdc_D1]                    ; D = D + D1
        test    dx,2000h                        ; D >= 0 ?
        jz      short draw_arc_pos              ; Yes! jump
        add     dx,[ggdc_D2]                    ; D  = D + D2
        sub     word ptr [ggdc_D2],2            ; D2 = D2 - 2
        mov     eax,ebx                         ; ax = DIR
        test    al,1                            ; DIR LSB = 0 ?
        jz      short draw_arc_inc              ; yes !
        jmp     short draw_arc_dir              ; no  !
draw_arc_pos:
        mov     eax,ebx                         ; ax = DIR
        test    al,1                            ; DIR LSB = 0 ?
        jz      short draw_arc_dir              ; Yes!
draw_arc_inc:
        inc     ax                              ; DIR = DIR + 1
        and     ax,7                            ; bound 7
draw_arc_dir:
        sub     word ptr[ggdc_D1],2             ; D1 = D1 - 2
        mov     eax,ggdc_dir_func_pixel[eax*4]  ; select dir function
        call    eax                             ; next position
        dec     [ggdc_DC]                       ; loop - 1
        jnz     draw_arc_loop                   ; 0 ?? next pixel

        call    save_ead_dad                    ; last position save
        popad                                   ; restore all reg
        stdRET          _ggdc_drawing_arc

stdENDP         _ggdc_drawing_arc

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::    NEC98 GGDC Graphic Draw RECT       :::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


cPublicProc     _ggdc_drawing_rect,0

        pushad

        mov     esi,[ggdc_EAD]                  ; esi = ggdc start address
        mov     ebp,[ggdc_VRAM]                 ; ebp = vram start address
        mov     ebx,[ggdc_DIR]                  ; bx  = direction next
        mov     cx ,[ggdc_PTN]                  ; cx  = mask pattern
        mov     dx ,[ggdc_D]                    ; dx  = vectw param D

draw_rect_loop:
        movzx   eax,cx                          ; ax is PTN
        and     eax,1                           ; set pattern
        mov     eax,draw_one_pixel[eax*4]       ; address set
        call    eax                             ; drawing 1 dot
        ror     cx,1                            ; next pattern

        movzx   ebx,bx                          ; ax = DIR
        mov     eax,ggdc_dir_func_pixel[ebx*4]  ; select dir function
        call    eax                             ; next position

        add     dx,[ggdc_D1]                    ; D = D+1
        test    dx,3fffh                        ; D=0 ?
        jnz     draw_rect_loop                  ; no! next

        test    word ptr[ggdc_DC],1             ; DC LSB = 0
        jnz     short @f                        ; No ! jump
        add     dx,[ggdc_D2]                    ; D = D + D2
        jmp     short draw_rect_dec             ;
@@:
        add     dx,[ggdc_DM]                    ;
draw_rect_dec:
        add     bx,2                            ; DIR = DIR + 2
        and     bx,7                            ; bound 7

        dec     [ggdc_DC]                       ; DC = DC - 1
        jnz     draw_rect_loop                  ; if DC!=0 loop

        call    save_ead_dad                    ; last position save
        popad                                   ; restore all reg
        stdRET          _ggdc_drawing_rect

stdENDP         _ggdc_drawing_rect


;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::    NEC98 GGDC Graphic Draw PIXEL    :::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_drawing_pixel

        pushad

        mov     esi,[ggdc_EAD]                  ; esi = ggdc start address
        mov     ebp,[ggdc_VRAM]                 ; ebp = vram start address
        mov     ebx,[ggdc_DIR]                  ; bx  = direction next
        mov     cx ,[ggdc_PTN]                  ; cx  = line pattern

        movzx   eax,cx                          ; set line pattern
        and     eax, 1                          ; pattern ?
        mov     eax,draw_one_pixel[eax*4]       ; select function
        call    eax                             ; draw pixel

        mov     eax,ggdc_dir_func_pixel[ebx*4]  ; select dir function
        call    eax                             ; next position

        call    save_ead_dad                    ; last position save
        popad                                   ; restore all reg
        stdRET          _ggdc_drawing_pixel

stdENDP         _ggdc_drawing_pixel


;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::    NEC98 GGDC Graphic Draw TEXT     :::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_drawing_text,0

        pushad
        mov     esi,[ggdc_EAD]                  ; esi  = ggdc start address
        mov     ebp,[ggdc_VRAM]                 ; ebp  = vram start address
        mov     dx, [ggdc_D]                    ; edx  = D
        mov     ax, [ggdc_ZOOM]                 ; copy zoom
        mov     [ZOOM1],ax                      ; ZW1
        xor     ebx,ebx                         ; TXT start data
        mov     ch,01h                          ; reset PS

text_2nd_dir_loop:

        mov     cl,ggdc_TXT[ebx]                ; get TXn
        inc     ebx                             ; point to next TX
        and     bl,7                            ; bound 7
        mov     ax,[ggdc_ZOOM]                  ; eax = zoom
        mov     [ZOOM2],ax                      ; ZW2 = ZW + 1

text_2nd_dir_zoom:                              ; D times (D2 times)
text_1st_dir_loop:

        mov     al,cl                           ; copy TXn
        test    al,ch                           ; get PS bit
        mov     eax,0                           ; PS bit 1 or 0 ?
        jz      short @f                        ; 0 : EAX = 0
        inc     eax                             ; 1 : EAX = 1
@@:
        mov     eax,draw_one_pixel[eax*4]       ; select function
        call    eax                             ; drawing 1 dot

        dec     word ptr[ZOOM1]                 ; ZW1 = ZW1 - 1
        jnz     short text_1st_zoom_skip        ; ZW1 = 0 ? No!
        mov     ax,[ggdc_ZOOM]                  ; ax  = ZW + 1
        mov     [ZOOM1],ax                      ; ZW1 = ZW + 1
        add     dx,[ggdc_D1]                    ; D = D + D1

        test    dx,3fffh                        ; D = 0 ?
        jz      short text_1st_dir_loop_exit    ; Yes!

        rol     ch, 1                           ; ROL(PS)
        test    word ptr[ggdc_DM],1             ; if LSB(DM)
        jnz     short text_1st_zoom_skip        ;   1 : ROL(PS)
        ror     ch, 2                           ;   0 : ROR(PS)

text_1st_zoom_skip:
        mov     eax,[ggdc_DIR]                  ; get DIR
        mov     eax,ggdc_dir_func_pixel[eax*4]  ; select dir function
        call    eax                             ; calculate next dot address
        jmp     short text_1st_dir_loop         ; while D != 0

text_1st_dir_loop_exit:
        mov     eax,[ggdc_DIR]                  ; get DIR' = DIR
        inc     ax                              ; DIR' = DIR' + 1
        test    word ptr[ggdc_SL],1             ; SL bit check ?
        jnz     short @f                        ;   1 :  DIR' = DIR' + 0
        inc     ax                              ;   0 :  DIR' = DIR' + 1
@@:
        test    word ptr[ggdc_DM],1             ; if LSB(DM)
        jnz     short @f                        ;   1 :  DIR' = DIR' + 0
        add     ax, 4                           ;   0 :  DIR' = DIR' + 4
@@:
        and     eax, 7                          ; normalize DIR'
        mov     eax,ggdc_dir_func_pixel[eax*4]  ; select dir function
        call    eax                             ; calculate next scanline address
        add     [ggdc_DIR],4                    ; DIR = DIR + 4
        and     [ggdc_DIR],7                    ; normalize DIR

        mov     dx,[ggdc_D2]                    ;
        dec     word ptr[ggdc_DM]               ; DM = DM - 1
        dec     word ptr[ZOOM2]                 ; ZOOM2 - 1
        jnz     text_2nd_dir_zoom               ; ZOOM2 != 0

        dec     word ptr[ggdc_DC]               ; DC = DC - 1
        jnz     text_2nd_dir_loop               ; DC != 0

        call    save_ead_dad                    ; last position save
        popad                                   ; restore all reg
        stdRET          _ggdc_drawing_text

stdENDP         _ggdc_drawing_text

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::    NEC98 GGDC Graphic Draw WRITE    :::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_writing,1

        push    ebp
        mov     ebp,esp
        pushad

        mov     ebx,[ebp+8]                     ; output data address
        mov     bx,word ptr[ebx]                ; output data

        mov     esi,[ggdc_EAD]                  ; esi = ggdc start address
        mov     ebp,[ggdc_VRAM]                 ; ebp = vram start address
        mov     edx,[ggdc_DIR]                  ; dx  = direction

        test    [ggdc_WG],1                     ; WG bit on ?
        jnz     short write_text_mode           ;  1: TEXT  mode
                                                ;  0: GRAPH mode
write_graph_mode:
        test    bx,1                            ; check LSB of output data
        jz      short @f                        ;
        mov     eax,[write_one_word]            ;
        call    eax                             ; drawing 1 pixel
@@:
        mov     eax,ggdc_dir_func_pixel[edx*4]  ; select dir function
        call    eax                             ; calculate next dot address
        jmp     short write_end                 ;

write_text_mode:
        mov     ecx,16                          ; change out data
@@:     rcr     bx,1                            ;
        rcl     ax,1                            ; left bit <-> right bit
        loop    @b                              ;
        mov     bx,[ggdc_MASKCPU]               ; save mask data
        and     ax,bx                           ; mask & out data
        mov     [ggdc_MASKCPU],ax               ; ax = mask data

        mov     eax,[write_one_word]            ;
        call    eax                             ; drawing 1 word
        mov     eax,ggdc_dir_func_word[edx*4]   ; select dir function
        call    eax                             ; calculate next dot address

        mov     [ggdc_MASKCPU],bx               ; resrtore dAD/MASK
write_end:
        call    save_ead_dad                    ; last position save
        popad                                   ;
        pop     ebp                             ;
        stdRET          _ggdc_writing

stdENDP         _ggdc_writing

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::    NEC98 GGDC Graphic Draw READ     :::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_reading,1

        push    ebp
        mov     ebp,esp
        pushad

        mov     ebx,[ebp+8]                     ; return data address
        push    ebx                             ; save it
        mov     esi,[ggdc_EAD]                  ; esi = ggdc start address
        mov     ebp,[ggdc_VRAM]                 ; ebp = vram start address
        mov     edx,[ggdc_DIR]                  ; dx  = direction

        mov     edi,esi                         ; copy ggdc address
        and     edi,0000ffffH                   ; recalc NEC98 vram address bound
        mov     ax,[ebp+edi*2]                  ; read data
        xchg    ah,al                           ; high <-> low

        mov     ecx, 16
@@:     rcr     ax, 1                           ; reverse bits
        rcl     bx, 1                           ; left to right
        loop    short @b                        ; do 16 times
        mov     [ggdc_READ],bx                  ; save data

        test    [ggdc_WG],1                     ; WG check
        jnz     short read_text_mode            ;  1: TEXT mode
                                                ;  0: GRAPHIC mode
read_graph_mode:
        mov     eax,ggdc_dir_func_pixel[edx*4]  ; select dir function
        call    eax                             ; calculate next dot address
        jmp     short read_end

read_text_mode:
        mov     eax,ggdc_dir_func_word[edx*4]   ; select dir function
        call    eax                             ; calculate next dot address

read_end:
        mov     ax,[ggdc_READ]                  ; copy back from tmp
        pop     ebx                             ; data address
        mov     word ptr[ebx],ax                ; return

        call    save_ead_dad                    ; last position save
        popad
        pop     ebp
        stdRET  _ggdc_reading

stdENDP         _ggdc_reading

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
save_ead_dad:

        mov     eax,esi                 ; Last Ead address
        and     eax,0003FFFFH           ; bound GGDC memory area
        mov     [ggdc_read_back_EAD],eax;
        mov     [ggdc_CSRR_1],al        ; return data1
        shr     eax,8                   ;
        mov     [ggdc_CSRR_2],al        ; return data2
        shr     eax,8                   ;
        mov     [ggdc_CSRR_3],al        ; return data3
        mov     ecx,16                  ;
        mov     dx,[ggdc_MASKCPU]       ; GGDC mask data
@@:     rcr     dx,1                    ; reverse right <-> left
        rcl     ax,1                    ;
        loop    short   @b              ;
        mov     [ggdc_read_back_DAD],ax ; use GDC drawing
        mov     [ggdc_CSRR_4],al        ; return data4
        mov     [ggdc_CSRR_5],ah        ; return data5
        ret

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; draw_and                                                              ;
;       input:                                                          ;
;               esi = ggdc address                                      ;
;               ebp = virtual vram start address                        ;
;       destory:                                                        ;
;               eax,edi,flag                                            ;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

draw_and:
        public  draw_and

        mov     ax,[ggdc_MASKCPU]       ; set
        xchg    ah,al                   ; change High <-> Low
        not     ax                      ; not
        mov     edi,esi                 ; copy ggdc address
        and     edi,0000ffffH           ; recalc NEC98 vram address bound
        and     [ebp+edi*2],ax          ; draw pixel
        ret                             ; return

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; draw_or                                                               ;
;       input:                                                          ;
;               esi = ggdc address                                      ;
;               ebp = virtual vram start address                        ;
;       destory:                                                        ;
;               eax,edi,flag                                            ;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

draw_or:
        public  draw_or

        mov     ax,[ggdc_MASKCPU]       ; set
        xchg    ah,al                   ; change High <-> Low
        mov     edi,esi                 ; copy ggdc address
        and     edi,0000ffffH           ; recalc NEC98 vram address bound
        or      [ebp+edi*2],ax          ; draw pixel
        ret                             ; return

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; draw_xor                                                              ;
;       input:                                                          ;
;               esi = ggdc address                                      ;
;               ebp = virtual vram start address                        ;
;       destory:                                                        ;
;               eax,edi,flag                                            ;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

draw_xor:
        public  draw_xor

        mov     ax,[ggdc_MASKCPU]       ; set
        xchg    ah,al                   ; change High <-> Low
        mov     edi,esi                 ; copy ggdc address
        and     edi,0000ffffH           ; recalc NEC98 vram address bound
        xor     [ebp+edi*2],ax          ; draw pixel
        ret                             ; return


;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; draw_mov                                                              ;
;       input:                                                          ;
;               esi = ggdc address                                      ;
;               ebp = virtual vram start address                        ;
;       destory:                                                        ;
;               eax,edi,flag                                            ;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

draw_mov:
        public  draw_mov

        mov     ax,[ggdc_MASKCPU]       ; set
        xchg    ah,al                   ; change High <-> Low
        mov     edi,esi                 ; copy ggdc address
        and     edi,0000ffffH           ; recalc NEC98 vram address bound
        mov     [ebp+edi*2],ax          ; draw pixel
        ret                             ; return


;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; draw_mov                                                              ;
;       input  : none                                                   ;
;       destory: none                                                   ;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

draw_nop:
        public  draw_nop

                ret             ; do nothing

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; ggdc_dir_func_pixel                                                   ;
;       input  : none                                                   ;
;       update : esi                                                    ;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

pixel_dir_0:
        public  pixel_dir_0

        add     esi,[ggdc_PITCH]                ; move down
        ret                                     ; return


;-----------------------------------------------------------------------;
pixel_dir_1:
        public  pixel_dir_1

        add     esi,[ggdc_PITCH]                ; move down
        ror     word ptr [ggdc_MASKCPU],1       ; move right
        adc     esi,0                           ; over word?
        ret                                     ; return


;-----------------------------------------------------------------------;
pixel_dir_2:
        public  pixel_dir_2

        ror     word ptr [ggdc_MASKCPU],1       ; move right
        adc     esi,0                           ; over word?
        ret                                     ; return


;-----------------------------------------------------------------------;
pixel_dir_3:
        public  pixel_dir_3

        sub     esi,[ggdc_PITCH]                ; move up
        ror     word ptr[ggdc_MASKCPU],1        ; move right
        adc     esi,0                           ; over word?
        ret                                     ; return


;-----------------------------------------------------------------------;
pixel_dir_4:
        public  pixel_dir_4

        sub     esi,[ggdc_PITCH]                ; move up
        ret                                     ; return


;-----------------------------------------------------------------------;
pixel_dir_5:
        public  pixel_dir_5

        sub     esi,[ggdc_PITCH]                ; move up
        rol     word ptr [ggdc_MASKCPU],1       ; move left
        sbb     esi,0                           ; over word?
        ret                                     ; return


;-----------------------------------------------------------------------;
pixel_dir_6:
        public  pixel_dir_6

        rol     word ptr [ggdc_MASKCPU],1       ; move left
        sbb     esi,0                           ; over word?
        ret                                     ; return


;-----------------------------------------------------------------------;
pixel_dir_7:
        public  pixel_dir_7

        add     esi,[ggdc_PITCH]                ; move down
        rol     word ptr [ggdc_MASKCPU],1       ; move left
        sbb     esi,0                           ; over word?
        ret                                     ; return


;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; ggdc_dir_func_short                                                   ;
;       input  : none                                                   ;
;       destory: esi , dx , flag                                        ;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

word_dir_0:
        public  word_dir_0

        add     esi,[ggdc_PITCH]        ; move down
        ret                             ; return


;-----------------------------------------------------------------------;
word_dir_1:
        public  word_dir_1

        add     esi,[ggdc_PITCH]        ; move down
        inc     esi                     ; move right
        ret                             ; return


;-----------------------------------------------------------------------;
word_dir_2:
        public  word_dir_2

        inc     esi                     ; move right
        ret                             ; return


;-----------------------------------------------------------------------;
word_dir_3:
        public  word_dir_3

        sub     esi,[ggdc_PITCH]        ; move up
        inc     esi                     ; move right
        ret                             ; return


;-----------------------------------------------------------------------;
word_dir_4:
        public  word_dir_4

        sub     esi,[ggdc_PITCH]        ; move up
        ret                             ; return


;-----------------------------------------------------------------------;
word_dir_5:
        public  word_dir_5

        sub     esi,[ggdc_PITCH]        ; move up
        dec     esi                     ; move left
        ret                             ; return


;-----------------------------------------------------------------------;
word_dir_6:
        public  word_dir_6

        dec     esi                     ; move left
        ret                             ; return


;-----------------------------------------------------------------------;
word_dir_7:
        public  word_dir_7

        add     esi,[ggdc_PITCH]        ; move down
        dec     esi                     ; move left
        ret                             ; return


_TEXT   ENDS
END
;endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\biostruc.inc ===
; rom bios call packet structures

;*******************************
;system service call ( int 15h )
;*******************************
;function ah = 0c0h, return system configuration
;for pc and pcjr on return:
;	(ah)	= 80h
;	(cy)	= 1
;for pcxt, pc portable and pcat on return:
;	(ah)	= 86h
;	(cy)	= 1
;for all others:
;	(ah)	= 0
;	(cy)	= 0
;	(es:bx) = pointer to system descriptor vector in ros
; system descriptor :
;	dw	xxxx		length of descriptor in bytes,
;				minimum length = 8
;	db	xx		model byte
;				0ffh	= pc
;				0feh	= pc/xt, portable
;				0fdh	= pc/jr
;				0fch	= pc/at, 6mhz pc/at,
;					  6mhz pc/at running coprocessor(?),
;					  ps/2 model 50, 50 z
;				0fah	= ps/2 model 25, 30
;				0f9h	= pc convertible
;				0f8h	= ps/2 model 80
;				0f7h	= nova
;				0e0 thru 0efh = reserved
;
;	db	xx		secondary model byte
;				000h	= pc1
;				000h	= pc/xt, portable
;				000h	= pc/jr
;				000h	= pc/at
;				001h	= 6mhz pc/at
;				003h	= 6mhz pc/at running coprocessor(?)
;				004h	= ps/2 model 50, 50z
;				001h	= ps/2 model 25
;				000h	= pc convertible
;				000h	= ps/2 model 80
;				000h	= nova
;
;	db	xx		bios revision level
;				00 for first release, subsequent release
;				of code with same model byte and
;				secondary model byte require revison level
;				to increase by one.
;
;	db	xx		feature information byte 1
;				x0000000 = 1, bios use dma channel 3
;					 = 0, dma channel 3 not used
;
;				0x000000 = 1, 2nd interrupt chip present
;					 = 0, 2nd interrupt chip not present
;
;				00x00000 = 1, real time clock present
;					 = 0, real time clock not present
;
;				000x0000 = 1, keyboard escape sequence(int15h)
;						called in keyboard interrupt
;						(int 09h).
;					 = 0, keyboard escape sequence not
;						called.
;				0000xxxx reserved
;
;	db	xx		feature information byte 2 - reserved
;
;	db	xx		feature information byte 2 - reserved
;
;	db	xx		feature information byte 2 - reserved
;
;	db	xx		feature information byte 2 - reserved
;

bios_system_descriptor	struc
bios_sd_leng		dw	?
bios_sd_modelbyte	db	?
bios_sd_scnd_modelbyte	db	?
			db	?
bios_sd_featurebyte1	db	?
			db   4 dup (?)
bios_system_descriptor ends

;featurebyte1	bit map equates
dmachannel3		equ 10000000b
scndintcontroller	equ 01000000b
realtimeclock		equ 00100000b
keyescapeseq		equ 00010000b
;
;model byte
mdl_pc1 	equ	0ffh
mdl_xt		equ	0feh
mdl_jr		equ	0fdh
mdl_at		equ	0fch
mdl_convert	equ	0f9h

mdl_ps2_30	equ	0fah
mdl_ps2_80	equ	0f8h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\msbio1.asm ===
page	,160
	title	msbio1.asm - Bios_Data definition and device driver entry/exit

;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;
;----------------------------------------------------------------------------
;
	include version.inc	; set build flags
	include biosseg.inc	; define BIOS segments

	include	devsym.inc
	include	msequ.inc
	include vint.inc


; Assembly conditional for stack switching
;
STACKSW		equ	1

Bios_Data	segment

	assume	cs:Bios_Data
	public	BData_start
BData_start:


	assume	ds:nothing,es:nothing

	public	hdrv_pat
hdrv_pat label	word			; patched by msinit
	assume	cs:Bios_Data

	extrn	init:near		; this is in msinit

	jmp	init			; go to initialization code


;	define some stuff that is also used by msdos.sys from an include file

In_Bios	=	0ffffh	; define flag for msbdata.inc
	include	msbdata.inc


	public	inHMA,xms
inHMA	db	0		; flag indicates we're running from HMA
xms	dd	0		; entry point to xms if above is true

	align	4

	public	ntvdmstate
ntvdmstate  dd	0
IF 2
.errnz	ntvdmstate-BData_start-FIXED_NTVDMSTATE_OFFSET
ENDIF


	public	ptrsav
ptrsav	dd	0

	public	auxbuf
auxbuf	db	0,0,0,0   	;set of 1 byte buffers for com 1,2,3, and 4
	public	zeroseg
zeroseg dw	0		; easy way to load segment registers with zero

	public	auxnum
auxnum	dw	0			;which aux device was requested


	public	res_dev_list

res_dev_list	label	byte
	p_attr	=	chardev+outtilbusy+dev320+IOQUERY+DEVOPCL
; **	p_attr	=	chardev+outtilbusy+dev320

	sysdev <auxdev2,8013h,strategy,con_entry,'CON     '>
auxdev2 sysdev <prndev2,8000h,strategy,aux0_entry,'AUX     '>
prndev2 sysdev <timdev,p_attr,strategy,prn0_entry,'PRN     '>
timdev	sysdev <com1dev,8008h,strategy,tim_entry,'CLOCK$  '>
com1dev sysdev <lpt1dev,8000h,strategy,aux0_entry,'COM1    '>
lpt1dev sysdev <lpt2dev,p_attr,strategy,prn1_entry,"LPT1    ">
lpt2dev sysdev <lpt3dev,p_attr,strategy,prn2_entry,"LPT2    ">
lpt3dev sysdev <com2dev,p_attr,strategy,prn3_entry,"LPT3    ">
com2dev sysdev <com3dev,8000h,strategy,aux1_entry,"COM2    ">
com3dev sysdev <com4dev,8000h,strategy,aux2_entry,"COM3    ">
com4dev dw	-1,Bios_Data,8000h,strategy,aux3_entry
	db	"COM4    "


		public	RomVectors
RomVectors	label	byte
	public	Old10,	Old15, Old19, Old1B
	db	10h					; M028
Old10	dd	(?)					; M028
	db	15h
Old15	dd	(?)
	db	19h
Old19	dd	(?)
	db	1bh
Old1B	dd	(?)
EndRomVectors	equ	$
		public	NUMROMVECTORS
NUMROMVECTORS	equ	((EndRomVectors - RomVectors)/5)

	public	spc_mse_int10
spc_mse_int10	dd	(?)

	public	int29Perf
int29Perf	dd	(?)


	public	keyrd_func
	public	keysts_func

; moved altah to inc\msbdata.inc so it could go in instance table in DOS

keyrd_func	db	0	; default is conventional keyboard read
keysts_func	db	1	; default is conventional keyboard status check.

	public printdev
printdev	db	0		; index into above array

		public	multrk_flag
multrk_flag	dw	0

; the following variable can be modified via ioctl sub-function 16. in this
; way, the wait can be set to suit the speed of the particular printer being
; used. one for each printer device.

	public wait_count
wait_count	dw	4 dup (50h)	; array of retry counts for printer

	public	int19sem
int19sem db	0			; indicate that all int 19
					; initialization is complete

;	we assume the following remain contiguous and their order doesn't change
i19_lst:
	irp	aa,<02,08,09,0a,0b,0c,0d,0e,70,72,73,74,76,77>
	public	int19old&aa
		db	aa&h	; store the number as a byte
int19old&aa	dd	-1	;orignal hardware int. vectors for int 19h.
	endm

num_i19 =	((offset $) - (offset i19_lst))/5


;variables for dynamic relocatable modules
;these should be stay resident.

	public	int6c_ret_addr
int6c_ret_addr	dd	?		; return address from int 6c for p12 machine

;
;   data structures for real-time date and time
;
	public	bin_date_time
	public	month_table
	public	daycnt2
	public	feb29

bin_date_time:
	db	0		; century (19 or 20) or hours (0-23)
	db	0		; year in century (0...99) or minutes (0-59)
	db	0		; month in year (1...12) or seconds (0-59)
	db	0		; day in month (1...31)

month_table:
	dw	0		; january
	dw	31		; february
	dw	59
	dw	90
	dw	120
	dw	151
	dw	181
	dw	212
	dw	243
	dw	273
	dw	304
	dw	334		; december
daycnt2 dw	0000		; temp for count of days since 1-1-80
feb29	db	0		; february 29 in a leap year flag


;************************************************************************
;*									*
;*	entry points into Bios_Code routines.  The segment values	*
;*	  are plugged in by seg_reinit.					*
;*									*
;************************************************************************

	public	cdev
cdev	dd	chardev_entry
bcode_i2f dd	i2f_handler
end_BC_entries:

;************************************************************************
;*									*
;*	cbreak - break key handling - simply set altah=3 and iret	*
;*									*
;************************************************************************

	public	cbreak
cbreak	proc	near
	assume	ds:nothing,es:nothing

	mov	altah,3		;indicate break key set

	public	intret		; general purpose iret in the Bios_Data seg
intret:
        FIRET
cbreak	endp

;************************************************************************
;*									*
;*	strategy - store es:bx (device driver request packet)		*
;*		     away at [ptrsav] for next driver function call	*
;*									*
;************************************************************************

	public	strategy
strategy proc	far
	assume	ds:nothing,es:nothing

	mov	word ptr cs:[ptrsav],bx
	mov	word ptr cs:[ptrsav+2],es
	ret
strategy endp

;************************************************************************
;*									*
;*	device driver entry points.  these are the initial		*
;*	  'interrupt' hooks out of the device driver chain.		*
;*	  in the case of our resident drivers, they'll just		*
;*	  stick a fake return address on the stack which		*
;*	  points to dispatch tables and possibly some unit		*
;*	  numbers, and then call through a common entry point		*
;*	  which can take care of a20 switching				*
;*									*
;************************************************************************

con_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry	; call into code segment handler
	dw	con_table

con_entry endp

;--------------------------------------------------------------------

prn0_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	0,0		; device numbers

prn0_entry endp

;--------------------------------------------------------------------

prn1_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	0,1

prn1_entry endp

;--------------------------------------------------------------------

prn2_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	1,2

prn2_entry endp

;--------------------------------------------------------------------

prn3_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	2,3

prn3_entry endp

;--------------------------------------------------------------------

aux0_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	0

aux0_entry endp

;--------------------------------------------------------------------

aux1_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	1

aux1_entry endp

;--------------------------------------------------------------------

aux2_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	2

aux2_entry endp

;--------------------------------------------------------------------

aux3_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	3

aux3_entry endp

;--------------------------------------------------------------------

tim_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	tim_table

tim_entry endp

;--------------------------------------------------------------------

;************************************************************************
;*									*
;*	Ensure A20 is enabled before jumping into code in HMA.		*
;*	This code assumes that if Segment of Device request packet is	*
;*	DOS DATA segment then the Device request came from DOS & that	*
;*	A20 is already on.						*
;*									*
;************************************************************************

cdev_entry proc	near
	assume	ds:nothing,es:nothing
;
; M064 - BEGIN
;
	cmp	inHMA, 0
	je	ce_enter_codeseg; optimized for DOS in HMA

	push	ax
	mov	ax, DosDataSg
	cmp	word ptr [ptrsav+2], ax
	pop	ax
	jne	not_from_dos	; jump is coded this way to fall thru
				;	in 99.99% of the cases
ce_enter_codeseg:
	jmp	cdev
not_from_dos:
	call	EnsureA20On
;
; M064 - END
;
	jmp	short ce_enter_codeseg
cdev_entry endp

;************************************************************************
;*									*
;*	outchr - this is our int 29h handler.  it writes the		*
;*	   character in al on the display using int 10h ttywrite	*
;*									*
;************************************************************************

	public	outchr
outchr	proc	far
	assume	ds:nothing,es:nothing

	push	ax
	push	si
	push	di
	push	bp
	push	bx
	mov	ah,0eh		; set command to write a character
	mov	bx,7		; set foreground color
	int	10h		; call rom-bios
	pop	bx
	pop	bp
	pop	di
	pop	si
	pop	ax
        jmp     intret
outchr	endp

; M001 - BEGIN

;************************************************************************
;*									*
;*	EnsureA20On - ensure that a20 is enabled if we're running	*
;*	  in the HMA before interrupt entry points into Bios_Code	*
;*									*
;************************************************************************

HiMem	label	dword
	dw	90h
	dw	0ffffh

LoMem	label	dword
	dw	80h
	dw	0h

EnsureA20On	proc near
	assume	ds:nothing,es:nothing
	call	IsA20Off
	jz	ea_enable
	ret

EnableA20	proc	near	; M041
ea_enable:
	push	ax
	push	bx
	mov	ah,5		; localenablea20
	call	xms
	pop	bx
	pop	ax
bie_done:
	ret
EnableA20	endp		; M041

EnsureA20On	endp
;
; M001 - END

; M041 : BEGIN
;
;----------------------------------------------------------------------------
;
; procedure : IsA20Off
;
;----------------------------------------------------------------------------
;
IsA20Off	proc	near
		push	ds
		push	es
		push	cx
		push	si
		push	di
		lds	si, HiMem
		les	di, LoMem
		mov	cx, 8
		rep	cmpsw
		pop	di
		pop	si
		pop	cx
		pop	es
		pop	ds
		ret
IsA20Off	endp

;
;----------------------------------------------------------------------------
;
; procedure : DisableA20
;
;----------------------------------------------------------------------------
;
DisableA20	proc	near
		push	ax
		push	bx
		mov	ah,6		; localdisable a20
		call	xms
		pop	bx
		pop	ax
		ret
DisableA20	endp

; M041 : END

;************************************************************************
;*									*
;*	int19 - bootstrap interrupt -- we must restore a bunch of the	*
;*	  interrupt vectors before resuming the original int19 code	*
;*									*
;************************************************************************


	public	int19
int19	proc	far
	assume	ds:nothing,es:nothing

	push	cs
	pop	ds
	assume	ds:Bios_Data

	mov	es,zeroseg

	mov	cx, NUMROMVECTORS	; no. of rom vectors to be restored
	mov	si, offset RomVectors	; point to list of saved vectors
next_int:
	lodsb				; get int number
	cbw				; assume < 128
	shl	ax, 1
	shl	ax, 1			; int * 4
	mov	di, ax
	lodsw
	stosw
	lodsw
	stosw				; install the saved vector
	loop	next_int

	cmp	byte ptr int19sem,0	; don't do the others unless we
	jz	doint19			; set our initialization complete flag

;	stacks code has changed these hardware interrupt vectors
;	stkinit in sysinit1 will initialize int19holdxx values.

	mov	si,offset i19_lst
	mov	cx,num_i19

i19_restore_loop:
	lodsb			; get interrupt number
	cbw			; assume < 128
	mov	di,ax		; save interrupt number
	lodsw			; get original vector offset
	mov	bx,ax		; save it
	lodsw			; get original vector segment
	cmp	bx,-1		; check for 0ffffh (unlikely segment)
	jz	i19_restor_1	;opt no need to check selector too
	cmp	ax,-1		;opt 0ffffh is unlikely offset
	jz	i19_restor_1

	add	di,di
	add	di,di
	xchg	ax,bx
	stosw
	xchg	ax,bx
	stosw			; put the vector back

i19_restor_1:
	loop	i19_restore_loop

doint19:
	int	19h
int19	endp
;
; M036 - BEGIN
;
;
;----------------------------------------------------------------------------
;
; procedure : int15
;
;		Int15 handler for recognizing ctrl-alt-del seq.
;
;----------------------------------------------------------------------------
;
DELKEY		equ	53h
	public	Int15
Int15	proc	far
	assume	ds:nothing
	cmp	ax, (4fh shl 8) + DELKEY	; del keystroke ?
	je	@f
	jmp	dword ptr Old15			
@@:
	stc
	jmp	dword ptr Old15
Int15	endp
;
;
;************************************************************************
;*									*
;*	the int2f handler chains up to Bios_Code through here.		*
;*	  it returns through one of the three functions that follow.	*
;*	  notice that we'll assume we're being entered from DOS, so	*
;*	  that we're guaranteed to be A20 enabled if needed		*
;*									*
;************************************************************************

int_2f	proc	far
	assume	ds:nothing,es:nothing
	jmp	bcode_i2f
int_2f	endp



;************************************************************************
;*									*
;*	re_init - called back by sysinit after a bunch of stuff		*
;*		is done.  presently does nothing.  affects no		*
;*		registers!						*
;*									*
;************************************************************************

	public	re_init
re_init proc	far
	assume	ds:nothing,es:nothing
	ret
re_init endp


;SR; WIN386 support
; WIN386 instance data structure
;
;
; Here is a Win386 startup info structure which we set up and to which
; we return a pointer when Win386 initializes.
;

public	Win386_SI, SI_Version, SI_Next

Win386_SI	label	byte		; Startup Info for Win386
SI_Version	db	3, 0		; for Win386 3.0
SI_Next		dd	?		; pointer to next info structure
		dd	0		; a field we don't need
		dd	0		; another field we don't need
SI_Instance	dw	Instance_Table, Bios_Data ; far pointer to instance table

;
; This table gives Win386 the instance data in the BIOS and ROM-BIOS data
; areas.  Note that the address and size of the hardware stacks must
; be calculated and inserted at boot time.
;
Instance_Table	label	dword
	dw	00H, 50H		; print screen status...
	dw	02			; ...2 bytes
	dw	0Eh, 50H		; ROM Basic data...
	dw	14H			; ...14H bytes
	dw	ALTAH, Bios_Data	; a con device buffer...
	dw	01			; ... 1 byte
IF STACKSW
public NextStack
NextStack	label dword

;	NOTE:  If stacks are disabled by STACKS=0,0, the following
;		instance items WILL NOT be filled in by SYSINIT.
;		That's just fine as long as these are the last items
;		in the instance list since the first item is initialized
;		to 0000 at load time.

	dw	0, 0		; pointer to next stack to be used...
	dw	02			; ...2 bytes
; The next item in the instance table must be filled in at sysinit time
public IT_StackLoc, IT_StackSize
IT_StackLoc	dd	?		; location of hardware stacks
IT_StackSize	dw	?		; size of hardware stacks
ENDIF
	dd	0			; terminate the instance table

;SR;
; Flag to indicate whether Win386 is running or not
;
public	IsWin386
IsWin386		db	0

;
;This routine was originally in BIOS_CODE but this causes a lot of problems
;when we call it including checking of A20. The code being only about
;30 bytes, we might as well put it in BIOS_DATA
;
PUBLIC	V86_Crit_SetFocus

V86_Crit_SetFocus	PROC	FAR

			push	di
			push	es
			push	bx
			push	ax

			xor	di,di
			mov	es,di
			mov	bx,0015h	;Device ID of DOSMGR device
			mov	ax,1684h	;Get API entry point
			int	2fh
			mov	ax,es
			or	ax,di		
			jz	Skip
;
;Here, es:di is address of API routine. Set up stack frame to simulate a call
;
			push	cs		;push return segment
			mov	ax,OFFSET Skip
			push	ax		;push return offset
			push	es
			push	di		;API far call address
			mov	ax,1		;SetFocus function number
			retf			;do the call
Skip:
			pop	ax
			pop	bx
			pop	es
			pop	di
			ret
V86_Crit_SetFocus	ENDP



;
;End WIN386 support
;

		public	FreeHMAPtr
		public	MoveDOSIntoHMA
FreeHMAPtr	dw	-1
MoveDOSIntoHMA	dd	sysinitseg:FTryToMovDOSHi


;SR;
; A communication block has been setup between the DOS and the BIOS. All
;the data starting from SysinitPresent will be part of the data block.
;Right now, this is the only data being communicated. It can be expanded
;later to add more stuff
;
		public	SysinitPresent
		public	DemInfoFlag
SysinitPresent	db	0
DemInfoFlag     db      0


; this will be the end of the BIOS data if no hard disks are in system

	public	endBIOSData
endBIOSData label byte

Bios_Data ends

;
;	okay.  so much for Bios_Data.  Now let's put our device driver
;	  entry stuff up into Bios_Code.

Bios_Code	segment
	assume	cs:Bios_Code

; ORG a bit past zero to leave room for running in HMA...

	org	30h
	public	BCode_start
BCode_start:

;	device driver entry point tables

	extrn	con_table:near
	extrn	tim_table:near
	extrn	prn_table:near
	extrn	aux_table:near

	extrn	i2f_handler:far

	public	Bios_Data_Word
Bios_Data_Word	dw	Bios_Data

;************************************************************************
;*									*
;*	seg_reinit is called with ax = our new code segment value,	*
;*	  trashes di, cx, es						*
;*									*
;*	cas -- should be made disposable!				*
;*									*
;************************************************************************

	public	seg_reinit
seg_reinit	proc	far
	assume	ds:nothing,es:nothing

	mov	es,Bios_Data_Word
	assume	es:Bios_Data
	mov	di,2+offset cdev
	mov	cx,((offset end_BC_entries) - (offset cdev))/4

seg_reinit_1:
	stosw				; modify Bios_Code entry points
	inc	di
	inc	di
	loop	seg_reinit_1
	ret
seg_reinit	endp

;************************************************************************
;*									*
;*	chardev_entry - main device driver dispatch routine		*
;*	   called with a dummy parameter block on the stack		*
;*	   dw dispatch_table, dw prn/aux numbers (optional)		*
;*									*
;*	will eventually take care of doing the transitions in		*
;*	   out of Bios_Code						*
;*									*
;************************************************************************

chardev_entry	proc	far
	assume	ds:nothing,es:nothing

	push	si
	push	ax
	push	cx
	push	dx
	push	di
	push	bp
	push	ds
	push	es
	push	bx
	mov	bp,sp			; point to stack frame
	mov	si,18[bp]		; get return address (dispatch table)
	mov	ds,Bios_Data_Word	;  load ds: -> Bios_Data
	assume	ds:Bios_Data
	mov	ax,word ptr 2[si]	; get the device number if present
	mov	byte ptr [auxnum],al
	mov	byte ptr [printdev],ah
	mov	si,word ptr [si]	; point to the device dispatch table

	les	bx,[ptrsav]		;get pointer to i/o packet

	mov	al,byte ptr es:[bx].unit	;al = unit code
	mov	ah,byte ptr es:[bx].media	;ah = media descrip
	mov	cx,word ptr es:[bx].count	;cx = count
	mov	dx,word ptr es:[bx].start	;dx = start sector

	xchg	di,ax
	mov	al,byte ptr es:[bx].cmd
	cmp	al,cs:[si]
	jae	command_error

	cbw				; note that al <= 15 means ok
	shl	ax,1

	add	si,ax
	xchg	ax,di

	les	di,dword ptr es:[bx].trans

	cld				; ***** always clear direction
	call	cs:word ptr [si+1] 	;go do command
	assume	ds:nothing

	jc	already_got_ah_status	; if function returned status, don't
	mov	ah,1			;  load with normal completion

already_got_ah_status:
	mov	ds,Bios_Data_Word	; cas///// note: shouldn't be needed!
	assume	ds:Bios_Data
	lds	bx,[ptrsav]
	assume	ds:nothing
	mov	word ptr [bx].status,ax ;mark operation complete

	pop	bx
	pop	es
	pop	ds
	pop	bp
	pop	di
	pop	dx
	pop	cx
	pop	ax
	pop	si
	add	sp,2		; get rid of fake return address

chardev_entry endp		; fall through into bc_retf

	public	bc_retf
bc_retf	proc	far
	assume	ds:nothing,es:nothing

	ret

bc_retf	endp


command_error:
	call	bc_cmderr
	jmp	short already_got_ah_status

;
;----------------------------------------------------------------------------
; The following piece of hack is for supporting CP/M compatibility
; Basically at offset 5 we have a far call into 0:c0. But this does not call
; 0:c0 directly instead it call f01d:fef0, because it needs to support 'lhld 6'
; The following hack has to reside at ffff:d0 (= f01d:fef0) if BIOS is loaded
; high.
;----------------------------------------------------------------------------


; BUGBUG sudeepb 21-May-1991 ; We can save these 30 bytes by moving
; off_d0 to right place.

	db	1fh dup (?)	; pad to bring offset to 0d0h

if2
	if ( offset off_d0 - 0d0h )
		%out CP/M compatibilty broken!!!
		%out Please re-pos hack to ffff:d0
	endif
endif

	public	off_d0
off_d0	db	5 dup (?)	; 5 bytes from 0:c0 will be copied onto here
				;  which is the CP/M call 5 entry point
	.errnz (offset off_d0 - 0d0h)


;----------------------------------------------------------
;
;	exit - all routines return through this path
;

	public	bc_cmderr
bc_cmderr:
	mov	al,3			;unknown command error

;	now zero the count field by subtracting its current value,
;	  which is still in cx, from itself.


;	subtract the number of i/o's NOT YET COMPLETED from total
;	  in order to return the number actually complete


	public	bc_err_cnt
bc_err_cnt:
	assume	ds:Bios_Data
	les	bx,[ptrsav]
	assume	es:nothing
	sub	es:word ptr [bx].count,cx;# of successful i/o's
	mov	ah,81h			;mark error return
	stc				; indicate abnormal end
	ret

Bios_Code	ends


;	the last real segment is sysinitseg

sysinitseg	segment
	assume	cs:sysinitseg
	extrn	FTryToMovDOSHi:far
	public	SI_start
SI_start:
sysinitseg	ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\mschar.asm ===
page	,160
	title	mschar - character and clock devices
;
;----------------------------------------------------------------------------
;
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;
;----------------------------------------------------------------------------
;

	.xlist

	include version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

	include msequ.inc
	include	devsym.inc
        include ioctl.inc
        include vint.inc

break	macro
	endm

        include biosbop.inc

	include error.inc
	.list

	include msgroup.inc	; define Bios_Data segment


	extrn	ptrsav:dword

	extrn	altah:byte
	extrn	keyrd_func:byte
	extrn	keysts_func:byte

	extrn	auxnum:word
	extrn	auxbuf:byte

	extrn	wait_count:word
	extrn	printdev:byte
	extrn	Old10:dword
	extrn	spc_mse_int10:dword
	extrn	int29Perf:dword


; close Bios_Data and open Bios_Code segment

	tocode

	extrn	bc_cmderr:near
	extrn	bc_err_cnt:near

MODE_CTRLBRK	equ	0ffh		; M013

;************************************************************************
;*									*
;*	device driver dispatch tables					*
;*									*
;*	each table starts with a byte which lists the number of		*
;*	legal functions, followed by that number of words.  Each	*
;*	word represents an offset of a routine in Bios_Code which	*
;*	handles the function.  The functions are terminated with	*
;*	a near return.  If carry is reset, a 'done' code is returned	*
;*	to the caller.  If carry is set, the ah/al registers are	*
;*	returned as abnormal completion status.  Notice that ds		*
;*	is assumed to point to the Bios_Data segment throughout.	*
;*									*
;************************************************************************

	public	con_table
con_table:
	db	(((offset con_table_end) - (offset con_table) - 1)/2)
	dw	bc_exvec	; 00 init
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	con_read	; 04
	dw	con_rdnd	; 05
	dw	bc_exvec	; 06
	dw	con_flush	; 07
	dw	con_writ	; 08
	dw	con_writ	; 09
	dw	bc_exvec	; 0a
con_table_end:

	public	prn_table
prn_table	label	byte
	db	(((offset prn_table_end) - (offset prn_table) -1)/2)
	dw	bc_exvec	; 00 init
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	prn_input	; 04 indicate zero chars read
	dw	z_bus_exit	; 05 read non-destructive
	dw	bc_exvec	; 06
	dw	bc_exvec	; 07
	dw	prn_writ	; 08
	dw	prn_writ	; 09
	dw	prn_stat	; 0a
	dw	bc_exvec	; 0b
	dw	bc_exvec	; 0c
	dw	prn_open	; 0d
	dw	prn_close	; 0e
	dw	bc_exvec	; 0f
	dw	prn_tilbusy	; 10
	dw	bc_exvec	; 11
	dw	bc_exvec	; 12
	dw	prn_genioctl	; 13
	dw	bc_exvec	; 14
	dw	bc_exvec	; 15
	dw	bc_exvec	; 16
	dw	bc_exvec	; 17
	dw	bc_exvec	; 18
	dw	prn_ioctl_query	; 19
prn_table_end:



	public	aux_table
aux_table	label	byte
	db	(((offset aux_table_end) - (offset aux_table) -1)/2)

	dw	bc_exvec	; 00 - init
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	aux_read	; 04 - read
	dw	aux_rdnd	; 05 - read non-destructive
	dw	bc_exvec	; 06
	dw	aux_flsh	; 07
	dw	aux_writ	; 08
	dw	aux_writ	; 09
	dw	aux_wrst	; 0a
aux_table_end:


	public	tim_table
tim_table	label	byte
	db	(((offset tim_table_end) - (offset tim_table) -1)/2)
	dw	bc_exvec	; 00
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	bc_cmderr	; 04
	dw	z_bus_exit	; 05
	dw	bc_exvec	; 06
	dw	bc_exvec	; 07
	dw	bc_cmderr	; 08
	dw	bc_cmderr	; 09
tim_table_end:

;************************************************************************
;*									*
;*	con_read - read cx bytes from keyboard into buffer at es:di	*
;*									*
;************************************************************************

con_read proc	near
	assume	ds:Bios_Data,es:nothing

	jcxz	con_exit

con_loop:
	call	chrin		;get char in al
	stosb			;store char at es:di
	loop	con_loop

con_exit:
	clc
	ret
con_read endp

;************************************************************************
;*									*
;*	chrin - input single char from keyboard into al			*
;*									*
;*	  we are going to issue extended keyboard function, if		*
;*	  supported.  the returning value of the extended keystroke	*
;*	  of the extended keyboard function uses 0e0h in al		*
;*	  instead of 00 as in the conventional keyboard function.	*
;*	  this creates a conflict when the user entered real		*
;*	  greek alpha charater (= 0e0h) to  distinguish the extended	*
;*	  keystroke and the greek alpha.  this case will be handled	*
;*	  in the following manner:					*
;*									*
;*	      ah = 16h							*
;*	      int 16h							*
;*	      if al == 0, then extended code (in ah)			*
;*	      else if al == 0e0h, then					*
;*	      if ah <> 0, then extended code (in ah)			*
;*		else greek_alpha character.				*
;*									*
;*	also, for compatibility reason, if an extended code is		*
;*	  detected, then we are going to change the value in al		*
;*	  from 0e0h to 00h.						*
;*									*
;************************************************************************


chrin	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	ah,keyrd_func		; set by msinit. 0 or 10h
	xor	al,al
	xchg	al,altah		;get character & zero altah

	or	al,al
	jnz	keyret

	int	16h			; do rom bios keyrd function

alt10:
	or	ax,ax			;check for non-key after break
	jz	chrin

	cmp	ax,7200h		;check for ctrl-prtsc
	jnz	alt_ext_chk

	mov	al,16
	jmp	short keyret

alt_ext_chk:

;**************************************************************
;  if operation was extended function (i.e. keyrd_func != 0) then
;    if character read was 0e0h then
;      if extended byte was zero (i.e. ah == 0) then
;	 goto keyret
;      else
;	 set al to zero
;	 goto alt_save
;      endif
;    endif
;  endif

	cmp	byte ptr keyrd_func,0
	jz	not_ext
	cmp	al,0e0h
	jnz	not_ext

	or	ah,ah
	jz	keyret
ifdef	DBCS
ifdef   KOREA                           ; Keyl  1990/11/5
        cmp     ah, 0f0h                ; If hangeul code range then
        jb      EngCodeRange1           ; do not modify any value.
        cmp     ah, 0f2h
        jbe     not_ext
EngCodeRange1:
endif	; KOREA
endif	; DBCS
	xor	al,al
	jmp	short alt_save

not_ext:

	or	al,al			;special case?
	jnz	keyret

alt_save:
	mov	altah,ah		;store special key
keyret:
	ret
chrin	endp

;************************************************************************
;*									*
;*	con_rdnd - keyboard non destructive read, no wait		*
;*									*
;*	pc-convertible-type machine: if bit 10 is set by the dos	*
;*	in the status word of the request packet, and there is no	*
;*	character in the input buffer, the driver issues a system	*
;*	wait request to the rom. on return from the rom, it returns	*
;*	a 'char-not-found' to the dos.					*
;*									*
;************************************************************************

con_rdnd proc	near
	assume	ds:Bios_Data,es:nothing

	mov	al,[altah]
	or	al,al
	jnz	rdexit

	mov	ah,keysts_func		; keyboard i/o interrupt - get
	int	16h			;  keystroke status (keysts_func)
	jnz	gotchr

;
; pc-convertible checking is not needed on NTVDM
; if no key in buff return immediatly with busy status
;04-Aug-1992 Jonle
;
;	cmp	fhavek09,0
;	jz	z_bus_exit		; return with busy status if not k09
;
;       les     bx,[ptrsav]
;       assume  es:nothing
;       test    es:[bx].status,0400h    ; system wait enabled?
;       jz      z_bus_exit              ;  return with busy status if not
;
;	need to wait for ibm response to request for code
;	on how to use the system wait call.
;
;        mov     ax,4100h                ; wait on an external event
;        xor     bl,bl                   ; M055; wait for any event
;        int     15h                     ; call rom for system wait

z_bus_exit:
	stc
	mov	ah,3			; indicate busy status
	ret

gotchr:
	or	ax,ax
	jnz	notbrk			;check for null after break

	mov	ah,keyrd_func		; issue keyboard read function
	int	16h
	jmp	con_rdnd		;and get a real status

notbrk:
	cmp	ax,7200h		;check for ctrl-prtsc
	jnz	rd_ext_chk

	mov	al,'P' and 1fh		; return control p
	jmp	short rdexit

rd_ext_chk:
	cmp	keyrd_func,0		; extended keyboard function?
	jz	rdexit			; no. normal exit.

	cmp	al,0e0h 		; extended key value or greek alpha?
	jne	rdexit

ifdef	DBCS
ifdef   KOREA
        cmp     ah, 0f0h                ; If hangeul code range then
        jb      EngCodeRange            ; do not modify any value.
        cmp     ah, 0f2h
        jbe     rdexit                  ; Keyl 90/11/5
EngCodeRange:
endif	; KOREA
endif	; DBCS

	cmp	ah,0			; scan code exist?
	jz	rdexit			; yes. greek alpha char.
	mov	al,0			; no. extended key stroke.
					;  change it for compatibility

rdexit:
	les	bx,[ptrsav]
	assume	es:nothing
	mov	es:[bx].media,al	; *** return keyboard character here

bc_exvec:
	clc				; indicate normal termination
	ret

con_rdnd endp

;************************************************************************
;*									*
;*	con_write - console write routine				*
;*									*
;*	entry:	es:di -> buffer						*
;*		cx    =  count						*
;*									*
;************************************************************************

con_writ proc	near
	assume	ds:Bios_Data,es:nothing

	jcxz	bc_exvec

	push	es

	mov	bx,word ptr [int29Perf]
	mov	dx,word ptr [int29Perf+2] ;DX:BX is original INT 29h vector
	sub	ax,ax
	mov	es,ax
	cmp	BX,es:[29h*4+0]
	jne	con_lp1 		; if not the same do single int10s
	cmp	DX,es:[29h*4+2]
	jne	con_lp1 		; if not the same do single int10s
	mov	bx,word ptr [spc_mse_int10]
	mov	dx,word ptr [spc_mse_int10+2] ;DX:BX is original INT 10h vector
	cmp	BX,es:[10h*4+0]
	jne	con_lp1 		; if not the same do single int10s
	cmp	DX,es:[10h*4+2]
	jne	con_lp1 		; if not the same do single int10s

	pop	es

	; Sudeepb 21-Jul-1992:	We know that no one has hooked in10 so we
	; can optimize it by calling a private in1t10h which takes a full
	; string, displays it with the same attribute as present on the
	; screen and moves the cursor to the end.

	mov	ax,46h		; sounds like a good flag value
	push	ax		; make an iret frame
	push	cs
	mov	ax, offset ret_adr
	push	ax
	push	dx		; dx:bx is pointing to softpc int10 handler
	push	bx		; make the retf frame
	mov	ax,13FFh	; AH = WRITESTRING, AL = subfunction
	retf
ret_adr:
	jmp	short cc_ret

con_lp1:
	pop	es

con_lp:
	mov	al,es:[di]		;get char
	inc	di
	int	chrout			;output char
	loop	con_lp			;repeat until all through

cc_ret:
	clc
	ret
con_writ	endp

;************************************************************************
;*									*
;*	con_flush - flush out keyboard queue				*
;*									*
;************************************************************************

	public	con_flush	; called from msbio2.asm for floppy swapping
con_flush proc	near
	assume	ds:Bios_Data,es:nothing


	mov	[altah],0		;clear out holding buffer

;	while (charavail()) charread();

flloop:
	mov	ah,1			; command code for check status
	int	16h			; call rom-bios keyboard routine
	jz	cc_ret			; return carry clear if none

	xor	ah,ah			; if zf is nof set, get character
	int	16h			; call rom-bios to get character
	jmp	flloop

con_flush endp

;************************************************************************
;*									*
;*	some equates for rom bios printer i/o				*
;*									*
;************************************************************************

; ibm rom status bits (i don't trust them, neither should you)
; warning!!!  the ibm rom does not return just one bit.  it returns a
; whole slew of bits, only one of which is correct.


notbusystatus	=   10000000b		; not busy
nopaperstatus	=   00100000b		; no more paper
prnselected	=   00010000b		; printer selected
ioerrstatus	=   00001000b		; some kinda error
timeoutstatus	=   00000001b		; time out.

noprinter	=   00110000b		; no printer attached

;************************************************************************
;*									*
;*	prn_input - return with no error but zero chars read		*
;*									*
;*	enter with cx = number of characters requested			*
;*									*
;************************************************************************

prn_input proc	near
	assume	ds:Bios_Data,es:nothing

	call	bc_err_cnt	; reset count to zero (sub reqpkt.count,cx)
	clc			;  but return with carry reset for no error
	ret

prn_input endp

;************************************************************************
;*									*
;*	prn_writ - write cx bytes from es:di to printer device		*
;*									*
;*	auxnum has printer number					*
;*									*
;************************************************************************

prn_writ proc	near
	assume	ds:Bios_Data,es:nothing

	jcxz	prn_done		;no chars to output

prn_loop:
	mov	bx,2			;retry count

prn_out:
	call	prnstat 		; get status
	jnz	TestPrnError		; error

	mov	al,es:[di]		; get character to print
	xor	ah,ah
	call	prnop			; print to printer
	jz	prn_con			; no error - continue

	cmp	ah, MODE_CTRLBRK	; M013
	jne	@f			; M013
	mov	al, error_I24_gen_failure ; M013
	mov	altah, 0		; M013
	jmp	short pmessg		; M013
@@:
	test	ah,timeoutstatus
	jz	prn_con			; not time out - continue

TestPrnError:
	dec	bx			;retry until count is exhausted.
	jnz	prn_out

pmessg:
	jmp	bc_err_cnt		; return with error

; next character

prn_con:
	inc	di			;point to next char and continue
	loop	prn_loop

prn_done:
	clc
	ret
prn_writ	endp

;************************************************************************
;*									*
;*	prn_stat - device driver entry to return printer status		*
;*									*
;************************************************************************

prn_stat proc	near

	call	prnstat 		;device in dx
	jnz	pmessg			; other errors were found
	test	ah,notbusystatus
	jnz	prn_done		;no error. exit
	jmp	z_bus_exit		; return busy status
prn_stat endp

;************************************************************************
;*									*
;*	prnstat - utilty function to call ROM BIOS to check		*
;*		 printer status.  Return meaningful error code		*
;*									*
;************************************************************************

prnstat proc	near
	assume	ds:Bios_Data,es:nothing

	mov	ah, 2			; set command for get status
prnstat	endp				; fall into prnop

;************************************************************************
;*									*
;*	prnop - call ROM BIOS printer function in ah			*
;*		return zero true if no error				*
;*		return zero false if error, al = error code		*
;*									*
;************************************************************************

prnop	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	dx,[auxnum]		; get printer number
	int	17h			; call rom-bios printer routine

		; This check was added to see if this is a case of no
		; printer being installed. This tests checks to be sure
		; the error is noprinter (30h)

	push	ax			; M044
	and	ah, noprinter		; M044
	cmp	AH,noprinter		; Chk for no printer
	pop	ax			; M044

	jne	NextTest
	and	AH,NOT nopaperstatus
	or	AH,ioerrstatus

; examine the status bits to see if an error occurred.	unfortunately, several
; of the bits are set so we have to pick and choose.  we must be extremely
; careful about breaking basic.

NextTest:
	test	ah,(ioerrstatus+nopaperstatus) ; i/o error?
	jz	checknotready		; no, try not ready

; at this point, we know we have an error.  the converse is not true.

	mov	al,error_I24_out_of_paper
					; first, assume out of paper
	test	ah,nopaperstatus	; out of paper set?
	jnz	ret1			; yes, error is set
	inc	al			; return al=10 (i/o error)
ret1:
	ret				; return with error

checknotready:
	mov	al,2			; assume not-ready
	test	ah,timeoutstatus	; is time-out set?
	ret				; if nz then error, else ok
prnop endp

;************************************************************************
;*                                                                      *
;*      prn_open    - send bop to disable auto-close, and wait for      *
;*                   a DOS close                                        *
;*                                                                      *
;*      inputs:                                                         *
;*      outputs: BOP has been issued                                    *
;*                                                                      *
;************************************************************************

prn_open proc near
        push    si
        push    dx
        push    ds
        mov     dx,40h
        mov     ds,dx
        test    word ptr ds:[FIXED_NTVDMSTATE_REL40],  EXEC_BIT_MASK
        pop     ds
        jnz     po_nobop
        xor     dh, dh
        mov     dl, [printdev]
        or      dl, dl
        jz      @f
        dec     dl
@@:
        mov     si,PRNIO_OPEN
        bop     %BIOS_PRINTER_IO
po_nobop:
        pop     dx
        pop     si
        ret
prn_open endp

;************************************************************************
;*                                                                      *
;*      prn_close   - send bop to close actual printer, and re-enable   *
;*                   autoclose                                          *
;*                                                                      *
;*      inputs:                                                         *
;*      outputs: BOP has been issued                                    *
;*                                                                      *
;************************************************************************

prn_close proc near
        push    si
        push    dx
        push    ds
        mov     dx,40h
        mov     ds,dx
        test    word ptr ds:[FIXED_NTVDMSTATE_REL40],  EXEC_BIT_MASK
        pop     ds
        jnz     pc_nobop
        xor     dh, dh
        mov     dl, [printdev]
        or      dl, dl
        jz      @f
        dec     dl
@@:
        mov     si,PRNIO_CLOSE
        bop     %BIOS_PRINTER_IO
pc_nobop:
        pop     dx
        pop     si
        ret
prn_close endp

;************************************************************************
;*									*
;*	prn_tilbusy - output until busy.  Used by print spooler.	*
;*		     this entry point should never block waiting for	*
;*		     device to come ready.				*
;*									*
;*	inputs:	cx = count, es:di -> buffer				*
;*	outputs: set the number of bytes transferred in the		*
;*		 device driver request packet				*
;*									*
;************************************************************************

prn_tilbusy proc near

	mov	si,di			; everything is set for lodsb

prn_tilbloop:
	push	cx

	push	bx
	xor	bh,bh
	mov	bl,[printdev]
	shl	bx,1
	mov	cx,wait_count[bx]	; wait count times to come ready
	pop	bx

prn_getstat:
	call	prnstat 		; get status
	jnz	prn_bperr		; error
	test	ah,10000000b		; ready yet?
	loopz	prn_getstat		; no, go for more

	pop	cx			; get original count
	jz	prn_berr		; still not ready => done

	lods	es:byte ptr [si]
	xor	ah,ah
	call	prnop
	jnz	prn_berr		; error

	loop	prn_tilbloop		; go for more

	clc				; normal no-error return
	ret				;   from device driver

prn_bperr:
	pop	cx			; restore transfer count from stack

prn_berr:
	jmp	bc_err_cnt
prn_tilbusy endp

;************************************************************************
;*									*
;*	prn_genioctl - get/set printer retry count			*
;*									*
;************************************************************************

prn_genioctl proc near
	assume	ds:Bios_Data,es:nothing

	les	di,[ptrsav]
	cmp	es:[di].majorfunction,ioc_pc
	jz	prnfunc_ok

prnfuncerr:
	jmp	bc_cmderr

prnfunc_ok:
	mov	al,es:[di].minorfunction
	les	di,es:[di].genericioctl_packet
	xor	bh,bh
	mov	bl,[printdev]		; get index into retry counts
	shl	bx,1
	mov	cx,wait_count[bx]	; pull out retry count for device

	cmp	al,get_retry_count
	jz	prngetcount

	cmp	al,set_retry_count
	jnz	prnfuncerr

	mov	cx,es:[di].rc_count
prngetcount:
	mov	wait_count[bx],cx	; place "new" retry count
	mov	es:[di].rc_count,cx	; return current retry count
	clc
	ret
prn_genioctl endp

;************************************************************************
;*									*
;*  prn_ioctl_query							*
;*									*
;*  Added for 5.00							*
;************************************************************************

prn_ioctl_query PROC NEAR
	assume	ds:Bios_Data,es:nothing

	les	di,[ptrsav]
	cmp	es:[di].majorfunction,ioc_pc
	jne	prn_query_err

	mov	al,es:[di].minorfunction
	cmp	al,get_retry_count
	je	IOCtlSupported
	cmp	al,set_retry_count
	jne	prn_query_err

IOCtlSupported:
	clc
	ret

prn_query_err:
	stc
	jmp	BC_CmdErr

prn_ioctl_query ENDP

;************************************************************************
;*									*
;*	aux port driver code -- "aux" == "com1"				*
;*									*
;*	the device driver entry/dispatch code sets up auxnum to		*
;*	give the com port number to use (0=com1, 1=com2, 2=com3...)	*
;*									*
;************************************************************************

;	values in ah, requesting function of int 14h in rom bios

auxfunc_send	 equ	1	;transmit
auxfunc_receive  equ	2	;read
auxfunc_status	 equ	3	;request status

;	error flags, reported by int 14h, reported in ah:

flag_data_ready  equ	01h	;data ready
flag_overrun	 equ	02h	;overrun error
flag_parity	 equ	04h	;parity error
flag_frame	 equ	08h	;framing error
flag_break	 equ	10h	;break detect
flag_tranhol_emp equ	20h	;transmit holding register empty
flag_timeout	 equ	80h	;timeout

;	these flags reported in al:

flag_cts	 equ	10h	;clear to send
flag_dsr	 equ	20h	;data set ready
flag_rec_sig	 equ	80h	;receive line signal detect

;************************************************************************
;*									*
;*	aux_read - read cx bytes from [auxnum] aux port to buffer	*
;*		   at es:di						*
;*									*
;************************************************************************

aux_read proc near
	assume	ds:Bios_Data,es:nothing

	jcxz	exvec2		; if no characters, get out

	call	getbx		; put address of auxbuf in bx
	xor	al,al		; clear al register
	xchg	al,[bx] 	; get character , if any, from
				;   buffer and clear buffer
	or	al,al		; if al is nonzero there was a
				;   character in the buffer
	jnz	aux2		; if so skip first auxin call

aux1:
	call	auxin		; get character from port
;		^^^^^ 		  won't return if error
aux2:
	stosb			; store character
	loop	aux1		; if more characters, go around again

exvec2:
	clc			; all done, successful exit
	ret

aux_read endp

;************************************************************************
;*									*
;*	auxin - call rom bios to read character from aux port		*
;*		if error occurs, map the error and return one		*
;*		level up to device driver exit code, setting		*
;*		the number of bytes transferred appropriately		*
;*									*
;************************************************************************

;
; M026 - BEGIN
;
auxin	proc	near
	mov	ah,auxfunc_receive
	call	auxop		;check for frame, parity, or overrun errors
	 			;warning: these error bits are unpredictable
				; if timeout (bit 7) is set
	test	ah, flag_frame or flag_parity or flag_overrun
	jnz	arbad		; skip if any error bits set
	ret			; normal completion, ah=stat, al=char

;	error getting character

arbad:
	pop	ax		; remove return address (near call)
	xor	al,al
	or	al,flag_rec_sig or flag_dsr or flag_cts
	jmp	bc_err_cnt

auxin	endp

IFDEF	COMMENTEDOUT
auxin	proc	near
	push	cx
	mov	cx, 20		; number of retries on time out errors
@@:
	mov	ah,auxfunc_receive
	call	auxop		;check for frame, parity, or overrun errors
	 			;warning: these error bits are unpredictable
				; if timeout (bit 7) is set
	test	ah, flag_timeout
	jz	no_timeout
	loop	@b
no_timeout:
	pop	cx
	test	ah, flag_timeout or flag_frame or flag_parity or flag_overrun
	jnz	arbad		; skip if any error bits set
	ret			; normal completion, ah=stat, al=char

;	error getting character

arbad:
	pop	ax		; remove return address (near call)
	xor	al,al
	or	al,flag_rec_sig or flag_dsr or flag_cts
	jmp	bc_err_cnt

auxin	endp
ENDIF

;
; M026 - END
;
;************************************************************************
;*									*
;*	aux_rdnd - non-destructive aux port read			*
;*									*
;************************************************************************

aux_rdnd proc	near
	assume	ds:Bios_Data,es:nothing

	call	getbx		; have bx point to auxbuf
	mov	al,[bx] 	; copy contents of buffer to al
	or	al,al		; if al is non-zero (char in buffer)
	jnz	auxrdx		;   then return character

	call	auxstat 	;   if not, get status of aux device
	test	ah,flag_data_ready ; test data ready
	jz	auxbus		;   then device is busy (not ready)

	test	al,flag_dsr	;test data set ready
	jz	auxbus		;   then device is busy (not ready)

	call	auxin		;   else aux is ready, get character
	mov	[bx],al 	; save character in buffer

auxrdx:
	jmp	rdexit		; return al in [packet.media]

auxbus:
	jmp	z_bus_exit	; return busy status
aux_rdnd endp

;************************************************************************
;*									*
;*	aux_wrst - return aux port write status				*
;*									*
;************************************************************************

aux_wrst proc	near
	assume	ds:Bios_Data,es:nothing

	call	auxstat 	; get status of aux in ax
	test	al,flag_dsr	; test data set ready
	jz	auxbus		;   then device is busy (not ready)
	test	ah,flag_tranhol_emp ;test transmit hold reg empty
	jz	auxbus		;   then device is busy (not ready)
	clc
	ret
aux_wrst endp

;************************************************************************
;*									*
;*	auxstat - call rom bios to determine aux port status		*
;*									*
;*	exit:	ax = status						*
;*		dx = [auxnum]						*
;*									*
;************************************************************************

auxstat	proc near
	mov	ah,auxfunc_status
auxstat endp			; fall into auxop

;************************************************************************
;*									*
;*	auxop - perform rom-biox aux port interrupt			*
;*									*
;*	entry:	ah = int 14h function number				*
;*	exit:	ax = results						*
;*		dx = [auxnum]						*
;*									*
;************************************************************************

auxop	proc	near
				;ah=function code
				;0=init, 1=send, 2=receive, 3=status
	mov	dx,[auxnum]	; get port number
	int	14h		; call rom-bios for status
	ret
auxop	endp

;************************************************************************
;*									*
;*	aux_flsh - flush aux input buffer - set contents of		*
;*		   auxbuf [auxnum] to zero				*
;*									*
;*	cas - shouldn't this code call the rom bios input function	*
;*	      repeatedly until it isn't ready?  to flush out any	*
;*	      pending serial input queue if there's a tsr like MODE	*
;*	      which is providing interrupt-buffering of aux port?	*
;*									*
;************************************************************************

aux_flsh proc	near
	call	getbx		; get bx to point to auxbuf
	mov	byte ptr [bx],0 ; zero out buffer
	clc			; all done, successful return
	ret
aux_flsh endp

;************************************************************************
;*									*
;*	aux_writ - write to aux device					*
;*									*
;************************************************************************

aux_writ proc	near
	assume	ds:Bios_Data 	; set by aux device driver entry routine
	jcxz	exvec2		; if cx is zero, no characters
				;   to be written, jump to exit
aux_loop:
	mov	al,es:[di]	; get character to be written
	inc	di		; move di pointer to next character
	mov	ah,auxfunc_send ;value=1, indicates a write
	call	auxop		;send character over aux port

	test	ah,flag_timeout ;check for error
	jz	awok		;   then no error
	mov	al,10		;   else indicate write fault
	jmp	bc_err_cnt 	; call error routines

				; if cx is non-zero, still more
awok:
	loop	aux_loop	; more characrter to print
	clc			; all done, successful return
	ret
aux_writ endp

;************************************************************************
;*									*
;*	getbx - return bx -> single byte input buffer for		*
;*		selected aux port ([auxnum])				*
;*									*
;************************************************************************

getbx	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	bx,[auxnum]
	add	bx,offset auxbuf
	ret
getbx	endp

Bios_Code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\msinit.asm ===
page	,160
	title	msinit for BIOS
;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------
;

EXTENDEDKEY	equ	1	; use extended keyboard functions

	include version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

	include	msequ.inc
	include dossym.inc
	include	dosmac.inc
	include biostruc.inc
        include dossvc.inc
        include vint.inc

;	the following segment follows sysinit.  It is used to define
;	the location to load MSDOS.SYS into.

dos_load_seg	segment	para public 'dos_load_seg'
dos_load_seg	ends

	extrn	RomVectors:dword
	extrn	NUMROMVECTORS:abs
	extrn	res_dev_list:word
	extrn	keyrd_func:byte 	; for mscon. defined in msdata.
	extrn	keysts_func:byte	; for mscon. defined in msdata.
	extrn	endBIOSData:byte

	extrn	dosdatasg:word

	extrn	Int15:far		; M036
	extrn	int19:far
	extrn	intret:near
	extrn	cbreak:near
	extrn	outchr:near
	extrn	outchr:near

sysinitseg segment 
	assume	cs:sysinitseg
	extrn	current_dos_location:word
	extrn	device_list:dword
	extrn	memory_size:word
	extrn	sysinit:far
sysinitseg ends

Bios_Data_Init segment
	assume	cs:datagrp

;*********************************************************
;	system initialization
;
;	the entry conditions are established by the bootstrap
;	loader and are considered unknown. the following jobs
;	will be performed by this module:
;
;	1.	all device initialization is performed
;
;	2.	a local stack is set up and ds:si are set
;		to point to an initialization table. then
;		an inter-segment call is made to the first
;		byte of the dos
;
;	3.	once the dos returns from this call the ds
;		register has been set up to point to the start
;		of free memory. the initialization will then
;		load the command program into this area
;		beginning at 100 hex and transfer control to
;		this program.
;
;********************************************************



;===========================================================================
;
; entry from boot sector.  the register contents are:
;
;   dl = int 13 drive number we booted from
;   ch = media byte
;   bx = first data sector on disk.
;   ax = first data sector (high)
;   di = sectors/fat for the boot media.
;
	public	init
init	proc	near
	assume	ds:nothing,es:nothing

        FCLI
	xor	ax,ax
	mov	ds,ax

; Save a pack of interrupt vectors...

	push	cs
	pop	es			; cannot use cs override for stos

	mov	cx, NUMROMVECTORS     	; no. of rom vectors to be saved
	mov	si, offset RomVectors	; point to list of int vectors
next_int:				
	lods	byte ptr cs:[si]	; get int number
	cbw				; assume < 128
	shl	ax, 1
	shl	ax, 1			; int no * 4
	mov	di, ax
	xchg	si, di
	lodsw
	stosw
	lodsw
	stosw				; save the vector
	xchg	si, di
	loop	next_int

; set up int 15 for new action				; M036

	mov	word ptr ds:[15h*4],offset Int15	; M036
	mov	ds:[15h*4+2],cs				; M036



; set up int 19 for new action

	mov	word ptr ds:[19h*4],offset int19
	mov	ds:[19h*4+2],cs

;
	xor	dx,dx
	mov	ss,dx
	mov	sp,700h 		;local stack
        FSTI
	assume	ss:nothing

       ; NTVDM we do not intialize the com,prn ports here
       ; to stay seamless with the host OS
       ; 15-Sep-1992 Jonle
       ;
       ; mov     al,3            ; init com4
       ; call    aux_init
       ; mov     al,2            ; init com3
       ; call    aux_init
       ; mov     al,1            ; init com2
       ; call    aux_init
       ; xor     al,al           ; init com1
       ; call    aux_init
       ;
       ; mov     al,2            ; init lpt3
       ; call    print_init
       ; mov     al,1            ; init lpt2
       ; call    print_init
       ; xor     al,al           ; init lpt1
       ; call    print_init

        xor     dx,dx
	mov	ds,dx		; to initialize print screen vector
	mov	es,dx

	xor	ax,ax
	mov	di,initspot
	stosw			; init four bytes to 0
	stosw

	mov	ax,cs		; fetch segment

	mov	ds:word ptr brkadr,offset cbreak ;break entry point
	mov	ds:brkadr+2,ax		;vector for break

	mov	ds:word ptr chrout*4,offset outchr
	mov	ds:word ptr chrout*4+2,ax

	mov	di,4
	mov	bx,offset intret	;will initialize rest of interrupts
	xchg	ax,bx
	stosw				;location 4
	xchg	ax,bx
	stosw				;int 1	;location 6
	add	di,4
	xchg	ax,bx
	stosw				;location 12
	xchg	ax,bx
	stosw				;int 3	;location 14
	xchg	ax,bx
	stosw				;location 16
	xchg	ax,bx
	stosw				;int 4	;location 18

	mov	ds:word ptr 500h,dx	;set print screen & break =0
	mov	ds:word ptr lstdrv,dx	;clean out last drive spec


	mov	dx,sysinitseg
	mov	ds,dx

	assume	ds:sysinitseg

; set pointer to resident device driver chain

	mov	word ptr device_list,offset res_dev_list
	mov	word ptr device_list+2,cs


	mov	current_dos_location,dos_load_seg ; will load MSDOS here


ifdef	EXTENDEDKEY

; we will check if the system has ibm extended keyboard by
; looking at a byte at 40:96.  if bit 4 is set, then extended key board
; is installed, and we are going to set keyrd_func to 10h, keysts_func to 11h
; for the extended keyboard function. use cx as the temporary register.

	xor	cx,cx
	mov	ds,cx
	assume	ds:nothing
	mov	cl,ds:0496h			; get keyboard flag
	test	cl,00010000b
	jz	org_key				; orginal keyboard
	mov	byte ptr keyrd_func,10h		; extended keyboard
	mov	byte ptr keysts_func,11h	; change for ext. keyboard functions
org_key:

endif

	push	cs
	pop	ds
	push	cs
	pop	es

	assume	ds:datagrp, es:datagrp

	mov	di, offset endBIOSData	; BIOS data segment end address
	shr	di,1
	shr	di,1
	shr	di,1
	shr	di,1			; Converted to segmnet
	inc	di			; para align

	add	di,datagrp		; Add segment of BIOS data
	mov	[dosdatasg],di		; di = to be dos data segment

	mov	di,dos_load_seg

	SVC	SVC_DEMLOADDOS		; di is segment to load DOS
					; If it fails it never comes back

	jmp	sysinit

init	endp


;--------------------------------------------------------------------

; al = device number

print_init proc	near
	assume	ds:nothing,es:nothing

	cbw
	mov	dx,ax			; get printer port number into dx
	mov	ah,1			;initalize printer port
	int	17h			;call rom-bios routine
	ret

print_init endp

;--------------------------------------------------------------------

aux_init proc	near
	assume	ds:nothing,es:nothing

	cbw
	mov	dx,ax
	mov	al,rsinit		;2400,n,1,8 (msequ.inc)
	mov	ah,0			;initalize aux port
	int	14h			;call rom-bios routine
	ret

aux_init endp

Bios_Data_Init	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\sysimes.asm ===
page	,160
	;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------

	include	version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

sysinitseg segment

	public	badopm,crlfm,badsiz_pre,badld_pre,badcom,badcountry
	public	badmem,badblock,badstack
	public	insufmemory,badcountrycom
	public	badorder,errorcmd
	public	badparm
        public  toomanydrivesmsg			;M029

	include msbio.cl3

sysinitseg	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\spckbd.asm ===
;******************************************************************************
;
;       Copyright (c) 1992 Insignia Solutions Ltd.
;
;       Program:
;
;       Purpose:
;
;       Version:
;
;       Author:         Dave Bartlett
;	Modifications:
;		1) Tim June 92. Changes to get DEC PC working. Take over
;		   IVT entries 6h (illegal instruction), 11h (equipment
;		   check), 16h (keyboard BIOS), 17h (printer),
;		   42h (default video).
;		2) Tim June 92. Changed version to 1.11
;		3) Tim June 92. Avoid accesses to host ROM as far as
;		   possible. Take over lots of IVT entries and continue to
;		   point them at this driver.
;		4) Tim July 92. Version num 1.12, put pseudo ROM stuff back in.
;               5) Tim July 92. v 1.13, use SoftPC video BIOS when windowed.
;
;      6) 12-Sep-1992 Jonle, Merged with ntio.sys
;                            cleanup usage of assumes espcially with ES
;                            optimized loading of IVT
;                            other general cleanup
;
;      This obj module is intially loaded in a temporary memory location
;      along with ntio.sys. Ntio.sys will copy the resident code (marked by
;      SpcKbdBeg, SpcKbdEnd) into the permanent memory location which resides
;      just below the normal device drivers loaded by config.sys.
;
;      The nonresident intialization code is run with CS= temp seg
;      and DS= final seg.
;
;******************************************************************************


.286

include vint.inc

;================================================================
; Macros and includes
;================================================================

bop MACRO callid
    db 0c4h,0c4h,callid
endm


BIOS_CPU_QUIT   equ     0FEh
BIOS_KB_INT     equ     9
BIOS_INT15      equ     15h
BIOS_PRINTER_IO	equ	17h
UNEXP_BOP       equ     2
RTC_WAIT_FLAG   equ     0a0h     ; offset of rtc_wait_flag in bios data seg
VERSIONID       equ     0BEEFh

FULLSCREEN	equ	1
MAX_VIDEO_FUNC	equ	1Ch
GET_FONT_FUNC	equ	11h

VID_MODECHANGE	equ	0
MOUSE_LIGHT_PEN	equ	4
MIN_MOUSE_FUNC	equ	0F0H
MAX_MOUSE_FUNC	equ	0F7H
XTRA_MOUSE_FUNC	equ	0FAH
MS_VIDEO_STRING	equ	13FFH

MOUSE_VID_BOP	equ	0BEh
EGA_VIDEO_BOP	equ	42h

PRT_NOTBUSY	equ	80h
PRT_NUM_PORTS	equ	3
PRT_STATE_READY	equ	0
PRT_IRQ		equ	10h
PRT_LPT_BUSY    equ     1

TIMER_LOW       equ 6ch
TIMER_HIGH      equ 6eh
TIMER_OVFL      equ 70h
MOTOR_STATUS    equ 3fh
MOTOR_COUNT     equ 40h

; Keyboard buf ptrs
BUFFER_HEAD     equ 1ah
BUFFER_TAIL     equ 1ch
BUFFER_START    equ 80h
BUFFER_END      equ 82h

; kb_flag and LED bits
KB_FLAG         equ  17h
CAPS_STATE      equ  40h
NUM_STATE       equ  20h
SCROLL_STATE    equ  10h

KB_FLAG_1       equ  18h

KB_FLAG_2       equ  97h
KB_LEDS         equ  07h   ; Keyboard LED state bits
KB_PR_LED       equ  40h   ; Mode indicator update


KB_FLAG_3       equ  96h
LC_E1           equ  01h
LC_E0           equ  02h




;..............................................keyboard constants

; bits in kb_flag
	RIGHT_SHIFT = 1
	LEFT_SHIFT = 2
	CTL_SHIFT = 4
	ALT_SHIFT = 8


; bit in kb_flag_1
	HOLD_STATE = 8
	SCROLL_SHIFT = 10h
	NUM_SHIFT = 20h
	CAPS_SHIFT = 40h
        INS_SHIFT = 80h
        SYS_SHIFT = 04h


; IBM scan codes
	CTL_KEY = 29
	LEFT_SHIFTKEY = 42
	RIGHT_SHIFTKEY = 54
	ALT_KEY = 56
	CAPS_KEY = 58
	NUM_KEY = 69
	SCROLL_KEY = 70
	INS_KEY = 82    



;
; Segment definitions for ntio.sys,
;
include biosseg.inc


SpcKbdSeg    segment

        assume  cs:SpcKbdSeg,ds:nothing,es:nothing

;
; SpcKbdBeg - SpcKbdEnd
;
; Marks the resident code, anything outside of these markers
; is discarded after intialization
; 13-Sep-1992 Jonle
;
        public SpcKbdBeg

SpcKbdBeg    label  byte

;
; Reduced data table for Video 7 modes 0 and 2.
; This table is extracted from our video7 ROM. Only text modes are
; required, mode 0 and 1 are identical as are modes 2 and 3.
;
ega_parm_setup:

;--40x25--
	DB 40,24,16	; width,height,character height
	DW 00800H	; Page size in bytes

	DB 008H, 003H, 000H, 002H	; Sequencer Parameters

	DB 067H	;Misc Reg

; CRTC Parameters
	DB 02dH, 027H, 028H, 090H, 02bH
	DB 0a0H, 0bfH, 01fH, 000H, 04fH
	DB 00dH, 00eH, 000H, 000H, 000H
	DB 000H, 09cH, 0aeH, 08fH, 014H
	DB 01fH, 096H, 0b9H, 0a3H, 0ffH

; Attribute parameters
	DB 000H, 001H, 002H, 003H, 004H
	DB 005H, 014H, 007H, 038H, 039H
	DB 03aH, 03bH, 03cH, 03dH, 03eH
	DB 03fH, 00cH, 000H, 00fH, 008H

; Graph parameters
	DB 000H, 000H, 000H, 000H, 000H
	DB 010H, 00eH, 000H, 0ffH

;--80x25--
	DB 80,24,16	; width,height,character height
	DW 01000H	; Page size in bytes

	DB 000H, 003H, 000H, 002H	; Sequencer Parameters

	DB 067H	;Misc Reg

; CRTC Parameters
	DB 05fH, 04fH, 050H, 082H, 055H
	DB 081H, 0bfH, 01fH, 000H, 04fH
	DB 00dH, 00eH, 000H, 000H, 000H
	DB 000H, 09cH, 08eH, 08fH, 028H
	DB 01fH, 096H, 0b9H, 0a3H, 0ffH

; Attribute parameters
	DB 000H, 001H, 002H, 003H, 004H
	DB 005H, 014H, 007H, 038H, 039H
	DB 03aH, 03bH, 03cH, 03dH, 03eH
	DB 03fH, 00cH, 000H, 00fH, 008H

; Graph parameters
	DB 000H, 000H, 000H, 000H, 000H
	DB 010H, 00eH, 000H, 0ffH

;--80x25 mono--
	DB 80,24,16	; width,height,character height
	DW 01000H	; Page size in bytes

	DB 000H, 003H, 000H, 003H	; Sequencer Parameters

	DB 0a6H	;Misc Reg

; CRTC Parameters
	DB 05fH, 04fH, 050H, 082H, 055H
	DB 081H, 0bfH, 01fH, 000H, 04dH
	DB 00bH, 00cH, 000H, 000H, 000H
	DB 000H, 083H, 0a5H, 05dH, 028H
	DB 00dH, 063H, 0baH, 0a3H, 0ffH

; Attribute parameters
	DB 000H, 008H, 008H, 008H, 008H
	DB 008H, 008H, 008H, 010H, 018H
	DB 018H, 018H, 018H, 018H, 018H
	DB 018H, 00eH, 000H, 00fH, 008H

; Graph parameters
	DB 000H, 000H, 000H, 000H, 000H
	DB 010H, 00aH, 000H, 0ffH

; Mode b (font load)

	DB 5eh,32H,8	; width,height,character height
	DW 09700H	; Page size in bytes

	DB 001H, 00fH, 000H, 006H	; Sequencer Parameters

	DB 0e7H	;Misc Reg

; CRTC Parameters
	DB 06dH, 05dH, 05eH, 090H, 061H
	DB 08fH, 0bfH, 01fH, 000H, 040H
	DB 000H, 000H, 000H, 000H, 000H
	DB 000H, 0a2H, 08eH, 099H, 02fH
	DB 000H, 0a1H, 0b9H, 0e3H, 0ffH

; Attribute parameters
	DB 000H, 001H, 002H, 003H, 004H
	DB 005H, 014H, 007H, 038H, 039H
	DB 03aH, 03bH, 03cH, 03dH, 03eH
	DB 03fH, 001H, 000H, 00fH, 000H

; Graph parameters
	DB 000H, 000H, 000H, 000H, 000H
	DB 000H, 005H, 00fH, 0ffH


;--350 scanline 40x25
	DB 40,24,14	; width,height,character height
	DW 00800H	; Page size in bytes

	DB 009H, 003H, 000H, 002H	; Sequencer Parameters

	DB 0a3H	;Misc Reg

; CRTC Parameters
	DB 02dH, 027H, 028H, 090H, 02bH
	DB 0a0H, 0bfH, 01fH, 000H, 04dH
	DB 00bH, 00cH, 000H, 000H, 000H
	DB 000H, 083H, 0a5H, 05dH, 014H
	DB 01fH, 063H, 0baH, 0a3H, 0ffH

; Attribute parameters
	DB 000H, 001H, 002H, 003H, 004H
	DB 005H, 014H, 007H, 038H, 039H
	DB 03aH, 03bH, 03cH, 03dH, 03eH
	DB 03fH, 008H, 000H, 00fH, 000H

; Graph parameters
	DB 000H, 000H, 000H, 000H, 000H
	DB 010H, 00eH, 000H, 0ffH

;--350 scanline 80x25
	DB 80,24,14	; width,height,character height
	DW 01000H	; Page size in bytes

	DB 001H, 003H, 000H, 002H	; Sequencer Parameters

	DB 0a3H	;Misc Reg

; CRTC Parameters
	DB 05fH, 04fH, 050H, 082H, 055H
	DB 081H, 0bfH, 01fH, 000H, 04dH
	DB 00bH, 00cH, 000H, 000H, 000H
	DB 000H, 083H, 0a5H, 05dH, 028H
	DB 01fH, 063H, 0baH, 0a3H, 0ffH

; Attribute parameters
	DB 000H, 001H, 002H, 003H, 004H
	DB 005H, 014H, 007H, 038H, 039H
	DB 03aH, 03bH, 03cH, 03dH, 03eH
	DB 03fH, 008H, 000H, 00fH, 000H

; Graph parameters
	DB 000H, 000H, 000H, 000H, 000H
	DB 010H, 00eH, 000H, 0ffH

;
; End of baby mode table.
;
; Table of VGA bios 'capability' info for func 1b to point at.
vga_1b_table    db 07fh, 060h, 00fh, 000h, 000h, 000h, 000h, 007h
                db 002h, 008h, 0ffh, 00eh, 000h, 000h, 03fh, 000h

; Configuration table for INT 15 Func C0 to point at.
conf_table      dw 008h
;;		db 000h, 0fch, 002h, 000h, 070h, 000h, 000h, 000h, 000h
		db 000h, 0fch, 002h, 074h, 070h, 000h, 000h, 000h, 000h


PRT_BUF_SIZE     equ     255

;================================================================
; Printer status table
;================================================================
prt_status	db PRT_NUM_PORTS dup (?)
prt_state	db PRT_NUM_PORTS dup (?)
prt_control	db PRT_NUM_PORTS dup (?)
prt_lpt_stat    db PRT_NUM_PORTS dup (?)
cur_buf_size    dw PRT_BUF_SIZE
prt_data_buf    db PRT_BUF_SIZE dup (?) ; buffer in the 16bit side for perf.
cur_lpt         db 0ffh                 ; buffer is not being used
cur_count       dw ?
cur_busy        db 0                    ; initially not busy

;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
; Keyboard tables
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


shift_keys:                                                     ;K6
	DB INS_KEY,CAPS_KEY,NUM_KEY,SCROLL_KEY
	DB ALT_KEY,CTL_KEY,LEFT_SHIFTKEY,RIGHT_SHIFTKEY

shift_masks:                                                    ;K7
	DB INS_SHIFT,CAPS_SHIFT,NUM_SHIFT,SCROLL_SHIFT
	DB ALT_SHIFT,CTL_SHIFT,LEFT_SHIFT,RIGHT_SHIFT

ctl_n_table:                                                    ;K8
	DB  27,  -1,   0,  -1,  -1,  -1,  30,  -1
	DB  -1,  -1,  -1,  31,  -1, 127, 148,  17
	DB  23,   5,  18,  20,  25,  21,   9,  15
	DB  16,  27,  29,  10,  -1,   1,  19,   4
	DB   6,   7,   8,  10,  11,  12,  -1,  -1
	DB  -1,  -1,  28,  26,  24,   3,  22,   2
	DB  14,  13,  -1,  -1,  -1,  -1, 150,  -1
	DB ' ',  -1

ctl_f_table:                                                    ;K9
	DB  94,  95,  96,  97,  98,  99, 100, 101
	DB 102, 103,  -1,  -1, 119, 141, 132, 142
	DB 115, 143, 116, 144, 117, 145, 118, 146
	DB 147,  -1,  -1,  -1, 137, 138

lowercase:
	DB  27, '1', '2', '3', '4', '5', '6', '7', '8', '9'     ;K10
	DB '0', '-', '=',   8,   9, 'q', 'w', 'e', 'r', 't'
	DB 'y', 'u', 'i', 'o', 'p', '[', ']',  13, -1,  'a'
	DB 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';',  39
	DB  96,  -1,  92, 'z', 'x', 'c', 'v', 'b', 'n', 'm'
	DB ',', '.', '/',  -1, '*',  -1, ' ',  -1

lc_tbl_scan:
	DB  59,  60,  61,  62,  63,  64,  65,  66,  67,  68
	DB  -1,  -1

base_case:
	DB  71,  72,  73,  -1,  75,  -1,  77,  -1,  79,  80
	DB  81,  82,  83,  -1,  -1,  92, 133, 134               ;K15

uppercase:							;K11
	DB  27, '!', '@', '#', '$', '%', '^', '&', '*', '('
	DB ')', '_', '+',   8,   0, 'Q', 'W', 'E', 'R', 'T'
	DB 'Y', 'U', 'I', 'O', 'P', '{', '}',  13,  -1, 'A'
	DB 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', '"'
	DB 126,  -1, '|', 'Z', 'X', 'C', 'V', 'B', 'N', 'M'
	DB '<', '>', '?',  -1,	 0,  -1, ' ',  -1;

ucase_scan:
	DB  84,  85,  86,  87,  88,  89,  90,  91,  92,  93
	DB  -1,  -1

numb_state:
	DB '7', '8', '9', '-', '4', '5', '6', '+', '1', '2'	;K14
	DB '3', '0', '.' , -1,	-1, 124, 135, 136

alt_table:
	DB 82,	79,  80,  81,  75,  76,  77,  71,  72,	73	;K30
	DB 16,  17,  18,  19,  20,  21,  22,  23,  24,  25
	DB 30,  31,  32,  33,  34,  35,  36,  37,  38,  44
	DB 45,	46,  47,  48,  49,  50

;================================================================
; Keyboard break caller
;================================================================

keyboard_break_caller:
	int 1bh	    ;keyboard break
	bop %BIOS_CPU_QUIT

;================================================================
; Print screen caller
;================================================================

print_screen_caller:
	int 5h		    ;print screen
	bop %BIOS_CPU_QUIT

;================================================================
; Int 15 caller
;================================================================
; Tim modified int 15 caller. Copied from BIOS2. It gives CPU
; a chance to take other interrupts. Suspect the extra jumps are
; now harmless with IRET hooking.
;int15h_caller:
	;int	15h
	;bop	%BIOS_CPU_QUIT
int15h_caller:
	int	15h	; Cassette I/O.
	jmp	k1
k1:	jmp	k2
k2:	jmp	k3
k3:	BOP	%BIOS_CPU_QUIT

;================================================================
; Unexpected interrupt handler
;================================================================

unexp_int:
	bop %UNEXP_BOP
        jmp     iret_com

;================================================================
;Int 13 caller
;================================================================
int13h_caller:
	int	13h
	bop %BIOS_CPU_QUIT


;================================================================
; New interrupt 9h handler
;================================================================

int09h_vector:
        push    ax
        xor     ax, ax
        bop     %BIOS_KB_INT
        pop     ax
        jmp     iret_com

        ; CarbonCopy traces int 9 in order to gain control
        ; over where the kbd data is coming from (the physical kbd
        ; or the serial link) The kbd_inb instruction must be visible
        ; in the 16 bit code via int 1 tracing, for CarbonCopy to work.
        ; Softpc assumes the exact location of the first nop
        ; relative to the bop just above.
        nop
        nop
        in      al, 60h      ; keyba_io_buffers
        nop
        nop
        BOP     %BIOS_CPU_QUIT





;=================================================================
; IRET hooks bop table
;=================================================================


IRET_HOOK = 5dh 		;IRET hook BOP

iret_bop_table:
	bop %IRET_HOOK
	db 0
iret_end_first_entry:
	bop %IRET_HOOK
	db 1
	bop %IRET_HOOK
	db 2
	bop %IRET_HOOK
	db 3
	bop %IRET_HOOK
	db 4
	bop %IRET_HOOK
	db 5
	bop %IRET_HOOK
	db 6
	bop %IRET_HOOK
	db 7
	bop %IRET_HOOK
	db 8
	bop %IRET_HOOK
	db 9
	bop %IRET_HOOK
	db 10
	bop %IRET_HOOK
	db 11
	bop %IRET_HOOK
	db 12
	bop %IRET_HOOK
	db 13
	bop %IRET_HOOK
	db 14
	bop %IRET_HOOK
	db 15

;================================================================
; New interrupt 13h handler
;================================================================

int13h_vector:
	cmp	dl,80h		; 0 - 7f are floppy commands
	jb	int40h_vector

	cmp     ah,2		; we fail the direct access commands
	jb	diskcmd		; read/write/seek/verify/format
	cmp	ah,5		; but let others go through (disk tables etc)
	jbe	faildisk
	cmp	ah,0ah
	jb	diskcmd
	cmp	ah,0ch
	ja	diskcmd
faildisk:
	push	ax
	mov	ax,1		; direct access error panel
	bop	59h
	pop	ax		; preserve AL for safety sake
	mov	ah, 80h		; error - timeout
	stc
	retf	2

diskcmd:
	bop	13h
	retf	2

;================================================================
; New interrupt 40h handler
;================================================================

int40h_vector:
;	cmp	ah,2		; we fail the direct access commands
;	jb	flopcmd		; read/write/seek/verify/format
;	cmp	ah,5		; but let others go through (disk tables etc)
;	jbe	failflop
;	cmp	ah,0ah
;	jb	flopcmd
;	cmp	ah,0ch
;	ja	flopcmd
failflop:
;	push	ax
;	mov	ax,0		; direct access error panel
;	bop	59h
;	pop	ax
;	mov	ah, 80h		; error - timeout
;	stc
;	retf	2

flopcmd:
	bop	40h
	retf	2

;; waiting for diskette interrupt
wait_int:
	push	ds
	push	ax
	push	cx
	mov	ax, 40h
	mov	ds, ax
	mov	cx, 10h
wait_int_loop:
	mov	al, [3Eh]
	test	al, 80h
	loopz	wait_int_loop
	pop	cx
	pop	ax
	pop	ds
	bop	%BIOS_CPU_QUIT

;; floppy parameters table
floppy_table	label	byte

	DB	01				;; 360KB in 360KB
	DW	OFFSET md_tbl1
	DB	82H				;; 360KB in 1,2MB
	DW	OFFSET md_tbl2
	DB	02				;; 1.2MB in 1.2MB
	DW	OFFSET md_tbl3
	DB	03				;; 720KB in 720KB
	DW	OFFSET md_tbl4
	DB	84H				;; 720KB in 1.44MB
	DW	OFFSET md_tbl5
	DB	04				;; 1.44MB in 1.44MB
	DW	OFFSET md_tbl6
	DB	85h				;; 720KB in 2.88MB
	DW	OFFSET md_tbl7
	DB	85h				;; 1.44MB in 2.88MB
	DW	OFFSET md_tbl8
	DB	5				;; 2.88MB in 2.88MB
	DW	OFFSET md_tbl9


md_tbl1:
	; MEDIA = 40 track low data rate; DRIVE = 40 track low data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 39		; maximum track number
	DB 80H		; transfer rate

md_tbl2:
	; MEDIA = 40 track low data rate; DRIVE = 80 track high data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 39		; maximum track number
	DB 40H		; transfer rate

md_tbl3:
	; MEDIA = 80 track high data rate; DRIVE = 80 track high data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 15		; sectors/track
	DB 01Bh		; gap length
	DB 0FFh		; data length
	DB 054h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB 0		; transfer rate

md_tbl4:
	; MEDIA = 80 track low data rate; DRIVE = 80 track low data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start ime
	DB 79		; maximum track number
	DB 80H		; transfer rate

md_tbl5:
	; MEDIA = 80 track low data rate; DRIVE = 80 track high data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB 80H		; transfer rate

md_tbl6:
	; MEDIA = 80 track high data rate; DRIVE = 80 track high data rate
	DB 0AFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 18		; sectors/track
	DB 01Bh		; gap length
	DB 0FFh		; data length
	DB 06Ch		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB 0		; transfer rate

md_tbl7:
	;MEDIA = 80 tracks, 9 sectors/track; DRIVE = 80 tracks, 36 sectotrs per track

	DB 0E1h		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start ime
	DB 79		; maximum track number
	DB 80H		; transfer rate
md_tbl8:
	;MEDIA = 80 tracks, 18 sectors/track; DRIVE = 80 tracks, 36 sectotrs per track

	DB 0D1h		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 18		; sectors/track
	DB 01Bh		; gap length
	DB 0FFh		; data length
	DB 065h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB 0		; transfer rate

md_tbl9:
	;MEDIA = 80 tracks, 36 sectors/track; DRIVE = 80 tracks, 36 sectotrs per track

	DB 0A1h		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 36		; sectors/track
	DB 038h		; gap length
	DB 0FFh		; data length
	DB 053h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB 0C0h 	; transfer rate



floppy_table_len    equ $ - floppy_table

bios_floppy_table   label   byte
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 18		; sectors/track
	DB 01Bh		; gap length
	DB 0FFh		; data length
	DB 054h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
bios_floppy_table_len	equ $ - bios_floppy_table

;===============================================================
; New interrupt 15h handler
;================================================================
; Tim, modified this to be like a "normal" SoftPC ROM.
; Copied from BIOS2, but rtc_wait_flag is now referenced via ES not
; DS.
;
;  17-Sep-1992 Jonle , ES ref to rtc_wait was change from assume ES
;  to seg overides to prevent accidents in assuming.
;

;int15h_vector:
	;bop	  %BIOS_INT15
	;iret
;;;;;;;;;STF hide this int15h_vector:
int15h_vector:
        call    DOSTI
	cmp ah, 88h
	je lbl1
	cmp ah, 91h
	je lbl1
	cmp ah, 86h
	je lbl2
	BOP 15h
	RETF 2
lbl1:	BOP 15h
        jmp iret_com
lbl2:	BOP 15h
	jc lbl5
	push cx
	push dx
	push es				; Tim, save ES not DS.
        mov ax, 40                      ; point es to biosdata
        mov es, ax
	xchg dx, cx
lbl3:
        test byte ptr es:[RTC_WAIT_FLAG], 080h ; check for end of wait
        loopz lbl3                             ; dec timeout delay
        jnz lbl4                               ; exit if wait ended
        sub dx, 1                              ; dec error timeout counter
        jnc lbl3                               ; loop till counters timeout
lbl4:
        mov byte ptr es:[RTC_WAIT_FLAG], 0   ; set function inactive
        pop es                               ; Kipper, restore ES not DS.
	pop dx
	pop cx
	clc
lbl5:	
	RETF 2

;=================================================================
; Regular SoftPC int 17 handler	(especially important for DEC PCs)
;=================================================================

int17h_vector:
;
;    Do a get status purely in 16-bit code but only if the printer is ready and
;we don't have interrupts turned on. Otherwise we must do a BOP and let 32-bit
;code handle it.
;
	push	si
	push	dx
	push	ax
	mov	ax, dx			; dx = adapter no., ensure it is no
	xor	dx, dx			; greater than PRT_NUM_PORTS.
	mov	si, PRT_NUM_PORTS
	div	si
	mov	si, dx
	pop	ax
        cmp     ah, 2
        je      do_prt_status
        or      ah,ah
        je      do_write
        jmp     do_print_bop

do_prt_status:
	cmp	byte ptr cs:[si + prt_state], PRT_STATE_READY
	jne	do_print_bop
	test	byte ptr cs:[si + prt_control], PRT_IRQ
        je      get_status
        jmp     short do_print_bop

do_write:
        cmp     byte ptr cs:[cur_lpt],0ffh
        jne     check_lpti
        mov     byte ptr cs:[cur_lpt],dl
        mov     word ptr cs:[cur_count],0
        mov     byte ptr cs:[cur_busy],0ffh
        jmp     short do_print_bop
check_lpti:
        cmp     byte ptr cs:[cur_lpt],dl
        je      buf_ok
        push    si
        xor     si,si
        bop     %BIOS_PRINTER_IO
        pop     si
        mov     word ptr cs:[cur_count],0
        mov     byte ptr cs:[cur_lpt],dl
        jmp     short do_print_bop
buf_ok:
        mov     dx,word ptr cs:[cur_count]
        mov     si,dx
        mov     byte ptr cs:[si + prt_data_buf],al
        inc     word ptr cs:[cur_count]
        cmp     word ptr cs:[cur_count],PRT_BUF_SIZE
        jne     no_flushing
        xor     si,si                       ; sub-function 0 for this bop
        bop     %BIOS_PRINTER_IO
        test    ah,08h
        jz      flush_ok
        dec     word ptr cs:[cur_count]
        jmp     short int17h_end
flush_ok:
        mov     word ptr cs:[cur_count],0
no_flushing:
        mov     ah,90h
        jmp     short int17h_end

do_print_bop:
        mov     si,0ffffh                     ; sub-function 1
	bop     %BIOS_PRINTER_IO
        jmp     int17h_end

get_status:
	test	byte ptr cs:[si + prt_lpt_stat], PRT_LPT_BUSY
	jne	noset
	or	byte ptr cs:[si + prt_status], PRT_NOTBUSY
noset:
	mov	ah, cs:[si + prt_status]
	and	ah, 0f8h
	xor	ah, 48h
int17h_end:
	pop	dx
        pop     si
iret_com:
        FIRET


;=================================================================
; Pseudo-ROM vectuz, copied from BIOS2.ASM
;=================================================================

dummy_vector:           ; Copied from BIOS2.ASM
        jmp iret_com
illegal_bop_vector:
	bop     72h
        jmp     iret_com
intD11_vector:
	bop     72h
        jmp     iret_com

int05h_vector:		; Print Screen func. copied from BIOS2.ASM
        call DOSTI
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	PUSH DS
	;::::::::::::::::::::::::::::::::: Setup DS to point to BIOS data area
	MOV AX,40H
	MOV DS,AX
	;::::::::::::::::::::::::::::::: Print screen already in progress ????
	CMP BYTE PTR DS:[100H],1
	JE end_print
	;::::::::::::::::::::::::::::::::::::::::::::::: Set print screen busy
	MOV BYTE PTR DS:[100h],1
	;:::::::::::::::::::::::::::::::::::::::::::::::::::: Get video status
	MOV AH,15
	INT 10H
	MOV CH,AH	    ;No of columns
	;:::::::::::::::::::::::::::::::::: Setup no. of columns/rows to print
	BOP 80H		;(BIOS_PS_PRIVATE_1)
	MOV CL,AL	    ;No of rows
	;::::::::::::::::::::::::::::::::::: Print line feed / carriage return
	CALL print_crlf
	;:::::::::::::::::::::::::::::::::::::::::: Get current cursor postion
	PUSH CX
	MOV AH,3
	INT 10H
	POP CX
	;::::::::::::::::::::::::::::::::::::::::::::::::: Save cursor postion
	PUSH DX 		    ;save current cursor postion
	XOR DH,DH		    ;current row being processed
start_print_col:
	XOR DL,DL		    ;current column being processed
	;::::::::::::::::::::::::::::::::::::::::::::::: Start printing screen
start_print_row:
	;:::::::::::::::::::::::::::::::::::::::::::::::::: Set cursor postion
	PUSH DX 		    ;save current row,column
	MOV AH,2
	INT 10H
	;::::::::::::::::::::::::::::::::::: Read character at current postion
	MOV AH,8
	INT 10H
	;::::::::::::::::::::::::::::::::::::::::::::::::::::: Print character
	OR al,al
	JNZ print_char
	MOV AL,20H
print_char:
	XOR DX,DX
	XOR AH,AH
	INT 17H
	;:::::::::::::::::::::::::::::::::::::::::::: Check for printer errors
	POP DX			;Restore current row,column
	AND AH,25H
	JZ  cont2
	MOV BYTE PTR DS:[100H],0FFH
	JMP short exit_print
	;::::::::::::::::::::::::::::::::::::::::::: Move to mext print column
cont2:
	INC DL			;Inc current column
	CMP DL,CH		;Current col compared to no. of cols
	JB start_print_row
	;:::::::::::::::::::::::::::::::::::::::::: End of column, print CR/LF
	CALL print_crlf
	;:::::::::::::::::::::::::::::::::::::::::::::::::: More rows to print
	INC DH			;Inc current row
	CMP DH,CL		;Current row compared to no. of rows
	JBE start_print_col
	MOV BYTE PTR DS:[0100H],0
	;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Exit print
exit_print:
	;:::::::::::::::::::::::::::::::::::::; Restore orginal cursor postion
	POP DX
	MOV AH,2
	INT 10H
	;:::::::::::::::::::::::::::::::::::::::::::::::::::: Tidy up and exit
end_print:
	POP DS
	POP DX
	POP CX
	POP BX
	POP AX
        jmp iret_com

	;::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Print CR/LF
print_crlf:
	PUSH DX
	XOR DX,DX
	MOV AX,0DH
	INT 17H
	XOR DX,DX
	MOV AX,0AH
	INT 17H
	POP DX
	RET
;	End of int05_vector (print screen).

int06h_vector:
	bop     06h
        jmp     iret_com

; IVT 7 is set to unexpected interrupt.


int08h_vector:
; The usual int8 handler modified for optimum performance.
; - stays in 16 bit code (no BOP)
; - keeps interrupts off when not needed
; - calls int 1c directly
;
        call  DOCLI                ; make sure interrupts stay off until iret

        push  es
        push  ds                  ; save some registers
        push  ax
        push  dx

        mov   ax, 40h             ; set ds to bios data area
        mov   ds, ax
        xor   ax, ax
        mov   es, ax              ; set es to IVT seg for i1c callout

        inc   word ptr ds:[TIMER_LOW]        ; inc time counters
        jnz   i8v1
        inc   word ptr ds:[TIMER_HIGH]
i8v1:
        cmp   word ptr ds:[TIMER_HIGH], 018h  ; check for 24 hours, wrap point
        jnz   i8v2
        cmp   word ptr ds:[TIMER_LOW], 0b0h
        jnz   i8v2


        mov   word ptr ds:[TIMER_HIGH], ax    ; 24 hour wrap, set OVFL bit
        mov   word ptr ds:[TIMER_LOW], ax
        mov   byte ptr ds:[TIMER_OVFL], 1
        or    al, 8                ; set Overflow bit for fake flags

        ;---                       ; skip floppy motor stuff


i8v2:                              ; handle the floppy motor stuff
        push  ax
        dec   byte ptr ds:[MOTOR_COUNT]
        jnz   i8v3
        and   byte ptr ds:[MOTOR_STATUS], 0f0h
        mov   al, 0ch
        mov   dx, 03f2h            ; costly outb happens 1/256 timer tics...
        out   dx, al

i8v3:
        pop   ax
                                   ; call int1c user routine directly
        lahf                       ; get lobyte of flags for fake flags
        xchg  ah,al
        push  ax                   ; put fake flags on the stack
        call  dword ptr es:[1ch*4] ; do it!
        call  DOCLI                ; make sure interrupts stay off until iret

        mov   al, 20h              ; send eoi
        out   20h, al

        pop   dx                   ;restore the stack
        pop   ax
        pop   ds
        pop   es

        jmp     iret_com



int0e_vector:
	bop	0eh
        jmp     iret_com

DOCLI:
        FCLI
        ret

DOSTI:
        FSTI
        ret

;
; Tim August 92. Video BIOS grabber.
; Call SPC BIOS when in windowed mode and the host BIOS when in full-screen.
; Controled by value of 'use_host_int10'. 
; Try to limit bops by validating calling values. Mouse has to get first shot
; and then video bios.
;

use_host_int10     db 01h	; native/softpc bios flag
changing_mode	   db 01h	; delay handshake if in bios mode change

PUBLIC int10h_vector

int10h_vector:
        cmp     use_host_int10, FULLSCREEN
        je      nativebios

	cmp	ah,VID_MODECHANGE	; mode change??
	je	modechange
	cmp	ah,MAX_VIDEO_FUNC	; range check
	ja	mousecheck		; not a vid func but mouse has higher
	cmp	ah,MOUSE_LIGHT_PEN	; light pen special case
	je	mousebios
spcbios:
	bop	EGA_VIDEO_BOP		; regular windowed Int 10
	jmp	viddone

mousecheck:
	cmp	ah,MIN_MOUSE_FUNC	; range check mouse fn f0-f7 + fa.
	jb	badvid
	cmp	ah,MAX_MOUSE_FUNC
	jbe	mousebios
	cmp	ah,XTRA_MOUSE_FUNC
	jne	badvid

mousebios:				; call softpc mouse video entrypoint
	bop	MOUSE_VID_BOP
	jmp	viddone

modechange:			; windowed modechange. Mouse gets a look
	mov	changing_mode,1	; then softpc video bios. If gfx mode then
	bop	MOUSE_VID_BOP	; will go fullscreen
	;;;nop
	;;;nop			; nops aid debugging
	;;;bop	EGA_VIDEO_BOP	; will go fullscreen here
	nop
	nop
	push	ax		; save video mode which may have top bit set
	and	ax,7fh
	cmp	al,3
	jbe	endmode		; if graphics mode, repeat modechange to setup
	cmp	al,7		; video card, else fall through
	je	endmode
	pop	ax
	jmp	nativebios
endmode:
	pop	ax
	mov	changing_mode,0	; Clear 'mode changing' flag.

viddone:
        jmp     iret_com

badvid:				; unrecognised video func
	stc
	jmp viddone
	
nativebios:
	mov	changing_mode,0		; Clear 'mode changing' flag.
	cmp	ax,MS_VIDEO_STRING	; ensure not MS special video string fn
	je	ms_wrt_string

	cmp	ah,MIN_MOUSE_FUNC	; could be a mouse call
	jb	chk_mse_vid
	cmp	ah,MAX_MOUSE_FUNC	; range check mouse fn f0-f7 + fa.
	jbe	mousebios
	cmp	ah,XTRA_MOUSE_FUNC
	je	mousebios
	jmp	jmp_native		; probably bad func but...

chk_mse_vid:
        cmp     ah,MOUSE_LIGHT_PEN      ; mouse handles light pen
        je      mousebios
        cmp     ah,VID_MODECHANGE
        jne     chk_font_change
        bop     MOUSE_VID_BOP   ; mouse wants first sniff at mode changes
        jmp     jmp_native      ; then fall through
chk_font_change:
        cmp     ah,GET_FONT_FUNC
        jne     jmp_native
        bop     MOUSE_VID_BOP   ; select mouse buffer for new no. of lines
                                ; then fall through

jmp_native:
                   db      0EAh     ; far jump
host_int10	   dd	   ?	    ; to native int 10 vector

ms_wrt_string:
	push	si
	push	di
	push	bp
go_loop1:
	mov	dx,46h		; looks a good value for flags
	push	dx		; make an iret frame
	push	cs
	mov	bx, offset go_cont
	push	bx
	mov	bx,7		; set foreground color
	mov	ah,0eh		; set command to write a character
	mov	al,es:[di]	; get char
	inc	di
	jmp	jmp_native	; make far jmp to int 10 vector

go_cont:
	loop	go_loop1	;repeat until all through
	pop	bp
	pop	di
	pop	si
	mov	ax,1		; return success
	jmp	viddone
;
; int 42 - 'old' video bios entry point. Use same windowed/fullscreen
; redirection as Int 10 above.
;
int42h_vector:
        cmp     use_host_int10, FULLSCREEN
        jz      maybe_host_42_bios

	bop	10h	; old video bop
        jmp     iret_com

	; If it's the special BIOS print string function, don't call the
	; host video BIOS cos it won't know what we are talking about.
	; It's only in our video BIOS.
maybe_host_42_bios:
	cmp	AH, 013h
	jnz	gogo_host_42_bios
	cmp	AL, 0ffh
	jz	ms_wrt_string		; reuse path from Int 10

gogo_host_42_bios:
                   db      0EAh     ; far jump
host_int42         dd      ?        ; to native int 42 vector

int10h_caller:
	int	10h	; Re-entrant video entry point.
	bop	0feh

int11h_vector:		; Equipment check.
	bop     11h
        jmp     iret_com
int12h_vector:		; Get memory size, copied from BIOS2.ASM
	bop     12h
        jmp     iret_com

; IVT 13 is floppy io, grabbed above to fake error status.

int14h_vector:		; RS-232 serial comms, copied from BIOS2
	bop     14h
        jmp     iret_com

; Int 15 cassette io, is done above.



; Idle indicators- All word sized, and dword aligned
; Int 16 keyboard vector

        align   4
        public Icounter,CharsPerTick,MinTicks

Icounter        dw  0
                dw  0
CharsPerTick    dw  0
                dw  0
MinTicks        dw  50
                dw  0

int16h_vector:
        push    ds
        push    bx
        mov     bx, 40h           ; bios data adressable
        mov     ds, bx
        cmp     ah, 10h
        call    DOCLI             ; make sure interrupts are off
        jb      i16vStdFns
        jmp     i16vExtFns


        ; The dispatch code must preserve the jz,dec,dec pattern
        ; to return the same ah value as is returned by the
        ; standard bios (0 for supported unless otherwise documented
        ; and nonzero for unsupported). This is because some apps look
        ; at the ret value of ah even tho it is a side effect of the
        ; original dispatch code in the rom bios.

i16vStdFns:
        or      ah, ah
        jz      i16v00h           ; read key, wait
        dec     ah
        jz      i16v01h           ; read key no wait
        dec     ah
        jz      i16v02h           ; get shift state
        dec     ah
        jz      i16viret          ; we don't support ah=3, set kbd rate
        dec     ah
        jz      i16viret          ; undefined function
        dec     ah
        jz      i16v05h           ; push char into kbd buffer
                                  ; the rest are undefined\unsupported

        ; normal iret exit
i16viret:
        pop     bx
        pop     ds
        jmp     iret_com


        ; return shift state in al
i16v02h:
        mov     al, ds:[KB_FLAG]
        jmp     i16viret


i16v05h:
        push    si
        mov     bx, word ptr ds:[BUFFER_TAIL]
        mov     si, bx
        call    IncrBuffPtr
        cmp     bx, word ptr ds:[BUFFER_HEAD]
        je      i16v05h1
        mov     word ptr ds:[si], cx
        mov     word ptr ds:[BUFFER_TAIL], bx
        mov     al, 0
        pop     si
        jmp     i16viret

i16v05h1:
        mov     al, 1
        pop     si
        jmp     i16viret


        ; read a character, wait if none available
i16v00h:
        mov     bx, word ptr ds:[BUFFER_HEAD]
        cmp     bx, word ptr ds:[BUFFER_TAIL]
        jne     i16v00h1
        call    DOSTI
        mov     ax, 09002h
        int     15h              ; wait device

i16v00h0:
        call    DOCLI
        mov     bx, word ptr ds:[BUFFER_HEAD]
        cmp     bx, word ptr ds:[BUFFER_TAIL]

i16v00h1:
        call    UpdateLed
        jne     i16v00h2
        call    IdlePoll
        jmp     i16v00h0

i16v00h2:        ; translate.....
        mov     ax, [bx]
        call    IncrBuffPtr
        mov     word ptr ds:[BUFFER_HEAD], bx
        call    TranslateStd
        jc      i16v00h0
        call    IdleInit
        jmp     i16viret


        ; read a character, nowait if none available
i16v01h:
        mov     bx, word ptr ds:[BUFFER_HEAD]  ;;maybe should turn IF on ??
        cmp     bx, word ptr ds:[BUFFER_TAIL]
        mov     ax, [bx]
        call    UpdateLed
        je      i16vretf1

        call    IdleInit
        call    TranslateStd
        call    DOSTI
        jnc     i16vretf5             ; got a key, all done!
        call    IncrBuffPtr           ; throw away key
        mov     word ptr ds:[BUFFER_HEAD], bx
        jmp     i16v01h               ; go for the next one


        ; ExtKbd read a character, nowait if none available
i16v11h:
        mov     bx, word ptr ds:[BUFFER_HEAD]  ;;maybe should turn IF on ??
        cmp     bx, word ptr ds:[BUFFER_TAIL]
        mov     ax, [bx]
        call    UpdateLed
        je      i16vretf1          ; common retf stuff for nowait

        call    IdleInit
        call    TranslateExt
        call    DOSTI
        jmp     i16vretf5


         ; retf2 exit preserving flags
i16vretf1:
        call  DOSTI
        push  ax
        lahf
        push  ax

        mov   ax, cs:Icounter
        cmp   ax, cs:MinTicks
        jb    i16vretf2

        mov   ah, 1               ; polling kbd, idle now
        BOP   16h
        jmp   i16vretf4

i16vretf2:
        inc   cs:CharsPerTick


i16vretf4:
        pop  ax
        sahf
        pop  ax

i16vretf5:
        pop     bx
        pop     ds
        retf    2



i16vExtFns:
        sub     ah, 10h
        jz      i16v10h           ; extended read key, wait
        dec     ah
        jz      i16v11h           ; extended read key, nowait
        dec     ah
        jz      i16v12h           ; extended shift status
        jmp     i16viret          ; undefined


        ; return extended shift state
i16v12h:
        mov     al, ds:[KB_FLAG_1]
        mov     ah, al
        and     al, SYS_SHIFT
        push    cx
        mov     cl, 5
        shl     al, cl
        pop     cx
        and     ah, NOT (SYS_SHIFT+HOLD_STATE+INS_SHIFT)
        or      al, ah
        mov     ah, ds:[KB_FLAG_3]
        and     ah, NOT (LC_E1+LC_E0)
        or      ah, al
        mov     al, ds:[KB_FLAG]
        jmp     i16viret


        ; ExtKbd read a character, wait if none available
i16v10h:
        mov     bx, word ptr ds:[BUFFER_HEAD]
        cmp     bx, word ptr ds:[BUFFER_TAIL]
        jne     i16v10h1
        call    DOSTI
        mov     ax, 09002h
        int     15h              ; wait device

i16v10h0:
        call    DOCLI
        mov     bx, word ptr ds:[BUFFER_HEAD]
        cmp     bx, word ptr ds:[BUFFER_TAIL]

i16v10h1:
        call    UpdateLed
        jne     i16v10h2
        call    IdlePoll
        jmp     i16v10h0

i16v10h2:        ; translate.....
        mov     ax, [bx]
        call    IncrBuffPtr
        mov     word ptr ds:[BUFFER_HEAD], bx
        call    TranslateExt
        call    IdleInit
        jmp     i16viret



; IdlePoll  - Spins waiting for a key, doing idle callouts as needed
;             flags trashed, all registers preserved
;             interrupts are left on upon exit
;
IdlePoll  proc near
          push  ax

          call  DOSTI
          mov   ah, 2                          ; Idle_waitio
          BOP   16h
IPoll1:
          mov   bx, word ptr ds:[BUFFER_HEAD]
          cmp   bx, word ptr ds:[BUFFER_TAIL]  ; interrupts are off only
          jne   IPoll3                         ; safe to peek for change

          mov   ax, cs:Icounter
          cmp   ax, cs:MinTicks
          jae   IPoll2
          inc   cs:CharsPerTick
          jmp   IPoll1
IPoll2:
          mov   ah, 1                          ; idle now
          BOP   16h
IPoll3:
          pop   ax
          ret
IdlePoll  endp




; IdleInit - reinits the idle indicators, dups functionality
;            of IDLE_init()
;
IdleInit  proc near

          mov cs:Icounter, 0
          mov cs:CharsPerTick, 0

          ret
IdleInit  endp


;  TranslateExt - Retrieves and translates next scan code
;  pair for extended kbd
;
;  input:   ax - raw scan code pair
;  output:  ax - translated scan code pair
;
;  all other flags,registers preserved

TranslateExt proc near

             push    bx
             push    ax
             lahf
             mov     bx, ax
             pop     ax
             push    bx

             cmp     al, 0f0h
             jne     TExt1
             or      ah, ah
             jz      TExt1
             xor     al, al
TExt1:
             mov     bx, ax
             pop     ax
             sahf
             mov     ax, bx
             pop     bx
             ret

TranslateExt endp


;  TranslateStd - Retrieves and translates next scan code
;  pair for standard kbd
;
;  input:   ax - raw scan code pair
;  output:  ax - translated scan code pair
;  returns carry for throw away
;  all other flags,registers preserved

TranslateStd proc near

            push    bx
            push    ax
            lahf
            mov     bx, ax
            pop     ax
            push    bx

            cmp     ah, 0e0h
            jne     TStd1

            ; keypad enter or '/'
            mov     ah, 1ch        ; assume enter key
            cmp     al, 0dh
            je      TStdNoCarry
            cmp     al, 0ah
            je      TStdNoCarry
            mov     ah, 35h        ; oops it was key pad!
            jmp     TStdNoCarry

TStd1:
            cmp     ah, 84h
            ja      TStdCarry      ; extended key ?

            cmp     al, 0f0h       ; fill in key ?
            jne     TStd2
            or      ah, ah         ; ah = 0 is special
            jz      TStdNoCarry
            jmp     TStdCarry

TStd2:
            cmp     al, 0e0h       ; convert to compatible output
            jne     TStdNoCarry
            or      ah, ah
            jz      TStdNoCarry
            xor     al, al

TStdNoCarry:
            mov     bx, ax
            pop     ax
            sahf
            mov     ax, bx
            pop     bx
            clc
            ret

TStdCarry:
            mov     bx, ax
            pop     ax
            sahf
            mov     ax, bx
            pop     bx
            stc
            ret
TranslateStd endp



; IncrBuffPtr - increments the buffer pointer
;
; input:  ds:bx - curr buf ptr
; output: ds:bx - new buf ptr
; does not update the bios buf ptr

IncrBuffPtr  proc near
             inc bx
             inc bx
             cmp bx, word ptr ds:[BUFFER_END]
             jne ibpExit
             mov bx, word ptr ds:[BUFFER_START]
ibpExit:
             ret
IncrBuffPtr  endp



; UpdateLed - forms the data byte for the mode indicators
;             updates the led bits (MAKE_LED,SEND_LED)
;
; input:  none
; output: led bits updated
;
; Caveats: all low flags,registers preserved
;          MUST be called with interrupts off
;          does not update the kbd hardware (send_led)
;
UpdateLed  proc near

           push bx
           push cx
           push ax
           lahf
           push ax

           ; make_led
           mov  al, byte ptr ds:[KB_FLAG]            ; get led bits
           and  al, CAPS_STATE+NUM_STATE+SCROLL_STATE
           mov  cl, 4
           rol  al, cl                               ; shift for kb_flag_2
           and  al, KB_LEDS                          ; only led mode bits

           mov  bl, byte ptr ds:[KB_FLAG_2]
           xor  bl, al                               ; see of different
           and  bl, KB_LEDS                          ; only led mode bits
           jz   UledExit


           test byte ptr ds:[KB_FLAG_2], KB_PR_LED   ;if update under way
           jnz  ULedExit                             ;    skip update
           or   byte ptr ds:[KB_FLAG_2], KB_PR_LED   ;else upd in progress

           mov   ah, 3                               ; inform softpc to set lights
           BOP   16h

           and  byte ptr ds:[KB_FLAG_2], NOT KB_LEDS   ;clear led bits
           or   byte ptr ds:[KB_FLAG_2], al            ;stick in new led bits
           and  byte ptr ds:[KB_FLAG_2], NOT KB_PR_LED ;clear upd bit

ULedExit:
           pop  ax
           sahf
           pop  ax
           pop  cx
           pop  bx

           ret
UpdateLed  endp




; IVT 17 is printer IO, done above.

int18h_vector:		; ROM BASIC, copied from BIOS2.ASM
	bop     18h
        jmp     iret_com
int19h_vector:		; reboot vector, we terminate vdm!
	bop	19h
        jmp     iret_com


IdleTicLo   dw  0
IdleTicHi   dw  0
IdleTicNum  db  0

int1Ah_vector:          ; Time of day.
        call    DOSTI
        cmp     ah, 2
        jl      i1aTic1

        bop     1ah
        jmp     iret_com

i1aTic1:
        push    ds                                  ; bios data adressable
        push    bx
        push    ax
        mov     ax, 40h
        mov     ds, ax
        pop     ax
        call    DOCLI

        or      ah, ah                              ; fn 0 or fn 1 ?
        jnz     i1aTic5

i1aTic2:
        mov     al, byte ptr ds:[TIMER_OVFL]        ; GetTickCount
        mov     cx, word ptr ds:[TIMER_HIGH]
        mov     dx, word ptr ds:[TIMER_LOW]


        ; If time stamp is within 1 tic of curr tic count
        ; do idle polling managment

        cmp     cs:IdleTicHi, cx                    ; check TIMER_HIGH
        jnz     i1aTic8

        mov     bx, cs:IdleTicLo                    ; check TIMER_LOW
        cmp     bx, dx
        jz      i1aTic3
        inc     bx
        cmp     bx, dx
        jnz     i1aTic8


i1aTic3:
        inc     cs:IdleTicNum                       ; Yes, inc poll count
        cmp     cs:IdleTicNum, 16                   ; Is poll count too hi ?
        jb      i1aTic9

        call    DOSTI
        xor     ax,ax                               ; Yes, do idle BOP
        dec     cs:IdleTicLo                        ; make sure only bop once
        BOP     5ah
        call    DOCLI
        jmp     short i1aTic2

i1aTic5:
        mov     word ptr ds:[TIMER_LOW], dx         ; SetTickCount
        mov     word ptr ds:[TIMER_HIGH], cx

i1aTic8:
        mov     cs:IdleTicNum, 0                    ; reset idle indicators

i1aTic9:
        mov     cs:IdleTicLo, dx                    ; store time stamp
        mov     cs:IdleTicHi, cx
        mov     byte ptr ds:[TIMER_OVFL], 0         ; common TicCount exit
        pop     bx
        pop     ds
        jmp     iret_com


; IVT 1B is keyboard break, set to dummy.


int1Eh_vector:
	bop     1eh
        jmp     iret_com

int70h_vector:		; Real time clock, copied from BIOS1.ASM
	bop     70h	; rtc_bios.c:rtc_int()
        jmp     iret_com

int4Ah_caller:
        call    DOSTI   ; Called from base\bios\rtc_bios.c:rtc_int()
	int	4ah	; User installed alarm.
	jmp	r1
r1:	jmp	r2
r2:	jmp	r3
r3:
        call    DOCLI
	bop	0feh

int71h_vector:		; redirect, copied from BIOS1.ASM
	bop     71h
	int	0Ah
        jmp     iret_com
int75h_vector:		; NPX 287.
	bop     75h
	int	02h
        jmp     iret_com
;=================================================================
; End of pseudo-ROM vectuz.
;=================================================================


;================================================================
; Wait for interrupts
;================================================================

cpu_nop_code:
        call    DOSTI
	jmp	short nxt1
nxt1:	jmp	short nxt2
nxt2:	jmp	short nxt3
nxt3:   bop     %BIOS_CPU_QUIT

           public SpcKbdEnd
SpcKbdEnd  label byte

	align	4			;; makes MIPS happy

; offset table for redirected functions
kio_table dw  29 dup(?)

        public InstSpcKbd

;
; InstSpcKbd - Installs the softpc custom interrupt hooks
;
; Inputs:  ds == Resident location of SysInitSeg
; Outputs: None
;
InstSpcKbd   proc near

        pusha
        call    DOCLI

        ; The following vectors are used for both x86\mips
        ; The dos interrupts Int 25\Int26 are handled by the dos kerenl
        xor     ax, ax
        mov     es, ax
        mov     word ptr es:[08h*4], offset int08h_vector
        mov     word ptr es:[(08h*4)+2], ds
        mov     word ptr es:[09h*4], offset int09h_vector
        mov     word ptr es:[(09h*4)+2], ds
        mov     word ptr es:[13h*4], offset int13h_vector
        mov     word ptr es:[(13h*4)+2], ds
        mov     word ptr es:[16h*4], offset int16h_vector
        mov     word ptr es:[(16h*4)+2], ds
        mov     word ptr es:[40h*4], offset int40h_vector
	mov	word ptr es:[(40h*4)+2], ds
	mov	word ptr es:[19h*4], offset int19h_vector
        mov     word ptr es:[(19h*4)+2], ds
        mov     word ptr es:[1ah*4], offset int1Ah_vector
        mov     word ptr es:[(1ah*4)+2], ds



        ; BOP 5F - send interesting addresses to softpc C BIOS
        ;  CS seg of kio_table
        ;  DS seg of resident keyboard code
        ;  DI offset of bop table
        ;  CX size of bop table entry
        ;  SI offset of kio_table
	mov	si,offset sysinitgrp:kio_table
	push	ds
	push	cs
	pop	ds
	mov	word ptr [si],	  offset shift_keys	;K6
	mov	word ptr [si+2],  offset shift_masks   ;K7
	mov	word ptr [si+4],  offset ctl_n_table   ;K8
	mov	word ptr [si+6],  offset ctl_f_table   ;K9
	mov	word ptr [si+8],  offset lowercase     ;K10
	mov	word ptr [si+10], offset uppercase     ;K11
	mov	word ptr [si+12], offset alt_table     ;K30
	mov	word ptr [si+14], offset dummy_vector
	mov	word ptr [si+16], offset print_screen_caller
	mov	word ptr [si+18], offset int15h_caller
	mov	word ptr [si+20], offset cpu_nop_code
        mov     word ptr [si+22], offset int15h_vector
        mov     word ptr [si+24], offset Icounter
        mov     word ptr [si+26], offset int4Ah_caller
	mov	word ptr [si+28], offset keyboard_break_caller
	mov	word ptr [si+30], offset int10h_caller
	mov	word ptr [si+32], offset int10h_vector
	mov	word ptr [si+34], offset use_host_int10
	mov	word ptr [si+36], offset ega_parm_setup
	mov	word ptr [si+38], offset changing_mode
	mov	word ptr [si+40], offset prt_status
	mov	word ptr [si+42], offset wait_int
        mov     word ptr [si+44], offset floppy_table
	mov	word ptr [si+46], offset vga_1b_table
        mov     word ptr [si+48], offset conf_table
        mov     word ptr [si+50], offset int08h_vector
	mov	word ptr [si+52], offset int13h_vector
	mov	word ptr [si+54], offset int13h_caller
; The last entry is reserved for assertion checking
	mov	word ptr [si+56], VERSIONID
	pop	ds

	; mov	 si, offset kio_table
        mov     di, offset iret_bop_table
        mov     cx, offset iret_end_first_entry  - offset iret_bop_table
        mov     ax, VERSIONID
        bop     5fh
        jc      isk_int9
        jmp     isk_Exit
isk_int9:

        ; save old video int
        xor     ax, ax
        mov     es, ax
        mov     bx, es:[40h]
        mov     si, offset host_int10
        mov     word ptr ds:[si], bx
        mov     bx, es:[42h]
        mov     word ptr ds:[si+2], bx

	; save old secondary video int (42h)
        mov     bx, es:[108h]
        mov     si, offset host_int42
        mov     word ptr ds:[si], bx
        mov     bx, es:[10ah]
        mov     word ptr ds:[si+2], bx


;-----------------------------------------------------------
;
; Crazy vector grabber
;
; Works OK on DEC PC when grab INT's 6, 11, 16, 17, 42.
; Now try and avoid all accesses to host ROM.
;
; At this point we assume ES=0
;-----------------------------------------------------------

     ; Grab some prominent vectors for pseudo-ROM routines.
     ; start at Int 0h and work our way up as needed
     cld

     mov   di, 20
     mov   ax, offset int05h_vector  ; INT 05h
     stosw                                             ; Print screen
     mov   ax, ds
     stosw
     mov   ax, offset int06h_vector  ; INT 06h
     stosw                                             ; Illegal instruction.
     mov   ax, ds
     stosw
     mov   ax, offset unexp_int      ; INT 07h
     stosw
     mov   ax, ds
     stosw

     ; int 8h Timer hardware vector already done for both x86\mips
     ; int 9h kbd hardware vector already done for both x86\mips
     add   di, 8

     mov   ax, offset unexp_int      ; INT 0ah
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset unexp_int      ; INT 0bh
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset unexp_int      ; INT 0ch
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset unexp_int      ; INT 0dh
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int0e_vector   ; INT 0eh
     stosw                                             ; Floppy hardware int.
     mov   ax, ds
     stosw
     mov   ax, offset unexp_int      ; INT 0fh
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int10h_vector  ; INT 10h
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int11h_vector  ; INT 11h
     stosw                                             ; Equipment check.
     mov   ax, ds
     stosw
     mov   ax, offset int12h_vector  ; INT 12h
     stosw                                             ; Get memory size.
     mov   ax, ds
     stosw

     ; int 13h already done (see above) for both mips\x86

     mov   di, 14h*4                                   ; Communications.
     mov   ax, offset int14h_vector
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int15h_vector  ; INT 15h
     stosw
     mov   ax, ds
     stosw

     ; int 16h kbd hardware vector already done for both x86\mips
     add   di, 4

     mov   ax, offset int17h_vector  ; INT 17h
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int18h_vector  ; INT 18h
     stosw                                             ; ROM BASIC.
     mov   ax, ds
     stosw

     ; int 19h (reboot vector) already done for both x86\mips

     ; int 1ah, time of day, already done for both x86\mips

     mov   di, 1Bh*4
     mov   ax, offset dummy_vector   ; INT 1Bh
     stosw                                             ; Keyboard break.
     mov   ax, ds
     stosw
     mov   ax, offset dummy_vector  ; INT 1Ch
     stosw                                             ; Timer tick.
     mov   ax, ds
     stosw

     mov   di, 1Eh*4                                   ; Floppy parameters.
     mov   ax, offset bios_floppy_table
     stosw
     mov   ax, ds
     stosw

     ; int 40h already done (see above) for both mips\x86

     mov   di, 41h*4
     mov   ax, offset unexp_int      ; INT 41h
     stosw                                             ; Hard disk parameters.
     mov   ax, ds
     stosw
     mov   ax, offset int42h_vector  ; INT 42h
     stosw                                             ; Default video.
     mov   ax, ds
     stosw

     mov   di, 70h*4                                    ; Real time clock init.
     mov   ax, offset int70h_vector
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int71h_vector  ; INT 71h Redirect.
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset intD11_vector  ; INT 72h D11 int
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset intD11_vector  ; INT 73h D11 int
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset intD11_vector  ; INT 74h D11 int
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int75h_vector  ; INT 75h 287 int
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset intD11_vector  ; INT 76h D11 int
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset intD11_vector  ; INT 77h D11 int
     stosw
     mov   ax, ds
     stosw


isk_Exit:
     call  DOSTI
     popa
     ret

InstSpcKbd  endp

SpcKbdSeg    ends
             end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\sysconf.asm ===
page	,160
	title	bios system initialization
;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------

	include version.inc		; set version build flags
	include biosseg.inc		; establish bios segment structure

lf	equ	10
cr	equ	13
tab	equ	 9

have_install_cmd      equ     00000001b ; config.sys has install= commands
has_installed	      equ     00000010b ; sysinit_base installed.

default_filenum = 8

	break	macro	; dummy empty macro
	endm

	include sysvar.inc
	include	pdb.inc			; M020
	include syscall.inc
	include doscntry.inc
	include devsym.inc
	include devmark.inc

	include	umb.inc
	include	dossym.inc
        include dossvc.inc
        include cmdsvc.inc
        include softpc.inc

stacksw equ	true		;include switchable hardware stacks

	if	ibmjapver
noexec	equ	true
	else
noexec	equ	false
	endif




; external variable defined in ibmbio module for multi-track

multrk_on	equ	10000000b	;user spcified mutitrack=on,or system turns
					; it on after handling config.sys file as a
					; default value,if multrk_flag = multrk_off1.
multrk_off1	equ	00000000b	;initial value. no "multitrack=" command entered.
multrk_off2	equ	00000001b	;user specified multitrack=off.

Bios_Data segment 
	extrn	multrk_flag:word
	extrn	keyrd_func:byte
	extrn	keysts_func:byte
Bios_Data ends

; end of multi-track definition.

sysinitseg	segment 

assume	cs:sysinitseg,ds:nothing,es:nothing,ss:nothing

	extrn	badopm:byte,crlfm:byte,badcom:byte,badmem:byte,badblock:byte
	extrn	badsiz_pre:byte,badld_pre:byte
	extrn	badstack:byte,badcountrycom:byte
	extrn	badcountry:byte,insufmemory:byte
	extrn	condev:byte,auxdev:byte,prndev:byte,commnd:byte,config:byte
	extrn	cntry_drv:byte,cntry_root:byte,cntry_path:byte
	extrn	memory_size:word
	extrn	buffers:word
	extrn	files:byte,num_cds:byte
	extrn	dosinfo:dword
	extrn	fcbs:byte,keep:byte
	extrn	confbot:word,alloclim:word,command_line:byte
	extrn	zero:byte,sepchr:byte
	extrn	count:word,chrptr:word,cntryfilehandle:word
	extrn	memlo:word,memhi:word,prmblk:word,ldoff:word
	extrn	packet:byte,unitcount:byte,break_addr:dword
	extrn	bpb_addr:dword,drivenumber:byte,sysi_country:dword
	extrn	config_size:word
	extrn	install_flag:word
	extrn	badorder:byte
	extrn	errorcmd:byte
	extrn	linecount:word
	extrn	showcount:byte
	extrn	buffer_linenum:word
	extrn	h_buffers:word
	extrn	badparm:byte
	extrn	configmsgflag:word
	extrn	org_count:word
	extrn	multi_pass_id:byte

	extrn	mem_err:near,setdoscountryinfo:near
	extrn	pararound:near,tempcds:near
	extrn	set_country_path:near,move_asciiz:near,delim:near
	extrn	badfil:near,round:near
	extrn	do_install_exec:near
	extrn	setdevmark:near

	extrn	print:near,organize:near,newline:near
	extrn	parseline:near
	extrn	badload:near,calldev:near,prnerr:near

	extrn	runhigh:byte
	extrn	IsXMSLoaded:near

	extrn	TryToMovDOSHi:near

ifdef DBCS
	extrn	testkanj:near
endif

        extrn   bEchoConfig:byte  ; NTVDM flag off\on echo of cfg processing

	if	stacksw

; internal stack parameters

entrysize	equ	8

mincount	equ	8
defaultcount	equ	9
maxcount	equ	64

minsize 	equ	32
defaultsize	equ	128
maxsize 	equ	512

DOS_FLAG_OFFSET	equ	86h

	extrn  stack_count:word
	extrn  stack_size:word
	extrn  stack_addr:dword

	endif

	public doconf
	public getchr
	public multi_pass
        public AllocUMB
        public AllocUMBLow      ; NTVDM
	public	multdeviceflag
multdeviceflag	db	0
	public	devmark_addr
devmark_addr	dw	?		;segment address for devmark.
	public	setdevmarkflag
setdevmarkflag	    db	    0		;flag used for devmark

ems_stub_installed  db	    0

IFDEF	DONT_LOAD_OS2_DD		; M045

Os2ChkBuf	DD	0		; Tmp read buffer

ENDIF					; M045

badparm_ptr	label	dword
badparm_off	dw	0
badparm_seg	dw	0

;******************************************************************************
;take care of config.sys file.
;system parser data and code.
;******************************************************************************

;*******************************************************************
; parser options set for msbio sysconf module
;*******************************************************************
;
;**** default assemble swiches definition **************************

	ifndef	farsw
farsw	equ	0	; near call expected
	endif

	ifndef	datesw
datesw	equ	0	; check date format
	endif

	ifndef	timesw
timesw	equ	0	; check time format
	endif

	ifndef	filesw
filesw	equ	1	; check file specification
	endif

	ifndef	capsw
capsw	equ	0	; perform caps if specified
	endif

	ifndef	cmpxsw
cmpxsw	equ	0	; check complex list
	endif

	ifndef	numsw
numsw	equ	1	; check numeric value
	endif

	ifndef	keysw
keysw	equ	0	; support keywords
	endif

	ifndef	swsw
swsw	equ	1	; support switches
	endif

	ifndef	val1sw
val1sw	equ	1	; support value definition 1
	endif

	ifndef	val2sw
val2sw	equ	0	; support value definition 2
	endif

	ifndef	val3sw
val3sw	equ	1	; support value definition 3
	endif

	ifndef	drvsw
drvsw	equ	1	; support drive only format
	endif

	ifndef	qussw
qussw	equ	0	; support quoted string format
	endif


	include parse.asm		;together with psdata.inc

;control block definitions for parser.
;---------------------------------------------------
; buffer = [n | n,m] {/e}

p_parms struc
	dw	?
	db	1		; an extra delimiter list
	db	1		; length is 1
	db	';'		; delimiter
p_parms ends

p_pos	struc
	dw	?		; numeric value??
	dw	?		; function
	dw	?		; result value buffer

; note: by defining result_val before this structure, we could remove
;  the "result_val" from every structure invocation

	dw	?		; value list
	db	0		; no switches/keywords
p_pos	ends

p_range struc
	db	1		; range definition
	db	1		; 1 definition of range
	db	1		; item tag for this range
	dd	?		; numeric min
	dd	?		; numeric max
p_range ends

buf_parms p_parms <buf_parmsx>
buf_parmsx dw	201h,buf_pos1,buf_pos2	; min 1, max 2 positionals
	   db	1			; one switch
	   dw	sw_x_ctrl
	   db	0			; no keywords

buf_pos1    p_pos   <8000h,0,result_val,buf_range_1> ; numeric
buf_range_1 p_range <,,,1,99>			     ; M050
buf_pos2    p_pos   <8001h,0,result_val,buf_range_2> ; optional num.
buf_range_2 p_range <,,,0,8>

sw_x_ctrl p_pos <0,0,result_val,noval,1> ; followed by one switch
switch_x  db	'/X',0			; M016

p_buffers	dw	0	; local variables
p_h_buffers	dw	0
p_buffer_slash_x db	0

;common definitions ------------
noval	db	0

result_val	label	byte
	db	?		; type returned
	db	?		; item tag returned
	dw	?		; es:offset of the switch defined
rv_byte 	label	byte
rv_dword dd	?		; value if number,or seg:offset to string.
;-------------------------------

; break = [ on | off ]

brk_parms	p_parms  <brk_parmsx>

brk_parmsx dw	101h,brk_pos	; min,max = 1 positional
	   db	0		; no switches
	   db	0		; no keywords

brk_pos p_pos	<2000h,0,result_val,on_off_string> ; simple string

on_off_string	label	byte
	db	3		; signals that there is a string choice
	db	0		; no range definition
	db	0		; no numeric values choice
	db	2		; 2 strings for choice
	db	1		; the 1st string tag
	dw	on_string
	db	2		; the 2nd string tag
	dw	off_string

on_string	db	"ON",0
off_string	db	"OFF",0

p_ctrl_break	db	0	; local variable

;--------------------------------

; country = n {m {path}}
; or
; country = n,,path

cntry_parms	p_parms <cntry_parmsx>

cntry_parmsx dw	301h,cntry_pos1,cntry_pos2,cntry_pos3 ; min 1, max 3 pos.
	     db	0		; no switches
	     db	0		; no keywords

cntry_pos1 p_pos <8000h,0,result_val,cc_range> ; numeric value
cc_range p_range <,,,1,999>
cntry_pos2 p_pos <8001h,0,result_val,cc_range> ; optional num.
cntry_pos3 p_pos <201h,0,result_val,noval>     ; optional filespec

p_cntry_code	dw	0	; local variable
p_code_page	dw	0	; local variable

;--------------------------------

; files = n

files_parms	p_parms <files_parmsx>

files_parmsx dw	101h,files_pos	; min,max 1 positional
	     db	0		; no switches
	     db	0		; no keywords

files_pos   p_pos   <8000h,0,result_val,files_range,0> ; numeric value
files_range p_range <,,,8,255>

p_files db	0		; local variable

;-------------------------------

; fcbs = n,m

fcbs_parms	p_parms <fcbs_parmsx>

fcbs_parmsx dw	201h,fcbs_pos_1,fcbs_pos_2 ; min,max = 2 positional
	    db	0		; no switches
	    db	0		; no keywords

fcbs_pos_1	p_pos	<8000h,0,result_val,fcbs_range> ; numeric value
fcbs_range	p_range	<,,,1,255>
fcbs_pos_2	p_pos	<8000h,0,result_val,fcbs_keep_range> ; numeric value
fcbs_keep_range p_range <,,,0,255>

p_fcbs	db	0		; local variable
p_keep	db	0		; local variable

;-------------------------------
; lastdrive = x

ldrv_parms	p_parms <ldrv_parmsx>

ldrv_parmsx dw	101h,ldrv_pos	; min,max = 1 positional
	    db	0		; no switches
	    db	0		; no keywords

ldrv_pos p_pos	<110h,10h,result_val,noval> ; drive only, ignore colon
					    ; remove colon at end
p_ldrv	db	0		; local variable

;-------------------------------

; stacks = n,m

stks_parms	p_parms <stks_parmsx>

stks_parmsx dw	202h,stks_pos_1,stks_pos_2 ; min,max = 2 positionals
	    db	0		; no switches
	    db	0		; no keywords

stks_pos_1     p_pos   <8000h,0,result_val,stks_range> ; numeric value
stks_range     p_range <,,,0,64>
stks_pos_2     p_pos   <8000h,0,result_val,stk_size_range> ; numeric value
stk_size_range p_range <,,,0,512>

p_stack_count	dw	0	; local variable
p_stack_size	dw	0	; local variable

;-------------------------------

; multitrack = [ on | off ]

mtrk_parms	p_parms <mtrk_parmsx>

mtrk_parmsx dw	101h,mtrk_pos	; min,max = 1 positional
	    db	0		; no switches
	    db	0		; no keywords

mtrk_pos p_pos	<2000h,0,result_val,on_off_string> ; simple string

p_mtrk	db	0		; local variable

;-------------------------------
; switches=/k

swit_parms	p_parms <swit_parmsx>

swit_parmsx dw	0		; no positionals
	    db	3		; 2 switches for now.	M059 M063
	    dw	swit_k_ctrl	; /k control
	    dw	swit_t_ctrl	; /t control		M059
	    dw	swit_w_ctrl	; /w control		M063
	    db	0		; no keywords

swit_k_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows
swit_k db	'/K',0
swit_t_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows	M059
swit_t db	'/T',0			   ;				M059
swit_w_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows	M063
swit_w db	'/W',0			   ;				M063

p_swit_k	db     0	; local variable
p_swit_t	db     0	; local variable			M059
p_swit_w	db     0	; local variable			M063

;-------------------------------

; DOS = [ high | low ]

dos_parms	p_parms  <dos_parmsx>

dos_parmsx db	1		; min parameters
	   db	2		; max parameters
	   dw	dos_pos		; 
	   dw	dos_pos		; 
	   db	0		; no switches
	   db	0		; no keywords

dos_pos p_pos	<2000h,0,result_val,dos_strings> ; simple string
        p_pos	<2000h,0,result_val,dos_strings> ; simple string

dos_strings	label	byte
	db	3		; signals that there is a string choice
	db	0		; no range definition
	db	0		; no numeric values choice
	db	4		; 4 strings for choice
	db	1		; the 1st string tag
	dw	hi_string
	db	2		; the 2nd string tag
	dw	lo_string
	db	3
	dw	umb_string
	db	4
	dw	noumb_string

hi_string	db	"HIGH",0
lo_string	db	"LOW",0
umb_string	db	"UMB",0
noumb_string	db	"NOUMB",0

p_dos_hi	db	0	; local variable
				; BUGBUG : I dont know whether PARSER uses
				;          this variable or not



;******************************************************************************

		public	DevEntry

DevSize		dw	?	; size of the device driver being loaded(paras)
DevLoadAddr	dw	?	; Mem addr where the device driver is 2 b loaded
DevLoadEnd	dw	?	; MaxAddr to which device can be loaded
DevEntry	dd	?	; Entry point to the device driver
DevBrkAddr	dd	?	; Break address of the device driver
;
DevUMB		db	0	; byte indicating whether to load DDs in UMBs
DevUMBAddr	dw	0	; cuurent UMB used fro loading devices (paras)
DevUMBSize	dw	0	; Size of the current UMB being used   (paras)
DevUMBFree	dw	0	; Start of free are in the current UMB (paras)
;
DevXMSAddr	dd	?
;
DevExecAddr	dw	?	; Device load address parameter to Exec call
DevExecReloc	dw	?	; Device load relocation factor
;
DeviceHi	db	0	; Flag indicating whther the current device
				;  is being loaded into UMB
DevSizeOption	dw	?	; SIZE= option
;
Int12Lied	db	0	; did we trap int 12 ?
OldInt12Mem	dw	?	; value in 40:13h (int 12 ram)
ThreeComName	db	'PROTMAN$'	; 3Com Device name
;
FirstUMBLinked	db	0
DevDOSData	dw	?	; segment of DOS Data
DevCmdLine	dd	?	; Current Command line
DevSavedDelim	db	?	; The delimiter which was replaced with null
				; to use the file name in the command line
;
;----------------------------------------------------------------------------
;
; procedure : doconf
;
;             Config file is parsed intitially with this routine. For the
;             Subsequent passes 'multi_pass' entry is used .
;
;----------------------------------------------------------------------------
;
doconf	proc	near
	push	cs
	pop	ds
	assume	ds:sysinitseg

	mov	ax,(char_oper shl 8)	;get switch character
	int	21h
	mov	[command_line+1],dl	; set in default command line

	mov	dx,offset config	;now pointing to file description
	mov	ax,open shl 8		;open file "config.sys"
	stc				;in case of int 24
	int	21h			;function request
	jnc	noprob			; brif opened okay
	mov	multi_pass_id,11	; set it to unreasonable number
	ret
noprob: 				;get file size (note < 64k!!)
	mov	bx,ax
	xor	cx,cx
	xor	dx,dx
	mov	ax,(lseek shl 8) or 2
	int	21h
	mov	[count],ax

	xor	dx,dx
	mov	ax,lseek shl 8		;reset pointer to beginning of file
	int	21h

	mov	dx,[confbot]		;use current confbot value
	mov	ax,[count]
	mov	[config_size],ax	;save the size of config.sys file.
	call	pararound
	sub	dx,ax
	sub	dx,11h			;room for header
	mov	[confbot],dx		; config starts here. new conbot value.
	call	tempcds 		; finally get cds to "safe" location
	assume	ds:nothing,es:nothing

	mov	dx,[confbot]
	mov	ds,dx
	mov	es,dx
	xor	dx,dx
	mov	cx,[count]
	mov	ah,read
	stc				;in case of int 24
	int	21h			;function request
	pushf

; find the eof mark in the file.  if present,then trim length.

	push	ax
	push	di
	push	cx
	mov	al,1ah			; eof mark
	mov	di,dx			; point ro buffer
	jcxz	puteol			; no chars
	repnz	scasb			; find end
	jnz	puteol			; none found and count exahusted

; we found a 1a.  back up

	dec	di			; backup past 1a

;  just for the halibut,stick in an extra eol

puteol:
	mov	al,cr
	stosb
	mov	al,lf
	stosb
	sub	di,dx			; difference moved
	mov	count,di		; new count

	pop	cx
	pop	di
	pop	ax

	push	cs
	pop	ds
	assume	ds:sysinitseg

	push	ax
	mov	ah,close
	int	21h
	pop	ax
	popf
	jc	conferr 		;if not we've got a problem
	cmp	cx,ax
	jz	getcom			;couldn't read the file

conferr:
	mov	dx,offset config	;want to print config error
	call	badfil
endconv:
	ret
;
;----------------------------------------------------------------------------
;
; entry : multi_pass
;
;             called to execute device=,install= commands
;
;----------------------------------------------------------------------------
;

multi_pass:
	push	cs
	pop	ds

	cmp	multi_pass_id,10
	jae	endconv 		; do nothing. just return.

	push	confbot
	pop	es			; es -> confbot

	mov	si,org_count
	mov	count,si		; set count
	xor	si,si
	mov	chrptr,si		; reset chrptr,linecount
	mov	linecount,si
	call	getchr
	jmp	short conflp

getcom:
	call	organize		;organize the file
	call	getchr

conflp: jc	endconv

;***	call	reset_dos_version	; still need to reset version even ibmdos handles this through
;***					; function 4bh call,since ibmdos does not know when load/overlay call finishes.

	inc	linecount		; increase linecount.
	mov	multdeviceflag,0	; reset multdeviceflag.
	mov	setdevmarkflag,0	; reset setdevmarkflag.
	cmp	al,lf			; linefeed?
	je	blank_line		;  then ignore this line.

	mov	ah,al
	call	getchr
	jnc	tryi

	cmp	multi_pass_id,2
	jae	endconv 		;do not show badop again for multi_pass.
	jmp	badop

coff:	push	cs
	pop	ds
	call	newline
	jmp	conflp

blank_line:
	call	getchr
	jmp	conflp

coff_p:
	push	cs
	pop	ds


;to handle install= commands,we are going to use multi-pass.
;the first pass handles the other commands and only set install_flag when
;it finds any install command.	 the second pass will only handle the
;install= command.

;------------------------------------------------------------------------------
;install command
;------------------------------------------------------------------------------
tryi:
        cmp     multi_pass_id,0         ; the initial pass for DOS=HI
        je      multi_try_doshi

        cmp     multi_pass_id,2         ; the second pass was for ifs=
        je      coff                    ; now it is NOPs
					; This pass can be made use of if
					; we want do some config.sys process
					; after device drivers are loaded
					; and before install= commands
					; are processed

	cmp	multi_pass_id,3		; the third pass for install= ?
	je	multi_try_i
	cmp	ah, 'H'
        je      coff
        cmp     ah, 'E'
        je      coff
	cmp	ah,'I'			; install= command?
	jne	tryb				; the first pass is for normal operation.
	or	install_flag,have_install_cmd	; set the flag
	jmp	coff				; and handles the next command

multi_try_i:
	cmp	ah,'I'			; install= command?
	jne	multi_pass_filter	; no. ignore this.
	call	do_install_exec 	;install it.
	jmp	coff			;to handle next install= command.

multi_pass_filter:
	cmp	ah,'Y'			; comment?
	je	multi_pass_adjust
	cmp	ah,'Z'			; bad command?
	je	multi_pass_adjust
	cmp	ah,'0'			; rem?
        jne     coff         ; ignore the rest of the commands.

multi_pass_adjust:			; these commands need to
	dec	chrptr			;  adjust chrptr,count
	inc	count			;  for newline proc.

multi_pass_coff:
	jmp	coff			; to handle next install= commands.



;----------------------------------------------------------------------------
; DOS=HIGH/LOW command
;
; EchoConfig command turns on con echo for config processing
;            NTVDM 14-Aug-1992 Jonle
;----------------------------------------------------------------------------
;
multi_try_doshi:
	cmp	ah, 'H'
        je      it_is_h
        cmp     ah, 'E'
        jne     multi_pass_filter

        mov     cs:bEchoConfig, ah     ; init console
        CMDSVC  SVC_CMDINITCONSOLE
        jmp     coff


it_is_h:                                ; M003 - removed initing DevUMB
					;	 & runhigh
	mov	di,offset dos_parms
	xor	cx,cx
	mov	dx,cx
h_do_parse:
	call	sysinit_parse
	jnc	h_parse_ok		; parse error
h_badparm:
	call	badparm_p		;  show message and end the serach loop.
	jmp	short h_end

h_parse_ok:
	cmp	ax,$p_rc_eol		; end of line?
	jz	h_end			; then end the $endloop
	call	ProcDOS
	jmp	short h_do_parse
h_end:
	jmp	coff


;------------------------------------------------------------------------------
; buffer command
;------------------------------------------------------------------------------
;*******************************************************************************
;									      *
; function: parse the parameters of buffers= command.			      *
;									      *
; input :								      *
;	es:si -> parameters in command line.				      *
; output:								      *
;	buffers set							      *
;	buffer_slash_x	flag set if /x option chosen.			      *
;	h_buffers set if secondary buffer cache specified.		      *
;									      *
; subroutines to be called:						      *
;	sysinit_parse							      *
; logic:								      *
; {									      *
;	set di points to buf_parms;  /*parse control definition*/	      *
;	set dx,cx to 0; 						      *
;	reset buffer_slash_x;						      *
;	while (end of command line)					      *
;	{ sysinit_parse;						      *
;	  if (no error) then						      *
;	       if (result_val.$p_synonym_ptr == slash_e) then /*not a switch  *
;		    buffer_slash_x = 1					      *
;	       else if	 (cx == 1) then 	    /* first positional */    *
;			  buffers = result_val.$p_picked_val;		      *
;		    else  h_buffers = result_val.$p_picked_val; 	      *
;	  else	{show error message;error exit} 			      *
;	};								      *
;	if (buffer_slash_x is off & buffers > 99) then show_error;	      *
; };									      *
;									      *
;*******************************************************************************

tryb:
	cmp	ah,'B'
        jnz     tryc

        ; NTVDM - buffers command is ignored
        ; 15-Aug-1992 Jonle
        jmp     coff

if  0
        mov     p_buffer_slash_x,0
        mov     di,offset buf_parms
        xor     cx,cx
        mov     dx,cx

do7:
        call    sysinit_parse
        jnc     if7                     ; parse error,
        call    badparm_p               ;   and show messages and end the search loop.
        jmp     short sr7

if7:
        cmp     ax,$p_rc_eol            ; end of line?
        jz      en7                     ;  then jmp to $endloop for semantic check
        cmp     result_val.$p_synonym_ptr,offset switch_x
        jnz     if11

;       mov     p_buffer_slash_x,1      ; set the flag M016
	jmp	short en11

if11:
	mov	ax,word ptr result_val.$p_picked_val
	cmp	cx,1
	jnz	if13

	mov	p_buffers,ax
	jmp	short en11

if13:
	mov	p_h_buffers,ax
en11:
	jmp	do7

en7:
	cmp	p_buffers,99
	jbe	if18
;	cmp	p_buffer_slash_x,0	; M016
;	jnz	if18

	call	badparm_p
	mov	p_h_buffers,0
	jmp	short sr7

if18:
	mov	ax,p_buffers	; we don't have any problem.
	mov	buffers,ax	; now,let's set it really.

	mov	ax,p_h_buffers
	mov	h_buffers,ax

;	mov	al,p_buffer_slash_x	; M016
;	mov	buffer_slash_x,al

	mov	ax,linecount
	mov	buffer_linenum,ax ; save the line number for the future use.

sr7:
        jmp     coff
endif


;------------------------------------------------------------------------------
; break command
;------------------------------------------------------------------------------
;****************************************************************************
;									    *
; function: parse the parameters of break = command.			    *
;									    *
; input :								    *
;	es:si -> parameters in command line.				    *
; output:								    *
;	turn the control-c check on or off.				    *
;									    *
; subroutines to be called:						    *
;	sysinit_parse							    *
; logic:								    *
; {									    *
;	set di to brk_parms;						    *
;	set dx,cx to 0; 						    *
;	while (end of command line)					    *
;	{ sysinit_parse;						    *
;	  if (no error) then						    *
;	       if (result_val.$p_item_tag == 1) then	  /*on		 */ *
;		   set p_ctrl_break,on;					    *
;	       else					  /*off 	 */ *
;		   set p_ctrl_break,off;				    *
;	  else {show message;error_exit};				    *
;	};								    *
;	if (no error) then						    *
;	   dos function call to set ctrl_break check according to	    *
; };									    *
;									    *
;****************************************************************************

tryc:
	cmp	ah,'C'
	jnz	trym
	mov	di,offset brk_parms
	xor	cx,cx
	mov	dx,cx
do22:
	call	sysinit_parse
	jnc	if22			; parse error
	call	badparm_p		;  show message and end the serach loop.
	jmp	short sr22

if22:
	cmp	ax,$p_rc_eol		; end of line?
	jz	en22			; then end the $endloop
	cmp	result_val.$p_item_tag,1
	jnz	if26

	mov	p_ctrl_break,1		; turn it on
	jmp	short en26

if26:
	mov	p_ctrl_break,0		; turn it off
en26:
	jmp	short do22		; we actually set the ctrl break

en22:
	mov	ah,set_ctrl_c_trapping ; if we don't have any parse error.
	mov	al,1
	mov	dl,p_ctrl_break
	int	21h
sr22:
	jmp	coff

;------------------------------------------------------------------------------
; multitrack command
;------------------------------------------------------------------------------
;******************************************************************************
;									      *
; function: parse the parameters of multitrack= command.		      *
;									      *
; input :								      *
;	es:si -> parameters in command line.				      *
; output:								      *
;	turn multrk_flag on or off.					      *
;									      *
; subroutines to be called:						      *
;	sysinit_parse							      *
; logic:								      *
; {									      *
;	set di to brk_parms;						      *
;	set dx,cx to 0; 						      *
;	while (end of command line)					      *
;	{ sysinit_parse;						      *
;	  if (no error) then						      *
;	       if (result_val.$p_item_tag == 1) then	  /*on		 */   *
;		   set p_mtrk,on;					      *
;	       else					  /*off 	 */   *
;		   set p_mtrk,off;					      *
;	  else {show message;error_exit};				      *
;	};								      *
;	if (no error) then						      *
;	   dos function call to set multrk_flag according to p_mtrk.	      *
;									      *
; };									      *
;									      *
;******************************************************************************

trym:
	cmp	ah,'M'
	jnz	tryu

	mov	di,offset mtrk_parms
	xor	cx,cx
	mov	dx,cx
do31:
	call	sysinit_parse
	jnc	if31		; parse error
	call	badparm_p	;  show message and end the serach loop.
	jmp	short sr31
if31:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en31		; then end the $endloop

	cmp	result_val.$p_item_tag,1
	jnz	if35

	mov	p_mtrk,1	; turn it on temporarily.
	jmp	short en35

if35:
	mov	p_mtrk,0	; turn it off temporarily.
en35:
	jmp	short do31	; we actually set the multrk_flag here

en31:
	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume	ds:Bios_Data

	cmp	p_mtrk,0
	jnz	if39

	mov	multrk_flag,multrk_off2	; 0001h
	jmp	short en39

if39:
	mov	multrk_flag,multrk_on	; 8000h
en39:
	pop	ds
	assume	ds:sysinitseg
sr31:
	jmp	coff


;
;-----------------------------------------------------------------------------
; devicehigh command
;-----------------------------------------------------------------------------
;
	assume	ds:nothing
tryu:
	cmp	ah, 'U'
	jne	tryd
	mov	badparm_off, si		; stash it there in case of an error
	mov	badparm_seg, es
	call	ParseSize		; process the size= option
	jnc	@f
	call	badparm_p
	jmp	coff
@@:
	push	si
	push	es
@@:
	mov	al, es:[si]
	cmp	al, cr
	je	@f
	cmp	al, lf
	je	@f
	call	delim
	jz	@f
	inc	si
	jmp	@b
@@:
	mov	DevSavedDelim, al	; Save the delimiter before replacing
					;  it with null
	mov	byte ptr es:[si], 0
	pop	es
	pop	si

	mov	DeviceHi, 0
	cmp	DevUMB, 0		; do we support UMBs
	je	LoadDevice		; no, we don't
	mov	DeviceHi, 1
	jmp	short LoadDevice
;
;------------------------------------------------------------------------------
; device command
;------------------------------------------------------------------------------

	assume	ds:nothing
tryd:
	cmp	ah,'D'
	jz	gotd
	jmp	tryq
gotd:
	mov	DeviceHi, 0		; not to be loaded in UMB ;M007
	mov	DevSizeOption, 0
	mov	DevSavedDelim, ' '	; In case of DEVICE= the null has to
					;  be replaced with a ' '

LoadDevice:
	mov	bx,cs			;device= or devicehigh= command.
	mov	ds,bx

	mov	word ptr [bpb_addr],si	; pass the command line to the dvice
	mov	word ptr [bpb_addr+2],es

	mov	word ptr DevCmdLine, si	; save it for ourself
	mov	word ptr DevCmdLine+2, es

	call	round

	call	SizeDevice
        jc      BadFile

        call    InitDevLoad

	mov	ax, DevLoadAddr
	add	ax, DevSize
	jc	NoMem
	cmp	DevLoadEnd, ax
	jae	LoadDev

NoMem:
	jmp	mem_err

BadFile:
	cmp	byte ptr es:[si], cr
	jne	@f
	jmp	badop
@@:
	call	badload
	jmp	coff

LoadDev:
	push	es
	pop	ds
	assume	ds:nothing
	mov	dx,si			;ds:dx points to file name

	if	noexec
	les	bx,dword ptr cs:[memlo]
	call	ldfil			;load in the device driver

	else

	call	ExecDev			; load device driver using exec call

	endif

badldreset:
	push	ds
	pop	es			;es:si back to config.sys
	push	cs
	pop	ds			;ds back to sysinit
	jc	BadFile
goodld:
	push	es
	push	si			; ???

	call	RemoveNull

        push    es
        push    si

	push	cs
	pop	es


;NTVDM: block device drivers are not supported.
;       Putup user warning popup for unsupported device driver
;       29-Sep-1992 Jonle
;
        push    ds
	push	si
        lds     si, DevEntry                    ; peek the header attribute
        test    word ptr ds:[si.sdevatt],devtyp ; IS block device driver?
        pop     si
        pop     ds
        jnz     got_device_com_cont             ; no!

        pop     si                              ;clear the stack
        pop     es

        mov     ax, NOSUPPORT_DRIVER
        BOP     BOP_NOSUPPORT
        jmp     short erase_dev_do

got_device_com_cont:

	call	LieInt12Mem
	call	UpdatePDB		; update the PSP:2 value M020

	cmp	cs:multdeviceflag, 0	; Pass limit only for the 1st device
					;  driver in the file ; M027
	jne	skip_pass_limit		;		      ; M027

	mov	word ptr break_addr, 0	; pass the limit to the DD
	mov	bx, DevLoadEnd
	mov	word ptr break_addr+2, bx
skip_pass_limit:					      ; M027
	mov	bx,sdevstrat
	call	calldev 		;   calldev (sdevstrat);
	mov	bx,sdevint
	call	calldev 		;   calldev (sdevint);

	call	TrueInt12Mem

	mov	ax, word ptr break_addr	; move break addr from the req packet
	mov	word ptr DevBrkAddr, ax
	mov	ax, word ptr break_addr+2
	mov	word ptr DevBrkAddr+2, ax

	assume	ds:nothing

	cmp	DevUMB, 0
	jz	@f
	call	AllocUMB
@@:

;
;------ If we are waiting to be moved into hma lets try it now !!!
;
	cmp	runhigh, 0ffh
	jne	@f

	call	TryToMovDOSHi		; move DOS into HMA if reqd
@@:

	pop	si
	pop	ds
	mov	byte ptr [si],0 	;   *p = 0;

	push	cs
	pop	ds

	jmp	short was_device_com


erase_dev_do:                           ; modified to show message "error in config.sys..."
	pop	si
	pop	es

	push	cs
	pop	ds

;	test	[setdevmarkflag],setbrkdone	;if already set_break is done,
;	jnz	skip1_resetmemhi		; then do not
;	dec	[memhi] 			;adjust memhi by a paragrah of devmark.

skip1_resetmemhi:
	cmp	configmsgflag,0
	je	no_error_line_msg

	call	error_line		; no "error in config.sys" msg for device driver. dcr d493
	mov	configmsgflag,0		;set the default value again.

no_error_line_msg:
	jmp	coff
;
;----------------------------------------------------------------------------
;
was_device_com:
	mov	ax,word ptr [DevBrkAddr+2]
	cmp	ax,DevLoadEnd
	jbe	breakok

	pop	si
	pop	es
	jmp	BadFile

breakok:
        lds     si,DevEntry             ;ds:si points to header
        les     di,cs:[dosinfo]         ;es:di point to dos info
        mov     ax,ds:[si.sdevatt]      ;ax    Dev attributes
;
;------ lets deal with character devices,
;       NTVDM: removed check for block drivers, jonle
;
ischardev:
        or      cs:[setdevmarkflag],for_devmark
	call	DevSetBreak		; go ahead and alloc mem for device
        jc      erase_dev_do            ;device driver's init routine failed.

	test	ax,iscin		;is it a console in?
	jz	tryclk

        mov     word ptr es:[di.sysi_con],si
	mov	word ptr es:[di.sysi_con+2],ds

tryclk: test	ax,isclock		;is it a clock device?
        jz      linkit

        mov     word ptr es:[di+sysi_clock],si
	mov	word ptr es:[di+sysi_clock+2],ds

linkit:

        mov     cx,word ptr es:[di.sysi_dev]    ;dx:cx = head of list
	mov	dx,word ptr es:[di.sysi_dev+2]

        mov     word ptr es:[di.sysi_dev],si    ;set head of list in dos
	mov	word ptr es:[di.sysi_dev+2],ds
	mov	ax,ds:[si]			;get pointer to next device
	mov	word ptr cs:[DevEntry],ax	;and save it

	mov	word ptr ds:[si],cx		;link in the driver
	mov	word ptr ds:[si+2],dx

enddev:
	pop	si
	pop	es
	inc	ax			;ax = ffff (no more devs if yes)?
	jz	coffj3

	inc	cs:multdeviceflag	; possibly multiple device driver.
	call	DevBreak		; M009
	jmp	goodld			; otherwise pretend we loaded it in

coffj3: mov	cs:multdeviceflag,0	; reset the flag
	call	DevBreak
	jmp	coff

bad_bpb_size_sector:
	pop	si
	pop	es
	mov	dx,offset badsiz_pre
	mov	bx,offset crlfm
	call	prnerr

;	test	[setdevmarkflag],setbrkdone ;if already set_break is done,
;	jnz	skip2_resetmemhi	; then do not
;	dec	[memhi] 		;adjust memhi by a paragrah of devmark.

skip2_resetmemhi:
	jmp	coff


;------------------------------------------------------------------------------
; country command
;      the syntax is:
;	country=country id {,codepage {,path}}
;	country=country id {,,path}	:default codepage id in dos
;------------------------------------------------------------------------------

tryq:
	cmp	ah,'Q'
	jz	tryq_cont
	jmp	tryf
tryq_cont:

	mov	cntry_drv,0		; reset the drive,path to default value.
	mov	p_code_page,0
	mov	di,offset cntry_parms
	xor	cx,cx
	mov	dx,cx
do52:
	call	sysinit_parse
	jnc	if52			; parse error,check error code and

	call	cntry_error		;  show message and end the search loop.
	mov	p_cntry_code,-1		; signals that parse error.
	jmp	short sr52

if52:
	cmp	ax,$p_rc_eol		; end of line?
	jz	sr52			; then end the search loop

	cmp	result_val.$p_type,$p_number	; numeric?
	jnz	if56

	mov	ax,word ptr result_val.$p_picked_val
	cmp	cx,1
	jnz	if57

	mov	p_cntry_code,ax
	jmp	short en57

if57:
	mov	p_code_page,ax
en57:
	jmp	short en56		; path entered

if56:
	push	ds
	push	es
	push	si
	push	di

	push	cs
	pop	es

	lds	si,rv_dword		; move the path to known place.
	mov	di,offset cntry_drv
	call	move_asciiz

	pop	di
	pop	si
	pop	es
	pop	ds

en56:
	jmp	do52

sr52:
	cmp	p_cntry_code,-1		; had a parse error?
	jne	tryq_open
	jmp	coff

tryqbad:				;"invalid country code or code page"
       stc
       mov     dx,offset badcountry
       jmp     tryqchkerr

tryq_open:
	cmp	cntry_drv,0
	je	tryq_def
	mov	dx,offset cntry_drv
	jmp	short tryq_openit

tryq_def:
	mov	dx,offset cntry_root
tryq_openit:
	mov	ax,3d00h		;open a file
	stc
	int	21h
	jc	tryqfilebad		;open failure

	mov	cs:cntryfilehandle,ax	;save file handle
	mov	bx,ax
	mov	ax,cs:p_cntry_code
	mov	dx,cs:p_code_page	; now,ax=country id,bx=filehandle
	mov	cx,cs:[memhi]
	add	cx,384			; need 6k buffer to handle country.sys
					; M023
	cmp	cx,cs:[alloclim]
	ja	tryqmemory		;cannot allocate the buffer for country.sys

	mov	si,offset cntry_drv	;ds:si -> cntry_drv
	cmp	byte ptr [si],0 	;default path?
	jne	tryq_set_for_dos

	inc	si
	inc	si			;ds:si -> cntry_root

tryq_set_for_dos:
	les	di,cs:sysi_country	;es:di -> country info tab in dos
	push	di			;save di
	add	di,ccpath_countrysys
	call	move_asciiz		;set the path to country.sys in dos.
	pop	di			;es:di -> country info tab again.

	mov	cx,cs:[memhi]
	mov	ds,cx
	xor	si,si			;ds:si -> 2k buffer to be used.
	call	setdoscountryinfo	;now do the job!!!
	jnc	tryqchkerr		;read error or could not find country,code page combination

	cmp	cx,-1			;could not find matching country_id,code page?
	je	tryqbad 		;then "invalid country code or code page"

tryqfilebad:
	push	cs
	pop	es
	cmp	cs:cntry_drv,0		;is the default file used?
	je	tryqdefbad

	mov	si,offset cntry_drv
	jmp	short tryqbadload

tryqdefbad:				;default file has been used.
	mov	si,offset cntry_root	;es:si -> \country.sys in sysinit_seg
tryqbadload:
	call	badload 		;ds will be restored to sysinit_seg
	mov	cx,cs:[confbot]
	mov	es,cx			;restore es -> confbot.
	jmp	short coffj4

tryqmemory:
	mov	dx,offset insufmemory
tryqchkerr:
	mov	cx,cs:[confbot]
	mov	es,cx			;restore es -> confbot seg
	push	cs
	pop	ds			;retore ds to sysinit_seg
	jnc	coffj4			;if no error,then exit

	call	print			;else show error message
	call	error_line

coffj4:
	mov	bx,cntryfilehandle
	mov	ah,3eh
	int	21h			;close a file. don't care even if it fails.
	jmp	coff

cntry_error	proc	near

;function: show "invalid country code or code page" messages,or
;		"error in country command" depending on the error code
;		in ax returned by sysparse;
;in:	ax - error code
;	ds - sysinitseg
;	es - confbot
;out:	show message.  dx destroyed.

	cmp	ax,$p_out_of_range
	jnz	if64
	mov	dx,offset badcountry	;"invalid country code or code page"
	jmp	short en64

if64:
	mov	dx,offset badcountrycom ;"error in contry command"
en64:
	call	print
	call	error_line
	ret
cntry_error	endp

;------------------------------------------------------------------------------
; files command
;------------------------------------------------------------------------------
;*******************************************************************************
; function: parse the parameters of files= command.			       *
;									       *
; input :								       *
;	es:si -> parameters in command line.				       *
; output:								       *
;	variable files set.						       *
;									       *
; subroutines to be called:						       *
;	sysinit_parse							       *
; logic:								       *
; {									       *
;	set di points to files_parms;					       *
;	set dx,cx to 0; 						       *
;	while (end of command line)					       *
;	{ sysinit_parse;						       *
;	  if (no error) then						       *
;	     files = result_val.$p_picked_val				       *
;	  else								       *
;	     error exit;						       *
;	};								       *
; };									       *
;									       *
;*******************************************************************************
tryf:
	cmp	ah,'F'
	jnz	tryl

	mov	di,offset files_parms
	xor	cx,cx
	mov	dx,cx

do67:
	call	sysinit_parse
	jnc	if67			; parse error
	call	badparm_p		;   and show messages and end the search loop.
	jmp	short sr67

if67:
	cmp	ax,$p_rc_eol		; end of line?
	jz	en67			; then end the $endloop
	mov	al,byte ptr result_val.$p_picked_val
	mov	p_files,al		; save it temporarily
	jmp	short do67

en67:
	mov	al,p_files
	SVC	SVC_DEMWOWFILES 	; For WOW VDM Set the file= to max.
	mov	files,al		; no error. really set the value now.

sr67:
	jmp	coff

;------------------------------------------------------------------------------
; lastdrive command
;------------------------------------------------------------------------------
;*******************************************************************************
; function: parse the parameters of lastdrive= command. 		       *
;									       *
; input :								       *
;	es:si -> parameters in command line.				       *
; output:								       *
;	set the variable num_cds.					       *
;									       *
; subroutines to be called:						       *
;	sysinit_parse							       *
; logic:								       *
; {									       *
;	set di points to ldrv_parms;					       *
;	set dx,cx to 0; 						       *
;	while (end of command line)					       *
;	{ sysinit_parse;						       *
;	  if (no error) then						       *
;	     set num_cds to the returned value; 			       *
;	  else	/*error exit*/						       *
;	     error exit;						       *
;	};								       *
; };									       *
;									       *
;*******************************************************************************

tryl:
	cmp	ah,'L'
        jnz     tryp
        jmp     coff

;NTVDM Ignore the lastdrive command. Dos will figure this from the host OS.
;      17-Aug-1992 Jonle
if 0

	mov	di,offset ldrv_parms
	xor	cx,cx
	mov	dx,cx

do73:
	call	sysinit_parse
	jnc	if73		; parse error
	call	badparm_p	;   and show messages and end the search loop.
	jmp	short sr73

if73:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en73		; then end the $endloop
	mov	al,rv_byte	; pick up the drive number
	mov	p_ldrv,al	; save it temporarily
	jmp	do73

en73:
	mov	al,p_ldrv
	mov	num_cds,al	; no error. really set the value now.
sr73:
        jmp     coff
endif


;--------------------------------------------------------------------------
; setting drive parameters
;--------------------------------------------------------------------------

tryp:
	cmp	ah,'P'
        jnz     tryk
        jmp     coff

; sudeepb 04-Mar-1991 : Ignoring DRIVEPARM command
;       call    parseline
;       jc      trypbad
;
;	call	setparms
;	call	diddleback
;	jc	trypbad
;       jmp     coff
;trypbad:jmp     badop

;--------------------------------------------------------------------------
; setting internal stack parameters
; stacks=m,n where
;	m is the number of stacks (range 8 to 64,default 9)
;	n is the stack size (range 32 to 512 bytes,default 128)
; j.k. 5/5/86: stacks=0,0 implies no stack installation.
;	any combinations that are not within the specified limits will
;	result in "unrecognized command" error.
;--------------------------------------------------------------------------

;****************************************************************************
;									    *
; function: parse the parameters of stacks= command.			    *
;	    the minimum value for "number of stacks" and "stack size" is    *
;	    8 and 32 each.  in the definition of sysparse value list,they   *
;	    are set to 0.  this is for accepting the exceptional case of    *
;	    stacks=0,0 case (,which means do not install the stack.)	    *
;	    so,after sysparse is done,we have to check if the entered	    *
;	    values (stack_count,stack_size) are within the actual range,    *
;	    (or if "0,0" pair has been entered.)			    *
; input :								    *
;	es:si -> parameters in command line.				    *
; output:								    *
;	set the variables stack_count,stack_size.			    *
;									    *
; subroutines to be called:						    *
;	sysinit_parse							    *
; logic:								    *
; {									    *
;	set di points to stks_parms;					    *
;	set dx,cx to 0; 						    *
;	while (end of command line)					    *
;	{ sysinit_parse;						    *
;	  if (no error) then						    *
;	     { if (cx == 1) then /* first positional = stack count */	    *
;		   p_stack_count = result_val.$p_picked_val;		    *
;	       if (cx == 2) then /* second positional = stack size */	    *
;		   p_stack_size = result_val.$p_picked_val;		    *
;	     }								    *
;	  else	/*error exit*/						    *
;	     error exit;						    *
;	};								    *
;	here check p_stack_count,p_stack_size if it meets the condition;    *
;	if o.k.,then set stack_count,stack_size;			    *
;	 else error_exit;						    *
; };									    *
;****************************************************************************

tryk:
	cmp	ah,'K'
	je	do_tryk
	jmp	trys

		if	stacksw

do_tryk:
	mov	di,offset stks_parms
	xor	cx,cx
	mov	dx,cx

do79:
	call	sysinit_parse
	jnc	if79			; parse error

	mov	dx,offset badstack	; "invalid stack parameter"
	call	print			;  and show messages and end the search loop.
	call	error_line
	jmp	sr79

if79:
	cmp	ax,$p_rc_eol		; end of line?
	jz	en79			; then end the $endloop

	mov	ax,word ptr result_val.$p_picked_val
	cmp	cx,1
	jnz	if83

	mov	p_stack_count,ax
	jmp	short en83

if83:
	mov	p_stack_size,ax
en83:
	jmp	do79

en79:
	cmp	p_stack_count,0
	jz	if87

	cmp	p_stack_count,mincount
	jb	ll88
	cmp	p_stack_size,minsize
	jnb	if88

ll88:
	mov	p_stack_count,-1	; invalid
if88:
	jmp	short en87

if87:
	cmp	p_stack_size,0
	jz	en87
	mov	p_stack_count,-1	; invalid
en87:
	cmp	p_stack_count,-1	; invalid?
	jnz	if94

	mov	stack_count,defaultcount ;reset to default value.
	mov	stack_size,defaultsize
	mov	word ptr stack_addr,0

	mov	dx,offset badstack
	call	print
	call	error_line
	jmp	short sr79

if94:
	mov	ax,p_stack_count
	mov	stack_count,ax
	mov	ax,p_stack_size
	mov	stack_size,ax
	mov	word ptr stack_addr,-1	; stacks= been accepted.
sr79:
	jmp	coff

	endif

;------------------------------------------------------------------------
; shell command
;------------------------------------------------------------------------

trys:
	cmp	ah,'S'
	jnz	tryx

	mov	[command_line+1],0
	mov	di,offset commnd + 1
	mov	[di-1],al

storeshell:
	call	getchr
	or	al,al
	jz	getshparms

	cmp	al," "
	jb	endsh

	mov	[di],al
	inc	di
	jmp	storeshell

endsh:
	mov	byte ptr [di],0
;	push	di
;	mov	di,offset commnd
;	SVC	SVC_SETSHELLNAME
;	pop	di

	call	getchr
	cmp	al,lf
	jnz	conv

	call	getchr
conv:	jmp	conflp

getshparms:
	mov	byte ptr [di],0
	mov	di,offset command_line+1

parmloop:
	call	getchr
	cmp	al," "
	jb	endsh
	mov	[di],al
	inc	di
	jmp	parmloop

;------------------------------------------------------------------------
; fcbs command
;------------------------------------------------------------------------

;************************************************************************
; function: parse the parameters of fcbs= command.			*
;									*
; input :								*
;	es:si -> parameters in command line.				*
; output:								*
;	set the variables fcbs,keep.					*
;									*
; subroutines to be called:						*
;	sysinit_parse							*
; logic:								*
; {									*
;	set di points to fcbs_parms;					*
;	set dx,cx to 0; 						*
;	while (end of command line)					*
;	{ sysparse;							*
;	  if (no error) then						*
;	     { if (cx == 1) then /* first positional = fcbs */		*
;		   fcbs = result_val.$p_picked_val;			*
;	       if (cx == 2) then /* second positional = keep */ 	*
;		   keep = result_val.$p_picked_val;			*
;	     }								*
;	  else	/*error exit*/						*
;	     error exit;						*
;	};								*
; };									*
;************************************************************************

tryx:
	cmp	ah,'X'
	jnz	tryy

	mov	di,offset fcbs_parms
	xor	cx,cx
	mov	dx,cx

do98:
	call	sysinit_parse
	jnc	if98			; parse error
	call	badparm_p		;  and show messages and end the search loop.
	jmp	short sr98

if98:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en98		; then end the $endloop

	mov	al,byte ptr result_val.$p_picked_val
	cmp	cx,1		; the first positional?
	jnz	if102
	mov	p_fcbs,al
	jmp	short en102

if102:
	mov	p_keep,al
en102:
	jmp	do98

en98:
	mov	al,p_fcbs	; M017
	mov	fcbs,al		; M017
	mov	keep,0		; M017
sr98:
	jmp	coff

;-------------------------------------------------------------------------
; comment= do nothing. just decrese chrptr,and increase count for correct
;		line number
;-------------------------------------------------------------------------

tryy:
	cmp	ah,'Y'
	jne	try0

donothing:
	dec	chrptr
	inc	count
	jmp	coff

;------------------------------------------------------------------------
; rem command
;------------------------------------------------------------------------

try0:				;do nothing with this line.
	cmp	ah,'0'
	je	donothing

;-----------------------------------------------------------------------
; switches command
;-----------------------------------------------------------------------
;****************************************************************************
;									    *
; function: parse the option switches specified.			    *
; note - this command is intended for the future use also.  when we need to *
; to set system data flag,use this command.				    *
;									    *
; input :								    *
;	es:si -> parameters in command line.				    *
; output:								    *
;	p_swit_k set if /k option chosen.				    *
;									    *
; subroutines to be called:						    *
;	sysinit_parse							    *
; logic:								    *
; {									    *
;	set di points to swit_parms;  /*parse control definition*/	    *
;	set dx,cx to 0; 						    *
;	while (end of command line)					    *
;	{ sysinit_parse;						    *
;	  if (no error) then						    *
;	       if (result_val.$p_synonym_ptr == swit_k) then		    *
;		    p_swit_k = 1					    *
;	       endif							    *
;	  else {show error message;error exit}				    *
;	};								    *
; };									    *
;									    *
;****************************************************************************

	cmp	ah,'1'		;switches= command entered?
	je	do_try1
	jmp	tryt
do_try1:
	mov	di,offset swit_parms
	xor	cx,cx
	mov	dx,cx

do110:
	call	sysinit_parse
	jnc	if110		; parse error
	call	badparm_p	;  and show messages and end the search loop.
	jmp	short sr110

if110:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en110		; then jmp to $endloop for semantic check

	cmp	result_val.$p_synonym_ptr,offset swit_k
	jnz	if115		;				;M059
	mov	p_swit_k,1	; set the flag
	jmp	do110
if115:								;M059
	cmp	result_val.$p_synonym_ptr, offset swit_t	;M059
	jne	if116						;M059 M063
	mov	p_swit_t, 1					;M059
	jmp	do110						;M059
if116:
	cmp	result_val.$p_synonym_ptr, offset swit_w	;M063
	jne	do110						;M063
	mov	p_swit_w, 1					;M063
	jmp	do110						;M063
en110:
	cmp	p_swit_k,1	;if /k entered,

	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume	ds:Bios_Data
	jnz	if117
	mov	keyrd_func,0	;use the conventional keyboard functions
	mov	keysts_func,1
if117:
;	mov	al, p_swit_t					;M059
;	mov	t_switch, al					;M059

	cmp	p_swit_w, 0					;M063
	je	skip_dos_flag					;M063
	push	es
	push	bx
	mov	ah, GET_IN_VARS					;M063
	int	21h						;M063
	or	byte ptr es:[DOS_FLAG_OFFSET], SUPPRESS_WINA20	;M063
	pop	bx
	pop	es
skip_dos_flag:							;M063
	pop	ds
	assume	ds:sysinitseg

sr110:
	jmp	coff

;------------------------------------------------------------------------
; NTCMDPROMPT command. This command forces SCS functionality to use
; cmd.exe prompt rather than command.com's prompt on shelling out
; and on finding a TSR.
;------------------------------------------------------------------------
tryt:
	cmp	ah,'T'
	je	tryt_5
        jmp     short tryo

tryt_5:
	push	si
	push	bp
	xor	ax,ax
	mov	bp,ax
	mov	si,ax
	mov	al,4
	mov	ah,setdpb
	int	21h
	pop	bp
	pop	si
	jmp	coff

;------------------------------------------------------------------------
; DOSONLY command. This command forces only DOS binaries to run from
; command.com prompt. non_dos binaries will putup the stub message
; of unable to run it under DOS.
;------------------------------------------------------------------------
tryo:
        cmp     ah,'O'
        je      tryo_5
        jmp     short tryz

tryo_5:
	push	si
	push	bp
	xor	ax,ax
	mov	bp,ax
	mov	si,ax
        mov     al,6
	mov	ah,setdpb
	int	21h
	pop	bp
	pop	si
        jmp     coff

;------------------------------------------------------------------------
; bogus command
;------------------------------------------------------------------------

tryz:
	cmp	ah,0ffh
	je	tryff

	dec	chrptr
	inc	count
	jmp	short badop

;------------------------------------------------------------------------
; null command
;------------------------------------------------------------------------

tryff:				;skip this command.
	jmp	donothing

doconf	endp

;------------------------------------------------------------------------------

sysinit_parse	proc
;set up registers for sysparse
;in)	es:si -> command line in  confbot
;	di -> offset of the parse control defintion.
;
;out)	calls sysparse.
;	carry will set if parse error.
;	*** the caller should check the eol condition by looking at ax
;	*** after each call.
;	*** if no parameters are found,then ax will contain a error code.
;	*** if the caller needs to look at the synomym@ of the result,
;	***  the caller should use cs:@ instead of es:@.
;	cx register should be set to 0 at the first time the caller calls this
;	 procedure.
;	ax - exit code
;	bl - terminated delimeter code
;	cx - new positional ordinal
;	si - set to pase scanned operand
;	dx - selected result buffer

	push	es			;save es,ds
	push	ds

	push	es
	pop	ds			;now ds:si -> command line

	push	cs
	pop	es			;now es:di -> control definition

	mov	cs:badparm_seg,ds	;save the pointer to the parm
	mov	cs:badparm_off,si	; we are about to parse for badparm msg.
	mov	dx,0
	call	sysparse
	cmp	ax,$p_no_error		;no error

;**cas note:  when zero true after cmp, carry clear

	jz	ll4
	cmp	ax,$p_rc_eol		;or the end of line?
	jnz	if4

ll4:
	clc
	jmp	short en4

if4:
	stc
en4:
	pop	ds
	pop	es
	ret
sysinit_parse	endp

;
;----------------------------------------------------------------------------
;
; procedure : badop_p
;
;             same thing as badop,but will make sure to set ds register back
;             to sysinitseg and return back to the caller.
;
;----------------------------------------------------------------------------
;
badop_p proc	near


	push	cs
	pop	ds			;set ds to configsys seg.
	mov	dx,offset badopm
	call	print
	call	error_line
	ret

badop_p endp
;
;----------------------------------------------------------------------------
;
; label : badop
;
;----------------------------------------------------------------------------
;
badop:	mov	dx,offset badopm	;want to print command error "unrecognized command..."
	call	print
	call	error_line		;show "error in config.sys ..." .
	jmp	coff


;
;----------------------------------------------------------------------------
;
; procedure : badparm_p
;
;             show "bad command or parameters - xxxxxx"
;             in badparm_seg,badparm_off -> xxxxx
;
;----------------------------------------------------------------------------
;
badparm_p	proc	near


	push	ds
	push	dx
	push	si

	push	cs
	pop	ds

	mov	dx,offset badparm
	call	print			;"bad command or parameters - "
	lds	si,badparm_ptr

;	print "xxxx" until cr.

do1:
	mov	dl,byte ptr [si]	; get next character
	cmp	dl,cr			; is a carriage return?
	jz	en1			; exit loop if so

	mov	ah,std_con_output	; function 2
	int	21h			; display character
	inc	si			; next character
	jmp	do1
en1:
	push	cs
	pop	ds

	mov	dx,offset crlfm
	call	print
	call	error_line

	pop	si
	pop	dx
	pop	ds
badparmp_ret:
	ret
badparm_p	endp

;
;----------------------------------------------------------------------------
;
; procedure : getchr
;
;----------------------------------------------------------------------------
;
getchr	proc	near
	push	cx
	mov	cx,count
	jcxz	nochar

	mov	si,chrptr
	mov	al,es:[si]
	dec	count
	inc	chrptr
	clc
get_ret:
	pop	cx
	ret

nochar: stc
	jmp	short get_ret
getchr	endp

;
;----------------------------------------------------------------------------
;
; procedure : incorrect_order
;
;             show "incorrect order in config.sys ..." message.
;
;----------------------------------------------------------------------------
;

incorrect_order proc	near

	mov	dx,offset badorder
	call	print
	call	showlinenum
	ret

incorrect_order endp

;
;----------------------------------------------------------------------------
;
; procedure : error_line
;
;             show "error in config.sys ..." message.
;
;----------------------------------------------------------------------------
;
		public	error_line
error_line	proc	near


	push	cs
	pop	ds
	mov	dx,offset errorcmd
	call	print
	call	showlinenum
	ret

error_line	endp

;
;----------------------------------------------------------------------------
;
; procedure : showlinenum
;
; convert the binary linecount to decimal ascii string in showcount
;and display showcount at the current curser position.
;in.) linecount
;
;out) the number is printed.
;
;----------------------------------------------------------------------------
;
showlinenum	proc	near


	push	es
	push	ds
	push	di

	push	cs
	pop	es		; es=cs

	push	cs
	pop	ds

	mov	di,offset showcount+4	; di -> the least significant decimal field.
	mov	cx,10			; decimal devide factor
	mov	ax,cs:linecount

sln_loop:
	cmp	ax,10			; < 10?
	jb	sln_last

	xor	dx,dx
	div	cx
	or	dl,30h			; add "0" (= 30h) to make it an ascii.
	mov	[di],dl
	dec	di
	jmp	sln_loop

sln_last:
	or	al,30h
	mov	[di],al
	mov	dx,di
	call	print			; show it.
	pop	di
	pop	ds
	pop	es
	ret
showlinenum	endp

comment ^
set_devmark	proc	near
;***************************************************************************
; function: set a paragraph of informations infront of a device file or    *
;	    an ifs file to be loaded for mem command.			   *
;	    the structure is:						   *
;	      devmark_id	byte "d" for device,"i" for ifs		   *
;	      devmark_size	size in para for the device loaded	   *
;	      devmark_filename	11 bytes. filename			   *
;									   *
; input :								   *
;	    [memhi] = address to set up devmark.			   *
;	    [memlo] = 0 						   *
;	    es:si -> pointer to [drive][path]filename,0 		   *
;	    [ifs_flag] = is_ifs bit set if ifs= command.		   *
;									   *
; output:   devmark_id,devmark_filename set				   *
;	    cs:[devmark_addr] set.					   *
;	    ax,cx register destroyed.					   *
;***************************************************************************

	push	ds
	push	si
	push	es
	push	di

	mov	di,cs:[memhi]
	mov	ds,di
	assume	ds:nothing
	mov	[devmark_addr],di	; save the devmark address for the future.
	mov	ds:[devmark_id],devmark_device	; 'd'
	inc	di
	mov	ds:[devmark_seg],di
	xor	al,al
	push	si
	pop	di			; now es:si = es:di = [path]filename,0
	mov	cx,128			; maximum 128 char
	repnz	scasb			; find 0
	dec	di			; now es:di-> 0
sdvmk_backward: 			; find the pointer to the start of the filename.
	mov	al,byte ptr es:[di]	; we do this by check es:di backward until
	cmp	al,'\' 		        ; di = si or di -> '\' or di -> ':'.
	je	sdvmk_gotfile
	cmp	al,':'
	je	sdvmk_gotfile
	cmp	di,si
	je	sdvmk_fileptr
	dec	di
	jmp	sdvmk_backward
sdvmk_gotfile:
	inc	di
sdvmk_fileptr:				; now es:di -> start of file name
	push	di			; cas - holy sh*t!!!  CODE!
	pop	si			; save di to si.

	push	ds			; switch es,ds
	push	es
	pop	ds
	pop	es			; now,ds:si -> start of filename

	mov	di,devmark_filename
	push	di
	mov	al,' '
	mov	cx,8
	rep	stosb			; clean up memory.
	pop	di
	mov	cx,8			; max 8 char. only
sdvmk_loop:
	lodsb
	cmp	al,'.'
	je	sdvmk_done
	cmp	al,0
	je	sdvmk_done
	stosb
	loop	sdvmk_loop

sdvmk_done:
	pop	di
	pop	es
	pop	si
	pop	ds
	ret
set_devmark	endp
^
; =========================================================================
;reset_dos_version	proc	near
;
;;function: issue ax=122fh,dx=0,int 2fh to restore the dos version.
;
;	push	ax
;	push	dx
;	mov	ax,122fh
;	mov	dx,0
;	int	2fh
;	pop	dx
;	pop	ax
;	ret
;reset_dos_version	endp
;
;
; =========================================================================

IFDEF	DONT_LOAD_OS2_DD		; M045

EXE_SIG		EQU	5a4dh		; .EXE file signature
OS2_SIG 	EQU	454eh		; OS2 .EXE file signature

SIGNATURE_LEN	EQU	2		; Lenght of .EXE signature in bytes
SIZE_DWORD	EQU	4

SEG_SIG_OFFSET	EQU	18h		; Offset of segmented .EXE signature
SEG_EXE_SIG	EQU	40h		; Signature of a segmented .EXE file
SEG_HEADER_PTR	EQU	3ch		; Offsets of ptr to segmented header

; =========================================================================
; CheckForOS2 PROC
;
; Examines an open file to see if it is really an OS2 executable file.
;
; REGISTERS:	AX	- Open file handle
; RETURNS:	Carry	- Carry set if file is an OS2 executable or error.
; DESTROYS:	NOTHING
;		NOTE:	The file ptr is assumed to be set to start of file
;			on entry and is not reset to begining of the file
;			on exit.
;
; Strategy:	If word value at 00h == 454eh file is OS2
;		else if word value at 00h == 5a4dh and
;		        (word value at 18h == 40h and the dword ptr at 3ch
;			 points to word value of 454eh) file is OS2.
;
; =========================================================================

CheckForOS2 PROC NEAR

	push	AX
	push	BX
	push	CX
	push	DX
	push	DS
	push	BP

	push	CS				; BUGBUG
	pop	DS				; NOT ROM DOS COMPATIBLE

	mov	BX,AX				; Put open file handle in BX
	mov	BP,offset DS:Os2ChkBuf		; Save buff offset for latter

		; First we need to read in the first 2 bytes of the file
		; to see if it's an OS2 .EXE file and if not see if 
		; it is a DOS .EXE file. 

	mov	AX,(read shl 8)			; AH = DOS read function
	mov	CX,SIGNATURE_LEN		; CX = size of word value
	mov	DX,BP				; DS:DX --> tmp buffer
	int	21h
	jc	OS2ChkExit			; Return carry on error

	dec	AX				; Check number of byte read
	dec	AX
	jnz	NotOs2				; Must be at end of file

	mov	AX, WORD PTR DS:Os2ChkBuf
	cmp	AX, OS2_SIG			; Check for 454eh
	je	IsOS2				; Return is OS2 if match
	cmp	AX, EXE_SIG			; Now see if it's a DOS .EXE
	jne	NotOS2				; If no match can't be OS2

		; Here we know the file has a valid DOS .EXE signature so
		; now we need to see if it's a segmented .EXE file by looking
		; for the segmented .EXE signature at file offset 18h

	mov	AX,(lseek shl 8)		; AX = Seek from begining
	xor	CX,CX
	mov	DX,SEG_SIG_OFFSET		; CX:DX = offset of segmented
	int	21h				; Seek to offset 18h
	jc	OS2ChkExit			; Return carry on error

	mov	AX,read shl 8			; AX = Read file
	mov	CX,SIGNATURE_LEN		; CX = size of word value
	mov	DX,BP				; Restore buffer offset
	int	21h 				; DS:DX -> buffer
	jc	OS2ChkExit			; Return carry on error

	dec	AX				; Check number of byte read
	dec	AX
	jnz	NotOs2				; Must be at end of file

	cmp	WORD PTR DS:Os2ChkBuf,SEG_EXE_SIG ; Chk for segmented .EXE file
	jne	NotOS2				; Can't be OS2 if no match

		; Here we know we have a segmented .EXE file so we have
		; to get the offset of the start of the segmented  header
		; from offset 3ch in the file.

	mov	AX,(lseek shl 8)		; AX = Seek from begining
	xor	CX,CX
	mov	DX,SEG_HEADER_PTR		; CX:DX = offset of head ptr
	int	21h				; Seek to offset 3ch
	jc	OS2ChkExit			; Return carry on error

	mov	AX,(read shl 8)			; AX = Read file
	mov	CX,SIZE_DWORD			; CX = size of dword (4 bytes)
	mov	DX,BP				; Restore buffer offset
	int	21h 				; Read in 4 byte offset
	jc	OS2ChkExit			; Return carry on error

	cmp	AX,SIZE_DWORD			; Check number of byte read
	jne	NotOs2				; Must be at end of file

		; At this point OS2ChkBuf has a 4 byte offset into the file
		; to the start of a segmented .EXE header so we need to read
		; the 2 bytes at this location to see if they are 454eh

	mov	DX,WORD PTR DS:Os2ChkBuf
	mov	CX,WORD PTR DS:Os2ChkBuf[2]	; CX:DX = offset of new header
	mov	AX,(lseek shl 8)		; AX = Seek from begining
	int	21h				; Seek to offset 3ch
	jc	OS2ChkExit			; Return carry on error

	mov	AX,(read shl 8)			; AX = Read file
	mov	CX,SIGNATURE_LEN		; CX = size of word (2 bytes)
	mov	DX,BP				; DS:DX --> Os2ChkBuf
	int	21h 				; Read in 4 byte offset
	jc	OS2ChkExit			; Return carry on error

	dec	AX				; Check number of byte read
	dec	AX
	jnz	NotOs2				; Must be at end of file

		; We have the segmented .EXE header in OS2ChkBuf so all
		; we have left to do is see if it's a .EXE signature.

	cmp	WORD PTR DS:OS2ChkBuf,OS2_SIG	; Check for 454eh
	jne	NotOs2				; Not OS2 if it doesn't match

IsOs2:
	stc					; Signal error or OS2 .EXE
	jmp	SHORT OS2ChkExit
NotOs2:
	clc					; Signal no err and not OS2

OS2ChkExit:
	pop	BP
	pop	DS
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	ret

CheckForOS2 ENDP

ENDIF						; M045

;
;----------------------------------------------------------------------------
;
; procedure : ProcDOS
;
;	Process the result of DOS= parsing
;
;	result_val.$p_item_tag	= 1 for DOS=HIGH
;				= 2 for DOS=LOW
;				= 3 for DOS=UMB
;				= 4 for DOS=NOUMB
;----------------------------------------------------------------------------
;
ProcDOS	proc	near
	assume	ds:nothing, es:nothing
	xor	ah, ah
	mov	al, result_val.$p_item_tag
	dec	ax
	jz	pd_hi
	dec	ax
	jz	pd_lo
	dec	ax
	jz	pd_umb
	mov	DevUMB, 0
	ret
pd_umb:
	mov	DevUMB, 0ffh
	ret
pd_lo:
	mov	runhigh, 0
	ret
pd_hi:
	mov	runhigh, 0ffh
	ret
ProcDOS	endp

;
;----------------------------------------------------------------------------
;
; procedure : LieInt12Mem
;
;	Input : DevEntry points to Device Start address (offset == 0)
;		alloclim set to the limit of low memory.
;
;	Output : none
;
;	Changes the ROM BIOS variable which stores the total low memory
;	If a 3com device driver (any character device with name 'PROTMAN$')
;	is being loaded alloclim is converted into Ks and stored in 40:13h
;	Else if a device driver being loaded into UMB the DevLoadEnd is
;	converted into Ks and stored in 40:13h
;
;----------------------------------------------------------------------------
;
LieInt12Mem	proc	near

		assume	ds:nothing, es:nothing
 
		mov	ax, alloclim		; lie INT 12 as alloclim
						; assuming that it is 3Com
		call	IsIt3Com?		; Is it 3Com driver?
		je	lim_set			; yes, lie to him differently
		cmp	DeviceHi, 0		; Is the DD being loaded in UMB
		je	limx			; no, don't lie
		mov	ax, DevLoadEnd		; lie INT 12 as end of UMB
lim_set:
		call	SetInt12Mem
limx:
		ret
LieInt12Mem	endp

;
;----------------------------------------------------------------------------
;
; procedure : SetInt12Mem
;
;	Input : AX = Memory size to be set (in paras)
;	Output : none
;
;	Sets the variable 40:13 to the memory size passed in AX
;	It saves the old value in 40:13 in OldInt12Mem,
;	It also sets a flag Int12Lied to 0ffh, which is checked before
;	restoring the value of 40:13
;
;----------------------------------------------------------------------------
;
SetInt12Mem	proc	near

		assume	ds:nothing, es:nothing
 
		push	ds
		mov	bx, 40h
		mov	ds, bx			; ROM BIOS Data Segment
		mov	bx, word ptr ds:[13h]	; INT 12 memory variable
		mov	OldInt12Mem, bx		; save it
		mov	cl, 6
		shr	ax, cl			; convert paras into Ks
		mov	word ptr ds:[13h], ax	; Lie
		mov	Int12Lied, 0ffh		; mark that we are lying
		pop	ds
		ret
SetInt12Mem	endp

;
;----------------------------------------------------------------------------
;
; procedure : TrueInt12Mem
;
;	Input : Int12Lied = 0 if we are not lying currently
;			  = 0ffh if we are lying
;		OldInt12Mem = Saved value of 40:13h
;
;	Output : none
;
;	Resets the INT 12 Memory variable if we were lying about int 12
;	and resets the flag which indicates that we were lying
;
;----------------------------------------------------------------------------
;
TrueInt12Mem	proc	near

		assume	ds:nothing, es:nothing
 
		cmp	Int12Lied, 0		; were we lying so far?
		mov	Int12Lied, 0		; reset it anyway
		je	timx			; no, we weren't
		push	ds
		mov	ax, 40h
		mov	ds, ax
		mov	ax, OldInt12Mem
		mov	word ptr ds:[13h], ax	; restore INT 12 memory
		pop	ds
timx:
		ret
TrueInt12Mem	endp

;
;----------------------------------------------------------------------------
;
; procedure : IsIt3Com?
;
;	Input : DevEntry = Seg:0 of device driver
;	Output : Zero flag set if device name is 'PROTMAN$'
;		 else Zero flag is reset
;
;----------------------------------------------------------------------------
;
IsIt3Com?	proc	near
		assume	ds:nothing, es:nothing, ss:nothing
		push	ds
		push	es
		push	si
		lds	si, DevEntry		; ptr to device header
		add	si, sdevname		; ptr device name
		push	cs
		pop	es
		mov	di, offset ThreeComName
		mov	cx, 8			; name length
		rep	cmpsb
		pop	si
		pop	es
		pop	ds
		ret
IsIt3Com?	endp

;M020 : BEGIN
;
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
;
UpdatePDB	proc	near
		assume	ds:nothing
		push	ds
		mov	ah, 62h
		int	21h
		mov	ds, bx
		mov	bx, alloclim
		mov	ds:[PDB_Block_Len], bx
		pop	ds
		ret
UpdatePDB	endp
;
; M020 : END
;
;----------------------------------------------------------------------------
;
; procedure : InitDevLoad
;
;	Input : DeviceHi = 0 indicates load DD in low memory
;			 = 1 indicates load in UMB
;		DevSize  = Size of the device driver file in paras
;
;	Output : none
;
;	Initializes DevLoadAddr, DevLoadEnd & DevEntry.
;	Also sets up a header for the Device driver entry for mem utility
;
;----------------------------------------------------------------------------
;
InitDevLoad	proc	near

		assume	ds:nothing, es:nothing

		cmp	DeviceHi, 0		; Are we loading in UMB
		je	InitForLo		; no, init for lo mem
		call	SpaceInUMB?		; Do we have space left in the
						;  current UMB ?
		jnc	InitForHi		; yes, we have
		call	ShrinkUMB		; shrink the current UMB in use
		call	GetUMBForDev		; else try to allocate new UMB
		jc	InitForLo		; we didn't succeed, so load
						;  in low memory
InitForHi:
		mov	ax, DevUMBFree		; get Para addr of free mem
		mov	dx, DevUMBAddr		; UMB start addr
		add	dx, DevUMBSize		; DX = UMB End addr
		jmp	short idl1
		
InitForLo:
		mov	DeviceHi, 0		; in case we failed to load
						;  into UMB indicate that we
						;  are loading low
		mov	ax, memhi		; AX = start of Low memory
		mov	dx, alloclim		; DX = End of Low memory
idl1:
		call	DevSetMark		; setup a sub-arena for DD
		mov	DevLoadAddr, ax		; init the Device load address
		mov	DevLoadEnd, dx		; init the limit of the block
		mov	word ptr DevEntry, 0	; init Entry point to DD
		mov	word ptr DevEntry+2, ax
		ret
InitDevLoad     endp


;------------------------------------------------------------------
; NTVDM  08-Dec-1992 Jonle
;
; AllocUMBLow- Allocates a chunk from memory from UMB area
;              or from low memory area in case UMB memory
;              is unavailable.
;
; The arena is marked as
;
; Input:  es:di addr of arena name to copy
;         cx    size to allocate
;
; Output: es:di points to memory allocated
;
;------------------------------------------------------------------
AllocUMBLow  proc    near

             assume  ds:nothing, es:nothing

             mov     ax, cx              ; convert size to paras
             add     ax, 18              ; extra for dummy dev header for mem.exe
             call    pararound
             mov     DevSize, ax

             mov     word ptr [bpb_addr],   di  ; fake cmd line for dev name
             mov     word ptr [bpb_addr+2], es

             mov     al, DevUMB                 ; we want UMB
             mov     DeviceHi, al

             call    InitDevLoad

             mov     ax, word ptr DevEntry+2    ; mark arena for mem.exe
             dec     ax
             mov     es, ax
             mov     byte ptr es:[devmark_id], devmark_spc

             inc     ax                         ; mark final size
             add     ax, DevSize
             mov     word ptr DevBrkAddr+2,ax
             mov     word ptr DevBrkAddr, 0
             call    DevBreak

             mov     di, word ptr DevEntry      ; es:di -> deventry
             mov     ax, word ptr DevEntry+2
             mov     es, ax

AllocUMBLow  endp


;
;----------------------------------------------------------------------------
;
; procedure : SpaceInUMB?
;
;	Input : DevUMBAddr, DevUMBSize, DevUMBFree & DevSize
;	Output : Carry set if no space in UMB
;		 Carry clear if Space is available for the device in
;		   current UMB
;
;----------------------------------------------------------------------------
;
SpaceInUMB?	proc	near

		assume	ds:nothing, es:nothing

		mov	ax, DevUMBSize
		add	ax, DevUMBAddr		; End of UMB
		sub	ax, DevUMBFree		; - Free = Remaining space
		or	ax, ax			; Nospace ?
		jnz	@f
		stc
		ret
@@:
		dec	ax			; space for sub-arena
		cmp	ax, DevSize		; do we have space ?
		ret
SpaceInUMB?	endp

;
;----------------------------------------------------------------------------
;
; procedure : GetUMBForDev
;
;	Input : DevSize
;	Output : Carry set if couldn't allocate a UMB to fit the
;		 the device.
;		 If success carry clear
;
;	Allocates the biggest UMB for loading devices and updates
;	DevUMBSize, DevUMBAddr & DevUMBFree if it succeeded in allocating
;	UMB.
;
;	This routine relies on the fact that all of the low memory
;	is allocated, and any DOS alloc calls should return memory
;	from the UMB pool.
;
;----------------------------------------------------------------------------
;
GetUMBForDev	proc	near

		assume	ds:nothing, es:nothing

if 0
;;
		mov	bx, 0ffffh
		mov	ax, 4800h
		int	21h

		or	bx, bx
		jz	gufd_err

		dec	bx
		cmp	DevSize, bx
		ja	gufd_err
		inc	bx
		mov	ax, 4800h
		int	21h
		jc	gufd_err

		push	ds
		dec	ax
		mov	ds, ax
		mov	word ptr ds:[arena_owner], 8
		mov	word ptr ds:[arena_name], 'DS'
		inc	ax
		pop	ds

		mov	DevUMBSize, bx		; update the UMB Variables
		mov	DevUMBAddr, ax
		mov	DevUMBFree, ax
		clc				; mark no error
		ret
gufd_err:
		xor	ax, ax
		mov	DevUMBSize, ax		; erase the previous values
		mov	DevUMBAddr, ax
		mov	DevUMBFree, ax
		stc
		ret
else
;; we changed the allocation strategy to best-fit for NT. This is because
;; we want to reserve bigger blocks for loadhigh command. In most case,
;; device drivers are smaller than TSR(ran from loadhigh). This change give
;; us a better chance to load the big tsr like DOSX.EXE to UMB and
;; give applications more free conventional memory.
;; The following implementation seems slow because every time we need an
;; UMB, we go through the chain. This is done because each request has
;; different size - We can grab all UMBs from the very beginning and put
;; them in a list, but we have to maintain the list. -williamh
		push	cx
		push	dx
		push	es
		xor	cx, cx			;; allocated count = 0
		mov	dx, DevSize
		inc	dx			;; minimum size in paras
						;; bios needs its sub-arena
search_for_best_block:
		mov	bx, 0ffffh		;; get largest block size
		mov	ah, 48h 		;; so far
		int	21h
		cmp	bx, dx			;; will this satisfy ours?
		jb	allocate_the_block	;; no, break
		mov	ah, 48h			;; allocate this block
		int	21h
		jc	allocate_the_block	;; failed, use the previous one
		inc	cx			;; we have one more allocated
		push	bx			;; save the size
		push	ax			;; save the address
		jmp	short search_for_best_block

allocate_the_block:
;; the block saved on the top of the stack is the best fit one
;; grab it if there is one
		jcxz	gufd_err		;; no block found, error
		pop	ax			;; get the address
		pop	DevUMBSize		;; and size
		mov	DevUMBAddr, ax
		mov	DevUMBFree, ax
		dec	ax
		push	ds
		mov	ds, ax
		mov	word ptr ds:[arena_owner], 8
		mov	word ptr ds:[arena_name], 'DS'
		pop	ds
		dec	cx
;; now free those unnecessary blocks
		jcxz	allocate_done
free_allocated_blocks:
		pop	es			;; get the address
		add	sp, 2			;; discard the size
		mov	ah, 49h 		;; free it
		int	21h
		loop	free_allocated_blocks
allocate_done:
		clc				; mark no error
		jmp	short GetUMBForDevExit
gufd_err:
		xor	ax, ax
		mov	DevUMBSize, ax		; erase the previous values
		mov	DevUMBAddr, ax
		mov	DevUMBFree, ax
		stc
GetUMBForDevExit:
		pop	es
		pop	dx
		pop	cx
		ret
endif

GetUMBForDev	endp

;
;----------------------------------------------------------------------------
;
; procedure : DevSetMark
;
;	Input : AX - Free segment were device is going to be loaded
;	Output : AX - Segment at which device can be loaded (AX=AX+1)
;
;	Creates a sub-arena for the device driver
;	puts 'D' marker in the sub-arena
;	Put the owner of the sub-arena as (AX+1)
;	Copies the file name into sub-arena name field
;
;	Size field of the sub-arena will be set only at succesful
;	completion of Device load.
;
;----------------------------------------------------------------------------
;
DevSetMark	proc	near

		assume	ds:nothing, es:nothing

		push	es
		push	di
		push	ds
		push	si
		mov	es, ax
		mov	byte ptr es:[devmark_id], devmark_device	; 'D'
		inc	ax
		mov	word ptr es:[devmark_seg], ax
;
;-------------- Copy file name
;
		push	ax			; save load addr
		lds	si, bpb_addr		; command line is still there
;M004 - BEGIN
		mov	di, si
		cld
dsm_again:
		lodsb
		cmp	al, ':'
		jne	isit_slash
		mov	di, si
		jmp	dsm_again
isit_slash:
		cmp	al, '\'
		jne	isit_null
		mov	di, si
		jmp	dsm_again
isit_null:

ifdef DBCS
		call	testkanj
		jz	@f		; if this is not lead byte
		lodsb			; get tail byte
@@:
endif

		or	al, al
		jnz	dsm_again
		mov	si, di
;M004 - END
		mov	di, devmark_filename
		mov	cx, 8			; maximum 8 characters
dsm_next_char:
		lodsb
		or	al, al
		jz	blankout
		cmp	al, '.'
		jz	blankout
		stosb
		loop	dsm_next_char
blankout:
		jcxz	dsm_exit
		mov	al, ' '
		rep	stosb			; blank out the rest
dsm_exit:
		pop	ax			; restore load addr
		pop	si
		pop	ds
		pop	di
		pop	es
		ret
DevSetMark	endp

;
;----------------------------------------------------------------------------
;
; procedure : SizeDevice
;
;	Input : ES:SI - points to device file to be sized
;
;	Output : Carry set if file cannot be opened or if it is an OS2EXE file
;
;	Calculates the size of the device file in paras and stores it
;	in DevSize
;
;----------------------------------------------------------------------------
;
SizeDevice	proc	near

		assume	ds:nothing, es:nothing

		push	es
		pop	ds
		mov	dx, si			; ds:dx -> file name
		mov	ax, 3d00h		; open
		int	21h
		jc	sd_err			; open failed

IFDEF	DONT_LOAD_OS2_DD			; M045
		call	CheckForOS2		; is it a OS2 EXE file ?
		jc	sd_close		; yeah, we dont load them
ENDIF						; M045

		mov	bx, ax			; BX - file handle
		mov	ax, 4202h		; seek
		xor	cx, cx
		mov	dx, cx			; to end of file
		int	21h
		jc	sd_close		; did seek fail (impossible)
		add	ax, 15			; para convert
		adc	dx, 0
		test	dx, 0fff0h		; size > 0ffff paras ?
		jz	@f			; no
		mov	DevSize, 0ffffh		; invalid device size
						; assuming that we fail later
		jmp	short sd_close
@@:
		mov	cl, 4			; conver it to paras
		shr	ax, cl
		mov	cl, 12
		shl	dx, cl
		or	ax, dx			;
		cmp	ax, DevSizeOption
		ja	@f
		mov	ax, DevSizeOption
@@:
		mov	DevSize, ax		; save file size
		clc
sd_close:
		pushf				; let close not spoil our
						;  carry flag
		mov	ax, 3e00h		; close
		int	21h			; we are not checking for err
		popf
sd_err:
		ret
SizeDevice	endp

;
;----------------------------------------------------------------------------
;
; procedure : ExecDev
;
;	Input : ds:dx -> device to be executed
;		DevLoadAddr - contains where device has to be loaded
;
;	Output : Carry if error
;		 Carry clear if no error
;
;	Loads a device driver using the 4b03h function call
;
;----------------------------------------------------------------------------
;
ExecDev		proc	near

		assume	ds:nothing, es:nothing

		mov	bx, DevLoadAddr
		mov	DevExecAddr, bx		; Load the parameter block
						;  block for exec with
						;  Load address
		mov	DevExecReloc, bx
		mov	bx,cs
		mov	es,bx
		mov	bx,offset DevExecAddr	;es:bx points to parameters
		mov	al,3
		mov	ah,exec
		int	21h			;load in the device driver
		ret
ExecDev		endp

;
;----------------------------------------------------------------------------
;
; procedure : RemoveNull
;
;	Input : ES:SI points to a null terminated string
;
;	Output : none
;
;	Replaces the null at the end of a string with blank
;
;----------------------------------------------------------------------------
;

RemoveNull	proc	near

		assume	ds:nothing, es:nothing

rn_next:
		mov	bl, es:[si]
		or	bl, bl			; null ?
		jz	rn_gotnull
		inc	si			; advance the pointer
		jmp	rn_next
rn_gotnull:
		mov	bl, DevSavedDelim
		mov	byte ptr es:[si], bl	; replace null with blank
		ret
RemoveNull	endp

;
;----------------------------------------------------------------------------
;
; procedure : RoundBreakAddr
;
;	Input : DevBrkAddr
;	Output : DevBrkAddr
;
;	Rounds DevBrkAddr to a para address so that it is of the form xxxx:0
;
;----------------------------------------------------------------------------
;
RoundBreakAddr	proc	near

		assume	ds:nothing, es:nothing

		mov	ax, word ptr DevBrkAddr
		call	pararound
		add	word ptr DevBrkAddr+2, ax
		mov	word ptr DevBrkAddr, 0
		mov	ax, DevLoadEnd
		cmp	word ptr DevBrkAddr+2, ax
		jbe	rba_ok
		jmp	mem_err
rba_ok:
		ret
RoundBreakAddr	endp

;
;----------------------------------------------------------------------------
;
; procedure : DevSetBreak
;
;	Input : DevBrkAddr
;	Output : Carry set if Device returned Init failed
;		 Else carry clear
;
;----------------------------------------------------------------------------
;
DevSetBreak	proc	near

		assume	ds:nothing, es:nothing

		push	ax

		mov	ax,word ptr [DevBrkAddr+2]  ;remove the init code
		cmp	multdeviceflag, 0
		jne	set_break_continue	    ;do not check it.
		cmp	ax, DevLoadAddr
		jne	set_break_continue	    ;if not same, then o.k.

		cmp	word ptr [DevBrkAddr],0
		je	break_failed		;[DevBrkAddr+2]=[memhi] & [DevBrkAddr]=0

set_break_continue:
		call	RoundBreakAddr
		pop	ax
		clc
		ret
break_failed:
		pop	ax
		stc
		ret
DevSetBreak	endp

;
;----------------------------------------------------------------------------
;
; procedure : DevBreak
;
;	Input : DevLoadAddr & DevBrkAddr
;	Output : none
;
;	Marks a succesful install of a device driver
;	Sets device size field in sub-arena &
;	Updates Free ptr in UMB or adjusts memhi
;
;----------------------------------------------------------------------------
;
DevBreak	proc	near

		assume	ds:nothing, es:nothing

		push	ds
		mov	ax, DevLoadAddr
		mov	bx, word ptr [DevBrkAddr+2]
		dec	ax			; seg of sub-arena
		mov	ds, ax
		inc	ax			; Back to Device segment
		sub	ax, bx
		neg	ax			; size of device in paras
		mov	ds:[devmark_size], ax	; store it in sub-arena
		cmp	DeviceHi, 0
		je	db_lo
		mov	DevUMBFree, bx		; update Free ptr in UMB
		jmp	short db_exit
db_lo:
		mov	memhi, bx
		mov	memlo, 0
db_exit:
		pop	ds
		ret
DevBreak	endp
;
;----------------------------------------------------------------------------
;
; procedure : ParseSize
;
;	Parses the command line for SIZE= command
;
;	ES:SI = command line to parsed
;
;	returns ptr to command line after SIZE= option in ES:SI
;	updates the DevSizeOption variable with value supplied
;	in SIZE=option
;	Returns carry if the SIZE option was invalid
;
;----------------------------------------------------------------------------
;
ParseSize	proc	near

		assume	ds:nothing, es:nothing

		mov	DevSizeOption, 0	; init the value
		mov	word ptr DevCmdLine, si
		mov	word ptr DevCmdLine+2, es
		call	SkipDelim
		cmp	word ptr es:[si], 'IS'
		jne	ps_no_size
		cmp	word ptr es:[si+2], 'EZ'
		jne	ps_no_size
		mov	al, es:[si+4]
		call	delim
		jne	ps_no_size
		add	si, 5
		call	GetHexNum
		jc	ps_err
		mov	DevSizeOption, ax
		call	SkipDelim
ps_no_size:
		clc
		ret
ps_err:
		stc
		ret
ParseSize	endp
;
;----------------------------------------------------------------------------
;
; procedure : SkipDelim
;
;	Skips delimiters in the string pointed to by ES:SI
;	Returns ptr to first non-delimiter character in ES:SI
;
;----------------------------------------------------------------------------
;
SkipDelim	proc	near

		assume	ds:nothing, es:nothing

sd_next_char:
		mov	al, es:[si]
		call	delim
		jnz	sd_ret
		inc	si
		jmp	sd_next_char
sd_ret:
		ret
SkipDelim	endp
;
;----------------------------------------------------------------------------
;
; procedure : GetHexNum
;
;	Converts an ascii string terminated by a delimiter into binary.
;	Assumes that the ES:SI points to a Hexadecimal string
;
;	Returns in AX the number number of paras equivalent to the
;	hex number of bytes specified by the hexadecimal string.
;
;	Returns carry in case it encountered a non-hex character or
;	if it encountered crlf
;
;----------------------------------------------------------------------------
;
GetHexNum	proc	near

		assume	ds:nothing, es:nothing

		xor	ax, ax
		xor	dx, dx
ghn_next:
		mov	bl, es:[si]
		cmp	bl, cr
		je	ghn_err
		cmp	bl, lf
		je	ghn_err
		push	ax
		mov	al, bl
		call	Delim
		pop	ax
		jz	ghn_into_paras
		call	GetNibble
		jc	ghn_err
		mov	cx, 4
ghn_shift1:
		shl	ax, 1
		rcl	dx, 1
		loop	ghn_shift1
		or	al, bl
		inc	si
		jmp	ghn_next
ghn_into_paras:
		add	ax, 15
		adc	dx, 0
		test	dx, 0fff0h
		jnz	ghn_err
		mov	cx, 4
ghn_shift2:
		clc
		rcr	dx, 1
		rcr	ax, 1
		loop	ghn_shift2
		clc
		ret
ghn_err:
		stc
		ret
GetHexNum	endp
;
;----------------------------------------------------------------------------
;
; procedure : GetNibble
;
;	Convert one nibble (hex digit) in BL into binary
;
;	Retruns binary value in BL
;
;	Returns carry if BL contains non-hex digit
;
;----------------------------------------------------------------------------
;
GetNibble	proc	near
		cmp	bl, '0'
		jb	gnib_err
		cmp	bl, '9'
		ja	is_it_hex
		sub	bl, '0'			; clc
		ret
is_it_hex:
		cmp	bl, 'A'
		jb	gnib_err
		cmp	bl, 'F'
		ja	gnib_err
		sub	bl, 'A'- 10		; clc
		ret
gnib_err:
		stc
		ret
GetNibble	endp
;
;
;============================================================================
;============================================================================
;
;----------------------------------------------------------------------------
;
; procedure : AllocUMB
;
;	Allocate all UMBs and link it to DOS arena chain
;
;----------------------------------------------------------------------------
;
AllocUMB	proc	near
		call	InitAllocUMB		; link in the first UMB
		jc	au_exit			; quit on error
au_next:
		call	umb_allocate		; allocate
		jc	au_coalesce
		call	umb_insert		; & insert till no UMBs
		jmp	short au_next
au_coalesce:
		call	umb_coalesce		; coalesce all UMBs
au_exit:
		ret
AllocUMB	endp
;
;----------------------------------------------------------------------------
;
; procedure : InitAllocUMB
;
;----------------------------------------------------------------------------
;
InitAllocUMB	proc	near
		call	IsXMSLoaded
		jnz	iau_err			; quit on no XMS driver
		mov	ah, 52h
		int	21h			; get DOS DATA seg
		mov	DevDOSData, es		; & save it for later
		mov	ax, 4310h
		int	2fh
		mov	word ptr DevXMSAddr, bx	; get XMS driver address
		mov	word ptr DevXMSAddr+2, es
		cmp	FirstUMBLinked, 0	; have we already linked a UMB?
		jne	@f			; quit if we already did it
		call	LinkFirstUMB		; else link the first UMB
		jc	iau_err
		mov	FirstUMBLinked, 0ffh	; mark that 1st UMB linked
@@:
		clc
		ret
iau_err:
		stc
		ret
InitAllocUMB	endp

;-------------------------------------------------------------------------
;
; Procedure Name	: umb_allocate
;
; Inputs		: DS = data
;
; Outputs		: if UMB available
;				Allocates the largest available UMB and 
;			  	BX = segment of allocated block
;				DX = size of allocated block
;				NC
;			  else 
;				CY
;
; Uses			: BX, DX
;
;-------------------------------------------------------------------------

umb_allocate	proc	near

		push	ax
		mov	ah, XMM_REQUEST_UMB
		mov	dx, 0ffffh		; try to allocate largest
						;   possible
		call	dword ptr DevXMSAddr
						; dx now contains the size of
						; the largest UMB
		or	dx, dx
		jz	ua_err
	
		mov	ah, XMM_REQUEST_UMB
		call	dword ptr DevXMSAddr

		cmp	ax, 1			; Q: was the reqst successful
		jne	ua_err			; N: error

		clc

ua_done:
		pop	ax
		ret		

ua_err:
		stc
		jmp	short ua_done

umb_allocate	endp



;---------------------------------------------------------------------------
;
; Procedure Name	: umb_insert
;
; Inputs		: DOSDATA:UMB_HEAD = start of umb chain
;			: BX = seg address of UMB to be linked in
;			: DX = size of UMB to be linked in paras
;			; DS = data
;
; Outputs		: links the UMB into the arena chain
;
; Uses			: AX, CX, ES, DX, BX
;
;---------------------------------------------------------------------------


umb_insert	proc	near

		push	ds

		mov	ds, [DevDOSData]
		mov	ds, ds:[UMB_ARENA]	; es = UMB_HEAD
		mov	ax, ds
		mov	es, ax

ui_next:
		cmp	ax, bx			; Q: is current block above
						;    new block
		ja	ui_insert     		; Y: insert it
						; Q: is current block the
						;    last
		cmp	es:[arena_signature], arena_signature_end
		jz	ui_append		; Y: append new block to chain
						; N: get next block

		mov	ds, ax			; M005
		call	get_next		; ax = es = next block
		jmp	short ui_next

ui_insert:
	
		mov	cx, ds			; ds = previous arena
		inc	cx			; top of previous block

		sub	cx, bx
		neg	cx			; cx = size of used block
		mov	ds:[arena_signature], arena_signature_normal
		mov	ds:[arena_owner], 8	; mark as system owned
		mov	ds:[arena_size], cx	
		mov	word ptr ds:[arena_name], 'CS'

; prepare the arena at start of new block

		mov	es, bx
		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], arena_owner_system
						; mark as free
		sub	dx, 2			; make room for arena at
						; start & end of new block
		mov	es:[arena_size], dx	
		
; prepare arena at end of new block
	
		add	bx, dx
		inc	bx
		mov	es, bx			; es=arena at top of new block
		inc	bx			; bx=top of new block

						; ax contains arena just above
						; this block
		sub	ax, bx			; ax = size of used block
	
		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], 8	; mark as system owned
		mov	es:[arena_size], ax	
		mov	word ptr es:[arena_name], 'CS'

		jmp	short ui_done

ui_append:

						; es = arena of last block	

		add	ax, es:[arena_size]	; ax=top of last block-1 para
		sub	es:[arena_size], 1	; reflect the space we are
						; going to rsrv on top of this 
						; block for the next arena.
		mov	es:[arena_signature], arena_signature_normal

		mov	cx, ax			; cx=top of prev block-1
		inc	ax
		sub	ax, bx			; ax=top of prev block - 
						;    seg. address of new block

		neg	ax

		mov	es, cx			; ds = arena of unused block


		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], 8	; mark as system owned
		mov	es:[arena_size], ax	
		mov	word ptr es:[arena_name], 'CS'

; prepare the arena at start of new block

		mov	es, bx
		mov	es:[arena_signature], arena_signature_end
		mov	es:[arena_owner], arena_owner_system
						; mark as free
		dec	dx			; make room for arena
		mov	es:[arena_size], dx	

ui_done:
		pop	ds
		ret

umb_insert	endp


;
;----------------------------------------------------------------------------
;
;**	umb_coalesce - Combine free blocks ahead with current block
;
;	Coalesce adds the block following the argument to the argument block,
;	iff it's free.  Coalesce is usually used to join free blocks, but
;	some callers (such as $setblock) use it to join a free block to it's
;	preceeding allocated block.
;
;	EXIT	'C' clear if OK
;		  (ds) unchanged, this block updated
;		  (ax) = address of next block, IFF not at end
;		'C' set if arena trashed
;	USES	cx, di, ds, es
;
;----------------------------------------------------------------------------
;

umb_coalesce	proc	near



		xor	di, di

		mov	es, [DevDOSData]
		mov	es, es:[UMB_ARENA]	; es = UMB_HEAD

uc_nextfree:
		mov	ax, es
		mov	ds, ax
		cmp	es:[arena_owner], di	; Q: is current arena free
		jz	uc_again		; Y: try to coalesce with next block
						; N: get next arena
		call	get_next		; es, ax = next arena
		jc	uc_done
		jmp	short uc_nextfree
uc_again:
		call	get_next		; ES, AX <- next block
		jc	uc_done
uc_check:
		cmp     es:[arena_owner],di	; Q: is arena free
		jnz	uc_nextfree		; N: get next free arena
						; Y: coalesce
		mov     cx,es:[arena_size]      ; cx <- next block size
		inc     cx                      ; cx <- cx + 1 (for header size)
		add     ds:[arena_size],cx      ; current size <- current size + cx
		mov     cl,es:[di]              ; move up signature
		mov     ds:[di],cl
		jmp     short uc_again		; try again
uc_done:
		ret

umb_coalesce	endp

;
;----------------------------------------------------------------------------
;
;**	get_next - Find Next item in Arena
;
;	ENTRY	dS - pointer to block head
;	EXIT	AX,ES - pointers to next head
;		'C' set iff arena damaged
;
;----------------------------------------------------------------------------
;

get_next	proc	near

		cmp	byte ptr ds:[0], arena_signature_end
		je	gn_err

		mov     ax,ds                   ; ax=current block
		add     ax,ds:[arena_size]      ; ax=ax + current block length
		inc     ax                      ; remember that header!
		mov	es, ax
		clc
		ret
gn_err:
		stc
		ret

get_next	endp

;
;----------------------------------------------------------------------------
;
; procedure : LinkFirstUMB
;
;----------------------------------------------------------------------------
;
LinkFirstUMB	proc	near

		call	umb_allocate
		jc	lfu_err

; bx = segment of allocated UMB
; dx = size of UMB

		int	12h			; ax = size of memory
		mov	cl, 6
		shl	ax, cl			; ax = size in paragraphs

		mov	cx, ax			; cx = size in paras
		sub	ax, bx			; ax = - size of unused block

		neg	ax

		sub	cx, 1			; cx = first umb_arena
		mov	es, cx			; es = first umb_arena
	
		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], 8	; mark as system owned
					
		mov	es:[arena_size], ax	
		mov	word ptr es:[arena_name], 'CS'


; put in the arena for the first UMB

		mov	es, bx			; es has first free umb seg
		mov	es:[arena_signature], arena_signature_end
		mov	es:[arena_owner], arena_owner_system	
						; mark as free 
		dec	dx			; make room for arena
		mov	es:[arena_size], dx	


		mov	es, [DevDOSData]
		mov	di, UMB_ARENA
		mov	es:[di], cx		; initialize umb_head in DOS
						;  data segment with the arena
						;  just below Top of Mem

; we must now scan the arena chain and update the size of the last
; arena

		mov	di, DOS_ARENA
		mov	es, word ptr es:[di]	; es = start arena
		xor	di, di

	
scan_next:
		cmp	byte ptr es:[di], arena_signature_end
		jz	got_last
	
		mov	ax, es
		add	ax, es:[arena_size]
		inc	ax
		mov	es, ax
		jmp	short scan_next

got_last:
;; -williamh- we reserved the last paragraph for UMB_HEAD already.
;; refer to sysinit1.asm!goinit
;; The following instruction was commentted out for this reason.
;;		sub	es:[arena_size], 1
;;
		mov	es:[arena_signature], arena_signature_normal
		clc
		ret

lfu_err:
		stc
		ret
LinkFirstUMB	endp

;
;----------------------------------------------------------------------------
;
; procedure : ShrinkUMB
;
;	Shrinks the current UMB in use, so that the unused portions
;	of the UMB is given back to the DOS free mem pool
;
;----------------------------------------------------------------------------
;
		public	ShrinkUMB

ShrinkUMB	proc	near
		cmp	DevUMBAddr, 0
		je	su_exit
		push	es
		push	bx
		mov	bx, DevUMBFree
		sub	bx, DevUMBAddr
		mov	es, DevUMBAddr
		mov	ax, 4a00h
		int	21h
		mov	ax, es
		dec	ax
		mov	es, ax
		mov	word ptr es:[arena_owner], 8
		pop	bx
		pop	es
su_exit:
		ret
ShrinkUMB	endp

;M002 - BEGIN
;
;----------------------------------------------------------------------------
;
; procedure : UnlinkUMB
;
;	Unlinks the UMBs from the DOS arena chain
;
;----------------------------------------------------------------------------
;
		public	UnlinkUMB

UnlinkUMB	proc	near
		push	ds
		push	es
		cmp	FirstUMBLinked, 0
		je	ulu_x			; nothing to unlink
		mov	es, DevDOSData		; get DOS data seg
		mov	ds, es:[DOS_ARENA]
		mov	di, es:[UMB_ARENA]
ulu_next:
		call	get_next
		jc	ulu_x
		cmp	di, ax			; is the next one UMB ?
		je	ulu_found
		mov	ds, ax
		jmp	ulu_next
ulu_found:
		mov	ds:[arena_signature], 'Z'	
ulu_x:
		pop	es
		pop	ds
		ret
UnlinkUMB	endp

;M002 - END

; =========================================================================
;
sysinitseg	ends
		end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\spcmse.asm ===
;       Program:        Installable Device Driver for Mouse.
;
;       Purpose:        to provide compatability with the
;                       Microsoft MOUSE.SYS device driver.
;                       the code here installs the driver and
;                       hooks the IVT in exactly the same
;                       way as the current Insignia MOUSE.COM.
;
;       Version:        1.00    Date: 28th October 1992.
;
;       Author:         Andrew Watson
;
;       Revisions:
;
;	23-June-1994 Williamh, made mode 4/5 and 12 work.
;
;       12-Sep-1992 Jonle, Merged with ntio.sys
;                          optimized loading of IVT
;
;       5-March-1993 Andyw, Moved fullscreen text pointer code
;                           from 32bit land to 16bit driver for
;                           for speed purposes.
;
;      This obj module is intially loaded in a temporary memory location
;      along with ntio.sys. Ntio.sys will copy the resident code (marked by
;      SpcMseBeg, SpcMseEnd) into the permanent memory location which resides
;      just below the normal device drivers loaded by config.sys.
;
;      The nonresident intialization code is run with CS= temp seg
;      and DS= final seg.
;
;
;****************************************************************

.286
        include vint.inc

;================================================================
; Defined constants used in the driver.
;================================================================


        VERSIONID       equ     0BEEFh
        MAXCMD          equ     16
        UNKNOWN         equ     8003h
        DONE            equ     0100h
        MOUSEVER        equ     0003h
        INT1_BOP        equ     0BAh
        INT2_BOP        equ     0BBh
        IO_LANG_BOP     equ     0BCh
        IO_INTR_BOP     equ     0BDh
        VIDEO_IO_BOP    equ     0BEh
        UNSIMULATE_BOP  equ     0FEh
        VIDEO           equ     010h
        UNEXP_BOP       equ     2
        FORCE_YODA      equ     05bh
        ANDYS_BOP       equ     060h
        STACKSIZE       equ     200h-1

        TRUE            equ     0
        FALSE           equ     1
        STORED          equ     0
        NOTSTORED       equ     1
        ON              equ     0
        OFF             equ     1

        MAJOR_RELEASE_NUMBER    equ     6
        MINOR_RELEASE_NUMBER    equ     26



;MACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROS

bop MACRO callid
    db 0c4h,0c4h,callid
endm



;=============================================================================
; Macro to reassign the stack segment register to point at the driver code
; segment and the stack pointer to point to the most significant word in an
; array reserved as the driver stack.
;=============================================================================


;; !!!! interrupt must be disabled before calling this function !!!!!!

make_stack      MACRO
        LOCAL   reent                   ;; a local symbol to this macro
;;	 call	 DOCLI			 ;; turn off interrupts during this
                                        ;; macro's execution even if the CPU
                                        ;; does this for you when modifying SS
        inc     cs:reentrant            ;; has the interrupt been nested?
        jnz     reent                   ;; not reentrant if == zero

        ;; The driver code is not reentrant, so start the stack at the beginning

        mov     cs:top_of_stack,ss      ;; save the entry SS
        mov     cs:top_of_stack-2,sp    ;; save SP on the stack
        push    cs                      ;; the current code/data segment
        pop     ss                      ;; point SS at CS

        ;; point SP at the next free stack location.

        mov     sp,offset top_of_stack-2 ;; The current stack pointer position

reent:  ;; REENTRANT > 0 therefore reentrancy exists
        ;; The driver has gone reentrant due to a nested interrupt, so just
        ;; leave the stack alone because it is the same under reentrancy.

;;	 call  DOSTI				 ;; reenable interrupts

        ENDM

;=============================================================================
; Macro to return the stack pointer and segment back to what it was when
; the driver was called.
;=============================================================================

kill_stack      MACRO
        LOCAL   reent1
;;	 cli
        cmp     cs:reentrant,0          ;; is the code currently reentrant?
        jg      reent1                  ;; yes it is
        mov     sp,cs:top_of_stack-2    ;; pop SP
        mov     ss,cs:top_of_stack      ;; pop SS
reent1:
        dec     cs:reentrant            ;; reduce the level of reentrancy
;;	 call	 DOSTI
        ENDM

;MACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROS

;
; Segment definitions for ntio.sys,
;
include biosseg.inc




SpcMseSeg    segment
             assume  cs:SpcMseSeg, ds:nothing, es:nothing

;
; SpcMseBeg - SpcMseEnd
;
; Marks the resident code, anything outside of these markers
; is discarded after intialization
; 15-Sep-1992 Jonle
;

        public SpcMseBeg

SpcMseBeg    label  byte

  ; CAUTION: for crazy apps mouse recognition
  ;
  ; The offset for int33h_vector must not be Zero for Borlands QuattroPro
  ; The segment must not be in ROM area for pctools
  ; to keep the int33h_vector from having an offset of ZERO
  ; I have moved the data above it
  ; 25-Sep-1992 Jonle


; describe the default screen and cursor masks
; remember that x86 machines are little-endian

        ;;; include     pointer.inc
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;;; We'll Get this back to an include file soon but I'm including it like
 ;;;; this for 'diplomatic' reasons. (ie I want to check this in without
 ;;;; also doing an 'addfile' at this stage)!!! - Simon.
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This data will be accessed, on occasion, word by word, so
; be tidy and align to a word boundary

align   2

; Describe the default mouse pointer image. This is used if the
; user decides to switch on the pointer without specifying an image.

default_cursor		dw	0011111111111111b
			dw	0001111111111111b
			dw	0000111111111111b
			dw	0000011111111111b
			dw	0000001111111111b
			dw	0000000111111111b
			dw	0000000011111111b
			dw	0000000001111111b
			dw	0000000000111111b
			dw	0000000000011111b
			dw	0000000111111111b
			dw	0001000011111111b
			dw	0011000011111111b
			dw	1111100001111111b
			dw	1111100001111111b
			dw	1111110001111111b
			dw	0000000000000000b
			dw	0100000000000000b
			dw	0110000000000000b
			dw	0111000000000000b
			dw	0111100000000000b
			dw	0111110000000000b
			dw	0111111000000000b
			dw	0111111100000000b
			dw	0111111110000000b
			dw	0111110000000000b
			dw	0110110000000000b
			dw	0100011000000000b
			dw	0000011000000000b
			dw	0000001100000000b
			dw	0000001100000000b
			dw	0000000000000000b

        ; Set up the memory where the working cursor is situated. It is
        ; initialised to the default cursor image

;****************** ALIGNED FOR PIXEL ZERO *******************************

                ; screen mask

even
current_cursor          db      00111111b,11111111b,11111111b
                        db      00011111b,11111111b,11111111b
                        db      00001111b,11111111b,11111111b
                        db      00000111b,11111111b,11111111b
                        db      00000011b,11111111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000000b,01111111b,11111111b
                        db      00000000b,00111111b,11111111b
                        db      00000000b,00011111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00010000b,11111111b,11111111b
                        db      00110000b,11111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111100b,01111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      01000000b,00000000b,00000000b
                        db      01100000b,00000000b,00000000b
                        db      01110000b,00000000b,00000000b
                        db      01111000b,00000000b,00000000b
                        db      01111100b,00000000b,00000000b
                        db      01111110b,00000000b,00000000b
                        db      01111111b,00000000b,00000000b
                        db      01111111b,10000000b,00000000b
                        db      01111111b,11000000b,00000000b
                        db      01101100b,00000000b,00000000b
                        db      01000110b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL ONE *******************************

                ; screen mask

AlignData1:
                        db      10011111b,11111111b,11111111b
                        db      10001111b,11111111b,11111111b
                        db      10000111b,11111111b,11111111b
                        db      10000011b,11111111b,11111111b
                        db      10000001b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,01111111b,11111111b
                        db      10000000b,00111111b,11111111b
                        db      10000000b,00011111b,11111111b
                        db      10000000b,00001111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10001000b,01111111b,11111111b
                        db      10011000b,01111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111110b,00111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00100000b,00000000b,00000000b
                        db      00110000b,00000000b,00000000b
                        db      00111000b,00000000b,00000000b
                        db      00111100b,00000000b,00000000b
                        db      00111110b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00111111b,10000000b,00000000b
                        db      00111111b,11000000b,00000000b
                        db      00111111b,11100000b,00000000b
                        db      00110110b,00000000b,00000000b
                        db      00100011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL TWO *******************************

                ; screen mask

AlignData2:
                        db      11001111b,11111111b,11111111b
                        db      11000111b,11111111b,11111111b
                        db      11000011b,11111111b,11111111b
                        db      11000001b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,01111111b,11111111b
                        db      11000000b,00111111b,11111111b
                        db      11000000b,00011111b,11111111b
                        db      11000000b,00001111b,11111111b
                        db      11000000b,00000111b,11111111b
                        db      11000000b,01111111b,11111111b
                        db      11000100b,00111111b,11111111b
                        db      11001100b,00111111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111111b,00011111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00010000b,00000000b,00000000b
                        db      00011000b,00000000b,00000000b
                        db      00011100b,00000000b,00000000b
                        db      00011110b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,10000000b,00000000b
                        db      00011111b,11000000b,00000000b
                        db      00011111b,11100000b,00000000b
                        db      00011111b,11110000b,00000000b
                        db      00011011b,00000000b,00000000b
                        db      00010001b,10000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL THREE *******************************

                ; screen mask

AlignData3:
                        db      11100111b,11111111b,11111111b
                        db      11100011b,11111111b,11111111b
                        db      11100001b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,01111111b,11111111b
                        db      11100000b,00111111b,11111111b
                        db      11100000b,00011111b,11111111b
                        db      11100000b,00001111b,11111111b
                        db      11100000b,00000111b,11111111b
                        db      11100000b,00000011b,11111111b
                        db      11100000b,00111111b,11111111b
                        db      11100010b,00011111b,11111111b
                        db      11100110b,00011111b,11111111b
                        db      11111111b,00001111b,11111111b
                        db      11111111b,00001111b,11111111b
                        db      11111111b,10001111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00001000b,00000000b,00000000b
                        db      00001100b,00000000b,00000000b
                        db      00001110b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,10000000b,00000000b
                        db      00001111b,11000000b,00000000b
                        db      00001111b,11100000b,00000000b
                        db      00001111b,11110000b,00000000b
                        db      00001111b,11111000b,00000000b
                        db      00001101b,10000000b,00000000b
                        db      00001000b,11000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FOUR *******************************

                ; screen mask

AlignData4:
                        db      11110011b,11111111b,11111111b
                        db      11110001b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,01111111b,11111111b
                        db      11110000b,00111111b,11111111b
                        db      11110000b,00011111b,11111111b
                        db      11110000b,00001111b,11111111b
                        db      11110000b,00000111b,11111111b
                        db      11110000b,00000011b,11111111b
                        db      11110000b,00000001b,11111111b
                        db      11110000b,00011111b,11111111b
                        db      11110001b,00001111b,11111111b
                        db      11110011b,00001111b,11111111b
                        db      11111111b,10000111b,11111111b
                        db      11111111b,10000111b,11111111b
                        db      11111111b,11000111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000100b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,10000000b,00000000b
                        db      00000111b,11000000b,00000000b
                        db      00000111b,11100000b,00000000b
                        db      00000111b,11110000b,00000000b
                        db      00000111b,11111000b,00000000b
                        db      00000111b,11111100b,00000000b
                        db      00000110b,11000000b,00000000b
                        db      00000100b,01100000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FIVE *******************************

                ; screen mask
AlignData5:

                        db      11111001b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111000b,00111111b,11111111b
                        db      11111000b,00011111b,11111111b
                        db      11111000b,00001111b,11111111b
                        db      11111000b,00000111b,11111111b
                        db      11111000b,00000011b,11111111b
                        db      11111000b,00000001b,11111111b
                        db      11111000b,00000000b,11111111b
                        db      11111000b,00001111b,11111111b
                        db      11111000b,10000111b,11111111b
                        db      11111001b,10000111b,11111111b
                        db      11111111b,11000011b,11111111b
                        db      11111111b,11000011b,11111111b
                        db      11111111b,11100011b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000010b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,10000000b,00000000b
                        db      00000011b,11000000b,00000000b
                        db      00000011b,11100000b,00000000b
                        db      00000011b,11110000b,00000000b
                        db      00000011b,11111000b,00000000b
                        db      00000011b,11111100b,00000000b
                        db      00000011b,11111110b,00000000b
                        db      00000011b,01100000b,00000000b
                        db      00000010b,00110000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SIX *******************************

                ; screen mask

AlignData6:
                        db      11111100b,11111111b,11111111b
                        db      11111100b,01111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111100b,00011111b,11111111b
                        db      11111100b,00001111b,11111111b
                        db      11111100b,00000111b,11111111b
                        db      11111100b,00000011b,11111111b
                        db      11111100b,00000001b,11111111b
                        db      11111100b,00000000b,11111111b
                        db      11111100b,00000000b,01111111b
                        db      11111100b,00000111b,11111111b
                        db      11111100b,01000011b,11111111b
                        db      11111100b,11000011b,11111111b
                        db      11111111b,11100001b,11111111b
                        db      11111111b,11100001b,11111111b
                        db      11111111b,11110001b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000001b,11000000b,00000000b
                        db      00000001b,11100000b,00000000b
                        db      00000001b,11110000b,00000000b
                        db      00000001b,11111000b,00000000b
                        db      00000001b,11111100b,00000000b
                        db      00000001b,11111110b,00000000b
                        db      00000001b,11111111b,00000000b
                        db      00000001b,10110000b,00000000b
                        db      00000001b,00011000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SEVEN *******************************

                ; screen mask
AlignData7:

                        db      11111110b,01111111b,11111111b
                        db      11111110b,00111111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111110b,00001111b,11111111b
                        db      11111110b,00000111b,11111111b
                        db      11111110b,00000011b,11111111b
                        db      11111110b,00000001b,11111111b
                        db      11111110b,00000000b,11111111b
                        db      11111110b,00000000b,01111111b
                        db      11111110b,00000000b,00111111b
                        db      11111110b,00000011b,11111111b
                        db      11111110b,00100001b,11111111b
                        db      11111110b,01100001b,11111111b
                        db      11111111b,11110000b,11111111b
                        db      11111111b,11110000b,11111111b
                        db      11111111b,11111000b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000000b,10000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,11100000b,00000000b
                        db      00000000b,11110000b,00000000b
                        db      00000000b,11111000b,00000000b
                        db      00000000b,11111100b,00000000b
                        db      00000000b,11111110b,00000000b
                        db      00000000b,11111111b,00000000b
                        db      00000000b,11111111b,10000000b
                        db      00000000b,11011000b,00000000b
                        db      00000000b,10001100b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00000110b,00000000b
                        db      00000000b,00000110b,00000000b
                        db      00000000b,00000000b,00000000b


; Data area reserved for the clipped cursor images. When the pointer
; reaches byte 78 in the current raster, the image needs to be clipped
; to prevent it from being wrapped to the left hand edge of the screen.
; The image below stops that from happening by loading the image with
; a 1's partial AND mask and a 0's partial XOR mask.
; Note that byte 79 also needs a clipped image set.

even
clip_cursor78           db      00111111b,11111111b,11111111b
                        db      00011111b,11111111b,11111111b
                        db      00001111b,11111111b,11111111b
                        db      00000111b,11111111b,11111111b
                        db      00000011b,11111111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000000b,01111111b,11111111b
                        db      00000000b,00111111b,11111111b
                        db      00000000b,00011111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00010000b,11111111b,11111111b
                        db      00110000b,11111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111100b,01111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      01000000b,00000000b,00000000b
                        db      01100000b,00000000b,00000000b
                        db      01110000b,00000000b,00000000b
                        db      01111000b,00000000b,00000000b
                        db      01111100b,00000000b,00000000b
                        db      01111110b,00000000b,00000000b
                        db      01111111b,00000000b,00000000b
                        db      01111111b,10000000b,00000000b
                        db      01111111b,11000000b,00000000b
                        db      01101100b,00000000b,00000000b
                        db      01000110b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL ONE *******************************

                ; screen mask

AlignClip178:
                        db      10011111b,11111111b,11111111b
                        db      10001111b,11111111b,11111111b
                        db      10000111b,11111111b,11111111b
                        db      10000011b,11111111b,11111111b
                        db      10000001b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,01111111b,11111111b
                        db      10000000b,00111111b,11111111b
                        db      10000000b,00011111b,11111111b
                        db      10000000b,00001111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10001000b,01111111b,11111111b
                        db      10011000b,01111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111110b,00111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00100000b,00000000b,00000000b
                        db      00110000b,00000000b,00000000b
                        db      00111000b,00000000b,00000000b
                        db      00111100b,00000000b,00000000b
                        db      00111110b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00111111b,10000000b,00000000b
                        db      00111111b,11000000b,00000000b
                        db      00111111b,11100000b,00000000b
                        db      00110110b,00000000b,00000000b
                        db      00100011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL TWO *******************************

                ; screen mask

AlignClip278:
                        db      11001111b,11111111b,11111111b
                        db      11000111b,11111111b,11111111b
                        db      11000011b,11111111b,11111111b
                        db      11000001b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,01111111b,11111111b
                        db      11000000b,00111111b,11111111b
                        db      11000000b,00011111b,11111111b
                        db      11000000b,00001111b,11111111b
                        db      11000000b,00000111b,11111111b
                        db      11000000b,01111111b,11111111b
                        db      11000100b,00111111b,11111111b
                        db      11001100b,00111111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111111b,00011111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00010000b,00000000b,00000000b
                        db      00011000b,00000000b,00000000b
                        db      00011100b,00000000b,00000000b
                        db      00011110b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,10000000b,00000000b
                        db      00011111b,11000000b,00000000b
                        db      00011111b,11100000b,00000000b
                        db      00011111b,11110000b,00000000b
                        db      00011011b,00000000b,00000000b
                        db      00010001b,10000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL THREE *******************************

                ; screen mask

AlignClip378:
                        db      11100111b,11111111b,11111111b
                        db      11100011b,11111111b,11111111b
                        db      11100001b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,01111111b,11111111b
                        db      11100000b,00111111b,11111111b
                        db      11100000b,00011111b,11111111b
                        db      11100000b,00001111b,11111111b
                        db      11100000b,00000111b,11111111b
                        db      11100000b,00000011b,11111111b
                        db      11100000b,00111111b,11111111b
                        db      11100010b,00011111b,11111111b
                        db      11100110b,00011111b,11111111b
                        db      11111111b,00001111b,11111111b
                        db      11111111b,00001111b,11111111b
                        db      11111111b,10001111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00001000b,00000000b,00000000b
                        db      00001100b,00000000b,00000000b
                        db      00001110b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,10000000b,00000000b
                        db      00001111b,11000000b,00000000b
                        db      00001111b,11100000b,00000000b
                        db      00001111b,11110000b,00000000b
                        db      00001111b,11111000b,00000000b
                        db      00001101b,10000000b,00000000b
                        db      00001000b,11000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FOUR *******************************

                ; screen mask

AlignClip478:
                        db      11110011b,11111111b,11111111b
                        db      11110001b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,01111111b,11111111b
                        db      11110000b,00111111b,11111111b
                        db      11110000b,00011111b,11111111b
                        db      11110000b,00001111b,11111111b
                        db      11110000b,00000111b,11111111b
                        db      11110000b,00000011b,11111111b
                        db      11110000b,00000001b,11111111b
                        db      11110000b,00011111b,11111111b
                        db      11110001b,00001111b,11111111b
                        db      11110011b,00001111b,11111111b
                        db      11111111b,10000111b,11111111b
                        db      11111111b,10000111b,11111111b
                        db      11111111b,11000111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000100b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,10000000b,00000000b
                        db      00000111b,11000000b,00000000b
                        db      00000111b,11100000b,00000000b
                        db      00000111b,11110000b,00000000b
                        db      00000111b,11111000b,00000000b
                        db      00000111b,11111100b,00000000b
                        db      00000110b,11000000b,00000000b
                        db      00000100b,01100000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FIVE *******************************

                ; screen mask
AlignClip578:

                        db      11111001b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111000b,00111111b,11111111b
                        db      11111000b,00011111b,11111111b
                        db      11111000b,00001111b,11111111b
                        db      11111000b,00000111b,11111111b
                        db      11111000b,00000011b,11111111b
                        db      11111000b,00000001b,11111111b
                        db      11111000b,00000000b,11111111b
                        db      11111000b,00001111b,11111111b
                        db      11111000b,10000111b,11111111b
                        db      11111001b,10000111b,11111111b
                        db      11111111b,11000011b,11111111b
                        db      11111111b,11000011b,11111111b
                        db      11111111b,11100011b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000010b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,10000000b,00000000b
                        db      00000011b,11000000b,00000000b
                        db      00000011b,11100000b,00000000b
                        db      00000011b,11110000b,00000000b
                        db      00000011b,11111000b,00000000b
                        db      00000011b,11111100b,00000000b
                        db      00000011b,11111110b,00000000b
                        db      00000011b,01100000b,00000000b
                        db      00000010b,00110000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SIX *******************************

                ; screen mask

AlignClip678:
                        db      11111100b,11111111b,11111111b
                        db      11111100b,01111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111100b,00011111b,11111111b
                        db      11111100b,00001111b,11111111b
                        db      11111100b,00000111b,11111111b
                        db      11111100b,00000011b,11111111b
                        db      11111100b,00000001b,11111111b
                        db      11111100b,00000000b,11111111b
                        db      11111100b,00000000b,11111111b
                        db      11111100b,00000111b,11111111b
                        db      11111100b,01000011b,11111111b
                        db      11111100b,11000011b,11111111b
                        db      11111111b,11100001b,11111111b
                        db      11111111b,11100001b,11111111b
                        db      11111111b,11110001b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000001b,11000000b,00000000b
                        db      00000001b,11100000b,00000000b
                        db      00000001b,11110000b,00000000b
                        db      00000001b,11111000b,00000000b
                        db      00000001b,11111100b,00000000b
                        db      00000001b,11111110b,00000000b
                        db      00000001b,11111111b,00000000b
                        db      00000001b,10110000b,00000000b
                        db      00000001b,00011000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SEVEN *******************************

                ; screen mask
AlignClip778:

                        db      11111110b,01111111b,11111111b
                        db      11111110b,00111111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111110b,00001111b,11111111b
                        db      11111110b,00000111b,11111111b
                        db      11111110b,00000011b,11111111b
                        db      11111110b,00000001b,11111111b
                        db      11111110b,00000000b,11111111b
                        db      11111110b,00000000b,11111111b
                        db      11111110b,00000000b,11111111b
                        db      11111110b,00000011b,11111111b
                        db      11111110b,00100001b,11111111b
                        db      11111110b,01100001b,11111111b
                        db      11111111b,11110000b,11111111b
                        db      11111111b,11110000b,11111111b
                        db      11111111b,11111000b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000000b,10000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,11100000b,00000000b
                        db      00000000b,11110000b,00000000b
                        db      00000000b,11111000b,00000000b
                        db      00000000b,11111100b,00000000b
                        db      00000000b,11111110b,00000000b
                        db      00000000b,11111111b,00000000b
                        db      00000000b,11111111b,00000000b
       			db      00000000b,11011000b,00000000b
                        db      00000000b,10001100b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00000110b,00000000b
                        db      00000000b,00000110b,00000000b
                        db      00000000b,00000000b,00000000b


clip_cursor79           db      00111111b,11111111b,11111111b
                        db      00011111b,11111111b,11111111b
                        db      00001111b,11111111b,11111111b
                        db      00000111b,11111111b,11111111b
                        db      00000011b,11111111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00010000b,11111111b,11111111b
                        db      00110000b,11111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111100b,01111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      01000000b,00000000b,00000000b
                        db      01100000b,00000000b,00000000b
                        db      01110000b,00000000b,00000000b
                        db      01111000b,00000000b,00000000b
                        db      01111100b,00000000b,00000000b
                        db      01111110b,00000000b,00000000b
                        db      01111111b,00000000b,00000000b
                        db      01111111b,00000000b,00000000b
                        db      01111111b,00000000b,00000000b
                        db      01101100b,00000000b,00000000b
                        db      01000110b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL ONE *******************************

                ; screen mask

AlignClip179:
                        db      10011111b,11111111b,11111111b
                        db      10001111b,11111111b,11111111b
                        db      10000111b,11111111b,11111111b
                        db      10000011b,11111111b,11111111b
                        db      10000001b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10001000b,11111111b,11111111b
                        db      10011000b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00100000b,00000000b,00000000b
                        db      00110000b,00000000b,00000000b
                        db      00111000b,00000000b,00000000b
                        db      00111100b,00000000b,00000000b
                        db      00111110b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00110110b,00000000b,00000000b
                        db      00100011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL TWO *******************************

                ; screen mask

AlignClip279:
                        db      11001111b,11111111b,11111111b
                        db      11000111b,11111111b,11111111b
                        db      11000011b,11111111b,11111111b
                        db      11000001b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000100b,11111111b,11111111b
                        db      11001100b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00010000b,00000000b,00000000b
                        db      00011000b,00000000b,00000000b
                        db      00011100b,00000000b,00000000b
                        db      00011110b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011011b,00000000b,00000000b
                        db      00010001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL THREE *******************************

                ; screen mask

AlignClip379:
                        db      11100111b,11111111b,11111111b
                        db      11100011b,11111111b,11111111b
                        db      11100001b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100010b,11111111b,11111111b
                        db      11100110b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00001000b,00000000b,00000000b
                        db      00001100b,00000000b,00000000b
                        db      00001110b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001101b,00000000b,00000000b
                        db      00001000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FOUR *******************************

                ; screen mask

AlignClip479:
                        db      11110011b,11111111b,11111111b
                        db      11110001b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110001b,11111111b,11111111b
                        db      11110011b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000100b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000100b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FIVE *******************************

                ; screen mask
AlignClip579:

                        db      11111001b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111001b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000010b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000010b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SIX *******************************

                ; screen mask

AlignClip679:
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SEVEN *******************************

                ; screen mask
AlignClip779:

                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b

CursorOffsetLUT         dw      current_cursor
                        dw      AlignData1
                        dw      AlignData2
                        dw      AlignData3
                        dw      AlignData4
                        dw      AlignData5
                        dw      AlignData6
                        dw      AlignData7
ClipOffsetLUT78         dw      clip_cursor78
                        dw      AlignClip178
                        dw      AlignClip278
                        dw      AlignClip378
                        dw      AlignClip478
                        dw      AlignClip578
                        dw      AlignClip678
                        dw      AlignClip778
ClipOffsetLUT79         dw      clip_cursor79
                        dw      AlignClip179
                        dw      AlignClip279
                        dw      AlignClip379
                        dw      AlignClip479
                        dw      AlignClip579
                        dw      AlignClip679
                        dw      AlignClip779

; pointer to the current look up table set for the pointer image.
; The LUTs are swapped when the pointer enters bytes 78 and 79
; along a scanline to prevent the pointer wrapping around the screen.

PointerLUT              label   word
                        dw      offset  CursorOffsetLUT
 ;;;;;;;;;;;;;;;;;;;;;;;
 ;;;; End of what should be an include for pointer.inc
 ;;;;;;;;;;;;;;;;;;;;;;;

	even
        clrgend		dw	06e41h,07964h,05720h,07461h,06f73h,0f36eh
	hiresylut	dw	350,350,480,480
		
;============================================================================
; Surprisingly, a look up table multiply is much faster than
; the shift - add instruction sequence for multiplying by 80.
; So it would be silly not to use it eh? Times by 80 is needed
; to convert a raster location (1 raster = 80 bytes) in pixel
; y coordinates into a video buffer byte index
; Note: Multiply by 80 is also used for text mode calculations
; now! Andy on the 9/3/93
;============================================================================
        even

        mult80lut       label   word

                mulsum=0
                REPT    480             ; number of VGA scanlines for mode 12h
                dw      mulsum
                mulsum=mulsum+80
                ENDM

;============================================================================
; A table to do a multiply by 320. This is used for converting number of
; rasters into video buffer offsets for mode 13h (256 VGA colour mode).
;============================================================================
        even

        mult320lut      label   word

                mulsum=0
                REPT    200             ; number of VGA scanlines for mode 13h
                dw      mulsum
                mulsum=mulsum+320
                ENDM
        even

;============================================================================
; Look up table for use with modes 10h and 12h. This table provides the means
; for the selection of a clipped or unclipped pointer image depending on the
; current x position of the pointer.
;============================================================================

        ChooseImageLUT  label   word

                REPT    624
                dw      offset CursorOffsetLUT
                ENDM

                REPT    8
                dw      offset ClipOffsetLUT78
                ENDM

                REPT    8
                dw      offset ClipOffsetLUT79
                ENDM

;============================================================================
; Buffer arranged for 4 plane EGA video modes. The screen where
; the pointer is going to be drawn is scanned plane by plane and
; saved as bitplane separations.
;============================================================================

        even            ; make sure that this data is word aligned

        behindcursor    dw      24 dup(?)       ; Plane 0
                        dw      24 dup(?)       ; Plane 1
                        dw      24 dup(?)       ; Plane 2
                        dw      24 dup(?)       ; Plane 3


;============================================================================
; a table of the video buffer segment for the supported
; BIOS text and graphics modes.
;============================================================================

        even            ; make sure that this data is word aligned

        videomodetable  dw      0b800h,0b800h   ; modes 0,1
                        dw      0b800h,0b800h   ; modes 2,3
                        dw      0b800h,0b800h   ; modes 4,5
                        dw      0b800h,0b000h   ; modes 6,7
                        dw      0ffffh,0ffffh   ; n/a
                        dw      0ffffh,0ffffh   ; n/a
                        dw      0ffffh,0a000h   ; n/a,mode 0dh
                        dw      0a000h,0a000h   ; modes 0eh,0fh
                        dw      0a000h,0a000h   ; modes 10h,11h
                        dw      0a000h,0a000h   ; modes 12h,13h
        videobufferseg  dw      ?

        even            ; make sure that this data is word aligned

        hotspot         dw      2 dup(0)

	VRAMlasttextcelloff	label	word	; last text offset in VRAM
        VRAMlastbyteoff dw      ?               ; Last offset in VRAM
	VRAMlastbitoff	dw	?		; LSB: Where pointer is in byte
						; MSB: ODD/EVEN of the pointer
						;      first scan line
	LastXCounters	dw	?		; last X looping counter
	LastYCounters	dw	?		; last Y looping counter
						; ODD in LSB and EVEN in MSB
	lasttextimage	dw	?		; text cell from last time

        background      dw      NOTSTORED       ; STORED if data in buffer
        current_position_x      dw      ?
        current_position_y      dw      ?
        vidbytealigned  dw      ?
        lastmaskrotate  dw      ?
        lastvidmode     db      0ffh    ; the video mode during the last int.
        internalCF      db      0ffh    ; the mouse driver keeps a flag called
                                        ; the internal cursor flag. If the flag
                                        ; = 0, then int 33h f1 will display the
                                        ; pointer, -1 = default value.

 	; 32 bit code writes to this area on a hardware interrupt and
	; when an app does an int 33h function 3, it reads the data
	; directly from here.
	; Data format is: word 0 -> button status
	;                 word 1 -> x virtual coordinate
	;                 word 2 -> y virtual coordinate

	function3data	dw	3 dup(?)

	conditional_off db	0	;!= 0 if conditional off is on
					;
;=============================================================================
; Data to determine the address of where the latches should be saved in the
; video buffer for the current video mode.
; latchcache contains the value looked up by saveVGAregisters and used by
; restoreVGAregisters.
;=============================================================================


        latchcache      dw      ?       ; location of latch cache in VRAM
even
latchhomeLUT    label   word
                        dw      ?               ; mode 0
                        dw      ?               ; mode 1
                        dw      ?               ; mode 2
                        dw      ?               ; mode 3
                        dw      ?               ; mode 4
                        dw      ?               ; mode 5
                        dw      ?               ; mode 6
                        dw      ?               ; mode 7
                        dw      ?               ; mode 8
                        dw      ?               ; mode 9
                        dw      ?               ; mode a
                        dw      ?               ; mode b
                        dw      ?               ; mode c
                        dw      ?               ; mode d
                        dw      80*200+78       ; mode e
                        dw      80*350+78       ; mode f
                        dw      80*350+78       ; mode 10
                        dw      80*480+78       ; mode 11
                        dw      80*480+78       ; mode 12

;=============================================================================
; CGA video mode 4 is a 2 bit per pixel graphics mode. The pointer images
; received from the application (or the default images for that matter) are
; described by a one bit per pixel map. This look up table provides the means
; of conversion from one to two bits per pixel.
;=============================================================================
even
LUT1to2bit      label   word
        dw      00000h,00003h,0000Ch,0000Fh,00030h,00033h,0003Ch,0003Fh
        dw      000C0h,000C3h,000CCh,000CFh,000F0h,000F3h,000FCh,000FFh
        dw      00300h,00303h,0030Ch,0030Fh,00330h,00333h,0033Ch,0033Fh
        dw      003C0h,003C3h,003CCh,003CFh,003F0h,003F3h,003FCh,003FFh
        dw      00C00h,00C03h,00C0Ch,00C0Fh,00C30h,00C33h,00C3Ch,00C3Fh
        dw      00CC0h,00CC3h,00CCCh,00CCFh,00CF0h,00CF3h,00CFCh,00CFFh
        dw      00F00h,00F03h,00F0Ch,00F0Fh,00F30h,00F33h,00F3Ch,00F3Fh
        dw      00FC0h,00FC3h,00FCCh,00FCFh,00FF0h,00FF3h,00FFCh,00FFFh

        dw      03000h,03003h,0300Ch,0300Fh,03030h,03033h,0303Ch,0303Fh
        dw      030C0h,030C3h,030CCh,030CFh,030F0h,030F3h,030FCh,030FFh
        dw      03300h,03303h,0330Ch,0330Fh,03330h,03333h,0333Ch,0333Fh
        dw      033C0h,033C3h,033CCh,033CFh,033F0h,033F3h,033FCh,033FFh
        dw      03C00h,03C03h,03C0Ch,03C0Fh,03C30h,03C33h,03C3Ch,03C3Fh
        dw      03CC0h,03CC3h,03CCCh,03CCFh,03CF0h,03CF3h,03CFCh,03CFFh
        dw      03F00h,03F03h,03F0Ch,03F0Fh,03F30h,03F33h,03F3Ch,03F3Fh
        dw      03FC0h,03FC3h,03FCCh,03FCFh,03FF0h,03FF3h,03FFCh,03FFFh

        dw      0C000h,0C003h,0C00Ch,0C00Fh,0C030h,0C033h,0C03Ch,0C03Fh
        dw      0C0C0h,0C0C3h,0C0CCh,0C0CFh,0C0F0h,0C0F3h,0C0FCh,0C0FFh
        dw      0C300h,0C303h,0C30Ch,0C30Fh,0C330h,0C333h,0C33Ch,0C33Fh
        dw      0C3C0h,0C3C3h,0C3CCh,0C3CFh,0C3F0h,0C3F3h,0C3FCh,0C3FFh
        dw      0CC00h,0CC03h,0CC0Ch,0CC0Fh,0CC30h,0CC33h,0CC3Ch,0CC3Fh
        dw      0CCC0h,0CCC3h,0CCCCh,0CCCFh,0CCF0h,0CCF3h,0CCFCh,0CCFFh
        dw      0CF00h,0CF03h,0CF0Ch,0CF0Fh,0CF30h,0CF33h,0CF3Ch,0CF3Fh
        dw      0CFC0h,0CFC3h,0CFCCh,0CFCFh,0CFF0h,0CFF3h,0CFFCh,0CFFFh

        dw      0F000h,0F003h,0F00Ch,0F00Fh,0F030h,0F033h,0F03Ch,0F03Fh
        dw      0F0C0h,0F0C3h,0F0CCh,0F0CFh,0F0F0h,0F0F3h,0F0FCh,0F0FFh
        dw      0F300h,0F303h,0F30Ch,0F30Fh,0F330h,0F333h,0F33Ch,0F33Fh
        dw      0F3C0h,0F3C3h,0F3CCh,0F3CFh,0F3F0h,0F3F3h,0F3FCh,0F3FFh
        dw      0FC00h,0FC03h,0FC0Ch,0FC0Fh,0FC30h,0FC33h,0FC3Ch,0FC3Fh
        dw      0FCC0h,0FCC3h,0FCCCh,0FCCFh,0FCF0h,0FCF3h,0FCFCh,0FCFFh
        dw      0FF00h,0FF03h,0FF0Ch,0FF0Fh,0FF30h,0FF33h,0FF3Ch,0FF3Fh
        dw      0FFC0h,0FFC3h,0FFCCh,0FFCFh,0FFF0h,0FFF3h,0FFFCh,0FFFFh

;============================================================================
;   Table for selection of the correct pointer image for the current location
;   in the video buffer, when using video BIOS mode 4.
;============================================================================

mode4pointerLUT label   word
        REPT    76              ; for the first 76 bytes of scanline, use these
        dw      current_cursor
        dw      AlignData1
        dw      AlignData2
        dw      AlignData3
        ENDM
        dw      clip_cursor78
        dw      AlignClip178
        dw      AlignClip278
        dw      AlignClip378
        dw      AlignClip478
        dw      AlignClip578
        dw      AlignClip678
        dw      AlignClip778
        dw      clip_cursor79
        dw      AlignClip179
        dw      AlignClip279
        dw      AlignClip379
        dw      AlignClip479
        dw      AlignClip579
        dw      AlignClip679
        dw      AlignClip779

;============================================================================
;   Look up table to adjust CX on clipping in mode 4. This allows the mode4
;   pointer drawing algorithm to use the modes 10h/12h clipped pointer data
;   without having to modify it. The problem is that mode 10/12 expects the
;   data to be 4 bits per pixel and aligned to a word, whereas mode 4 is 2 bits
;   per pixel and aligns to a byte.
;============================================================================

mode4clipCXadjustLUT    label   word
        adjtemp=0               ; data for pixel x-coordinates 0 -> 307
        REPT    77
        dw      4 dup(adjtemp)
        adjtemp=adjtemp+1
        ENDM
        dw      4 dup(76)       ; data for pixels 308 -> 311
        dw      8 dup(78)       ; data for pixels 312 -> 319


;============================================================================
; The CGA buffer is split at 2000h. Therefore if the pointer starts writing
; below scanline 199 on the video display, the odd scanline video buffer
; will become corrupted. In these cases, the pointer should be clipped to
; display scanline 199. The look up table below maps loop counters to a
; display scanline for this purpose.
;
;       table arrangement       (odd scanline data, even scanline data)
;
;============================================================================

mode4clipDXLUT  label   word

        db      200-15  dup(8,8)        ; scanlines 0 -> 184
        db                  8,7         ; scanline  185
        db                  7,7         ; scanline  186
        db                  7,6         ; scanline  187
        db                  6,6         ; scanline  188
        db                  6,5         ; scanline  189
        db                  5,5         ; scanline  190
        db                  5,4         ; scanline  191
        db                  4,4         ; scanline  192
        db                  4,3         ; scanline  193
        db                  3,3         ; scanline  194
        db                  3,2         ; scanline  195
        db                  2,2         ; scanline  196
        db                  2,1         ; scanline  197
        db                  1,1         ; scanline  198
        db                  1,0         ; scanline  199

mode4SelectedPointer    label   word
        dw      ?

;==========================================================================
;   Some space into which the Medium resolution graphics pointer background
;   gets stored. Note that the 256 colour mode buffer encroaches on that of
;   mode 4.
;==========================================================================

bkgrnd256       label   byte            ; 256 colour buffer = 24*16 @ 1 byte/pix
        db      384-64  dup(?)          ; share the CGA buffer(=64 bytes)

CGAbackgrnd     label   byte

        db      24/4*16 dup(?)          ; 24 pixels/row @ 4 pixels/byte for 16
                                        ; rows.

;===========================================================================
;   Jump table to redirect the code flow according to the current video mode.
;   Used in the 32 bit entry point procedure.
;   Pointer drawing routines.
;===========================================================================
even
drawpointerJMPT label   word
        dw      offset  not_supported           ; mode 0
        dw      offset  not_supported           ; mode 1
IFDEF SIXTEENBIT
        dw      offset  drawTextPointer         ; mode 2
        dw      offset  drawTextPointer         ; mode 3
ELSE
        dw      offset  not_supported		; mode 2
        dw      offset  not_supported		; mode 3
ENDIF
        dw      offset  drawMediumResPointer    ; mode 4
	dw	offset	drawMediumResPointer	; mode 5
        dw      offset  not_supported           ; mode 6
IFDEF SIXTEENBIT
        dw      offset  drawTextPointer         ; mode 7
ELSE
        dw      offset  not_supported		; mode 7
ENDIF
        dw      offset  not_supported           ; mode 8
        dw      offset  not_supported           ; mode 9
        dw      offset  not_supported           ; mode a
        dw      offset  not_supported           ; mode b
        dw      offset  not_supported           ; mode c
        dw      offset  not_supported           ; mode d
        dw      offset  not_supported           ; mode e
        dw      offset  drawHiResPointer        ; mode f
        dw      offset  drawHiResPointer        ; mode 10
        dw      offset  drawHiResPointer        ; mode 11
        dw      offset  drawHiResPointer        ; mode 12
        dw      offset  drawC256pointer         ; mode 13

;===========================================================================
;   Jump table to redirect the code flow according to the current video mode.
;   Used in the 32 bit entry point procedure.
;   INT 33h Function 1 support modules.
;===========================================================================
even
int33function1JMPT      label   word
        dw      offset  not_supported           ; mode 0
        dw      offset  not_supported           ; mode 1
IFDEF SIXTEENBIT
        dw      offset  TextInt33Function1      ; mode 2
        dw      offset  TextInt33Function1      ; mode 3
ELSE
        dw      offset  not_supported		; mode 2
        dw      offset  not_supported		; mode 3
ENDIF
        dw      offset  MediumResInt33Function1 ; mode 4
	dw	offset	MediumResInt33Function1	; mode 5
        dw      offset  not_supported           ; mode 6
IFDEF SIXTEENBIT
        dw      offset  TextInt33Function1      ; mode 7
ELSE
        dw      offset  not_supported		; mode 7
ENDIF
        dw      offset  not_supported           ; mode 8
        dw      offset  not_supported           ; mode 9
        dw      offset  not_supported           ; mode a
        dw      offset  not_supported           ; mode b
        dw      offset  not_supported           ; mode c
        dw      offset  not_supported           ; mode d
        dw      offset  not_supported           ; mode e
        dw      offset  HiResInt33Function1     ; mode f
        dw      offset  HiResInt33Function1     ; mode 10
        dw      offset  HiResInt33Function1     ; mode 11
        dw      offset  HiResInt33Function1     ; mode 12
        dw      offset  C256Int33Function1      ; mode 13

;===========================================================================
;   Jump table to redirect the code flow according to the current video mode.
;   Used in the 32 bit entry point procedure.
;   INT 33h Function 2 support modules.
;===========================================================================
even
int33function2JMPT      label   word
        dw      offset  not_supported           ; mode 0
        dw      offset  not_supported           ; mode 1
IFDEF SIXTEENBIT
        dw      offset  TextInt33Function2      ; mode 2
        dw      offset  TextInt33Function2      ; mode 3
ELSE
        dw      offset  not_supported		; mode 2
        dw      offset  not_supported		; mode 3
ENDIF
        dw      offset  MediumResInt33Function2 ; mode 4
	dw	offset	MediumResInt33Function2	; mode 5
        dw      offset  not_supported           ; mode 6
IFDEF SIXTEENBIT
        dw      offset  TextInt33Function2      ; mode 7
ELSE
        dw      offset  not_supported		; mode 7
ENDIF
        dw      offset  not_supported           ; mode 8
        dw      offset  not_supported           ; mode 9
        dw      offset  not_supported           ; mode a
        dw      offset  not_supported           ; mode b
        dw      offset  not_supported           ; mode c
        dw      offset  not_supported           ; mode d
        dw      offset  not_supported           ; mode e
        dw      offset  HiResInt33Function2     ; mode f
        dw      offset  HiResInt33Function2     ; mode 10
        dw      offset  HiResInt33Function2     ; mode 11
        dw      offset  HiResInt33Function2     ; mode 12
        dw      offset  C256Int33Function2      ; mode 13



;==========================================================================
;   Some storage space for the critical VGA registers.
;==========================================================================

;Sequencer Registers

seqregs         label   byte
                db      4 dup(?)        ; N.B. sequencer reset reg doesn't
                                        ; get saved.

; Graphics Controller Registers

GCregs          label   byte
                db      9 dup(?)

;==========================================================================
; The mouse driver's very own stack. To prevent unnecessary tears,
; particulary from the application running in DOS land, a stack is
; maintained by the driver. This prevents the driver routines from
; blowing a very full stack elsewhere.
; N.B. on leaving the driver, the stack should be empty!
;==========================================================================

even
mouse_stack     dw      STACKSIZE dup(?)
top_of_stack    label   word
                dw      ?       ; this is where the stack starts

;===========================================================================
; The memory variable below is incremented on entry to the 16 bit code
; and on exit, decremented. If an interrupt occurs during the execution of
; this 16 bit code, the flag is incremented again, and thus greater than zero
; so it is known that the code has been reentered and the stack must be
; maintained accordingly.
;===========================================================================

reentrant       dw      -1

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;   END OF DATA
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



;================================================================
; code to redirect the flow of control from the segment:offset for
; the mouse interrupt (33h) as indicated in the IVT (the IVT entry
; has been set to point to here) to the Insignia mouse driver code.
;================================================================
int33h_vector:

        jmp     short   skip

; High level language entry point.

lvector db      0EAh    ; far jump opcode
loffset dw      ?       ; destination offset
lseg    dw      ?       ; destination segment

; The  pointer set to our interrupt 33h handler

skip:   

;
; Let's just jump to the C mouse_io_interrupt code for
; RISC and bypass the ROM like 4.0 does.
;

	bop	0BDh
	iret



db      0EAh    ; far jump opcode
moff    dw      ?       ; will be filled in by the driver code from the IVT
mseg    dw      ?       ; as before

DOCLI:
        FCLI
        ret

DOSTI:
        FSTI
        ret

DOIRET:
        FIRET


;================================================================
; Functions moved out of ROM - real ROMS mapped in
;================================================================

unexp_int:
        bop     UNEXP_BOP
        jmp     DOIRET

mouse_io:
	;
	; INT 33h entry point
	;

        jmp     mio_hack
        nop
mouse_io_lang:                  ; entry point for HLL
        pushf                   ; check ASAP if redundant show/hide cursor
        push    di              ; save di,
        mov     di, [di+14]     ; get first parameter (mouse function),
                                ; then duplicate mio_hack below.
                                ; this has to be done to preserve
                                ; compatibility between both ways to
                                ; call the mouse.
        jz      lbop            ; F0
        cmp     di,2
        jg      lbop            ; >F2
        je      miol_2
miol_1:
	mov	conditional_off, 0  ; disable conditonal off
        cmp     [internalCF],0  ; is the flag already zero?
        je      miol_12_quit    ; if so, do nothing
        inc     [internalCF]    ; increment it
        jz      lbop
miol_12_quit:
        pop     di
        popf
        jmp     DOIRET

miol_2:
        dec     [internalCF]      ; decrement the pointer internal flag
        cmp     [internalCF], 0ffh; currently displayed?
        jne     miol_12_quit
lbop:
        pop     ax
        popf
        bop     IO_LANG_BOP
        retf    8

mio_hack:			; int 33h handler
        pushf                   ; save up the flags
        cmp     ax,1		; mouse show cursor.
        je      mio_1		
        cmp     ax,2		; mouse hide cursor.
        je      mio_2
        cmp     ax,3		; get button status and mouse position.
        je      mio_3
        cmp     ax,9		; set graphics cursor
        je	mio_9
        cmp     ax,10		; set text cursor - not supported
        je	mio_quit	; return straight back to app.

        jmp short hack1bop      ; none of the above, so goto 32 bit land

mio_1:
	mov	conditional_off, 0  ; disable conditional off
        cmp     [internalCF],0  ; is the flag already zero?
        je      mio_quit        ; if so, do nothing
        inc     [internalCF]    ; increment it
        jz      hack1bop	; just turned zero, so turn pointer on
                                 ; via the 32 bit code.
mio_quit:
        popf
        jmp     DOIRET

mio_2:
        dec     [internalCF]      ; decrement the pointer internal flag
        cmp     [internalCF], 0ffh; currently displayed?
        jne      mio_quit	  ; Already turned off, so quit

hack1bop:
        popf
        bop     IO_INTR_BOP	; BOP to the 32 bit part of the handler
        jmp     DOIRET		; return back after the BOP to caller
mio_9:
	call	int33function9	; change the shape of the graphics pointer
        popf			; restore the flag state
        jmp     DOIRET		; back to the caller
mio_3:
	mov	bx,[function3data]	; return button status
	mov	cx,[function3data+2]	; return x coordinate
	mov	dx,[function3data+4]	; return x coordinate
        popf				; return back to the application
        jmp     DOIRET			; via an iret.


IFDEF MOUSE_VIDEO_BIOS

mouse_video_io:

        pushf
        or      ah,ah
        jne     mvio1
        jmp     do_bop
mvio1:
        cmp     ax,6f05h
        jne     mvio2
        jmp     do_bop
mvio2:
        cmp     ah,4
        jne     mvio3
        jmp     do_bop
mvio3:

;=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

        ; Microsoft EGA.LIB function support
        ; input: AH = the function required

        cmp     ah,0f0h         ; is function F0 or greater?
        jge     mvio4           ; YES, so check to see if less than or == F7
        jmp     go_rom          ; NO, so do rom stuff
mvio4:
        cmp     ah,0f7h         ; is it greater than F7
        jg      mvio5           ; YES, so test for == FA
        jmp     ega_lib         ; NO, but in range F0 to F7, so do EGALIB emm
mvio5:
        cmp     ah,0fah
        jne     mvio6
        jmp     egaFA
mvio6:
        jmp     go_rom

        ; to get here, must want to do mouse video functions 0f0h to 0f7h or
        ; function 0fah.

        jmp     ega_lib

        ; data area for EGA.LIB function support
        ; Notice that the sequencer register buffer only has space
        ; for four entrys even though it actually has five addressable
        ; registers. The Sequencer RESET status is not stored, so the buffer
        ; is arranged thus:
        ;                  buffer offset   0   1   2   3
        ;                  register index  1   2   3   4
        ;

        even

        ega_current_crtc        db      25 dup(?) ; driver's copy of CRTC regs
        ega_current_seq         db      4  dup(?) ; driver's copy of Seq regs
        ega_current_graph       db      9  dup(?) ; driver's copy of GC regs
        ega_current_attr        db      20 dup(?) ; driver's copy of AC regs
        ega_current_misc        db      ?         ; driver's copy of misc reg
        dirty_crtc              db      25 dup(?)
        dirty_seq               db      4  dup(?)
        dirty_graph             db      9  dup(?)
        dirty_attr              db      20 dup(?)
        ega_default_crtc        db      25 dup(?) ; default EGA register values
        ega_default_seq         db      4  dup(?) ; as set by the application
        ega_default_graph       db      9  dup(?) ; through a call to F7
        ega_default_attr        db      20 dup(?)
        ega_default_misc        db      ?

        relnum                  label   word

        release_major           db      MAJOR_RELEASE_NUMBER
        release_minor           db      MINOR_RELEASE_NUMBER

        even

        egalibjmp       label   word    ; crafty jump table to replace a base
                                        ; switch
                                dw      egaF0   ; 0F0h - read one EGA register
                                dw      egaF1   ; 0F1h - write one EGA register
                                dw      egaF2   ; 0F2h - read register range
                                dw      egaF3   ; 0F3h - write register range
                                dw      egaF4   ; 0F4h - read register set
                                dw      egaF5   ; 0F5h - write register set
                                dw      egaF6   ; 0F6h - revert to default regs
                                dw      egaF7   ; 0F7h - define deflt reg table
                                dw      noint   ; 0F8h is not a valid function
                                dw      noint   ; 0F9h is not a valid function
                                dw      egaFA   ; 0FAh - interrogate driver
ega_lib:

        xor     al,al
        sub     ax,0f0h                 ; create a jump table index
        shl     ax,1                    ; remember that a word pointer is reqd
        mov     si,ax
        jmp     [egalibjmp+si]          ; get the relavent jump address

egaF0:  ;--- Read an EGA register ----------------------------------------------

        pusha
        and     bx,0ffh                 ; just want the lower byte (BL)
F00:
        cmp     dx,0
        jne     F08
        mov     bl,byte ptr [ega_current_crtc+bx]
        popa
        jmp     noint
F08:
        cmp     dx,8
        jne     F010
        dec     bx                      ; note that RESET is not stored
        mov     bl,byte ptr [ega_current_seq+bx]
        popa
        jmp     noint
F010:
        cmp     dx,010h
        jne     F018
        mov     bl,byte ptr [ega_current_graph+bx]
        popa
        jmp     noint
F018:
        cmp     dx,018h
        jne     F020
        mov     bl,byte ptr [ega_current_attr+bx]
        popa
        jmp     noint
F020:
        cmp     dx,020h
        jne     F028
        mov     bl,byte ptr [ega_current_misc]

F028:   ; do nothing for this case
F0quit:
        popa
        jmp     noint

egaF1:  ;--- Write an EGA register --------------------------------------------

F10:
        pusha
        cmp     dx,0
        jne     F18
        mov     dx,03d4h                ; write to the CRTC index register
        mov     ax,bx                   ; values to write to ports 3d4/3d5
        out     dx,ax                   ; do the write
        mov     di,bx                   ; save the written values to memory
        and     di,0ffh                 ; get just the lower 8 bits
        mov     byte ptr [ega_current_crtc+di],bh
        mov     byte ptr [dirty_crtc+di],1
        popa
        jmp     noint
F18:
        cmp     dx,8
        jne     F110
        mov     dx,03c4h                ; write to the Sequencer index register
        mov     ax,bx                   ; values to write to ports 3c4/3c5
        out     dx,ax                   ; do the write
        cmp     bl,0                    ; Cannot index reset because it its
        jle     F18bra1                 ; not stored. range = 1->4
        and     bx,0ffh                 ; just want BL
        dec     bx                      ; actually, one less than that
        mov     byte ptr [ega_current_seq+bx],ah
        mov     byte ptr [dirty_seq+bx],1
F18bra1:
        popa
        jmp     noint
F110:
        cmp     dx,010h
        jne     F118
        mov     dx,03ceh                ; write to the Graphics controller
        mov     ax,bx                   ; values to write to ports 3ce/3cf
        out     dx,ax                   ; do the write
        mov     di,bx                   ; save the written values to memory
        and     di,0ffh                 ; get just the lower 8 bits
        mov     byte ptr [ega_current_graph+di],bh
        mov     byte ptr [dirty_graph+di],1
        popa
        jmp     noint
F118:
        cmp     dx,018h
        jne     F120
        mov     dx,03dah                ; clear attribute controller index
        in      al,dx                   ; the read clears this register
        mov     ax,bx                   ; need to write BX to the ports
        mov     dx,03c0h                ; Attribute Controller index register
        out     dx,ax                   ; do the write
        inc     dx
        mov     al,020h                 ; EGA palette enable
        out     dx,al                   ; enable the palette
        mov     di,bx                   ; save the written values to memory
        and     di,0ffh                 ; get just the lower 8 bits
        mov     byte ptr [ega_current_graph+di],bh
        mov     byte ptr [dirty_graph+di],1
        popa
        jmp     noint
F120:
        cmp     dx,020h
        jne     F128
        mov     dx,03c2h                ; EGA miscellaneous register
        mov     al,bl
        out     dx,al                   ; write to the register
        mov     [ega_current_misc],bl
        popa
        jmp     noint
F128:
        cmp     dx,028h
        jne     F128
        mov     dx,03dah                ; EGA feature register
        mov     al,bl
        out     dx,al
F1quit:
        popa
        jmp     noint

egaF2:  ;--- Read a register range ---------------------------------------------

        pusha
        cmp     dx,0
        jne     F28
F20:
        lea     si,ega_current_crtc     ; get the address of this buffer
        mov     dx,cx                   ; save this value
        xchg    ch,cl                   ; create an index with CH
        and     cx,0ffh                 ; only need CH (now CL)
        add     si,cx                   ; SOURCE adjust the address
        xor     dh,dh                   ; only want the old CL value
        mov     cx,dx                   ; restore CX
        mov     di,bx                   ; DESTINATION got from the application
        rep     movsb                   ; copy to the app's register block
        popa
        jmp     noint
F28:
        cmp     dx,8
        jne     F210
        lea     si,ega_current_seq      ; get the address of this buffer
        mov     dx,cx                   ; save this value
        xchg    ch,cl                   ; create an index with CH
        and     cx,0ffh                 ; only need CH (now CL)
        dec     cx                      ; RESET is not stored, so index-1
        add     si,cx                   ; SOURCE adjust the address
        xor     dh,dh                   ; only want the old CL value
        mov     cx,dx                   ; restore CX
        mov     di,bx                   ; DESTINATION got from the application
        rep     movsb                   ; copy to the app's register block
        popa
        jmp     noint
F210:
        cmp     dx,010h
        jne     F218
        lea     si,ega_current_graph    ; get the address of this buffer
        mov     dx,cx                   ; save this value
        xchg    ch,cl                   ; create an index with CH
        and     cx,0ffh                 ; only need CH (now CL)
        add     si,cx                   ; SOURCE adjust the address
        xor     dh,dh                   ; only want the old CL value
        mov     cx,dx                   ; restore CX
        mov     di,bx                   ; DESTINATION got from the application
        rep     movsb                   ; copy to the app's register block
        popa
        jmp     noint
F218:
        cmp     dx,018h
        jne     F2quit
        lea     si,ega_current_attr     ; get the address of this buffer
        mov     dx,cx                   ; save this value
        xchg    ch,cl                   ; create an index with CH
        and     cx,0ffh                 ; only need CH (now CL)
        add     si,cx                   ; SOURCE adjust the address
        xor     dh,dh                   ; only want the old CL value
        mov     cx,dx                   ; restore CX
        mov     di,bx                   ; DESTINATION got from the application
        rep     movsb                   ; copy the application's register block
F2quit:
        popa
        jmp     noint

egaF3:  ;--- Write a register range to the EGA adapter ------------------------

        pusha
        push    ds
        push    es
F31:
        cmp     dx,0
        jne     F38
        lea     di,ega_current_crtc     ; write the application data here
        mov     al,ch                   ; adjust the write position as required
        cbw
        add     di,ax                   ; DESTINATION specified address
        mov     si,bx                   ; SOURCE from the application
        lea     bx,dirty_crtc           ; need to write some data into here
        add     bx,ax                   ; well, at this offset anyway
        mov     ax,es                   ; The application is the source
        mov     ds,ax                   ; so point to its segment
        mov     dx,03d4h                ; CRTC index register
        mov     ah,ch                   ; CRTC register to start at
        xor     ch,ch                   ; CX is now the loop counter
        assume  ds:nothing
F31cp:
        mov     byte ptr cs:[bx],1      ; fill in the dirty_crtc array
        inc     bx
        movsb                           ; get the value from the app to write
                                        ; and write to the internal buffer
        out     dx,ax                   ; write to the EGA adapter
        loop    F31cp
        jmp     F3quit
F38:
        cmp     dx,8
        jne     F310
        lea     di,ega_current_seq      ; write the application data here
        mov     al,ch                   ; adjust the write position as required
        cbw
        add     di,ax                   ; DESTINATION specified address
        dec     di                      ; RESET is not stored, so index-1
        mov     si,bx                   ; SOURCE from the application
        lea     bx,dirty_seq            ; need to write some data into here
        add     bx,ax                   ; well, at this offset anyway
        inc     bx
        mov     ax,es                   ; The application is the source
        mov     ds,ax                   ; so point to its segment
        mov     dx,03c4h                ; Sequencer index register
        mov     ah,ch                   ; Sequencer register to start at
        inc     ah
        xor     ch,ch                   ; CX is now the loop counter
        assume  ds:nothing
F38cp:
        mov     byte ptr cs:[bx],1      ; fill in the dirty_seq array
        inc     bx
        movsb                           ; get the value from the app to write
                                        ; and write to the internal buffer
        out     dx,ax                   ; write to the EGA adapter
        loop    F38cp
        assume  ds:SpcMseSeg
        jmp     F3quit
F310:
        cmp     dx,010h
        jne     F318
        lea     di,ega_current_graph    ; write the application data here
        mov     al,ch                   ; adjust the write position as required
        cbw
        add     di,ax                   ; DESTINATION specified address
        mov     si,bx                   ; SOURCE from the application
        lea     bx,dirty_graph          ; need to write some data into here
        add     bx,ax                   ; well, at this offset anyway
        mov     ax,es                   ; The application is the source
        mov     ds,ax                   ; so point to its segment
        mov     dx,03ceh                ; Graphics Controller index register
        mov     ah,ch                   ; GC register to start at
        xor     ch,ch                   ; CX is now the loop counter
        assume  ds:nothing
F310cp:
        mov     byte ptr cs:[bx],1      ; fill in the dirty_graph array
        inc     bx
        movsb                           ; get the value from the app to write
                                        ; and write to the internal buffer
        out     dx,ax                   ; write to the EGA adapter
        loop    F310cp
        assume  ds:SpcMseSeg
        jmp     short F3quit
F318:
        cmp     dx,018h
        jne     F3quit
        mov     dx,03dah                ; clear attribute controller index
        in      al,dx                   ; the read clears this register
        lea     di,ega_current_attr     ; write the application data here
        mov     al,ch                   ; adjust the write position as required
        cbw
        add     di,ax                   ; DESTINATION specified address
        mov     si,bx                   ; SOURCE from the application
        lea     bx,dirty_attr           ; need to write some data into here
        add     bx,ax                   ; well, at this offset anyway
        mov     ax,es                   ; The application is the source
        mov     ds,ax                   ; so point to its segment
        mov     dx,03c0h                ; Attribute Controller index register
        mov     ah,ch                   ; AC register to start at
        xor     ch,ch                   ; CX is now the loop counter
        assume  ds:nothing
F318cp:
        mov     byte ptr cs:[bx],1      ; fill in the dirty_attr array
        inc     bx
        movsb                           ; get the value from the app to write
                                        ; and write to the internal buffer
        out     dx,ax                   ; write to the EGA adapter
        loop    F318cp
        assume  ds:SpcMseSeg
F3quit:
        pop     es
        pop     ds
        popa
        jmp     noint

egaF4:  ;--- Read EGA register set -------------------------------------------
        ;
        ; note that the incoming/outgoing data is structured thus:
        ;
        ;       from application -->    db      Port number
        ;                        -->    db      must be zero
        ;                        -->    db      pointer value
        ;       to application   <--    db      data read from register

        pusha
F4lp:
        mov     al,byte ptr es:[bx]     ; get the type of the next EGA register
        mov     dl,byte ptr es:[bx+2]   ; load up the offset required
        xor     dh,dh                   ; convert DL to a word (DX)
        add     bx,3                    ; point to where the data should
                                        ; be written for the application
F40:
        cmp     al,0
        jne     F48
        lea     di,ega_current_crtc     ; point to the internal CRTC reg. buffer
        add     di,dx                   ; index into the buffer
        mov     al,byte ptr [di]        ; get the register value from the driver
        mov     byte ptr es:[bx],al     ; store the register value
        jmp     short F4lp2             ; do the next loop iteration
F48:
        cmp     al,8
        jne     F410
        lea     di,ega_current_seq      ; point to the internal Sequencer buffer
        add     di,dx                   ; index into the buffer
        dec     di                      ; RESET is not stored, so index off 1
        mov     al,byte ptr [di]        ; get the register value from the driver
        mov     byte ptr es:[bx],al     ; store the register value
        jmp     short F4lp2             ; do the next loop iteration
F410:
        cmp     al,010h
        jne     F418
        lea     di,ega_current_graph    ; point to the internal GC reg. buffer
        add     di,dx                   ; index into the buffer
        mov     al,byte ptr [di]        ; get the register value from the driver
        mov     byte ptr es:[bx],al     ; store the register value
        jmp     short F4lp2             ; do the next loop iteration
F418:
        cmp     al,018h
        jne     F420
        lea     di,ega_current_attr     ; point to the interal AC reg. buffer
        add     di,dx                   ; index into the buffer
        mov     al,byte ptr [di]        ; get the register value from the driver
        mov     byte ptr es:[bx],al     ; store the register value
        jmp     short F4lp2             ; do the next loop iteration
F420:
        cmp     al,020h
        jne     F4lp2
        mov     al,[ega_current_misc]   ; load contents of miscellaneous reg
        mov     byte ptr[di],al         ; store the register value

        ; the C code actually loads BL here but I don't know why!
F4lp2:
        inc     bx               ; point to the next 'record'
        loop    F4lp
        popa
        jmp     noint

egaF5:  ;--- Write EGA register set -------------------------------------------
        ;
        ; note that the incoming data is structured thus:
        ;
        ;       from application -->    db      Port number
        ;                        -->    db      must be zero
        ;                        -->    db      pointer value
        ;                        -->    db      data read from register

        pusha
F5lp:
        mov     al,byte ptr es:[bx]     ; get the type of the next EGA register
        mov     dl,byte ptr es:[bx+2]   ; load up the offset required
        xor     dh,dh                   ; turn from 8 bit to a word quantity
        mov     si,dx                   ; need this when accessing buffers
        add     bx,3                    ; point to where the data should
                                        ; be written for the application
        mov     ah,byte ptr es:[bx]     ; load data to send to the port
        inc     bx                      ; point to the next 'record'
F50:
        cmp     al,0
        jne     F58
        mov     al,dl                   ; also the port offset to access
        mov     dx,03d4h                ; index register for CRTC
        out     dx,ax                   ; write to the specified port
        mov     byte ptr [ega_current_crtc+si],ah
        mov     byte ptr [dirty_crtc+si],1
        jmp     short F5lp2
F58:
        cmp     al,8
        jne     F510
        mov     al,dl                   ; also the port offset to access
        mov     dx,03c4h                ; index register for Sequencer
        out     dx,ax                   ; write to the specified port
        dec     si                      ; RESET is not stored, so index off 1
        mov     byte ptr [ega_current_seq+si],ah
        mov     byte ptr [dirty_seq+si],1
        jmp     short F5lp2
F510:
        cmp     al,010h
        jne     F518
        mov     al,dl                   ; also the port offset to access
        mov     dx,03ceh                ; index register for GC
        out     dx,ax                   ; write to the specified port
        mov     byte ptr [ega_current_graph+si],ah
        mov     byte ptr [dirty_graph+si],1
        jmp     short F5lp2
F518:
        cmp     al,018h
        jne     F520
        mov     dx,03dah                ; clear attribute controller index
        in      al,dx                   ; the read clears this register
        lea     di,ega_current_attr     ; write the application data here
        mov     al,dl                   ; also the port offset to access
        mov     dx,03c0h                ; index register for AC
        out     dx,ax                   ; write to the specified port
        mov     al,020h                 ; EGA palette enable
        out     dx,al                   ; reenable the video
        mov     byte ptr [ega_current_attr+si],ah
        mov     byte ptr [dirty_attr+si],1
        jmp     short F5lp2
F520:
        cmp     al,020h
        jne     F528
        mov     byte ptr [ega_current_misc],ah
        mov     dx,03c2h                ; Miscellaneous output register
        xchg    ah,al
        out     dx,al                   ; write one byte
        jmp     short F5lp2
F528:
        xchg    ah,al
        mov     dx,03dah                ; EGA feature register
        out     dx,al
F5lp2:
        dec     cx
        cmp     cx,0
        jz      F5quit
        jmp     F5lp
F5quit:
        popa
        jmp     noint

egaF6:  ;--- Restore the EGA default register values --------------------------
        pusha
        push    es

        ; copy the default EGA register sets to the driver's internal cache

        mov     ax,ds
        mov     es,ax

        mov     cx,25
        lea     di,ega_current_crtc
        lea     si,ega_default_crtc
        rep     movsb
        mov     cx,4
        lea     di,ega_current_seq
        lea     si,ega_default_seq
        rep     movsb
        mov     cx,9
        lea     di,ega_current_graph
        lea     si,ega_default_graph
        rep     movsb
        mov     cx,20
        lea     di,ega_current_attr
        lea     si,ega_default_attr
        rep     movsb
        mov     al,[ega_default_misc]
        mov     [ega_current_misc],al

        ; Set up the Sequencer defaults

        mov     dx,03c4h                ; Sequencer index register
        mov     ax,0100h                ; Synchronous reset
        out     dx,ax                   ; do the work

        xor     bx,bx                   ; do the four non reset registers
        inc     al                      ; point to the next Sequencer register
F6lp1:
        cmp     [dirty_seq+bx],1        ; has the dirty bit been set?
        jne     F6ne1
        mov     ah,[ega_default_seq+bx] ; default value to send to the register
        out     dx,ax                   ; do the work
F6ne1:
        inc     bx                      ; point to the next buffer location
        inc     al                      ; point to the next Sequencer register
        cmp     bx,3                    ; copy elements 0->3 to ports
        jl      F6lp1
        mov     ax,0300h                ; Clear synchronous reset
        out     dx,ax                   ; do the work

        ; Set up the default Miscellaneous Output Register value.

        mov     dx,03c2h                ; Miscellaneous o/p register address
        mov     al,[ega_default_misc]   ; the default value
        out     dx,al                   ; write to the EGA/VGA

        ; Set up the Cathode Ray Tube Controller in the default fashion

        mov     dx,03d4h                ; Index to the CRTC
        xor     bx,bx                   ; clear an index register
F6lp2:
        cmp     [dirty_crtc+bx],1       ; has the dirty bit been set?
        jne     F6ne2
        mov     ax,bx                   ; index for the CRTC index register
        mov     ah,[ega_default_crtc+bx] ; default value for the selected reg.
        out     dx,ax
F6ne2:
        inc     bx                      ; point to the next location
        cmp     bx,25                   ; 25 registers to copy
        jl      F6lp2

        ; Set up the Attribute Controller default values
        ; Remember that this is a funny beast which uses a flip-flop
        ; off just one address/data port

        mov     dx,03dah                ; CRT status register
        in      al,dx                   ; set the AC flip-flop
        mov     dx,03c0h                ; Attibute controller address/data regs
        xor     bx,bx                   ; clear an index register
F6lp3:
        cmp     [dirty_attr+bx],1       ; has the dirty bit been set?
        jne     F6ne3
        mov     ax,bx                   ; index for the CRTC index register
        mov     ah,[ega_default_attr+bx] ; default value for the selected reg.
        out     dx,al                   ; index the register, then flip the flop
        xchg    al,ah                   ; get the default data for this register
        out     dx,al                   ; write the data out
F6ne3:
        inc     bx                      ; point to the next location
        cmp     bx,20                   ; 20 registers to copy

        ; Set the Graphics Controller default values

        mov     dx,03ceh                ; Index to the GC
        xor     bx,bx                   ; clear an index register
F6lp4:
        cmp     [dirty_graph+bx],1      ; has the dirty bit been set?
        jne     F6ne4
        mov     ax,bx                   ; index for the GC index register
        mov     ah,[ega_default_graph+bx] ; default value for the selected reg.
        out     dx,ax
F6ne4:
        inc     bx                      ; point to the next location
        cmp     bx,9                    ; 9 registers to copy
        jl      F6lp2

        ; Reenable the video

        mov     dx,03c0h                ; index register for AC
        mov     al,020h                 ; EGA palette enable
        out     dx,al                   ; reenable the video

        ; Clean out the dirty register arrays

        xor     al,al                   ; put a nice zero in all the dirty
                                        ; registers
        mov     cx,25+4+9+20            ; do the CRTC, SEQ, GC and AC in
        mov     di,offset dirty_crtc    ; one go
        rep     stosb

        pop     es
        popa
        jmp     noint

egaF7:  ;---Define default register table -------------------------------------
        pusha
        push    es
        push    ds

        ; Load a new set of default registers for a particular EGA/VGA component


        mov     si,bx           ; SOURCE of the incoming data from the app
        mov     ax,es           ; save the SOURCE segment register
        mov     bx,ds           ; save the DESTINATION offset
        mov     ds,ax           ; DS is now the SOURCE segment in the app
        mov     es,bx           ; ES is now the DESTINATION segment in the dvr

        assume ds:nothing, es:SpcMseSeg

F70:    ; Set the default CRTC registers

        cmp     dx,0
        jne     F78
        mov     cx,25           ; copy 25 register entries
        mov     di,offset ega_default_crtc
        rep     movsb           ; do the copy
        jmp     short F7dirty

F78:    ; Set the default Sequencer registers

        cmp     dx,8
        jne     F710
        mov     cx,4            ; copy 4 register entries
        mov     di,offset ega_default_seq
        rep     movsb           ; do the copy
        jmp     short F7dirty

F710:   ; Set the default Graphic Controller registers

        cmp     dx,10
        jne     F718
        mov     cx,9            ; copy 9 register entries
        mov     di,offset ega_default_graph
        rep     movsb           ; do the copy
        jmp     short F7dirty

F718:   ; Set the default Attribute Controller registers

        cmp     dx,18
        jne     F720
        mov     cx,20           ; copy 20 register entries
        mov     di,offset ega_default_attr
        rep     movsb           ; do the copy
        jmp     short F7dirty

F720:   ; Set the default Miscellaneous Output register

        cmp     dx,20
        jne     F7quit
        mov     word ptr cs:[ega_default_misc],si

F7dirty:

        ; Set all the dirty register arrays

        mov     al,1                    ; put a nice one in all the dirty
                                        ; registers
        mov     cx,25+4+9+20            ; dirty all the registers in one go
        mov     di,offset dirty_crtc
        rep     stosb

F7quit:
        pop     ds              ; need to restore the segment registers
        pop     es

        assume  ds:SpcMseSeg, es:nothing

        popa

        jmp     noint

egaFA:  ;--- Interrogate driver -----------------------------------------------
        ; The real Microsoft mouse driver gets this wrong (release 7.03)

        push    ax
        mov     ax,cs
        mov     es,ax
        mov     bx,offset relnum        ; return the address of the mouse
                                        ; driver version number
        pop     ax
        jmp     noint

;=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

ENDIF ; MOUSE_VIDEO_BIOS

do_bop:

        bop     VIDEO_IO_BOP    ;BOP BE
        nop
        nop
        jnc     noint
go_rom:
        popf
        db      0EAh    ; this is a far jump
old_vid_int     dd ?    ; far pointer to the old int 10h vector
        jmp     DOIRET
noint:
        popf
        jmp     DOIRET

mouse_int1:
        bop     INT1_BOP
        jmp     DOIRET

mouse_version:
        dw      04242h
        dw      0000h

mouse_copyright:
        db      "Windows NT MS-DOS subsystem Mouse Driver"

video_io:
        int     VIDEO
        bop     UNSIMULATE_BOP

mouse_int2:
        bop     INT2_BOP
        jmp     DOIRET

mouseINB:
        in      al,dx
        bop     0feh

mouseOUTB:
        out     dx,al
        bop     0feh

mouseOUTW:
        out     dx,ax
        bop     0feh


;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;16 BIT ENTRY POINT 16 BIT ENTRY POINT 16 BIT ENTRY POINT 16 BIT ENTRY POINT
;
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;========================================================================
;   Procedure that provides the driver interface to 32 bit land. This is
;   the entry point to the Intel 16 bit driver from the mouse interrupt
;   handler in the host mouse code.
;
;   This procedure determines the current video mode from the BIOS data
;   area, and depending on this branches to the correct display routines
;   for this mode.
;
;   N.B. This function MUST NOT modify CX and DX because the next level
;   of functions in the driver heirarchy requires the values passed in
;   them from 32 bit land.
;========================================================================

        assume  ds:SpcMseSeg

entry_point_from_32bit  proc    near
        make_stack              ; use the driver's own stack
        push    ds
        push    ax
        push    bx

        mov     ax,cs
        mov     ds,ax

        call    getBIOSvideomode; read the BIOS data area
        xor     bx,bx           ; clear the jump table index
        shl     al,1            ; create a table index for word sized entries
        mov     bl,al           ; move into a base register
        call    [drawpointerJMPT+bx]    ; jump to the correct routine

        pop     bx
        pop     ax
        pop     ds
        kill_stack              ; return to the previous stack

        bop     0FEh            ; return to the 32 bit side

entry_point_from_32bit  endp


;========================================================================
;   Procedure to set the cursor draw flag to DO DRAW. This is called from
;   SoftPC code via a host_simulate(). This routine is called when the
;   application does an INT 33h, function 1.
;
;   In accordance with the Microsoft Programmer's Reference, the internal
;   cursor flag (internalCF) has a default value of -1. If intenalCF = 0
;   then the cursor is drawn. If the flag is already 0, then this function
;   does nothing.
;
;   Note: with calls to int 33h AX = 2, it is legal to
;   make internalCF less than -1.
;========================================================================

int33function1  proc    near

        make_stack              ; use the driver's own stack
        push    ax
        push    bx
        push    ds

        mov     ax,cs
        mov     ds,ax
;; do not allow mouse int comes in while we are updating the cursor.
;;	call	DOCLI

        ; check to see if the pointer should be drawn

;        cmp     [internalCF],0  ; is the flag already zero?
;        jz      fn1quit         ; if so, do nothing

	; pointer is not ON, so increment the flag to try to turn it ON

;        inc     [internalCF]    ; increment the pointer internal flag
;        cmp     [internalCF],0  ; if 0, then the pointer can be drawn
;        jl      fn1quit         ; it is < 0, so don't draw the pointer.

	; The internal cursor flag hits zero for the first time, so
	; draw the pointer.

        call    getBIOSvideomode; read the BIOS data area
        xor     bx,bx           ; clear the jump table index
        shl     al,1            ; create a table index for word sized entries
        mov     bl,al           ; move into a base register
        call    [Int33function1JMPT+bx] ; do the correct function 1 handler
fn1quit:
;;	call	DOSTI
        pop     ds
        pop     bx
        pop     ax
        kill_stack              ; return to the previous stack
        bop     0FEh            ; back to jolly old 32 bit land

int33function1  endp



;========================================================================
;   Procedure to set the cursor draw flag to DONT DRAW. This is called from
;   SoftPC code via a host_simulate(). This routine is called when the
;   application does an INT 33h, function 2
;
;   Note: with calls to int 33h AX = 2, it is legal to
;   make internalCF less than -1.
;========================================================================

int33function2  proc    near

        make_stack              ; use the driver's own stack
        push    ax
        push    bx
        push    ds

        mov     ax,cs
        mov     ds,ax
;; do not allow mouse int comes in while we are updating the cursor.
;;	call	DOCLI

;        dec     [internalCF]    ; decrement the pointer internal flag

	; if the internal cursor flag is less than -1, then do not try
	; do remove the pointer from the screen because this has already
	; been done.

;        cmp     [internalCF],0ffh
;        jl      fn2quit		; do nothing if < -1

	; Internal flag hits -1, so remove the pointer from the screen.

        call    getBIOSvideomode; read the BIOS data area
        xor     bx,bx           ; clear the jump table index
        shl     al,1            ; create a table index for word sized entries
        mov     bl,al           ; move into a base register
        call    [Int33function2JMPT+bx] ; do the correct function 1 handler
fn2quit:
;;	call	DOSTI
        pop     ds
        pop     bx
        pop     ax
        kill_stack              ; return to the previous stack

        bop     0feh

int33function2  endp

;========================================================================
;   Procedure to return straight back to cloud 32. This is needed if an
;   unsupported video mode is found in the BIOS data area.
;========================================================================

not_supported   proc    near
        ret                     ; cant't BOP 0feh here or the stack will die
                                ; (out of balance with CS:IP stored from call)
not_supported   endp

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; END 16 BIT ENTRY END 16 BIT ENTRY END 16 BIT ENTRY END 16 BIT ENTRY
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


;========================================================================
;   Procedure to draw a cursor on the fullscreen X86 graphics display for
;   high resolution graphics modes.
;   This procedure saves the area about to be written over, blts the
;   pointer image onto the screen and restores the background from whence
;   cursor has just come.
;
;   Input:      CX = x-coordinate
;               DX = y-coordinate
;   Output:     None
;========================================================================


drawHiResPointer        proc    near

        ; save the video card's read/write context

;;	call	 DOCLI
        pusha
        push    ds
        mov     ax,cs           ; make sure that DS points to the
        mov     ds,ax           ; right segment


        call    saveVGAregisters
        call    check_for_mode_change


        mov     bx,cx           ; get X coordinate into a base register
        shl     bx,1            ; calculate a word index
        mov     ax,[ChooseImageLUT+bx] ; select the right image LUT
        mov     [PointerLUT],ax ; store the LUT address

	xor	ax,ax		; assume carry clear after the next call
        call    determineboundary
	jnc	detcont		; pointer in buonds if carry clear
	not	ax		; carry was set, so set AX non zero

detcont:

        ; Coordinates are now transformed from Cartesian to physical VRAM
        ; memory byte and bit offsets.

        mov     di,dx           ; store DX for later

        ; internalCF     = the current pointer status
        ; background     = indicates if a background has been stored or not
        ;
        ; if(internalCF == Zero && background == STORED)
        ; The normal cursor ON condition

        cmp     [internalCF],0
        jnz     end_the_if              ; request to turn pointer on
        cmp     [background],STORED
        jne     end_the_if

        mov     si,cx
        mov     di,dx
        mov     dx,[VRAMlastbyteoff]
        mov     cx,[VRAMlastbitoff]
        call    restore_background

	cmp	ax,0		; should the pointer be drawn?
	jnz	end_the_if	; if the pointer has gone off the edge of
				; the screen, then quit

        mov     [VRAMlastbyteoff],di    ; save the current position
        mov     [VRAMlastbitoff],si
        mov     cx,si
        mov     dx,di
        call    save_background
        mov     cx,si
        mov     dx,di
        call    drawEGApointer

end_the_if:

        call    restoreVGAregisters

        pop     ds
        popa
;;	call	 DOSTI
        ret

drawHiResPointer        endp

;========================================================================
;   Procedure to draw a cursor on the fullscreen X86 graphics display.for
;   medium resolution graphics modes.
;   This procedure saves the area about to be written over, blts the
;   pointer image onto the screen and restores the background from whence
;   cursor has just come.
;
;   Input:      CX = x-coordinate
;               DX = y-coordinate
;   Output:     None
;========================================================================

drawMediumResPointer    proc    near

        pusha
;;	call	DOCLI

        shr     cx,1                    ; map from 640 virtual to 320 real

        ; CX,DX = x,y cartesian coordinates here.

        call    check_for_mode_change

        ; internalCF     = the current pointer status
        ; background     = indicates if a background has been stored or not
        ;
        ; if(internalCF == Zero && background == STORED)
        ; The normal cursor ON condition


        cmp     [internalCF],0
        jnz     cant_draw_ptr           ; request to turn pointer on
        cmp     [background],STORED
        jne     cant_draw_ptr
	mov	si, cx			; save new cursor position
	mov	di, dx
	mov	dx,[VRAMlastbyteoff]	;
        mov     cx,[VRAMlastbitoff]
	mov	bp,[LastYCounters]	; Y looping counter
        call    restorebkgrndmode4
	mov	cx, si			; restore new cursor position
	mov	dx, di
	call	detboundmode4		; calculate new byte offset
	jc	cant_draw_ptr		; don't draw new cursor of out of scrn

	mov	[VRAMlastbyteoff], dx	; byte offset
	mov	[VRAMlastbitoff], cx	; MSB = 0FFh if start with ODD line
					; LSB = bit offset
	mov	[LastYCounters], bp	; MSB: even counter, LSB for odd
        call    savebkgrndmode4
        call    drawmode4pointer

cant_draw_ptr:

;;	call	DOSTI
        popa
        ret

drawMediumResPointer    endp

;========================================================================
;   Procedure to draw a cursor on the fullscreen X86 graphics display for
;   medium resolution, 256 colour graphics mode. (video bios mode 13h).
;   This procedure saves the area about to be written over, blts the
;   pointer image onto the screen and restores the background from whence
;   cursor has just come.
;
;   Input:      CX = x-coordinate
;               DX = y-coordinate
;   Output:     None
;========================================================================

drawC256Pointer proc    near
        pusha
;;	call	DOCLI
        shr     cx,1                    ; map from 640 virtual to 320 real x

        ; CX,DX = x,y cartesian coordinates here.

        call    check_for_mode_change

        ; internalCF     = the current pointer status
        ; background     = indicates if a background has been stored or not
        ;
        ; if(internalCF == Zero && background == STORED)
        ; The normal cursor ON condition


        cmp     [internalCF],0
        jnz     cant_draw_256ptr        ; request to turn pointer on
        cmp     [background],STORED
        jne     cant_draw_256ptr

        mov     si,cx
        mov     di,dx
        mov     dx,[VRAMlastbyteoff]
	mov	cx,[LastXCounters]
	mov	bp,[LastYCounters]
        call    restorebkgrndmode13
	mov	cx, si
	mov	dx, di
	call	detboundmode13
	jc	cant_draw_256ptr

	mov	[VRAMlastbyteoff],dx	 ; save the current position
	mov	[LastXCounters],cx
	mov	[LastYCounters], bp
        call    savebkgrndmode13
        call    draw256pointer

cant_draw_256ptr:
;;	call	DOSTI
        popa
        ret
drawC256Pointer endp

;========================================================================
;   Procedure to draw a pointer on the fullscreen X86 text display for
;   BIOS modes 3 and 7.
;   This procedure saves the area about to be written over, XORs the
;   pointer image onto the screen and restores the background from whence
;   cursor has just come.
;
;   Input:      CX = x-coordinate
;               DX = y-coordinate
;   Output:     None
;========================================================================

IFDEF SIXTEENBIT

drawTextPointer proc    near
        pusha
	push	es

        ; CX,DX = x,y virtual pixel coordinates here.
	; 0 <= x < 640
	; 0 <= y < 200	for 25 line mode
	; 0 <= y < 344	for 43 line mode
	; 0 <= y < 400	for 50 line mode
	; The virtual character size is always 8x8 virtual pixels.

        call    check_for_mode_change

        ; internalCF     = the current pointer status
        ; background     = indicates if a background has been stored or not
        ;
        ; if(internalCF == Zero && background == STORED)
        ; The normal cursor ON condition

        cmp     [internalCF],0
        jnz     cant_draw_text_ptr     ; request to turn pointer on
        cmp     [background],STORED
        jne     cant_draw_text_ptr


        ; Calculate the current cell location as an offset
        ; into the text buffer segment starting at B800:0
        ; Note: The following kinky shifts allow for the fact that the text
        ;       video buffer consists of word elements of the form char:attr.
        ;       So, if a row = 80 characters wide on the screen, it is 160
        ;       bytes wide in VRAM.

        mov     bx,dx                   ; create a word table index
        shr     bx,3                    ; virtual char height = 8, but 160 bytes
                                        ; per text row, so save some shifts.
        shl     bx,1                    ; make a word table index
        mov     di,[mult80lut+bx]       ; multiply by 80 words per text row.
        shl     di,1
        shr     cx,3                    ; divide the x virtual pixel coordinate
                                        ; by 8 = virtual char width and mult
                                        ; by 2 to get word offset in text row.
        shl     cx,1
        add     di,cx                   ; full VRAM location now in DI

        ; Restore the text cell previously overwritten.

        mov     si,[VRAMlasttextcelloff]; address of last modified text cell
        mov     [VRAMlasttextcelloff],di; store the current cell location

        mov     ax,0b800h               ; the text buffer segment
        mov     es,ax                   ; ES now points there

        ; The text pointer uses the same magic as the graphics code
        ; to place a pointer on the screen.

        mov     bx,07700h               ; the magic cursor mask for pointer
        mov     cx,077ffh               ; the magic screen mask for pointer

        assume es:nothing

        mov     ax,[lasttextimage]      ; restore the background
        mov     es:[si],ax              ; from last time
        mov     ax,es:[di]              ; load the cell to be modifyed
        mov     [lasttextimage],ax      ; save this cell for next time
        and     ax,cx                   ; apply the screen mask
        xor     ax,bx                   ; apply the cursor mask
        mov     es:[di],ax              ; and write back

        assume es:SpcMseSeg

cant_draw_text_ptr:

	pop	es
        popa
	ret
drawTextPointer endp

ENDIF ;; SIXTEENBIT

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Interrupt 33h support functions.
; These functions are called via a jump table from the 16 bit entry
; point code.
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;========================================================================
;   Procedure to set the cursor draw flag to DO DRAW. This is called from
;   SoftPC code via a host_simulate(). This routine is called when the
;   application does an INT 33h, function 1
;========================================================================

int33function0  proc    near

        make_stack                      ; use the driver's own stack
        push    ds
        push    es
        pusha

        ; sort out the segments

        mov     ax,cs
        mov     ds,ax
        mov     ax,cs
        mov     es,ax
;; do not allow mouse int comes in while we are updating the cursor.
;;	call	DOCLI
        ; set the internal pointer flag to its default value.

        mov     [internalCF],0ffh

        ; set the default hotspot location = (0,0)

        xor     ax,ax
        mov     [hotspot],ax
        mov     [hotspot+2],ax

        ; copy the default pointer to the working pointer buffer

        lea     si,default_cursor
        lea     di,current_cursor
        call    copy_pointer_to_current

        ; clear the pointer enabled flag, turn the pointer off by restoring
        ; the background.

        mov     [background],NOTSTORED  ; there is no stored background now

;;	call	DOSTI
        popa
        pop     es
        pop     ds
        kill_stack                      ; restore the previous stack
        bop     0FEh

int33function0  endp



;========================================================================
;   Procedure to accept a cursor bit image from the current application
;   at ES:DX. This is stored as the current pointer image for use by
;   the driver.
;========================================================================

assume es:nothing

int33function9  proc    near
	call	DOCLI
        make_stack                      ; use the driver's own stack
        push    ds
        push    es
        pusha


        mov     ax,cs                   ; point at the driver data segment
        mov     ds,ax
;; do not allow mouse int comes in while we are updating the cursor.
;;	call	DOCLI
        ; Read in the hotspot cartesian coordinate values for the
        ; new pointer image. If the hotspot values are out of range
        ; i.e. >127 | < -128, then reset to the boundary value
        ; Now using kinky non modRM short forms by clever use of AX

        mov     ax,127                  ; load accumulator with 127
        mov     bp,ax                   ; store this constant in a register
        cmp     ax,bx                   ; compare X value of hotspot with 127
        jg      test_low_x              ; if 127 > BX, BX is within upper limit
        xchg    ax,bx                   ; BX > 127, so set to 127
        jmp     short check_y_hotspot   ; now test the Y values

test_low_x:

        not     ax                      ; change accumulator from 127 to -128
        cmp     ax,bx                   ; compare X value of hotspot with -128
        jl      check_y_hotspot         ; if -128 < BX, BX is within lower lim.
        xchg    ax,bx                   ; BX < -128, so set it to -128

check_y_hotspot:

        mov     ax,bp                   ; reload AX with 127
        cmp     ax,cx                   ; compare Y value of hotspot with 127
        jg      test_low_y              ; if 127 > CX, Cx is within upper limit
        xchg    ax,cx                   ; CX > 127, so set CX to 127
        jmp     short done_hotspot_check; both hotspot coords tested, so save

test_low_y:

        not     ax                      ; change accumulator from 127 to -128
        cmp     ax,cx                   ; compare Y value of hotspot with -128
        jl      done_hotspot_check      ; if -128 < CX, CX is within lower lim.
        xchg    ax,cx                   ; CX < -128, so set it to -128

done_hotspot_check:

        mov     [hotspot],bx            ; save the hotspot x,y
        mov     [hotspot+2],cx          ; y component of the hotspot

        ; DESTINATION: the driver current pointer buffer
        ; Note: the SOURCE is already being pointed at by DX

        lea     di,current_cursor       ; this is the bit that must change
        mov     si,dx

        ; copy in the new application pointer

        mov     ax,es
        mov     ds,ax                   ; DS now points to where ES points
        mov     ax,cs
        mov     ax,es                   ; ES points to our data area now
        call    copy_pointer_to_current ; Copy the pointer image appropriately

        popa
        pop     es
        pop     ds
        kill_stack                      ; restore the previous stack
	call	DOSTI
        ret				; this code is called from within this
					; 16 bit driver, so don't BOP
int33function9  endp

;============================================================================
;   Procedure to display the pointer image in HIRES graphics modes
;============================================================================

HiResInt33Function1     proc    near

        pusha
        call    check_for_mode_change
        call    saveVGAregisters
        mov     cx,[current_position_x] ; get the last known cursor position
        mov     dx,[current_position_y] ; from the OS via the event loop
        call    determineboundary       ; convert to VRAM coordinates
	jc	end_function1		; if the pointer has gone off the edge
					; of the screen, then quit
        mov     [VRAMlastbyteoff],dx    ; save the restore background location
        mov     [VRAMlastbitoff],cx
        mov     si,cx
        mov     di,dx
        call    save_background
        mov     cx,si
        mov     dx,di
        call    drawEGApointer
        mov     [background],STORED
end_function1:
        call    restoreVGAregisters
        popa
        ret                             ; return to driver surface manager code

HiResInt33Function1     endp

;============================================================================
;   Procedure to display the pointer image in MEDIUMRES graphics modes
;   Note that this function does a conversion from virtual pixel coordinates
;   to real screen coordinates as required if the stored values in the
;   current_position memory locations are greater than 320 for X or 200
;   for Y.
;============================================================================

MediumResInt33Function1 proc    near

        pusha
        call    check_for_mode_change
        mov     cx,[current_position_x] ; get the last known cursor position
        mov     dx,[current_position_y] ; from the OS via the event loop
	shr	cx,1			; virtual coor -> screen coor
        call    detboundmode4           ; convert to VRAM coordinates
	jc	MediumResFunction1_exit

        mov     [VRAMlastbyteoff],dx    ; save the restore background location
        mov     [VRAMlastbitoff],cx
	mov	[LastYCounters], bp
        call    savebkgrndmode4
        call    drawmode4pointer
        mov     [background],STORED

MediumResFunction1_exit:
        popa
        ret

MediumResInt33Function1 endp

;============================================================================
;   Procedure to display the pointer image in VGA 256 colour graphics modes
;============================================================================

C256Int33Function1      proc    near
        pusha
        call    check_for_mode_change
        call    modifyentry255          ; make sure that DAC entry 255 is white
        mov     cx,[current_position_x] ; get the last known cursor position
	mov	dx,[current_position_y]
	shr	cx, 1			; virtual coor -> screen coord
        call    detboundmode13          ; convert to VRAM coordinates
	jc	C256Function1_exit

        mov     [VRAMlastbyteoff],dx    ; save the restore background location
	mov	[LastXCounters],cx	; X loop counter
	mov	[LastYCounters], bp	; Y loop counter
        call    savebkgrndmode13
        call    draw256pointer
        mov     [background],STORED

C256Function1_exit:
        popa
        ret                             ; return to driver surface manager code

C256Int33Function1      endp

;============================================================================
; Procedure to show the TEXT pointer
;============================================================================
IFDEF SIXTEENBIT

TextInt33Function1     proc    near

        pusha
        push    es

        mov     [background],STORED
        call    check_for_mode_change

        mov     cx,[current_position_x] ; get the last known cursor position
        mov     bx,[current_position_y] ; from the OS via the event loop

        shr     bx,3                    ; virtual char height = 8, but 160 bytes
                                        ; per text row.
        shl     bx,1                    ; make a word table index
        mov     di,[mult80lut+bx]       ; multiply by 80 words per text row.
        shl     di,1                    ; remember 160 bytes NOT 80 in a row
        shr     cx,3                    ; divide the x virtual pixel coordinate
                                        ; by 8 = virtual char width and mult
                                        ; by 2 to get word offset in text row.
        shl     cx,1
        add     di,cx                   ; full VRAM location now in DI

        mov     [VRAMlasttextcelloff],di; store the current cell location

        mov     ax,0b800h               ; the text buffer segment
        mov     es,ax                   ; DS now points there

        mov     bx,07700h               ; the magic cursor mask for pointer
        mov     cx,077ffh               ; the magic screen mask for pointer

        assume es:nothing

        mov     ax,es:[di]              ; load the cell to be modifyed
        mov     [lasttextimage],ax      ; save this cell for next time
        and     ax,cx                   ; apply the screen mask
        xor     ax,bx                   ; apply the cursor mask
        mov     es:[di],ax              ; and write back

        assume es:SpcMseSeg

        pop     es
        popa
        ret                             ; return to driver surface manager code

TextInt33Function1     endp

ENDIF ;; SIXTEENBIT
;============================================================================
;   Procedure to remove the pointer image in HIRES graphics modes
;============================================================================

HiResInt33Function2     proc    near

        push    cx
        push    dx

        call    saveVGAregisters
        call    check_for_mode_change

        cmp     [background],STORED     ; is there some stored background?
        jne     no_background_stored    ; no, so don't restore it
        mov     dx,[VRAMlastbyteoff]
        mov     cx,[VRAMlastbitoff]
        call    restore_background      ; restored the background at correct
        mov     [background],NOTSTORED  ; place. Set buffer cleared Flag

no_background_stored:

        call    restoreVGAregisters

        pop     dx
        pop     cx
        ret

HiResInt33Function2     endp

;============================================================================
;   Procedure to remove the pointer image in MEDIUMRES graphics modes
;============================================================================

MediumResInt33Function2 proc    near
        push    cx
        push    dx
	push	bp
        call    check_for_mode_change

        cmp     [background],STORED     ; is there some stored background?
        jne     nobkgrndstored          ; no, so don't restore it
        mov     dx,[VRAMlastbyteoff]
        cmp     dx,80*100               ; mustn't be greater than buffer size
        jl      vidoffok                ; it's OK, so do nothing
        mov     dx,80*10-1              ; modify DX to fit in the buffer
vidoffok:
	mov	cx,[VRAMlastbitoff]	; CL = bit offset
					; CH = odd/even flag
	and	cl,3			; cannot be greater than bit 3( 2bits/p)
	mov	bp, [LastYCounters]
        call    restorebkgrndmode4      ; restored the background at correct
        mov     [background],NOTSTORED  ; place. Set buffer cleared Flag

nobkgrndstored:
	pop	bp
        pop     dx
        pop     cx
        ret
MediumResInt33Function2 endp

;============================================================================
;   Procedure to remove the pointer image in MEDIUMRES graphics modes
;============================================================================

C256Int33Function2      proc    near
        push    cx
        push    dx
	push	bp
        call    check_for_mode_change

        cmp     [background],STORED     ; is there some stored background?
        jne     nobkgrndstored256       ; no, so don't restore it
        mov     dx,[VRAMlastbyteoff]
	mov	cx,[LastXCounters]
	mov	bp,[LastYCounters]
        call    restorebkgrndmode13     ; restored the background at correct
        mov     [background],NOTSTORED  ; place. Set buffer cleared Flag
nobkgrndstored256:

	pop	bp
        pop     dx
        pop     cx
        ret

C256Int33Function2      endp

;============================================================================
;   Procedure to remove the pointer image in TEXT modes
;============================================================================

IFDEF SIXTEENBIT

TextInt33Function2     proc    near

	push	ax
	push	si
	push	es

        call    check_for_mode_change

        cmp     [background],STORED     ; is there some stored background?
        jne     no_text_background_stored    ; no, so don't restore it

        mov     [background],NOTSTORED  ; place. Set buffer cleared Flag

	; Restore the text cell previously overwritten.

        mov	si,[VRAMlasttextcelloff]; address of last modified text cell

	mov	ax,0b800h		; the text buffer segment
	mov	es,ax			; DS now points there

	assume es:nothing

	mov	ax,[lasttextimage]	; restore the background
	mov	es:[si],ax		; from last time

no_text_background_stored:

	assume	es:SpcMseSeg

        pop     es
        pop     si
        pop     ax
        ret

TextInt33Function2     endp

ENDIF ;; SIXTEENBIT

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; End of Interrupt 33h support functions.
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Mouse driver general support functions
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


;========================================================================
;  Procedure to determine if the application has changed video modes since
;  the last mouse interrupt. If it has, then the image that is saved in the
;  background restore buffer is invalid and should not be drawn.
;========================================================================

check_for_mode_change   proc    near

        push    ax

        call    getBIOSvideomode; peek at the BIOS data area for video mode
        cmp     al,[lastvidmode]; compare with the last mode value
                                ; from the preceding interrupt
        jnz     mode_change     ; a mode change has occurred
        pop     ax              ; no mode change, so quit
        ret
mode_change:
        mov     [background],NOTSTORED
        mov     byte ptr [lastvidmode],al       ; store the new mode
        pop     ax

        ret
check_for_mode_change   endp

;========================================================================
; Procedure to read the BIOS data area and get the current video mode
; Output:   AL = BIOS video mode
; Modifies: memory variable -> currentvidmode, puts the video found in
;           the BIOS data area in this memory location.
;========================================================================

getBIOSvideomode        proc    near

        push    es
        push    bx
        mov     ax,40h          ; BIOS data area segment
        mov     es,ax

        mov     al,es:[49h]     ; get the BIOS video mode data

        mov     bl,al           ; copy the video mode value
        xor     bh,bh
        shl     bx,1            ; create a word table index
        mov     bx,[latchhomeLUT+bx] ; get the latch hiding place for this
                                ; video mode
        mov     [latchcache],bx ; save in memory for use in save and restore
                                ; vga registers.

        pop     bx
        pop     es              ; restore the 'normal' data segment
        ret

getBIOSvideomode        endp

;=========================================================================
; Function to modify the 256th palette entry for 256 colour mode. The
; driver requires white to be set in this DAC register triple.
;=========================================================================
modifyentry255  proc    near
        push    ax
        push    dx
        mov     dx,03c8h
        mov     al,0ffh
        out     dx,al
        inc     dx
        out     dx,al
        out     dx,al
        out     dx,al
        pop     dx
        pop     ax
        ret
modifyentry255  endp


;========================================================================
;   Procedure to copy the required pointer image to the snapshot
;   buffers. Each buffer holds a different instance of the mouse
;   pointer for each possible alignment of the pointer image in
;   a VRAM byte.
;
;   INPUT DS:SI = pointer to the source image
;
;========================================================================

assume  ds:nothing

copy_pointer_to_current proc    near

        push    ds
        push    es
        pusha


        ; Set up the destination for the copy

        mov     ax,cs                   ; point ES to this segment
        mov     es,ax
        lea     di,current_cursor       ; this is the bit that must change
        mov     bx,di                   ; save this address for a while
        mov     bp,si                   ; save the application source address

        ; Fill the AND buffer with 1s and then fill the XOR buffer with
        ; 0s for the byte aligned pointer condition. This is done so that
        ; the last byte in the 3byte scanline sequence is set to the correct
        ; value to prevent image loss from the screen.

        cld                             ; move low mem -> high mem
        mov     ax,24                   ; avoid doing a modRM load of immediate
        mov     cx,ax                   ; 24 words to fill.
        mov     dx,ax                   ; store this for a while
        xor     ax,ax                   ; clear AX (AX = 0)
        not     ax                      ; AX = 0ffffh -> fill AND mask with it.
        rep     stosw                   ; fill the screen mask (AND mask)
        mov     cx,dx                   ; do the next 24 words (XOR mask)
        not     ax                      ; AX = 0h -> fill XOR mask with it
        rep     stosw                   ; Fill the cursor mask

        ; Now fill the prepared 48 word buffer with the user defined
        ; AND and XOR masks
        ; Note that the image passed in from the application is little-endian.
        ; To write to the VGA planes byte by byte, the image has to be reversed
        ; to big-endian for the purpose of quick drawing since the VGA can only
        ; read and write one byte from/to its latches.

        mov     di,bx                   ; point to the top of the buffer again
        mov     si,bp                   ; point to the new pointer image

	mov	cx,32
norept1:
        lodsw                           ; read in the required image word
        xchg    al,ah                   ; convert little endian to big endian
        stosw                           ; write into local buffer
        inc     di                      ; remember local buffer in 3 bytes wide
	dec	cx
	jnz	norept1

        ; Now, the aligned mask must be rotated, then copied into each of
        ; the seven unaligned image buffers.

        mov     ax,cs
        mov     ds,ax                   ; return to the default data segment

        mov     bp,1000000000000000b    ; a mask for the MSBit

        lea     di,AlignData1           ; point to the buffer for 1 bit offset
        mov     si,bx                   ; source = byte aligned pointer image

	push	bx
	mov	bx,32*7
norept2:
        lodsw                           ; load the word from 3 byte sequence
        xchg    al,ah                   ; put into little-endian format
        mov     cl,byte ptr [si]        ; load the remaining byte
        shr     ax,1                    ; LSB now stored in CF
        rcr     cl,1                    ; CF into MSB, lsb into CF
        jnc     $+4                     ; CF=0 -> don't need to do anything
        or      ax,bp                   ; OR in the carried bit from CF
        xchg    al,ah                   ; return to bitstream format
        stosw                           ; write the rotated data
        mov     byte ptr[di],cl
        inc     si                      ; point to the next source scanline
        inc     di                      ; point to the next dest scanline

	dec	bx
	jnz	norept2
	pop	bx

        ; Just to do a little bit more work, the rotated buffers created
        ; above must be copied to the instances for byte 78 and byte 79
        ; of the scanline. These images are then cunningly clipped in the
        ; process to the edge of the screen!

        mov     si,bx                   ; BX points to the top of current buffer
                                        ; Note DI points to clip_cursor78 now

        ; may as well use the nice string functions now that I don't
        ; have to XCHG bytes. (how space and cycle efficient

        xor     al,al                   ; constant for putting in masks

        ; there are 8 instances for bits 0 to 7

	mov	bx,8
norept3:

        ; Do the AND mask modifications for byte 78

        not     al                      ; AL = 11111111b
        REPT    16                      ; 16 scanlines
        movsw                           ; copy contents of AND word
        stosb                           ; Nice clear AND mask = 11111111b
        inc     si                      ; point to the first image byte in
                                        ; the next scanline
        ENDM

        ; Do the XOR mask modifications for byte 78

        not     al                      ; AL = 00000000b
        REPT    16                      ; 16 scanlines
        movsw                           ; copy contents of XOR word
        stosb                           ; Nice clear XOR mask = 00000000b
        inc     si                      ; point to the first image byte in
                                        ; the next scanline
        ENDM

	dec	bx
	jnz	norept3

        ; prepare the BYTE 79 instances
        ; SI and DI should be in the right place

        xor     ax,ax                   ; constant for putting in masks
        mov     bx,2                    ; constant for addressing source

        ; there are 8 instances for bits 0 to 7

	mov	cx,8
norept4:

        ; Do the AND mask modifications for byte 79

        not     ax                      ; AX = 0ffffh
        REPT    16                      ; 16 scanlines
        movsb                           ; copy contents of AND byte
        stosw                           ; Nice clear AND mask (=0ffffh)
        add     si,bx                   ; point to the first image byte in
                                        ; the next scanline
        ENDM

        ; Do the XOR mask modifications for byte 79

        not     ax                      ; AX = 0h
        REPT    16                      ; 16 scanlines
        movsb                           ; copy contents of XOR byte
        stosw                           ; Nice clear XOR mask
        add     si,bx                   ; point to the first image byte in
                                        ; the next scanline
        ENDM

	dec	cx
	jz	norept4quit
	jmp	norept4
norept4quit:
	
        popa
        pop     es
        pop     ds

        ret
copy_pointer_to_current endp

;========================================================================
;   Procedure to determine the segment of the video buffer for
;   the current display mode.
;========================================================================

assume ds:SpcMseSeg

getvideobuffer  proc    near

        push    ax
        push    si

        ; determine the current video mode from the BIOS and save it.
        ; Use this value to determine the video buffer segment address.

        mov     ah,0fh                  ; use the bios to get the video mode
        int     10h
        cbw                             ; create a table index
        shl     ax,1                    ; word sized table entries
        mov     si,ax
        mov     ax,[videomodetable+si]  ; use video mode to index the table
        mov     [videobufferseg],ax


        pop     si
        pop     ax
        ret

getvideobuffer  endp

IFDEF DEBUGMOUSE

;=========================================================================
; Code to provide 32 bit side with a dump of the VGA registers on request.
;=========================================================================

VGAregs db      9+5+25 dup(?)           ; enough room for sequencer, GC and CTRC

dumpVGAregs     proc    near

        call    DOCLI
        pusha
        push    ds


        mov     ax,cs
        mov     ds,ax

        assume  ds:SpcMseSeg

        ; Save the Graphics Controller registers

        xor     bx,bx           ; Index into the G.C. register saving array
        mov     dx,03ceh        ; Graphics Controller index register
        xor     ax,ax

        mov	cx,9            ; save 9 G.C. registers
norept5:
        mov     al,ah
        out     dx,al           ; Select it
        inc     dx              ; Address the register
        in      al,dx           ; Get the register contents
        mov     [VGAregs+bx],al ; Save the register
        inc     bx              ; index to next array entry
        inc     ah
        dec     dx              ; Sequencer index register
	dec	cx
	jnz	norept5

        ; Save the Sequencer registers

        mov     dx,03c4h        ; Sequencer index register
        xor     ax,ax

        mov	cx,5            ; save 5 sequencer registers
norept6:
        mov     al,ah
        out     dx,al           ; Select it
        inc     dx              ; Address the register
        in      al,dx           ; Get the register contents
        mov     [VGAregs+bx],al ; Save the register
        inc     bx              ; index to next array entry
        inc     ah
        dec     dx              ; Sequencer index register
	dec	cx
	jnz	norept6

        ; Save the CRTC registers

        mov     dx,03d4h        ; CRTC index register
        xor     ax,ax

        mov	cx,25              ; save 25 sequencer registers
norept7:
        mov     al,ah
        out     dx,al           ; Select it
        inc     dx              ; Address the register
        in      al,dx           ; Get the register contents
        mov     [VGAregs+bx],al ; Save the register
        inc     bx              ; index to next array entry
        inc     ah
        dec     dx              ; CRTC index register
	dec	cx
	jnz	norept7

        pop     ds
        popa
        call    DOSTI
        bop     0feh                    ; return to 32 bit land

dumpVGAregs     endp

ENDIF   ; DEBUGMOUSE


;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; End of Mouse driver general support functions
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;========================================================================
;   Procedure to draw an EGA pointer image on the graphics screen at a
;   specified bit location.
;
;   Input:      CX = pointer offset in the current VRAM byte.
;               DX = offset in the video buffer to pointer
;   Output:     None
;   Modifies:   AX,BX,CX,DX,BP,SI,DI
;========================================================================

        assume  ds:SpcMseSeg
.286
even

drawEGApointer  proc    near

        push    es
        push    ds

        mov     ax,cs
        mov     ds,ax

        cld                 ; index from low memory to high for LODSB

        ; point to the video buffer

        mov     ax,0a000h
        mov     es,ax
        mov     bp,dx       ; save the byte offset in VRAM for the XOR code

        ; Select the Graphics Controller

        mov     dx,03ceh

        ;************ AND MASK OPERATION **************************

        ; use the bit position to select the relavent pointer image

        shl     cx,1        ; need a word offset into LUT
        mov     di,cx       ; need an index register
        mov     bx,[PointerLUT]
        mov     si,[bx+di]  ; Point to the screen (AND) mask
        mov     di,bp       ; point to the byte offset in VRAM
        mov     ax,0803h    ; Index the data rotate register and select AND
        out     dx,ax       ; do it
        mov     ax,80-2     ; Avoid modRM loading of CX
        mov     cx,ax       ; A constant handily kept in a register

                            ; The pointer contains 16 words of information
	push	bx
	mov	bx,16
norept8:

        lodsw               ; Load 2 bytes from the AND mask into AL and AH
        xchg    al,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        inc     di          ; point to the next byte in VRAM

        xchg    ah,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        inc     di          ; point to the next byte in VRAM

        lodsb               ; Load a byte from the AND mask into AL
        xchg    al,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        add     di,cx       ; point to the next byte in VRAM on the next scan
                            ; line to write to. CX contains 80-2

	dec	bx
	jnz	norept8
	pop	bx

        ;************ XOR MASK OPERATION **************************

        ; Note: SI points to current_cursor+48 now, automatically
        ; i.e. at the start of the XOR mask.

        mov     di,bp       ; point to the byte offset in VRAM
        mov     ax,1803h    ; Index the DATA ROTATE REGISTER and
                            ; Select the XOR function to XOR CPU data in
        out     dx,ax       ; Do the deed

	push	bx
	mov	bx,16
norept9:

        lodsw               ; Load 2 bytes from the AND mask into AL and AH
        xchg    al,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        inc     di          ; point to the next byte in VRAM

        xchg    ah,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        inc     di          ; point to the next byte in VRAM

        lodsb               ; Load a byte from the XOR mask into AL
        xchg    al,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        add     di,cx       ; point to the next byte in VRAM on the next scan
                            ; line to write to. CX contains 80-2
	dec	bx
	jnz	norept9
	pop	bx

        pop     ds
        pop     es
        ret

drawEGApointer  endp

;========================================================================
; Procedure to determine what the byte and bit offset is, in the current
; VGA buffer for the top left hand corner of the pointer bitmap.
; The X,Y value is modified for hotspot in this routine. A flag is set,
; also, to relay whether or not the cursor bitmap is byte aligned or not.
;
; INPUT: CX,DX = pointer x,y coordinates
; OUT  : DX    = byte offset to top left hand pointer pixel
;        CX    = bit offset in the byte
;	 CF    = set if it is not possible to draw the pointer on the
;                screen because of the hotspot adjustment. (Usually a
;		 negative hotspot value will cause clipping and wrapping
;		 problems at the right and bottom screen boundaries.
;========================================================================

determineboundary       proc    near

        push    ax
        push    bx
	push	es


        ; do the adjustment in x,y for pointer hotspot
        ; Also test for top or left screen boundary problems
	; and zero the coordinate if it goes negative.

	
        sub     cx,[hotspot]    ; adjust the x cartesian coord for hotspot
        jns     dont_zero_x     ; if x goes negative, assume zero
        xor     cx,cx
dont_zero_x:
        sub     dx,[hotspot+2]  ; adjust the y cartesian coord for the hotspot
        jns     dont_zero_y     ; if y goes negative, assume zero
        xor     dx,dx
dont_zero_y:

	; Now check the right and bottom bounds to prevent the pointer
	; image wrapping if the hotspot adjustment forces either of
	; the coordinates to exceed the screen bounds.
 	; First, for all video modes that this function handles, the
	; X bound is always x < 640 ... check this first.

	cmp	cx,640
	jl	didntexceedX
	stc			; Oh oh - failed, so set carry flag.
	jmp	short quitdet	; bye bye.

didntexceedX:

	; Now check out the y value by finding the maximum extent from
	; a lut based on the current BIOS video mode.

	mov	ax,40h		; B.D.A. segment
	mov	es,ax		; and ES points to it.
	mov	al,byte ptr es:[49h]
	sub	al,0fh		; table is normalized. mode f is in entry
				; zero.
	xor	ah,ah		; create a look up table index
	shl	ax,1		; for a table with word sized elements.
	xchg	bx,ax		; use a suitable register as index

	cmp	dx,[hiresylut+bx]	; get the extent and compare y coord.
	jl	didntexceedY
	stc			; Oh oh - failed, so set carry flag.
	jmp	short quitdet	; bye bye.

didntexceedY:

        ; determine the byte offset from the start of the video buffer
        ; for the modified coordinates. First calculate how many bytes
        ; there are for the number of scanlines -1 to where the pointer
        ; is.

        mov     ax,dx           ; copy Y position into AX
	shl     ax,1            ; create a word table index
	xchg    ax,bx           ; copy table index into a base register
	mov     dx,[mult80lut+bx]       ; do a fast LUT multiply by 80

        ; determine the byte position of the pixel in question

        mov     ax,cx           ; save the x-coordinate displacement
        and     ax,7            ; do a modulus 8 to find the pixel position
                                ; in the byte. The bit number is in DX.

        ; add the whole number of bytes in the current row to the number
        ; of complete-row bytes

        shr     cx,3            ; divide pixels by 8 to get bytes
        add     dx,cx           ; DX hold the complete byte offset.
        xchg    ax,cx           ; CX = bit offset in the byte.

	; the pointer has not exceeded the screen buonds, so clear
	; the carry flag to signify this.

	clc

	; Wind up the routine and return with the carry flag:
	; SET if cursor exceeded screen bounds.
	; CLEAR otherwise.
quitdet:

	pop	es
        pop     bx
        pop     ax
        ret

determineboundary       endp

;========================================================================
; Procedure to buffer up the data over which the cursor will next be
; drawn. This data will be used to replace the cursor at a later point
; when the cursor position has changed and for generating a cursor image
; To prevent having separate routines for aligned and unaligned pointer
; saves, this routine saves a pixel block 24 x 16 deep in all cases. The
; start offset is a byte location into VRAM in which the pointer TLHC lives.
;
; Input:        DX = VRAM byte
; Modifies:     AX,BX,DI,CX,DX,ES
;
;========================================================================

assume ds:SpcMseSeg

even

save_background proc    near

        push    ds
        push    es
        pusha

        mov     ax,cs           ; point DS briefly at the driver data
        mov     ds,ax
        mov     es,ax           ; point ES to the driver segment

        lea     di,behindcursor ; DESTINATION: a nice, safe place in the
                                ; driver segment
        mov     ax,0a000h       ; point DS at VRAM
        mov     ds,ax

        assume  ds:nothing

        mov     bp,dx           ; save DX=VRAM byte offset for later use
        mov     dx,03ceh        ; VGA GC index register
        mov     al,4            ; select the read map select reg
        out     dx,al           ; Index in the map select register
        inc     dx              ; DX holds port address to map select register
        xor     al,al           ; plane 0 will be selected first

        cld                     ; make sure to address forward in memory
        mov     ah,3            ; number of bytes to copy per pointer scanline
        xor     cx,cx           ; counter for the REP MOVSB
        mov     bx,80-3         ; another handy constant: move to next scanline
                                ; byte.

        REPT    4               ; read the 4 EGA planes individually

        mov     si,bp           ; SOURCE: somewhere in VRAM
        out     dx,al           ; do the plane selection
        inc     al              ; select the next plane to latch

        ; note that only one byte at a time may be read from the latches

                                ; do 16 scanlines for each plane
	push	dx
	mov	dx,16
@@:
        mov     cl,ah           ; CX now contains 3
        rep     movsb           ; copy 3 bytes from VRAM to data segment
        add     si,bx           ; move down to the first byte in next scanline
	dec	dx
	jnz	@B		; norept10
	pop	dx

        ENDM

        popa
        pop     es
        pop     ds

        ret

save_background endp

;========================================================================
;   Procedure to restore the area of the screen that was behind the cursor
;   before it had moved.
;
;   Note. Currently (2/12/92) this is the only routine that modifies the
;   VGA sequencer. Therefore, the code from save and restore vga registers
;   that maintain the sequencer registers has been moved to here for
;   centralisation purposes.
;
;   Input:      DX = VRAM byte
;   Output:     None
;   Modifies:   AX,BX,CX,DX,DI,SI
;========================================================================
assume  ds:SpcMseSeg

even

restore_background      proc    near
        push    ds
        push    es
        pusha

;;	call	 DOCLI		 ; turn off interrupts
        mov     ax,cs
        mov     ds,ax           ; point at the driver data segment
        mov     ax,0a000h       ; videobufferseg
        mov     es,ax           ; point ES at VRAM segment
        mov     bp,dx           ; save the pointer for later
        mov     si,offset behindcursor ; SOURCE: point at the stored planes

        ; set up the Graphic Controller for the restore.

        mov     dx,03ceh        ; VGA GC index register
        mov     ax,0003h        ; Select copy into latches function
        out     dx,ax           ; i.e. data rotate -> replace
        mov     ax,0ff08h       ; bitmask register reset
        out     dx,ax

        ; do the 4 plane restore.

        mov     cx,80-2         ; point to the first byte in image on next line
        cld                     ; write forward in memory
        mov     bx,0102h        ; BH = initial plane mask value
                                ; plane 0 is selected with a 1
                                ; BL = map mask register offset
        mov     dx,03c4h        ; index register for sequencer

        mov     al,bl           ; point to the map mask register in sequencer
        out     dx,al           ; index the register into 03c5h
        inc     dx              ; point to the data register
        in      al,dx           ; read the data register value in
        dec     dx              ; restore DX to 03c4h
        mov     [seqregs],al    ; save the map mask register value

        REPT    4               ; 4 planes to restore

        mov     di,bp           ; DESTINATION: pointer into VRAM
        mov     ax,bx           ; select the plane to mask and map mask register
        out     dx,ax           ; do the mask
        shl     bh,1            ; point to the mask for the next iteration

	push	dx
	mov	dx,16
@@:

        lodsw                   ; load the old background data (ONE WORD)
        xchg    al,es:[di]      ; latch the VRAM data and swap with the
        inc     di              ; point to next byte to replace
        xchg    ah,es:[di]      ; latch the VRAM data and swap with the
        inc     di              ; point to next byte to replace
        lodsb                   ; load the old background data (ONE BYTE)
        xchg    al,es:[di]      ; latch the VRAM data and swap with the
        add     di,cx           ; point to the first byte in image on next line

	dec	dx
	jnz	@B		; norept11
	pop	dx

        ENDM

        mov     ah,[seqregs]    ; the old map mask value
        mov     al,bl           ; need to restore the map mask register
        out     dx,ax           ; do the restore
;;	call	 DOSTI		 ; reenable interrupts.
        popa
        pop     es
        pop     ds
        ret
restore_background      endp


;==========================================================================
;   Procedure to save the register state of the VGA card on receiving a
;   mouse pointer update interrupt. This procedure also sets up the following
;   VGA registers to nice values for the driver.
;
;   mode register               <write mode 0, read mode 0>
;   data rotate register        <do not rotate, no logical ops>
;   enable set/reset register   <disable set/reset>
;
;==========================================================================

even
assume ds:SpcMseSeg

saveVGAregisters        proc    near

        push    dx
        push    di
        push    es

        ; Save the Graphics Controller registers that the
        ; Driver uses

        xor     bx,bx           ; Index into the G.C. register saving array
        mov     dx,03ceh        ; Graphics Controller index register
        xor     al,al

	push	cx
        mov	cx,9            ; save 9 G.C. registers
norept12:
        out     dx,al           ; Select it
        inc     dx              ; Address the register
        in      al,dx           ; Get the register contents
        mov     [GCregs+bx],al  ; Save the register
        inc     bx              ; index to next array entry
        mov     al,bl
        dec     dx              ; G.C. index register
	dec	cx
	jnz	norept12
	pop	cx

        ; save the latches to location in a bit of video buffer
        ; off the screen.

        mov     ax,0a000h       ; point to the video buffer
        mov     es,ax

        assume  es:nothing

        mov     ax,0105h        ; select write mode 1 to squirt latches out
        out     dx,ax           ; do the selection
        mov     di,[latchcache] ; 1 byte over the last location
        mov     es:[di],al      ; write the latches out to the planes

        ; disable the enable set/reset register

        mov     ax,01h          ; select enable set/reset register and clear it
        out     dx,ax

        ; clear the data rotate register (no logical operations).

        inc     ax
        inc     ax              ; select data rotate register and clear it
        out     dx,ax           ; AX = 3 therefore points to the DRR

        ; set write mode 0 for the graphics display
        ; conveniently, this also sets read mode to 0 which is needed too!

        inc     ax
        inc     ax              ; select write mode 0
        out     dx,ax           ; AX = 5, i.e. the mode register

	; color don't care. don't care for all planes
	inc	ax		;register 7, color don't care
	inc	ax
	out	dx, ax
	; bit mask register. enable all planes
	;
	inc	ax		;register 8, bit mask
	not	ah
	out	dx, ax
        pop     es
        pop     di
        pop     dx
        ret

saveVGAregisters        endp

;==========================================================================
;   Procedure to restore the register state of the VGA card after dealing
;   with mouse pointer update interrupt.
;==========================================================================

restoreVGAregisters     proc    near

        assume  ds:SpcMseSeg

        push    es
        push    di
        push    bx

        ; restore the latches that where saved in the video planes

        mov     ax,0a000h       ; point to the video buffer
        mov     es,ax

        assume  es:nothing

        mov     di,[latchcache] ; the byte just off the end of the buffer
        mov     al,es:[di]      ; read in the latches

        ; Restore the Graphics Controller registers that the
        ; Driver uses

        xor     ax,ax           ; create an index
        xor     bx,bx           ; Index into the G.C. register saving array
        mov     dx,03ceh        ; Graphics Controller index register

norept13:
        mov     ah,[GCregs+bx]  ; restore the register
        out     dx,ax           ; Select it
        inc     al              ; index for the next register
        inc     bx              ; index to next array entry
	cmp	al,9
	jne	norept13

        pop     bx
        pop     di
        pop     es
        ret

restoreVGAregisters     endp

;=======================================================================
;   Procedure to draw a BIOS Mode 4 graphics pointer to the display.
;   Input:    DX = byte offset
;	      CL = bit offset in the byte
;	      CH = 0FFh if ODD, 0 if EVEN
;	      BP = Y loop counter, ODD in LSB, EVEN in MSB
;=======================================================================
drawmode4pointer        proc    near

        pusha
        push    es
        cld

	xchg	dx, bp			;
	mov	di, bp			; bp = di = byte offset, dx = y counters
        mov     ax,0b800h               ; point a segment register to
        mov     es,ax                   ; the CGA video buffer.
	or	ch, ch			;
	je	drawonevenscanline	;
        jmp     drawonoddscanline       ; otherwise do an ODD job

; ANDEVEN ANDEVEN ANDEVEN ANDEVEN ANDEVEN ANDEVEN ANDEVEN ANDEVEN ANDEVEN

drawonevenscanline:

        mov     si,[mode4SelectedPointer]
        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for even scanlines

	xor	cx, cx
	mov	cl, dh			; number of even scanlines to draw
	push	dx
evensl1:
	mov	dx,3
norept14:
        lodsb                           ; load 8 pixels from pointer bitmap
        xor     bh,bh                   ; want a zero extended 16 bit value
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah                   ; little-endianise
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        and     ax,bx                   ; AND the AND mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept14

        add     si,3
        add     di,80-6
        loop    evensl1
	pop	dx

        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for odd scanlines

        mov     si,[mode4SelectedPointer]
        add     si,3
        mov     di,bp
        add     di,02000h               ; offset into video buffer
                                        ; the video buffer
        mov     cl,dl                   ; number of odd scanlines to draw
	push	dx
oddsl1:
	mov	dx,3
norept15:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        and     ax,bx                   ; AND the AND mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept15

        add     si,3
        add     di,80-6
        loop    oddsl1
	pop	dx

; XOREVEN XOREVEN XOREVEN XOREVEN XOREVEN XOREVEN XOREVEN XOREVEN XOREVEN


        mov     si,[mode4SelectedPointer]
        add     si,48

        mov     di,bp                   ; offset into video buffer

        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for even scanlines

        mov     cl,dh                   ; number of even scanlines to draw
	push	dx
evensl2:
	mov	dx,3
norept16:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        xor     ax,bx                   ; XOR the XOR mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept16

        add     si,3
        add     di,80-6
        loop    evensl2
	pop	dx

        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for odd scanlines

        mov     si,[mode4SelectedPointer]
        add     si,48+3
        mov     di,bp
        add     di,02000h               ; offset into video buffer
                                        ; the video buffer
        mov     cl,dl                   ; number of odd scanlines to draw
oddsl2:
	mov	dx,3
norept17:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        xor     ax,bx                   ; XOR the XOR mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept17

        add     si,3
        add     di,80-6
        loop    oddsl2
        pop     es
        popa
        ret


; ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD
;
;       This part of the code draws the pointer on an odd numbered scanline
;       of the video display. Since the video buffer is split, 0000 to 1fff
;       containing even scanlines and 2000 to 3fff containing odd, the data
;       must be manipulated in a subtly different fashion than that of the
;       even display scanline code.
;       The even scanline code display arrangement falls through naturally,
;       with an even scanline drawing thus:
;                                               buffer 0: scanline 0
;                                               buffer 1: scanline 0
;                                               buffer 0: scanline 1
;                                               buffer 1: scanline 1
;                                               buffer 0: scanline 2
;                                               buffer 1: scanline 2 etc.
;       whereas in the odd case:
;                                               buffer 1: scanline 0
;                                               buffer 0: scanline 0
;                                               buffer 1: scanline 1
;                                               buffer 0: scanline 1
;                                               buffer 1: scanline 2
;                                               buffer 0: scanline 2 etc.
;       and this requires that the odd image scanlines must be placed
;       one scanline lower in the even buffer than the even image scanlines
;       do in the odd buffer

drawonoddscanline:


        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for odd scanlines

        mov     si,[mode4SelectedPointer]
        add     di,02000h               ; offset into video buffer
                                        ; the video buffer

        xor     cx,cx
        mov     cl,dl                   ; number of odd scanlines to draw
	push	dx
oddsl3:
	mov	dx,3
norept18:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        and     ax,bx                   ; AND the AND mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept18

        add     si,3
        add     di,80-6
        loop    oddsl3
	pop	dx


        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for even scanlines

        and     dh,dh
        jz      dontdothis1             ; can't do the loop 0 times

        mov     si,[mode4SelectedPointer]
        add     si,3
        mov     di,bp
        add     di,6                    ; This is required to align the
                                        ; even and odd scanlines together
        mov     cl,dh                   ; number of even scanlines to draw
	push	dx
evensl3:
        add     di,80-6                 ; remember even BELOW odd
	mov	dx,3
norept19:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        and     ax,bx                   ; AND the AND mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept19
        add     si,3
        loop    evensl3
	pop	dx

dontdothis1:

; XORODD XORODD XORODD XORODD XORODD XORODD XORODD XORODD XORODD XORODD XORODD


        mov     si,[mode4SelectedPointer]
        add     si,48
        mov     di,bp                   ; offset into video buffer
        add     di,02000h               ; offset into video buffer
                                        ; the video buffer

        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for odd scanlines

        mov     cl,dl                   ; number of odd scanlines to draw
	push	dx
oddsl4:
	mov	dx,3
norept20:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        xor     ax,bx                   ; XOR the XOR mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept20
        add     si,3
        add     di,80-6
        loop    oddsl4
	pop	dx

        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for even scanlines

        and     dh,dh                   ; can't do a loop 0 times
        jz      dontdothis2

        mov     si,[mode4SelectedPointer]
        add     si,48+3
        mov     di,bp
        add     di,6

        mov     cl,dh                   ; number of even scanlines to draw
	
evensl4:
        add     di,80-6
	mov	dx,3
norept21:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        xor     ax,bx                   ; XOR the XOR mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept21

        add     si,3
        loop    evensl4

dontdothis2:

; XORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXOR

        pop     es
        popa
        ret
drawmode4pointer        endp

;========================================================================
; Procedure to determine what the byte and bit offset is, in the current
; VGA buffer for the top left hand corner of the pointer bitmap.
; The X,Y value is modified for hotspot in this routine.
; Y looping counter(ODD and EVEN) are also returned
; The CGA buffer is interleaved, and runs from B800:0000 to B800:1999 for
; odd scanlines and from B800:2000 for even scanlines.
;
; INPUT: CX,DX = pointer x,y coordinates
; OUT  :
;	 carry set if either X or Y is out of screen
;	 DX	= byte offset to top left hand pointer pixel of the pointer
;	 CL	= bit offset in the byte
;	 CH	= 0FFh if ODD, 0 if EVEN
;	 BP	= Y loop counter(ODD in LSB and EVEN in MSB)
;========================================================================

detboundmode4   proc    near

	push	ax
        push    bx
        push    ds

        mov     ax,cs
        mov     ds,ax

        assume  ds:SpcMseSeg


        ; do the adjustment in x,y for pointer hotspot
        ; modify the raw X,Y values for hotspot

        sub     cx,[hotspot]    ; adjust the x cartesian coord for hotspot
        jns     dont_zero_xmode4; if x goes negative, assume zero
        xor     cx,cx

dont_zero_xmode4:

        sub     dx,[hotspot+2]  ; adjust the y cartesian coord for the hotspot
        jns     dont_zero_ymode4; if y goes negative, assume zero
        xor     dx,dx

dont_zero_ymode4:

	cmp	cx, 320 		;
	jae	detboundmode4_exit	; CY is cleared
	cmp	dx, 200
	jae	detboundmode4_exit	; CY is cleared
        ; determine the byte offset from the start of the video buffer
        ; for the modified coordinates. First calculate how many bytes
        ; there are for the number of scanlines -1 to where the pointer
        ; is. Also if the pointer starts on a odd scanline, set CF, else
        ; clear CF.

        mov     ax,dx           ; copy Y position into AX
        mov     bp,dx           ; copy Y position into BP for use later

        ; CGA video buffer is split in two. Therefore, screen scanline 0 maps
        ; to video buffer scanline 0 and screen scanline 1 maps to video
        ; buffer+2000h, scanline 0

        and     ax,0fffeh       ; do the mapping 0->0, 1->0, 2->1, 3->1 etc.
                                ; and create a word table index
	mov	bx, ax		; copy table index into a base register
				; 2bits/pixel -> 4 pixels/byte
				; sine x total is 320, we have 80bytes
				; so a shl bx, 1 will be wrong.
	mov     dx,[mult80lut+bx]       ; do a fast LUT multiply by 80

        ; determine the byte position of the pixel in question

        mov     ax,cx           ; save the x-coordinate displacement
        and     ax,3            ; do a modulus 4 to find the pixel position
                                ; in the byte. The byte number will be in DX.

        ; add the whole number of bytes in the current row to the number
        ; of complete-row bytes. Note that mode 4 is 2bits per pixel, so
        ; there are four pixels represented by one byte.

        mov     bx,cx           ; Save in a base reg. to create a table index
        shl     bx,1            ; Create a table index for word sized entries
        add     dx,[mode4clipCXadjustLUT+bx]; DX hold the complete byte offset.
	mov	cx, ax		; CX = bit offset in the byte.

	mov	ax, [mode4pointerLUT + bx]  ; select appropriate pointer
	mov	[mode4SelectedPointer], ax

        ; Odd or Even scanline? note BP contains y cartesian coordinate

	mov	bx, bp		; y coordinate
	shr	bp, 1		; shift right to determine if odd or even
				; CF if odd, or 0 if even.
	sbb	ch, ch		; CH = 0FFh if ODD, 0 if EVEN
	shl	bx, 1
	mov	bp, [mode4clipDXLUT + bx] ;the Y counters
	stc			; we are fine, set the CY so we will return
				; CY cleared.
detboundmode4_exit:
	cmc				; revese the CY
        pop     ds
        pop     bx
	pop	ax
        ret

detboundmode4   endp



;=============================================================================
;   Procedure to save the area of CGA video buffer into which the pointer will
;   be drawn. The memory buffer in which this data is stored is arranged odd
;   scanlines first, then even. So, the first 48 bytes are the odd scanline
;   data.
;
;   Input:    DX = byte offset
;	      CL = bit offset in the byte
;	      CH = 0FFh if ODD, 0 if EVEN
;	      BP = Y loop counter, ODD in LSB, EVEN in MSB
;
;=============================================================================

savebkgrndmode4 proc    near

        pusha
        push    es
        push    ds

        ; set up the segment registers as required

        mov     ax,ds
        mov     es,ax
        mov     ax,0b800h
        mov     ds,ax
        assume  ds:nothing, es:SpcMseSeg
        mov     si,dx                   ; start the save.
	or	ch, ch
	je	svbkeven		 ; check the returned carry flag

        ; the image's first scanline is odd

        mov     di,offset CGAbackgrnd   ; where the background will be saved
        mov     bx,bp                   ; set the loop counter up
        xor     bh,bh                   ; don't want unwanted mess in MSB
        add     si,2000h                ; odd part of buffer starts at 2000h
svodd1:
        mov     cx,3                    ; copy six bytes
        rep     movsw                   ; do the image scanline save
        add     si,80-6                 ; point to the next scanline
        dec     bx                      ; decrement the loop counter
        jnz     svodd1                  ; do more scanlines if necessary

        ; save some even scanlines if need be.

        mov     si,dx                   ; offset into CGA buffer
	add	si, 80
        mov     bx,bp                   ; set up the loop counter
        xchg    bl,bh                   ; get the even part of loop counter
        xor     bh,bh                   ; trash the top end trash
        and     bx,bx                   ; check for a zero loop
        jz      misseven                ; can't have a loop which execs 0 times
        mov     di,offset CGAbackgrnd+48; where the background will be saved
sveven1:
        mov     cx,3                    ; copy six bytes = 24 pixels
        rep     movsw                   ; do the scanline save
        add     si,80-6                 ; point to the next scanline
        dec     bx                      ; decrement the loop counter
        jnz     sveven1                 ; do more scanlines if necessary

misseven:       ; jump to here if there are no even scanlines to draw

        jmp     short endsavemode4

svbkeven: ; the image's first scanline is even

        mov     di,offset CGAbackgrnd+48; where the background will be saved

        mov     bx,bp                   ; get the loop counter
        xchg    bl,bh                   ; rearrage to get the even part
        xor     bh,bh                   ; clear out the trash
sveven2:
        mov     cx,3                    ; copy six bytes
        rep     movsw                   ; do the copy
        add     si,80-6                 ; point to the next scanline
        dec     bx                      ; decrement the loop counter
        jnz     sveven2                 ; do more scanlines if necessary

        mov     si,dx                   ; offset into CGA buffer
        add     si,2000h                ; odd part of the video buffer
        mov     di,offset CGAbackgrnd   ; where to save the odd scanlines
        mov     bx,bp                   ; get the loop counter
        xor     bh,bh                   ; clear out the unwanted trash
svodd2:
        mov     cx,3                    ; copy six bytes
        rep     movsw                   ; do the copy
        add     si,80-6                 ; point to the next scanline
        dec     bx                      ; decrement the loop counter
        jnz     svodd2                  ; do more scanlines if necessary

endsavemode4:
        assume  ds:SpcMseSeg, es:nothing

        pop     ds
        pop     es
        popa
        ret
savebkgrndmode4 endp

;=============================================================================
;   Procedure to restore the area of CGA video buffer into which the pointer
;   was drawn. The memory buffer in which this data is stored is arranged
;   odd scanlines first, then even. So, the first 48 bytes are the odd scanline
;   data.
;
;   Input:
;	 DX	= byte offset to top left hand pointer pixel of the pointer
;	 CL	= bit offset in the byte
;	 CH	= 0FFh if ODD, 0 if EVEN
;	 BP	= Y loop counter(ODD in LSB and EVEN in MSB)
;
;=============================================================================

restorebkgrndmode4      proc    near

        pusha
        push    es

        ; set up the segment registers as required

        mov     ax,0b800h
        mov     es,ax
        mov     di,dx                   ; restore background
	or	ch, ch
	je	rsbkeven		 ; check the returned carry flag

        ; the image's first scanline is odd. The CGA buffer is translated
        ; so that a scanline (row N) from the even part of the buffer appears
        ; on the screen at raster I. The scanline at position N from the
        ; odd part of the video buffer maps to screen position I+1. If the
        ; 1st. scanline is odd, then this is drawn at raster A and the
        ; following algorithm draws the 1st. even row at raster A+1 to
        ; compensate for the video buffer arrangement.

        mov     si,offset CGAbackgrnd   ; where the background is be saved
        add     di,2000h                ; do the odd buffer

        mov     bx,bp                   ; set the loop counter up
        xor     bh,bh                   ; clear out the MSB trash
rsodd1:
        mov     cx,3                    ; copy six bytes
        rep     movsw                   ; do the restore
        add     di,80-6                 ; point to the next odd scanline
        dec     bx                      ; decrement the loop counter
        jnz     rsodd1                  ; restore more even scanlines if needed

        mov     bx,bp                   ; let the loop counter
        xchg    bl,bh                   ; get the even part
        xor     bh,bh                   ; clear out the MSB trash
        and     bx,bx                   ; test for zero even scanlines
        jz      misseven1rs             ; can't have a zero execute loop
        mov     di,dx                   ; offset into CGA buffer
        add     di,80                   ; get the odd/even scanlines instep
        mov     si,offset CGAbackgrnd+48; where the background is be saved
rseven1:
        mov     cx,3                    ; restore six bytes
        rep     movsw                   ; do the restore
        add     di,80-6                 ; point to the next even scanline
        dec     bx                      ; decrement the loop counter
        jnz     rseven1                 ; restore more even scanlines if needed

misseven1rs:    ; jump to here if there are no even scanlines to be restored.

        jmp     short endrestoremode4

rsbkeven: ; the image's first scanline is even

        mov     si,offset CGAbackgrnd+48; where the background will be saved

        mov     bx,bp                   ; get the loop counter
        xchg    bl,bh                   ; get the even part of the loop counter
        xor     bh,bh                   ; scrap the MSB trash
rseven2:
        mov     cx,3                    ; restore six bytes
        rep     movsw                   ; do the restore
        add     di,80-6                 ; point to the next even scanline
        dec     bx                      ; decrement the loop counter
        jnz     rseven2                 ; do more even scanlines if needed

        mov     di,dx                   ; offset into CGA buffer
        add     di,2000h                ; do the odd buffer
        mov     si,offset CGAbackgrnd   ; where to save the odd scanlines

        mov     bx,bp                   ; set the loop counter up
        xor     bh,bh                   ; scrap the MSB trash
rsodd2:
        mov     cx,3                    ; restore six bytes
        rep     movsw                   ; do the restore
        add     di,80-6                 ; point to the next  odd scanline
        dec     bx                      ; decrement the loop counter
        jnz     rsodd2                  ; restore more odd scanlines if needed

endrestoremode4:
        assume  ds:SpcMseSeg, es:nothing

        pop     es
        popa
        ret
restorebkgrndmode4      endp

;============================================================================
;   Procedure to draw the pointer image into the video buffer for mode 13h
;   VGA graphics.
;
;   Input:
;	   DX = byte offset
;	   BP = Y loop counter
;	   CX = X loop counter
;
;============================================================================

draw256pointer  proc    near
        pusha
        push    es
        push    ds

        mov     ax,0a000h       ; point to the 256 colour mode video buffer
        mov     es,ax
        mov     ax,cs
        mov     ds,ax

        assume  ds:SpcMseSeg, es:nothing

        cld                     ; write forward through the buffer
	; DX = TLHC pixel offset in the video buffer.
        mov     di,dx           ; point DI at the video buffer location of fun
	mov	si, offset current_cursor   ; we only use this cursor shape
					    ; because every pixel is on byte
					    ; boundary. The X counter would
					    ; take care of X clipping
y_256:
	push	cx
	lodsw			    ;and mask
	mov	dx, [si + 48 - 2]   ;xor mask
	inc	si		    ;we don't need the third byte
	xchg	al, ah		    ; byte sequence
	xchg	dh, dl		    ;
x_256:
	shl	ax, 1		    ;AND mask bit
	sbb	bl, bl		    ; bl = 0FFf if CY, 0 if not CY
	and	bl, es:[di]	    ;and the target and save the result
	shl	dx, 1		    ;XOR mask bit
	sbb	bh, bh		    ;
	xor	bl, bh		    ;xor with the save result
	mov	es:[di], bl	    ;update the target
	inc	di		    ;next pixel
	loop	x_256		    ;until this scan line is done
	pop	cx		    ;recovery X loop counter
	add	di, 320 	    ;target address to next scan line
	sub	di, cx
	dec	bp		    ;Y counter
	jne	y_256

        pop     ds
        pop     es
        popa
        ret
draw256pointer  endp

;=============================================================================
;   Procedure to save the area of 256 colour mode video buffer into which the
;   pointer will be drawn. The memory buffer in which this data is stored is
;   arranged odd scanlines first, then even. So, the first 48 bytes are the odd
;   scanline data.
;
;   Input:
;	    DX = byte offset
;	    BP = Y loop counter
;	    CX = X loop counter
;
;=============================================================================

savebkgrndmode13        proc    near
        pusha
        push    es
        push    ds

        mov     di,offset bkgrnd256     ; point to the area in which backgound
                                        ; data will be saved
        mov     si,dx           ; SOURCE: the video buffer at x,y

        mov     ax,0a000h
        mov     ds,ax
        mov     ax,cs
        mov     es,ax
	mov	bx, cx			;x counter
	mov	dx, 320
	sub	dx, bx
        assume  ds:nothing, es:SpcMseSeg
	cld
save_256_loop:
	mov	cx, bx
	shr	cx, 1
	rep	movsw
	adc	cl, 0
	rep	movsb
	add	si, dx			; next scan line offset
	dec	bp			; until Y counter is done
	jne	save_256_loop

        pop     ds
        pop     es

        assume  es:nothing, ds:SpcMseSeg

        popa
        ret
savebkgrndmode13        endp

;=============================================================================
;   Procedure to replace an existing pointer image in the 256 colour video
;   buffer with the data that was there previous to the pointer draw operation.
;   The data is stored in an internal (to the driver) buffer.
;
;   Input:
;	 DX = byte offset
;	 BP = Y loop counter
;	 CX = X loop counter
;
;=============================================================================

restorebkgrndmode13     proc    near
        pusha
        push    es

        mov     di,dx           ; DESTINATION: in the VRAM
        mov     ax,0a000h       ; point a segment register at video buffer
        mov     es,ax

        assume  es:nothing
	mov	bx, cx
        mov     si,offset bkgrnd256     ; where the data is saved
	mov	dx, 320
	sub	dx, bx

        cld                     ; write forward in memory
restore_256_loop:
	mov	cx, bx
	shr	cx, 1
	rep	movsw
	adc	cl, 0
	rep	movsb
	add	di, dx
	dec	bp
	jne	restore_256_loop

        pop     es
        popa
        ret
restorebkgrndmode13     endp

;========================================================================
; Procedure to determine what the byte offset is, in the current
; VGA buffer for the top left hand corner of the pointer bitmap.
; The X,Y value is modified for hotspot in this routine. X and Y looping
; counters are also returned.
;
; INPUT: CX,DX = pointer x,y coordinates
; OUT  :
;	carry set if either X or Y is out of screen
;	DX	= byte offset to top left hand pointer pixel of the pointer
;	CX	= X counter
;	BP	= Y counter
;========================================================================

detboundmode13  proc    near

        push    ax
        push    bx
        push    ds

        mov     ax,cs
        mov     ds,ax

        assume  ds:SpcMseSeg


        ; do the adjustment in x,y for pointer hotspot
        ; modify the raw X,Y values for hotspot

        sub     cx,[hotspot]    ; adjust the x cartesian coord for hotspot
        jns     dont_zero_xmode13; if x goes negative, assume zero
        xor     cx,cx

dont_zero_xmode13:

        sub     dx,[hotspot+2]  ; adjust the y cartesian coord for the hotspot
        jns     dont_zero_ymode13; if y goes negative, assume zero
        xor     dx,dx

dont_zero_ymode13:
	cmp	cx, 320
	jae	detboundmode13_exit ; CY is cleared
	cmp	dx, 200 	    ;
	jae	detboundmode13_exit ; CY is cleared

        ; CX and DX are now validated for the following section: buffer
        ; offset determination. Note, unlike other video modes, mode 13
        ; provides a direct mapping of the video display to video buffer.
        ; in other words; 1 byte represents 1 pixel. From this, it is not
        ; necessary to provide byte alignment data.

        mov     bx,dx                   ; save in a base register
	shl	bx,1			; create a word table index
        mov     dx,[mult320LUT+bx]      ; do the multiply by 320
        ; add in the offset along the current raster.

        add     dx,cx                   ; cx contains the byte offset from
	mov	ax,[mode4clipDXLUT + bx]; get Y loop counter from table
	add	al, ah			; the table has ODD/EVEN counters
	cbw
	mov	bp, ax			; the final Y counter
					; column 0.
	mov	ax, 320 		; calculate X loop counter
	sub	ax, cx
	cmp	ax, 16			;
	jl	set_new_x_counter
	mov	ax, 16
set_new_x_counter:
	mov	cx, ax			; X counter
	stc				; everything is fine, set CY
					; so we will return CY cleared
detboundmode13_exit:
	cmc				; complement the CY
        pop     ds
        pop     bx
        pop     ax
        ret

detboundmode13  endp


          public SpcMseEnd
SpcMseEnd label  byte

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;   Installation Code From Here Downwards
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; segment:offset table for redirected mouse functions for real rom version.

mio_table       dw      38 dup(?)



        assume  cs:SpcMseSeg,ds:nothing,es:nothing

        public InstSpcMse
;
; InstSpcMse - Installs the softpc mouse driver code
;
; Inputs:  ds == Resident location of SpcMseSeg
; Outputs: None
;
InstSpcMse   proc    near

        ;;;;;;;;;;;;;;;;do ret to use old mouse driver;;; ret

        pusha

        ; save old int 10 vector
        xor     ax,ax
        mov     es,ax
        mov     ax,es:[40h]
        mov     si,offset old_vid_int
        mov     word ptr ds:[si],ax
        mov     ax,es:[42h]
        mov     word ptr ds:[si+2],ax

        mov     bx,ds
        mov     si,offset sysinitgrp:mio_table
        push    ds
        push    cs
        pop     ds

        mov     word ptr ds:[si], offset mouse_io
        mov     word ptr ds:[si+2],bx

IFDEF MOUSE_VIDEO_BIOS

        mov     word ptr ds:[si+4],offset mouse_video_io
        mov     word ptr ds:[si+6],bx

ENDIF ; MOUSE_VIDEO_BIOS

        mov     word ptr ds:[si+8],offset mouse_int1
        mov     word ptr ds:[si+10],bx
        mov     word ptr ds:[si+12], offset mouse_version
        mov     word ptr ds:[si+14],bx
        mov     word ptr ds:[si+16],offset mouse_copyright
        mov     word ptr ds:[si+18],bx
        mov     word ptr ds:[si+20],offset video_io
        mov     word ptr ds:[si+22],bx
        mov     word ptr ds:[si+24],offset mouse_int2
        mov     word ptr ds:[si+26],bx
        mov     word ptr ds:[si+28],offset entry_point_from_32bit
        mov     word ptr ds:[si+30],bx
        mov     word ptr ds:[si+32],offset int33function0
        mov     word ptr ds:[si+34],bx
        mov     word ptr ds:[si+36],offset int33function1
        mov     word ptr ds:[si+38],bx
        mov     word ptr ds:[si+40],offset int33function2
        mov     word ptr ds:[si+42],bx
        mov     word ptr ds:[si+44],offset int33function9
        mov     word ptr ds:[si+46],bx
        mov     word ptr ds:[si+48],offset current_position_x
        mov     word ptr ds:[si+50],bx
        mov     word ptr ds:[si+52],offset current_position_y
        mov     word ptr ds:[si+54],bx
        mov     word ptr ds:[si+56],offset mouseINB
        mov     word ptr ds:[si+58],bx
        mov     word ptr ds:[si+60],offset mouseOUTB
        mov     word ptr ds:[si+62],bx
        mov     word ptr ds:[si+64],offset mouseOUTW
        mov     word ptr ds:[si+66],bx
        mov     word ptr ds:[si+68],offset VRAMlasttextcelloff
        mov     word ptr ds:[si+70],bx
        mov     word ptr ds:[si+72],offset internalCF
        mov     word ptr ds:[si+74],bx
        mov     word ptr ds:[si+76],offset function3data
        mov     word ptr ds:[si+78],bx
	mov	word ptr ds:[si+80],offset conditional_off
	mov	word ptr ds:[si+82],bx
        pop     ds
        mov     bx, offset sysinitgrp:mio_table
        bop     0C8h            ; Host mouse installer BOP

; get the freshly written int 33h vector from IVT
; write the vector segment:offset data to the jump patch

        xor     ax,ax
        mov     es,ax
        mov     ax,es:[33h*4]
        mov     bx,es:[(33h*4)+2]
        mov     si,offset moff
        mov     word ptr ds:[si],ax
        mov     word ptr ds:[si+2],bx
        add     ax,2                          ; HLL entry point
        mov     si,offset loffset
        mov     word ptr ds:[si],ax
        mov     word ptr ds:[si+2],bx

; write the new value to the IVT
        call    DOCLI
        mov     bx, offset int33h_vector
        mov     word ptr es:[33h*4], bx
        mov     bx, ds
        mov     word ptr es:[(33h*4)+2], bx
        call    DOSTI

        popa
        ret
InstSpcMse  endp

SpcMseSeg    ends
             end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\bios\sysinit1.asm ===
page	,160
	title	bios	system initialization
;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------

break	macro	; dummy empty macro
	endm
	include version.inc
	include biosseg.inc
	include sysvar.inc
	include curdir.inc
	include pdb.inc
	include exe.inc
	include sf.inc
	include arena.inc
	include syscall.inc
	include devsym.inc
	include ioctl.inc
	include biostruc.inc
	include dossym.inc
	include	dosmac.inc
	include	mult.inc
        include dossvc.inc
        include dbgsvc.inc
        include cmdsvc.inc
        include xmssvc.inc
        include vint.inc

Bios_Code	segment
	extrn	BCode_start:near
	extrn	BCode_end:near
	extrn	seg_reinit:far

Bios_Code	ends

	include devmark.inc
	include cputype.inc


true	equ	0ffffh
false	equ	0
cr	equ	13
lf	equ	10
tab	equ	9

;multMULT		equ	4ah
multMULTGETHMAPTR	equ	1
multMULTALLOCHMA	equ	2


stacksw equ     true                    ;include switchable hardware stacks
mycds_size equ	71			; size of curdir_list. if it is not
					;the same, then will generate compile error.

if DEBUG				; BUGBUG - Jeez, remove this!
  dossize equ	0b200h
else
  dossize equ	0a000h
endif

	if	ibmjapver
noexec	equ	   true
	else
noexec	equ	   false
	endif

;     if mycds_size <> curdirlen,then force a compilatiaon error.

	if	mycds_size ne curdirlen
	%out	!!! sysinit1 compilation failed. different cds size !!!
	.errne	mycds_size eq curdirlen
	endif

	if	not ibmjapver
	extrn	 re_init:far
	endif

	ifdef	TAIWAN
	extrn	cdosinit:near
	endif

;---------------------------------------

Bios_Data	segment

;equates for main stack and stack initialization program

	if	stacksw

	extrn	NextStack:dword		; Win386 Instance table stuff
	extrn	IT_StackLoc:dword	;  we have to plug in so that our
	extrn	IT_StackSize:word	;  stacks can be instanced

entrysize   equ     8

mincount    equ     8
defaultcount equ    9
maxcount    equ     64

minsize     equ     32
defaultsize equ     128
maxsize     equ     512

allocbyte   equ     0
intlevel    equ     1
savedsp     equ     2
savedss     equ     4
newsp	    equ     6

free	    equ     0
allocated   equ     1
overflowed  equ     2
clobbered   equ     3






;	 external variables in ibmbio for int19h handling rouitne.

	extrn	 int19sem:byte

	irp	   aa,<02,08,09,0a,0b,0c,0d,0e,70,72,73,74,76,77>
	extrn	 int19old&aa:dword
	endm
	endif


;---------------------------------------
; external variable defined in ibmbio module for multi-track
multrk_on equ	10000000b		;user spcified mutitrack=on,or system turns
					; it on after handling config.sys file as a
					; default value,if multrk_flag = multrk_off1.
multrk_off1 equ 00000000b		;initial value. no "multitrack=" command entered.
multrk_off2 equ 00000001b		;user specified multitrack=off.

	extrn	multrk_flag:word
;
;SR; Win386 present flag
;
	extrn	IsWin386:BYTE
;
;SR; Added for SetFocus routine for WIN386 support
;
         extrn	V86_Crit_SetFocus:far

	extrn	xms:dword		; entry point for xms driver
	extrn	inHMA:byte		; flag meaning we're running high

	extrn	FreeHMAPtr:word
	extrn	MoveDOSIntoHMA:dword
	extrn	SysinitPresent:byte
        extrn   DemInfoFlag:byte
	extrn	spc_mse_int10:dword
	extrn	int29Perf:dword

	extrn	outchr:near
Bios_Data       ends

; NTVDM 16-Sep-1992 Jonle
; Softpc Kbd, mouse, emm drivers
SpcKbdSeg  segment
        extrn   InstSpcKbd:near
        extrn   SpcKbdBeg:byte
        extrn   SpcKbdEnd:byte
	extrn	int10h_vector:near
SpcKbdSeg  ends

SpcMseSeg  segment
        extrn   InstSpcMse:near
        extrn   SpcMseBeg:byte
        extrn   SpcMseEnd:byte
SpcMseSeg  ends

SpcEmmSeg  segment
        extrn   InitSpcEmm:near
        extrn   SpcEmmBeg:byte
        extrn   SpcEmmEnd:byte
	extrn	SI_end:byte
SpcEmmSeg  ends




sysinitseg segment
        assume  cs:sysinitseg, ds:nothing,es:nothing,ss:nothing

	extrn	badcom:byte
        extrn   condev:byte
	extrn	auxdev:byte
        extrn   prndev:byte
        extrn   commnd:byte
	extrn	devmark_addr:word
	extrn	setdevmarkflag:byte
	extrn	pathstring:byte

	extrn	print:near
	extrn	int24:near
	extrn	mem_err:near
	extrn	doconf:near
        extrn   multi_pass:near

	extrn	badload:near
	extrn	error_line:near

	extrn	ShrinkUMB:near
	extrn	UnlinkUMB:near					;M002
	extrn	AllocUMB:near
        extrn   toomanydrivesmsg:byte                           ; M029


        ;NTVDM
        extrn   MseDev:byte              ; internal mouse driver name
        extrn   AllocUMBLow:near         ; mem alloc for new internal drivers
        extrn   bEchoConfig:byte
        extrn   config:byte

        public  current_dos_location
	public	device_list
	public	sysi_country
	public	memory_size
	public	default_drive
	public	buffers
	public	files
	public	num_cds
	public	sysinit
	public	cntryfilehandle
	public	command_line

	if	stacksw 		; internal stack information
	public	stack_count
	public	stack_size
	public	stack_addr
	endif

	public	dosinfo
	public	fcbs
	public	keep
	public	confbot
	public	alloclim
	public	zero
	public	sepchr
	public	count
	public	chrptr
	public	org_count
	public	bufptr
	public	memlo
	public	prmblk
	public	memhi
	public	ldoff
	public	area
	public	packet
	public	unitcount
	public	break_addr
        public  bpb_addr
	public	drivenumber
	public	config_size
	public	install_flag
	public	com_level
	public	cmmt
	public	cmmt1
	public	cmmt2
	public	cmd_indicator
	public	linecount
	public	showcount
	public	buffer_linenum
	public	donotshownum
	public	h_buffers
	public	configmsgflag
	public	do_install_exec
	public	multi_pass_id
	public	temp_bcode_seg
	public	seg_reinit_ptr

        public toomanydrivesflag			; M029

sysinit$:
	if	stacksw
.sall

;	interrupt level 2, 3, 4, 5, 6, 7,(10, 11, 12, 14, 15 - at level)
;	should follow the standard interrupt sharing scheme which has
;	a standard header structure.
;	fyi, the following shows the relations between
;	the interrupt vector and interrupt level.
; vec(hex)    2  8  9  a  b  c	d  e  70  72  73  74  76  77
; lvl(deci)   9  0  1  2  3  4	5  6   8  10  11  12  14  15
;	msstack module modifies the following interrupt vectors
;	to meet the standard interrupt sharing standard;
;	  a, b, c, d, e, 72, 73, 74, 76, 77.
;	also, for interrupt level 7 and 15, the firstflag in a standard header
;	should be initialized to indicat whether this interrupt handler is
;	the first (= 80h) or not.  the firstflag entry of int77h's
;	program header is initialized in this module.
;	firstflag is only meaningful for interrupt level 7 and 15.
;

;  user specifies the number of stack elements - default = 9
;						 minimum = 8
;						 maximum = 64
;
;  intercepts asynchronous hardware interrupts only
;
;  picks a stack from pool of stacks and switches to it
;
;  calls the previously saved interrupt vector after pushing flags
;
;  on return, returns the stack to the stack pool
;


; this is a modification of stacks:
; 1. to fix a bug which was causing the program to take up too much space.
; 2. to dispense stack space from hi-mem first rather than low-mem first.
;    . clobbers the stack that got too big instead of innocent stack
;    . allows system to work if the only stack that got too big was the most
;      deeply nested one
; 3. disables nmi interrupts while setting the nmi vector.
; 4. double checks that a nested interrupt didn't get the same stack.
; 5. intercepts ints 70, 72-77 for pc-ats and other future products

		even
		dw	0	; spare field but leave these in order
stackcount	dw	0
stackat 	dw	0
stacksize	dw	0
stacks		dw	0
		dw	0

firstentry	dw	stacks
lastentry	dw	stacks+(defaultcount*entrysize)-entrysize
nextentry	dw	stacks+(defaultcount*entrysize)-entrysize


; these are the individual interrupt handlers

	assume	ds:nothing,es:nothing,ss:nothing

public	int02
public	old02
	old02	dd	0
int02	proc	far

;; NTVDM support for pc convertable is NOT NEEDED 10-Aug-1992 Jonle
;;
;; *********************************************************************
;;
;; this is special support for the pc convertible / nmi handler
;;
;;       on the pc convertible, there is a situation where an nmi can be
;;       caused by using the "out" instructions to certain ports.  when this
;;       occurs, the pc convertible hardware *guarantees* that **nothing**
;;       can stop the nmi or interfere with getting to the nmi handler.  this
;;       includes other type of interrupts (hardware and software), and
;;       also includes other type of nmi's.  when any nmi has occured,
;;       no other interrtupt (hardware, software or nmi) can occur until
;;       the software takes specific steps to allow further interrupting.
;;
;;       for pc convertible, the situation where the nmi is generated by the
;;       "out" to a control port requires "fixing-up" and re-attempting.  in
;;       otherwords, it is actually a "restartable exception".  in this
;;       case, the software handler must be able to get to the stack in
;;       order to figure out what instruction caused the problem, where
;;       it was "out"ing to and what value it was "out"ing.  therefore,
;;       we will not switch stacks in this situation.  this situation is
;;       detected by interrogating port 62h, and checking for a bit value
;;       of 80h.  if set, *****do not switch stacks*****.
;;
;; *********************************************************************
;
;        push    ax
;        push    es
;        mov     ax,0f000h
;        mov     es,ax
;        cmp     byte ptr es:[0fffeh],mdl_convert        ;check if convertible
;        pop     es
;        jne     normal02
;
;        in      al,62h
;        test    al,80h
;        jz      normal02
;
;special02:
;        pop     ax
;        jmp     dword ptr old02
;
;normal02:
;        pop     ax
;

        call    do_int_stacks
        dw      old02

int02	endp

public	int08
public	old08
old08	dd	0
int08	proc	far
	call	do_int_stacks
	dw	old08
int08	endp

public	int09
public	old09
old09	dd	0
int09	proc	far

; keyboard interrupt must have a three byte jump, a nop and a zero byte
; as its first instruction for compatibility reasons

	ifidn	<09>,<09>
	jmp	short keyboard_lbl
	nop
	db	0
keyboard_lbl	label	near
	endif

	call	do_int_stacks
	dw	old09
int09	endp

public	int70
public	old70
old70	dd	0
int70	proc	far
	call	do_int_stacks
	dw	old70
int70	endp

	irp	a,<0a,0b,0c,0d,0e,72,73,74,76,77>
public	int&a
public	old&a
public	firstflag&a
int&a	proc	far
	jmp	short entry_int&a&_stk
old&a	dd	  0		;forward pointer
	dw	  424bh 	;compatible signature for int. sharing
firstflag&a db   0		;the firstly hooked.
	jmp	short intret_&a	;reset routine. we don't care this.
	db	7 dup (0)	;reserved for future.
entry_int&a&_stk:
	call	do_int_stacks
	dw	old&a
intret_&a:
        jmp     DOIRET
int&a	endp
        endm


DOCLI:
    FCLI
    ret
DOSTI:
    FSTI
    ret
DOIRET:
    FIRET


;********************************************************************
;common routines

;	do interrupt stack switching.  the fake return address holds
;	  a pointer to the far-pointer of the actual interrupt
;	  service routine

do_int_stacks:
	push	ax
	push	bp
	push	es
	mov	es, cs:[stacks+2]	; get segment of stacks

	mov	bp,nextentry		; get most likely candidate
	mov	al,allocated
	xchg	es:byte ptr allocbyte[bp],al		; grab the entry
	cmp	al,free 		; still avail?
	jne	notfree02

	sub	nextentry,entrysize	; set for next interrupt

found02:
	mov	es:word ptr savedsp[bp],sp		; save sp value
	mov	es:word ptr savedss[bp],ss		; save ss also

	mov	ax,bp			; temp save of table offset


	mov	bp,es:word ptr newsp[bp]		; get new sp value
	cmp	es:[bp],ax		; check for offset into table
	jne	foundbad02

	push	bp
	mov	bp,sp
	mov	ax,8[bp]		; get offset of interrupt vector
	pop	bp

	push	es			; ss:sp = new stack
	pop	ss
	mov	sp,bp

	mov	bp,ax			; get pointer to interrupt vector
	mov	bp,cs:[bp]
	pushf				; go execute the real interrupt handler
	call	cs:dword ptr [bp]	; call the old interrupt vector

	mov	bp,sp			; retrieve the table offset for us
	mov	bp,es:[bp]		;  but leave it on the stack
	mov	ss,es:word ptr savedss[bp]		; get old stack back
	mov	sp,es:word ptr savedsp[bp]


	mov	es:byte ptr allocbyte[bp],free		; free the entry
	mov	nextentry,bp		; setup to use next time

newerror02:
	pop	es
	pop	bp			; saved on entry
	pop	ax			; saved on entry
	add	sp,2			; lose the fake return address

intret_02:
        jmp     DOIRET                  ; done with this interrupt

notfree02:
	cmp	al,allocated		; error flag
	je	findnext02		;  no, continue
	xchg	es:byte ptr allocbyte[bp],al		;  yes, restore error value

findnext02:
	call	longpath
	jmp	found02

foundbad02:
	cmp	bp,firstentry
	jc	findnext02
	mov	bp,ax			; flag this entry
	mov	es:byte ptr allocbyte[bp],clobbered
	jmp	findnext02		; keep looking
longpath:
	mov	bp,lastentry		; start with last entry in table

lploopp:
	cmp	es:byte ptr allocbyte[bp],free		; is entry free?
	jne	inuse			;  no, try next one

	mov	al,allocated
	xchg	es:byte ptr allocbyte[bp],al		; allocate entry
	cmp	al,free 		; is it still free?
	je	found			;  yes, go use it

	cmp	al,allocated		; is it other than allocated or free?
	je	inuse			;  no, check the next one

	mov	es:byte ptr allocbyte[bp],al		;  yes, put back the error state

inuse:
	cmp	bp,firstentry
	je	fatal
	sub	bp,entrysize
	jmp	lploopp

found:
	ret

fatal   proc    near

; NTVDM support for pc convertable is NOT NEEDED 10-Aug-1992 Jonle
;
;        push    ds
;        mov     ax, 0f000h              ;look at the model byte
;        mov     ds, ax
;        cmp     ds:byte ptr [0fffeh], mdl_convert ;convertible?
;        pop     ds
;        jne     skip_nmis
;
;        mov     al,07h                          ; disable pc convertible nmis
;        out     72h,al
;
;skip_nmis:

        call    DOCLI                           ; disable and mask
	mov	al,0ffh 			;   all other ints
	out	021h,al
	out	0a1h,al

	mov	si,cs
	mov	ds,si
	mov	si,offset fatal_msg

;SR;
;   We set all foci to this VM to issue the stack failure message
;
	push	ax
	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume 	ds:Bios_Data

	test	ds:[IsWin386],1
	pop	ds
	pop	ax
	assume	ds:nothing
	jz	fatal_loop	;win386 not present, continue

	call	V86_Crit_SetFocus	;set focus to this VM
;
;SR; We do not bother about the returned status of this call.
;

fatal_loop:
	lodsb
	cmp	al,'$'
	je	fatal_done

	mov	bl,7
	mov	ah,14
	int	010h			; whoops, this enables ints
	jmp	fatal_loop

fatal_done:
	jmp	fatal_done
fatal	endp

	include msbio.cl5		;fatal stack error message
.xall
	public	endstackcode
endstackcode label  byte
	endif

sysinit:
	jmp	goinit
;
;----------------------------------------------------------------------------
;
DDHighInfo	struc
 ddhigh_CSegPtr	dd	?		; pointer to code segment to be relocated
 ddhigh_CSegLen	dw	?		; length of code segment to be relocated
 ddhigh_CallBak	dd	?		; pointer to the call back routine
DDHighInfo	ends

		public	runhigh
runhigh		db	0h


dosinfo	dd	0		; address of the DOS Sysini Variables

dos_temp_location label	dword
dosinit	dw	0
current_dos_location dw 0

device_list dd	0

sysi_country dd	0			; pointer to country table in dos

dos_segreinit	dw	0,0		; room for dword

lo_doscod_size	dw	0		; dos code size when in low mem
hi_doscod_size	dw	0		; dos code size when in HMA

def_php		dw	0


; M022--
; pointer for calling into Bios_Code for re-initializing segment values.
;  call with ax = new segment for Bios_Code.  Notice that we'll
;  call it in its temporary home, cuz seg_reinit won't get moved to
;  the new home.

seg_reinit_ptr	label dword

		dw	offset Bios_Code:seg_reinit
temp_bcode_seg	dw	Bios_Code


;variables for stack initialization program.

	if	stacksw
stack_count dw	    defaultcount
stack_size  dw	    defaultsize
stack_addr  dd	    0
	endif

; various default values

memory_size	dw	1
RPLMemTop	dw	0
default_drive	db	0		;initialized by ibminit.
buffers 	dw	-1		; initialized during buffer allocation
h_buffers	dw	0		; # of the heuristic buffers. initially 0.
singlebuffersize dw	?		; maximum sector size + buffer header

files	db	8			; enough files for pipe
fcbs	db	4			; performance for recycling
keep	db	0			; keep original set
num_cds db	1			; minimum needed is 1, so that initialization does'nt have a problem
confbot dw	?
alloclim dw	?
DirStrng db	"A:\",0                 ; string for the root directory of a drive
command_line db 2,0,"P" 		;default command.com args
	db	125 dup (0)
zero	db	0
sepchr	db	0
linecount dw	0			;  line count in config.sys
showcount db	'     ',cr,lf,'$'	;  used to convert linecount to ascii.
buffer_linenum dw 0			; line count for "buffers=" command if entered.


buf_prev_off dw 0

	if	not noexec
comexe	exec0	 <0,command_line,default_drive,zero>
	endif

;------------------------------------------------------------------
;	variables for install= command.

multi_pass_id	db	0		; parameter passed to multi_pass
					;  indicating the pass number
					; 0 - do scan for DOS=HIGH/LOW
					; 1 - load device drivers
					; 2 - was to load IFS
					;      now it is unused
					; 3 - do install=
					; >3 - nop
install_flag	dw	0

have_install_cmd equ	00000001b	; config.sys has install= commands
has_installed	equ	00000010b	; sysinit_base installed.

config_size	dw	0		; size of config.sys file. set by sysconf.asm
sysinit_base_ptr dd	0		; pointer to sysinit_base
sysinit_ptr	dd	0		; returning addr. from sysinit_base
checksum	dw	0		; used by sum_up

ldexec_fcb	db	20 dup (' ')	;big enough
ldexec_line	db	0		;# of parm characters
ldexec_start	db	' '
ldexec_parm	db	80 dup (0)

instexe exec0	<0,ldexec_line,ldexec_fcb,ldexec_fcb>

;------------------------------------------------------------------
;variables for comment=

com_level	db	0		;level of " " in command line
cmmt		db	0		;length of comment string token
cmmt1		db	0		;token
cmmt2		db	0		;token
cmd_indicator	db	?
donotshownum	db	0

;------------------------------------------------------------------
count		dw	0
org_count	dw	0
chrptr		dw	0
cntryfilehandle dw	0
old_area	dw	0
impossible_owner_size dw 0		; paragraph
;------------------------------------------------------------------

bucketptr label dword
bufptr	label	dword			;leave this stuff in order!
memlo	dw	0
prmblk	label	word
memhi	dw	0
ldoff	dw	0
area	dw	0

packet	db	24			; was 22
	db	0
	db	0			;initialize code
	dw	0
	db	8 dup (?)

unitcount	db	0
break_addr	dd	0
bpb_addr	dd	0
drivenumber	db	0
configmsgflag	dw	0		; used to control "error in config.sys line #" message

toomanydrivesflag db    0               ;>24 fixed disk partitions flag   ; M029

BCodeSeg        dw      Bios_Code




;SR;
; This is the communication block between the DOS and the BIOS. It starts at
;the SysinitPresent flag. Any other data that needs to be communicated
;to the DOS should be added after SysinitPresent. The pointer to this block
;is passed to DOS as part of the DOSINIT call.
;

BiosComBlock	dd	Bios_Data:SysinitPresent

tempstack db	80h dup (?)

goinit:

ifdef JAPAN
	mov	ah,50h			; set crt mode
	mov	al,0
	mov	bx,81			; for JAPAN
	int	10h
	mov	ah,50h			; set keyboard mode
	mov	al,0
	mov	bx,81			; for JAPAN
	int	16h
endif
	cld

;; Before we installed spckbd.asm (we hook a lot of vectors there),
;; we shouldn't invoke any interrupt calls directly to bios(they will
;; go directly to ROM bios). Since we do know what exactly those ROM
;; bios(s) do, a safer manner is to issue bop to our 32 bits side.
;;	int	12h			; Get Memory in 1k
	BOP	12h
	mov	cl,6
	shl	ax,cl			;convert to 16-byte blocks(segment no.)
	mov	cx,ax
	dec	cx			; one para for an arena at end of mem
					; in case of UMBs
	mov	memory_size,cx

	push	cs
	pop	ds
	xor	si,si
	mov	di,si
        mov     ax, offset sysinitgrp:SI_end   ; need this much room for sysinit
	call	off_to_para
	sub	cx,ax

; we need to leave room for the DOS and for the BIOS
; code above sysinit in memory
;
	sub	cx,dossize/16		; leave this much room for DOS

	mov	ax,offset BCode_end
	call	off_to_para		; leave this much room for BIOS code
	sub	cx,ax

	mov	es,cx			; offset where sysinit will be located
        mov     cx,offset sysinitgrp:SI_end
	shr	cx,1			;divide by 2 to get words
	rep	movsw			;relocate sysinit

	push	es			; push relocated segment
	mov	ax,offset sysin
	push	ax			; push relocated entry point

	retf				; far jump to relocated sysinit


;	move the dos to its proper location

sysin:
	assume	ds:nothing,es:nothing,ss:nothing

	mov	ax, Bios_Data		; point DS to BIOS data
	mov	ds, ax

	assume	ds:Bios_Data

	mov	word ptr MoveDOSIntoHMA+2, cs	; set seg of routine to move DOS
	mov	SysinitPresent, 1	; flag that MoveDOSIntoHMA can be called

        SVC     SVC_ISDEBUG
        mov     DemInfoFlag, al

        test    al,ISDBG_DEBUGGEE
        je      @f
        SAVEREG <bx,dx,es>
        mov     bx, cs                  ; current base of BIOS
        xor     cx, cx
        mov     dx, current_dos_location; get offset of end of code
        sub     dx, bios_data           ; add in length of data segment
        REPT    4
        shl     dx, 1
        rcl     cx, 1
        endm

        mov     ax, SYMOP_LOAD SHL 8 + ID_NTIO
        SVC     SVC_DEMSYSTEMSYMBOLOP

        mov     bx, 1                   ; bugbug: Hardcoded segment number
        mov     ax, ds                  ; low segment location
        mov     es, ax                  ; relocated segment

        mov     ax, SYMOP_MOVE SHL 8 + ID_NTIO
        SVC     SVC_DEMSYSTEMSYMBOLOP

        RESTOREREG <es,dx,bx>
@@:

; first move the MSDOS.SYS image up to a harmless place
; on top of our new sysinitseg

        mov     ax,offset sysinitgrp:SI_end        ; how big is sysinitseg?
	call	off_to_para
	mov	cx,cs			; pick a buffer for msdos above us
	add	ax,cx
	mov	es,ax
	xor	si,si
	mov	di,si

	mov	ds,[current_dos_location] ; where it is (set by msinit)

	assume	ds:nothing

	mov	cx,dossize/2
	rep	movsw
	mov	[current_dos_location],es

; The DOS code is ORGed at a non-zero value to allow it to be located in
; HIMEM.  Thus, the DOS segment location must be adjusted accordingly.

	mov	ax,ds:word ptr 3	; get offset of dos
	mov	[dosinit],ax		; that's the entry point offset
	call	off_to_para		; subtract this much from segment
	sub	[current_dos_location],ax


; BIOS code is moved to the top of memory
; until it is determined whether it will be running in HIMEM or not.


; now put Bios_Code up on top of that.  Assume Bios_Code + dossize < 64k

	mov	ax,es
	add	ax,dossize/16		; get paragraph of end of dos
	mov	es,ax
	xchg	ax,temp_bcode_seg	; swap with original home of Bios_Code
	mov	ds,ax			; point to loaded image of Bios_Code

	assume	ds:nothing

	mov	si,offset BCode_start
	mov	di,si
	mov	cx,offset BCode_end
	sub	cx,si
	shr	cx,1
	rep	movsw			; move Bios_Code into place

	mov	ax,es			; tell it what segment it's in
	call	[seg_reinit_ptr]	; far call to seg_reinit in Bios_Code (M022)


;	now call dosinit while it's in its temporary home

	les	di,cs:[BiosComBlock]	; ptr to BIOS communication block
	lds	si,cs:[device_list]	; set for call to dosinit

	assume	ds:nothing, es:nothing

	mov	dx,cs:[memory_size]	; set for call to dosinit

        call    DOCLI
	mov	ax,cs
	mov	ss,ax
	align	2		; assembler wouldn't let me do an "and 0fffeh"
locstack label	byte		;  on the mov sp,offset locstack
	mov	sp,offset locstack	; set stack

        call    DOSTI


; This call to DOSINIT will relocate the DOS data from its present location
; at the top of memory, to its final location in low memory just above the
; BIOS data.  It will then build important DOS data structures in low
; memory following the DOS data.  It returns (among many other things) the
; new starting address of free memory.

	call	[dos_temp_location]	; call dosinit
					;es:di -> sysinitvars_ext

	mov	[def_php],ds		; save pointer to PSP
	mov	[hi_doscod_size],ax	; size of doscode (including exepatch)
	mov	[lo_doscod_size],cx	; (not including exepatch)
	mov	[dos_segreinit],dx	; save offset of segreinit

	mov	ax,word ptr es:[di.sysi_initvars]
	mov	word ptr dosinfo,ax
	mov	ax,word ptr es:[di.sysi_initvars+2]
	mov	word ptr [dosinfo+2],ax ;set the sysvar pointer

	mov	ax,word ptr es:[di.sysi_country_tab]
	mov	word ptr [sysi_country],ax
	mov	ax,word ptr es:[di.sysi_country_tab+2]
	mov	word ptr [sysi_country+2],ax ;set the sysi_country pointer

	mov	es,[current_dos_location]	; give dos its temporary loc.
	mov	[dos_segreinit+2],es
;
	les	di,dosinfo		;es:di -> dosinfo

	clc				;get the extended memory size

;	execute the get extended memory size subfunction in the bios int 15h
;	if the function reports an error do nothing else store the extended
;	memory size reported at the appropriate location in the dosinfo buffer
;	currently pointed to by es:di.	use the offsets specified in the
;	definition of the sysinitvars struct in inc\sysvar.inc

	mov	ah,88h
;; IBM ps/2 90 int 15(ah = 88h) read a coms byte(0B6h) which we don't support.
;; it returns 0 on this query.
;; we issue a bop to 32bits to get the real extended memeory size
;;	int	15h			;check extended memory size
	BOP	15h
;;	jc	no_ext_memory
	mov	es:[di].sysi_ext_mem,ax ;save extended memory size
;;	or	ax, ax
no_ext_memory:
	mov	ax,es:[di.sysi_maxsec]	; get the sector size
	add	ax,bufinsiz		; size of buffer header
	mov	[singlebuffersize],ax	; total size for a buffer

	SVC	SVC_DEMGETBOOTDRIVE
	mov	[default_drive],al
	mov	es:[di.sysi_boot_drive],al ; set sysi_boot_drive

; determine if 386 system...
if 1
        get_cpu_type                    ; macro to determine cpu type
        cmp     ax,2                    ; is it a 386?
        jne     not_386_system          ; no: don't mess with flag
endif

	mov	es:[di.sysi_dwmove],1
not_386_system:
	mov	al,es:[di.sysi_numio]
	mov	drivenumber,al		; save start of installable block drvs

	mov	ax,cs
	sub	ax,11h			; room for PSP we will copy shortly
	mov	cx,[singlebuffersize]	; temporary single buffer area
	shr	cx,1			
	shr	cx,1			; divide size by 16...
	shr	cx,1
	shr	cx,1			; ...to get paragraphs...
	inc	cx			; ... and round up

;	cas note:  this unorthodox paragraph rounding scheme wastes a byte if
;	  [singlebuffersize] ever happens to be zero mod 16.  Could this
;	  ever happen?  Only if the buffer overhead was zero mod 16, since
;	  it is probably safe to assume that the sector size always will be.
;
;	 mohans also found a bug in CONFIG.SYS processing where it replaces
;	  EOF's with cr,lf's, without checking for collision with [confbot].
;	  perhaps the extra byte this code guarantees is what has kept that
;	  other code from ever causing a problem???

	sub	ax,cx
	mov	[confbot],ax		; temp "unsafe" location
;	push	es			; preserve pointer to DOSINFO data
;	push	di

; setup and initialize the temporary buffer

;	les	di,es:[di.sysi_buf]	;get the buffer chain entry pointer
;	mov	word ptr es:[di.Dirty_Buff_Count],0
;	mov	word ptr es:[di.Buff_Queue],0
;	mov	word ptr es:[di.Buff_Queue+2],ax
;	mov	es,ax
;	xor	ax,ax
;	mov	di,ax			;es:di -> single buffer

;	mov	es:[di.buf_next],ax	;points to itself
;	mov	es:[di.buf_prev],ax	;points to itself

;	mov	word ptr es:[di.buf_id],00ffh ;free buffer,clear flag
;	mov	word ptr es:[di.buf_sector],0
;	mov	word ptr es:[di.buf_sector+2],0

;	pop	di			; restore pointer to DOSINFO data
;	pop	es

	push	cs
	pop	ds

	assume	ds:sysinitseg

	call	tempcds 		; set up cdss so re_init and sysinit
					;   can make disk system calls
	assume	ds:nothing		; tempcds trashes ds

	mov	ds,[def_php]		; retreive pointer to PSP returned by DOSINIT

	if	not ibmjapver
	call	re_init			; re-call the bios
	endif

        call    DOSTI                   ; ints ok
	cld				; make sure

; dosinit has set up a default "process" (php) at ds:0. we will move it out
; of the way by putting it just below sysinit at end of memory.

	mov	bx,cs
	sub	bx,10h
	mov	es,bx
	xor	si,si
	mov	di,si
	mov	cx,80h
	rep	movsw

	mov	word ptr es:[pdb_jfn_pointer + 2],es ; relocate
	mov	ah,set_current_pdb
	int	21h			; tell dos we moved it

	push	ds			; preserve DS returned by DOSINIT
	push	cs
	pop	ds			; point DS to sysinitseg

	assume	ds:sysinitseg

	; set up temp. critical error handler
	mov	dx,offset int24 	;set up int 24 handler
	mov	ax,(set_interrupt_vector shl 8) or 24h
	int	21h

        cmp     byte ptr [TooManyDrivesFlag],0  ;Q: >24 partitions? M029
        je      no_err                          ;  N: continue      M029
        mov     dx,offset TooManyDrivesMsg      ;  Y: print error message M029
        call	print                           ;		    M029
no_err:						;		    M029

	pop	ds			; start of free memory

	assume	ds:nothing

	mov	dl,[default_drive]
	or	dl,dl
	jz	nodrvset		; bios didn't say
	dec	dl			; a = 0
	mov	ah,set_default_drive
	int	21h			;select the disk

nodrvset:

;
; Process the CONFIG.SYS file
;

ProcessConfig:

;
; NTVDM store temp file name for config.sys, 23-Nov-1992 Jonle
;
        push    ds
        push    cs
        pop     ds
        assume  ds:sysinitseg
        mov     dx,offset config        ; ds:dx points file description
        CMDSVC  SVC_GETCONFIGSYS
        pop     ds
        assume  ds:nothing


ifndef  TAIWAN

	call	doconf			;do pre-scan for dos=high/low

else	; taiwan

	call	chkoemlocaldrv
	mov	cs:oemdriverinst,ax
	call	cdosinit
	push	es
	push	bx

	pop	bx
	pop	es
	call	maketempvector		;make dummy int service routine

	call	doconf			;do pre-scan for dos=high/low

	call	chklocalexist		;check if local dev drv exist
					;if not found,system halt
	call	recovercsiint		;recover csi interrupt vector
endif	; taiwan



; Now, we decide what to do with the DOS code.
; It will either be relocated to low memory, above the DOS data structures,
; or else it will be located in HiMem, in which case a stub with the DOS
; code entry points will be located in low memory.  Dos_segreinit is used
; to tell the DOS data where the code has been placed, and to install the
; low memory stub if necessary.  If the DOS is going to go into HiMem, we
; must first initialize it in its present location and load the installable
; device drivers.  Then, if a HiMem driver has been located, we can actually
; relocate the DOS code into HiMem.
;

; M025 begin

	cmp	runhigh, 0		; Did user choose to run low ?
	je	dont_install_stub	; yes, don't install dos low mem stub
;
;------ user chose to load high
;


	mov	es,[current_dos_location]	; give dos its temporary loc.

	xor	ax,ax				; ax = 00 ---> install stub
	call	cs:dword ptr [dos_segreinit]	; call dos segreinit
	jmp	short do_multi_pass
	
;
;------ User chose to load dos low
;
dont_install_stub:

	xor	bx, bx			; M012
					;  don't use int 21 call to alloc mem

	call	MovDOSLo		; move it !


	mov	ax, 1			; dont install stub
	mov	es, current_dos_location; set_dos_final_position set it up
	call	dword ptr dos_segreinit	; inform dos about new seg


do_multi_pass:

	call	AllocFreeMem		; allocate all the free mem
					;  & update [memhi] & [area]
					; start of free memory.

; M025 end



; NTVDM
; Copy softpc keyboard driver resident code to start of free mem
; Install Softpc IVT hooks
        mov     al,devmark_spc
        call    setdevmark
        mov     es, cs:[devmark_addr]
        mov     word ptr es:[arena_name], 'BK'
        mov     word ptr es:[arena_name+2], 'D'

        cld
	mov	ax,[memhi]
        push    ds
        mov     cx,Bios_Data
	mov	ds,cx
	assume	ds:Bios_Data
	mov	word ptr spc_mse_int10,offset int10h_vector
	mov	word ptr spc_mse_int10+2,ax
	mov	word ptr int29Perf,offset outchr    ; sudeepb 03-Nov-1992
	mov	word ptr int29Perf+2,ds 	    ; added for int10 performance
	pop	ds
        assume  ds:nothing

        mov     es,ax           ;es dest seg. for SpcKbd
        push    es
        push    cs
        pop     ds              ;ds src seg for SpcKbd
        mov     si,offset sysinitgrp:SpcKbdBeg
        mov     cx,offset sysinitgrp:SpcKbdEnd
        sub     cx,si
        xor     di,di
        mov     [memlo],cx
        or      [setdevmarkflag],for_devmark
        call    round
        rep     movsb
        pop     ds
        call    sysinitgrp:InstSpcKbd

        ; save value of int09 for int 09 hardware stack disable
        xor     ax,ax
        mov     ds,ax
        mov     si, 09h*4
        lodsw
        mov     word ptr cs:old09, ax
        lodsw
        mov     word ptr cs:old09+2, ax

        ; save value of int08 for int 08 hardware stack disable
        mov     si, 08h*4
        lodsw
        mov     word ptr cs:old08, ax
        lodsw
        mov     word ptr cs:old08+2, ax


; NTVDM
; Attempt to init emm memory manager. if we have emm
; then load internal emm stub device driver.
;
        ; check if emm memory is available
        mov    ax, [memhi]
        inc    ax                              ;1 para for arena header
        mov    ds, ax                          ;expected seg for emm drv
        call   sysinitgrp:InitSpcEmm
        cmp    ax, 0
        jne    NoEmmServices

        ; fill in the arena name
        mov     al, devmark_device
        call    setdevmark
        mov     es, cs:[devmark_addr]
        mov     word ptr es:[arena_name], 'ME'
        mov     word ptr es:[arena_name+2], 'M'

        ; copy in emm stub driver code
        cld
	mov	ax,[memhi]
        mov     es,ax
        push    es                              ;save for diddling devheader
        push    cs
        pop     ds
        mov     si,offset sysinitgrp:SpcEmmBeg
        mov     cx,offset sysinitgrp:SpcEmmEnd
        sub     cx,si
        xor     di,di
        mov     [memlo],cx
        or      [setdevmarkflag],for_devmark
        call    round
        rep     movsb

        ; link in emm stub driver
        ; so apps can find emm driver
        pop     ds
        xor     si, si                          ;ds:si = device header
        les     di, cs:[dosinfo]                ;es:di = to dos info
        mov     cx,word ptr es:[di.sysi_dev]    ;dx:cx = head of list
        mov     dx,word ptr es:[di.sysi_dev+2]
        mov     word ptr es:[di.sysi_dev],si    ;set head of list in dos
        mov     word ptr es:[di.sysi_dev+2],ds
        mov     word ptr ds:[si],  cx           ;link in the driver
        mov     word ptr ds:[si+2], dx

NoEmmServices:


; Now, process config.sys some more.
; Load the device drivers and install programs
        inc     cs:multi_pass_id        ; multi_pass_id = 1
        call    multi_pass              ; load device drivers


; NTVDM
; Install Softpc Mouse driver in UMB if can else in LOW memory
; This must be done after himem.sys is loaded for umb support
;
        mov     cx, offset sysinitgrp:SpcMseEnd
        sub     cx, offset sysinitgrp:SpcMseBeg  ; cx,    size of SpceMse
        mov     di, offset MseDev
        push    cs
        pop     es                      ; es:di,  dest
        push    cx                      ; preserve cx
        call    AllocUMBLow
        pop     cx
        push    es                      ; save to pass to InstSpcMse

        mov     si, offset sysinitgrp:SpcMseBeg
        push    cs
        pop     ds                      ; ds:si, Source of SpcMse code
        rep     movsb

        pop     ds
        call    sysinitgrp:InstSpcMse



        call    ShrinkUMB
	call	UnlinkUMB		; unlink all UMBs	;M002
	inc	cs:multi_pass_id	; multi_pass_id = 2
        call    multi_pass              ; was load ifs (now does nothing)
        call    endfile                 ; setup fcbs, files, buffers etc

;
;Reset SysinitPresent flag here. This is needed for the special fix for lying
;to device drivers. This has been moved up to this point to avoid problems
;with overlays called from installed programs
;
	mov	ax,Bios_Data
	mov	es,ax			; point ES to bios data

	assume	es:Bios_Data

	mov	es:SysinitPresent,0	; clear SysinitPresent flag

	test	install_flag,have_install_cmd ; are there install commands?
	jz	dolast			; no, no need for further processing
	inc	cs:multi_pass_id	; mult_pass_id = 3
	call	multi_pass		; execute install= commands
dolast:
	assume	es:nothing

; [area] has the segment address for the allocated memory of sysinit, confbot.
;  free the confbot area used for config.sys and sysinit itself.


; Now if DOS is supposed to run high, we actually move it into high memory
; (if HiMem manager is available).
;
; There is also this little hack for CPM style DOS calls that needs to
; be done when A20 is set...

	cmp	runhigh, 0ffh		; are we still waiting to be moved?
	jne	@f			; no, our job is over
	call	LoadDOSHiOrLo
@@:

	cmp	runhigh, 0		; are we running low
	je	@f			; yes, no CPM hack needed
	call	CPMHack			; make ffff:d0 same as 0:c0
@@:


; We are now done with CONFIG.SYS processing

ConfigDone:
;; let NTVDM knows that we have done config.sys processing
	xor	al, al			;config.sys done
	BOP	BOP_NOTIFICATION	;
	call	AllocUMB		; allocate remaining UMBs if there are any
        mov     cs:[donotshownum],1     ; done with config.sys. do not show line number message.
	mov	es,[area]

	assume	es:nothing

	mov	ah,49h			; free allocated memory for command.com
	int	21h

	test	cs:[install_flag],has_installed ; sysinit_base installed?
	jz	skip_free_sysinitbase	; no.

;set block from the old_area with impossible_owner_size.
;this will free the unnecessary sysinit_base that had been put in memory to
;handle install= command.

	push	es
	push	bx
	mov	es,cs:[old_area]
	mov	bx,cs:[impossible_owner_size]
	mov	ah,setblock
	int	21h
	mov	ax,es
	dec	ax
	mov	es,ax			;point to arena
	mov	es:[arena_owner],8	;set impossible owner
	mov	word ptr es:[arena_name], 'DS'	; System Data
	pop	bx
	pop	es

skip_free_sysinitbase:

if	noexec
	mov	bp,ds			;save command.com segment
	push	ds
	pop	es
	mov	bx,cs
	sub	bx,10h			; point to current php
	mov	ds,bx
	xor	si,si
	mov	di,si
	mov	cx,80h
	rep	movsw			; copy it to new location for shell
	mov	word ptr es:[pdb_jfn_pointer + 2],es ; relocate
	mov	bx,es
	mov	ah,set_current_pdb
	int	21h			; tell dos we moved it
	mov	es:[pdb_parent_pid],es	;we are the root
endif ; noexec

	push	cs
	pop	ds			; point DS to sysinitseg

	assume	ds:sysinitseg

; set up the parameters for command

	mov	si,offset command_line+1

if	noexec
	mov	di,81h
else
	push	ds
	pop	es
	mov	di,si
endif

	mov	cl,-1
comtranlp:				;find length of command line
	inc	cl
	lodsb
	stosb				;copy command line in
	or	al,al
	jnz	comtranlp
	dec	di
	mov	al,cr			; cr terminate
	stosb

if	noexec
	mov	es:[80h],cl		; set up header
	mov	al,[default_drive]
	mov	es:[5ch],al
else
	mov	[command_line],cl	;count
endif

	mov	dx,offset commnd	;now pointing to file description


if	noexec
	mov	es,bp		;set load address
	mov	bx,100h
	call	dfil		;read in command
	jc	comerr
	mov	ds,bp
	mov	dx,80h
	mov	ah,set_dma	;set disk tranfer address
	int	21h
        call    DOCLI
	mov	ss,bp
	mov	sp,dx
        call    DOSTI
	xor	ax,ax		;push a word of zeros
	push	ax
	push	bp		;set high part of jump address
	mov	ax,100h
	push	ax		;set low part of jump address
	retf			;crank up command!

else ; not noexec

; we are going to open the command interpreter and size it as is done in
; ldfil.  the reason we must do this is that sysinit is in free memory.  if
; there is not enough room for the command interpreter,exec will probably
; overlay our stack and code so when it returns with an error sysinit won't be
; here to catch it.  this code is not perfect (for instance .exe command
; interpreters are possible) because it does its sizing based on the
; assumption that the file being loaded is a .com file.  it is close enough to
; correctness to be usable.

	push	dx		; save pointer to name

; first, find out where the command interpreter is going to go.

	mov	bx,0ffffh
	mov	ah,alloc
	int	21h		;get biggest piece
	mov	ah,alloc
	int	21h		; second time gets it
	jc	memerrjx	; oooops

	mov	es,ax
	mov	ah,dealloc
	int	21h		; give it right back
	mov	bp,bx

; es:0 points to block,and bp is the size of the block
;   in para.

; we will now adjust the size in bp down by the size of sysinit. we
;   need to do this because exec might get upset if some of the exec
;   data in sysinit is overlayed during the exec.

	mov	bx,[memory_size] ; get location of end of memory
	mov	ax,cs		; get location of beginning of sysinit
	sub	bx,ax		; bx is size of sysinit in para
	add	bx,11h		; add the sysinit php
	sub	bp,bx		; sub sysinit size from amount of free memory
	jc	memerrjx	; if there isn't even this much memory, give up

	mov	ax,(open shl 8)	;open the file being execed
	stc			;in case of int 24
	int	21h
	jc	comerr		; ooops

	mov	bx,ax		;handle in bx
	xor	cx,cx
	xor	dx,dx
	mov	ax,(lseek shl 8) or 2
	stc			;in case of int 24
	int	21h		; get file size in dx:ax
	jc	comerr
				; convert size in dx:ax to para in ax
	add	ax,15		; round up size for conversion to para
	adc	dx,0
	call	off_to_para
	mov	cl,12
	shl	dx,cl		; low nibble of dx to high nibble
	or	ax,dx		; ax is now # of para for file
	add	ax,10h		; 100h byte php
	cmp	ax,bp		; will command fit in available mem?
	jb	okld		; jump if yes.
memerrjx:
	jmp	mem_err

okld:
	mov	ah,close
	int	21h		; close file

	pop	dx		; recover pointer to name
	push	cs		; point es to sysinitseg
	pop	es
	mov	bx,offset comexe ; point to exec block
	mov	word ptr [bx.exec0_com_line+2],cs ; set segments
	mov	word ptr [bx.exec0_5c_fcb+2],cs
	mov	word ptr [bx.exec0_6c_fcb+2],cs
	xor	ax,ax		;load and go
	mov	ah,exec
	stc			;in case of int 24
	int	21h		;go start up command
	endif

; note fall through if exec returns (an error)

comerr:
	mov	dx,offset badcom ;want to print command error
	extrn	badfil:near
	call	badfil
	public	stall
stall:	SVC	SVC_DEMEXITVDM		; Will Kill The VDM

;
;----------------------------------------------------------------------------
; procedure : AllocFreeMem
;
; Allocate Max memory from DOS to find out where to load DOS.
; DOS is at temporary location when this call is being made
;
; Inputs : None
; Outputs: The biggest chunk of memory is allocated (all mem at init time)
;	   [area] & [memhi] set to the para value of the start of the
;	   free memory.
;
; Uses   : AX, BX
;
;----------------------------------------------------------------------------
;
AllocFreeMem	proc	near

	assume	es:nothing, ds:nothing
	mov	bx,0ffffh
	mov	ah,alloc
	int	21h			;first time fails
	mov	ah,alloc
	int	21h			;second time gets it
	mov	[area],ax
	mov	[memhi],ax		; memhi:memlo now points to
	ret
					; start of free memory
AllocFreeMem	endp

;	start M000
	include	msbio.cl6
;	end M000

;
;----------------------------------------------------------------------------
;
; procedure : LoadDOSHiOrLo
;
;		Tries to move DOS into HMA. If it fails then loads
;		DOS into Low memory.
;
;----------------------------------------------------------------------------
;

LoadDOSHiOrLo	proc	near
	call	TryToMovDOSHi			; Try moving it into HMA (M024)
	jc	LdngLo				; If that don't work...
	ret
LdngLo:
	push	cs
	pop	ds
	mov	ah, 9
	mov	dx, offset DOSLOMSG		; inform user that we are
	int	21h				;  loading low

	; actually move the dos, and reinitialize it.

	mov	bx, 1				; M012
						;  use int 21 alloc for mem
	call	MovDOSLo
	mov	es,[current_dos_location]	; give dos its temporary loc.
	xor	ax,ax				; ax = 00 ---> install stub
	call	cs:dword ptr [dos_segreinit]	; call dos segreinit

	mov	runhigh, 0			; mark that we are running lo
	ret
LoadDOSHiOrLo	endp


;
;----------------------------------------------------------------------------
;
; procedure : TryToMovDOSHi
;
;		This tries to move DOS into HMA.
;		Returns CY if it failed.
;		If it succeeds returns with carry cleared.
;
;
;----------------------------------------------------------------------------
;

		public	TryToMovDOSHi

TryToMovDOSHi	proc	near
	call	MovDOSHi
	jc	ttldhx


	mov	es,[current_dos_location]	; give dos its temporary loc.

	xor	ax,ax				; ax = 00 ---> install stub
	call	cs:dword ptr [dos_segreinit]	; call dos segreinit

	mov	runhigh, 1
	clc
ttldhx:
	ret
TryToMovDOSHi	endp


;
;----------------------------------------------------------------------------
;
; procedure : MovDOSHi
;
;		Tries to allocate HMA and Move DOS/BIOS code into HMA
;
;		Returns : CY if it failed
;
;----------------------------------------------------------------------------
;

MovDOSHi	proc	near
	call	AllocHMA
	jc	mdhx				; did we get HMA?
	mov	ax, 0ffffh			; yes, HMA seg = 0ffffh
	mov	es, ax

	; actually move the BIOS and DOS

	call	MovBIOS				; First move BIOS into HMA

	; ES:DI points to free HMA after BIOS

	mov	cx, hi_doscod_size		; pass the code size of DOS
						;  when it is in HMA
	call	MovDOS				; and move it

	; ES:DI points to free HMA after DOS

	call	SaveFreeHMAPtr			; Save the Free HMA ptr
	clc
mdhx:
	ret
MovDOSHi	endp


;
;----------------------------------------------------------------------------
;
; procedure : MovDOSLo
;
;		Allocates memory from DOS and moves BIOS/DOS code into it
;
;----------------------------------------------------------------------------
;


MovDOSLo	proc	near
	call	AllocMemForDOS			; 
	mov	es, ax				; pass the segment to MovBIOS
	call	MovBIOS
;
;------ ES:DI points memory immediately after BIOS
;
	mov	cx, lo_doscod_size		; DOS code size when loaded
						;  low
	call	MovDOS
	ret
MovDOSLo	endp


;
;----------------------------------------------------------------------------
;
; procedure : MovBIOS
;
;		Moves BIOS code into requested segment
;
;	In : ES - segment to which BIOS is to be moved
;		  ( it moves always into offset BCode_Start)
;
;	Out : ES:DI - pointer to memory immediately after BIOS
;
;----------------------------------------------------------------------------
;


MovBIOS	proc	near
	mov	ds, temp_bcode_seg		; current BIOS code seg
	mov	si, offset BCode_Start
	mov	di, si
	mov	cx, offset BCode_End
	sub	cx, si				; size of BIOS
	shr	cx, 1				; Both the labels are para
						;  aligned
	rep	movsw
	push	es
	push	di				; save end of BIOS
	mov	ax, es
	mov	BCodeSeg, ax			; save it for later use
	call	[seg_reinit_ptr]		; far call to seg_reinit (M022)
	pop	di
	pop	es				; get back end of BIOS
	ret
MovBIOS	endp


;
;----------------------------------------------------------------------------
;
; procedure : MovDOS
;
;		Moves DOS code into requested area
;
;	In : ES:DI - pointer to memory where DOS is  to be moved
;	     CX    - size of DOS code to be moved
;
;	Out : ES:DI - pointer to memory immediately after DOS
;
;----------------------------------------------------------------------------
;


MovDOS	proc	near
	push	es
	push	di
	lds	si, dos_temp_location		; current location of DOS
	rep	movsb
	pop	bx				; get back offset into which
						;  DOS was moved
	mov	ax, dosinit			; get the offset at which DOS
						;  wants to run
	sub	ax, bx
	call	off_to_para
	pop	bx				; get the segment at which
						;  we moved DOS into
	sub	bx, ax				; Adjust segment
	mov	current_dos_location, bx	; and save it
	ret
MovDOS	endp


;
;----------------------------------------------------------------------------
;
; procedure : AllocMemForDOS
;
;		Allocate memory for DOS/BIOS code from DOS !!!
;
;	Out : AX - seg of allocated memoryblock
;
;----------------------------------------------------------------------------
;


AllocMemForDOS	proc	near
	mov	ax, offset BCode_end
	sub	ax, offset BCode_start		; BIOS code size
	add	ax, lo_doscod_size		; + DOS code size
	add	ax, 15
	call	off_to_para			; convert to para
	or	bx, bx				; M012
						;  can we use int 21 for alloc
	mov	bx, ax
	jz	update_arena			; M012
	mov	ah, 48h				; request DOS
	int	21h
	jc	FatalErr			; IF ERR WE ARE HOSED
	sub	ax, 3				; Take care ORG 30h of
						;  BIOS code
	mov	es, ax
	mov	word ptr es:[20h+arena_owner], 08h	; mark it as system
	mov	word ptr es:[20h+arena_name], 'CS'	;  code area
	ret

;
; M012 : BEGIN
;
update_arena:
	push	ds
	push	di
	push	cx
	push	dx
	lds	di, dosinfo			; get ptr to DOS var
	dec	di
	dec	di				; Arena head is immediately
						;  before sysvar
	mov	es, ds:[di]			; es = arena head
	mov	cx, es:[arena_size]		; cx = total low mem size
	cmp	cx, bx				; is it sufficient ?
	jb	FatalErr			; no, fatal error
	mov	dl, es:[arena_signature]
	mov	ax, es
	add	ax, bx				; ax = new arena head
	mov	ds:[di], ax			; store it in DOS data area
	mov	ds, ax
	mov	byte ptr ds:[arena_signature], dl	; type of arena
	mov	word ptr ds:[arena_owner], 0		; free
	sub	cx, bx				; size of the new block
	mov	word ptr ds:[arena_size], cx	; store it in the arena
	mov	ax, es				; return seg to the caller
	sub	ax, 3				; Take care ORG 30h of
						;  BIOS code
	pop	dx
	pop	cx
	pop	di
	pop	ds
	ret
;
; M012 : END
;
FatalErr:
	push	cs
	pop	ds
	mov	dx, offset FEMsg
	mov	ah, 9h
	int	21h
        cli
	hlt
AllocMemForDOS	endp


;
;----------------------------------------------------------------------------
;
; procedure : AllocHMA
;
;	grab_the_hma tries to enable a20 and make sure there is memory
;	  up there.  If it gets any sort of error, it will return with
;	  carry set so that we can resort to running low.
;
;	It also returns ES: -> 0ffffh if it returns success
;
;----------------------------------------------------------------------------
;

AllocHMA	proc near
	assume	ds:nothing,es:nothing
;
;	cas note:  The pre-286 check is no longer needed here since the
;		   presence of XMS is sufficient.  However, this code hasn't
;		   been deleted because it can be recycled for skipping the
;		   extra pass of CONFIG.SYS and assuming we're running low
;		   in the case of a pre-286.

;
;;	see if we're running on a pre-286.  If not, force low.
;
;	xor	ax,ax
;	pushf			; save flags (like int)
;	push	ax
;	popf
;	pushf
;	pop	ax
;	popf			; restore original flags (like int)
;	and	ax,0f000h
;	cmp	ax,0f000h	; 8088/8086?
;	jz	grab_hma_error
;
	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume 	ds:Bios_Data

	call	IsXMSLoaded
	jnz	grabhma_error

	mov	ax,4310h
	int	2fh		; get the vector into es:bx
	mov	word ptr xms,bx
	mov	word ptr xms+2,es

	mov	ah,1		; request HMA
	mov	dx,0ffffh
	call	xms
	dec	ax
	jz	@f		; error if not able to allocate HMA

;
;------ Himem may be lying because it has allocated mem for int 15
;
	mov	ah, 88h
	int	15h
	cmp	ax, 64		; less than 64 K of hma ?
	jb	grabhma_error

@@:	mov	ah,5		; localenableA20
	call	xms
	dec	ax
	jnz	grabhma_error	; error if couldn't enable A20

	mov	ax,0ffffh
	mov	es,ax
	mov	es:word ptr 10h,1234h	; see if we can really read/write there
	cmp	es:word ptr 10h,1234h
	jnz	grabhma_error	; don't try to load there if XMS lied

	clc
	pop	ds
	ret

grabhma_error:
	stc
	pop	ds
	assume	ds:nothing
	ret

AllocHMA	endp

;
;----------------------------------------------------------------------------
;
; procedure : IsXMSLoaded
;
;             Checks whether a XMS driver is loaded
;
; Returns : Z flag set if XMS driver loaded
;           Z flag reset if no XMS drivers are present
;
;----------------------------------------------------------------------------
;
		public	IsXMSLoaded

IsXMSLoaded	proc	near
		mov	ax,4300h
		int	2fh
		cmp	al,80h		; XMS installed?
		ret
IsXMSLoaded	endp

;
;
;----------------------------------------------------------------------------
; procedure : FTryToMovDOSHi
;
;		Called from HMA suballoc calls
;	
;----------------------------------------------------------------------------
;
;

		public	FTryToMovDOSHi
FTryToMovDOSHi	proc	far

		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	ds
		push	es
		cmp	runhigh, 0ffh
		jne	@f

		call	TryToMovDOSHi
@@:
		pop	es
		pop	ds
		pop	di
		pop	si
		pop	dx
		pop	cx