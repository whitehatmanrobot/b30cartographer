Type_Not_Enumerated:1;
            ULONGLONG   Reserved1:7;
            ULONGLONG   Cap_Wake:1;
            ULONGLONG   Cap_Raw:1;
            ULONGLONG   Cap_Button:1;
            ULONGLONG   Cap_Always_PS0:1;
            ULONGLONG   Cap_No_Filter:1;
            ULONGLONG   Cap_No_Stop:1;
            ULONGLONG   Cap_No_Override:1;
            ULONGLONG   Cap_ISA:1;
            ULONGLONG   Cap_EIO:1;
            ULONGLONG   Cap_PCI:1;
            ULONGLONG   Cap_Serial:1;
            ULONGLONG   Cap_Thermal_Zone:1;
            ULONGLONG   Cap_LinkNode:1;
            ULONGLONG   Cap_No_Show_in_UI:1;
            ULONGLONG   Cap_Never_show_in_UI:1;
            ULONGLONG   Cap_Start_in_D3:1;
            ULONGLONG   Cap_PCI_Device:1;
            ULONGLONG   Cap_PIC_Device:1;
            ULONGLONG   Cap_Unattached_Dock:1;
            ULONGLONG   Cap_No_Disable_Wake:1;
            ULONGLONG   Cap_Processor:1;
            ULONGLONG   Cap_Container:1;
            ULONGLONG   Cap_PCI_Bar_Target:1;
            ULONGLONG   Cap_No_Remove_or_Eject:1;
            ULONGLONG   Reserved2:1;
            ULONGLONG   Prop_Rebuild_Children:1;
            ULONGLONG   Prop_Invalid_Relations:1;
            ULONGLONG   Prop_Unloading:1;
            ULONGLONG   Prop_Address:1;
            ULONGLONG   Prop_HID:1;
            ULONGLONG   Prop_UID:1;
            ULONGLONG   Prop_Fixed_HID:1;
            ULONGLONG   Prop_Fixed_UID:1;
            ULONGLONG   Prop_Failed_Init:1;
            ULONGLONG   Prop_Srs_Present:1;
            ULONGLONG   Prop_No_Object:1;
            ULONGLONG   Prop_Exclusive:1;
            ULONGLONG   Prop_Ran_INI:1;
            ULONGLONG   Prop_Device_Enabled:1;
            ULONGLONG   Prop_Device_Failed:1;
            ULONGLONG   Prop_Acpi_Power:1;
            ULONGLONG   Prop_Dock:1;
            ULONGLONG   Prop_Built_Power_Table:1;
            ULONGLONG   Prop_Has_PME:1;
            ULONGLONG   Prop_No_Lid_Action:1;
            ULONGLONG   Prop_Fixed_Address:1;
            ULONGLONG   Prop_Callback:1;
            ULONGLONG   Prop_Fixed_CiD:1;
        } UFlags;

    };

    //
    // Signature Block
    //
    ULONG               Signature;

    //
    // Debug Flags
    //
    ULONG               DebugFlags;

    //
    // Primary irp handlers
    //
    PIRP_DISPATCH_TABLE DispatchTable;

    //
    // Note that we cannot have these 2 structures in the 2nd nameless union
    // because these structures are basically used by all devices
    //
    union {

        //
        // Start device context
        //
        WORK_QUEUE_CONTEXT          WorkContext;

        //
        // Contains Fdo Specific information
        //
        FDO_DEVICE_EXTENSION        Fdo;

        //
        // Contains Filter Specific information
        //
        FILTER_DEVICE_EXTENSION     Filter;

        //
        // Contains PDO specific information
        //
        PDO_DEVICE_EXTENSION        Pdo;

    };

    //
    // Union of those structures that are device type dependent
    //
    union {

        //
        // Common device worker queue structure for device types
        // which use them
        //
        EXTENSION_WORKER            WorkQueue;

        //
        // Contains internal button device information
        //
        BUTTON_EXTENSION            Button;

        //
        // Contains internal thermal device information
        //
        THERMAL_EXTENSION           Thermal;

        //
        // Contains the information for a link node
        //
        LINK_NODE_EXTENSION         LinkNode;

        //
        // Contains dock information (such as the extension of the acpi object
        // this node represents)
        //
        DOCK_EXTENSION              Dock;

        //
        // Contains the information about the processor device
        //
        PROCESSOR_DEVICE_EXTENSION  Processor;

    };

    //
    // Device State Flags
    //
    ACPI_DEVICE_STATE   DeviceState;

    //
    // Previous State Flags (for the Cancel routines)
    //
    ACPI_DEVICE_STATE   PreviousState;

    //
    // Power Information about the device
    //
    ACPI_POWER_INFO     PowerInfo;

    //
    // Pointer to a built-up string that represents the
    // Device ID or the device address. The flags determine
    // which of the following should be used
    //
    union {
        PUCHAR              DeviceID;
        ULONG               Address;
    };

    //
    // The instance ID of this device
    //
    PUCHAR              InstanceID;

    //
    // The resource list that received
    //
    PCM_RESOURCE_LIST   ResourceList;

    //
    // The resource list that we output
    //
    POBJDATA            PnpResourceList;

    //
    // Outstanding IRP Reference Counts ...
    //
    LONG                OutstandingIrpCount;

    //
    // This is the number of outstanding references to this device extension
    // When this drops to zero, the memory may be freed. Each child object
    // counts for one reference, as does the associated device object and
    // name space object.
    //
    LONG                ReferenceCount;

    //
    // This is the number of outstanding Hibernate Path notifications on the
    // the device
    //
    LONG                HibernatePathCount;

    //
    // Synchronization Event for our use. Lets us know when a remove occurs.
    //
    PKEVENT             RemoveEvent;

    //
    // Points to the associated ACPI-Name-space object
    //
    PNSOBJ              AcpiObject;

    //
    // This is the device object that we are linked to
    //
    PDEVICE_OBJECT      DeviceObject;

    //
    // This is the driver object we send requests onto
    //
    PDEVICE_OBJECT      TargetDeviceObject;

    //
    // This is the driver object just below us.
    //
    PDEVICE_OBJECT      PhysicalDeviceObject;

    //
    // This is our Parent
    //
    struct _DEVICE_EXTENSION *ParentExtension;

    //
    // This points to our first child
    //
    LIST_ENTRY          ChildDeviceList;

    //
    // This points to our next sibling
    //
    LIST_ENTRY          SiblingDeviceList;

    //
    // This is a list of devices that will be ejected when this device is
    //
    LIST_ENTRY          EjectDeviceHead;

    //
    // The ejection list is threaded through this entry.
    //
    LIST_ENTRY          EjectDeviceList;
} ;

//
// DEVICE_EXTENSION.Flags
// These are the ones that specify which type of object the current
// extension represents. As you tell, they are not quite mutually exclusive
//
// The difference between the NOT_FOUND, NOT_PRESENT, and NEVER_PRESENT is
//
//      NOT_FOUND is used to determine if we have build a PDO/FDO whatever.
//                the NOT_FOUND flag is set on an attach or devobj create, and
//                is cleared during a devobj delete or in response to a surprise
//                remove IRP.
//
//      NOT_PRESENT means that the isn't currently present as determined by the
//                _STA method in the hardware.
//
//      NEVER_PRESENT means that the device will always be NOT_PRESENT
//                regardless of what the _STA says
//
// The difference between an extension that has been REMOVED and one that has
// been SURPRISE_REMOVED is that there is a dummy extension for the
// SURPRISE_REMOVED case that replaces the original device extension pointer
// in the device object. This new extension gets the SURPRISE_REMOVED flag, so
// that people know that there is an original extension behind it.
//
//
#define DEV_TYPE_NEVER_PRESENT      0x0000000000000001
#define DEV_TYPE_NOT_PRESENT        0x0000000000000002
#define DEV_TYPE_REMOVED            0x0000000000000004
#define DEV_TYPE_NOT_FOUND          0x0000000000000008
#define DEV_TYPE_FDO                0x0000000000000010
#define DEV_TYPE_PDO                0x0000000000000020
#define DEV_TYPE_FILTER             0x0000000000000040
#define DEV_TYPE_SURPRISE_REMOVED   0x0000000000000080
#define DEV_TYPE_NOT_ENUMERATED     0x0000000000000100

//
// These are the capabilities of the device
//
#define DEV_CAP_WAKE                0x0000000000010000
#define DEV_CAP_RAW                 0x0000000000020000
#define DEV_CAP_BUTTON              0x0000000000040000
#define DEV_CAP_ALWAYS_PS0          0x0000000000080000
#define DEV_CAP_NO_FILTER           0x0000000000100000
#define DEV_CAP_NO_STOP             0x0000000000200000
#define DEV_CAP_NO_OVERRIDE         0x0000000000400000
#define DEV_CAP_ISA                 0x0000000000800000
#define DEV_CAP_EIO                 0x0000000001000000
#define DEV_CAP_PCI                 0x0000000002000000
#define DEV_CAP_SERIAL              0x0000000004000000
#define DEV_CAP_THERMAL_ZONE        0x0000000008000000
#define DEV_CAP_LINK_NODE           0x0000000010000000
#define DEV_CAP_NO_SHOW_IN_UI       0x0000000020000000
#define DEV_CAP_NEVER_SHOW_IN_UI    0x0000000040000000
#define DEV_CAP_START_IN_D3         0x0000000080000000
#define DEV_CAP_PCI_DEVICE          0x0000000100000000
#define DEV_CAP_PIC_DEVICE          0x0000000200000000
#define DEV_CAP_UNATTACHED_DOCK     0x0000000400000000
#define DEV_CAP_NO_DISABLE_WAKE     0x0000000800000000
#define DEV_CAP_PROCESSOR           0x0000001000000000
#define DEV_CAP_CONTAINER           0x0000002000000000
#define DEV_CAP_PCI_BAR_TARGET      0x0000004000000000
#define DEV_CAP_NO_REMOVE_OR_EJECT  0x0000008000000000

//
// These are the properties of the device
//
#define DEV_PROP_REBUILD_CHILDREN   0x0000020000000000
#define DEV_PROP_INVALID_RELATIONS  0x0000040000000000
#define DEV_PROP_UNLOADING          0x0000080000000000
#define DEV_PROP_ADDRESS            0x0000100000000000
#define DEV_PROP_HID                0x0000200000000000
#define DEV_PROP_UID                0x0000400000000000
#define DEV_PROP_FIXED_HID          0x0000800000000000
#define DEV_PROP_FIXED_UID          0x0001000000000000
#define DEV_PROP_FAILED_INIT        0x0002000000000000
#define DEV_PROP_SRS_PRESENT        0x0004000000000000
#define DEV_PROP_NO_OBJECT          0x0008000000000000
#define DEV_PROP_EXCLUSIVE          0x0010000000000000
#define DEV_PROP_RAN_INI            0x0020000000000000
#define DEV_PROP_DEVICE_ENABLED     0x0040000000000000
#define DEV_PROP_DEVICE_FAILED      0x0080000000000000
#define DEV_PROP_ACPI_POWER         0x0100000000000000
#define DEV_PROP_DOCK               0x0200000000000000
#define DEV_PROP_BUILT_POWER_TABLE  0x0400000000000000
#define DEV_PROP_HAS_PME            0x0800000000000000
#define DEV_PROP_NO_LID_ACTION      0x1000000000000000
#define DEV_PROP_FIXED_ADDRESS      0x2000000000000000
#define DEV_PROP_CALLBACK           0x4000000000000000
#define DEV_PROP_FIXED_CID          0x8000000000000000

//
// This mask should be used to obtain just unique type bytes
//
#define DEV_MASK_TYPE               0x00000000000001FF
#define DEV_MASK_CAP                0xFFFFFFFFFFFF0000
#define DEV_MASK_UID                (DEV_PROP_UID | DEV_PROP_FIXED_UID)
#define DEV_MASK_HID                (DEV_PROP_HID | DEV_PROP_FIXED_HID)
#define DEV_MASK_ADDRESS            (DEV_PROP_ADDRESS | DEV_PROP_FIXED_ADDRESS)
#define DEV_MASK_NOT_PRESENT        (DEV_TYPE_NOT_PRESENT | DEV_PROP_FAILED_INIT)
#define DEV_MASK_BUS                (DEV_CAP_ISA | DEV_CAP_PCI | DEV_CAP_EIO)
#define DEV_MASK_INTERNAL_DEVICE    (DEV_CAP_NO_FILTER | DEV_CAP_NO_STOP | \
                                     DEV_PROP_EXCLUSIVE)
#define DEV_MASK_THERMAL            (DEV_CAP_NO_FILTER | DEV_PROP_EXCLUSIVE)
#define DEV_MASK_INTERNAL_BUS       (DEV_CAP_RAW | DEV_CAP_NO_FILTER)
#define DEV_MASK_PCI                (DEV_CAP_PCI | DEV_CAP_PCI_DEVICE)
#define DEV_MASK_PRESERVE           (DEV_CAP_PCI_BAR_TARGET)

//
// DEVICE_EXTENSION.DebugFlags
//
#define DEVDBG_EJECTOR_FOUND    0x00000001

//
// This is the acpi device extension signature
//
#define ACPI_SIGNATURE      0x5f534750

//
// These are the pooltag signatures
//
#define ACPI_ARBITER_POOLTAG    'ApcA'
#define ACPI_BUFFER_POOLTAG     'BpcA'
#define ACPI_DEVICE_POOLTAG     'DpcA'
#define ACPI_INTERFACE_POOLTAG  'FpcA'
#define ACPI_IRP_POOLTAG        'IpcA'
#define ACPI_MISC_POOLTAG       'MpcA'
#define ACPI_POWER_POOLTAG      'PpcA'
#define ACPI_OBJECT_POOLTAG     'OpcA'
#define ACPI_RESOURCE_POOLTAG   'RpcA'
#define ACPI_STRING_POOLTAG     'SpcA'
#define ACPI_THERMAL_POOLTAG    'TpcA'
#define ACPI_TRANSLATE_POOLTAG  'XpcA'

//
// ACPI Override Attributes
//
#define ACPI_OVERRIDE_NVS_CHECK         0x00000001
#define ACPI_OVERRIDE_STA_CHECK         0x00000002
#define ACPI_OVERRIDE_MP_SLEEP          0x00000004
#define ACPI_OVERRIDE_OPTIONAL_WAKE     0x00000008
#define ACPI_OVERRIDE_DISABLE_S1        0x00000010
#define ACPI_OVERRIDE_DISABLE_S2        0x00000020
#define ACPI_OVERRIDE_DISABLE_S3        0x00000040
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\acpiosnt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    acpiosnt.c

Abstract:

    This module implements the OS specific functions for the Windows NT
    version of the ACPI driver

Author:

    Jason Clark (jasoncl)
    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    09-Oct-96 Initial Revision
    20-Nov-96 Interrupt Vector support
    31-Mar-97 Cleanup

--*/

#include "pch.h"
#include "amlihook.h"

// from shared\acpiinit.c
extern PACPIInformation AcpiInformation;

// from irqarb.c
extern ULONG InterruptModel;

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

PPM_DISPATCH_TABLE PmHalDispatchTable;
FAST_IO_DISPATCH ACPIFastIoDispatch;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,OSInterruptVector)
#pragma alloc_text(PAGE,NotifyHalWithMachineStates)
#endif

ACPI_HAL_DISPATCH_TABLE AcpiHalDispatchTable;

NTSTATUS
DriverEntry (
    PDRIVER_OBJECT      DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:

    The ACPI driver's entry point

Arguments:

    DriverObject    - Pointer to the object that represents this driver

Return Value:

    N/A

--*/
{
    NTSTATUS    status;
    ULONG       i;
    ULONG       argSize;

    //
    //  If the AMLIHOOK interface is enabled
    //  hook it.
    //

    AmliHook_InitTestHookInterface();

    //
    // Remember the name of the driver object
    //
    AcpiDriverObject = DriverObject;

    //
    // Save registry path for use by WMI registration code
    //
    AcpiRegistryPath.Length = 0;
    AcpiRegistryPath.MaximumLength = RegistryPath->Length + sizeof(WCHAR);
    AcpiRegistryPath.Buffer = ExAllocatePoolWithTag(
        PagedPool,
        RegistryPath->Length+sizeof(WCHAR),
        ACPI_MISC_POOLTAG
        );
    if (AcpiRegistryPath.Buffer != NULL) {
        RtlCopyUnicodeString(&AcpiRegistryPath, RegistryPath);

    } else {

        AcpiRegistryPath.MaximumLength = 0;

    }

    //
    // Read the keys that we need to operate this driver from the
    // registry
    //
    ACPIInitReadRegistryKeys();

    //
    // This flag may be set, when its not required, nor desired
    // so take the opportunity to clean it up now
    //
    if (AcpiOverrideAttributes & ACPI_OVERRIDE_MP_SLEEP) {

        KAFFINITY   processors = KeQueryActiveProcessors();

        //
        // If this is a UP system, then turn off this override
        //
        if (processors == 1) {

            AcpiOverrideAttributes &= ~ACPI_OVERRIDE_MP_SLEEP;

        }

    }

    //
    // Initialize the DPCs
    //
    KeInitializeDpc( &AcpiPowerDpc, ACPIDevicePowerDpc, NULL );
    KeInitializeDpc( &AcpiBuildDpc, ACPIBuildDeviceDpc, NULL );
    KeInitializeDpc( &AcpiGpeDpc,   ACPIInterruptDispatchEventDpc, NULL );

    //
    // Initialize the timer
    //
    KeInitializeTimer( &AcpiGpeTimer );

    //
    // Initialize the SpinLocks
    //
    KeInitializeSpinLock( &AcpiDeviceTreeLock );
    KeInitializeSpinLock( &AcpiPowerLock );
    KeInitializeSpinLock( &AcpiPowerQueueLock );
    KeInitializeSpinLock( &AcpiBuildQueueLock );
    KeInitializeSpinLock( &AcpiThermalLock );
    KeInitializeSpinLock( &AcpiButtonLock );
    KeInitializeSpinLock( &AcpiFatalLock );
    KeInitializeSpinLock( &AcpiUpdateFlagsLock );
    KeInitializeSpinLock( &AcpiGetLock );

    //
    // Initialize the List Entry's
    //
    InitializeListHead( &AcpiPowerDelayedQueueList );
    InitializeListHead( &AcpiPowerQueueList );
    InitializeListHead( &AcpiPowerPhase0List );
    InitializeListHead( &AcpiPowerPhase1List );
    InitializeListHead( &AcpiPowerPhase2List );
    InitializeListHead( &AcpiPowerPhase3List );
    InitializeListHead( &AcpiPowerPhase4List );
    InitializeListHead( &AcpiPowerPhase5List );
    InitializeListHead( &AcpiPowerWaitWakeList );
    InitializeListHead( &AcpiPowerSynchronizeList );
    InitializeListHead( &AcpiPowerNodeList );
    InitializeListHead( &AcpiBuildQueueList );
    InitializeListHead( &AcpiBuildDeviceList );
    InitializeListHead( &AcpiBuildOperationRegionList );
    InitializeListHead( &AcpiBuildPowerResourceList );
    InitializeListHead( &AcpiBuildRunMethodList );
    InitializeListHead( &AcpiBuildSynchronizationList );
    InitializeListHead( &AcpiBuildThermalZoneList );
    InitializeListHead( &AcpiUnresolvedEjectList );
    InitializeListHead( &AcpiThermalList );
    InitializeListHead( &AcpiButtonList );
    InitializeListHead( &AcpiGetListEntry );

    //
    // Initialize the variables/booleans
    //
    AcpiPowerDpcRunning             = FALSE;
    AcpiPowerWorkDone               = FALSE;
    AcpiBuildDpcRunning             = FALSE;
    AcpiBuildFixedButtonEnumerated  = FALSE;
    AcpiBuildWorkDone               = FALSE;
    AcpiFatalOutstanding            = FALSE;
    AcpiGpeDpcRunning               = FALSE;
    AcpiGpeDpcScheduled             = FALSE;
    AcpiGpeWorkDone                 = FALSE;

    //
    // Initialize the LookAside lists.
    //
    ExInitializeNPagedLookasideList(
        &BuildRequestLookAsideList,
        NULL,
        NULL,
        0,
        sizeof(ACPI_BUILD_REQUEST),
        ACPI_DEVICE_POOLTAG,
        (PAGE_SIZE / sizeof(ACPI_BUILD_REQUEST) )
        );
    ExInitializeNPagedLookasideList(
        &RequestLookAsideList,
        NULL,
        NULL,
        0,
        sizeof(ACPI_POWER_REQUEST),
        ACPI_POWER_POOLTAG,
        (PAGE_SIZE * 4 / sizeof(ACPI_POWER_REQUEST) )
        );
    ExInitializeNPagedLookasideList(
        &DeviceExtensionLookAsideList,
        NULL,
        NULL,
        0,
        sizeof(DEVICE_EXTENSION),
        ACPI_DEVICE_POOLTAG,
        64
        );
    ExInitializeNPagedLookasideList(
        &ObjectDataLookAsideList,
        NULL,
        NULL,
        0,
        sizeof(OBJDATA),
        ACPI_OBJECT_POOLTAG,
        (PAGE_SIZE / sizeof(OBJDATA) )
        );
    ExInitializeNPagedLookasideList(
        &PswContextLookAsideList,
        NULL,
        NULL,
        0,
        sizeof(ACPI_WAKE_PSW_CONTEXT),
        ACPI_POWER_POOLTAG,
        16
        );

    //
    // Initialize internal worker
    //
    ACPIInitializeWorker ();

    //
    // Make sure that we have an AddDevice function that will create
    // the basic FDO for this device when it is called
    //
    DriverObject->DriverExtension->AddDevice    = ACPIDispatchAddDevice;

    //
    // All irps will be sent through a single dispatch point
    //
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[ i ] = ACPIDispatchIrp;

    }
    DriverObject->DriverUnload = ACPIUnload;

    //
    // Fill out the Fast Io Detach callback for our bus filter
    //
    RtlZeroMemory(&ACPIFastIoDispatch, sizeof(FAST_IO_DISPATCH)) ;
    ACPIFastIoDispatch.SizeOfFastIoDispatch = sizeof(FAST_IO_DISPATCH) ;
    ACPIFastIoDispatch.FastIoDetachDevice = ACPIFilterFastIoDetachCallback ;
    DriverObject->FastIoDispatch = &ACPIFastIoDispatch ;

    //
    // Initialize some HAL stuff
    //
    AcpiHalDispatchTable.Signature = ACPI_HAL_DISPATCH_SIGNATURE;
    AcpiHalDispatchTable.Version   = ACPI_HAL_DISPATCH_VERSION;
    AcpiHalDispatchTable.AcpipEnableDisableGPEvents =
        &ACPIGpeHalEnableDisableEvents;
    AcpiHalDispatchTable.AcpipInitEnableAcpi        =
        &ACPIEnableInitializeACPI;
    AcpiHalDispatchTable.AcpipGpeEnableWakeEvents   =
        &ACPIWakeEnableWakeEvents;
    HalInitPowerManagement(
        (PPM_DISPATCH_TABLE)(&AcpiHalDispatchTable),
        &PmHalDispatchTable
        );

    return STATUS_SUCCESS;
}

VOID
OSInitializeCallbacks(
    VOID
    )
/*++

Routine Description:

    This routine is called right after the interper has been initialized,
    but before AML code has actually been executed.


Arguments:

    None

Return Value:

    None

--*/
{
    POPREGIONHANDLER    dummy;
#if DBG
    NTSTATUS    status;

    status =
#endif
    AMLIRegEventHandler(
        EVTYPE_OPCODE_EX,
        OP_LOAD,
        ACPICallBackLoad,
        0
        );
#if DBG
    if (!NT_SUCCESS(status)) {
        ACPIBreakPoint();
    }

    status =
#endif
    AMLIRegEventHandler(
        EVTYPE_OPCODE_EX,
        OP_UNLOAD,
        ACPICallBackUnload,
        0
        );
#if DBG
    if (!NT_SUCCESS(status)) {
        ACPIBreakPoint();
    }

    status =
#endif
    AMLIRegEventHandler(
        EVTYPE_DESTROYOBJ,
        0,
        (PFNHND)ACPITableNotifyFreeObject,
        0
        );
#if DBG
    if (!NT_SUCCESS(status)) {
        ACPIBreakPoint();
    }

    status =
#endif
    AMLIRegEventHandler(
        EVTYPE_NOTIFY,
        0,
        NotifyHandler,
        0
        );
#if DBG
    if (!NT_SUCCESS(status)) {
        ACPIBreakPoint();
    }

    status =
#endif
    AMLIRegEventHandler(
        EVTYPE_ACQREL_GLOBALLOCK,
        0,
        GlobalLockEventHandler,
        0
        );
#if DBG
    if (!NT_SUCCESS(status)) {
        ACPIBreakPoint();
    }

    status =
#endif
    AMLIRegEventHandler(
        EVTYPE_CREATE,
        0,
        OSNotifyCreate,
        0
        );
#if DBG
    if (!NT_SUCCESS(status)) {
        ACPIBreakPoint();
    }

    status =
#endif
    AMLIRegEventHandler(
        EVTYPE_FATAL,
        0,
        OSNotifyFatalError,
        0
        );
#if DBG
    if (!NT_SUCCESS(status)) {
        ACPIBreakPoint();
    }
#endif

    //
    // Register internal support of PCI operational regions. Note that
    // we don't specify a region object here because we haven't yet created it
    //
    RegisterOperationRegionHandler(
        NULL,
        EVTYPE_RS_COOKACCESS,
        REGSPACE_PCICFG,   // PCI config space
        (PFNHND)PciConfigSpaceHandler,
        0,
        &dummy);
}

BOOLEAN
OSInterruptVector(
    PVOID   Context
    )
/*++

Routine Description:

    This routine is charged with claiming an Interrupt for the device

Arguments:

    Context - Context Pointer (points to FDO currently)

Return

    TRUE for success

--*/
{
    NTSTATUS                        status;
    PDEVICE_EXTENSION               deviceExtension;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR InterruptDesc;
    ULONG                           Count;

    PAGED_CODE();

    deviceExtension = ACPIInternalGetDeviceExtension( (PDEVICE_OBJECT) Context );

    //
    // Grab the translated interrupt vector from our resource list
    //
    Count = 0;
    InterruptDesc = RtlUnpackPartialDesc(
        CmResourceTypeInterrupt,
        deviceExtension->ResourceList,
        &Count
        );
    if (InterruptDesc == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            " - Could not find interrupt descriptor\n"
            ) );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_ROOT_RESOURCES_FAILURE,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) deviceExtension->ResourceList,
            1
            );

    }

    //
    // Initialize our DPC object
    //
    KeInitializeDpc(
        &(deviceExtension->Fdo.InterruptDpc),
        ACPIInterruptServiceRoutineDPC,
        deviceExtension
        );

    //
    // Now, lets connect ourselves to the interrupt
    //
    status = IoConnectInterrupt(
        &(deviceExtension->Fdo.InterruptObject),
        (PKSERVICE_ROUTINE) ACPIInterruptServiceRoutine,
        deviceExtension,
        NULL,
        InterruptDesc->u.Interrupt.Vector,
        (KIRQL)InterruptDesc->u.Interrupt.Level,
        (KIRQL)InterruptDesc->u.Interrupt.Level,
        LevelSensitive,
        CmResourceShareShared,
        InterruptDesc->u.Interrupt.Affinity,
        FALSE
        );

    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSInterruptVector: Could not connected to interrupt - %#08lx\n",
            status
            ) );
        return FALSE;

    }


    //
    // Tell the HAL directly that we are done with the interrupt init
    // stuff and it can start using the ACPI timer.
    //
    HalAcpiTimerInit(0,0);

    //
    // Done
    //
    return (TRUE);
}

VOID
ACPIAssert (
    ULONG Condition,
    ULONG ErrorCode,
    PCHAR ReplacementText,
    PCHAR SupplementalText,
    ULONG Flags
    )
/*++

Routine Description:

    This is called to allow OS specific code to perform some additional OS
    specific processing for Asserts. After this function returns, the normal
    ASSERT macro will be called

Arguments:

    Condition
    ErrorCode
    ReplacementText
    SupplementalText
    Flags

Return Value:

    NONE

--*/
{
    if (!Condition) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIAssert: \n"
            "    ErrorCode = %08lx Flags = %08lx\n"
            "    ReplacmentText = %s\n"
            "    SupplmentalText = %s\n",
            ErrorCode, Flags,
            ReplacementText,
            SupplementalText
            ) );
        ASSERT(Condition);

    }
    return;
}

PNSOBJ
OSConvertDeviceHandleToPNSOBJ(
    PVOID   DeviceHandle
    )
/*++

Routine Description:

   This function converts a DeviceHandle (which will always be a
   DeviceObject on NT) to a PNSObj handle.

Arguments:

   DeviceHandle -- A DeviceObject whose PNSOBJ we want to determine.

Return Value:

   The PNSOBJ for the given DeviceHandle or NULL if the conversion
   could not be done.

--*/
{
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   deviceExtension;

    deviceObject = (PDEVICE_OBJECT) DeviceHandle;
    ASSERT( deviceObject != NULL );
    if (deviceObject == NULL) {

        return (NULL);

    }

    deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);
    ASSERT( deviceExtension != NULL );
    if (deviceExtension == NULL) {

        return (NULL);

    }

    return deviceExtension->AcpiObject;
}

NTSTATUS
NotifyHalWithMachineStates(
    VOID
    )
/*++

Routine Description:

   This routine marshals the information about C states and
   S states that the HAL needs and then passes it down.

Arguments:

   none

Return Value:

   status

--*/
{
    BOOLEAN             overrideMpSleep = FALSE;
    CHAR                picMethod[]     = "\\_PIC";
    NTSTATUS            status;
    OBJDATA             data;
    PHAL_SLEEP_VAL      sleepVals       = NULL;
    PNSOBJ              pnsobj          = NULL;
    PUCHAR              SleepState[]    = { "\\_S1", "\\_S2", "\\_S3",
                                            "\\_S4", "\\_S5" };
    SYSTEM_POWER_STATE  systemState;
    UCHAR               processor       = 0;
    UCHAR               state;
    ULONG               flags           = 0;
    ULONG               pNum            = 0;

    PAGED_CODE();

    //
    // Notify the HAL with the location of the PBLKs
    //
    while(ProcessorList[pNum] && pNum < ACPI_SUPPORTED_PROCESSORS) {

        //
        // find the number of processors
        //
        pNum++;

    }

    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "NotifyHalWithMachineStates: Number of processors is %d\n",
        pNum
        ) );

    sleepVals = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(HAL_SLEEP_VAL) * 5,
        ACPI_MISC_POOLTAG
        );

    if (!sleepVals) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If there are more than 1 processors (ie: this is an MP machine)
    // and the OverrideMpSleep attribute is set, then we should remember that
    // so that we disallow all S-States other than S0, S4, and S5
    //
    if (AcpiOverrideAttributes & ACPI_OVERRIDE_MP_SLEEP) {

        overrideMpSleep = TRUE;
    }

    //
    // Remember that the only s-states that we support are S0, S4, and S5,
    // by default
    //
    AcpiSupportedSystemStates =
        (1 << PowerSystemWorking) +
        (1 << PowerSystemHibernate) +
        (1 << PowerSystemShutdown);

    //
    // Get the values that the HAL needs for sleeping the machine
    // for each sleep state that this machine supports.
    //
    for (systemState = PowerSystemSleeping1, state = 0;
         state < 5;
         systemState++, state++) {

        if ( ( (systemState == PowerSystemSleeping1) &&
               (AcpiOverrideAttributes & ACPI_OVERRIDE_DISABLE_S1) ) ||
             ( (systemState == PowerSystemSleeping2) &&
               (AcpiOverrideAttributes & ACPI_OVERRIDE_DISABLE_S2) ) ||
             ( (systemState == PowerSystemSleeping3) &&
               (AcpiOverrideAttributes & ACPI_OVERRIDE_DISABLE_S3) )) {

            ACPIPrint( (
                ACPI_PRINT_LOADING,
                "ACPI: SleepState %s disabled due to override\n",
                SleepState[state]
                ) );
            sleepVals[state].Supported = FALSE;
            continue;

        }

        status = AMLIGetNameSpaceObject(SleepState[state], NULL, &pnsobj, 0);
        if ( !NT_SUCCESS(status) ) {

            ACPIPrint( (
                ACPI_PRINT_LOADING,
                "ACPI: SleepState %s not supported\n",
                SleepState[state]
            ) );
            sleepVals[state].Supported = FALSE;
            continue;

        }
        if (overrideMpSleep && systemState < PowerSystemHibernate) {

            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPI: SleepState %s not supported due to override\n",
                SleepState[state]
                ) );
            sleepVals[state].Supported = FALSE;
            continue;

        }

        //
        // Remember that we support this state
        //
        AcpiSupportedSystemStates |= (1 << systemState);
        sleepVals[state].Supported = TRUE;

        //
        // Retrieve the value that will be written into the SLP_TYPa
        // register.
        //
        AMLIEvalPackageElement (pnsobj, 0, &data);
        sleepVals[state].Pm1aVal = (UCHAR)data.uipDataValue;
        AMLIFreeDataBuffs(&data, 1);

        //
        // Retriece the value that will be written in to the SLp_TYPb
        // register
        //
        AMLIEvalPackageElement (pnsobj, 1, &data);
        sleepVals[state].Pm1bVal = (UCHAR)data.uipDataValue;
        AMLIFreeDataBuffs(&data, 1);

    }

    //
    // Notify the HAL
    //
    HalAcpiMachineStateInit(NULL, sleepVals, &InterruptModel);

    ExFreePool(sleepVals);

    //
    // Notify the namespace with the _PIC val.
    //
    if (InterruptModel > 0) {

        status = AMLIGetNameSpaceObject(picMethod,NULL,&pnsobj,0);
        if (!NT_SUCCESS(status)) {

            //
            // The OEM didn't supply a _PIC method.  That's OK.
            // We'll assume that IRQ will somehow work without it.
            //
            return status;
        }

        RtlZeroMemory(&data, sizeof(data));
        data.dwDataType = OBJTYPE_INTDATA;
        data.uipDataValue = InterruptModel;

        status = AMLIEvalNameSpaceObject(pnsobj, NULL, 1, &data);
        if (!NT_SUCCESS(status)) {

            //
            // Failure to evaluate the _PIC method is not OK.
            //
            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_FAILED_PIC_METHOD,
                InterruptModel,
                status,
                (ULONG_PTR) pnsobj
                );
        }
    }

    //
    // Done
    //
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\acpiirp.h ===
typedef NTSTATUS (*ACPICALLBACKROUTINE)(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context,
    IN BOOLEAN        CalledInCompletion
    ) ;

NTSTATUS
ACPIIrpSetPagableCompletionRoutineAndForward(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PIRP                   Irp,
    IN ACPICALLBACKROUTINE    CompletionRoutine,
    IN PVOID                  Context,
    IN BOOLEAN                InvokeOnSuccess,
    IN BOOLEAN                InvokeIfUnhandled,
    IN BOOLEAN                InvokeOnError,
    IN BOOLEAN                InvokeOnCancel
    );

NTSTATUS
ACPIIrpInvokeDispatchRoutine(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PIRP                   Irp,
    IN PVOID                  Context,
    IN ACPICALLBACKROUTINE    CompletionRoutine,
    IN BOOLEAN                InvokeOnSuccess,
    IN BOOLEAN                InvokeIfUnhandled
    );

//
// These functions are private to acpiirp.c
//

typedef struct {

    PDEVICE_OBJECT          DeviceObject ;
    PIRP                    Irp ;
    ACPICALLBACKROUTINE     CompletionRoutine ;
    BOOLEAN                 InvokeOnSuccess ;
    BOOLEAN                 InvokeIfUnhandled ;
    BOOLEAN                 InvokeOnError ;
    BOOLEAN                 InvokeOnCancel ;
    PIO_WORKITEM            IoWorkItem ;
    PVOID                   Context ;

} ACPI_IO_CONTEXT, *PACPI_IO_CONTEXT ;

NTSTATUS
ACPIIrpGenericFilterCompletionHandler(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PIRP                   Irp,
    IN PVOID                  Context
    );

VOID
ACPIIrpCompletionRoutineWorker(
    IN  PDEVICE_OBJECT        DeviceObject,
    IN  PVOID                 Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\amlisupp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    amlisupp.h

Abstract:

    This contains some of the routines to read
    and understand the AMLI library

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"


PSZ gpszOSName = "Microsoft Windows NT";


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIAmliFindObject)
#endif


VOID
ACPIAmliDoubleToName(
    IN  OUT PUCHAR  ACPIName,
    IN      ULONG   DwordID,
    IN      BOOLEAN ConvertToID
    )
/*++

Routine Description:

    Convert the DWORD ID into a 9 character name

Arguments:

    ACPIName    - Pointer to a memory location to fill
    DwordID     - The ID to verify with IsID()?

Return Value:

    None

--*/
{
    USHORT   value;

    //
    // Leading Star
    //
    // Note: This has been left in since this is what Query ID should return:
    //  DeviceID    = ACPI\PNPxxxx
    //  InstanceID  = yyyy
    //  HardwareID  = DeviceID,*PNPxxxx
    //
    if (ConvertToID) {

        *ACPIName = '*';
        ACPIName++;
    }

    //
    // First character of DwordID[2..6]
    //
    *ACPIName = (UCHAR) ( ( (DwordID & 0x007C) >> 2 ) + 'A' - 1);
    ACPIName++;

    //
    // Second Character from DwordID[13..15,0..1]
    //
    *ACPIName = (UCHAR) ( ( (DwordID & 0x3 )<< 3 ) +
        ( (DwordID & 0xE000) >> 13 ) + 'A' - 1);
    ACPIName++;

    //
    // Third Character from dwID[8..12]
    //
    *ACPIName = (UCHAR) ( ( (DwordID >> 8 ) & 0x1F) + 'A' - 1);
    ACPIName++;

    //
    // The rest is made up of the Product ID, which is the HIWORD of the
    // DwordID
    //
    value = (USHORT) (DwordID >> 16);

    //
    // Add to the reset of the string
    //
    sprintf(ACPIName, "%02X%02X",(value & 0xFF ) ,( value >> 8 ));
}


VOID
ACPIAmliDoubleToNameWide(
    IN  OUT PWCHAR  ACPIName,
    IN      ULONG   DwordID,
    IN      BOOLEAN ConvertToID
    )
/*++

Routine Description:

    Convert the DWORD ID into a 9 character name

Arguments:

    ACPIName    - Pointer to a memory location to fill
    DwordID     - The ID to verify with IsID()?

Return Value:

    None

--*/
{
    USHORT   value;

    //
    // Leading Star
    //
    // Note: This has been left in since this is what Query ID should return:
    //  DeviceID    = ACPI\PNPxxxx
    //  InstanceID  = yyyy
    //  HardwareID  = DeviceID,*PNPxxxx
    //
    if (ConvertToID) {

        *ACPIName = L'*';
        ACPIName++;

    }

    //
    // First character of DwordID[2..6]
    //
    *ACPIName = (WCHAR) ( ( (DwordID & 0x007C) >> 2 ) + L'A' - 1);
    ACPIName++;

    //
    // Second Character from DwordID[13..15,0..1]
    //
    *ACPIName = (WCHAR) ( ( (DwordID & 0x3 )<< 3 ) +
        ( (DwordID & 0xE000) >> 13 ) + L'A' - 1);
    ACPIName++;

    //
    // Third Character from dwID[8..12]
    //
    *ACPIName = (WCHAR) ( ( (DwordID >> 8 ) & 0x1F) + L'A' - 1);
    ACPIName++;

    //
    // The rest is made up of the Product ID, which is the HIWORD of the
    // DwordID
    //
    value = (USHORT) (DwordID >> 16);

    //
    // Add to the reset of the string
    //
    swprintf(ACPIName, L"%02X%02X",(value & 0xFF ) ,( value >> 8 ));
}

VOID
EXPORT
AmlisuppCompletePassive(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
/*++

Routine Description:

    This is used as the completion routine for several
    functions in this file that run at passive level.

Arguments:

    AcpiObject  - unused
    Status      - status to be returned to caller
    Result      - unused
    Context     - contains the event to be set

Return Value:

    none

--*/
{
    PRKEVENT    event = &((PAMLISUPP_CONTEXT_PASSIVE)Context)->Event;

    ASSERT(Context);

    ((PAMLISUPP_CONTEXT_PASSIVE)Context)->Status = Status;
    KeSetEvent(event, IO_NO_INCREMENT, FALSE);
}

PNSOBJ
ACPIAmliGetNamedChild(
    IN  PNSOBJ  AcpiObject,
    IN  ULONG   ObjectId
    )
/*++

Routine Description:

    Looks at all the children of AcpiObject and returns
    the one named 'ObjectId'.

Arguments:

    AcpiObject  - Object to search in
    ObjectId    - What we are looking for

Return Value:

    A PNSOBJ, NULL if none

--*/
{
    PNSOBJ  tempObject;

    //
    // Lets try to find a child object
    //
    for (tempObject = NSGETFIRSTCHILD(AcpiObject);
         tempObject != NULL;
         tempObject = NSGETNEXTSIBLING(tempObject)) {

        if (ObjectId == tempObject->dwNameSeg) {

            break;

        }

    }

    return tempObject;
}

PUCHAR
ACPIAmliNameObject(
    IN  PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    Returns a String that describes the objects
    Debug Only

Arguments:

    AcpiOBject  - The object to name

Returns:

    String

--*/
{
    static  UCHAR   buffer[5];

    RtlCopyMemory( &buffer[0], &(AcpiObject->dwNameSeg), 4 );
    buffer[4] = '\0';

    return &(buffer[0]);
}

NTSTATUS
ACPIAmliFindObject(
    IN  PUCHAR  ObjectName,
    IN  PNSOBJ  Scope,
    OUT PNSOBJ  *Object
    )
/*++

Routine Description:

    Finds the first occurrence of an object within a given scope.

Arguments:

    ObjectName  - Name of the object.  (null terminated)

    Scope       - Node to search under

    Object      - Pointer to return value

Returns:

    status

--*/
{
    NTSTATUS    status;
    PNSOBJ      child;
    PNSOBJ      sibling;

    PAGED_CODE();

    status = AMLIGetNameSpaceObject(ObjectName,
                                    Scope,
                                    Object,
                                    NSF_LOCAL_SCOPE);

    if (NT_SUCCESS(status)) {
        return status;
    }

    child = NSGETFIRSTCHILD(Scope);

    if (child) {

        status = ACPIAmliFindObject(ObjectName,
                                    child,
                                    Object);

        if (NT_SUCCESS(status)) {
            return status;
        }
    }

    sibling = NSGETNEXTSIBLING(Scope);

    if (sibling) {

        status = ACPIAmliFindObject(ObjectName,
                                    sibling,
                                    Object);
    }

    return status;
}

NTSTATUS
ACPIAmliGetFirstChild(
    IN  PUCHAR  ObjectName,
    OUT PNSOBJ  *Object)
/*++

Routine Description:

    This routine is called to get the first nsobject which is of type 'Device'
    that lives under ObjectName

Arguments:

    ObjectName  - The parent of the child we are looking for
    Object      - Where to save a pointer to the PNSOBJ

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PNSOBJ      parentObj;

    status = AMLIGetNameSpaceObject(
        ObjectName,
        NULL,
        &parentObj,
        0
        );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    *Object = parentObj->pnsFirstChild;
    if (*Object == NULL ) {

        return STATUS_OBJECT_NAME_NOT_FOUND;

    }

    if ( NSGETOBJTYPE(*Object) == OBJTYPE_DEVICE) {

        return STATUS_SUCCESS;

    }

    *Object = (PNSOBJ) (*Object)->list.plistNext;
    parentObj = parentObj->pnsFirstChild;
    while (*Object != parentObj) {

        if ( NSGETOBJTYPE( *Object ) == OBJTYPE_DEVICE) {

            return STATUS_SUCCESS;

        }
        *Object = (PNSOBJ) (*Object)->list.plistNext;

    }

    *Object = NULL;
    return STATUS_OBJECT_NAME_NOT_FOUND;

}

NTSTATUS
ACPIAmliBuildObjectPathname(
    IN     PNSOBJ   ACPIObject,
    OUT    PUCHAR   *ConstructedPathName
    )
/*++

Routine Description:

    This function takes an ACPI node and constructs the full path name with
    the parent/children seperated by '.'s, spaces with '*'s. e.g. (we smack
    off the initial '\___'.

    _SB*.PCI0.DOCK

Arguments:

    ACPIObject          - Object to start the enumeration at.
    ConstructedPathName - Allocated from the paged pool.

Return Value:

    NTSTATUS

--*/
{
    PNSOBJ      currentAcpiObject, nextAcpiObject ;
    ULONG       nDepth, i, j ;
    PUCHAR      objectPathname ;

    ASSERT(ACPIObject) ;

    //
    // First, calculate the size of data we must allocate
    //
    nDepth=0 ;
    currentAcpiObject=ACPIObject ;
    while(1) {

        nextAcpiObject = NSGETPARENT(currentAcpiObject);
        if (!nextAcpiObject) {

            break;

        }
        nDepth++;
        currentAcpiObject = nextAcpiObject;

    }

    objectPathname = (PUCHAR) ExAllocatePoolWithTag(
        NonPagedPool,
        (nDepth * 5) + 1,
        ACPI_STRING_POOLTAG
        );
    if (!objectPathname) {

        return STATUS_INSUFFICIENT_RESOURCES ;

    }

    objectPathname[ nDepth * 5 ] = '\0';
    j = nDepth;
    currentAcpiObject = ACPIObject;

    while(1) {

        nextAcpiObject = NSGETPARENT(currentAcpiObject);
        if (!nextAcpiObject) {

            break;

        }

        j--;
        RtlCopyMemory(
            &objectPathname[ (j * 5) ],
            &(currentAcpiObject->dwNameSeg),
            sizeof(NAMESEG)
            );
        for(i = 0; i < 4; i++) {

            if (objectPathname[ (j * 5) + i ] == '\0' ) {

                objectPathname[ (j * 5) + i ] = '*';

            }

        }
        objectPathname[ (j * 5) + 4 ] = '.';
        currentAcpiObject = nextAcpiObject;

    }

    //
    // Smack of trailing '.'
    //
    if (nDepth) {

        objectPathname[ (nDepth * 5) - 1 ] = '\0';

    }

    *ConstructedPathName = objectPathname;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\buildsrc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    buildsrc.h

Abstract:

    This module contains the detector for the NT driver.
    This module makes extensive calls into the AMLI library

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July 9, 1997    - Complete Rewrite
    Feb 13, 1998    - Another rewrite to make code ASYNC

--*/

#ifndef _BUILDSRC_H_
#define _BUILDSRC_H_

    //
    // Callback function for build requests
    //
    typedef VOID ( *PACPI_BUILD_CALLBACK )(PVOID, PVOID, NTSTATUS);

    typedef struct _ACPI_BUILD_REQUEST {

        //
        // This is the list entry that the request is currently queued on
        //
        LIST_ENTRY              ListEntry;

        //
        // We believe in signatures
        //
        ULONG                   Signature;

        //
        // We belive in flags
        //
        union {
            ULONG                   Flags;
            struct {
                ULONG               Device:1;
                ULONG               Sync:1;
                ULONG               Run:1;
                ULONG               ReleaseReference:1;
                ULONG               Reserved1:8;
                ULONG               ValidTarget:1;
                ULONG               Reserved2:19;
            } UFlags;
        };

        //
        // This the current state of the request. It can only be touched
        // from the InterlockedXXX functions
        //
        ULONG                   WorkDone;

        //
        // This is the current state of the request. It can be read safely
        // from within any of the processing routines. It can only be written
        // from within the ACPIBuildProcessXXXList() functions
        //
        ULONG                   CurrentWorkDone;

        //
        // This is the state that we should transition to next, if we succeed
        // at the current state
        //
        ULONG                   NextWorkDone;

        //
        // This is the object associated with this request
        //
        PVOID                   BuildContext;

        //
        // The current status of the request
        //
        NTSTATUS                Status;

        //
        // Remember what the most current control method that we ran was
        //
        PNSOBJ                  CurrentObject;

        //
        // We may want to have a callback..
        //
        PACPI_BUILD_CALLBACK    CallBack;

        //
        // And we should have a context as well
        //
        PVOID                   CallBackContext;

        //
        // At this point, the contends depend on what kind of request we
        // are processing.
        //
        union {

            //
            // This is the structure for a device request
            //
            struct {

                //
                // Some local storage for result from an AMLI call
                //
                OBJDATA                 ResultData;

            } DeviceRequest;

            struct {

                //
                // We need to remember the name of the control method
                //
                union {
                    ULONG                   ControlMethodName;
                    UCHAR                   ControlMethodNameAsUchar[4];
                };

                //
                // We believe in flags while recursing
                //
                union {
                    ULONG                   Flags;
                    struct {
                        ULONG               CheckStatus:1;
                        ULONG               MarkIni:1;
                        ULONG               Recursive:1;
                        ULONG               CheckWakeCount:1;
                        ULONG               RegOn:1;
                        ULONG               RegOff:1;
                        ULONG               StopAtBridges:1;
                        ULONG               Reserved:25;
                    } UFlags;
                };

            } RunRequest;

            struct {

                //
                // We need to know which list we require to be empty
                //
                PLIST_ENTRY             SynchronizeListEntry;

                //
                // We can keep track of the method name that we are
                // trying to sync with
                //
                union {
                    ULONG                   SynchronizeMethodName;
                    UCHAR                   SynchronizeMethodNameAsUchar[4];
                };

                //
                // We believe in flags for this structure
                //
                union {
                    ULONG                   Flags;
                    struct {
                        ULONG               HasMethod:1;
                        ULONG               Reserved:31;
                    } UFlags;
                };

            } SynchronizeRequest;

        };

        //
        // This is for scratch storage. Note that we use this space to
        // indicate which is the appropriate list that the request should
        // be moved onto
        //
        union {

            //
            // Keep Enough space for one integer
            //
            ULONG       Integer;

            //
            // Or one string pointer
            //
            PUCHAR      String;

            //
            // This is a pointer to the head of the list that this request should
            // be moved onto
            //
            PLIST_ENTRY TargetListEntry;

        };

    } ACPI_BUILD_REQUEST, *PACPI_BUILD_REQUEST;

    //
    // These are the flags that are used for BuildRequest
    //
    #define BUILD_REQUEST_DEVICE            0x0001
    #define BUILD_REQUEST_SYNC              0x0002
    #define BUILD_REQUEST_RUN               0x0004
    #define BUILD_REQUEST_RELEASE_REFERENCE 0x0008
    #define BUILD_REQUEST_VALID_TARGET      0x1000

    //
    // These are the flags that we use in the RunRequest case
    //
    #define RUN_REQUEST_CHECK_STATUS        0x01
    #define RUN_REQUEST_MARK_INI            0x02
    #define RUN_REQUEST_RECURSIVE           0x04
    #define RUN_REQUEST_CHECK_WAKE_COUNT    0x08
    #define RUN_REQUEST_REG_METHOD_ON       0x10
    #define RUN_REQUEST_REG_METHOD_OFF      0x20
    #define RUN_REQUEST_STOP_AT_BRIDGES     0x40

    //
    // These are the flags that we use in the SyncRequest case
    //
    #define SYNC_REQUEST_HAS_METHOD         0x1

    //
    // Prototype function pointer
    //
    typedef NTSTATUS (*PACPI_BUILD_FUNCTION)( IN PACPI_BUILD_REQUEST );

    //
    // These are variables exported from buildsrc.c
    //
    extern  BOOLEAN                 AcpiBuildDpcRunning;
    extern  BOOLEAN                 AcpiBuildFixedButtonEnumerated;
    extern  BOOLEAN                 AcpiBuildWorkDone;
    extern  KSPIN_LOCK              AcpiBuildQueueLock;
    extern  LIST_ENTRY              AcpiBuildQueueList;
    extern  LIST_ENTRY              AcpiBuildPowerResourceList;
    extern  LIST_ENTRY              AcpiBuildDeviceList;
    extern  LIST_ENTRY              AcpiBuildOperationRegionList;
    extern  LIST_ENTRY              AcpiBuildRunMethodList;
    extern  LIST_ENTRY              AcpiBuildSynchronizationList;
    extern  LIST_ENTRY              AcpiBuildThermalZoneList;
    extern  KDPC                    AcpiBuildDpc;
    extern  NPAGED_LOOKASIDE_LIST   BuildRequestLookAsideList;

    //
    // Because its rather annoying to base everything off the WORK_DONE_STEP_XX
    // defines (espacially if you have to renumber them), these defines are
    // used to abstract it out
    //
    #define WORK_DONE_ADR           WORK_DONE_STEP_1
    #define WORK_DONE_ADR_OR_HID    WORK_DONE_STEP_0
    #define WORK_DONE_CID           WORK_DONE_STEP_4
    #define WORK_DONE_CRS           WORK_DONE_STEP_16
    #define WORK_DONE_EJD           WORK_DONE_STEP_6
    #define WORK_DONE_HID           WORK_DONE_STEP_2
    #define WORK_DONE_PR0           WORK_DONE_STEP_10
    #define WORK_DONE_PR1           WORK_DONE_STEP_12
    #define WORK_DONE_PR2           WORK_DONE_STEP_14
    #define WORK_DONE_PRW           WORK_DONE_STEP_8
    #define WORK_DONE_PSC           WORK_DONE_STEP_18
    #define WORK_DONE_STA           WORK_DONE_STEP_5
    #define WORK_DONE_UID           WORK_DONE_STEP_3


    //
    // These are the function prototypes
    //
    VOID
    ACPIBuildCompleteCommon(
        IN  PULONG  OldWorkDone,
        IN  ULONG   NewWorkDone
        );

    VOID EXPORT
    ACPIBuildCompleteGeneric(
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    ObjectData,
        IN  PVOID       Context
        );

    VOID EXPORT
    ACPIBuildCompleteMustSucceed(
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    ObjectData,
        IN  PVOID       Context
        );

    VOID
    ACPIBuildDeviceDpc(
        IN  PKDPC       Dpc,
        IN  PVOID       DpcContext,
        IN  PVOID       SystemArgument1,
        IN  PVOID       SystemArgument2
        );

    NTSTATUS
    ACPIBuildDeviceExtension(
        IN  PNSOBJ              CurrentObject,
        IN  PDEVICE_EXTENSION   ParentDeviceExtension,
        OUT PDEVICE_EXTENSION   *ReturnExtension
        );

    NTSTATUS
    ACPIBuildDevicePowerNodes(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PNSOBJ              ResultObject,
        IN  POBJDATA            ResultData,
        IN  DEVICE_POWER_STATE  DeviceState
        );

    NTSTATUS
    ACPIBuildDeviceRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PACPI_BUILD_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  BOOLEAN                 RunDPC
        );

    NTSTATUS
    ACPIBuildDockExtension(
        IN  PNSOBJ                  CurrentObject,
        IN  PDEVICE_EXTENSION       ParentExtension
        );

    NTSTATUS
    ACPIBuildFilter(
        IN  PDRIVER_OBJECT      DriverObject,
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PDEVICE_OBJECT      PdoObject
        );

    NTSTATUS
    ACPIBuildFixedButtonExtension(
        IN  PDEVICE_EXTENSION   ParentExtension,
        IN  PDEVICE_EXTENSION   *ResultExtnesion
        );

    NTSTATUS
    ACPIBuildFlushQueue(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIBuildMissingChildren(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIBuildMissingEjectionRelations(
        );

    VOID
    ACPIBuildNotifyEvent(
        IN  PVOID           BuildContext,
        IN  PVOID           Context,
        IN  NTSTATUS        Status
        );

    NTSTATUS
    ACPIBuildPdo(
        IN  PDRIVER_OBJECT      DriverObject,
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PDEVICE_OBJECT      ParentPdoObject,
        IN  BOOLEAN             CreateAsFilter
        );

    NTSTATUS
    ACPIBuildPowerResourceExtension(
        IN  PNSOBJ                  PowerResource,
        OUT PACPI_POWER_DEVICE_NODE *ReturnNode
        );

    NTSTATUS
    ACPIBuildPowerResourceRequest(
        IN  PACPI_POWER_DEVICE_NODE PowerNode,
        IN  PACPI_BUILD_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  BOOLEAN                 RunDPC
        );

    NTSTATUS
    ACPIBuildProcessDeviceFailure(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDeviceGenericEval(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDeviceGenericEvalStrict(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseAdr(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseAdrOrHid(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseCid(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseCrs(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseEjd(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseHid(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhasePr0(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhasePr1(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhasePr2(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhasePrw(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhasePsc(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseSta(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseUid(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessGenericComplete(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessGenericList(
        IN  PLIST_ENTRY             ListEntry,
        IN  PACPI_BUILD_FUNCTION    *DispatchTable
        );

    NTSTATUS
    ACPIBuildProcessorExtension(
        IN  PNSOBJ                  ProcessorObject,
        IN  PDEVICE_EXTENSION       ParentExtension,
        IN  PDEVICE_EXTENSION       *ResultExtension,
        IN  ULONG                   ProcessorIndex
        );

    NTSTATUS
    ACPIBuildProcessorRequest(
        IN  PDEVICE_EXTENSION       ProcessorExtension,
        IN  PACPI_BUILD_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  BOOLEAN                 RunDPC
        );

    NTSTATUS
    ACPIBuildProcessPowerResourceFailure(
        IN  PACPI_BUILD_REQUEST     BuidlRequest
        );

    NTSTATUS
    ACPIBuildProcessPowerResourcePhase0(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessPowerResourcePhase1(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessQueueList(
        VOID
        );

    NTSTATUS
    ACPIBuildProcessRunMethodPhaseCheckBridge(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessRunMethodPhaseCheckSta(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessRunMethodPhaseRecurse(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessRunMethodPhaseRunMethod(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessSynchronizationList(
        IN  PLIST_ENTRY             ListEntry
        );

    NTSTATUS
    ACPIBuildProcessThermalZonePhase0(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildRegRequest(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PACPI_BUILD_CALLBACK    CallBack
        );

    NTSTATUS
    ACPIBuildRegOffRequest(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PACPI_BUILD_CALLBACK    CallBack
        );

    NTSTATUS
    ACPIBuildRegOnRequest(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PACPI_BUILD_CALLBACK    CallBack
        );

    NTSTATUS
    ACPIBuildRunMethodRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PACPI_BUILD_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  ULONG                   MethodName,
        IN  ULONG                   MethodFlags,
        IN  BOOLEAN                 RunDPC
        );

    NTSTATUS
    ACPIBuildSurpriseRemovedExtension(
        IN  PDEVICE_EXTENSION       DeviceExtension
        );

    NTSTATUS
    ACPIBuildSynchronizationRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PACPI_BUILD_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  PLIST_ENTRY             SynchronizeListEntry,
        IN  BOOLEAN                 RunDPC
        );

    NTSTATUS
    ACPIBuildThermalZoneExtension(
        IN  PNSOBJ                  ThermalObject,
        IN  PDEVICE_EXTENSION       ParentExtension,
        IN  PDEVICE_EXTENSION       *ResultExtension
        );

    NTSTATUS
    ACPIBuildThermalZoneRequest(
        IN  PDEVICE_EXTENSION       ThermalExtension,
        IN  PACPI_BUILD_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  BOOLEAN                 RunDPC
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\buildsrc.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    buildsrc.c

Abstract:

    This module is used to 'build' associations and new device objects.
    It contains functionality that was within detect.c but split to make
    the files more readable

    Someone asked me to describe how the building of a device extension
    works


                            PhaseAdrOrHid
                                  |
              ------------------------------------------------
              |                                              |
          PhaseAdr                                       PhaseUid
              |                   |--------------------------|
              |-------------------|                      PhaseHid
                                  |--------------------------|
                                  |                      PhaseCid
                                  |--------------------------|
                                  |
                              PhaseSta
                                  |
                              PhaseEjd
                                  |
                                  ---------------------------|
                                  |                      PhaseCrs
                                  ---------------------------|
                              PhasePrw
                                  |
                              PhasePr0
                                  |
                              PhasePr1
                                  |
                              PhasePr2
                                  |
             ----------------------
             |                    |
             |                 PhasePsc
             |--------------------|
             |
         PhasePsc+1

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July 7, 1997    - Complete Rewrite

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIBuildFlushQueue)
#endif

//
// This is the variable that indicates wether or not the BUILD DPC is running
//
BOOLEAN                 AcpiBuildDpcRunning;

//
// This is set to true if we have done the fixed button enumeration
//
BOOLEAN                 AcpiBuildFixedButtonEnumerated;

//
// This is the variable that indicates wether or not the BUILD DPC has
// completed real work
//
BOOLEAN                 AcpiBuildWorkDone;

//
// This is the lock used to the entry queue
//
KSPIN_LOCK              AcpiBuildQueueLock;

//
// This is the list that requests are queued onto. You must be holding the
// QueueLock to access this list
//
LIST_ENTRY              AcpiBuildQueueList;

//
// This is the list for Devices
//
LIST_ENTRY              AcpiBuildDeviceList;

//
// This is the list for Operation Regions
//
LIST_ENTRY              AcpiBuildOperationRegionList;

//
// This is the list for Power Resources
//
LIST_ENTRY              AcpiBuildPowerResourceList;

//
// This is the list entry for the running Control Methods
//
LIST_ENTRY              AcpiBuildRunMethodList;

//
//
// This is the list for Synchronization with external (to the DPC anyways)
// threads. Items in this list are blocked on an event.
//
LIST_ENTRY              AcpiBuildSynchronizationList;

//
// This is the list for Thermal Zones
//
LIST_ENTRY              AcpiBuildThermalZoneList;

//
// This is what we use to queue up the DPC
//
KDPC                    AcpiBuildDpc;

//
// This is the list that we use to pre-allocate storage for requests
//
NPAGED_LOOKASIDE_LIST   BuildRequestLookAsideList;

//
// This is the table used to map functions for the Device case. The indices
// are based on the WORK_DONE_xxx fields
//
PACPI_BUILD_FUNCTION    AcpiBuildDeviceDispatch[] = {
    ACPIBuildProcessGenericComplete,                // WORK_DONE_COMPLETE
    NULL,                                           // WORK_DONE_PENDING
    ACPIBuildProcessDeviceFailure,                  // WORK_DONE_FAILURE
    ACPIBuildProcessDevicePhaseAdrOrHid,            // WORK_DONE_STEP_ADR_OR_UID
    ACPIBuildProcessDevicePhaseAdr,                 // WORK_DONE_STEP_ADR
    ACPIBuildProcessDevicePhaseHid,                 // WORK_DONE_STEP_HID
    ACPIBuildProcessDevicePhaseUid,                 // WORK_DONE_STEP_UID
    ACPIBuildProcessDevicePhaseCid,                 // WORK_DONE_STEP_CID
    ACPIBuildProcessDevicePhaseSta,                 // WORK_DONE_STEP_STA
    ACPIBuildProcessDeviceGenericEvalStrict,        // WORK_DONE_STEP_EJD
    ACPIBuildProcessDevicePhaseEjd,                 // WORK_DONE_STEP_EJD + 1
    ACPIBuildProcessDeviceGenericEvalStrict,        // WORK_DONE_STEP_PRW
    ACPIBuildProcessDevicePhasePrw,                 // WORK_DONE_STEP_PRW + 1
    ACPIBuildProcessDeviceGenericEvalStrict,        // WORK_DONE_STEP_PR0
    ACPIBuildProcessDevicePhasePr0,                 // WORK_DONE_STEP_PR0 + 1
    ACPIBuildProcessDeviceGenericEvalStrict,        // WORK_DONE_STEP_PR1
    ACPIBuildProcessDevicePhasePr1,                 // WORK_DONE_STEP_PR1 + 1
    ACPIBuildProcessDeviceGenericEvalStrict,        // WORK_DONE_STEP_PR2
    ACPIBuildProcessDevicePhasePr2,                 // WORK_DONE_STEP_PR2 + 1
    ACPIBuildProcessDeviceGenericEvalStrict,        // WORK_DONE_STEP_CRS
    ACPIBuildProcessDevicePhaseCrs,                 // WORK_DONE_STEP_CRS + 1
    ACPIBuildProcessDeviceGenericEval,              // WORK_DONE_STEP_PSC
    ACPIBuildProcessDevicePhasePsc,                 // WORK_DONE_STEP_PSC + 1
};

//
// This is the table that is used to map the level of WorkDone with the
// object that we are currently looking for
//
ULONG                   AcpiBuildDevicePowerNameLookup[] = {
    0,          // WORK_DONE_COMPLETE
    0,          // WORK_DONE_PENDING
    0,          // WORK_DONE_FAILURE
    0,          // WORK_DONE_ADR_OR_HID
    0,          // WORK_DONE_ADR
    0,          // WORK_DONE_HID
    0,          // WORK_DONE_UID
    0,          // WORK_DONE_CID
    0,          // WORK_DONE_STA
    PACKED_EJD, // WORK_DONE_EJD
    0,          // WORK_DONE_EJD + 1
    PACKED_PRW, // WORK_DONE_PRW
    0,          // WORK_DONE_PRW + 1
    PACKED_PR0, // WORK_DONE_PR0
    0,          // WORK_DONE_PR0 + 1
    PACKED_PR1, // WORK_DONE_PR1
    0,          // WORK_DONE_PR1 + 1
    PACKED_PR2, // WORK_DONE_PR2
    0,          // WORK_DONE_PR2 + 1
    PACKED_CRS, // WORK_DONE_CRS
    0,          // WORK_DONE_CRS + 1
    PACKED_PSC, // WORK_DONE_PSC
    0,          // WORK_DONE_PSC + 1
};

//
// We aren't using the Operation Region dispatch point yet
//
PACPI_BUILD_FUNCTION    AcpiBuildOperationRegionDispatch[] = {
    ACPIBuildProcessGenericComplete,                // WORK_DONE_COMPLETE
    NULL,                                           // WORK_DONE_PENDING
    NULL,                                           // WORK_DONE_FAILURE
    NULL                                            // WORK_DONE_STEP_0
};

//
// This is the table used to map functions for the PowerResource case.
// The indices are based on the WORK_DONE_xxx fields
//
PACPI_BUILD_FUNCTION    AcpiBuildPowerResourceDispatch[] = {
    ACPIBuildProcessGenericComplete,                // WORK_DONE_COMPLETE
    NULL,                                           // WORK_DONE_PENDING
    ACPIBuildProcessPowerResourceFailure,           // WORK_DONE_FAILURE
    ACPIBuildProcessPowerResourcePhase0,            // WORK_DONE_STEP_0
    ACPIBuildProcessPowerResourcePhase1             // WORK_DONE_STEP_1
};

//
// This is the table used to map functions for the RunMethod case.
// The indices are based on the WORK_DONE_xxx fields
//
PACPI_BUILD_FUNCTION    AcpiBuildRunMethodDispatch[] = {
    ACPIBuildProcessGenericComplete,                // WORK_DONE_COMPLETE,
    NULL,                                           // WORK_DONE_PENDING
    NULL,                                           // WORK_DONE_FAILURE
    ACPIBuildProcessRunMethodPhaseCheckSta,         // WORK_DONE_STEP_0
    ACPIBuildProcessRunMethodPhaseCheckBridge,      // WORK_DONE_STEP_1
    ACPIBuildProcessRunMethodPhaseRunMethod,        // WORK_DONE_STEP_2
    ACPIBuildProcessRunMethodPhaseRecurse           // WORK_DONE_STEP_3
};

//
// This is the table used to map functions for the ThermalZone case.
// The indices are based on the WORK_DONE_xxx fields
//
PACPI_BUILD_FUNCTION    AcpiBuildThermalZoneDispatch[] = {
    ACPIBuildProcessGenericComplete,                // WORK_DONE_COMPLETE
    NULL,                                           // WORK_DONE_PENDING
    NULL,                                           // WORK_DONE_FAILURE
    ACPIBuildProcessThermalZonePhase0               // WORK_DONE_STEP_0
};

VOID
ACPIBuildCompleteCommon(
    IN  PULONG  OldWorkDone,
    IN  ULONG   NewWorkDone
    )
/*++

Routine Description:

    Since the completion routines all have to do some bit of common work to
    get the DPC firing again, this routine reduces the code duplication

Arguments:

    OldWorkDone - Pointer to the old amount of work done
    NewWorkDone - The new amount of work that has been completed

    NOTENOTE: There is an implicit assumption that the current value of
              WorkDone in the request is WORK_DONE_PENDING. If that is
              not the case, we will fail to transition to the next stage,
              which means that we will loop forever.

Return Value:

    None

--*/
{
    KIRQL   oldIrql;

    //
    // Update the state of the request
    //
    InterlockedCompareExchange( OldWorkDone, NewWorkDone,WORK_DONE_PENDING);

    //
    // We need this lock to look at the following variables
    //
    KeAcquireSpinLock( &AcpiBuildQueueLock, &oldIrql );

    //
    // No matter what, work was done
    //
    AcpiBuildWorkDone = TRUE;

    //
    // Is the DPC already running?
    //
    if (!AcpiBuildDpcRunning) {

        //
        // Better make sure that it does then
        //
        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiBuildQueueLock, oldIrql );

}

VOID EXPORT
ACPIBuildCompleteGeneric(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This is a generic completion handler. If the interperter has successfully
    execute the method, it completes the request to the next desired WORK_DONE,
    otherwise, it fails the request

Arguments:

    AcpiObject  - Points to the control that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - PACPI_BUILD_REQUEST

Return Value:

    VOID

--*/
{
    PACPI_BUILD_REQUEST buildRequest    = (PACPI_BUILD_REQUEST) Context;
    ULONG               nextWorkDone    = buildRequest->NextWorkDone;

    //
    // Device what state we should transition to next
    //
    if (!NT_SUCCESS(Status)) {

        //
        // Remember why we failed, but do not mark the request as being failed
        //
        buildRequest->Status = Status;

    }

    //
    // Note: we don't have a race condition here because only one
    // routine can be processing a request at any given time. Thus it
    // is safe for us to specify a new next phase
    //
    buildRequest->NextWorkDone = WORK_DONE_FAILURE;

    //
    // Transition to the next stage
    //
    ACPIBuildCompleteCommon(
        &(buildRequest->WorkDone),
        nextWorkDone
        );

}

VOID EXPORT
ACPIBuildCompleteMustSucceed(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This is a generic completion handler. If the interperter has successfully
    execute the method, it completes the request to the next desired WORK_DONE,
    otherwise, it fails the request

Arguments:

    AcpiObject  - Points to the control that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - PACPI_BUILD_REQUEST

Return Value:

    VOID

--*/
{
    PACPI_BUILD_REQUEST buildRequest    = (PACPI_BUILD_REQUEST) Context;
    ULONG               nextWorkDone    = buildRequest->NextWorkDone;

    //
    // Device what state we should transition to next
    //
    if (!NT_SUCCESS(Status)) {

        //
        // Remember why we failed, and mark the request as being failed
        //
        buildRequest->Status = Status;

        //
        // Death
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_FAILED_MUST_SUCCEED_METHOD,
            (ULONG_PTR) AcpiObject,
            Status,
            (AcpiObject ? AcpiObject->dwNameSeg : 0)
            );

    } else {

        //
        // Note: we don't have a race condition here because only one
        // routine can be processing a request at any given time. Thus it
        // is safe for us to specify a new next phase
        //
        buildRequest->NextWorkDone = WORK_DONE_FAILURE;

        //
        // Transition to the next stage
        //
        ACPIBuildCompleteCommon(
            &(buildRequest->WorkDone),
            nextWorkDone
            );

    }

}

VOID
ACPIBuildDeviceDpc(
    IN  PKDPC   Dpc,
    IN  PVOID   DpcContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    )
/*++

Routine Description:

    This routine is where all of the device extension related work is done.
    It looks at queued requests and processes them as appropriate.

    READ THIS:

        The design of this DPC is such that it goes out and tries to find
        work to do. Only if it finds no work does it stop. For this reason,
        one *cannot* use a 'break' statement within the main 'do - while()'
        loop. A continue must be use. Additionally, the code cannot make
        assumptions that at a certain point, that any of the lists are assumed
        to be empty. The code *must* use the IsListEmpty() macro to ensure
        that lists that should be empty are in fact empty.

Arguments:

    None used

Return Value:

    VOID

--*/
{
    NTSTATUS    status;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( DpcContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    //
    // First step is to acquire the DPC Lock, and check to see if another
    // DPC is already running
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );
    if (AcpiBuildDpcRunning) {

        //
        // The DPC is already running, so we need to exit now
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );
        return;

    }

    //
    // Remember that the DPC is now running
    //
    AcpiBuildDpcRunning = TRUE;

    //
    // We must try to do *some* work
    //
    do {

        //
        // Assume that we won't do any work
        //
        AcpiBuildWorkDone = FALSE;

        //
        // If there are items in the Request Queue, then move them to the
        // proper list
        //
        if (!IsListEmpty( &AcpiBuildQueueList ) ) {

            //
            // Sort the list
            //
            ACPIBuildProcessQueueList();

        }

        //
        // We can release the spin lock now
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

        //
        // If there are items in the Run Method list, then process the
        // list
        //
        if (!IsListEmpty( &AcpiBuildRunMethodList ) ) {

            //
            // We actually care what this call returns. The reason we do
            // is that we want all of the control methods to be run before
            // we do any of the following steps
            //
            status = ACPIBuildProcessGenericList(
                &AcpiBuildRunMethodList,
                AcpiBuildRunMethodDispatch
                );

            //
            // We must own the spin lock before we do the following...
            //
            KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

            //
            // If we got back STATUS_PENDING, that means that there's
            // a method queued in the interpreter somewhere. This will
            // cause the DPC to (eventually) become scheduled again.
            // That means that we don't have to do anything special to
            // handle it.
            //
            if (status == STATUS_PENDING) {

                continue;

            }

            //
            // The case that is special is where we are do get STATUS_SUCCESS
            // back. This indicates that we've drained the list. The little
            // fly in the ointment is that we might have scheduled other
            // run requests, but those are stuck in the BuildQueue list. So
            // what we need to do here is check to see if the BuildQueue list
            // is non-empty and if it is, set the AcpiBuildWorkDone to TRUE
            // so that we iterage again (and move the elements to the proper
            // list).
            //
            if (!IsListEmpty( &AcpiBuildQueueList) ) {

                AcpiBuildWorkDone = TRUE;
                continue;

            }

            //
            // If we've reached this point, then the Run list must be complete
            // and there must be no items in the BuildQueue list. This means
            // that's its safe to drop the lock and continue
            //
            KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

        }

        //
        // If there are items in the Operation Region list, then process
        // the list
        //
        if (!IsListEmpty( &AcpiBuildOperationRegionList ) ) {

            //
            // Since we don't block on this list --- ie: we can create
            // operation regions at any time that we want, we don't care what
            // this function returns.
            //
            status = ACPIBuildProcessGenericList(
                &AcpiBuildOperationRegionList,
                AcpiBuildOperationRegionDispatch
                );

        }

        //
        // If there are items in the Power Resource list, then process
        // the list
        //
        if (!IsListEmpty( &AcpiBuildPowerResourceList ) ) {

            //
            // We actually care what this call returns. The reason we do
            // is that we want all of the power resources to be built before
            // we do any of the following steps
            //
            status = ACPIBuildProcessGenericList(
                &AcpiBuildPowerResourceList,
                AcpiBuildPowerResourceDispatch
                );
            if (status == STATUS_PENDING) {

                //
                // We must own the spinlock before we continue
                //
                KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );
                continue;

            }

        }

        //
        // If there are items in Device list, then process the list
        //
        if (!IsListEmpty( &AcpiBuildDeviceList ) ) {

            //
            // Since we don't block on this list --- ie we can create
            // devices at any time that we want, we don't care what this
            // function returns.
            //
            status = ACPIBuildProcessGenericList(
                &AcpiBuildDeviceList,
                AcpiBuildDeviceDispatch
                );

        }

        //
        // If there are items in the Thermal list, then process the list
        //
        if (!IsListEmpty( &AcpiBuildThermalZoneList ) ) {

            //
            // Since we don't block on this list --- ie we can create
            // thermal zones at any time that we want, we don't care what this
            // function returns.
            //
            status = ACPIBuildProcessGenericList(
                &AcpiBuildThermalZoneList,
                AcpiBuildThermalZoneDispatch
                );

        }

        //
        // If we have emptied out all the lists, then we can issue the
        // synchronization requests
        //
        if (IsListEmpty( &AcpiBuildDeviceList )             &&
            IsListEmpty( &AcpiBuildOperationRegionList)     &&
            IsListEmpty( &AcpiBuildPowerResourceList)       &&
            IsListEmpty( &AcpiBuildRunMethodList)           &&
            IsListEmpty( &AcpiBuildThermalZoneList ) ) {

            //
            // Check to see if we have any devices in the Delayed queue for
            // the Power DPC. Note that we have to own the power lock for
            // this, so claim it now
            //
            KeAcquireSpinLockAtDpcLevel( &AcpiPowerQueueLock );
            if (!IsListEmpty( &AcpiPowerDelayedQueueList) ) {

                //
                // Move the contents of the list over
                //
                ACPIInternalMoveList(
                    &AcpiPowerDelayedQueueList,
                    &AcpiPowerQueueList
                    );

                //
                // Schedule the DPC, if necessary
                //
                if (!AcpiPowerDpcRunning) {

                    KeInsertQueueDpc( &AcpiPowerDpc, 0, 0 );

                }

            }
            KeReleaseSpinLockFromDpcLevel( &AcpiPowerQueueLock );

        }

        //
        // This is our chance to look at the synchronization list and
        // see if some of the events have occured
        //
        if (!IsListEmpty( &AcpiBuildSynchronizationList) ) {

            //
            // Since we don't block on this list --- ie we can notify the
            // system that the lists are empty at any time that we want,
            // we don't care about what this function returns
            //
            status = ACPIBuildProcessSynchronizationList(
                &AcpiBuildSynchronizationList
                );

        }

        //
        // We need the lock again, since we are about to check to see if
        // we have completed some work
        //
        KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

    } while ( AcpiBuildWorkDone );

    //
    // The DPC is no longer running
    //
    AcpiBuildDpcRunning = FALSE;

    //
    // We no longer need the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

    //
    // Done
    //
    return;
}

NTSTATUS
ACPIBuildDeviceExtension(
    IN  PNSOBJ              CurrentObject OPTIONAL,
    IN  PDEVICE_EXTENSION   ParentDeviceExtension OPTIONAL,
    OUT PDEVICE_EXTENSION   *ReturnExtension
    )
/*++

Routine Description:

    This routine just creates the bare frameworks for an ACPI device extension.
    No control methods can be run at this point in time.

    N.B:    This routine is called with AcpiDeviceTreeLock being held by the
    caller. So this routine executes at DISPATCH_LEVEL

Arguments:


    CurrentObject           - The object that we will link into the tree
    ParentDeviceExtension   - Where to link the deviceExtension into
    ReturnExtension         - Where we store a pointer to what we just created

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PACPI_POWER_INFO    powerInfo;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // Sanity checks
    //
    if (ParentDeviceExtension) {

        ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL);

        //
        // We must be under the tree lock.
        //
        //ASSERT_SPINLOCK_HELD(&AcpiDeviceTreeLock) ;
    }

    //
    // Make sure that the current device doesn't already have a device extension
    // This shouldn't really happen --- if it did, the interpreter called us
    // twice, which is a bug on its part.
    //
    if ( CurrentObject != NULL &&
         (PDEVICE_EXTENSION) CurrentObject->Context != NULL) {

        //
        // We have a value --- in theory, it should point to a DeviceExtension
        //
        deviceExtension = (PDEVICE_EXTENSION) CurrentObject->Context;

        //
        // It might not be safe to deref this
        //
        ASSERT( deviceExtension->ParentExtension == ParentDeviceExtension);
        if (deviceExtension->ParentExtension == ParentDeviceExtension) {

            //
            // This again requires some thought: processing the same node
            // again insn't a failure
            //
            return STATUS_SUCCESS;

        }

        //
        // This is probably a bad place to be since we deref'ed something
        // that may or may not exist
        //
        return STATUS_NO_SUCH_DEVICE;

    }

    //
    // Create a new extension for the object
    //
    deviceExtension = ExAllocateFromNPagedLookasideList(
        &DeviceExtensionLookAsideList
        );
    if (deviceExtension == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIBuildDeviceExtension:  NS %08lx - No Memory for "
            "extension\n",
            CurrentObject
            ) );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Lets begin with a clean slate
    //
    RtlZeroMemory( deviceExtension, sizeof(DEVICE_EXTENSION) );

    //
    // Initialize the reference count mechanism. We only have a NS object
    // so the value should be 1
    //
    deviceExtension->ReferenceCount++ ;

    //
    // The initial outstanding IRP count will be set to one. Only during a
    // remove IRP will this drop to zero, and then it will immediately pop
    // back up to one.
    //
    deviceExtension->OutstandingIrpCount++;

    //
    // Initialize the link fields
    //
    deviceExtension->AcpiObject = CurrentObject;

    //
    // Initialize the data fields
    //
    deviceExtension->Signature      = ACPI_SIGNATURE;
    deviceExtension->Flags          = DEV_TYPE_NOT_FOUND | DEV_TYPE_NOT_PRESENT;
    deviceExtension->DispatchTable  = NULL;
    deviceExtension->DeviceState    = Stopped;
    *ReturnExtension                = deviceExtension;

    //
    // Setup some of the power information values
    //
    powerInfo = &(deviceExtension->PowerInfo);
    powerInfo->DevicePowerMatrix[PowerSystemUnspecified] =
        PowerDeviceUnspecified;
    powerInfo->DevicePowerMatrix[PowerSystemWorking]    = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemSleeping1]  = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemSleeping2]  = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemSleeping3]  = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemHibernate]  = PowerDeviceD3;
    powerInfo->DevicePowerMatrix[PowerSystemShutdown]   = PowerDeviceD3;
    powerInfo->SystemWakeLevel = PowerSystemUnspecified;
    powerInfo->DeviceWakeLevel = PowerDeviceUnspecified;

    //
    // Initialize the list entries
    //
    InitializeListHead( &(deviceExtension->ChildDeviceList) );
    InitializeListHead( &(deviceExtension->EjectDeviceHead) );
    InitializeListHead( &(deviceExtension->EjectDeviceList) );
    InitializeListHead( &(powerInfo->WakeSupportList) );
    InitializeListHead( &(powerInfo->PowerRequestListEntry) );

    //
    // Make sure that the deviceExtension has pointers to its parent
    // extension. Note, that this should cause the ref count on the
    // parent to increase
    //
    deviceExtension->ParentExtension = ParentDeviceExtension;

    if (ParentDeviceExtension) {

        InterlockedIncrement( &(ParentDeviceExtension->ReferenceCount) );

        //
        // Add the deviceExtension into the deviceExtension tree
        //
        InsertTailList(
            &(ParentDeviceExtension->ChildDeviceList),
            &(deviceExtension->SiblingDeviceList)
            );
    }

    //
    // And make sure that the Name Space Object points to the extension
    //
    if (CurrentObject != NULL ) {

        CurrentObject->Context = deviceExtension;
    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildDevicePowerNodes(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PNSOBJ              ResultObject,
    IN  POBJDATA            ResultData,
    IN  DEVICE_POWER_STATE  DeviceState
    )
/*++

Routine Description:

    This routine builds the Device Power Nodes for a Device, using the
    given result data as a template

    N.B. This routine is always called at DPC_LEVEL

Arguments:

    DeviceExtension - Device to build power nodes for
    ResultObject    - The object that was used to get the data
    ResultData      - Information about the power nodes
    DeviceState     - The power state the information is for. Note that we
                      use PowerDeviceUnspecified for the Wake capabilities

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PACPI_DEVICE_POWER_NODE deviceNode;
    PACPI_DEVICE_POWER_NODE deviceNodePool;
    PNSOBJ                  packageObject   = NULL;
    POBJDATA                currentData;
    ULONG                   count;
    ULONG                   index           = 0;
    ULONG                   i;

    //
    // The number of nodes to build is based on what is in the package
    //
    count = ((PACKAGEOBJ *) ResultData->pbDataBuff)->dwcElements;
    if (DeviceState == PowerDeviceUnspecified) {

        //
        // If this node doesn't have the bear minimum of entries then
        // we should just crash
        //
        if (count < 2) {

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_PRW_PACKAGE_TOO_SMALL,
                (ULONG_PTR) DeviceExtension,
                (ULONG_PTR) ResultObject,
                count
                );
            goto ACPIBuildDevicePowerNodesExit;

        }

        //
        // The first two elements in the _PRW are taken up by other things
        //
        count -= 2;

        //
        // Remember to bias the count by 2
        //
        index = 2;

    }

    //
    // Never allocate zero bytes of memory
    //
    if (count == 0) {

        goto ACPIBuildDevicePowerNodesExit;

    }

    //
    // Allocate a block of memory to hold the device nodes
    //
    deviceNode = deviceNodePool = ExAllocatePoolWithTag(
        NonPagedPool,
        count * sizeof(ACPI_DEVICE_POWER_NODE),
        ACPI_POWER_POOLTAG
        );
    if (deviceNode == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // We need a spinlock for the following
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Remember the device power nodes for this Dx state
    //
    DeviceExtension->PowerInfo.PowerNode[DeviceState] = deviceNode;

    //
    // Process all the nodes listed
    //
    for (i = 0; i < count; i++, index++) {

        //
        // Initialize the current device node
        //
        RtlZeroMemory( deviceNode, sizeof(ACPI_DEVICE_POWER_NODE) );

        //
        // Grab the current object data
        //
        currentData =
            &( ( (PACKAGEOBJ *) ResultData->pbDataBuff)->adata[index]);

        //
        // Remember that we don't have the package object yet
        //
        packageObject = NULL;

        //
        // Turn this into a name space object
        //
        status = AMLIGetNameSpaceObject(
            currentData->pbDataBuff,
            ResultObject,
            &packageObject,
            0
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                DeviceExtension,
                "ACPIBuildDevicePowerNodes: %s Status = %08lx\n",
                currentData->pbDataBuff,
                status
                ) );

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_PRX_CANNOT_FIND_OBJECT,
                (ULONG_PTR) DeviceExtension,
                (ULONG_PTR) ResultObject,
                (ULONG_PTR) currentData->pbDataBuff
                );

        }

        //
        // Make sure that the associated power object is not null
        //
        if (packageObject == NULL ||
            NSGETOBJTYPE(packageObject) != OBJTYPE_POWERRES) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                DeviceExtension,
                "ACPIBuildDevicePowerNodes: %s references bad power object.\n",
                currentData->pbDataBuff
                ) );

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_EXPECTED_POWERRES,
                (ULONG_PTR) DeviceExtension,
                (ULONG_PTR) ResultObject,
                (ULONG_PTR) currentData->pbDataBuff
                );

        }

        //
        // Find the associated power object.
        //
        deviceNode->PowerNode = (PACPI_POWER_DEVICE_NODE)
            packageObject->Context;

        //
        // Determine the support system level, and other static values
        //
        deviceNode->SystemState = deviceNode->PowerNode->SystemLevel;
        deviceNode->DeviceExtension = DeviceExtension;
        deviceNode->AssociatedDeviceState = DeviceState;
        if (DeviceState == PowerDeviceUnspecified) {

            deviceNode->WakePowerResource = TRUE;

        }
        if (DeviceState == PowerDeviceD0 &&
            DeviceExtension->Flags & DEV_CAP_NO_OVERRIDE) {

            ACPIInternalUpdateFlags(
                &(deviceNode->PowerNode->Flags),
                (DEVICE_NODE_ALWAYS_ON | DEVICE_NODE_OVERRIDE_ON),
                FALSE
                );

        }

        //
        // Add the device to the list that the power node maintains
        //
        InsertTailList(
            &(deviceNode->PowerNode->DevicePowerListHead),
            &(deviceNode->DevicePowerListEntry)
            );

        //
        // If this is not the last node, then make sure to keep a pointer
        // to the next node
        //
        if (i < count - 1) {

            deviceNode->Next = (deviceNode + 1);

        } else {

            deviceNode->Next = NULL;
        }

        //
        // Point to the next node in the array of device nodes
        //
        deviceNode++;

    }

    //
    // Done with lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

ACPIBuildDevicePowerNodesExit:
    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildDeviceRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PACPI_BUILD_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  BOOLEAN                 RunDPC
    )
/*++

Routine Description:

    This routine is called when a device extension is ready to be filled in.
    This routine creates a request which is enqueued. When the DPC is fired,
    the request will be processed

    Note:   AcpiDeviceTreeLock must be held to call this function

Arguments:

    DeviceExtension - The device which wants to be filled in
    CallBack        - The function to call when done
    CallBackContext - The argument to pass to that function
    RunDPC          - Should we enqueue the DPC immediately (if it is not
                      running?)

Return Value:

    NTSTATUS

--*/
{
    PACPI_BUILD_REQUEST buildRequest;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Allocate a buildRequest structure
    //
    buildRequest = ExAllocateFromNPagedLookasideList(
        &BuildRequestLookAsideList
        );
    if (buildRequest == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // If the current reference is 0, that means that someone else beat
    // use to the device extension that that we *CANNOT* touch it
    //
    if (DeviceExtension->ReferenceCount == 0) {

        ExFreeToNPagedLookasideList(
            &BuildRequestLookAsideList,
            buildRequest
            );
        return STATUS_DEVICE_REMOVED;

    } else {

        InterlockedIncrement( &(DeviceExtension->ReferenceCount) );

    }

    //
    // Fill in the structure
    //
    RtlZeroMemory( buildRequest, sizeof(ACPI_BUILD_REQUEST) );
    buildRequest->Signature         = ACPI_SIGNATURE;
    buildRequest->TargetListEntry   = &AcpiBuildDeviceList;
    buildRequest->WorkDone          = WORK_DONE_STEP_0;
    buildRequest->Status            = STATUS_SUCCESS;
    buildRequest->CallBack          = CallBack;
    buildRequest->CallBackContext   = CallBackContext;
    buildRequest->BuildContext      = DeviceExtension;
    buildRequest->Flags             = BUILD_REQUEST_VALID_TARGET |
                                      BUILD_REQUEST_DEVICE;

    //
    // At this point, we need the spinlock
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

    //
    // Add this to the list
    //
    InsertTailList(
        &AcpiBuildQueueList,
        &(buildRequest->ListEntry)
        );

    //
    // Do we need to queue up the DPC?
    //
    if (RunDPC && !AcpiBuildDpcRunning) {

        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

    //
    // Done
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIBuildFilter(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PDEVICE_OBJECT      PdoObject
    )
/*++

Routine Description:

    This routine builds a device object for the given device extension and
    attaches to the specified PDO

Arguments:

    DriverObject    - This is used for IoCreateDevice
    DeviceExtension - The extension to create a PDO for
    PdoObject       - The stack to attach the PDO to

Return Value:

    NTSTATUS

--*/
{

    KIRQL           oldIrql;
    NTSTATUS        status;
    PDEVICE_OBJECT  newDeviceObject     = NULL;
    PDEVICE_OBJECT  targetDeviceObject  = NULL;

    //
    // First step is to create a device object
    //
    status = IoCreateDevice(
        DriverObject,
        0,
        NULL,
        FILE_DEVICE_ACPI,
        FILE_AUTOGENERATED_DEVICE_NAME,
        FALSE,
        &newDeviceObject
        );
    if ( !NT_SUCCESS(status) ) {

        return status;

    }

    //
    // Attach the device to the PDO
    //
    targetDeviceObject = IoAttachDeviceToDeviceStack(
        newDeviceObject,
        PdoObject
        );
    if (targetDeviceObject == NULL) {

        //
        // Bad. We could not attach to a PDO. So we must fail this
        //
        IoDeleteDevice( newDeviceObject );

        //
        // This is as good as it gets
        //
        return STATUS_INVALID_PARAMETER_3;

    }

    //
    // At this point, we have succeeded in creating everything we need
    // so lets update the device extension.
    //
    // First, we need the lock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Now, update the links
    //
    newDeviceObject->DeviceExtension        = DeviceExtension;
    DeviceExtension->DeviceObject           = newDeviceObject;
    DeviceExtension->PhysicalDeviceObject   = PdoObject;
    DeviceExtension->TargetDeviceObject     = targetDeviceObject;

    //
    // Setup initial reference counts.
    //
    InterlockedIncrement( &(DeviceExtension->ReferenceCount) );

    //
    // Update the flags for the extension
    //
    ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_MASK_TYPE, TRUE );
    ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_TYPE_FILTER, FALSE );
    DeviceExtension->PreviousState = DeviceExtension->DeviceState;
    DeviceExtension->DeviceState = Stopped;
    DeviceExtension->DispatchTable = &AcpiFilterIrpDispatch;

    //
    // Propagate the Pdo's requirements
    //
    newDeviceObject->StackSize = targetDeviceObject->StackSize + 1;
    newDeviceObject->AlignmentRequirement =
        targetDeviceObject->AlignmentRequirement;

    if (targetDeviceObject->Flags & DO_POWER_PAGABLE) {

        newDeviceObject->Flags |= DO_POWER_PAGABLE;

    }

    if (targetDeviceObject->Flags & DO_DIRECT_IO) {

        newDeviceObject->Flags |= DO_DIRECT_IO;

    }

    //
    // Done with the device lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // We are done initializing the device object
    //
    newDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildFixedButtonExtension(
    IN  PDEVICE_EXTENSION   ParentExtension,
    OUT PDEVICE_EXTENSION   *ResultExtension
    )
/*++

Routine Description:

    This routine builds a device extension for the fixed button if one is
    detected

    N.B. This function is called with ACPIDeviceTreeLock being owned

Arguments:

    ParentExtension - Which child are we?
    ResultExtension - Where to store the created extension

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    ULONG               buttonCaps;
    ULONG               fixedEnables;

    //
    // Have we already done this?
    //
    if (AcpiBuildFixedButtonEnumerated) {

        //
        // Make sure not to return anything
        //
        *ResultExtension = NULL;
        return STATUS_SUCCESS;

    }
    AcpiBuildFixedButtonEnumerated = TRUE;

    //
    // Lets look at the Fixed enables
    //
    fixedEnables = ACPIEnableQueryFixedEnables();
    buttonCaps = 0;
    if (fixedEnables & PM1_PWRBTN_EN) {

        buttonCaps |= SYS_BUTTON_POWER;

    }
    if (fixedEnables & PM1_SLEEPBTN_EN) {

        buttonCaps |= SYS_BUTTON_SLEEP;

    }

    //
    // If we have no caps, then do nothing
    //
    if (!buttonCaps) {

        *ResultExtension = NULL;
        return STATUS_SUCCESS;

    }

    //
    // By default, the button can wake the computer
    //
    buttonCaps |= SYS_BUTTON_WAKE;

    //
    // Build the device extension
    //
    status = ACPIBuildDeviceExtension(
        NULL,
        ParentExtension,
        ResultExtension
        );
    if (!NT_SUCCESS(status)) {

        //
        // Make sure not to return anything
        //
        *ResultExtension = NULL;
        return status;

    }
    deviceExtension = *ResultExtension;

    //
    // Set the flags for the device
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        (DEV_PROP_NO_OBJECT | DEV_CAP_RAW |
         DEV_MASK_INTERNAL_DEVICE | DEV_CAP_BUTTON),
        FALSE
        );

    //
    // Initialize the button specific extension
    //
    KeInitializeSpinLock( &deviceExtension->Button.SpinLock);
    deviceExtension->Button.Capabilities = buttonCaps;

    //
    // Create the HID for the device
    //
    deviceExtension->DeviceID = ExAllocatePoolWithTag(
        NonPagedPool,
        strlen(ACPIFixedButtonId) + 1,
        ACPI_STRING_POOLTAG
        );
    if (deviceExtension->DeviceID == NULL) {

        //
        // Mark the device as having failed init
        //
        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            DEV_PROP_FAILED_INIT,
            FALSE
            );

        //
        // Done
        //
        *ResultExtension = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlCopyMemory(
        deviceExtension->DeviceID,
        ACPIFixedButtonId,
        strlen(ACPIFixedButtonId) + 1
        );

    //
    // Remember that we now have an _HID
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        (DEV_PROP_HID | DEV_PROP_FIXED_HID),
        FALSE
        );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildFlushQueue(
    PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine will block until the Build Queues have been flushed

Arguments:

    DeviceExtension - The device which wants to flush the queue

Return Value:

    NSTATUS

--*/
{
    KEVENT      event;
    NTSTATUS    status;

    //
    // Initialize the event that we will wait on
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Now, push a request onto the stack such that when the build
    // list has been flushed, we unblock this thread
    //
    status = ACPIBuildSynchronizationRequest(
        DeviceExtension,
        ACPIBuildNotifyEvent,
        &event,
        &AcpiBuildDeviceList,
        TRUE
        );

    //
    // Block until its done
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = STATUS_SUCCESS;

    }

    //
    // Let the world know
    //
    return status;
}

NTSTATUS
ACPIBuildMissingChildren(
    PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    Walk the ACPI namespace children of this device extension and create
    device extension for any of the missing devices.

    N.B. This function is called with the device tree locked...

Arguments:

    DeviceExtension - Extension to walk

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PNSOBJ      nsObject;
    ULONG       objType;

    //
    // Sanity check
    //
    if (DeviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        return STATUS_SUCCESS;

    }

    //
    // Walk all of children of this object
    //
    for (nsObject = NSGETFIRSTCHILD(DeviceExtension->AcpiObject);
         nsObject != NULL;
         nsObject = NSGETNEXTSIBLING(nsObject)) {

        //
        // Does the namespace object already have a context object? If so,
        // then the object likely already has an extension...
        //
        if (nsObject->Context != NULL) {

            continue;

        }

        //
        // At this point, we possible don't have a device extension
        // (depending on the object type) so we need to simulate an Object
        // Creation call, similar to what OSNotifyCreate() does
        //
        objType = nsObject->ObjData.dwDataType;
        switch (objType) {
            case OBJTYPE_DEVICE:
                status = OSNotifyCreateDevice(
                    nsObject,
                    DEV_PROP_REBUILD_CHILDREN
                    );
                break;
            case OBJTYPE_OPREGION:
                status = OSNotifyCreateOperationRegion(
                    nsObject
                    );
                break;
            case OBJTYPE_PROCESSOR:
                status = OSNotifyCreateProcessor(
                    nsObject,
                    DEV_PROP_REBUILD_CHILDREN
                    );
                break;
            case OBJTYPE_THERMALZONE:
                status = OSNotifyCreateThermalZone(
                    nsObject,
                    DEV_PROP_REBUILD_CHILDREN
                    );
                break;
            default:
                status = STATUS_SUCCESS;
                break;
        }

        if (!NT_SUCCESS(status)) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ACPIBuildMissingChildren: Error %x when building %x\n",
                status,
                nsObject
                ) );

        }

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildMissingEjectionRelations(
    )
/*++

Routine Description:

    This routine takes the elements from the AcpiUnresolvedEjectList and tries
    to resolve them

    N.B. This function can only be called IRQL < DISPATCH_LEVEL

Argument

    None

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    LIST_ENTRY          tempList;
    LONG                oldReferenceCount;
    NTSTATUS            status;
    OBJDATA             objData;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_EXTENSION   ejectorExtension;
    PNSOBJ              ejdObject;
    PNSOBJ              ejdTarget;

    ASSERT( KeGetCurrentIrql() <= DISPATCH_LEVEL );

    //
    // Initialize the list
    //
    InitializeListHead( &tempList);

    //
    // We need the device tree lock to manipulate the UnresolvedEject list
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Check to see if there is work to do...
    //
    if (IsListEmpty( &AcpiUnresolvedEjectList ) ) {

        //
        // No work todo
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
        return STATUS_SUCCESS;

    }

    //
    // Move the list so that we can release the lock...
    //
    ACPIInternalMoveList( &AcpiUnresolvedEjectList, &tempList );

    //
    // As long as we haven't drained the list, look at each element...
    //
    while (!IsListEmpty( &tempList ) ) {

        //
        // Get the corresponding device extension and remove the entry
        // from the list
        //
        deviceExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
            tempList.Flink,
            DEVICE_EXTENSION,
            EjectDeviceList
            );
        RemoveEntryList( tempList.Flink );

        //
        // See if the _EJD object exists --- it really should otherwise we
        // wouldn't be here..
        //
        ejdObject = ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_EJD
            );
        if (!ejdObject) {

            continue;

        }

        //
        // Grab a reference to the object since we will be dropping the
        // DeviceTreeLock.
        //
        InterlockedIncrement( &(deviceExtension->ReferenceCount) );

        //
        // Done with the lock for now...
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

        //
        // Evaluate it... Note that we are not holding the lock at this point,
        // so its safe to call the blocking semantic version of the API
        //
        status = AMLIEvalNameSpaceObject(
            ejdObject,
            &objData,
            0,
            NULL
            );

        //
        // Hold the device tree lock while we look for a match
        //
        KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

        //
        // Decrement the reference count...
        //
        oldReferenceCount = InterlockedDecrement( &(deviceExtension->ReferenceCount) );
        if (oldReferenceCount == 0) {

            //
            // Free the extension...
            //
            ACPIInitDeleteDeviceExtension( deviceExtension );
            continue;

        }

        //
        // Now we can check to see if the call succeeded
        //
        if (!NT_SUCCESS(status)) {

            //
            // Be more forgiving and add the entry back to the unresolved list
            //
            InsertTailList(
                &AcpiUnresolvedEjectList,
                &(deviceExtension->EjectDeviceList)
                );
            continue;

        }

        //
        // However, we must get back a string from the BIOS...
        //
        if (objData.dwDataType != OBJTYPE_STRDATA) {

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_EXPECTED_STRING,
                (ULONG_PTR) deviceExtension,
                (ULONG_PTR) ejdObject,
                objData.dwDataType
                );

        }

        //
        // See what this object points to
        //
        ejdTarget = NULL;
        status = AMLIGetNameSpaceObject(
            objData.pbDataBuff,
            NULL,
            &ejdTarget,
            0
            );

        //
        // Free the objData now
        //
        if (NT_SUCCESS(status)) {

            AMLIFreeDataBuffs( &objData, 1 );

        }

        if (!NT_SUCCESS(status) || ejdTarget == NULL || ejdTarget->Context == NULL) {

            //
            // No, match. Be forgiving and add this entry back to the
            // unresolved extension...
            //
            InsertTailList(
                &AcpiUnresolvedEjectList,
                &(deviceExtension->EjectDeviceList)
                );

        } else {

            ejectorExtension = (PDEVICE_EXTENSION) ejdTarget->Context;
            InsertTailList(
                &(ejectorExtension->EjectDeviceHead),
                &(deviceExtension->EjectDeviceList)
                );
            if (!(ejectorExtension->Flags & DEV_TYPE_NOT_FOUND)) {

                IoInvalidateDeviceRelations(
                    ejectorExtension->PhysicalDeviceObject,
                    EjectionRelations
                    );

            }

        }

    }

    //
    // Done with the spinlock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

VOID
ACPIBuildNotifyEvent(
    IN  PVOID               BuildContext,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This routine is called when one of the queues that we are attempting
    to synchronize on has gotten empty. The point of this routine is to
    set an event so that we can resume processing in the proper thread.

Arguments:

    BuildContext    - Aka the Device Extension
    Context         - Aka the Event to set
    Status          - The result of the operation

Return Value:

    None

--*/
{
    PKEVENT event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER( BuildContext );
    UNREFERENCED_PARAMETER( Status );

    //
    // Set the event
    //
    KeSetEvent( event, IO_NO_INCREMENT, FALSE );
}

NTSTATUS
ACPIBuildPdo(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PDEVICE_OBJECT      ParentPdoObject,
    IN  BOOLEAN             CreateAsFilter
    )
/*++

Routine Description:

    This routine builds a device object for the given device extension.

Arguments:

    DriverObject    - This is used for IoCreateDevice
    DeviceExtension - The extension to create a PDO for
    ParentPdoObject - Used to get reference required for filter
    CreateAsFilter  - If we should create as a PDO-Filter

Return Status:

    NTSTATUS

--*/
{
    KIRQL           oldIrql;
    NTSTATUS        status;
    PDEVICE_OBJECT  filterDeviceObject  = NULL;
    PDEVICE_OBJECT  newDeviceObject     = NULL;

    //
    // First step is to create a device object
    //
    status = IoCreateDevice(
        DriverObject,
        0,
        NULL,
        FILE_DEVICE_ACPI,
        FILE_AUTOGENERATED_DEVICE_NAME,
        FALSE,
        &newDeviceObject
        );
    if ( !NT_SUCCESS(status) ) {

        return status;

    }

    //
    // Next step is device if we should create the extension as a filter
    // or not
    //
    if (CreateAsFilter) {

        if (!(DeviceExtension->Flags & DEV_CAP_NO_FILTER) ) {

            filterDeviceObject = IoGetAttachedDeviceReference(
                ParentPdoObject
                );

            //
            // Did we fail to attach?
            //
            if (filterDeviceObject == NULL) {

                //
                // We failed --- we must clean up this device object
                //
                IoDeleteDevice( newDeviceObject );
                return STATUS_NO_SUCH_DEVICE;

            }

        } else {

            CreateAsFilter = FALSE;

        }

    }

    //
    // At this point, we have succeeded in creating everything we need
    // so lets update the device extension.
    //
    // First, we need the lock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Now, update the links and the reference counts
    //
    newDeviceObject->DeviceExtension        = DeviceExtension;
    DeviceExtension->DeviceObject           = newDeviceObject;
    DeviceExtension->PhysicalDeviceObject   = newDeviceObject;
    InterlockedIncrement( &(DeviceExtension->ReferenceCount) );

    //
    // Update the flags for the extension
    //
    ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_MASK_TYPE, TRUE );
    ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_TYPE_PDO, FALSE );
    DeviceExtension->PreviousState = DeviceExtension->DeviceState;
    DeviceExtension->DeviceState = Stopped;

    //
    // Set the Irp Dispatch point
    //
    DeviceExtension->DispatchTable = &AcpiPdoIrpDispatch;

    //
    // Did we have to create as a PDO-Filter
    //
    if (CreateAsFilter) {

        //
        // Update the target field
        //
        DeviceExtension->TargetDeviceObject = filterDeviceObject;

        //
        // Update the flags to indicate that this a filter
        //
        ACPIInternalUpdateFlags(
            &(DeviceExtension->Flags),
            DEV_TYPE_FILTER,
            FALSE
            );

        //
        // Update the Irp Dispatch point
        //
        DeviceExtension->DispatchTable = &AcpiBusFilterIrpDispatch;

        //
        // Update the deviceObject information...
        //
        newDeviceObject->StackSize = filterDeviceObject->StackSize + 1;
        newDeviceObject->AlignmentRequirement =
            filterDeviceObject->AlignmentRequirement;
        if (filterDeviceObject->Flags & DO_POWER_PAGABLE) {

            newDeviceObject->Flags |= DO_POWER_PAGABLE;

        }

    }

    //
    // A further refinition of the PDO is to see if it one of the 'special'
    // internal devices
    //
    if (DeviceExtension->Flags & DEV_CAP_PROCESSOR) {

        DeviceExtension->DispatchTable = &AcpiProcessorIrpDispatch;

    } else if (DeviceExtension->Flags & DEV_PROP_HID) {

        ULONG   i;
        PUCHAR  ptr;

        ASSERT( DeviceExtension->DeviceID );

        for (i = 0; AcpiInternalDeviceTable[i].PnPId; i++) {

            ptr = strstr(
                DeviceExtension->DeviceID,
                AcpiInternalDeviceTable[i].PnPId
                );
            if (ptr) {

                DeviceExtension->DispatchTable =
                    AcpiInternalDeviceTable[i].DispatchTable;
                break;

            }

        }

    }

    //
    // Do some more specialized handling here
    //
    if (DeviceExtension->Flags & DEV_CAP_BUTTON &&
        DeviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        //
        // This means that this is the fixed button
        //
        FixedButtonDeviceObject = newDeviceObject;

    }

    //
    // Done with the device lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // We are done initializing the device object
    //
    newDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    if (DeviceExtension->Flags & DEV_PROP_EXCLUSIVE) {

        newDeviceObject->Flags |= DO_EXCLUSIVE;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildPowerResourceExtension(
    IN  PNSOBJ                  PowerResource,
    OUT PACPI_POWER_DEVICE_NODE *ReturnNode
    )
/*++

Routine Description:

    This routine is called when a new power resource appears. This routine
    builds the basic framework for the power resource. More data is filled
    in latter

    Note: this function is called with the AcpiDeviceTreeLock being held by
    the caller

Arguments:

    PowerResource   - ACPI NameSpace Object that was added
    ReturnNode      - Where to store what we create

Return Value:

    NTSTATUS

--*/
{
    PACPI_POWER_DEVICE_NODE powerNode;
    PACPI_POWER_DEVICE_NODE tempNode;
    PLIST_ENTRY             listEntry;
    PPOWERRESOBJ            powerResourceObject;

    //
    // Allocate some memory for the power node
    //
    powerNode = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(ACPI_POWER_DEVICE_NODE),
        ACPI_DEVICE_POOLTAG
        );
    if (powerNode == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIBuildPowerResourceExtension: Could not allocate %08lx\n",
            sizeof(ACPI_POWER_DEVICE_NODE)
            ) );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // This will give us some useful data about the power resource
    //
    powerResourceObject = (PPOWERRESOBJ) (PowerResource->ObjData.pbDataBuff);

    //
    // Fill in the node. Note that the RtlZero explicitly clears all the flags.
    // This is the desired behaviour
    //
    RtlZeroMemory( powerNode, sizeof(ACPI_POWER_DEVICE_NODE) );
    powerNode->Flags            = DEVICE_NODE_STA_UNKNOWN;
    powerNode->PowerObject      = PowerResource;
    powerNode->ResourceOrder    = powerResourceObject->bResOrder;
    powerNode->WorkDone         = WORK_DONE_STEP_0;
    powerNode->SystemLevel      = ACPIDeviceMapSystemState(
        powerResourceObject->bSystemLevel
        );
    InitializeListHead( &powerNode->DevicePowerListHead );
    *ReturnNode                 = powerNode;

    //
    // Make sure that the nsobj points to this entry.
    //
    PowerResource->Context = powerNode;

    //
    // We need to be holding the lock so that we add the node to the list
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Grab the first element in the list and walk it
    //
    for (listEntry = AcpiPowerNodeList.Flink;
         listEntry != &AcpiPowerNodeList;
         listEntry = listEntry->Flink) {

        //
        // Look at the current node
        //
        tempNode = CONTAINING_RECORD(
            listEntry,
            ACPI_POWER_DEVICE_NODE,
            ListEntry
            );

        //
        // Should this node go *before* the current one?
        //
        if (tempNode->ResourceOrder >= powerNode->ResourceOrder) {

            InsertTailList(
                listEntry,
                &(powerNode->ListEntry)
                );
            break;

        }

    }

    //
    // Did we loop all the way around?
    //
    if (listEntry == &AcpiPowerNodeList) {

        //
        // Yes? Oh well, we have to add the entry to the tail now
        //
        InsertTailList(
            listEntry,
            &(powerNode->ListEntry)
            );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // Done
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIBuildPowerResourceRequest(
    IN  PACPI_POWER_DEVICE_NODE PowerNode,
    IN  PACPI_BUILD_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  BOOLEAN                 RunDPC
    )
/*++

Routine Description:

    This routine is called when a power node is ready to be filled in.
    This routine creates a request which is enqueued. When the DPC is fired,
    the request will be processed

    Note:   AcpiDeviceTreeLock must be held to call this function

Arguments:

    PowerNode       - The PowerNode that wants to be filled in
    CallBack        - The function to call when done
    CallBackContext - The argument to pass to that function
    RunDPC          - Should we enqueue the DPC immediately (if it is not
                      running?)

Return Value:

    NTSTATUS

--*/
{
    PACPI_BUILD_REQUEST buildRequest;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Allocate a buildRequest structure
    //
    buildRequest = ExAllocateFromNPagedLookasideList(
        &BuildRequestLookAsideList
        );
    if (buildRequest == NULL) {

        //
        // If there is a completion routine, call it
        //
        if (CallBack != NULL) {

            (*CallBack)(
                PowerNode,
                CallBackContext,
                STATUS_INSUFFICIENT_RESOURCES
                );

        }
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Fill in the structure
    //
    RtlZeroMemory( buildRequest, sizeof(ACPI_BUILD_REQUEST) );
    buildRequest->Signature         = ACPI_SIGNATURE;
    buildRequest->TargetListEntry   = &AcpiBuildPowerResourceList;
    buildRequest->WorkDone          = WORK_DONE_STEP_0;
    buildRequest->Status            = STATUS_SUCCESS;
    buildRequest->CallBack          = CallBack;
    buildRequest->CallBackContext   = CallBackContext;
    buildRequest->BuildContext      = PowerNode;
    buildRequest->Flags             = BUILD_REQUEST_VALID_TARGET;


    //
    // At this point, we need the spinlock
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

    //
    // Add this to the list
    //
    InsertTailList(
        &AcpiBuildQueueList,
        &(buildRequest->ListEntry)
        );

    //
    // Do we need to queue up the DPC?
    //
    if (RunDPC && !AcpiBuildDpcRunning) {

        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

    //
    // Done
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIBuildProcessDeviceFailure(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine handle the case where we failed to initialize the device
    extension due to some error

Arguments:

    BuildRequest    - The request that failed

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = BuildRequest->Status;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;

    ACPIDevPrint( (
        ACPI_PRINT_FAILURE,
        deviceExtension,
        "ACPIBuildProcessDeviceFailure: NextWorkDone = %lx Status = %08lx\n",
        BuildRequest->NextWorkDone,
        status
        ) );

    //
    // Mark the node as having failed
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_PROP_FAILED_INIT,
        FALSE
        );

    //
    // Complete the request using the generic completion routine
    //
    status = ACPIBuildProcessGenericComplete( BuildRequest );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDeviceGenericEval(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is very generic. Since the remainder of the work involve
    us executing a request then doing some specialized work on the result,
    it is easy to share the common first part.

    Path:   PhaseX ---> PhaseX+1

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);
    ULONG               objectName;

    //
    // Make sure that we clear the result
    //
    RtlZeroMemory( result, sizeof(OBJDATA) );

    //
    // Base everything on the current amount of workDone
    //
    objectName = AcpiBuildDevicePowerNameLookup[BuildRequest->CurrentWorkDone];

    //
    // Remember that the next work done is the CurrentWorkDone + 1
    //
    BuildRequest->NextWorkDone = BuildRequest->CurrentWorkDone + 1;

    //
    // Does this object exists?
    //
    BuildRequest->CurrentObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        objectName
        );
    if (BuildRequest->CurrentObject != NULL) {

        //
        // Yes, then call that function
        //
        status = AMLIAsyncEvalObject(
            BuildRequest->CurrentObject,
            result,
            0,
            NULL,
            ACPIBuildCompleteGeneric,
            BuildRequest
            );

    }

    //
    // If we didn't get pending back, then call the method ourselves
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteGeneric(
            BuildRequest->CurrentObject,
            status,
            result,
            BuildRequest
            );

    }

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDeviceGenericEval: Phase%lx Status = %08lx\n",
        BuildRequest->CurrentWorkDone - WORK_DONE_STEP_0,
        status
        ) );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildProcessDeviceGenericEvalStrict(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is very generic. Since the remainder of the work involve
    us executing a request then doing some specialized work on the result,
    it is easy to share the common first part.

    Path:   PhaseX ---> PhaseX+1

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);
    ULONG               objectName;

    //
    // Make sure that we clear the result
    //
    RtlZeroMemory( result, sizeof(OBJDATA) );

    //
    // Base everything on the current amount of workDone
    //
    objectName = AcpiBuildDevicePowerNameLookup[BuildRequest->CurrentWorkDone];

    //
    // Remember that the next work done is the CurrentWorkDone + 1
    //
    BuildRequest->NextWorkDone = BuildRequest->CurrentWorkDone + 1;

    //
    // Does this object exists?
    //
    BuildRequest->CurrentObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        objectName
        );
    if (BuildRequest->CurrentObject != NULL) {

        //
        // Yes, then call that function
        //
        status = AMLIAsyncEvalObject(
            BuildRequest->CurrentObject,
            result,
            0,
            NULL,
            ACPIBuildCompleteMustSucceed,
            BuildRequest
            );

    }

    //
    // What happened
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDeviceGenericEval: Phase%lx Status = %08lx\n",
        BuildRequest->CurrentWorkDone - WORK_DONE_STEP_0,
        status
        ) );

    //
    // If we didn't get pending back, then call the method ourselves
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteMustSucceed(
            BuildRequest->CurrentObject,
            status,
            result,
            BuildRequest
            );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildProcessDevicePhaseAdr(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called by the interpreter once it has evaluate the _ADR
    method.

    Path:   PhaseAdr -> PhaseSta

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;

    //
    // If we got to this point, that means that the control method was
    // successfull and so lets remember that we have an address
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_PROP_ADDRESS,
        FALSE
        );

    //
    // The next phase is to run the _STA
    //
    BuildRequest->NextWorkDone = WORK_DONE_STA;

    //
    // Get the device status
    //
    status = ACPIGetDevicePresenceAsync(
        deviceExtension,
        ACPIBuildCompleteMustSucceed,
        BuildRequest,
        (PVOID *) &(BuildRequest->Integer),
        NULL
        );

    //
    // What happened?
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhaseAdr: Status = %08lx\n",
        status
        ) );

    //
    // Common code to handle the result of the 'Get' routine
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteMustSucceed(
            NULL,
            status,
            NULL,
            BuildRequest
            );

    } else {

        status = STATUS_SUCCESS;

    }

    //
    // Done
    //
    return status;
} // ACPIBuildProcessDevicePhaseAdr

NTSTATUS
ACPIBuildProcessDevicePhaseAdrOrHid(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called after all the children of the current device
    have been created with the name space tree. This function is responsible
    then for evaluating the 'safe' control methods to determine the name
    of the extension, etc, etc

    Path:   PhaseAdrOrHid -> PhaseAdr
                         |-> PhaseUid
                         |-> PhaseHid

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    PNSOBJ              nsObject        = NULL;
    POBJDATA            resultData      = &(BuildRequest->DeviceRequest.ResultData);

    //
    // We need to name this node, so lets determine if there is an _HID
    // or an _ADR is present
    //
    nsObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        PACKED_HID
        );
    if (nsObject == NULL) {

        //
        // Otherwise, there had better be an _ADR present
        //
        nsObject = ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_ADR
            );
        if (nsObject == NULL) {

            //
            // At this point, we have an invalid name space object ---
            // this should not happen
            //
            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_REQUIRED_METHOD_NOT_PRESENT,
                (ULONG_PTR) deviceExtension,
                PACKED_ADR,
                0
                );

            //
            // Never get here
            //
            return STATUS_NO_SUCH_DEVICE;

        } else {

            //
            // If we think there is an ADR, then the correct next stage is
            // to post process the ADR
            //
            BuildRequest->NextWorkDone = WORK_DONE_ADR;

            //
            // Remember which name space object we are evaluating
            //
            BuildRequest->CurrentObject = nsObject;

            //
            // Get the Address
            //
            status = ACPIGetAddressAsync(
                deviceExtension,
                ACPIBuildCompleteMustSucceed,
                BuildRequest,
                (PVOID *) &(deviceExtension->Address),
                NULL
                );
        }

    } else {

        //
        // Remember which name space object we are evaluating
        //
        BuildRequest->CurrentObject = nsObject;

        //
        // When we go down this path, we actually want to build the UID before
        // the HID because that makes deciding wether to run the CID much easier
        //
        nsObject = ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_UID
            );
        if (nsObject != NULL) {

            //
            // If we think there is an UID, then the correct next stage is
            // to postprocess the UID. The reason that
            //
            BuildRequest->NextWorkDone = WORK_DONE_UID;

            //
            // Remember which name space object we are evaluating
            //
            BuildRequest->CurrentObject = nsObject;

            //
            // Get the Instance ID
            //
            status = ACPIGetInstanceIDAsync(
                deviceExtension,
                ACPIBuildCompleteMustSucceed,
                BuildRequest,
                &(deviceExtension->InstanceID),
                NULL
                );

        } else {

            //
            // We don't have UID, so lets process the HID
            //
            BuildRequest->NextWorkDone = WORK_DONE_HID;

            //
            // Get the Device ID
            //
            status = ACPIGetDeviceIDAsync(
                deviceExtension,
                ACPIBuildCompleteMustSucceed,
                BuildRequest,
                &(deviceExtension->DeviceID),
                NULL
                );

        }

    }

    //
    // Common code to handle the result of the 'Get' routine
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteMustSucceed(
            nsObject,
            status,
            NULL,
            BuildRequest
            );

    } else {

        status = STATUS_SUCCESS;

    }

    //
    // Done
    //
    return status;

} // ACPIBuildProcessDevicePhaseAdrOrUid

NTSTATUS
ACPIBuildProcessDevicePhaseCid(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

    This routine is called by the interpreter once it has evaluate the _CID
    method. This routine then sets any flag that are appropriate
    device

    Path:   PhaseCid -> PhaseSta

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);
    PUCHAR              tempPtr         = BuildRequest->String;
    ULONG               i;

    //
    // Walk the CID, trying to find the double NULL
    //
    for ( ;tempPtr != NULL && *tempPtr != '\0'; ) {

        tempPtr += strlen(tempPtr);
        if (*(tempPtr+1) == '\0') {

            //
            // Found the double null, so we can break
            //
            break;

        }

        //
        // Set the character to be a 'space'
        //
        *tempPtr = ' ';

    }
    tempPtr = BuildRequest->String;

    //
    // Set any special flags associated with this device id
    //
    for (i = 0; AcpiInternalDeviceFlagTable[i].PnPId != NULL; i++) {

        if (strstr( tempPtr, AcpiInternalDeviceFlagTable[i].PnPId ) ) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                AcpiInternalDeviceFlagTable[i].Flags,
                FALSE
                );
            break;

        }

    }

    //
    // Done with the string
    //
    if (tempPtr != NULL) {

        ExFreePool( tempPtr );

    }

    //
    // The next stage is to run the _STA
    //
    BuildRequest->NextWorkDone = WORK_DONE_STA;

    //
    // Get the device status
    //
    status = ACPIGetDevicePresenceAsync(
        deviceExtension,
        ACPIBuildCompleteMustSucceed,
        BuildRequest,
        (PVOID *) &(BuildRequest->Integer),
        NULL
        );

    //
    // What happened?
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhaseCid: Status = %08lx\n",
        status
        ) );

    //
    // Common code to handle the result of the 'Get' routine
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteMustSucceed(
            NULL,
            status,
            NULL,
            BuildRequest
            );

    } else {

        status = STATUS_SUCCESS;

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDevicePhaseCrs(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called by the interpreter once it has evaluate the _CRS
    method. This routine then determines if this is the kernel debugger

    Path:   PhaseCrs ---> PhasePrw

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);

    //
    // The next step is to run the _PRW
    //
    BuildRequest->NextWorkDone = WORK_DONE_PRW;

    //
    // Did we have an object to run?
    //
    if (BuildRequest->CurrentObject == NULL) {

        //
        // No? Then there is no work for us to do here
        //
        goto ACPIBuildProcessDevicePhaseCrsExit;

    }

    //
    // We are expecting a package
    //
    if (result->dwDataType != OBJTYPE_BUFFDATA) {

        //
        // A bios must return a package to a PRW method
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_EXPECTED_BUFFER,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            result->dwDataType
            );
        goto ACPIBuildProcessDevicePhaseCrsExit;

    }

    //
    // Update the bits to see if the serial port matches either the kernel debugger
    // port or the kernel headless port.
    //
    ACPIMatchKernelPorts(
        deviceExtension,
        result
        );

    //
    // Do not leave object lying around without having freed them first
    //
    AMLIFreeDataBuffs( result, 1 );

ACPIBuildProcessDevicePhaseCrsExit:

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhaseCrs: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDevicePhaseEjd(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called when we have run _EJD

Arguments:

    BuildRequest    - The request that has just been completed

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status              = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension     = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    PDEVICE_EXTENSION   ejectorExtension    = NULL;
    POBJDATA            result              = &(BuildRequest->DeviceRequest.ResultData);
    PNSOBJ              ejectObject         = NULL;

    //
    // From here, decide if we have a serial port or not
    //
    if (!(deviceExtension->Flags & DEV_TYPE_NOT_PRESENT) &&
         (deviceExtension->Flags & DEV_CAP_SERIAL) ) {

        //
        // The next step is to run the _CRS
        //
        BuildRequest->NextWorkDone = WORK_DONE_CRS;

    } else {

        //
        // The next step is to run the _PRW
        //
        BuildRequest->NextWorkDone = WORK_DONE_PRW;

    }


    //
    // Did we have an object to run?
    //
    if (BuildRequest->CurrentObject == NULL) {

        //
        // No? Then there is no work for us to do here
        //
        goto ACPIBuildProcessDevicePhaseEjdExit;

    }

    //
    // No longer need the result
    //
    AMLIFreeDataBuffs( result, 1 );

    //
    // Add the device extension into the unresolved eject tree
    //
    ExInterlockedInsertTailList(
        &AcpiUnresolvedEjectList,
        &(deviceExtension->EjectDeviceList),
        &AcpiDeviceTreeLock
        );

#if DBG
    if (deviceExtension->DebugFlags & DEVDBG_EJECTOR_FOUND) {

        ACPIDevPrint( (
            ACPI_PRINT_WARNING,
            deviceExtension,
            "ACPIBuildProcessDevicePhaseEjd: Ejector already found\n"
            ) );

    } else {

        deviceExtension->DebugFlags |= DEVDBG_EJECTOR_FOUND;

    }
#endif

ACPIBuildProcessDevicePhaseEjdExit:

    //
    // Check to see if we have a dock device
    //
    if (!ACPIDockIsDockDevice( deviceExtension->AcpiObject) ) {

       //
       // If it's not a dock, then don't bother...
       //
       status = STATUS_SUCCESS;
       goto ACPIBuildProcessDevicePhaseEjdExit2;

    }
    if (!AcpiInformation->Dockable) {

       ACPIDevPrint( (
           ACPI_PRINT_WARNING,
           deviceExtension,
           "ACPIBuildProcessDevicePhaseEjd: BIOS BUG - DOCK bit not set\n"
           ) );
       KeBugCheckEx(
           ACPI_BIOS_ERROR,
           ACPI_CLAIMS_BOGUS_DOCK_SUPPORT,
           (ULONG_PTR) deviceExtension,
           (ULONG_PTR) BuildRequest->CurrentObject,
           0
           );

    }

#if DBG
    //
    // Have we already handled this? --- This guy will grab the lock. So don't
    // hold the DeviceTree Lock at this point
    //
    if (ACPIDockFindCorrespondingDock( deviceExtension ) ) {

       KeBugCheckEx(
          ACPI_BIOS_ERROR,
          ACPI_CLAIMS_BOGUS_DOCK_SUPPORT,
          (ULONG_PTR) deviceExtension,
          (ULONG_PTR) BuildRequest->CurrentObject,
          1
          );

    }
#endif

    //
    // We need the spinlock to touch the device tree
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiDeviceTreeLock );

    //
    // Build the device extension
    //
    status = ACPIBuildDockExtension(
        deviceExtension->AcpiObject,
        RootDeviceExtension
        );

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiDeviceTreeLock );

ACPIBuildProcessDevicePhaseEjdExit2:

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhaseEjd: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteGeneric(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIBuildProcessDevicePhaseHid(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called by the interpreter once it has evaluate the _HID
    method.

    Path:   PhaseHid -> PhaseCid
                    |-> PhaseSta

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             matchFound      = FALSE;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    PNSOBJ              nsObject        = NULL;
    PUCHAR              tempPtr         = deviceExtension->DeviceID;
    ULONG               i;

    //
    // Set any special flags associated with this device id
    //
    for (i = 0; AcpiInternalDeviceFlagTable[i].PnPId != NULL; i++) {

        if (strstr( tempPtr, AcpiInternalDeviceFlagTable[i].PnPId ) ) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                AcpiInternalDeviceFlagTable[i].Flags,
                FALSE
                );
            matchFound = TRUE;
            break;

        }

    }

    //
    // Remember that we have an HID
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_PROP_HID,
        FALSE
        );

    //
    // Lets see if there is a _CID to run. Only run the _CID if there
    // was no match found above
    //
    nsObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        PACKED_CID
        );
    if (nsObject != NULL && matchFound == FALSE) {

        //
        // The next phase is to post process the _CID
        //
        BuildRequest->NextWorkDone = WORK_DONE_CID;

        //
        // Get the compatible ID
        //
        status = ACPIGetCompatibleIDAsync(
            deviceExtension,
            ACPIBuildCompleteMustSucceed,
            BuildRequest,
            &(BuildRequest->String),
            NULL
            );

    } else {

        //
        // The next step is to run the _STA
        //
        BuildRequest->NextWorkDone = WORK_DONE_STA;

        //
        // Get the device status
        //
        status = ACPIGetDevicePresenceAsync(
            deviceExtension,
            ACPIBuildCompleteMustSucceed,
            BuildRequest,
            (PVOID *) &(BuildRequest->Integer),
            NULL
            );

    }

    //
    // What happened?
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhaseHid: Status = %08lx\n",
        status
        ) );

    //
    // Common code to handle the result of the 'Get' routine
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteMustSucceed(
            nsObject,
            status,
            NULL,
            BuildRequest
            );

    } else {

        status = STATUS_SUCCESS;

    }

    //
    // Done
    //
    return status;

} // ACPIBuildProcessDevicePhaseHid

NTSTATUS
ACPIBuildProcessDevicePhasePr0(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

    This routine is called by the interpreter once it has evaluate the _PR0
    method. This routine then determines the current power state of the
    device

    Path:   PhasePr0 ---> PhasePr1

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);

    //
    // The next stage is PR1
    //
    BuildRequest->NextWorkDone = WORK_DONE_PR1;

    //
    // Get the appropriate _PSx object to go with this object
    //
    deviceExtension->PowerInfo.PowerObject[PowerDeviceD0] =
        ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_PS0
            );

    //
    // Did we have an object to run?
    //
    if (BuildRequest->CurrentObject == NULL) {

        //
        // No? Then there is no work for us to do here
        //
        goto ACPIBuildProcessDevicePhasePr0Exit;

    }

    //
    // We are expecting a package
    //
    if (result->dwDataType != OBJTYPE_PKGDATA) {

        //
        // A bios must return a package to a PRW method
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_EXPECTED_PACKAGE,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            result->dwDataType
            );
        goto ACPIBuildProcessDevicePhasePr0Exit;

    }

    //
    // Process the package
    //
    status = ACPIBuildDevicePowerNodes(
        deviceExtension,
        BuildRequest->CurrentObject,
        result,
        PowerDeviceD0
        );

    //
    // Do not leave object lying around without having freed them first
    //
    AMLIFreeDataBuffs( result, 1 );

ACPIBuildProcessDevicePhasePr0Exit:

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhasePr0: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDevicePhasePr1(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

    This routine is called by the interpreter once it has evaluate the _PR1
    method. This routine then determines the current power state of the
    device

    Path:   PhasePr1 ---> PhasePr2

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);

    //
    // The next stage is Phase16
    //
    BuildRequest->NextWorkDone = WORK_DONE_PR2;

    //
    // Get the appropriate _PSx object to go with this object
    //
    deviceExtension->PowerInfo.PowerObject[PowerDeviceD1] =
        ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_PS1
            );
    if (deviceExtension->PowerInfo.PowerObject[PowerDeviceD1] == NULL) {

        deviceExtension->PowerInfo.PowerObject[PowerDeviceD1] =
            deviceExtension->PowerInfo.PowerObject[PowerDeviceD0];

    }

    //
    // Did we have an object to run?
    //
    if (BuildRequest->CurrentObject == NULL) {

        //
        // No? Then there is no work for us to do here
        //
        goto ACPIBuildProcessDevicePhasePr1Exit;

    }

    //
    // We are expecting a package
    //
    if (result->dwDataType != OBJTYPE_PKGDATA) {

        //
        // A bios must return a package to a PRW method
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_EXPECTED_PACKAGE,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            result->dwDataType
            );
        goto ACPIBuildProcessDevicePhasePr1Exit;

    }

    //
    // Process the package
    //
    status = ACPIBuildDevicePowerNodes(
        deviceExtension,
        BuildRequest->CurrentObject,
        result,
        PowerDeviceD1
        );

    //
    // Do not leave object lying around without having freed them first
    //
    AMLIFreeDataBuffs( result, 1 );

ACPIBuildProcessDevicePhasePr1Exit:

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhasePr1: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDevicePhasePr2(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

    This routine is called by the interpreter once it has evaluate the _PR2
    method. This routine then determines the current power state of the
    device

    Path:   PhasePr2 ---> PhasePsc
                      |-> PhasePsc+1

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);

    //
    // Get the appropriate _PSx object to go with this object
    //
    deviceExtension->PowerInfo.PowerObject[PowerDeviceD2] =
        ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_PS2
            );
    if (deviceExtension->PowerInfo.PowerObject[PowerDeviceD2] == NULL) {

        deviceExtension->PowerInfo.PowerObject[PowerDeviceD2] =
            deviceExtension->PowerInfo.PowerObject[PowerDeviceD1];

    }

    //
    // Did we have an object to run?
    //
    if (BuildRequest->CurrentObject == NULL) {

        //
        // No? Then there is no work for us to do here
        //
        goto ACPIBuildProcessDevicePhasePr2Exit;

    }

    //
    // We are expecting a package
    //
    if (result->dwDataType != OBJTYPE_PKGDATA) {

        //
        // A bios must return a package to a PRW method
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_EXPECTED_PACKAGE,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            result->dwDataType
            );
        goto ACPIBuildProcessDevicePhasePr2Exit;

    }

    //
    // Process the package
    //
    status = ACPIBuildDevicePowerNodes(
        deviceExtension,
        BuildRequest->CurrentObject,
        result,
        PowerDeviceD2
        );

    //
    // Do not leave object lying around without having freed them first
    //
    AMLIFreeDataBuffs( result, 1 );

ACPIBuildProcessDevicePhasePr2Exit:

    //
    // If the device is not physically present, then we cannot run the _CRS and
    // _PSC. If the device is not present, the we cannot run those two methods,
    //  but we can fake it..
    //
    if (deviceExtension->Flags & DEV_TYPE_NOT_PRESENT) {

        BuildRequest->CurrentObject = NULL;
        BuildRequest->NextWorkDone = (WORK_DONE_PSC + 1);

    } else {

        //
        // The next step is to run the _PSC
        //
        BuildRequest->NextWorkDone = WORK_DONE_PSC;

    }

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhasePr2: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDevicePhasePrw(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

    This routine is called by the interpreter once it has evaluate the _PRW
    method. This routine then determines the current power state of the
    device

    Path:   PhasePRW ---> PhasePR0

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             ignorePrw       = FALSE;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);
    POBJDATA            stateObject     = NULL;
    POBJDATA            pinObject       = NULL;
    ULONG               gpeRegister;
    ULONG               gpeMask;

    //
    // The next stage is Phase12
    //
    BuildRequest->NextWorkDone = WORK_DONE_PR0;

    //
    // Get the appropriate _PSx object to go with this object
    //
    deviceExtension->PowerInfo.PowerObject[PowerDeviceUnspecified] =
        ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_PSW
            );

    //
    // Did we have an object to run?
    //
    if (BuildRequest->CurrentObject == NULL) {

        //
        // No? Then there is no work for us to do here
        //
        goto ACPIBuildProcessDevicePhasePrwExit;

    }

    //
    // Should we ignore the _PRW for this device?
    //
    if ( (AcpiOverrideAttributes & ACPI_OVERRIDE_OPTIONAL_WAKE) &&
        !(deviceExtension->Flags & DEV_CAP_NO_DISABLE_WAKE) ) {

        ignorePrw = TRUE;

    }

    //
    // We are expecting a package
    //
    if (result->dwDataType != OBJTYPE_PKGDATA) {

        //
        // A bios must return a package to a PRW method
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_EXPECTED_PACKAGE,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            result->dwDataType
            );

    }

    //
    // Process the package
    //
    status = ACPIBuildDevicePowerNodes(
        deviceExtension,
        BuildRequest->CurrentObject,
        result,
        PowerDeviceUnspecified
        );

    //
    // Hold the power lock for the following
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Since this was a _PRW object, then we want to store a bit more information
    // about the wake capabilities
    //

    //
    // Set the GPE pin which will be used to wake the system
    //
    pinObject = &( ( (PACKAGEOBJ *) result->pbDataBuff)->adata[0]);
    if (pinObject->dwDataType != OBJTYPE_INTDATA) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_PRW_PACKAGE_EXPECTED_INTEGER,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            pinObject->dwDataType
            );

    }

    //
    // Set the system wake level for the device
    //
    stateObject = &( ( (PACKAGEOBJ *) result->pbDataBuff)->adata[1]);
    if (stateObject->dwDataType != OBJTYPE_INTDATA) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_PRW_PACKAGE_EXPECTED_INTEGER,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            stateObject->dwDataType
            );

    }

    //
    // Set these bits only if we support sleep
    //
    if (!ignorePrw) {

        //
        // First, store the pin that we use as the wakeup signal
        //
        deviceExtension->PowerInfo.WakeBit = (ULONG)pinObject->uipDataValue;

        //
        // Next, store the system state that we can wake up from
        //
        deviceExtension->PowerInfo.SystemWakeLevel = ACPIDeviceMapSystemState(
            stateObject->uipDataValue
            );

        //
        // Finally, lets set the Wake capabilities flag
        //
        ACPIInternalUpdateFlags( &(deviceExtension->Flags), DEV_CAP_WAKE, FALSE );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // Calculate the correct register and mask
    //
    gpeRegister =      ( (UCHAR) (pinObject->uipDataValue) / 8);
    gpeMask     = 1 << ( (UCHAR) (pinObject->uipDataValue) % 8);

    //
    // We need access to the table lock for this
    //
    KeAcquireSpinLockAtDpcLevel( &GpeTableLock );

    //
    // Does this vector have a GPE?
    //
    if ( (GpeEnable[gpeRegister] & gpeMask) ) {

        //
        // If we got here, and we aren't marked as DEV_CAP_NO_DISABLE, then we
        // should turn off the GPE. The easiest way to do this is to make sure
        // that the GpeWakeHandler[] vector is masked with the appropriate
        // bit
        //
        if (!(deviceExtension->Flags & DEV_CAP_NO_DISABLE_WAKE) ) {

            //
            // It has a gpe mask, so remember that there is a wake handler
            // for it. This should prevent us from arming the GPE without
            // a request for it
            //
            if (!(GpeSpecialHandler[gpeRegister] & gpeMask) ) {

                GpeWakeHandler[gpeRegister] |= gpeMask;

            }

        } else {

            //
            // If we got here, then we should remember that we can never
            // consider this pin as *just* a wake handler
            //
            GpeSpecialHandler[gpeRegister] |= gpeMask;

            //
            // Make sure that the pin isn't set as a wake handler
            //
            if (GpeWakeHandler[gpeRegister] & gpeMask) {

                //
                // Clear the pin from the wake handler mask
                //
                GpeWakeHandler[gpeRegister] &= ~gpeMask;

            }

        }

    }

    //
    // Done with the table lock
    //
    KeReleaseSpinLockFromDpcLevel( &GpeTableLock );

    //
    // Do not leave object lying around without having freed them first
    //
    AMLIFreeDataBuffs( result, 1 );

    //
    // Finally, if there is a _PSW object, make sure that we run it to disable
    // that capability --- this way we resume from a known state
    //
    if (deviceExtension->PowerInfo.PowerObject[PowerDeviceUnspecified]) {

        OBJDATA argData;

        //
        // Setup the parameters
        //
        RtlZeroMemory( &argData, sizeof(OBJDATA) );
        argData.dwDataType = OBJTYPE_INTDATA;
        argData.uipDataValue = 0;

        //
        // Run the method. Note that we don't specify a callback because we
        // don't actually care when it completes
        //
        AMLIAsyncEvalObject(
            deviceExtension->PowerInfo.PowerObject[PowerDeviceUnspecified],
            NULL,
            1,
            &argData,
            NULL,
            NULL
            );

    }

ACPIBuildProcessDevicePhasePrwExit:

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhasePrw: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDevicePhasePsc(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called by the interpreter once it has evaluate the _PSC
    method. This routine then determines the current power state of the
    device

    Path:   PhasePsc ---> COMPLETE

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE      i;
    NTSTATUS                status          = STATUS_SUCCESS;
    PACPI_DEVICE_POWER_NODE deviceNode;
    PACPI_POWER_INFO        powerInfo;
    PDEVICE_EXTENSION       deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA                result          = &(BuildRequest->DeviceRequest.ResultData);
    SYSTEM_POWER_STATE      matrixIndex     = PowerSystemSleeping1;


    //
    // The next stage is Complete
    //
    BuildRequest->NextWorkDone = WORK_DONE_COMPLETE;

    //
    // We will use the power information structure a lot
    //
    powerInfo = &(deviceExtension->PowerInfo);

    //
    // Since we didn't get a change to look for the _PS3 object earlier,
    // lets find it now. Note, that we cannot use the PS2 object if we don't
    // find the PS3 object.
    //
    powerInfo->PowerObject[PowerDeviceD3] =
        ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_PS3
            );

    //
    // We must be holding a spinlock for the following
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // For each S state, walk PR0 to PR2 until you find a resource that
    // cannot be ON in S state. The next lighter D state is then the lightest
    // D state for the given S state.
    //
    for ( ; matrixIndex <= PowerSystemHibernate ; matrixIndex++ ) {

        //
        // Loop on all members of the PowerNode
        //
        for (i = PowerDeviceD0; i <= PowerDeviceD2; i++ ) {

            //
            // Are there any resources to look at?
            //
            deviceNode = powerInfo->PowerNode[i];
            if (deviceNode == NULL) {

                continue;

            }

            while (deviceNode != NULL &&
                   deviceNode->SystemState >= matrixIndex) {

                deviceNode = deviceNode->Next;


            }

            //
            // If we have had a device node, but don't have now, that means
            // that we found a D level that is compliant for this S-state
            //
            if (deviceNode == NULL) {

                ACPIDevPrint( (
                    ACPI_PRINT_LOADING,
                    deviceExtension,
                    "ACPIBuildDeviceProcessPhasePsc: D%x <-> S%x\n",
                    (i - PowerDeviceD0),
                    matrixIndex - PowerSystemWorking
                    ) );

                //
                // This device can be in Di state while in SmatrixIndex state
                //
                powerInfo->DevicePowerMatrix[matrixIndex] = i;
                break;

            }

        } // for (i = PowerDeviceD0 ...

    } // for ( ; matrixIndex ...

    //
    // Now that we have built the matrix, we can figure out what D-level the
    // device can support wake with.
    //
    powerInfo->DeviceWakeLevel =
        powerInfo->DevicePowerMatrix[powerInfo->SystemWakeLevel];


    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // At this point, we have to decide what to do based on the result of
    // the _PSC. The first step is assume that the device is in the D0 state
    //
    i = PowerDeviceD0;

    //
    // We will override the above if there is a bit that says that the device
    // should start in the D3 state
    //
    if (deviceExtension->Flags & DEV_CAP_START_IN_D3) {

        //
        // Go directly to D3
        //
        i = PowerDeviceD3;
        goto ACPIBuildProcessDevicePhasePscBuild;

    }

    //
    // Did we have an object to run?
    //
    if (BuildRequest->CurrentObject == NULL) {

        //
        // No? Then there is no work for us to do here
        //
        goto ACPIBuildProcessDevicePhasePscBuild;

    }

    //
    // If we didn't succeed the control method, assume that the device
    // should be in the D0 state
    //
    if (!NT_SUCCESS(BuildRequest->Status)) {

        goto ACPIBuildProcessDevicePhasePscBuild;

    }

    //
    // Also, if we know that the device must always be in the D0 state, then
    // we must ignore whatever the _PSC says
    //
    if (deviceExtension->Flags & DEV_CAP_ALWAYS_PS0) {

        //
        // Free the buffer
        //
        AMLIFreeDataBuffs( result, 1 );
        deviceExtension->PowerInfo.PowerState = i;
        goto ACPIBuildProcessDevicePhasePscBuild;

    }

    //
    // Did the request what we expected?
    //
    if (result->dwDataType != OBJTYPE_INTDATA) {

        //
        // A bios must return an integer for a _PSC
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_EXPECTED_INTEGER,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            result->dwDataType
            );
        goto ACPIBuildProcessDevicePhasePscExit;

    }

    //
    // Turn the power state into something that we can understand
    //
    i = ACPIDeviceMapPowerState( result->uipDataValue );

    //
    // No longer need the buffer
    //
    AMLIFreeDataBuffs( result, 1 );

ACPIBuildProcessDevicePhasePscBuild:

    //
    // Queue the request
    //
    status = ACPIDeviceInternalDelayedDeviceRequest(
        deviceExtension,
        i,
        NULL,
        NULL
        );

ACPIBuildProcessDevicePhasePscExit:

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhasePsc: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteGeneric(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIBuildProcessDevicePhaseSta(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

    This routine is called by the interpreter once it has evaluate the _STA
    method. This routine then determines the current power state of the
    device

    Path:   PhaseSta -> PhaseEjd

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;

    //
    // The next stage is to start running the _EJD
    //
    BuildRequest->NextWorkDone = WORK_DONE_EJD;

    //
    // What happened
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhaseSta: Status = %08lx\n",
        status
        ) );

    //
    // See if the device conforms to the ACPI specification for HIDs and UIDs
    // We do this at this point because we now know wether or not the device
    // is present or not and that is an important test because the OEM is
    // allowed to have 2 devices with the same HID/UID as long as both aren't
    // present at the same time.
    //
    ACPIDetectDuplicateHID(
        deviceExtension
        );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDevicePhaseUid(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called by the interpreter once it has evaluate the _UID
    method.

    Path:   PhaseUid --> PhaseHid

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    PNSOBJ              nsObject;

    //
    // Remember that we have an UID
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_PROP_UID,
        FALSE
        );

    //
    // Lets see if there is a _HID to run
    //
    nsObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        PACKED_HID
        );
    if (nsObject != NULL) {

        //
        // The next phase is to post process the _HID
        //
        BuildRequest->NextWorkDone = WORK_DONE_HID;

        //
        // Get the Device ID
        //
        status = ACPIGetDeviceIDAsync(
            deviceExtension,
            ACPIBuildCompleteMustSucceed,
            BuildRequest,
            &(deviceExtension->DeviceID),
            NULL
            );

    } else {

        //
        // Not having an _HID is a fatal error
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) deviceExtension,
            PACKED_HID,
            0
            );

    }

    //
    // What happened
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhaseUid: Status = %08lx\n",
        status
        ) );

    //
    // Common code to handle the result of the 'Get' routine
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteMustSucceed(
            nsObject,
            status,
            NULL,
            BuildRequest
            );

    } else {

        status = STATUS_SUCCESS;

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessGenericComplete(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called when we are done with the request

Arguments:

    BuildRequest    - The request that has just been completed

Return Value:

    NTSTATUS

--*/
{
    PACPI_BUILD_CALLBACK    callBack = BuildRequest->CallBack;

    //
    // Invoke the callback, if there is any
    //
    if (callBack != NULL) {

        (*callBack)(
            BuildRequest->BuildContext,
            BuildRequest->CallBackContext,
            BuildRequest->Status
            );

    }

    //
    // Do we have to release a reference on this request?
    //
    if (BuildRequest->Flags & BUILD_REQUEST_RELEASE_REFERENCE) {

        PDEVICE_EXTENSION       deviceExtension;
        LONG                    oldReferenceCount;

        deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;

        //
        // We to have the device tree lock
        //
        KeAcquireSpinLockAtDpcLevel( &AcpiDeviceTreeLock );

        //
        // No longer need a reference to the device extension
        //
        InterlockedDecrement( &(deviceExtension->ReferenceCount) );

        //
        // Done with the device tree lock
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiDeviceTreeLock );

    }

    //
    // We need the spinlock for this
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

    //
    // Remember that work was done --- this should be all that is required
    // to have the currently running DPC process the next request
    //
    AcpiBuildWorkDone = TRUE;

    //
    // Remove the entry from the current list. We might not need to be
    // hodling the lock to do this, but it doesn't pay to not do it while
    // we can
    //
    RemoveEntryList( &(BuildRequest->ListEntry) );

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

    //
    // We are done with the request memory
    //
    ExFreeToNPagedLookasideList(
        &BuildRequestLookAsideList,
        BuildRequest
        );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildProcessGenericList(
    IN  PLIST_ENTRY             ListEntry,
    IN  PACPI_BUILD_FUNCTION    *DispatchTable
    )
/*++

Routine Description:

    This routine processes all the build requests through the various
    phases required to build a complete device extension

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN                 allWorkComplete = TRUE;
    NTSTATUS                status          = STATUS_SUCCESS;
    PACPI_BUILD_FUNCTION    buildFunction   = NULL;
    PACPI_BUILD_REQUEST     buildRequest;
    PLIST_ENTRY             currentEntry    = ListEntry->Flink;
    PLIST_ENTRY             tempEntry;
    ULONG                   workDone;

    while (currentEntry != ListEntry) {

        //
        // Turn into a build request
        //
        buildRequest = CONTAINING_RECORD(
            currentEntry,
            ACPI_BUILD_REQUEST,
            ListEntry
            );

        //
        // Set the temp pointer to the next element. The reason that this
        // gets done is because once we call the dispatch function, the
        // current request can be completed (and thus freed), so we need
        // to remember whom the next person to process is.
        //
        tempEntry = currentEntry->Flink;

        //
        // Check to see if we have any work to do on the request
        //
        workDone = InterlockedCompareExchange(
            &(buildRequest->WorkDone),
            WORK_DONE_PENDING,
            WORK_DONE_PENDING
            );

        //
        // Look at the dispatch table to see if there is a function to
        // call
        //
        buildFunction = DispatchTable[ workDone ];
        if (buildFunction != NULL) {

            //
            // Just to help us along, if we are going to the failure
            // path, then we should not update the Current Work Done field.
            // This gives us an easy means of find which step failed
            //
            if (workDone != WORK_DONE_FAILURE) {

                //
                // Mark the node as being in the state 'workDone'
                //
                buildRequest->CurrentWorkDone = workDone;

            }

            //
            // Mark the request as pending
            //
            workDone = InterlockedCompareExchange(
                &(buildRequest->WorkDone),
                WORK_DONE_PENDING,
                workDone
                );

            //
            // Call the function
            //
            status = (buildFunction)( buildRequest );

        } else {

            //
            // The work is not all complete, and we should look at the
            // next element
            //
            allWorkComplete = FALSE;
            currentEntry = tempEntry;

            //
            // Loop
            //
            continue;

        }

        //
        // If we have completed the request, then we should look at the
        // at the next request, otherwise, we need to look at the current
        // request again
        if ( workDone == WORK_DONE_COMPLETE || workDone == WORK_DONE_FAILURE) {

            currentEntry = tempEntry;

        }

    } // while

    //
    // Have we completed all of our work?
    //
    return (allWorkComplete ? STATUS_SUCCESS : STATUS_PENDING );
}

NTSTATUS
ACPIBuildProcessorExtension(
    IN  PNSOBJ                  ProcessorObject,
    IN  PDEVICE_EXTENSION       ParentExtension,
    IN  PDEVICE_EXTENSION       *ResultExtension,
    IN  ULONG                   ProcessorIndex
    )
/*++

Routine Description:

    Since we leverage ACPIBuildDeviceExtension for the core of the processor
    extension, we don't have much to do here. However, we are responsible
    for making sure that we do tasks that don't require calling the interpreter,
    and an id unique to the processor

    N.B. This function is called with AcpiDeviceTreeLock being held

Arguments:

    ProcessorObject - The object which represents the processor
    ParentExtension - Who our parent is
    ResultExtension - Where to store the extension that we build
    ProcessorIndex  - Where do we find the processor in the ProcessorList

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // If we did not get the correct ID out of the registry earlier, fail now.
    //
    if (AcpiProcessorString.Buffer == NULL) {
        return(STATUS_OBJECT_NAME_NOT_FOUND);
    }

    //
    // Build the extension
    //
    status = ACPIBuildDeviceExtension(
        ProcessorObject,
        ParentExtension,
        ResultExtension
        );
    if (!NT_SUCCESS(status) || *ResultExtension == NULL) {

        return status;

    }

    //
    // Grab a pointer to the device extension for easy usage
    //
    deviceExtension = *ResultExtension;

    //
    // Make sure to remember that this is in fact a processor
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        (DEV_CAP_PROCESSOR | DEV_MASK_INTERNAL_DEVICE),
        FALSE
        );

    //
    // Remember the the Index of this processor object in the processor
    // array table
    //
    deviceExtension->Processor.ProcessorIndex = ProcessorIndex;

    //
    // Allocate memory for the HID
    //
    deviceExtension->DeviceID = ExAllocatePoolWithTag(
        NonPagedPool,
        AcpiProcessorString.Length,
        ACPI_STRING_POOLTAG
        );
    if (deviceExtension->DeviceID == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIBuildProcessorExtension: failed to allocate %08 bytes\n",
            AcpiProcessorString.Length
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIBuildProcessorExtensionExit;

    }
    RtlCopyMemory(
        deviceExtension->DeviceID,
        AcpiProcessorString.Buffer,
        AcpiProcessorString.Length
        );

    //
    // Allocate memory for the CID
    //
    deviceExtension->Processor.CompatibleID = ExAllocatePoolWithTag(
        NonPagedPool,
        strlen(AcpiProcessorCompatId) + 1,
        ACPI_STRING_POOLTAG
        );
    if (deviceExtension->Processor.CompatibleID == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIBuildProcessorExtension: failed to allocate %08 bytes\n",
            strlen(AcpiProcessorCompatId) + 1
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIBuildProcessorExtensionExit;

    }
    RtlCopyMemory(
        deviceExtension->Processor.CompatibleID,
        AcpiProcessorCompatId,
        strlen(AcpiProcessorCompatId) + 1
        );

    //
    // Allocate memory for the UID
    //
    deviceExtension->InstanceID = ExAllocatePoolWithTag(
        NonPagedPool,
        3,
        ACPI_STRING_POOLTAG
        );
    if (deviceExtension->InstanceID == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIBuildProcessorExtension: failed to allocate %08 bytes\n",
            3
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIBuildProcessorExtensionExit;

    }
    sprintf(deviceExtension->InstanceID,"%2d", ProcessorIndex );

    //
    // Set the flags for the work that we have just done
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        (DEV_PROP_HID | DEV_PROP_FIXED_HID | DEV_PROP_FIXED_CID |
         DEV_PROP_UID | DEV_PROP_FIXED_UID),
        FALSE
        );

ACPIBuildProcessorExtensionExit:

    //
    // Handle the case where we might have failed
    //
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPIBuildProcessorExtension: = %08lx\n",
            status
            ) );

        if (deviceExtension->InstanceID != NULL) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                (DEV_PROP_UID | DEV_PROP_FIXED_UID),
                TRUE
                );
            ExFreePool( deviceExtension->InstanceID );
            deviceExtension->InstanceID = NULL;

        }

        if (deviceExtension->DeviceID != NULL) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                (DEV_PROP_HID | DEV_PROP_FIXED_HID),
                TRUE
                );
            ExFreePool( deviceExtension->DeviceID );
            deviceExtension->DeviceID = NULL;

        }

        if (deviceExtension->Processor.CompatibleID != NULL) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                (DEV_PROP_FIXED_CID),
                TRUE
                );
            ExFreePool( deviceExtension->Processor.CompatibleID );
            deviceExtension->Processor.CompatibleID = NULL;

        }

        //
        // Remember that we failed init
        //
        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            DEV_PROP_FAILED_INIT,
            TRUE
            );

    } else {

        ACPIDevPrint( (
            ACPI_PRINT_LOADING,
            deviceExtension,
            "ACPIBuildProcessorExtension: = %08lx\n",
            status
            ) );

    }

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIBuildProcessorRequest(
    IN  PDEVICE_EXTENSION       ProcessorExtension,
    IN  PACPI_BUILD_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  BOOLEAN                 RunDPC
    )
/*++

Routine Description:

    This routine is called when a processor is ready to be filled in.
    This routine creates a request which is enqueued. When the DPC is fired,
    the request will be processed

    Note:   AcpiDeviceTreeLock must be held to call this function

Arguments:

    ThermalExtension    - The thermal zone to process
    CallBack            - The function to call when done
    CallBackContext     - The argument to pass to that function
    RunDPC              - Should we enqueue the DPC immediately (if it is not
                          running?)

Return Value:

    NTSTATUS

--*/
{
#if 0
    PACPI_BUILD_REQUEST buildRequest;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Allocate a buildRequest structure
    //
    buildRequest = ExAllocateFromNPagedLookasideList(
        &BuildRequestLookAsideList
        );
    if (buildRequest == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // If the current reference is 0, that means that someone else beat
    // use to the device extension that that we *CANNOT* touch it
    //
    if (ProcessorExtension->ReferenceCount == 0) {

        ExFreeToNPagedLookasideList(
            &BuildRequestLookAsideList,
            buildRequest
            );
        return STATUS_DEVICE_REMOVED;

    } else {

        InterlockedIncrement( &(ProcessorExtension->ReferenceCount) );

    }

    //
    // Fill in the structure
    //
    RtlZeroMemory( buildRequest, sizeof(ACPI_BUILD_REQUEST) );
    buildRequest->Signature         = ACPI_SIGNATURE;
    buildRequest->TargetListEntry   = &AcpiBuildDeviceList;
    buildRequest->WorkDone          = WORK_DONE_STEP_0;
    buildRequest->Status            = STATUS_SUCCESS;
    buildRequest->CallBack          = CallBack;
    buildRequest->CallBackContext   = CallBackContext;
    buildRequest->BuildContext      = ProcessorExtension;
    buildRequest->Flags             = BUILD_REQUEST_VALID_TARGET |
                                      BUILD_REQUEST_RELEASE_REFERENCE;

    //
    // At this point, we need the spinlock
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

    //
    // Add this to the list
    //
    InsertTailList(
        &AcpiBuildQueueList,
        &(buildRequest->ListEntry)
        );

    //
    // Do we need to queue up the DPC?
    //
    if (RunDPC && !AcpiBuildDpcRunning) {

        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );
#endif

    //
    // Done
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIBuildProcessPowerResourceFailure(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is run when we detect a failure in the Power Resource
    initialization code path

Arguments:

    BuildRequest    - The request that we have just failed

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status      = BuildRequest->Status;
    PACPI_POWER_DEVICE_NODE powerNode   = (PACPI_POWER_DEVICE_NODE) BuildRequest->BuildContext;

    //
    // Make sure that the node is marked as not being present and not having
    // been initialized
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );
    ACPIInternalUpdateFlags(
        &(powerNode->Flags),
        (DEVICE_NODE_INITIALIZED | DEVICE_NODE_PRESENT),
        TRUE
        );
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // call the generic completion handler
    //
    status = ACPIBuildProcessGenericComplete( BuildRequest );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessPowerResourcePhase0(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine finds the pointers to the _ON, _OFF, and _STA objects for
    the associated power nodes. If these pointers cannot be found, the system
    will bugcheck.

    Once the pointers are found, the _STA method is evaluated

Arguments:

    BuildRequest    - The request that we are processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status      = STATUS_ACPI_FATAL;
    PACPI_POWER_DEVICE_NODE powerNode   = (PACPI_POWER_DEVICE_NODE) BuildRequest->BuildContext;
    PNSOBJ                  nsObject;
    POBJDATA                resultData  = &(BuildRequest->DeviceRequest.ResultData);

    //
    // The next state is Phase1
    //
    BuildRequest->NextWorkDone = WORK_DONE_STEP_1;

    //
    // Get the _OFF object
    //
    nsObject = ACPIAmliGetNamedChild(
        powerNode->PowerObject,
        PACKED_OFF
        );
    if (nsObject == NULL) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_POWER_NODE_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) powerNode->PowerObject,
            PACKED_OFF,
            0
            );
        goto ACPIBuildProcessPowerResourcePhase0Exit;

    }
    powerNode->PowerOffObject = nsObject;

    //
    // Get the _ON object
    //
    nsObject = ACPIAmliGetNamedChild(
        powerNode->PowerObject,
        PACKED_ON
        );
    if (nsObject == NULL) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_POWER_NODE_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) powerNode->PowerObject,
            PACKED_ON,
            0
            );
        goto ACPIBuildProcessPowerResourcePhase0Exit;

    }
    powerNode->PowerOnObject = nsObject;

    //
    // Get the _STA object
    //
    nsObject = ACPIAmliGetNamedChild(
        powerNode->PowerObject,
        PACKED_STA
        );
    if (nsObject == NULL) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_POWER_NODE_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) powerNode->PowerObject,
            PACKED_STA,
            0
            );
        goto ACPIBuildProcessPowerResourcePhase0Exit;

    }

    //
    // Make sure that our result data structure is 'clean'
    //
    RtlZeroMemory( resultData, sizeof(OBJDATA) );

    //
    // Remember the current object that we will evalute
    //
    BuildRequest->CurrentObject = nsObject;

    //
    // Evalute the _STA object
    //
    status = AMLIAsyncEvalObject(
        nsObject,
        resultData,
        0,
        NULL,
        ACPIBuildCompleteGeneric,
        BuildRequest
        );

ACPIBuildProcessPowerResourcePhase0Exit:

    //
    // If we didn't get pending back, then call the method ourselves
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteGeneric(
            nsObject,
            status,
            resultData,
            BuildRequest
            );

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessPowerResourcePhase1(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is run after we have finished the _STA method

Arguments:

    BuildRequest    - The request that we are processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status      = STATUS_SUCCESS;
    PACPI_POWER_DEVICE_NODE powerNode   = (PACPI_POWER_DEVICE_NODE) BuildRequest->BuildContext;
    POBJDATA                result      = &(BuildRequest->DeviceRequest.ResultData);

    //
    // The next stage is Complete
    //
    BuildRequest->NextWorkDone = WORK_DONE_COMPLETE;

    //
    // Do we have an integer?
    //
    if (result->dwDataType != OBJTYPE_INTDATA) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_EXPECTED_INTEGER,
            (ULONG_PTR) powerNode->PowerObject,
            (ULONG_PTR) BuildRequest->CurrentObject,
            result->dwDataType
            );
        status = STATUS_ACPI_FATAL;
        goto ACPIBuildProcessPowerResourcePhase1Exit;

    }

    //
    // We need the spinlock to do the following
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Marked the node as having been initialized
    //
    ACPIInternalUpdateFlags(
        &(powerNode->Flags),
        DEVICE_NODE_INITIALIZED,
        FALSE
        );

    //
    // Check the device status?
    //
    ACPIInternalUpdateFlags(
        &(powerNode->Flags),
        DEVICE_NODE_PRESENT,
        (BOOLEAN) ((result->uipDataValue & STA_STATUS_PRESENT) ? FALSE : TRUE)
        );

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

ACPIBuildProcessPowerResourcePhase1Exit:

    //
    // Do not leave objects lying around without having free'ed them first
    //
    AMLIFreeDataBuffs( result, 1 );

    //
    // We don't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have duplicate code
    //
    ACPIBuildCompleteGeneric(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessQueueList(
    VOID
    )
/*++

Routine Description:

    This routine looks at all the items on the Queue list and places them
    on the appropriate build list

    N.B:    This routine is called with AcpiBuildQueueLock being owned

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    PACPI_BUILD_REQUEST buildRequest;
    PLIST_ENTRY         currentEntry    = AcpiBuildQueueList.Flink;

    //
    // Look at all the items in the list
    //
    while (currentEntry != &AcpiBuildQueueList) {

        //
        // Crack the data structure
        //
        buildRequest = CONTAINING_RECORD(
            currentEntry,
            ACPI_BUILD_REQUEST,
            ListEntry
            );

        //
        // Remove this entry from the Queue List
        //
        RemoveEntryList( currentEntry );

        //
        // Move this entry onto its new list
        //
        InsertTailList( buildRequest->TargetListEntry, currentEntry );

        //
        // We no longer need the TargetListEntry, so lets zero it to make
        // sure that we don't run into problems
        //
        buildRequest->Flags &= ~BUILD_REQUEST_VALID_TARGET;
        buildRequest->TargetListEntry = NULL;

        //
        // Look at the head of the list again
        //
        currentEntry = AcpiBuildQueueList.Flink;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildProcessRunMethodPhaseCheckBridge(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine determines if the current object is present or not

Arguments:

    BuildRequest    - The request that we are processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;

    //
    // Check the flags to see if we need to check the result of the device
    // presence test
    //
    if (BuildRequest->RunRequest.Flags & RUN_REQUEST_CHECK_STATUS) {

        //
        // Is the device present?
        //
        if ( (deviceExtension->Flags & DEV_TYPE_NOT_PRESENT) ) {

            BuildRequest->NextWorkDone = WORK_DONE_COMPLETE;
            goto ACPIBuildProcessRunMethodPhaseCheckBridgeExit;

        }

    }

    //
    // The next state is Phase2
    //
    BuildRequest->NextWorkDone = WORK_DONE_STEP_2;

    //
    // Do we have to check the device status?
    //
    if (BuildRequest->RunRequest.Flags & RUN_REQUEST_STOP_AT_BRIDGES) {

        //
        // Get the device status
        //
        BuildRequest->Integer = 0;
        status = IsPciBusAsync(
            deviceExtension->AcpiObject,
            ACPIBuildCompleteMustSucceed,
            BuildRequest,
            (BOOLEAN *) &(BuildRequest->Integer)
            );

        //
        // What happened?
        //
        ACPIDevPrint( (
            ACPI_PRINT_LOADING,
            deviceExtension,
            "ACPIBuildProcessRunMethodPhaseCheckBridge: Status = %08lx\n",
            status
            ) );
        if (status == STATUS_PENDING) {

            return status;

        }

    }

ACPIBuildProcessRunMethodPhaseCheckBridgeExit:

    //
    // Common code to handle the result of the 'Get' routine
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );


    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessRunMethodPhaseCheckSta(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine determines if the current object is present or not

Arguments:

    BuildRequest    - The request that we are processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;

    //
    // The next state is Phase1
    //
    BuildRequest->NextWorkDone = WORK_DONE_STEP_1;

    //
    // Is this a device with a 'fake' PDO?
    //
    if (deviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        BuildRequest->NextWorkDone = WORK_DONE_COMPLETE;
        goto ACPIBuildProcessRunMethodPhaseCheckStaExit;

    }

    //
    // Do we have to check the device status?
    //
    if (BuildRequest->RunRequest.Flags & RUN_REQUEST_CHECK_STATUS) {

        //
        // Get the device status
        //
        status = ACPIGetDevicePresenceAsync(
            deviceExtension,
            ACPIBuildCompleteMustSucceed,
            BuildRequest,
            (PVOID *) &(BuildRequest->Integer),
            NULL
            );

        //
        // What happened?
        //
        ACPIDevPrint( (
            ACPI_PRINT_LOADING,
            deviceExtension,
            "ACPIBuildProcessRunMethodPhaseCheckSta: Status = %08lx\n",
            status
            ) );
        if (status == STATUS_PENDING) {

            return status;

        }

    }

ACPIBuildProcessRunMethodPhaseCheckStaExit:

    //
    // Common code to handle the result of the 'Get' routine
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );


    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessRunMethodPhaseRecurse(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine does the recursion

Arguments:

    BuildRequest    - The request that we are processing

Return Value:

    NTSTATUS

--*/
{
    EXTENSIONLIST_ENUMDATA  eled ;
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       childExtension;
    PDEVICE_EXTENSION       deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;

    //
    // We are done after this
    //
    BuildRequest->NextWorkDone = WORK_DONE_COMPLETE;

    //
    // Do we recurse or not?
    //
    if (BuildRequest->RunRequest.Flags & RUN_REQUEST_RECURSIVE) {

        //
        // Walk children
        //
        ACPIExtListSetupEnum(
            &eled,
            &(deviceExtension->ChildDeviceList),
            &AcpiDeviceTreeLock,
            SiblingDeviceList,
            WALKSCHEME_HOLD_SPINLOCK
            ) ;

        for(childExtension = ACPIExtListStartEnum(&eled);
                             ACPIExtListTestElement(&eled, (BOOLEAN) NT_SUCCESS(status));
            childExtension = ACPIExtListEnumNext(&eled)) {


            //
            // Make a request to run the control method on this child
            //
            status = ACPIBuildRunMethodRequest(
                childExtension,
                NULL,
                NULL,
                BuildRequest->RunRequest.ControlMethodName,
                BuildRequest->RunRequest.Flags,
                FALSE
                );
        }
    }

    //
    // What happened
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessRunMethodPhaseRecurse: Status = %08lx\n",
        status
        ) );

    //
    // Common code
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessRunMethodPhaseRunMethod(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine determines if there is a control method to run

Arguments:

    BuildRequest    - The request that we are processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    OBJDATA             objData[2];
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    PNSOBJ              nsObj           = NULL;
    POBJDATA            args            = NULL;
    ULONGLONG           originalFlags;
    ULONG               numArgs         = 0;

    //
    // Check the flags to see if we need to check the result of the device
    // presence test
    //
    if (BuildRequest->RunRequest.Flags & RUN_REQUEST_STOP_AT_BRIDGES) {

        //
        // Is this a PCI-PCI bridge?
        //
        if (BuildRequest->Integer) {

            ACPIDevPrint( (
                ACPI_PRINT_LOADING,
                deviceExtension,
                "ACPIBuildProcessRunMethodPhaseRunMethod: Is PCI-PCI bridge\n",
                status
                ) );
            BuildRequest->NextWorkDone = WORK_DONE_COMPLETE;
            goto ACPIBuildProcessRunMethodPhaseRunMethodExit;

        }

    }

    //
    // From here, we need to go one more step
    //
    BuildRequest->NextWorkDone = WORK_DONE_STEP_3;

    //
    // If there an object present?
    //
    nsObj = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        BuildRequest->RunRequest.ControlMethodName
        );
    if (nsObj == NULL) {

        //
        // There is no method to run. Lets skip to the next stage then
        //
        goto ACPIBuildProcessRunMethodPhaseRunMethodExit;

    }

    //
    // Do we need to mark the node with the _INI flags?
    //
    if (BuildRequest->RunRequest.Flags & RUN_REQUEST_MARK_INI) {

        //
        // Attempt to set the flag so that we don't run the method twice
        //
        originalFlags = ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            DEV_PROP_RAN_INI,
            FALSE
            );
        if ( (originalFlags & DEV_PROP_RAN_INI) ) {

            //
            // If the flag was already set, then there is nothing for
            // us to do here
            //
            goto ACPIBuildProcessRunMethodPhaseRunMethodExit;

        }

    } else if (BuildRequest->RunRequest.Flags & RUN_REQUEST_CHECK_WAKE_COUNT) {

        //
        // Do we need to check the Wake count?
        //
        if (deviceExtension->PowerInfo.WakeSupportCount == 0) {

            //
            // Nothing to do
            //
            goto ACPIBuildProcessRunMethodPhaseRunMethodExit;

        }

        //
        // Setup the arguments that we will pass to the method
        //
        RtlZeroMemory( objData, sizeof(OBJDATA) );
        objData[0].uipDataValue = DATAVALUE_ONE;
        objData[0].dwDataType = OBJTYPE_INTDATA;

        //
        // Remember that we have 1 argument
        //
        args    = &objData[0];
        numArgs = 1;

    } else if (BuildRequest->RunRequest.Flags & RUN_REQUEST_REG_METHOD_ON ||
               BuildRequest->RunRequest.Flags & RUN_REQUEST_REG_METHOD_OFF) {

        //
        // First thing is to make sure that we will never recurse past a pci
        // PCI-PCI bridge
        //
        BuildRequest->RunRequest.Flags |= RUN_REQUEST_STOP_AT_BRIDGES;

        //
        // Next is that we have to initialize the arguments that we will
        // pass to the function. For historical reasons, we will only
        // pass in a REGSPACE_PCIFCFG registration
        //
        RtlZeroMemory( objData, sizeof(objData) );
        objData[0].uipDataValue = REGSPACE_PCICFG;
        objData[0].dwDataType   = OBJTYPE_INTDATA;
        objData[1].dwDataType   = OBJTYPE_INTDATA;
        if (BuildRequest->RunRequest.Flags & RUN_REQUEST_REG_METHOD_ON) {

            objData[1].uipDataValue = 1;

        } else {

            objData[1].uipDataValue = 0;

        }

        //
        // Remember that we have two arguments
        //
        args    = &objData[0];
        numArgs = 2;

    }

    //
    // Remember that we are running this control method
    //
    BuildRequest->CurrentObject = nsObj;

    //
    // Run the control method
    //
    status = AMLIAsyncEvalObject(
        nsObj,
        NULL,
        numArgs,
        args,
        ACPIBuildCompleteMustSucceed,
        BuildRequest
        );

ACPIBuildProcessRunMethodPhaseRunMethodExit:

    //
    // What happened
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessRunMethodPhaseRunMethod: Status = %08lx\n",
        status
        ) );

    //
    // Common code to handle the result of the 'Get' routine
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteMustSucceed(
            nsObj,
            status,
            NULL,
            BuildRequest
            );

    } else {

        status = STATUS_SUCCESS;

    }

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIBuildProcessSynchronizationList(
    IN  PLIST_ENTRY             ListEntry
    )
/*++

Routine Description:

    This routine looks at the elements in the synchronize list and
    determines if the can be completed

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN                 allWorkComplete = TRUE;
    NTSTATUS                status          = STATUS_SUCCESS;
    PACPI_BUILD_REQUEST     buildRequest;
    PDEVICE_EXTENSION       deviceExtension;
    PLIST_ENTRY             currentEntry    = ListEntry->Flink;

    while (currentEntry != ListEntry) {

        //
        // Turn into a build request
        //
        buildRequest = CONTAINING_RECORD(
            currentEntry,
            ACPI_BUILD_REQUEST,
            ListEntry
            );

        //
        // Set the temp pointer to the next element
        //
        currentEntry = currentEntry->Flink;

        //
        // Is the list pointed by this entry empty?
        //
        if (!IsListEmpty( (buildRequest->SynchronizeRequest.SynchronizeListEntry) ) ) {

            allWorkComplete = FALSE;
            continue;

        }

        //
        // Let the world know
        //
        deviceExtension = (PDEVICE_EXTENSION) buildRequest->BuildContext;
        ACPIDevPrint( (
            ACPI_PRINT_LOADING,
            deviceExtension,
            "ACPIBuildProcessSynchronizationList(%4s) = %08lx\n",
            buildRequest->SynchronizeRequest.SynchronizeMethodNameAsUchar,
            status
            ) );

        //
        // Complete the request
        //
        ACPIBuildProcessGenericComplete( buildRequest );

    } // while

    //
    // Have we completed all of our work?
    //
    return (allWorkComplete ? STATUS_SUCCESS : STATUS_PENDING );
}

NTSTATUS
ACPIBuildProcessThermalZonePhase0(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is run after we have build the thermal zone extension

Arguments:

    BuildRequest    - The request that we are processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   thermalExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    PTHRM_INFO          info;

    //
    // Remember to set a pointer to the next state
    //
    BuildRequest->NextWorkDone = WORK_DONE_COMPLETE;

    //
    // We need a pointer to the thermal info
    //
    info = thermalExtension->Thermal.Info;

    //
    // We need the _TMP object
    //
    info->TempMethod = ACPIAmliGetNamedChild(
        thermalExtension->AcpiObject,
        PACKED_TMP
        );
    if (info->TempMethod == NULL) {

        //
        // If we don't have one... bugcheck
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) thermalExtension,
            PACKED_TMP,
            0
            );
        goto ACPIBuildProcessThermalZonePhase0Exit;

    }

ACPIBuildProcessThermalZonePhase0Exit:

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        thermalExtension,
        "ACPIBuildProcessThermalZonePhase0: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteGeneric(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIBuildDockExtension(
    IN  PNSOBJ              CurrentObject,
    IN  PDEVICE_EXTENSION   ParentDeviceExtension
    )
/*++

Routine Description:

    This routine creates a device for CurrentObject, if it is an NameSpace
    object that ACPI might be interested as, and links into the tree of
    ParentDeviceExtension

Argument Description:

    CurrentObject           - The object that we are current interested in
    ParentDeviceExtension   - Where to link the deviceExtension into

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_NO_SUCH_DEVICE;
    PDEVICE_EXTENSION   deviceExtension = NULL;
    PUCHAR              deviceID        = NULL;
    PUCHAR              instanceID      = NULL;

    //
    // Build the device extension
    //
    status = ACPIBuildDeviceExtension(
        NULL,
        ParentDeviceExtension,
        &deviceExtension
        );
    if (!NT_SUCCESS(status) || deviceExtension == NULL) {

        return status;

    }

    //
    // At this point, we care about this device, so we will allocate some
    // memory for the deviceID, which we will build this off the ACPI node
    // name.
    //
    deviceID = ExAllocatePoolWithTag(
        NonPagedPool,
        21,
        ACPI_STRING_POOLTAG
        );
    if (deviceID == NULL) {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIBuildDockExtension: Cannot allocate 0x%04x "
            "bytes for deviceID\n",
            21
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIBuildDockExtensionExit;

    }

    //
    // The format for a deviceID is
    //  ACPI\DockDevice
    //  the ACPI node name will form the instance ID
    strcpy( deviceID, "ACPI\\DockDevice") ;
    deviceExtension->DeviceID = deviceID;

    //
    // Form the instance ID
    //
    status = ACPIAmliBuildObjectPathname(CurrentObject, &instanceID) ;
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPIBuildDockExtension: Path = %08lx\n",
            status
            ) );
        goto ACPIBuildDockExtensionExit;

    }
    deviceExtension->InstanceID = instanceID;

    //
    // And make sure we are pointed to the correct docking node
    //
    deviceExtension->Dock.CorrospondingAcpiDevice =
        (PDEVICE_EXTENSION) CurrentObject->Context ;

    //
    // By default, we update profiles only on eject
    //
    deviceExtension->Dock.ProfileDepartureStyle = PDS_UPDATE_ON_EJECT;

    //
    // If we are booting, or the device has just come back we assume _DCK has
    // already been ran if we find the device with _STA == present. We will
    // only override this assumption if Notify(Dock, 0) is called.
    //
    deviceExtension->Dock.IsolationState = IS_UNKNOWN;

    //
    // Make sure that we remember that we are a dock
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_TYPE_NOT_FOUND |
        DEV_PROP_UID | DEV_PROP_FIXED_UID |
        DEV_PROP_HID | DEV_PROP_FIXED_HID |
        DEV_PROP_NO_OBJECT | DEV_PROP_DOCK | DEV_CAP_RAW,
        FALSE
        );

ACPIBuildDockExtensionExit:

    //
    // Free any resources that we don't need because we failed. Note
    // that the way this is structured, we won't have to acquire a spinlock
    // since by the time we attempt to link in the tree, we cannot fail
    //
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPIBuildDockExtension: = %08lx\n",
            status
            ) );

        if (instanceID != NULL ) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                (DEV_PROP_HID | DEV_PROP_FIXED_HID),
                TRUE
                );
            ExFreePool( instanceID );
            deviceExtension->InstanceID = NULL;

        }
        if (deviceID != NULL) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                (DEV_PROP_HID | DEV_PROP_FIXED_HID),
                TRUE
                );
            ExFreePool( deviceID );
            deviceExtension->DeviceID = NULL;

        }

        //
        // Remember that we failed init
        //
        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            DEV_PROP_FAILED_INIT,
            TRUE
            );

    } else {

        ACPIDevPrint( (
            ACPI_PRINT_LOADING,
            deviceExtension,
            "ACPIBuildDockExtension: = %08lx\n",
            status
            ) );

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildRegRequest(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PACPI_BUILD_CALLBACK    CallBack
    )
/*++

Routine Description:

    This routine is called when a device is turned on, and we need to tell
    the AML that the regionspace behind it are available

Arguments:

    DeviceObject    - The target device object
    Irp             - The target irp
    CallBack        - The routine to call when done

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  deviceState;
    KIRQL               oldIrql;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    ULONG               methodFlags;

    //
    // Grab the requested device state and power action
    //
    deviceState = irpStack->Parameters.Power.State.DeviceState;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIBuildRegRequest - Handle D%d\n",
        Irp,
        (deviceState - PowerDeviceD0)
        ) );

    //
    // Do we need to mark the irp as pending?
    //
    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );

    }

    //
    // Lets us look at the current status code for the request. On error,
    // we will just call the completion right now, and it is responsible
    // for doing the 'right' thing
    //
    status = Irp->IoStatus.Status;
    if (!NT_SUCCESS(status)) {

        //
        // Call the completion routine and return
        //
        if (*CallBack != NULL ) {

            (*CallBack)(
                deviceExtension,
                Irp,
                status
                );

        }
        return status;

    }

    //
    // Calculate the flags that we will use
    //
    methodFlags = (RUN_REQUEST_CHECK_STATUS | RUN_REQUEST_RECURSIVE);
    if (deviceState == PowerDeviceD0) {

        methodFlags |= RUN_REQUEST_REG_METHOD_ON;

    } else {

        methodFlags |= RUN_REQUEST_REG_METHOD_OFF;

    }

    //
    // Queue the request --- this function will always return
    // MORE_PROCESSING_REQUIRED instead of PENDING, so we don't have
    // to mess with it
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
    status = ACPIBuildRunMethodRequest(
        deviceExtension,
        CallBack,
        (PVOID) Irp,
        PACKED_REG,
        methodFlags,
        TRUE
        );
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
    if (status == STATUS_PENDING) {

        status = STATUS_MORE_PROCESSING_REQUIRED;

    }
    return status;
}

NTSTATUS
ACPIBuildRegOffRequest(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PACPI_BUILD_CALLBACK    CallBack
    )
/*++

Routine Description:

    This routine is called when a device is turned off, and we need to tell
    the AML that the regionspace behind it are not available

Arguments:

    DeviceObject    - The target device object
    Irp             - The target irp
    CallBack        - The routine to call when done

Return Value:

    NTSTATUS

--*/
{
    return ACPIBuildRegRequest( DeviceObject, Irp, CallBack );
}

NTSTATUS
ACPIBuildRegOnRequest(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PACPI_BUILD_CALLBACK    CallBack
    )
/*++

Routine Description:

    This routine is called when a device is turned on, and we need to tell
    the AML that the regionspace behind it are now available

Arguments:

    DeviceObject    - The target device object
    Irp             - The target irp
    CallBack        - The routine to call when done

Return Value:

    NTSTATUS

--*/
{
    ACPIBuildRegRequest( DeviceObject, Irp, CallBack );
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
ACPIBuildRunMethodRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PACPI_BUILD_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  ULONG                   MethodName,
    IN  ULONG                   MethodFlags,
    IN  BOOLEAN                 RunDPC
    )
/*++

Routine Description:

    This routine is called to request that a control method be run
    recursively on the device tree

    Note:   AcpiDeviceTreeLock must be held to call this function

Arguments:

    DeviceExtension - The device extension to run the method on
    MethodName      - The name of the method to run
    RunDpc          - Should we run the dpc?

Return Value:

    NTSTATUS

--*/
{
    PACPI_BUILD_REQUEST buildRequest;
    PACPI_BUILD_REQUEST syncRequest;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Allocate a buildRequest structure
    //
    buildRequest = ExAllocateFromNPagedLookasideList(
        &BuildRequestLookAsideList
        );
    if (buildRequest == NULL) {

        if (CallBack != NULL) {

            (*CallBack)(
                 DeviceExtension,
                 CallBackContext,
                 STATUS_INSUFFICIENT_RESOURCES
                 );

        }
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Do we need to have the 2nd buildrequest structure?
    //
    if (CallBack != NULL) {

        syncRequest = ExAllocateFromNPagedLookasideList(
            &BuildRequestLookAsideList
            );
        if (syncRequest == NULL) {

            ExFreeToNPagedLookasideList(
                &BuildRequestLookAsideList,
                buildRequest
                );
            (*CallBack)(
                 DeviceExtension,
                 CallBackContext,
                 STATUS_INSUFFICIENT_RESOURCES
                 );
            return STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    //
    // If the current reference is 0, that means that someone else beat
    // use to the device extension that that we *CANNOT* touch it
    //
    if (DeviceExtension->ReferenceCount == 0) {

        ExFreeToNPagedLookasideList(
            &BuildRequestLookAsideList,
            buildRequest
            );
        if (CallBack != NULL) {

            ExFreeToNPagedLookasideList(
                &BuildRequestLookAsideList,
                syncRequest
                );
            (*CallBack)(
                 DeviceExtension,
                 CallBackContext,
                 STATUS_DEVICE_REMOVED
                 );

        }
        return STATUS_DEVICE_REMOVED;

    } else {

        InterlockedIncrement( &(DeviceExtension->ReferenceCount) );
        if (CallBack != NULL) {

            //
            // Grab second reference
            //
            InterlockedIncrement( &(DeviceExtension->ReferenceCount) );

        }
    }

    //
    // Fill in the structure
    //
    RtlZeroMemory( buildRequest, sizeof(ACPI_BUILD_REQUEST) );
    buildRequest->Signature                    = ACPI_SIGNATURE;
    buildRequest->TargetListEntry              = &AcpiBuildRunMethodList;
    buildRequest->WorkDone                     = WORK_DONE_STEP_0;
    buildRequest->Status                       = STATUS_SUCCESS;
    buildRequest->BuildContext                 = DeviceExtension;
    buildRequest->RunRequest.ControlMethodName = MethodName;
    buildRequest->RunRequest.Flags             = MethodFlags;
    buildRequest->Flags                        = BUILD_REQUEST_VALID_TARGET |
                                                 BUILD_REQUEST_RUN          |
                                                 BUILD_REQUEST_RELEASE_REFERENCE;

    //
    // Do we have to call the callback? If so, we need a 2nd request to
    // queue up to the synchronize list
    //
    if (CallBack != NULL) {

        //
        // Fill in the structure
        //
        RtlZeroMemory( syncRequest, sizeof(ACPI_BUILD_REQUEST) );
        syncRequest->Signature             = ACPI_SIGNATURE;
        syncRequest->TargetListEntry       = &AcpiBuildSynchronizationList;
        syncRequest->WorkDone              = WORK_DONE_STEP_0;
        syncRequest->NextWorkDone          = WORK_DONE_COMPLETE;
        syncRequest->Status                = STATUS_SUCCESS;
        syncRequest->CallBack              = CallBack;
        syncRequest->CallBackContext       = CallBackContext;
        syncRequest->BuildContext          = DeviceExtension;
        syncRequest->SynchronizeRequest.SynchronizeListEntry =
            &AcpiBuildRunMethodList;
        syncRequest->SynchronizeRequest.SynchronizeMethodName =
            MethodName;
        syncRequest->Flags                 = BUILD_REQUEST_VALID_TARGET |
                                             BUILD_REQUEST_SYNC         |
                                             BUILD_REQUEST_RELEASE_REFERENCE;
        syncRequest->SynchronizeRequest.Flags = SYNC_REQUEST_HAS_METHOD;

    }

    //
    // At this point, we need the spinlock
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

    //
    // Add this to the list
    //
    InsertTailList(
        &AcpiBuildQueueList,
        &(buildRequest->ListEntry)
        );

    if (CallBack != NULL) {

        InsertTailList(
            &AcpiBuildQueueList,
            &(syncRequest->ListEntry)
            );

    }

    //
    // Do we need to queue up the DPC?
    //
    if (RunDPC && !AcpiBuildDpcRunning) {

        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

    //
    // Done
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIBuildSurpriseRemovedExtension(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine is called when the system wants to turn the above
    extension into a surprised removed one

Arguments:

    DeviceExtension - The extension that is being surprised removed

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   oldIrql;
    PDEVICE_EXTENSION       dockExtension;
    PDEVICE_EXTENSION       parentExtension, childExtension;
    EXTENSIONLIST_ENUMDATA  eled;

    //
    // This device might have a corrosponding fake extension. Find out now - if
    // it exists we must nuke it.
    //
    dockExtension = ACPIDockFindCorrespondingDock( DeviceExtension );

    if (dockExtension) {

        //
        // We have a fake dock, nuke it too since it's underlying hardware is
        // gone.
        //
        dockExtension->DeviceState = SurpriseRemoved;
        ACPIBuildSurpriseRemovedExtension( dockExtension );
    }

    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_REFERENCE_ENTRIES
        );

    for(childExtension = ACPIExtListStartEnum(&eled);
                         ACPIExtListTestElement(&eled, TRUE);
        childExtension = ACPIExtListEnumNext(&eled)) {

        ACPIBuildSurpriseRemovedExtension(childExtension);
    }

    //
    // We also want to flush the power queue to insure that any events
    // dealing with the removed object go away as fast as possible...
    //
    ACPIDevicePowerFlushQueue( DeviceExtension );

    //
    // At this point, we don't think the device is coming back, so we
    // need to fully remove this extension. The first step to do that
    // is mark the extension as appropriate, and to do that, we need
    // the device spin lock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Clear the flags for this extension
    //
    if (DeviceExtension->Flags & DEV_TYPE_PDO) {

        ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_MASK_TYPE, TRUE );
        ACPIInternalUpdateFlags(
            &(DeviceExtension->Flags),
            (DEV_TYPE_PDO | DEV_TYPE_SURPRISE_REMOVED | DEV_PROP_NO_OBJECT | DEV_TYPE_NOT_ENUMERATED),
            FALSE
            );
        DeviceExtension->DispatchTable = &AcpiSurpriseRemovedPdoIrpDispatch;

    } else if (DeviceExtension->Flags & DEV_TYPE_FILTER) {

        ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_MASK_TYPE, TRUE );
        ACPIInternalUpdateFlags(
            &(DeviceExtension->Flags),
            (DEV_TYPE_FILTER | DEV_TYPE_SURPRISE_REMOVED | DEV_PROP_NO_OBJECT | DEV_TYPE_NOT_ENUMERATED),
            FALSE
            );
        DeviceExtension->DispatchTable = &AcpiSurpriseRemovedFilterIrpDispatch;

    }

    //
    // At this point, we are going to have to make a call ---
    // do we re-build the original device extension in the tree
    // or do we forget about it. We have to forget about it if the
    // table is being unloaded. We need to make this decision while
    // we still have a pointer to the parent extension...
    //
    if (!(DeviceExtension->Flags & DEV_PROP_UNLOADING) ) {

        //
        // Set the bit to cause the parent to rebuild missing
        // children on QDR
        //
        parentExtension = DeviceExtension->ParentExtension;
        if (parentExtension) {

            ACPIInternalUpdateFlags(
                &(parentExtension->Flags),
                DEV_PROP_REBUILD_CHILDREN,
                FALSE
                );

            if (DeviceExtension->AcpiObject &&
                ACPIDockIsDockDevice(DeviceExtension->AcpiObject)) {

                ASSERT(parentExtension->PhysicalDeviceObject != NULL);

                //
                // This will cause us to rebuild this extension afterwards. We
                // need this because notify attempts on docks require fully
                // built and processed device extensions.
                //
                IoInvalidateDeviceRelations(
                    parentExtension->PhysicalDeviceObject,
                    SingleBusRelations
                    );
            }
        }
    }

    //
    // Remove this extension from the tree. This will nuke the pointer
    // to the parent extension (that's the link that gets cut from the
    // tree)
    //
    ACPIInitRemoveDeviceExtension( DeviceExtension );

    //
    // Remember to make sure that the ACPI Object no longer points to this
    // device extension
    //
    if (DeviceExtension->AcpiObject) {

        DeviceExtension->AcpiObject->Context = NULL;
    }

    //
    // Are we a thermal zone?
    //
    if (DeviceExtension->Flags & DEV_CAP_THERMAL_ZONE) {

        //
        // Do Some Clean-up by flushing all the currently queued requests
        //
        ACPIThermalCompletePendingIrps(
            DeviceExtension,
            DeviceExtension->Thermal.Info
            );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildSynchronizationRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PACPI_BUILD_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  PLIST_ENTRY             SynchronizeListEntry,
    IN  BOOLEAN                 RunDPC
    )
/*++

Routine Description:

    This routine is called when the system wants to know when the DPC routine
    has been completed.

Arguments:

    DeviceExtension     - This is the device extension that we are
                          typically interested in. Usually, it will be the
                          root node
    CallBack            - The function to call when done
    CallBackContext     - The argument to pass to that function
    Event               - The event to notify when done
    RunDpc              - Should we run the dpc?

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    PACPI_BUILD_REQUEST buildRequest;

    //
    // Allocate a buildRequest structure
    //
    buildRequest = ExAllocateFromNPagedLookasideList(
        &BuildRequestLookAsideList
        );
    if (buildRequest == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // We need the device tree lock while we look at the device
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // If the current reference is 0, that means that someone else beat
    // use to the device extension that that we *CANNOT* touch it
    //
    if (DeviceExtension->ReferenceCount == 0) {

        ExFreeToNPagedLookasideList(
            &BuildRequestLookAsideList,
            buildRequest
            );
        return STATUS_DEVICE_REMOVED;

    } else {

        InterlockedIncrement( &(DeviceExtension->ReferenceCount) );

    }

    //
    // Fill in the structure
    //
    RtlZeroMemory( buildRequest, sizeof(ACPI_BUILD_REQUEST) );
    buildRequest->Signature             = ACPI_SIGNATURE;
    buildRequest->TargetListEntry       = &AcpiBuildSynchronizationList;
    buildRequest->WorkDone              = WORK_DONE_STEP_0;
    buildRequest->NextWorkDone          = WORK_DONE_COMPLETE;
    buildRequest->Status                = STATUS_SUCCESS;
    buildRequest->CallBack              = CallBack;
    buildRequest->CallBackContext       = CallBackContext;
    buildRequest->BuildContext          = DeviceExtension;
    buildRequest->SynchronizeRequest.SynchronizeListEntry =
        SynchronizeListEntry;
    buildRequest->Flags                 = BUILD_REQUEST_VALID_TARGET |
                                          BUILD_REQUEST_SYNC         |
                                          BUILD_REQUEST_RELEASE_REFERENCE;

    //
    // Done looking at the device
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // At this point, we need the build queue spinlock
    //
    KeAcquireSpinLock( &AcpiBuildQueueLock, &oldIrql );

    //
    // Add this to the list. We add the request to the head
    // of the list because we want to guarantee a LIFO ordering
    //
    InsertHeadList(
        &AcpiBuildQueueList,
        &(buildRequest->ListEntry)
        );

    //
    // Do we need to queue up the DPC?
    //
    if (RunDPC && !AcpiBuildDpcRunning) {

        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiBuildQueueLock, oldIrql );

    //
    // Done
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIBuildThermalZoneExtension(
    IN  PNSOBJ                  ThermalObject,
    IN  PDEVICE_EXTENSION       ParentExtension,
    IN  PDEVICE_EXTENSION       *ResultExtension
    )
/*++

Routine Description:

    Since we leverage ACPIBuildDeviceExtension for the core of the thermal
    extension, we don't have much to do here. However, we are responsible
    for making sure that we do tasks that don't require calling the interpreter,
    and a unique to the ThermalZone here

    N.B. This function is called with AcpiDeviceTreeLock being held

Arguments:

    ThermalObject   - The object we care about
    ParentExtension - Who our parent is
    ResultExtension - Where to store the extension that we build

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   thermalExtension;
    PTHRM_INFO          info;

    //
    // Build the extension
    //
    status = ACPIBuildDeviceExtension(
        ThermalObject,
        ParentExtension,
        ResultExtension
        );
    if (!NT_SUCCESS(status) || *ResultExtension == NULL) {

        return status;

    }

    thermalExtension = *ResultExtension;

    //
    // Make sure to remember that this is in fact a thermal zone
    //
    ACPIInternalUpdateFlags(
        &(thermalExtension->Flags),
        (DEV_CAP_THERMAL_ZONE | DEV_MASK_THERMAL | DEV_CAP_RAW | DEV_CAP_NO_STOP),
        FALSE
        );

    //
    // Allocate the additional thermal device storage
    //
    info = thermalExtension->Thermal.Info = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(THRM_INFO),
        ACPI_THERMAL_POOLTAG
        );
    if (thermalExtension->Thermal.Info == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            thermalExtension,
            "ACPIBuildThermalZoneExtension: failed to allocate %08 bytes\n",
            sizeof(THRM_INFO)
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIBuildThermalZoneExtensionExit;

    }

    //
    // Make sure that the memory is freshly scrubbed
    //
    RtlZeroMemory( thermalExtension->Thermal.Info, sizeof(THRM_INFO) );

    //
    // Allocate memory for the HID
    //
    thermalExtension->DeviceID = ExAllocatePoolWithTag(
        NonPagedPool,
        strlen(ACPIThermalZoneId) + 1,
        ACPI_STRING_POOLTAG
        );
    if (thermalExtension->DeviceID == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            thermalExtension,
            "ACPIBuildThermalZoneExtension: failed to allocate %08 bytes\n",
            strlen(ACPIThermalZoneId) + 1
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIBuildThermalZoneExtensionExit;

    }
    RtlCopyMemory(
        thermalExtension->DeviceID,
        ACPIThermalZoneId,
        strlen(ACPIThermalZoneId) + 1
        );

    //
    // Allocate memory for the UID
    //
    thermalExtension->InstanceID = ExAllocatePoolWithTag(
        NonPagedPool,
        5,
        ACPI_STRING_POOLTAG
        );
    if (thermalExtension->InstanceID == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            thermalExtension,
            "ACPIBuildThermalZoneExtension: failed to allocate %08 bytes\n",
            5
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIBuildThermalZoneExtensionExit;

    }
    RtlCopyMemory(
        thermalExtension->InstanceID,
        (PUCHAR) &(thermalExtension->AcpiObject->dwNameSeg),
        4
        );
    thermalExtension->InstanceID[4] = '\0';

    //
    // Set the flags for the work that we have just done
    //
    ACPIInternalUpdateFlags(
        &(thermalExtension->Flags),
        (DEV_PROP_HID | DEV_PROP_FIXED_HID | DEV_PROP_UID | DEV_PROP_FIXED_UID),
        FALSE
        );

ACPIBuildThermalZoneExtensionExit:

    //
    // Handle the case where we might have failed
    //
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            thermalExtension,
            "ACPIBuildThermalZoneExtension: = %08lx\n",
            status
            ) );

        if (thermalExtension->InstanceID != NULL) {

            ACPIInternalUpdateFlags(
                &(thermalExtension->Flags),
                (DEV_PROP_UID | DEV_PROP_FIXED_UID),
                TRUE
                );
            ExFreePool( thermalExtension->InstanceID );
            thermalExtension->InstanceID = NULL;

        }

        if (thermalExtension->DeviceID != NULL) {

            ACPIInternalUpdateFlags(
                &(thermalExtension->Flags),
                (DEV_PROP_HID | DEV_PROP_FIXED_HID),
                TRUE
                );
            ExFreePool( thermalExtension->DeviceID );
            thermalExtension->DeviceID = NULL;

        }

        if (thermalExtension->Thermal.Info != NULL) {

            ExFreePool( thermalExtension->Thermal.Info );
            thermalExtension->Thermal.Info = NULL;

        }

        //
        // Remember that we failed init
        //
        ACPIInternalUpdateFlags(
            &(thermalExtension->Flags),
            DEV_PROP_FAILED_INIT,
            TRUE
            );

    } else {

        ACPIDevPrint( (
            ACPI_PRINT_LOADING,
            thermalExtension,
            "ACPIBuildThermalZoneExtension: = %08lx\n",
            status
            ) );

    }

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIBuildThermalZoneRequest(
    IN  PDEVICE_EXTENSION       ThermalExtension,
    IN  PACPI_BUILD_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  BOOLEAN                 RunDPC
    )
/*++

Routine Description:

    This routine is called when a thermal zone is ready to be filled in.
    This routine creates a request which is enqueued. When the DPC is fired,
    the request will be processed

    Note:   AcpiDeviceTreeLock must be held to call this function

Arguments:

    ThermalExtension    - The thermal zone to process
    CallBack            - The function to call when done
    CallBackContext     - The argument to pass to that function
    RunDPC              - Should we enqueue the DPC immediately (if it is not
                          running?)

Return Value:

    NTSTATUS

--*/
{
    PACPI_BUILD_REQUEST buildRequest;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Allocate a buildRequest structure
    //
    buildRequest = ExAllocateFromNPagedLookasideList(
        &BuildRequestLookAsideList
        );
    if (buildRequest == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // If the current reference is 0, that means that someone else beat
    // use to the device extension that that we *CANNOT* touch it
    //
    if (ThermalExtension->ReferenceCount == 0) {

        ExFreeToNPagedLookasideList(
            &BuildRequestLookAsideList,
            buildRequest
            );
        return STATUS_DEVICE_REMOVED;

    } else {

        InterlockedIncrement( &(ThermalExtension->ReferenceCount) );

    }

    //
    // Fill in the structure
    //
    RtlZeroMemory( buildRequest, sizeof(ACPI_BUILD_REQUEST) );
    buildRequest->Signature         = ACPI_SIGNATURE;
    buildRequest->TargetListEntry   = &AcpiBuildThermalZoneList;
    buildRequest->WorkDone          = WORK_DONE_STEP_0;
    buildRequest->Status            = STATUS_SUCCESS;
    buildRequest->CallBack          = CallBack;
    buildRequest->CallBackContext   = CallBackContext;
    buildRequest->BuildContext      = ThermalExtension;
    buildRequest->Flags             = BUILD_REQUEST_VALID_TARGET |
                                      BUILD_REQUEST_RELEASE_REFERENCE;

    //
    // At this point, we need the spinlock
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

    //
    // Add this to the list
    //
    InsertTailList(
        &AcpiBuildQueueList,
        &(buildRequest->ListEntry)
        );

    //
    // Do we need to queue up the DPC?
    //
    if (RunDPC && !AcpiBuildDpcRunning) {

        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

    //
    // Done
    //
    return STATUS_PENDING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\button.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    button.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _BUTTON_H_
#define _BUTTON_H_

    extern KSPIN_LOCK     AcpiButtonLock;
    extern LIST_ENTRY     AcpiButtonList;
    extern PDEVICE_OBJECT FixedButtonDeviceObject;

    VOID
    ACPIButtonCancelRequest(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    BOOLEAN
    ACPIButtonCompletePendingIrps(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  ULONG           ButtonEvent
        );


    NTSTATUS
    ACPIButtonDeviceControl (
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIButtonEvent (
        IN PDEVICE_OBJECT   DeviceObject,
        IN ULONG            ButtonEvent,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIButtonStartDevice (
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\bus.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    bus.h

Abstract:

    This module contains the bus dispatcher for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _BUS_H_
#define _BUS_H_

extern LIST_ENTRY AcpiUnresolvedEjectList;

#define CompareGuid(g1, g2)  ( (g1) == (g2) \
                                 ? TRUE \
                                 : RtlCompareMemory( (g1), (g2), sizeof(GUID) ) == sizeof(GUID) \
                             )

    NTSTATUS
    ACPIBusAndFilterIrpEject(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PVOID                   Context,
        IN  BOOLEAN                 ProcessingFilterIrp
        );

    NTSTATUS
    ACPIBusAndFilterIrpQueryCapabilities(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PVOID                   Context,
        IN  BOOLEAN                 ProcessingFilterIrp
        );

    NTSTATUS
    ACPIBusAndFilterIrpQueryEjectRelations(
        IN     PDEVICE_OBJECT       DeviceObject,
        IN     PIRP                 Irp,
        IN OUT PDEVICE_RELATIONS    *PdeviceRelations
        );

    NTSTATUS
    ACPIBusAndFilterIrpQueryPnpDeviceState(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PVOID                   Context,
        IN  BOOLEAN                 ProcessingFilterIrp
        );

    NTSTATUS
    ACPIBusAndFilterIrpSetLock(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PVOID                   Context,
        IN  BOOLEAN                 ProcessingFilterIrp
        );

    NTSTATUS
    ACPIBusIrpCancelRemoveOrStopDevice(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpDeviceUsageNotification(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpEject(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    VOID
    ACPIBusAndFilterIrpEjectCancelRoutine(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    VOID
    ACPIBusAndFilterIrpEjectComplete(
        IN  PDEVICE_EXTENSION  DeviceExtension,
        IN  PIRP               Irp OPTIONAL,
        IN  NTSTATUS           Status
        );

    NTSTATUS
    ACPIBusIrpQueryBusInformation(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryBusRelations(
        IN     PDEVICE_OBJECT       DeviceObject,
        IN     PIRP                 Irp,
        IN OUT PDEVICE_RELATIONS    *PdeviceRelations
        );

    NTSTATUS
    ACPIBusIrpQueryCapabilities(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryDeviceRelations(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryId(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryInterface(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryPnpDeviceState(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryPower(
         IN  PDEVICE_OBJECT          DeviceObject,
         IN  PIRP                    Irp
         );

    NTSTATUS
    ACPIBusIrpQueryRemoveOrStopDevice(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryResources(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryResourceRequirements(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryTargetRelation(
        IN     PDEVICE_OBJECT       DeviceObject,
        IN     PIRP                 Irp,
        IN OUT PDEVICE_RELATIONS    *PdeviceRelations
        );

    NTSTATUS
    ACPIBusIrpRemoveDevice(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpSetLock(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpSetDevicePower(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PIO_STACK_LOCATION      IrpStack
        );

    NTSTATUS
    ACPIBusIrpSetPower(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpSetSystemPower(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PIO_STACK_LOCATION      IrpStack
        );

    NTSTATUS
    ACPIBusIrpSetSystemPowerComplete(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  UCHAR                   MinorFunction,
        IN  POWER_STATE             PowerState,
        IN  PVOID                   Context,
        IN  PIO_STATUS_BLOCK        IoStatus
        );

    NTSTATUS
    ACPIBusIrpStartDevice(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    VOID
    ACPIBusIrpStartDeviceCompletion(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PVOID                   Context,
        IN  NTSTATUS                Status
        );

    VOID
    ACPIBusIrpStartDeviceWorker(
        IN  PVOID                   Context
        );

    NTSTATUS
    ACPIBusIrpStopDevice(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpSurpriseRemoval(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpUnhandled(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    VOID
    SmashInterfaceQuery(
        IN OUT PIRP                 Irp
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\button.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    button.c

Abstract:

    Fixed button support

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July 7, 1997    - Complete Rewrite

--*/

#include "pch.h"

PDEVICE_OBJECT FixedButtonDeviceObject;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIButtonStartDevice)
#endif

//
// Spinlock to protect the thermal list
//
KSPIN_LOCK  AcpiButtonLock;

//
// List entry to store the thermal requests on
//
LIST_ENTRY  AcpiButtonList;


VOID
ACPIButtonCancelRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine cancels an outstanding button request

Arguments:

    DeviceObject    - the device which as a request being cancelled
    Irp             - the cancelling irp

Return Value:

    None

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    //
    // We no longer need the cancel lock
    //
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    // We do however need the button queue lock
    //
    KeAcquireSpinLock( &AcpiButtonLock, &oldIrql );

    //
    // Remove the irp from the list that it is on
    //
    RemoveEntryList( &(Irp->Tail.Overlay.ListEntry) );

    //
    // Complete the irp now
    //
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
}

BOOLEAN
ACPIButtonCompletePendingIrps(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  ULONG           ButtonEvent
    )
/*++

Routine Description:

    This routine completes any pending button irp sent to the specified
    device object with the knowledge of which button events have occured

    The respective's button's spinlock is held during this call

Arguments:

    DeviceObject    - the target button object
    ButtonEvent     - the button event that occured

Return Value:

    TRUE if we completed an irp, FALSE, otherwise

--*/
{
    BOOLEAN             handledRequest = FALSE;
    KIRQL               oldIrql;
    LIST_ENTRY          doneList;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpSp;
    PIRP                irp;
    PLIST_ENTRY         listEntry;
    PULONG              resultBuffer;

    //
    // Initialize the list that will hold the requests that we need to
    // complete
    //
    InitializeListHead( &doneList );

    //
    // Acquire the thermal lock so that we can pend these requests
    //
    KeAcquireSpinLock( &AcpiButtonLock, &oldIrql );

    //
    // Walk the list of pending irps to see which ones match this extension
    //
    listEntry = AcpiButtonList.Flink;
    while (listEntry != &AcpiButtonList) {

        //
        // Grab the irp from the list entry and update the next list entry
        // that we will look at
        //
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        listEntry = listEntry->Flink;

        //
        // We need the current irp stack location
        //
        irpSp = IoGetCurrentIrpStackLocation( irp );

        //
        // what is the target object for this irp?
        //
        targetObject = irpSp->DeviceObject;

        //
        // Is this an irp that we care about? IE: does the does target mage
        // the ones specified in this function
        //
        if (targetObject != DeviceObject) {

            continue;

        }

        //
        // At this point, we need to set the cancel routine to NULL because
        // we are going to take care of this irp and we don't want it cancelled
        // underneath us
        //
        if (IoSetCancelRoutine(irp, NULL) == NULL) {

            //
            // Cancel routine is active. stop processing this irp and move on
            //
            continue;

        }

        //
        // set the data to return in the irp
        //
        resultBuffer  = (PULONG) irp->AssociatedIrp.SystemBuffer;
        *resultBuffer = ButtonEvent;
        irp->IoStatus.Status = STATUS_SUCCESS;
        irp->IoStatus.Information = sizeof(ULONG);

        //
        // Remove the entry from the list
        //
        RemoveEntryList( &(irp->Tail.Overlay.ListEntry) );

        //
        // Insert the list onto the next queue, so that we know how to
        // complete it later on
        //
        InsertTailList( &doneList, &(irp->Tail.Overlay.ListEntry) );

    }

    //
    // At this point, droup our button lock
    //
    KeReleaseSpinLock( &AcpiButtonLock, oldIrql );

    //
    // Walk the list of irps to be completed
    //
    listEntry = doneList.Flink;
    while (listEntry != &doneList) {

        //
        // Grab the irp from the list entry, update the next list entry
        // that we will look at, and complete the request
        //
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        listEntry = listEntry->Flink;
        RemoveEntryList( &(irp->Tail.Overlay.ListEntry) );

        //
        // Complete the request and remember that we handled a request
        //
        IoCompleteRequest( irp, IO_NO_INCREMENT );
        handledRequest = TRUE;


    }

    //
    // Return wether or not we handled a request
    //
    return handledRequest;
}

NTSTATUS
ACPIButtonDeviceControl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    Fixed button device IOCTL handler

Arguments:

    DeviceObject    - fixed feature button device object
    Irp             - the ioctl request

Return Value:

    Status

--*/
{
    KIRQL                   oldIrql;
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION      irpSp           = IoGetCurrentIrpStackLocation(Irp);
    PULONG                  resultBuffer;

    //
    // Do not allow user mode IRPs in this routine
    //
    if (Irp->RequestorMode != KernelMode) {

        return ACPIDispatchIrpInvalid( DeviceObject, Irp );

    }

    resultBuffer = (PULONG) Irp->AssociatedIrp.SystemBuffer;

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_GET_SYS_BUTTON_CAPS:

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength != sizeof(ULONG)) {

            status = STATUS_INFO_LENGTH_MISMATCH;
            Irp->IoStatus.Information = 0;

        } else {

            *resultBuffer = deviceExtension->Button.Capabilities;
            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(ULONG);

        }

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;

    case IOCTL_GET_SYS_BUTTON_EVENT:

        //
        // Make sure our buffer is big enough
        //
        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength != sizeof(ULONG)) {

            Irp->IoStatus.Status = status = STATUS_INFO_LENGTH_MISMATCH;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
            break;

        }

        //
        // Grab the button lock, queue the request to the proper place, and
        // make sure to set a cancel routine
        //
        KeAcquireSpinLock( &AcpiButtonLock, &oldIrql );
        IoSetCancelRoutine( Irp, ACPIButtonCancelRequest);
        if (Irp->Cancel && IoSetCancelRoutine( Irp, NULL) ) {

            //
            // If we got here, that measn that the irp has been cancelled and
            // that we beat the IO manager to the ButtonLock. So release the
            // irp and mark the irp as being cancelled
            //
            KeReleaseSpinLock( &AcpiButtonLock, oldIrql );
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = status = STATUS_CANCELLED;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            break;

        }

        //
        // If we got here, that means we are going to the queue the request and so
        // some work on it later
        //
        IoMarkIrpPending( Irp );

        //
        // Queue the irp into a queue
        //
        InsertTailList( &AcpiButtonList, &(Irp->Tail.Overlay.ListEntry) );

        //
        // Done with the lock at this point
        //
        KeReleaseSpinLock( &AcpiButtonLock, oldIrql );

        //
        // Fire off the work thread
        //
        status = ACPIButtonEvent( DeviceObject, 0, NULL );
        break ;

    default:

        status = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;

    }
    return status;
}

NTSTATUS
ACPIButtonEvent (
    IN PDEVICE_OBJECT   DeviceObject,
    IN ULONG            ButtonEvent,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine applies and event mask and irp to the button device.
    If there's a pending event and an irp to handle it, the irp will
    be completed

Arguments:

    DeviceObject    - fixed feature button device object
    ButtonEvent     - events to apply to the device
    Irp             - irp to capture the next events

Return Value:

    Status

--*/
{
    BOOLEAN                 completedIrp;
    KIRQL                   oldIrql;
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PULONG                  resultBuffer;

    UNREFERENCED_PARAMETER( Irp );

    if ((ButtonEvent & (SYS_BUTTON_SLEEP | SYS_BUTTON_POWER | SYS_BUTTON_WAKE)) &&
        !(deviceExtension->Button.Capabilities & SYS_BUTTON_LID)) {

        //
        // Notify that the user is present, except if we happen to be
        // messing with the lid.  The kernel will set the user-present
        // bit there, and we don't want the screen to turn on when
        // the user closes the lid.
        //

        PoSetSystemState (ES_USER_PRESENT);
    }

    if (!DeviceObject) {

        return (STATUS_SUCCESS);

    }

    //
    // Set pending info
    //
    KeAcquireSpinLock (&(deviceExtension->Button.SpinLock), &oldIrql);
    deviceExtension->Button.Events |= ButtonEvent;

    //
    // Are there any outstanding events? If so, then try to complete all
    // the pending irps against that button with the list of events
    //
    if (deviceExtension->Button.Events) {

        completedIrp = ACPIButtonCompletePendingIrps(
            DeviceObject,
            deviceExtension->Button.Events
            );
        if (completedIrp) {

            deviceExtension->Button.Events = 0;

        }

    }
    KeReleaseSpinLock (&(deviceExtension->Button.SpinLock), oldIrql);

    //
    // Always return pending
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIButtonStartDevice (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    Start device function for the fixed feature power and sleep device

Arguments:

    DeviceObject    - fixed feature button device object
    Irp             - the start request

Return Value:

    Status

--*/
{
    NTSTATUS        Status;

    Status = ACPIInternalSetDeviceInterface (
        DeviceObject,
        (LPGUID) &GUID_DEVICE_SYS_BUTTON
        );

    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\callback.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    callback.c

Abstract:

    This module implements all the callbacks that are NT specific from
    the AML Interperter

Environment

    Kernel mode only

Revision History:

    04-Jun-97 Initial Revision
    01-Mar-98 Split off all the OSNotify() into osnotify.c
    02-Mar-98 Rewrite to make the notifactions work at DPC level
    13-Mar-00 Rewrite to handle Load()/Unload()

--*/

#include "pch.h"

//
// Keep track of the number of Loads and Unloads present in the system
//
ULONG   AcpiTableDelta = 0;

NTSTATUS
EXPORT
ACPICallBackLoad(
    IN  ULONG   EventType,
    IN  ULONG   NotifyType,
    IN  ULONG   EventData,
    IN  PNSOBJ  AcpiObject,
    IN  ULONG   EventParameter
    )
/*++

Routine Description:

    This routine is called when before we process the Load() and after we
    finish the Load() operator.

    The purpose of this function is to do the work required to load the
    table. We actually split the work to be done at the start of the
    load process and the work to be done after the table has been loaded

Arguments:

    EventType  - EVTYPE_OPCODE_EX
    NotifyType - This indicates wether or not we have completed the Load() yet
    EventData  - OP_LOAD
    AcpiObject - the affected name space object (ignored)
    EventParam - Supplied information (ignored)

Return Value:

    NTSTATUS

--*/
{
    ULONG   newValue;

    if (NotifyType == OPEXF_NOTIFY_PRE) {

        //
        // We are being called before the load operator. Increment
        // the count of Load()'s outstanding. If this value reaches
        // 1, then we know that this is the first instance..
        //
        newValue = InterlockedIncrement( &AcpiTableDelta );
        if (newValue == 1) {

            //
            // We need to get rid of the GPEs...
            //
            ACPIGpeClearEventMasks();

        }
        return STATUS_SUCCESS;

    }

    //
    // We are being called after the load operator. Decrement the Load()'s
    // outstanding. If this value reaches 0, then we know what we are the
    // last instance
    //
    newValue = InterlockedDecrement( &AcpiTableDelta );
    if (newValue == 0) {

        //
        // We re-enable to re-enable the GPEs
        //
        ACPIGpeBuildEventMasks();

        //
        // We also need to process the table...
        //
        ACPITableLoad();

    }
    return STATUS_SUCCESS;
}

NTSTATUS
EXPORT
ACPICallBackUnload(
    IN  ULONG   EventType,
    IN  ULONG   NotifyType,
    IN  ULONG   EventData,
    IN  PNSOBJ  AcpiObject,
    IN  ULONG   EventParameter
    )
/*++

Routine Description:

    This routine is called when the AML interpreter has started unloading
    a Differentiated Data Block

Arguments:

    EventType       - The event type (should be EVTYPE_OPCODE)
    NotifyType      - This indicates wether or not we have completed the
                      Unload() yet
    EventData       - The event subtype (should be OP_UNLOAD)
    AcpiObject      - The affected name space object (ignored)
    EventParamter   - The event specific information

Return Value:

    NTSTATUS

--*/
{
    ULONG   newValue;

    if (NotifyType == OPEXF_NOTIFY_PRE) {

        //
        // We are being called before the load operator. Increment
        // the count of Load()'s outstanding. If this value reaches
        // 1, then we know that this is the first instance..
        //
        newValue = InterlockedIncrement( &AcpiTableDelta );
        if (newValue == 1) {

            //
            // We need to get rid of the GPEs...
            //
            ACPIGpeClearEventMasks();

        }

        //
        // Lets try to flush the power and device queues
        //
        ACPIBuildFlushQueue( RootDeviceExtension );
        ACPIDevicePowerFlushQueue( RootDeviceExtension );

        return STATUS_SUCCESS;

    }

    //
    // We are being called after the load operator. Decrement the Load()'s
    // outstanding. If this value reaches 0, then we know what we are the
    // last instance
    //
    newValue = InterlockedDecrement( &AcpiTableDelta );
    if (newValue == 0) {

        //
        // We re-enable to re-enable the GPEs
        //
        ACPIGpeBuildEventMasks();

        //
        // We also need to process the disappearing table...
        //
        ACPITableUnload();

    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\bus.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    bus.c

Abstract:

    This module contains the bus dispatcher for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

extern ACPI_INTERFACE_STANDARD  ACPIInterfaceTable;
LIST_ENTRY AcpiUnresolvedEjectList;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIBusAndFilterIrpEject)
#pragma alloc_text(PAGE, ACPIBusAndFilterIrpQueryCapabilities)
#pragma alloc_text(PAGE, ACPIBusAndFilterIrpQueryEjectRelations)
#pragma alloc_text(PAGE, ACPIBusAndFilterIrpQueryPnpDeviceState)
#pragma alloc_text(PAGE, ACPIBusAndFilterIrpSetLock)
#pragma alloc_text(PAGE, ACPIBusIrpCancelRemoveOrStopDevice)
#pragma alloc_text(PAGE, ACPIBusIrpDeviceUsageNotification)
#pragma alloc_text(PAGE, ACPIBusIrpEject)
#pragma alloc_text(PAGE, ACPIBusIrpQueryBusInformation)
#pragma alloc_text(PAGE, ACPIBusIrpQueryBusRelations)
#pragma alloc_text(PAGE, ACPIBusIrpQueryCapabilities)
#pragma alloc_text(PAGE, ACPIBusIrpQueryDeviceRelations)
#pragma alloc_text(PAGE, ACPIBusIrpQueryId)
#pragma alloc_text(PAGE, ACPIBusIrpQueryInterface)
#pragma alloc_text(PAGE, ACPIBusIrpQueryPnpDeviceState)
#pragma alloc_text(PAGE, ACPIBusIrpQueryRemoveOrStopDevice)
#pragma alloc_text(PAGE, ACPIBusIrpQueryResourceRequirements)
#pragma alloc_text(PAGE, ACPIBusIrpQueryResources)
#pragma alloc_text(PAGE, ACPIBusIrpQueryTargetRelation)
#pragma alloc_text(PAGE, ACPIBusIrpSetLock)
#pragma alloc_text(PAGE, ACPIBusIrpStartDevice)
#pragma alloc_text(PAGE, ACPIBusIrpStartDeviceWorker)
#pragma alloc_text(PAGE, ACPIBusIrpStopDevice)
#pragma alloc_text(PAGE, SmashInterfaceQuery)
#endif

PDEVICE_EXTENSION   DebugExtension = NULL;

NTSTATUS
ACPIBusAndFilterIrpEject(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context,
    IN  BOOLEAN         ProcessingFilterIrp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_EJECT requests sent to
    the PDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status           = Irp->IoStatus.Status;
    PDEVICE_EXTENSION   deviceExtension;
    PNSOBJ              acpiObject;
    PDEVICE_EXTENSION   parentExtension  = NULL;
    PIO_STACK_LOCATION  irpStack         = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction    = irpStack->MinorFunction;
    ULONG               i;
    KIRQL               oldIrql;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    acpiObject      = deviceExtension->AcpiObject;

    if ( acpiObject == NULL) {

        //
        // Don't touch this one
        //
        status = STATUS_NOT_SUPPORTED;
        goto ACPIBusAndFilterIrpEjectExit ;

    }

    if ( (deviceExtension->DeviceState != Inactive) &&
         (deviceExtension->DeviceState != Stopped) ) {

        //
        // We got called to eject a live node! Yuck, how did this happen?!
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIBusAndFilterIrpEject: Active node!\n",
            Irp
            ) );
        status = STATUS_UNSUCCESSFUL ;
        goto ACPIBusAndFilterIrpEjectExit ;

    }

    //
    // Bye bye card.
    //
    ACPIGetNothingEvalIntegerSync(
        deviceExtension,
        PACKED_EJ0,
        1
        );

    //
    // If this is an eject in S0, make the device go away immediately
    // by getting the currrent device status
    //
    status = ACPIGetDevicePresenceSync(
        deviceExtension,
        (PVOID *) &i,
        NULL
        );

    if (NT_SUCCESS(status) &&
        (!ProcessingFilterIrp) &&
        (!(deviceExtension->Flags & DEV_TYPE_NOT_PRESENT))) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIBusAndFilterIrpEject: "
            "device is still listed as present after _EJ0!\n",
            Irp
            ) );

        //
        // The device did not go away. Let us fail this IRP.
        //
        status = STATUS_UNSUCCESSFUL;
    }

ACPIBusAndFilterIrpEjectExit:

    //
    // done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status;
}

NTSTATUS
ACPIBusAndFilterIrpQueryCapabilities(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context,
    IN  BOOLEAN         ProcessingFilterIrp
    )
/*++

Routine Description:

    This routine handles the IRP_MN_QUERY_CAPABILITIES requests for both
    bus and filter devnodes.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PDEVICE_CAPABILITIES    capabilities;
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ                  acpiObject, rmvObject;
    UCHAR                   minorFunction   = irpStack->MinorFunction;
    ULONG                   deviceStatus;
    ULONG                   slotUniqueNumber, rmvValue;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    acpiObject      = deviceExtension->AcpiObject;

    //
    // Grab a pointer to the capabilities
    //
    capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;
#ifndef HANDLE_BOGUS_CAPS
    if (capabilities->Version < 1) {

        //
        // do not touch irp!
        //
        status = STATUS_NOT_SUPPORTED;
        goto ACPIBusAndFilterIrpQueryCapabilitiesExit;

    }
#endif

#if !defined(ACPI_INTERNAL_LOCKING)

    //
    // An object of this name signifies the node is lockable
    //
    if (ACPIAmliGetNamedChild( acpiObject, PACKED_LCK) != NULL) {

        capabilities->LockSupported = TRUE;

    }
#endif

    //
    // Note presence of _RMV and _EJx methods unless there is a
    // capability on the object to the contrary.
    //

    if ((deviceExtension->Flags & DEV_CAP_NO_REMOVE_OR_EJECT) == 0) {
        //
        // An object of this name signifies the node is removable,
        // unless it's a method which might be trying to tell us the
        // device *isn't* removable.
        //
        rmvObject = ACPIAmliGetNamedChild( acpiObject, PACKED_RMV);
        if (rmvObject != NULL) {

            if (NSGETOBJTYPE(rmvObject) == OBJTYPE_METHOD) {

                //
                // Execute the RMV method.
                //
                status = ACPIGetIntegerSyncValidate(
                    deviceExtension,
                    PACKED_RMV,
                    &rmvValue,
                    NULL
                    );

                if (NT_SUCCESS(status)) {

                    capabilities->Removable = rmvValue ? TRUE : FALSE;

                } else {

                    capabilities->Removable = TRUE;
                }

            } else {

                //
                // If it's anything other than a method, it means the device is
                // removable (even if it's _RMV = 0)
                //
                capabilities->Removable = TRUE;
            }
        }

        //
        // An object of this name signifies the node is ejectable, but we strip
        // that away for docks (the profile provider can present these)
        //
        if (!ACPIDockIsDockDevice(acpiObject)) {


            if (ACPIAmliGetNamedChild( acpiObject, PACKED_EJ0) != NULL) {

                capabilities->EjectSupported = TRUE;
                capabilities->Removable = TRUE;

            }

            if (ACPIAmliGetNamedChild( acpiObject, PACKED_EJ1) ||
                ACPIAmliGetNamedChild( acpiObject, PACKED_EJ2) ||
                ACPIAmliGetNamedChild( acpiObject, PACKED_EJ3) ||
                ACPIAmliGetNamedChild( acpiObject, PACKED_EJ4)) {

                capabilities->WarmEjectSupported = TRUE;
                capabilities->Removable = TRUE;

            }
        }
    }

    //
    // An object of this name will signifies inrush
    //
    if (ACPIAmliGetNamedChild( acpiObject, PACKED_IRC) != NULL) {

        DeviceObject->Flags |= DO_POWER_INRUSH;

    }

    //
    // Is the device disabled?
    //
    status = ACPIGetDevicePresenceSync(
        deviceExtension,
        (PVOID *) &deviceStatus,
        NULL
        );
    if (!NT_SUCCESS(status)) {

        goto ACPIBusAndFilterIrpQueryCapabilitiesExit;

    }
    if (!(deviceExtension->Flags & DEV_PROP_DEVICE_ENABLED)) {

        if (ACPIAmliGetNamedChild( acpiObject, PACKED_CRS) != NULL &&
            ACPIAmliGetNamedChild( acpiObject, PACKED_SRS) == NULL) {

            capabilities->HardwareDisabled = 1;

        } else if (ProcessingFilterIrp) {

            capabilities->HardwareDisabled = 0;

        }

    } else if (!ProcessingFilterIrp) {

        //
        // For machines with this attribute set, this means that the
        // hardware REALLY isn't present and should always be reported
        // as disabled
        //
        if (AcpiOverrideAttributes & ACPI_OVERRIDE_STA_CHECK) {

            capabilities->HardwareDisabled = 1;

        } else {

            capabilities->HardwareDisabled = 0;

        }

    }

    //
    // If we fail the START_DEVICE, then there are some cases where we don't
    // want the device to show up in the Device Manager. So try to report this
    // capability based on the information from the device presence...
    //
    if (!(deviceStatus & STA_STATUS_USER_INTERFACE)) {

        //
        // See the bit that says that we shouldn't the device in the UI if
        // the Start Device Fails
        //
        capabilities->NoDisplayInUI = 1;

    }

    //
    // Determine the slot number
    //
    if (ACPIAmliGetNamedChild( acpiObject, PACKED_SUN) != NULL) {

        //
        // If we have UINumber information, use it.
        //
        status = ACPIGetIntegerSync(
            deviceExtension,
            PACKED_SUN,
            &slotUniqueNumber,
            NULL
            );

        if (NT_SUCCESS(status)) {

            capabilities->UINumber = slotUniqueNumber;
        }
    }

    //
    // Is there an address?
    //
    if (ACPIAmliGetNamedChild( acpiObject, PACKED_ADR) != NULL) {

        status = ACPIGetAddressSync(
            deviceExtension,
            &(capabilities->Address),
            NULL
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                deviceExtension,
                " - Could query device address - %08lx",
                status
                ) );

            goto ACPIBusAndFilterIrpQueryCapabilitiesExit;

        }
    }

    //
    // Do the power capabilities
    //
    status = ACPISystemPowerQueryDeviceCapabilities(
        deviceExtension,
        capabilities
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            " - Could query device capabilities - %08lx",
            status
            ) );

        goto ACPIBusAndFilterIrpQueryCapabilitiesExit;
    }

    //
    // Set the current flags for the capabilities
    //
    if (!ProcessingFilterIrp) {

        //
        // Set some rather boolean capabilities
        //
        capabilities->SilentInstall = TRUE;
        capabilities->RawDeviceOK =
            (deviceExtension->Flags & DEV_CAP_RAW) ? TRUE : FALSE;
        capabilities->UniqueID =
            (deviceExtension->InstanceID == NULL ? FALSE : TRUE);

        //
        // In the filter case, we will just let the underlying pdo determine the
        // success or failure of the irp.
        //
        status = STATUS_SUCCESS;

    }

ACPIBusAndFilterIrpQueryCapabilitiesExit:

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status;
}

NTSTATUS
ACPIBusAndFilterIrpQueryEjectRelations(
    IN     PDEVICE_OBJECT    DeviceObject,
    IN     PIRP              Irp,
    IN OUT PDEVICE_RELATIONS *DeviceRelations
    )
{
    PDEVICE_EXTENSION  deviceExtension, additionalExtension;
    PNSOBJ             acpiObject;
    NTSTATUS           status ;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    acpiObject      = deviceExtension->AcpiObject;

    //
    // lets look at the ACPIObject that we have so can see if it is valid...
    //
    if (acpiObject == NULL) {

        //
        // Invalid name space object <bad>
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIBusAndFilterIrpQueryEjectRelations: "
            "invalid ACPIObject (0x%08lx)\n",
            Irp,
            acpiObject
            ) );

        //
        // Mark the irp as very bad...
        //
        return STATUS_INVALID_PARAMETER;

    }

    //
    // Mark sure _DCK nodes have ejection relations that include their fake
    // dock nodes.
    //
    if (ACPIDockIsDockDevice(acpiObject)) {

        additionalExtension = ACPIDockFindCorrespondingDock( deviceExtension );

    } else {

        additionalExtension = NULL;
    }

    status = ACPIDetectEjectDevices(
        deviceExtension,
        DeviceRelations,
        additionalExtension
        );

    //
    // If something went wrong...
    //
    if (!NT_SUCCESS(status)) {

        //
        // That's not nice..
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIBusAndFilterIrpQueryEjectRelations: enum = 0x%08lx\n",
            Irp,
            status
            ) );
    }

    //
    // Done
    //
    return status ;
}

NTSTATUS
ACPIBusAndFilterIrpQueryPnpDeviceState(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context,
    IN  BOOLEAN         ProcessingFilterIrp
    )
/*++

Routine Description:

    This routines tells the system what PNP state the device is in

Arguments:

    DeviceObject        - The device whose state we want to know
    Irp                 - The request
    ProcessingFilterIrp - Are we a filter or not?

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             staPresent;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              nsObj           = NULL;
    UCHAR               minorFunction   = irpStack->MinorFunction;
    ULONG               deviceStatus;

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // We base some of the decisions on wether or not a _STA is *really*
    // present or not. Determine that now
    //
    if ( !(deviceExtension->Flags & DEV_PROP_NO_OBJECT) ) {

        nsObj = ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_STA
            );

    }
    staPresent = (nsObj == NULL ? FALSE : TRUE);

    //
    // Get the device status
    //
    status = ACPIGetDevicePresenceSync(
        deviceExtension,
        (PVOID *) &deviceStatus,
        NULL
        );
    if (!NT_SUCCESS(status)) {

        goto ACPIBusAndFilterIrpQueryPnpDeviceStateExit;

    }

    //
    // do we show this in the UI?
    //
    if (deviceExtension->Flags & DEV_CAP_NEVER_SHOW_IN_UI) {

        Irp->IoStatus.Information |= PNP_DEVICE_DONT_DISPLAY_IN_UI;

    } else  if (deviceExtension->Flags & DEV_CAP_NO_SHOW_IN_UI) {

        Irp->IoStatus.Information |= PNP_DEVICE_DONT_DISPLAY_IN_UI;

    } else if (staPresent || !ProcessingFilterIrp) {

        Irp->IoStatus.Information &= ~PNP_DEVICE_DONT_DISPLAY_IN_UI;

    }

    //
    // Is the device not working?
    //
    if (deviceExtension->Flags & DEV_PROP_DEVICE_FAILED) {

        Irp->IoStatus.Information |= PNP_DEVICE_FAILED;

    } else if (staPresent && !ProcessingFilterIrp) {

        Irp->IoStatus.Information &= ~PNP_DEVICE_FAILED;

    }

    //
    // Can we disable this device?
    // Note that anything that isn't a regular device should be
    // marked as disableable...
    //
    if (!(deviceExtension->Flags & DEV_PROP_NO_OBJECT) &&
        !(deviceExtension->Flags & DEV_CAP_PROCESSOR) &&
        !(deviceExtension->Flags & DEV_CAP_THERMAL_ZONE) &&
        !(deviceExtension->Flags & DEV_CAP_BUTTON) ) {

        if (!ProcessingFilterIrp) {

            //
            // Can we actually disable the device?
            // Note --- this requires an _DIS, a _PS3, or a _PR0
            //
            nsObj = ACPIAmliGetNamedChild(
                deviceExtension->AcpiObject,
                PACKED_DIS
                );
            if (nsObj == NULL) {

                nsObj = ACPIAmliGetNamedChild(
                    deviceExtension->AcpiObject,
                    PACKED_PS3
                    );

            }
            if (nsObj == NULL) {

                nsObj = ACPIAmliGetNamedChild(
                    deviceExtension->AcpiObject,
                    PACKED_PR0
                    );

            }
            if (deviceExtension->Flags & DEV_CAP_NO_STOP) {

                nsObj = NULL;

            }

            if (nsObj == NULL) {

                Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;

            }

        } else {

            //
            // Can we actually disable the device?
            // Note --- this requires an _DIS, a _PS3, or a _PR0
            //
            nsObj = ACPIAmliGetNamedChild(
                deviceExtension->AcpiObject,
                PACKED_DIS
                );
            if (nsObj == NULL) {

                nsObj = ACPIAmliGetNamedChild(
                    deviceExtension->AcpiObject,
                    PACKED_PS3
                    );

            }
            if (nsObj == NULL) {

                nsObj = ACPIAmliGetNamedChild(
                    deviceExtension->AcpiObject,
                    PACKED_PR0
                    );

            }
            if (deviceExtension->Flags & DEV_CAP_NO_STOP) {

                nsObj = NULL;

            }

            if (nsObj != NULL) {

                Irp->IoStatus.Information &= ~PNP_DEVICE_NOT_DISABLEABLE;

            }

        }

    } else {

        //
        // If we have no device object...
        //
        if (deviceExtension->Flags & DEV_CAP_NO_STOP) {

            Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;

        }

    }

ACPIBusAndFilterIrpQueryPnpDeviceStateExit:

    ACPIDevPrint( (
        ACPI_PRINT_PNP_STATE,
        deviceExtension,
        ":%s%s%s%s%s%s\n",
        ( (Irp->IoStatus.Information & PNP_DEVICE_DISABLED) ? " Disabled" : ""),
        ( (Irp->IoStatus.Information & PNP_DEVICE_DONT_DISPLAY_IN_UI) ? " NoShowInUi" : ""),
        ( (Irp->IoStatus.Information & PNP_DEVICE_FAILED) ? " Failed" : ""),
        ( (Irp->IoStatus.Information & PNP_DEVICE_REMOVED) ? " Removed" : ""),
        ( (Irp->IoStatus.Information & PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED) ? " ResourceChanged" : ""),
        ( (Irp->IoStatus.Information & PNP_DEVICE_NOT_DISABLEABLE) ? " NoDisable" : "")
        ) );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status;
}

NTSTATUS
ACPIBusAndFilterIrpSetLock(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context,
    IN  BOOLEAN         ProcessingFilterIrp
    )
/*++

Routine Description:

    This handles lock and unlock requests for PDO's or filters...

Arguments:

    DeviceObject    - The device to stop
    Irp             - The request to tell us how to do it...

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = Irp->IoStatus.Status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;
    BOOLEAN             lockParameter   = irpStack->Parameters.SetLock.Lock;
    ULONG               acpiLockArg ;
    NTSTATUS            lockStatus ;

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

#if !defined(ACPI_INTERNAL_LOCKING)
    //
    // Attempt to lock/unlock the device as appropriate
    //
    acpiLockArg = ((lockParameter) ? 1 : 0) ;

    //
    // Here we go...
    //
#if 0
    lockStatus = ACPIGetNothingEvalIntegerSync(
        deviceExtension,
        PACKED_LCK,
        acpiLockArg
        );
#endif
    if (status == STATUS_NOT_SUPPORTED) {

        status = STATUS_SUCCESS ;

    }
#endif
    //
    // done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status;
}

NTSTATUS
ACPIBusIrpCancelRemoveOrStopDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called when we no longer wish to remove or stop the device
    object

Arguments:

    DeviceObject    - The device object to be removed
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Were we allowed to stop the device?
    //
    if (!(deviceExtension->Flags & DEV_CAP_NO_STOP) ) {

        //
        // Check to see if we have placed this device in the inactive state
        //
        if (deviceExtension->DeviceState == Inactive) {

            //
            // Mark the device extension as being started
            //
            deviceExtension->DeviceState = deviceExtension->PreviousState;

        }

    }

    //
    // Complete the irp
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIBusIrpDeviceUsageNotification(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called to let ACPI know that the device is on one
    particular type of path

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      parentObject;
    PIO_STACK_LOCATION  irpSp           = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Do we have a parent extension?
    //
    if (deviceExtension->ParentExtension != NULL) {

        //
        // Get the parents stack
        //
        parentObject = deviceExtension->ParentExtension->DeviceObject;
        if (parentObject == NULL) {

            //
            // Fail because we don't have a device object
            //
            status = STATUS_NO_SUCH_DEVICE;
            goto ACPIBusIrpDeviceUsageNotificationExit;

        }

        //
        // Send a synchronous irp down and wait for the result
        //
        status = ACPIInternalSendSynchronousIrp(
            parentObject,
            irpSp,
            NULL
            );

    }

    //
    // Did we succeed
    //
    if (NT_SUCCESS(status)) {

        //
        // Do we care about the usage type?
        //
        if (irpSp->Parameters.UsageNotification.Type ==
            DeviceUsageTypeHibernation) {

            //
            // Yes --- then perform the addition or subtraction required
            //
            IoAdjustPagingPathCount(
                &(deviceExtension->HibernatePathCount),
                irpSp->Parameters.UsageNotification.InPath
                );

        }

    }

ACPIBusIrpDeviceUsageNotificationExit:

    //
    // Complete the request
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, IRP_MN_DEVICE_USAGE_NOTIFICATION),
        status
        ) );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBusIrpEject(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_EJECT requests sent to
    the PDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    return ACPIIrpInvokeDispatchRoutine(
        DeviceObject,
        Irp,
        NULL,
        ACPIBusAndFilterIrpEject,
        FALSE,
        TRUE
        );
}

NTSTATUS
ACPIBusIrpQueryBusInformation(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is only called if the device is of the special type PNP0A06
    (EIO Bus). This is because we need to tell the system that this is
    the ISA bus

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status  = STATUS_SUCCESS;
    PPNP_BUS_INFORMATION    busInfo = NULL;

    PAGED_CODE();

    //
    // Allocate some memory to return the information
    //
    busInfo = ExAllocatePoolWithTag(
        PagedPool,
        sizeof(PNP_BUS_INFORMATION),
        ACPI_MISC_POOLTAG
        );
    if (busInfo != NULL) {

        //
        // The BusNumber = 0 might come back and haunt us
        //
        // Fill in the record
        //
        busInfo->BusTypeGuid = GUID_BUS_TYPE_ISAPNP;
        busInfo->LegacyBusType = Isa;
        busInfo->BusNumber = 0;

    } else {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceObject->DeviceExtension,
            "ACPIBusIrpQueryBusInformation: Could not allocate 0x%08lx bytes\n",
            sizeof(PNP_BUS_INFORMATION)
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Done with the request
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = (ULONG_PTR) busInfo;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBusIrpQueryBusRelations(
    IN  PDEVICE_OBJECT    DeviceObject,
    IN  PIRP              Irp,
    OUT PDEVICE_RELATIONS *DeviceRelations
    )
/*++

Routine Description:

    This handles DeviceRelations requests sent onto the ACPI driver

Arguments:

    DeviceObject    - The object that we care about...
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            filterStatus;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              acpiObject;
    UCHAR               minorFunction   = irpStack->MinorFunction;
    NTSTATUS            status ;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    acpiObject      = deviceExtension->AcpiObject;

    //
    // lets look at the ACPIObject that we have so can see if it is valid...
    //
    if (acpiObject == NULL) {

        //
        // Invalid name space object <bad>
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIBusIrpQueryDeviceRelations: "
            "invalid ACPIObject (0x%08lx)\n",
            Irp,
            acpiObject
            ) );

        //
        // Mark the irp as very bad...
        //
        return STATUS_INVALID_PARAMETER;

    }

    //
    // Active the code to detect unenumerated devices...
    //
    status = ACPIDetectPdoDevices(
        DeviceObject,
        DeviceRelations
        );

    //
    // If something went wrong...
    //
    if (!NT_SUCCESS(status)) {

        //
        // Ouch bad..
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIBusIrpQueryDeviceRelations: enum = 0x%08lx\n",
            Irp,
            status
            ) );

    } else {

        //
        // Load the filters
        //
        filterStatus = ACPIDetectFilterDevices(
            DeviceObject,
            *DeviceRelations
            );
        if (!NT_SUCCESS(filterStatus)) {

            //
            // Filter Operation failed
            //
            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                deviceExtension,
                "(0x%08lx): ACPIBusIrpQueryDeviceRelations: filter = 0x%08lx\n",
                Irp,
                filterStatus
                ) );
        }
    }

    //
    // Done
    //
    return status ;
}

NTSTATUS
ACPIBusIrpQueryCapabilities(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_CAPABILITIES requests sent
    to the PDO

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();
    ACPIDebugEnter( "ACPIBusIrpQueryCapabilities" );

    return ACPIIrpInvokeDispatchRoutine(
        DeviceObject,
        Irp,
        NULL,
        ACPIBusAndFilterIrpQueryCapabilities,
        TRUE,
        TRUE
        );

    ACPIDebugExit( "ACPIBusIrpQueryCapabilities" );
}

NTSTATUS
ACPIBusIrpQueryDeviceRelations(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles DeviceRelations requests sent onto the ACPI driver

Arguments:

    DeviceObject    - The object that we care about...
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status ;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_RELATIONS   deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Fork off to the appropriate query relations subtype function
    //
    switch(irpStack->Parameters.QueryDeviceRelations.Type) {

        case TargetDeviceRelation:
            status = ACPIBusIrpQueryTargetRelation(
                DeviceObject,
                Irp,
                &deviceRelations
                );
            break ;

        case BusRelations:
            status = ACPIBusIrpQueryBusRelations(
                DeviceObject,
                Irp,
                &deviceRelations
                );
            break ;

        case EjectionRelations:
            status = ACPIBusAndFilterIrpQueryEjectRelations(
                DeviceObject,
                Irp,
                &deviceRelations
                );
            break ;

        default:

            status = STATUS_NOT_SUPPORTED;

            ACPIDevPrint( (
                ACPI_PRINT_IRP,
                deviceExtension,
                "(0x%08lx): %s - Unhandled Type %d\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
                irpStack->Parameters.QueryDeviceRelations.Type
                ) );
            break ;

    }

    //
    // If we succeeds, then we can always write to the irp
    //
    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

    } else if ( (status != STATUS_NOT_SUPPORTED) &&
        (deviceRelations == NULL) ) {

        //
        // We explicitely failed the irp, and nobody above us had anything to
        // add.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) NULL;

    } else {

        //
        // Either we haven't touched the IRP or existing children were already
        // present (placed there by an FDO). Grab our status from what is
        // already present.
        //
        status = Irp->IoStatus.Status;

    }

    //
    // Done with the irp
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIBusIrpQueryId(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_ID PNP
    minor function

    Note:   This is what the returned strings from this function should look
            like. This is from mail that lonny sent.

            DeviceID    = ACPI\PNPxxxx
            InstanceID  = yyyy
            HardwareID  = ACPI\PNPxxxx,*PNPxxxx

Arguments:

    DeviceObject    - The object that we care about
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    BUS_QUERY_ID_TYPE   type;
    NTSTATUS            status          = Irp->IoStatus.Status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PUCHAR              baseBuffer;
    ULONG               baseBufferSize;
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // What we do is based on the IdType of the Request...
    //
    type = irpStack->Parameters.QueryId.IdType;
    switch (type) {
    case BusQueryCompatibleIDs:

        //
        // This returns a MULTI-SZ wide string...
        //
        status = ACPIGetCompatibleIDSyncWide(
            deviceExtension,
            &baseBuffer,
            &baseBufferSize
            );
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            status = STATUS_NOT_SUPPORTED;
            break;

        } else if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                " (0x%08lx): IRP_MN_QUERY_ID( %d - CID) = 0x%08lx\n",
                Irp,
                type,
                status
                ) );
            break;

        }

        //
        // Store the result in the Irp
        //
        Irp->IoStatus.Information = (ULONG_PTR) baseBuffer;
        break;

    case BusQueryInstanceID:

        //
        // In this case, we have to build the instance id
        //
        status = ACPIGetInstanceIDSyncWide(
            deviceExtension,
            &baseBuffer,
            &baseBufferSize
            );
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            status = STATUS_NOT_SUPPORTED;
            break;

        } else if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                " (0x%08lx): IRP_MN_QUERY_ID( %d - UID) = 0x%08lx\n",
                Irp,
                type,
                status
                ) );
            break;

        }

        //
        // Store the result in the Irp
        //
        Irp->IoStatus.Information = (ULONG_PTR) baseBuffer;
        break;

    case BusQueryDeviceID:

        //
        // Get the Device ID as a wide string
        //
        status = ACPIGetDeviceIDSyncWide(
            deviceExtension,
            &baseBuffer,
            &baseBufferSize
            );
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            status = STATUS_NOT_SUPPORTED;
            break;

        } else if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                " (0x%08lx): IRP_MN_QUERY_ID( %d - HID) = 0x%08lx\n",
                Irp,
                type,
                status
                ) );
            break;

        }

        //
        // Store the result in the Irp
        //
        Irp->IoStatus.Information = (ULONG_PTR) baseBuffer;
        break;

    case BusQueryHardwareIDs:

        //
        // Get the device ID as a normal string
        //
        status = ACPIGetHardwareIDSyncWide(
            deviceExtension,
            &baseBuffer,
            &baseBufferSize
            );
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            status = STATUS_NOT_SUPPORTED;
            break;

        } else if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                " (0x%08lx): IRP_MN_QUERY_ID( %d - UID) = 0x%08lx\n",
                Irp,
                type,
                status
                ) );
            break;

        }

        //
        // Store the result in the Irp
        //
        Irp->IoStatus.Information = (ULONG_PTR) baseBuffer;
        break;

    default:

        ACPIDevPrint( (
            ACPI_PRINT_IRP,
            deviceExtension,
            "(0x%08lx): %s - Unhandled Id %d\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            type
            ) );
        break;

    } // switch

    //
    // Store the status result of the request and complete it
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s(%d) = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        type,
        status
        ) );
    return status;
}

NTSTATUS
ACPIBusIrpQueryInterface(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine handles IRP_MN_QUERY_INTERFACE requests for PDOs owned
    by the ACPI driver.  It will eject an 'ACPI' interface and it will
    smash Translator Interfaces for interrupts that have been provided
    by the devnode's FDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    CM_RESOURCE_TYPE    resource;
    GUID                *interfaceType;
    NTSTATUS            status          = STATUS_NOT_SUPPORTED;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    ULONG               count;

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Obtain the info we will need from the irp
    //
    resource = (CM_RESOURCE_TYPE)
        PtrToUlong(irpStack->Parameters.QueryInterface.InterfaceSpecificData);
    interfaceType = (LPGUID) irpStack->Parameters.QueryInterface.InterfaceType;

#if DBG
    {
        NTSTATUS        status2;
        UNICODE_STRING  guidString;

        status2 = RtlStringFromGUID( interfaceType, &guidString );
        if (NT_SUCCESS(status2)) {

            ACPIDevPrint( (
                ACPI_PRINT_IRP,
                deviceExtension,
                "(0x%08lx): %s - Res %x Type = %wZ\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, irpStack->MinorFunction),
                resource,
                &guidString
                ) );

            RtlFreeUnicodeString( &guidString );

        }

    }
#endif

    //
    // *Only* Handle the Guids that we know about. Do Not Ever touch
    // any other GUID
    //
    if (CompareGuid(interfaceType, (PVOID) &GUID_ACPI_INTERFACE_STANDARD)) {

        PACPI_INTERFACE_STANDARD    interfaceDestination;

        //
        // Only copy up to current size of the ACPI_INTERFACE structure
        //
        if (irpStack->Parameters.QueryInterface.Size >
            sizeof (ACPI_INTERFACE_STANDARD) ) {

            count = sizeof (ACPI_INTERFACE_STANDARD);

        } else {

            count = irpStack->Parameters.QueryInterface.Size;

        }

        //
        // Find where we will store the interface
        //
        interfaceDestination = (PACPI_INTERFACE_STANDARD)
            irpStack->Parameters.QueryInterface.Interface;

        //
        // Copy from the global table to the caller's table, using size
        // specified.  Give caller only what was asked for, for
        // backwards compatibility.
        //
        RtlCopyMemory(
            interfaceDestination,
            &ACPIInterfaceTable,
            count
            );

        //
        // Make sure that we can give the user back the correct context. To do
        // this we need to calculate that the number of bytes we are giving back
        // is at least more than that is required to store a pointer at the
        // correct place in the structure
        //
        if (count > (FIELD_OFFSET(ACPI_INTERFACE_STANDARD, Context) + sizeof(PVOID) ) ) {

            interfaceDestination->Context = DeviceObject;

        }

        //
        // Done with the irp
        //
        status = STATUS_SUCCESS;

    } else if (CompareGuid(interfaceType, (PVOID) &GUID_TRANSLATOR_INTERFACE_STANDARD)) {

        if (resource == CmResourceTypeInterrupt) {

            //
            // Smash any interface that has already been reported because we
            // want to arbitrate UNTRANSLATED resources.  We can be certain
            // that the HAL underneath will provide the translator interface that
            // has to be there.
            //

            // TEMPTEMP HACKHACK  This should last only as long as the PCI
            // driver is building its IRQ translator.
            //
            // EFN: Remove this HACKHACK on Alpha
            //
#ifndef _ALPHA_
            if (IsPciBus(DeviceObject)) {

                SmashInterfaceQuery(Irp);

            }
#endif // _ALPHA_

        } else if ((resource == CmResourceTypePort) || (resource == CmResourceTypeMemory)) {

            //
            // For root PCI buses, determine whether we need to eject a translator or not.
            // This decision will be based on the contents of the _CRS.
            //
            if (IsPciBus(DeviceObject)) {

                status = TranslateEjectInterface(DeviceObject, Irp);

            }

        }

    } else if (CompareGuid(interfaceType, (PVOID) &GUID_PCI_BUS_INTERFACE_STANDARD)) {

        if (IsPciBus(DeviceObject)) {

            status = PciBusEjectInterface(DeviceObject, Irp);

        }

    } else if (CompareGuid(interfaceType, (PVOID) &GUID_BUS_INTERFACE_STANDARD)) {

        //
        // Fail the irp unless we have the correct interface
        //
        Irp->IoStatus.Status = STATUS_NOINTERFACE;

        //
        // Is there are parent to this PDO?
        //
        if (deviceExtension->ParentExtension != NULL) {

            PDEVICE_OBJECT  parentObject =
                deviceExtension->ParentExtension->DeviceObject;

            //
            // Make a new irp and send it ownward.
            // Note: Because the Interface pointer is in the IO Stack,
            // by passing down the current stack as the one to copy into
            // the new irp, we effectively get to pass the interfaces for free
            //
            if (parentObject != NULL) {

                Irp->IoStatus.Status = ACPIInternalSendSynchronousIrp(
                    parentObject,
                    irpStack,
                    NULL
                    );

            }

        }

    }

    if (status != STATUS_NOT_SUPPORTED) {

        //
        // Set the status code in the Irp to what we will return
        //
        Irp->IoStatus.Status = status;

    } else {

        //
        // Use the status code from the Irp to determine what we will return
        //
        status = Irp->IoStatus.Status;
    }

    //
    // Complete the request
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

NTSTATUS
ACPIBusIrpQueryPnpDeviceState(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_DEVICE_STATE
    requests sent to the Physical Device Objects

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    return ACPIIrpInvokeDispatchRoutine(
        DeviceObject,
        Irp,
        NULL,
        ACPIBusAndFilterIrpQueryPnpDeviceState,
        TRUE,
        TRUE
        );
}

NTSTATUS
ACPIBusIrpQueryPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routines tells the system what PNP state the device is in

Arguments:

    DeviceObject    - The device whose state we want to know
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpSp           = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              acpiObject;
    PNSOBJ              ejectObject;
    SYSTEM_POWER_STATE  systemState;
    ULONG               packedEJx;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Get the Current stack location to determine if we are a system
    // irp or a device irp. We ignore device irps here and any system
    // irp that isn't of type PowerActionWarmEject
    //
    if (irpSp->Parameters.Power.Type != SystemPowerState) {

        //
        // We don't handle this irp
        //
        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );

    }
    if (irpSp->Parameters.Power.ShutdownType != PowerActionWarmEject) {

        //
        // No eject work - just complete the IRP.
        //
        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );

    }
    if (deviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        //
        // If we don't have an ACPI object, then we can't succeed this request
        //
        return ACPIDispatchPowerIrpFailure( DeviceObject, Irp );

    }


    //
    // Restrict power states to those possible during a warm eject...
    //
    acpiObject = deviceExtension->AcpiObject ;
    if (ACPIDockIsDockDevice(acpiObject)) {

        //
        // Don't touch this device, the profile provider manages eject
        // transitions.
        //
        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );

    }

    //
    // What system state are we looking at?
    //
    systemState = irpSp->Parameters.Power.State.SystemState;
    switch (irpSp->Parameters.Power.State.SystemState) {
        case PowerSystemSleeping1: packedEJx = PACKED_EJ1; break;
        case PowerSystemSleeping2: packedEJx = PACKED_EJ2; break;
        case PowerSystemSleeping3: packedEJx = PACKED_EJ3; break;
        case PowerSystemHibernate: packedEJx = PACKED_EJ4; break;
        default: return ACPIDispatchPowerIrpFailure( DeviceObject, Irp );
    }

    //
    // Does the appropriate object exist for this device?
    //
    ejectObject = ACPIAmliGetNamedChild( acpiObject, packedEJx) ;
    if (ejectObject == NULL) {

        //
        // Fail the request, as we cannot eject in this case.
        //
        return ACPIDispatchPowerIrpFailure( DeviceObject, Irp );

    }

    //
    // Succeed the request
    //
    return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );
}

NTSTATUS
ACPIBusIrpQueryRemoveOrStopDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine transitions a device to the Inactive State

Arguments:

    DeviceObject    - The device that is to become inactive
    Irp             - The request

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Are we allowed to stop this device?
    //
    if (deviceExtension->Flags & DEV_CAP_NO_STOP) {

        //
        // No, then fail the irp
        //
        status = STATUS_INVALID_DEVICE_REQUEST;

    } else {

        //
        // Mark the device extension as being inactive
        //
        deviceExtension->PreviousState = deviceExtension->DeviceState;
        deviceExtension->DeviceState = Inactive;
        status = STATUS_SUCCESS;

    }

    //
    // Complete the irp
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done processing
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIBusIrpQueryResources(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_RESOURCES requests sent
    to PDO device objects

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:
    NTSTATUS

--*/
{
    NTSTATUS                        status;
    PDEVICE_EXTENSION               deviceExtension;
    PIO_STACK_LOCATION              irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PCM_RESOURCE_LIST               cmList          = NULL;
    PIO_RESOURCE_REQUIREMENTS_LIST  ioList          = NULL;
    PUCHAR                          crsBuf          = NULL;
    UCHAR                           minorFunction   = irpStack->MinorFunction;
    ULONG                           deviceStatus;
    ULONG                           crsBufSize;

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Note that at this point, we must evaluate the _DDN for the
    // object and store that in the registry
    //
    ACPIInitDosDeviceName( deviceExtension );

    //
    // The first thing to look for is wether or not the device is present and
    // decoding its resources. We do this by getting the device status and
    // looking at Bit #1
    //
    status = ACPIGetDevicePresenceSync(
        deviceExtension,
        (PVOID *) &deviceStatus,
        NULL
        );
    if (!NT_SUCCESS(status)) {

        goto ACPIBusIrpQueryResourcesExit;

    }
    if ( !(deviceExtension->Flags & DEV_PROP_DEVICE_ENABLED) ) {

        //
        // The device isn't decoding any resources. So asking it for its
        // current resources is doomed to failure
        //
        ACPIDevPrint( (
            ACPI_PRINT_WARNING,
            deviceExtension,
            "(0x%08lx) : ACPIBusIrpQueryResources - Device not Enabled\n",
            Irp
            ) );
        status = STATUS_INVALID_DEVICE_STATE;
        goto ACPIBusIrpQueryResourcesExit;

    }

    //
    // Container objects do not claim resources. So, don't even bother
    // trying to obtain a _CRS
    //
    if (!(deviceExtension->Flags & DEV_CAP_CONTAINER)) {

        //
        // Here we try to find the current resource set
        //
        status = ACPIGetBufferSync(
            deviceExtension,
            PACKED_CRS,
            &crsBuf,
            &crsBufSize
            );

    } else {

        //
        // This is the status code returned if there is no _CRS. It actually
        // doesn't matter what code we use since in the failure case, we
        // should return whatever code was already present in the IRP
        //
        status = STATUS_OBJECT_NAME_NOT_FOUND;

    }
    if (!NT_SUCCESS(status)) {

        //
        // If this is the PCI device, then we *must* succeed, otherwise the OS
        // will not boot.
        //
        if (! (deviceExtension->Flags & DEV_CAP_PCI) ) {

            //
            // Abort. Complete the irp with whatever status code is present
            //
            status = Irp->IoStatus.Status;

        }
        goto ACPIBusIrpQueryResourcesExit;

    }

    //
    // Build a IO_RESOURCE_REQUIREMENT_LISTS
    //
    status = PnpBiosResourcesToNtResources(
        crsBuf,
        (deviceExtension->Flags & DEV_CAP_PCI ?
          PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES : 0),
        &ioList );

    //
    // Whatever happens, we are done with the buffer
    //
    ExFreePool(crsBuf);
    if (!NT_SUCCESS(status)) {

        //
        // Abort. We failed the irp for a reason. Remember that
        //
        goto ACPIBusIrpQueryResourcesExit;

    }

    //
    // Make sure that if the DEVICE is PCI, that we subtract out the
    // resource that should not be there
    //
    if (deviceExtension->Flags & DEV_CAP_PCI) {

        status = ACPIRangeSubtract(
            &ioList,
            RootDeviceExtension->ResourceList
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                deviceExtension,
                "(0x%08lx) : ACPIBusIrpQueryResources "
                "Subtract = 0x%08lx\n",
                Irp,
                status
                ) );

            ExFreePool( ioList );
            goto ACPIBusIrpQueryResourcesExit;

        }

        //
        // Make sure our range is the proper size
        //
        ACPIRangeValidatePciResources( deviceExtension, ioList );

    } else if (deviceExtension->Flags & DEV_CAP_PIC_DEVICE) {

        //
        // Strip out the PIC resources
        //
        status = ACPIRangeFilterPICInterrupt(
            ioList
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                deviceExtension,
                "(0x%08lx): ACPIBusIrpQueryResources "
                "FilterPIC = 0x%08lx\n",
                Irp,
                status
                ) );
            ExFreePool( ioList );
            goto ACPIBusIrpQueryResourcesExit;

        }

    }

    //
    // Turn the list into a CM_RESOURCE_LIST
    //
    if (NT_SUCCESS(status)) {

        status = PnpIoResourceListToCmResourceList(
            ioList,
            &cmList
            );
        if (!NT_SUCCESS(status)) {

            ExFreePool( ioList );
            goto ACPIBusIrpQueryResourcesExit;

        }

    }

    //
    // Whatever happens, we are done with the IO list
    //
    ExFreePool(ioList);

ACPIBusIrpQueryResourcesExit:

    //
    // If this is the PCI device, then we *must* succeed, otherwise the OS
    // will not boot.
    //
    if (!NT_SUCCESS(status) && status != STATUS_INSUFFICIENT_RESOURCES &&
        (deviceExtension->Flags & DEV_CAP_PCI) ) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_ROOT_PCI_RESOURCE_FAILURE,
            (ULONG_PTR) deviceExtension,
            0,
            (ULONG_PTR) Irp
            );

    }

    //
    // Done with Irp
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information =  (ULONG_PTR) ( NT_SUCCESS(status) ? cmList : NULL );
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status;
}

NTSTATUS
ACPIBusIrpQueryResourceRequirements(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_RESOURCES requests sent
    to PDO device objects

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:
    NTSTATUS

--*/
{
    NTSTATUS                        crsStat;
    NTSTATUS                        prsStat;
    NTSTATUS                        status          = Irp->IoStatus.Status;
    PCM_RESOURCE_LIST               cmList          = NULL;
    PDEVICE_EXTENSION               deviceExtension;
    PIO_RESOURCE_REQUIREMENTS_LIST  resList         = NULL;
    PIO_STACK_LOCATION              irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PUCHAR                          crsBuf          = NULL;
    PUCHAR                          prsBuf          = NULL;
    UCHAR                           minorFunction   = irpStack->MinorFunction;
    ULONG                           crsBufSize;
    ULONG                           prsBufSize;

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Here we must return a PIO_RESOURCE_REQUIREMENTS_LIST. For
    // now, we will simply obtain some interesting pointers
    // and fall through
    //

    //
    // Container objects are special in that they have _CRS/_PRS but do not
    // claim resources. Rather, they are used to specify a resource
    // translation
    //
    if (!(deviceExtension->Flags & DEV_CAP_CONTAINER)) {

        //
        // Fetch the buffers, as appropriate
        //
        crsStat = ACPIGetBufferSync(
            deviceExtension,
            PACKED_CRS,
            &crsBuf,
            &crsBufSize
            );
        prsStat = ACPIGetBufferSync(
            deviceExtension,
            PACKED_PRS,
            &prsBuf,
            &prsBufSize
            );

    } else {

        //
        // Pretend that there is no _CRS/_PRS present
        //
        crsStat = STATUS_OBJECT_NAME_NOT_FOUND;
        prsStat = STATUS_OBJECT_NAME_NOT_FOUND;

    }

    //
    // If there is a _CRS, then remember to clear the irp-generated status
    // we will want to fall through
    //
    if (NT_SUCCESS(crsStat)) {

        status = STATUS_NOT_SUPPORTED;

    } else if (!NT_SUCCESS(prsStat)) {

        //
        // This is the case where there isn't a _PRS. We jump directly to
        // the point where we complete the irp, note that the irp will
        // be completed with whatever status code is currently present.
        // The only exception to this is if we discovered that we didn't
        // have enough memory to fulfill either operation..
        //
        if (prsStat == STATUS_INSUFFICIENT_RESOURCES ||
            crsStat == STATUS_INSUFFICIENT_RESOURCES) {

            status = STATUS_INSUFFICIENT_RESOURCES;

        }
        goto ACPIBusIrpQueryResourceRequirementsExit;

    }

    //
    // Did we find a PRS?
    //
    if (NT_SUCCESS(prsStat)) {

        //
        // Our first step is to try to use these resources to build the
        // information...
        //
        status = PnpBiosResourcesToNtResources(
            prsBuf,
            0,
            &resList
            );

        ASSERT(NT_SUCCESS(status));

        ACPIDevPrint( (
            ACPI_PRINT_IRP,
            deviceExtension,
            "(0x%08lx): %s - ResourcesToNtResources =  0x%08lx\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            status
            ) );

        //
        // Done with PRS buffer
        //
        ExFreePool(prsBuf);

        //
        // Fall through!!!
        //

    }

    //
    // Earlier, we cleared the status bit if the crsStat was successful. So
    // we should succeed the following this if there was no _PRS, or if there
    // was one but an error occured. Of course, there would have to be
    // a _CRS...
    //
    if (!NT_SUCCESS(status) && NT_SUCCESS(crsStat) ) {

        status = PnpBiosResourcesToNtResources(
            crsBuf,
            (deviceExtension->Flags & DEV_CAP_PCI ?
              PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES : 0),
            &resList
            );
        ASSERT(NT_SUCCESS(status));

    }

    //
    // Free the _CRS memory, if appropriate
    //
    if (NT_SUCCESS(crsStat)) {

        ExFreePool( crsBuf );

    }

    //
    // Make sure that if the DEVICE is PCI, that we subtract out the
    // resource that should not be there
    //
    if (deviceExtension->Flags & DEV_CAP_PCI) {

        //
        // Make sure our resources are the proper size
        //
        ACPIRangeValidatePciResources( deviceExtension, resList );

        //
        // Subtract out the resources that conflict with the HAL...
        //
        status = ACPIRangeSubtract(
            &resList,
            RootDeviceExtension->ResourceList
            );
        ASSERT(NT_SUCCESS(status));
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                deviceExtension,
                "(0x%08lx) : ACPIBusIrpQueryResourceRequirements "
                "Subtract = 0x%08lx\n",
                Irp,
                status
                ) );
            ExFreePool( resList );
            resList = NULL;

        }

        //
        // Make sure our resources are *still* correct
        //
        ACPIRangeValidatePciResources( deviceExtension, resList );

    } else if (deviceExtension->Flags & DEV_CAP_PIC_DEVICE) {

        //
        // Strip out the PIC resources
        //
        status = ACPIRangeFilterPICInterrupt(
            resList
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                deviceExtension,
                "(0x%08lx): ACPIBusIrpQueryResources "
                "FilterPIC = 0x%08lx\n",
                Irp,
                status
                ) );
            ExFreePool( resList );
            resList = NULL;

        }

    }

    //
    // Dump the list
    //
#if DBG
    if (NT_SUCCESS(status)) {

        ACPIDebugResourceRequirementsList( resList, deviceExtension );

    }
#endif

    //
    // Remember the resource list
    //
    Irp->IoStatus.Information = (ULONG_PTR)
        ( NT_SUCCESS(status) ? resList : NULL );

ACPIBusIrpQueryResourceRequirementsExit:

    //
    // If this is the PCI device, then we *must* succeed, otherwise the OS
    // will not boot.
    //
    if (!NT_SUCCESS(status) && status != STATUS_INSUFFICIENT_RESOURCES &&
        (deviceExtension->Flags & DEV_CAP_PCI)) {

        ASSERT(NT_SUCCESS(status));
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): %s = 0x%08lx\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            status
            ) );

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_ROOT_PCI_RESOURCE_FAILURE,
            (ULONG_PTR) deviceExtension,
            1,
            (ULONG_PTR) Irp
            );

    }

    //
    // Done Processing Irp
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status;
}

NTSTATUS
ACPIBusIrpQueryTargetRelation(
    IN  PDEVICE_OBJECT    DeviceObject,
    IN  PIRP              Irp,
    OUT PDEVICE_RELATIONS *DeviceRelations
    )
/*++

Routine Description:

    This handles DeviceRelations requests sent onto the ACPI driver

Arguments:

    DeviceObject    - The object that we care about...
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            status ;

    PAGED_CODE();

    //
    // Nobody should have answered this IRP and sent it down to us. That would
    // be immensely bad...
    //
    ASSERT(*DeviceRelations == NULL) ;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Allocate some memory for the return buffer
    //
    *DeviceRelations = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(DEVICE_RELATIONS),
        ACPI_IRP_POOLTAG
        );

    if (*DeviceRelations == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIBusIrpQueryTargetRelation: cannot "
            "allocate %x bytes\n",
            Irp,
            sizeof(DEVICE_RELATIONS)
            ) );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Reference the object
    //
    status = ObReferenceObjectByPointer(
        DeviceObject,
        0,
        NULL,
        KernelMode
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIBusIrpQueryDeviceRelations: ObReference = %08lx\n",
            Irp,
            status
            ) );
        ExFreePool( *DeviceRelations );
        return status ;

    }

    //
    // Setup the relations
    //
    (*DeviceRelations)->Count = 1;
    (*DeviceRelations)->Objects[0] = DeviceObject;

    //
    // Done
    //
    return status ;
}

NTSTATUS
ACPIBusIrpRemoveDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called when we need to remove the device object...

Arguments:

    DeviceObject    - The device object to be removed
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    LONG                oldReferenceCount;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    //
    // Get the device extension.
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    if (!(deviceExtension->Flags & DEV_TYPE_NOT_ENUMERATED)) {

        //
        // If the device is still physically present, so must the PDO be.
        // This case is essentially a stop.
        //
        deviceExtension->DeviceState = Stopped;

        //
        // Delete the children of this device
        //
        ACPIInitDeleteChildDeviceList( deviceExtension );

        //
        // Mark the request as complete...
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        if (NT_SUCCESS(status)) {

            //
            // Attempt to stop the device, and unlock the device.
            //
            ACPIInitStopDevice( deviceExtension , TRUE);

        }

        return status ;
    }

    //
    // If the device has already been removed, then hhmm...
    //
    if (deviceExtension->DeviceState == Removed) {

       Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE ;
       IoCompleteRequest( Irp, IO_NO_INCREMENT );
       return STATUS_NO_SUCH_DEVICE ;

    }

    //
    // Otherwise, try to stop the device
    //
    if (deviceExtension->DeviceState != SurpriseRemoved) {

        if (IsPciBus(deviceExtension->DeviceObject)) {

            //
            // If this is PCI bridge, then we
            // may have _REG methods to evaluate.
            //
            EnableDisableRegions(deviceExtension->AcpiObject, FALSE);

        }

        //
        // Attempt to stop the device (if possible)
        //
        ACPIInitStopDevice( deviceExtension, TRUE );

    }

    //
    // Delete the children of this device
    //
    ACPIInitDeleteChildDeviceList( deviceExtension );

    //
    // Set the device state as removed
    //
    deviceExtension->DeviceState = Removed;

    //
    // Complete the request
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = (ULONG_PTR) NULL;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // After this point, the device extension is GONE
    //
    ACPIDevPrint( (
        ACPI_PRINT_REMOVE,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        STATUS_SUCCESS
        ) );

    //
    // Reset the device extension
    //
    ACPIInitResetDeviceExtension( deviceExtension );

    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBusIrpSetLock(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_SET_LOCK
    requests sent to the PDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    return ACPIIrpInvokeDispatchRoutine(
        DeviceObject,
        Irp,
        NULL,
        ACPIBusAndFilterIrpSetLock,
        TRUE,
        TRUE
        );
}

NTSTATUS
ACPIBusIrpSetDevicePower(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This routine handles device power request for a PDO

Arguments:

    DeviceObject    - The PDO target
    DeviceExtension - The real extension to the target
    Irp             - The request
    IrpStack        - The current request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PDEVICE_EXTENSION   deviceExtension;

    UNREFERENCED_PARAMETER( IrpStack );

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // We are going to do some work on the irp, so mark it as being
    // successfull for now
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Mark the irp as pending
    //
    IoMarkIrpPending( Irp );

    //
    // We might queue up the irp, so this counts as a completion routine.
    // Which means we need to incr the ref count
    //
    InterlockedIncrement( &deviceExtension->OutstandingIrpCount );

    //
    // Queue the irp up. Note that we will *always* call the completion
    // routine, so we don't really care what was returned directly by
    // this call --- the callback gets a chance to execute.
    //
    status = ACPIDeviceIrpDeviceRequest(
        DeviceObject,
        Irp,
        ACPIDeviceIrpCompleteRequest
        );

    //
    // Did we return STATUS_MORE_PROCESSING_REQUIRED (which we used
    // if we overload STATUS_PENDING)
    //
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = STATUS_PENDING;

    }

    //
    // Note: We called the completion routine, which should have completed
    // the IRP with the same STATUS code as is being returned here (okay, if
    // it is STATUS_PENDING, obviously we haven't completed the IRP, but that
    // is okay).
    //
    return status;
}

NTSTATUS
ACPIBusIrpSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine handles request to set the power state for a Physical
    Device object

Arguments:

    DeviceObject    - The PDO target of the request
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );

    //
    // Look to see who should actually handle this request
    //
    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        //
        // This is a system request
        //
        return ACPIBusIrpSetSystemPower( DeviceObject, Irp, irpStack );

    } else {

        //
        // This is a device request
        //
        return ACPIBusIrpSetDevicePower( DeviceObject, Irp, irpStack );

    }

}

NTSTATUS
ACPIBusIrpSetSystemPower(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This handles request for a system set power irp sent to a PDO

Arguments:

    DeviceObject    - The PDO target of the request
    Irp             - The current request
    IrpStack        - The current arguments

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  deviceState;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    POWER_STATE         powerState;
    SYSTEM_POWER_STATE  systemState;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Grab these two values. They are required for further calculations
    //
    systemState= IrpStack->Parameters.Power.State.SystemState;
    deviceState = deviceExtension->PowerInfo.DevicePowerMatrix[systemState];

    //
    // If our ShutdownAction is PowerActionWarmEject, then we have a special
    // case, and we don't need to request a D-irp for the device
    //
    if (IrpStack->Parameters.Power.ShutdownType == PowerActionWarmEject) {

        ASSERT(!(deviceExtension->Flags & DEV_PROP_NO_OBJECT));
        ASSERT(!ACPIDockIsDockDevice(deviceExtension->AcpiObject));

        //
        // We are going to do some work on the irp, so mark it as being
        // successfull for now
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // Mark the irp as pending
        //
        IoMarkIrpPending( Irp );

        //
        // We might queue up the irp, so this counts as a completion routine.
        // Which means we need to incr the ref count
        //
        InterlockedIncrement( &deviceExtension->OutstandingIrpCount );

        ACPIDevPrint( (
            ACPI_PRINT_REMOVE,
            deviceExtension,
            "(0x%08lx) ACPIBusIrpSetSystemPower: Eject from S%d!\n",
            Irp,
            systemState - PowerSystemWorking
            ) );

        //
        // Request the warm eject
        //
        status = ACPIDeviceIrpWarmEjectRequest(
            deviceExtension,
            Irp,
            ACPIDeviceIrpCompleteRequest,
            FALSE
            );

        //
        // If we got back STATUS_MORE_PROCESSING_REQUIRED, then that is
        // just an alias for STATUS_PENDING, so we make that change now
        //
        if (status == STATUS_MORE_PROCESSING_REQUIRED) {

            status = STATUS_PENDING;

        }
        return status;

    }

    //
    // Look at the device extension and determine if we need to send a
    // D-irp in respond. The rule is that if the device is RAW driven or
    // the current D state of the device is numerically lower then the
    // known D state for the given S state, then we should send the request
    //
    if ( !(deviceExtension->Flags & DEV_CAP_RAW) ) {

        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );

    } // if
    if ( (deviceExtension->PowerInfo.PowerState == deviceState) ) {

        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );

    } // if

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx) ACPIBusIrpSetSystemPower: send D%d irp!\n",
        Irp,
        deviceState - PowerDeviceD0
        ) );

    //
    // We are going to do some work on the irp, so mark it as being
    // successfull for now
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Mark the irp as pending
    //
    IoMarkIrpPending( Irp );

    //
    // We might queue up the irp, so this counts as a completion routine.
    // Which means we need to incr the ref count
    //
    InterlockedIncrement( &deviceExtension->OutstandingIrpCount );

    //
    // We need to actually use a PowerState to send the request down, not
    // a device state
    //
    powerState.DeviceState = deviceState;

    //
    // Make the request
    //
    PoRequestPowerIrp(
        DeviceObject,
        IRP_MN_SET_POWER,
        powerState,
        ACPIBusIrpSetSystemPowerComplete,
        Irp,
        NULL
        );

    //
    // Always return pending
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIBusIrpSetSystemPowerComplete(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This routine is called when the created D-irp has been sent throughout
    the stack

Arguments:

    DeviceObject    - The device that received the request
    MinorFunction   - The function that was requested of the device
    PowerState      - The power state the device was sent to
    Context         - The original system irp
    IoStatus        - The result of the request

Return Value:

    NTSTATUS

--*/
{
    PIRP                irp = (PIRP) Context;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Make sure that we have cleared the information field
    //
    irp->IoStatus.Information = 0;

    //
    // Call this wrapper function so that we don't have to duplicated code
    //
    ACPIDeviceIrpCompleteRequest(
        deviceExtension,
        (PVOID) irp,
        IoStatus->Status
        );

    //
    // Done
    //
    return IoStatus->Status;
}

typedef struct {
    KEVENT  Event;
    PIRP    Irp;
} START_DEVICE_CONTEXT, *PSTART_DEVICE_CONTEXT;

NTSTATUS
ACPIBusIrpStartDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to start the device

Arguments:

    DeviceObject    - The device to start
    Irp             - The request to the device to tell it to stop

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // If this is a PCI root bus (the only way that it can be here is if
    // we enumerated this as a PNP0A03 device object) then we need to do
    // a few extra things
    //
    if (deviceExtension->Flags & DEV_CAP_PCI) {

        //
        // The IRQ Arbiter needs to have the FDO of the PCI
        // bus.  So here is a PDO.  From this, can be gotten
        // the FDO.  And only do it once.
        //
        if (!PciInterfacesInstantiated) {

            AcpiArbInitializePciRouting( DeviceObject );

        }

        //
        // We need to get the PME interface as well
        //
        if (!PciPmeInterfaceInstantiated) {

            ACPIWakeInitializePmeRouting( DeviceObject );

        }

    }

    //
    // Pass the real work off to this function
    //
    status = ACPIInitStartDevice(
         DeviceObject,
         irpStack->Parameters.StartDevice.AllocatedResources,
         ACPIBusIrpStartDeviceCompletion,
         Irp,
         Irp
         );
    if (NT_SUCCESS(status)) {

        return STATUS_PENDING;

    } else {

        return status;

    }
}

VOID
ACPIBusIrpStartDeviceCompletion(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is the call back routine that is invoked when we have finished
    programming the resources

    This routine completes the irp

Arguments:

    DeviceExtension - Extension of the device that was started
    Context         - The Irp
    Status          - The result

Return Value:

    None

--*/
{
    PIRP                irp         = (PIRP) Context;
    PWORK_QUEUE_CONTEXT workContext = &(DeviceExtension->Pdo.WorkContext);

    irp->IoStatus.Status = Status;
    if (NT_SUCCESS(Status)) {

        DeviceExtension->DeviceState = Started;

    } else {

        PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( irp );
        UCHAR               minorFunction = irpStack->MinorFunction;

        //
        // Complete the irp --- we can do this at DPC level without problem
        //
        IoCompleteRequest( irp, IO_NO_INCREMENT );

        //
        // Let the world know
        //
        ACPIDevPrint( (
            ACPI_PRINT_IRP,
            DeviceExtension,
            "(0x%08lx): %s = 0x%08lx\n",
            irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            Status
            ) );
        return;

    }

    //
    // We can't run EnableDisableRegions at DPC level,
    // so queue a worker item.
    //
    ExInitializeWorkItem(
          &(workContext->Item),
          ACPIBusIrpStartDeviceWorker,
          workContext
          );
    workContext->DeviceObject = DeviceExtension->DeviceObject;
    workContext->Irp = irp;
    ExQueueWorkItem(
          &(workContext->Item),
          DelayedWorkQueue
          );
}

VOID
ACPIBusIrpStartDeviceWorker(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called at PASSIVE_LEVEL after we after turned on the
    device

Arguments:

    Context - Contains the arguments passed to the START_DEVICE function

Return Value:

    None

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      deviceObject;
    PIRP                irp;
    PIO_STACK_LOCATION  irpStack;
    PWORK_QUEUE_CONTEXT workContext = (PWORK_QUEUE_CONTEXT) Context;
    UCHAR               minorFunction;

    PAGED_CODE();

    //
    // Grab the parameters that we need out of the Context
    //
    deviceObject = workContext->DeviceObject;
    deviceExtension = ACPIInternalGetDeviceExtension( deviceObject );
    irp = workContext->Irp;
    irpStack = IoGetCurrentIrpStackLocation( irp );
    minorFunction = irpStack->MinorFunction;
    status = irp->IoStatus.Status;

    //
    // Update the status of the device
    //
    if (NT_SUCCESS(status)) {

        if (IsNsobjPciBus(deviceExtension->AcpiObject)) {

            //
            // This may be a PCI bridge, so we
            // may have _REG methods to evaluate.
            // N.B.  This work is done here, instead
            // of in ACPIBusIrpStartDevice because we
            // need to wait until after the resources
            // have been programmed.
            //
            EnableDisableRegions(deviceExtension->AcpiObject, TRUE);

        }

    }

    //
    // Complete the request
    //
    irp->IoStatus.Status = status;
    irp->IoStatus.Information = (ULONG_PTR) NULL;
    IoCompleteRequest( irp, IO_NO_INCREMENT );

    //
    // Let the world know
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
}

NTSTATUS
ACPIBusIrpStopDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to stop the device...

Arguments:

    DeviceObject    - The device to stop
    Irp             - The request to the device to tell it to stop..

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              acpiObject;
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    acpiObject      = deviceExtension->AcpiObject;

    //
    // We are trying to be intelligent here. If we got a stop without being
    // in the inactive state, then we should remember what state we where in
    //
    if (deviceExtension->DeviceState != Inactive) {

        deviceExtension->DeviceState = deviceExtension->PreviousState;

    }

    if (IsPciBus(deviceExtension->DeviceObject)) {

        //
        // If this is PCI bridge, then we
        // may have _REG methods to evaluate.
        //

        EnableDisableRegions(deviceExtension->AcpiObject, FALSE);
    }

    //
    // Set the device as 'Stopped'
    //
    deviceExtension->DeviceState = Stopped;

    //
    // Mark the request as complete...
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    if (NT_SUCCESS(status)) {

        //
        // Attempt to stop the device
        //
        ACPIInitStopDevice( deviceExtension, FALSE );

    }

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIBusIrpSurpriseRemoval(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for surprise remove

Arguments:

    DeviceObject    - The device object
    Irp             - The request in question

Return Value:

    NTSTATUS
--*/
{
    KIRQL               oldIrql;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              acpiObject;
    UCHAR               minorFunction   = irpStack->MinorFunction;
    PDEVICE_EXTENSION   newDeviceExtension ;

    //
    // Get the device extension and acpi object.
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    acpiObject      = deviceExtension->AcpiObject;

    //
    // If we are already removed, then this isn't a valid request
    //
    if (deviceExtension->DeviceState == Removed) {

        return ACPIDispatchIrpSurpriseRemoved( DeviceObject, Irp );

    }

    if ( !ACPIInternalIsReportedMissing(deviceExtension) ) {

        //
        // If the device is still physically present, then an FDO used
        // IoInvalidatePnpDeviceState to set the device to disabled. No
        // QueryRemove/Remove combination happens here, we just get a
        // SurpriseRemove as we are already started. It is actually appropriate
        // to set it to stop as we may get restarted after remove strips the
        // complaining FDO off.
        //
        deviceExtension->DeviceState = Stopped;

        //
        // Mark the request as complete...
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        if (NT_SUCCESS(status)) {

            //
            // Attempt to stop the device
            //
            ACPIInitStopDevice( deviceExtension, TRUE );

        }
        return status;

    }

    if (IsPciBus(deviceExtension->DeviceObject)) {

        //
        // If this is PCI bridge, then we
        // may have _REG methods to evaluate.
        //
        EnableDisableRegions(deviceExtension->AcpiObject, FALSE);
    }

    //
    // Set the device state as surprise removed
    //
    deviceExtension->DeviceState = SurpriseRemoved;

    //
    // Attempt to stop the device (if possible)
    //
    ACPIInitStopDevice( deviceExtension, TRUE );

    //
    // Is the device really gone? In other words, did ACPI not see it the
    // last time that it was enumerated?
    //
    ACPIBuildSurpriseRemovedExtension(deviceExtension);

    //
    // Complete the request
    //
    Irp->IoStatus.Status = status ;
    Irp->IoStatus.Information = (ULONG_PTR) NULL;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_REMOVE,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status ;
}

NTSTATUS
ACPIBusIrpUnhandled(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for all unhandled irps

Arguments:

    DeviceObject    - The device object that we (do not) care about
    Irp             - The request in question

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Auto-complete the IRP as something we don't handle...
    //
    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status;
}

VOID
SmashInterfaceQuery(
    IN OUT PIRP     Irp
    )
{
    GUID                *interfaceType;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    interfaceType = (LPGUID) irpStack->Parameters.QueryInterface.InterfaceType;

    RtlZeroMemory(interfaceType, sizeof(GUID));
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\callback.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    callback.h

Abstract:

    This module implements all the callbacks that are NT specific from
    the AML Interperter

Environment

    Kernel mode only

Revision History:

    04-Jun-97 Initial Revision

--*/

#ifndef _CALLBACK_H_
#define _CALLBACK_H_

    extern PNSOBJ               ProcessorList[];
    extern KSPIN_LOCK           AcpiCallBackLock;
    extern SINGLE_LIST_ENTRY    AcpiCallBackList;

    //
    // This is the structure that is used to store the information
    // about the callbacks that we had to queue up
    //
    typedef struct _ACPI_CALLBACK_ENTRY {

        //
        // Points to the next element in the list
        //
        SINGLE_LIST_ENTRY   ListEntry;

        //
        // This is the type of event type eg: EVTYPE_OPCODE
        //
        ULONG               EventType;

        //
        // This is the subtype: eg  OP_DEVICE
        //
        ULONG               EventData;

        //
        // The targeted NS object
        //
        PNSOBJ              AcpiObject;

        //
        // Event specific information
        //
        ULONG               EventParameter;

        //
        // Function to call
        //
        PFNOH               CallBack;

    } ACPI_CALLBACK_ENTRY, *PACPI_CALLBACK_ENTRY;

    NTSTATUS
    EXPORT
    ACPICallBackLoad(
        IN  ULONG   EventType,
        IN  ULONG   NotifyType,
        IN  ULONG   EventData,
        IN  PNSOBJ  AcpiObject,
        IN  ULONG   EventParameter
        );

    NTSTATUS
    EXPORT
    ACPICallBackUnload(
        IN  ULONG   EventType,
        IN  ULONG   NotifyType,
        IN  ULONG   EventData,
        IN  PNSOBJ  AcpiObject,
        IN  ULONG   EventParameter
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\cmbutton.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cmbutton.c

Abstract:

    Control Method Button support

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July 7, 1997    - Complete Rewrite

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPICMButtonStart)
#pragma alloc_text(PAGE, ACPICMLidStart)
#pragma alloc_text(PAGE, ACPICMPowerButtonStart)
#pragma alloc_text(PAGE, ACPICMSleepButtonStart)
#endif

VOID
ACPICMButtonNotify (
    IN PVOID    Context,
    IN ULONG    EventData
    )
/*++

Routine Description:

    AMLI device notification handler for control method button device

Arguments:

    DeviceObject    - fixed feature button device object
    EventData       - The event code the device is notified with

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      deviceObject = (PDEVICE_OBJECT) Context;
    ULONG               capabilities;

    deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);

    //
    // Handle event type
    //
    switch (EventData) {
    case 0x80:
#if 0
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            0,
            0,
            0,
            0
            );
#endif
        capabilities = deviceExtension->Button.Capabilities;
        if (capabilities & SYS_BUTTON_LID) {

            //
            // Get worker to check LID's status
            //
            ACPISetDeviceWorker( deviceExtension, LID_SIGNAL_EVENT);

        } else {

            //
            // Notify button was pressed
            //
            ACPIButtonEvent(
                deviceObject,
                capabilities & ~SYS_BUTTON_WAKE,
                NULL
                );

        }
        break;

    case 2:

        //
        // Signal wake button
        //
        ACPIButtonEvent (deviceObject, SYS_BUTTON_WAKE, NULL);
        break;

    default:

        ACPIDevPrint( (
            ACPI_PRINT_WARNING,
            deviceExtension,
            "ACPICMButtonNotify: Unknown CM butt notify code %d\n",
            EventData
            ) );
        break;

    }
}

NTSTATUS
ACPICMButtonSetPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the main routine for setting power to a button. It dispatches a
    WAIT_WAKE irp (if necessary) then calls the real worker function to
    put the button in the proper state

Arguments:

    DeviceObject    - The button device object
    Irp             - The request that we are handling

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    SYSTEM_POWER_STATE  systemState;

    //
    // If this is request to go a specific D-state, pass that along and
    // return immediately --- there is nothing for us to do in this case
    //
    if (irpStack->Parameters.Power.Type == DevicePowerState) {

        goto ACPICMButtonSetPowerExit;

    }

    //
    // HACKHACK --- Some Vendors can't get their act together and need to
    // have _PSW(On) when the system boots, otherwise they cannot deliver
    // Button Press notification, so to accomodate those vendors, we have
    // enabled _PSW(On) for all button devices except lid switchs. So,
    // if we aren't a lid switch, then do nothing
    //
    if ( !(deviceExtension->Button.Capabilities & SYS_BUTTON_LID) ) {

        goto ACPICMButtonSetPowerExit;

    }

    //
    // If we don't support wake on the device, then there is nothing to do
    //
    if ( !(deviceExtension->Flags & DEV_CAP_WAKE) ) {

        goto ACPICMButtonSetPowerExit;

    }

    //
    // What system state are we going to go to?
    //
    systemState = irpStack->Parameters.Power.State.SystemState;
    if (systemState == PowerSystemWorking) {

        //
        // If we are transitioning back into D0, then we want to cancel
        // any outstanding WAIT_WAKE requests that we have
        //
        status = ACPICMButtonWaitWakeCancel( deviceExtension );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                "%08lx: ACPICMButtonWaitWakeCancel = %08lx\n",
                Irp,
                status
                ) );
            goto ACPICMButtonSetPowerExit;

        }

    } else {

        //
        // Can we wake the system from this state?
        //
        if (deviceExtension->PowerInfo.SystemWakeLevel < systemState) {

            goto ACPICMButtonSetPowerExit;

        }

        //
        // Do not enable this behaviour by default
        //
        if ( (deviceExtension->Flags & DEV_PROP_NO_LID_ACTION) ) {

            goto ACPICMButtonSetPowerExit;

#if 0
            //
            // If we are a lid switch and if the lid isn't closed
            // right now, then do not enable wake support.
            //
            if ( (deviceExtension->Button.LidState != 0) ) {

                //
                // The lid is open
                //
                goto ACPICMButtonSetPowerExit;

            }
#endif

        }

        //
        // Send a WAIT_WAKE irp to ourselves
        //
        status = PoRequestPowerIrp(
            DeviceObject,
            IRP_MN_WAIT_WAKE,
            irpStack->Parameters.Power.State,
            ACPICMButtonWaitWakeComplete,
            NULL,
            NULL
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                "(%08lx): ACPICMButtonSetPower - PoRequestPowerIrp = %08lx\n",
                Irp,
                status
                ) );
            goto ACPICMButtonSetPowerExit;

        }
    }

ACPICMButtonSetPowerExit:

    //
    // Pass the irp to the normal dispatch point
    //
    return ACPIBusIrpSetPower(
        DeviceObject,
        Irp
        );
}

NTSTATUS
ACPICMButtonStart (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  ULONG           ButtonType
    )
/*++

Routine Description:

    This is the main routine for starting a button. We remember what type
    of button we have then we start the button as we would any other device.

    We actually register device interfaces and the like in the worker function
    that the completion routine schedules for us.

Arguments:

    DeviceObject    - The device that is starting
    Irp             - The start irp request
    ButtonType      - What kind of button this is

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    NTSTATUS            status;

    PAGED_CODE();

    //
    // Initialize device support
    //
    KeInitializeSpinLock (&deviceExtension->Button.SpinLock);
    deviceExtension->Button.Capabilities = ButtonType;

    //
    // Start the device
    //
    status = ACPIInitStartDevice(
        DeviceObject,
        NULL,
        ACPICMButtonStartCompletion,
        Irp,
        Irp
        );
    if (NT_SUCCESS(status)) {

        return STATUS_PENDING;

    } else {

        return status;

    }

}

VOID
ACPICMButtonStartCompletion(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is the callback routine that is invoked when we have finished
    programming the resources.

    This routine queues the irp to a worker thread so that we can do the
    rest of the start device code. It will complete the irp, however, if
    the success is not STATUS_SUCCESS.

Arguments:

    DeviceExtension - Extension of the device that was started
    Context         - The Irp
    Status          - The result

Return Value:

    None

--*/
{
    PIRP                irp         = (PIRP) Context;
    PWORK_QUEUE_CONTEXT workContext = &(DeviceExtension->Pdo.WorkContext);

    irp->IoStatus.Status = Status;
    if (NT_SUCCESS(Status)) {

        DeviceExtension->DeviceState = Started;

    } else {

        PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( irp );
        UCHAR               minorFunction = irpStack->MinorFunction;

        //
        // Complete the irp --- we can do this at DPC level without problem
        //
        IoCompleteRequest( irp, IO_NO_INCREMENT );

        //
        // Let the world know
        //
        ACPIDevPrint( (
             ACPI_PRINT_IRP,
            DeviceExtension,
            "(0x%08lx): %s = 0x%08lx\n",
            irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            Status
            ) );
        return;

    }

    //
    // We can't run EnableDisableRegions at DPC level,
    // so queue a worker item.
    //
    ExInitializeWorkItem(
          &(workContext->Item),
          ACPICMButtonStartWorker,
          workContext
          );
    workContext->DeviceObject = DeviceExtension->DeviceObject;
    workContext->Irp = irp;
    ExQueueWorkItem(
          &(workContext->Item),
          DelayedWorkQueue
          );

}

VOID
ACPICMButtonStartWorker(
    IN  PVOID   Context
    )
/*++

Routine Description:

    This routine is called at PASSIVE_LEVEL after we turned on the device

    It registers any interfaces we might need to use

Arguments:

    Context - Contains the arguments passed to the START_DEVICE function

Return Value:

    None

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      deviceObject;
    PIRP                irp;
    PIO_STACK_LOCATION  irpStack;
    PWORK_QUEUE_CONTEXT workContext = (PWORK_QUEUE_CONTEXT) Context;
    UCHAR               minorFunction;

    //
    // Grab the parameters that we need out of the Context
    //
    deviceObject    = workContext->DeviceObject;
    deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);
    irp             = workContext->Irp;
    irpStack        = IoGetCurrentIrpStackLocation( irp );
    minorFunction   = irpStack->MinorFunction;
    status          = irp->IoStatus.Status;

    //
    // Update the status of the device
    //
    if (!NT_SUCCESS(status)) {

        goto ACPICMButtonStartWorkerExit;

    }

    //
    // If this is a lid switch, find out what the current state of
    // switch is
    //
    if (deviceExtension->Button.Capabilities & SYS_BUTTON_LID) {

        //
        // Register the callback. Ignore the return value as we will
        // don't really care if registration was successfull or not
        //
        status = ACPIInternalRegisterPowerCallBack(
            deviceExtension,
            (PCALLBACK_FUNCTION) ACPICMLidPowerStateCallBack
            );
        if (!NT_SUCCESS(status)) {

            status = STATUS_SUCCESS;

        }

        //
        // Force a callback to make sure that we initialize the lid to the
        // proper policy
        //
        ACPICMLidPowerStateCallBack(
            deviceExtension,
            PO_CB_SYSTEM_POWER_POLICY,
            0
            );

        //
        // Note: Setting the events as 0x0 should just cause the
        // system to run ACPICMLidWorker() without causing any side
        // effects (like telling the system to go to sleep
        //
        ACPISetDeviceWorker( deviceExtension, 0 );

    } else {

        IO_STATUS_BLOCK ioStatus;
        KIRQL           oldIrql;
        POWER_STATE     powerState;

        //
        // Initialize the ioStatus block to enable the device's waitwake
        //
        ioStatus.Status = STATUS_SUCCESS;
        ioStatus.Information = 0;

        //
        // This is the S-state that we will try to wake the system from
        //
        KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );
        powerState.SystemState = deviceExtension->PowerInfo.SystemWakeLevel;
        KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

        //
        // Start the WaitWake Loop
        //
        status = ACPIInternalWaitWakeLoop(
            deviceObject,
            IRP_MN_WAIT_WAKE,
            powerState,
            NULL,
            &ioStatus
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                " - ACPIInternalWaitWakeLoop = %08lx\n",
                status
                ) );
            goto ACPICMButtonStartWorkerExit;

        }

    }

    //
    // Register for device notifies on this device
    //
    ACPIRegisterForDeviceNotifications(
        deviceObject,
        (PDEVICE_NOTIFY_CALLBACK) ACPICMButtonNotify,
        (PVOID) deviceObject
        );

    //
    // Register device as supporting system button ioctl
    //
    status = ACPIInternalSetDeviceInterface(
        deviceObject,
        (LPGUID) &GUID_DEVICE_SYS_BUTTON
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_WARNING,
            deviceExtension,
            "ACPICMButtonStartWorker: ACPIInternalSetDeviceInterface = %08lx\n",
            status
            ) );
        goto ACPICMButtonStartWorkerExit;

    }

ACPICMButtonStartWorkerExit:

    //
    // Complete the request
    //
    irp->IoStatus.Status = status;
    irp->IoStatus.Information = (ULONG_PTR) NULL;
    IoCompleteRequest( irp, IO_NO_INCREMENT );

    //
    // Let the world know
    //
    ACPIDevPrint( (
         ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

}

NTSTATUS
ACPICMButtonWaitWakeCancel(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine cancels any outstanding WAIT_WAKE irp on the given
    device extension.

    The way that this code works is rather slimy. It is based on the
    assumption that the way that the Irp is cancelled doesn't really
    matter since the completion routine doesn't do anything interesting.
    So, the choice is that the driver can keep track of each WAIT WAKE
    irp the extension is associated with in the extension, write some
    complicated synchronization code to make sure that we don't cancel
    an IRP that could fire a WAIT WAKE, etc, etc, or we can simply fake
    a call that tells the OS that the device woke the system

Arguments:

    DeviceExtension - The deviceExtension to cancel

Return Value:

    NTSTATUS

--*/
{    return OSNotifyDeviceWake( DeviceExtension->AcpiObject );
}

NTSTATUS
ACPICMButtonWaitWakeComplete(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This routine is called when the button has awoken the system

Arguments:

    DeviceObject    - The device object which woke the computer
    MinorFunction   - IRP_MN_WAIT_WAKE
    PowerState      - The state that it woke the computer from
    Context         - Not used
    IoStatus        - The result of the request

--*/
{
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    UNREFERENCED_PARAMETER( MinorFunction );
    UNREFERENCED_PARAMETER( PowerState );
    UNREFERENCED_PARAMETER( Context );

    if (!NT_SUCCESS(IoStatus->Status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPICMButtonWaitWakeComplete - %08lx\n",
            IoStatus->Status
            ) );

    } else {

        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            deviceExtension,
            "ACPICMButtonWaitWakeComplete - %08lx\n",
            IoStatus->Status
            ) );

    }

    return IoStatus->Status;
}

VOID
ACPICMLidPowerStateCallBack(
    IN  PVOID   CallBackContext,
    IN  PVOID   Argument1,
    IN  PVOID   Argument2
    )
/*++

Routine Description:

    This routine is called whenever the system changes the power policy.

    The purpose of this routine is to see wether or not the user placed
    an action on closing the lid. If there is, then we arm the behaviour
    that the lid should always wake up the computer. Otherwise, opening the
    lid should do nothing

Arguments:

    CallBackContext - The DeviceExtension for the lid switch
    Argument1       - The action that is being undertaken
    Argument2       - Unused

Return Value:

    None

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) CallBackContext;
    SYSTEM_POWER_POLICY powerPolicy;
    ULONG               action = PtrToUlong(Argument1);

    UNREFERENCED_PARAMETER( Argument2 );

    //
    // We are looking for a PO_CB_SYSTEM_POWER_POLICY change
    //
    if (action != PO_CB_SYSTEM_POWER_POLICY) {

        return;

    }

    //
    // Get the information that we desired
    //
    status = ZwPowerInformation(
        SystemPowerPolicyCurrent,
        NULL,
        0,
        &powerPolicy,
        sizeof(SYSTEM_POWER_POLICY)
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPICMLidPowerStateCallBack - Failed ZwPowerInformation %8x\n",
            status
            ) );
        return;

    }

    //
    // Is there an action for the lid?
    //
    if (powerPolicy.LidClose.Action == PowerActionNone ||
        powerPolicy.LidClose.Action == PowerActionReserved) {

        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            DEV_PROP_NO_LID_ACTION,
            FALSE
            );

    } else {

        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            DEV_PROP_NO_LID_ACTION,
            TRUE
            );

    }
}

NTSTATUS
ACPICMLidSetPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the main routine for setting power to a lid. It dispatches a
    WAIT_WAKE irp (if necessary) then calls the real worker function to
    put the button in the proper state

Arguments:

    DeviceObject    - The button device object
    Irp             - The request that we are handling

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    PULONG              lidState;

    //
    // If this is request to go a specific D-state, pass that along and
    // return immediately --- there is nothing for us to do in this case
    //
    if (irpStack->Parameters.Power.Type == DevicePowerState) {

        return ACPIBusIrpSetDevicePower( DeviceObject, Irp, irpStack );

    }

    //
    // HACKHACK
    //
    // We are going to want to know what the state of the lid is. We will
    // end up calling the interpreter at DPC level, so where we store the
    // lidState cannot be on the local stack. One nice place that we
    // can use is the Parameters.Power.Type field, since we already know
    // what the answer should be
    //
    lidState = (PULONG)&(irpStack->Parameters.Power.Type);

    //
    // Mark the irp as pending
    //
    IoMarkIrpPending( Irp );

    //
    // Evalute the integer
    //
    status = ACPIGetIntegerAsync(
        deviceExtension,
        PACKED_LID,
        ACPICMLidSetPowerCompletion,
        Irp,
        lidState,
        NULL
        );
    if (status != STATUS_PENDING) {

        ACPICMLidSetPowerCompletion(
            NULL,
            status,
            NULL,
            Irp
            );

    }

    //
    // Always return STATUS_PENDING --- if we complete the irp with
    // another status code, we will do so in another (maybe) context...
    //
    return STATUS_PENDING;
}

VOID
EXPORT
ACPICMLidSetPowerCompletion(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    Result,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called when the system has finished fetching the
    current lid state for the switch

Arguments:

    AcpiObject  - The object that we ran (ie: _LID)
    Status      - Did the operation succeed
    Result      - The result of the operation
    Context     - IRP

Return Value:

    None

--*/
{
    BOOLEAN             noticeStateChange = FALSE;
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      deviceObject;
    PIO_STACK_LOCATION  irpStack;
    PIRP                irp = (PIRP) Context;
    PULONG              lidStateLocation;
    ULONG               lidState;

    //
    // Get the current Irp Stack location
    //
    irpStack = IoGetCurrentIrpStackLocation( irp );

    //
    // Get the current device extension
    //
    deviceObject    = irpStack->DeviceObject;
    deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);

    //
    // Go and find the place were to told the OS to write the answer to the
    // _LID request. We should also reset this stack location to the proper
    // value
    //
    lidStateLocation = (PULONG)&(irpStack->Parameters.Power.Type);
    lidState = *lidStateLocation;
    *lidStateLocation = (ULONG) SystemPowerState;

    //
    // Did we succeed?
    //
    if (!NT_SUCCESS(Status)) {

        //
        // Note that we choose to pass the irp back to something
        // that will not send it a WAIT_WAKE irp
        //
        *lidStateLocation = (ULONG) SystemPowerState;
        ACPIBusIrpSetSystemPower( deviceObject, irp, irpStack );
        return;

    }

    //
    // Make sure that the lid state is a one or a zero
    //
    lidState = (lidState ? 1 : 0);

    //
    // Grab the button spinlock
    //
    KeAcquireSpinLock( &(deviceExtension->Button.SpinLock), &oldIrql );

    //
    // Did we the lid change state? Note that because we don't want the
    // user sleeping the machine, closing the lid, then the machine
    // waking up because of Wake-On-LAN causing the machine to go back
    // to sleep, the only state change that we care about is if the
    // lid went from the closed state to the open state
    //
    if (deviceExtension->Button.LidState == FALSE &&
        lidState == 1) {

        noticeStateChange = TRUE;

    }
    deviceExtension->Button.LidState = (BOOLEAN) lidState;

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &(deviceExtension->Button.SpinLock), oldIrql );

    //
    // Did we notice a lid state change?
    //
    if (noticeStateChange) {

        ACPIButtonEvent (
            deviceObject,
            SYS_BUTTON_WAKE,
            NULL
            );

    }

    //
    // At this point, we are done, and we can pass the request off to
    // the proper dispatch point. Note that we will choose something that
    // can fire a WAIT_WAKE irp
    //
    ACPICMButtonSetPower( deviceObject, irp );
    return;
}

NTSTATUS
ACPICMLidStart (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the start routine for any lid device

Arguments:

    DeviceObject    - The device that is starting
    Irp             - The start irp request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();
    return ACPICMButtonStart (
        DeviceObject,
        Irp,
        SYS_BUTTON_LID
        );
}

VOID
ACPICMLidWorker (
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN ULONG                Events
    )
/*++

Routine Description:

    Worker thread function to get the current lid status

Arguments:

    deviceExtension  - The Device Extension for the lid
    Events  - The event that occured

Return Value:

    VOID

--*/
{
    KIRQL           oldIrql;
    NTSTATUS        status;
    ULONG           lidState;

    //
    // Get the current lid status
    //
    status = ACPIGetIntegerSync(
        DeviceExtension,
        PACKED_LID,
        &lidState,
        NULL
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            " ACPICMLidWorker - ACPIGetIntegerSync = %08lx\n",
            status
            ) );
        return;

    }

    //
    // force the value to either a 1 or a 0
    //
    lidState = lidState ? 1 : 0;

    //
    // We need a spinlock since we can access/set this data from multiple
    // places
    //
    KeAcquireSpinLock( &(DeviceExtension->Button.SpinLock), &oldIrql );

    //
    // Set the new lid state
    //
    DeviceExtension->Button.LidState = (BOOLEAN) lidState;

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &(DeviceExtension->Button.SpinLock), oldIrql );

    //
    // Further processing depends on what events are set
    //
    if (Events & LID_SIGNAL_EVENT) {

        //
        // Signal the event
        //
        ACPIButtonEvent (
            DeviceExtension->DeviceObject,
            lidState ? SYS_BUTTON_WAKE : SYS_BUTTON_LID,
            NULL
            );

    }
}

NTSTATUS
ACPICMPowerButtonStart (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the start routine for any power button

Arguments:

    DeviceObject    - The device that is starting
    Irp             - The start irp request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();
    return ACPICMButtonStart (
        DeviceObject,
        Irp,
        SYS_BUTTON_POWER | SYS_BUTTON_WAKE
        );
}

NTSTATUS
ACPICMSleepButtonStart (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the start routine for any sleep button

Arguments:

    DeviceObject    - The device that is starting
    Irp             - The start irp request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();
    return ACPICMButtonStart (
        DeviceObject,
        Irp,
        SYS_BUTTON_SLEEP | SYS_BUTTON_WAKE
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\cmbutton.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    button.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _CMBUTTON_H_
#define _CMBUTTON_H_

    //
    // Lid Events
    //
    #define LID_SIGNAL_EVENT        0x1

    VOID
    ACPICMButtonNotify(
        IN  PVOID   Context,
        IN  ULONG   EventData
        );

    NTSTATUS
    ACPICMButtonSetPower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );


    NTSTATUS
    ACPICMButtonStart(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp,
        IN  ULONG           ButtonType
        );

    VOID
    ACPICMButtonStartCompletion(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PVOID               Context,
        IN  NTSTATUS            Status
        );

    VOID
    ACPICMButtonStartWorker(
        IN  PVOID               Context
        );

    NTSTATUS
    ACPICMButtonWaitWakeCancel(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPICMButtonWaitWakeComplete(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  UCHAR               MinorFunction,
        IN  POWER_STATE         PowerState,
        IN  PVOID               Context,
        IN  PIO_STATUS_BLOCK    IoStatus
        );

    VOID
    ACPICMLidPowerStateCallBack(
        IN  PVOID               CallBackContext,
        IN  PVOID               Argument1,
        IN  PVOID               Argument2
        );

    NTSTATUS
    ACPICMLidSetPower(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PIRP                Irp
        );

    VOID
    EXPORT
    ACPICMLidSetPowerCompletion(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  PVOID               Context
        );

    NTSTATUS
    ACPICMLidStart(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID
    ACPICMLidWorker(
        IN  PDEVICE_EXTENSION   DevExt,
        IN  ULONG               Events
        );

    NTSTATUS
    ACPICMPowerButtonStart(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPICMSleepButtonStart(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\dat.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dat.c

Abstract:

    This module contains all of the data variables that are used for
    dispatching IRPs in the ACPI NT Driver. The major Irp tables might
    be assigned as follows:

                                   +-- ACPI Root ------IRP--+
                                   | FDO: AcpiFdoIrpDispatch |
                                   | PDO:                    |
                                   +-------------------------+

                        +-- PCI Bus --------IRP--+
                        | FDO:                    |
                        | PDO: AcpiPdoIrpDispatch |
                        +-------------------------+

 +-- ACPI Device ----------IRP--+  +-- PCI Device -----------IRP--+
 | FDO:                          |  | FDO:                          |
 | Filter:                       |  | Filter: AcpiFilterIrpDispatch |
 | PDO: AcpiBusFilterIrpDispatch |  | PDO:                          |
 +-------------------------------+  +-------------------------------+

    Rules:

    1) AcpiPdoIrpDispatch is assigned if the ACPI is an FDO on the node's
       parent. Right now, this equates to any *immediate child* of ACPI Root

    2) AcpiBusFilterIrpDispatch is for ACPI devices parading on other busses.
       For example, an ACPI, non-PCI, AC adapter might be listed as a child
       of a PCI-to-PCI Bridge Dock.

    3) AcpiFilterIrpDispatch is used when a non-ACPI bus device has ACPI
       methods. For example, the PCI-to-PCI dock bridge would fall under
       this category.

    4) Some devices, such as buttons, may have special override dispatch
       tables. These tables override any of the three previously mentioned
       tables under ACPI, although I would not expect AcpiFilterIrpDispatch
       to be overriden.

    NB: As of 02/11/98, AcpiPdoIrpDispatch and AcpiBusFilterIrpDispatch have
        identical PnP Irp handlers.


Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

#include <initguid.h>       // define guids
#include <poclass.h>
#include <wdmguid.h>
#include <wmiguid.h>
#include <dockintf.h>


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

//
// These are the PNP dispatch tables
//
PDRIVER_DISPATCH    ACPIDispatchFdoPnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIRootIrpQueryRemoveOrStopDevice,         // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIRootIrpRemoveDevice,                    // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIRootIrpCancelRemoveOrStopDevice,        // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIRootIrpStopDevice,                      // 0x04 - IRP_MN_STOP_DEVICE
    ACPIRootIrpQueryRemoveOrStopDevice,         // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIRootIrpCancelRemoveOrStopDevice,        // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIRootIrpQueryDeviceRelations,            // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIRootIrpQueryInterface,                  // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIRootIrpQueryCapabilities,               // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIDispatchForwardIrp,                     // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIDispatchForwardIrp,                     // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIDispatchForwardIrp,                     // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIDispatchForwardIrp,                     // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIDispatchForwardIrp,                     // 0x0E - NOT USED
    ACPIDispatchForwardIrp,                     // 0x0F - IRP_MN_READ_CONFIG
    ACPIDispatchForwardIrp,                     // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIDispatchForwardIrp,                     // 0x11 - IRP_MN_EJECT
    ACPIDispatchForwardIrp,                     // 0x12 - IRP_MN_SET_LOCK
    ACPIDispatchForwardIrp,                     // 0x13 - IRP_MN_QUERY_ID
    ACPIDispatchForwardIrp,                     // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIDispatchForwardIrp,                     // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIFilterIrpDeviceUsageNotification,       // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIDispatchForwardIrp,                     // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIDispatchForwardIrp                      //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchPdoPnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIBusIrpRemoveDevice,                     // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIBusIrpStopDevice,                       // 0x04 - IRP_MN_STOP_DEVICE
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIBusIrpQueryDeviceRelations,             // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIBusIrpQueryInterface,                   // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIBusIrpQueryCapabilities,                // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIBusIrpQueryResources,                   // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIBusIrpQueryResourceRequirements,        // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIBusIrpUnhandled,                        // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0E - NOT USED
    ACPIBusIrpUnhandled,                        // 0x0F - IRP_MN_READ_CONFIG
    ACPIBusIrpUnhandled,                        // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIBusIrpEject,                            // 0x11 - IRP_MN_EJECT
    ACPIBusIrpSetLock,                          // 0x12 - IRP_MN_SET_LOCK
    ACPIBusIrpQueryId,                          // 0x13 - IRP_MN_QUERY_ID
    ACPIBusIrpQueryPnpDeviceState,              // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIBusIrpUnhandled,                        // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIBusIrpDeviceUsageNotification,          // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIBusIrpSurpriseRemoval,                  // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIBusIrpUnhandled                         //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchFilterPnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIRootIrpQueryRemoveOrStopDevice,         // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIFilterIrpRemoveDevice,                  // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIRootIrpCancelRemoveOrStopDevice,        // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIFilterIrpStopDevice,                    // 0x04 - IRP_MN_STOP_DEVICE
    ACPIRootIrpQueryRemoveOrStopDevice,         // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIRootIrpCancelRemoveOrStopDevice,        // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIFilterIrpQueryDeviceRelations,          // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIFilterIrpQueryInterface,                // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIFilterIrpQueryCapabilities,             // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIDispatchForwardIrp,                     // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIDispatchForwardIrp,                     // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIDispatchForwardIrp,                     // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIDispatchForwardIrp,                     // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIDispatchForwardIrp,                     // 0x0E - NOT USED
    ACPIDispatchForwardIrp,                     // 0x0F - IRP_MN_READ_CONFIG
    ACPIDispatchForwardIrp,                     // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIFilterIrpEject,                         // 0x11 - IRP_MN_EJECT
    ACPIFilterIrpSetLock,                       // 0x12 - IRP_MN_SET_LOCK
    ACPIFilterIrpQueryId,                       // 0x13 - IRP_MN_QUERY_ID
    ACPIFilterIrpQueryPnpDeviceState,           // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIDispatchForwardIrp,                     // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIFilterIrpDeviceUsageNotification,       // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIFilterIrpSurpriseRemoval,               // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIDispatchForwardIrp                      //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchBusFilterPnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIBusIrpRemoveDevice,                     // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIBusIrpStopDevice,                       // 0x04 - IRP_MN_STOP_DEVICE
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIBusIrpQueryDeviceRelations,             // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIBusIrpQueryInterface,                   // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIBusIrpQueryCapabilities,                // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIBusIrpQueryResources,                   // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIBusIrpQueryResourceRequirements,        // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIBusIrpUnhandled,                        // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0E - NOT USED
    ACPIBusIrpUnhandled,                        // 0x0F - IRP_MN_READ_CONFIG
    ACPIBusIrpUnhandled,                        // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIBusIrpEject,                            // 0x11 - IRP_MN_EJECT
    ACPIBusIrpSetLock,                          // 0x12 - IRP_MN_SET_LOCK
    ACPIBusIrpQueryId,                          // 0x13 - IRP_MN_QUERY_ID
    ACPIBusIrpQueryPnpDeviceState,              // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIBusIrpUnhandled,                        // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIBusIrpDeviceUsageNotification,          // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIBusIrpSurpriseRemoval,                  // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIBusIrpUnhandled                         //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchRawDevicePnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIBusIrpRemoveDevice,                     // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIBusIrpStopDevice,                       // 0x04 - IRP_MN_STOP_DEVICE
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIInternalDeviceQueryDeviceRelations,     // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIBusIrpQueryInterface,                   // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIInternalDeviceQueryCapabilities,        // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIBusIrpQueryResources,                   // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIBusIrpQueryResourceRequirements,        // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIBusIrpUnhandled,                        // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0E - NOT USED
    ACPIBusIrpUnhandled,                        // 0x0F - IRP_MN_READ_CONFIG
    ACPIBusIrpUnhandled,                        // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIBusIrpUnhandled,                        // 0x11 - IRP_MN_EJECT
    ACPIBusIrpSetLock,                          // 0x12 - IRP_MN_SET_LOCK
    ACPIBusIrpQueryId,                          // 0x13 - IRP_MN_QUERY_ID
    ACPIBusIrpQueryPnpDeviceState,              // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIBusIrpUnhandled,                        // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIBusIrpDeviceUsageNotification,          // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIBusIrpSurpriseRemoval,                  // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIBusIrpUnhandled                         //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchInternalDevicePnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIBusIrpRemoveDevice,                     // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIBusIrpStopDevice,                       // 0x04 - IRP_MN_STOP_DEVICE
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIInternalDeviceQueryDeviceRelations,     // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIBusIrpQueryInterface,                   // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIInternalDeviceQueryCapabilities,        // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIBusIrpUnhandled,                        // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIBusIrpUnhandled,                        // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIBusIrpUnhandled,                        // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0E - NOT USED
    ACPIBusIrpUnhandled,                        // 0x0F - IRP_MN_READ_CONFIG
    ACPIBusIrpUnhandled,                        // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIBusIrpUnhandled,                        // 0x11 - IRP_MN_EJECT
    ACPIBusIrpUnhandled,                        // 0x12 - IRP_MN_SET_LOCK
    ACPIBusIrpQueryId,                          // 0x13 - IRP_MN_QUERY_ID
    ACPIBusIrpQueryPnpDeviceState,              // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIBusIrpUnhandled,                        // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIBusIrpDeviceUsageNotification,          // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIBusIrpSurpriseRemoval,                  // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIBusIrpUnhandled                         //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchEIOBusPnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIBusIrpRemoveDevice,                     // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIBusIrpStopDevice,                       // 0x04 - IRP_MN_STOP_DEVICE
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIBusIrpQueryDeviceRelations,             // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIBusIrpQueryInterface,                   // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIBusIrpQueryCapabilities,                // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIBusIrpQueryResources,                   // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIBusIrpQueryResourceRequirements,        // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIBusIrpUnhandled,                        // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0E - NOT USED
    ACPIBusIrpUnhandled,                        // 0x0F - IRP_MN_READ_CONFIG
    ACPIBusIrpUnhandled,                        // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIBusIrpEject,                            // 0x11 - IRP_MN_EJECT
    ACPIBusIrpSetLock,                          // 0x12 - IRP_MN_SET_LOCK
    ACPIBusIrpQueryId,                          // 0x13 - IRP_MN_QUERY_ID
    ACPIBusIrpQueryPnpDeviceState,              // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIBusIrpQueryBusInformation,              // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIBusIrpDeviceUsageNotification,          // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIBusIrpSurpriseRemoval,                  // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIBusIrpUnhandled                         //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchDockPnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIDispatchIrpSuccess,                     // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIDockIrpRemoveDevice,                    // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIDispatchIrpSuccess,                     // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIDispatchIrpSuccess,                     // 0x04 - IRP_MN_STOP_DEVICE
    ACPIDispatchIrpSuccess,                     // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIDispatchIrpSuccess,                     // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIDockIrpQueryDeviceRelations,            // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIDockIrpQueryInterface,                  // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIDockIrpQueryCapabilities,               // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIBusIrpUnhandled,                        // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIBusIrpUnhandled,                        // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIBusIrpUnhandled,                        // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0E - NOT USED
    ACPIBusIrpUnhandled,                        // 0x0F - IRP_MN_READ_CONFIG
    ACPIBusIrpUnhandled,                        // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIDockIrpEject,                           // 0x11 - IRP_MN_EJECT
    ACPIDockIrpSetLock,                         // 0x12 - IRP_MN_SET_LOCK
    ACPIDockIrpQueryID,                         // 0x13 - IRP_MN_QUERY_ID
    ACPIDockIrpQueryPnpDeviceState,             // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIBusIrpUnhandled,                        // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIDispatchIrpInvalid,                     // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIDispatchIrpSuccess,                     // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIBusIrpUnhandled                         //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPISurpriseRemovedFilterPnPTable[ACPIDispatchPnpTableSize] = {
   NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
   ACPIDispatchIrpSurpriseRemoved,             // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
   ACPIFilterIrpRemoveDevice,                  // 0x02 - IRP_MN_REMOVE_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x04 - IRP_MN_STOP_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x05 - IRP_MN_QUERY_STOP_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
   ACPIDispatchIrpSurpriseRemoved,             // 0x08 - IRP_MN_QUERY_INTERFACE
   ACPIDispatchIrpSurpriseRemoved,             // 0x09 - IRP_MN_QUERY_CAPABILITIES
   ACPIDispatchIrpSurpriseRemoved,             // 0x0A - IRP_MN_QUERY_RESOURCES
   ACPIDispatchIrpSurpriseRemoved,             // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
   ACPIDispatchIrpSurpriseRemoved,             // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
   ACPIDispatchIrpSurpriseRemoved,             // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
   ACPIDispatchIrpSurpriseRemoved,             // 0x0E - NOT USED
   ACPIDispatchIrpSurpriseRemoved,             // 0x0F - IRP_MN_READ_CONFIG
   ACPIDispatchIrpSurpriseRemoved,             // 0x10 - IRP_MN_WRITE_CONFIG
   ACPIDispatchIrpSurpriseRemoved,             // 0x11 - IRP_MN_EJECT
   ACPIDispatchIrpSurpriseRemoved,             // 0x12 - IRP_MN_SET_LOCK
   ACPIDispatchIrpSurpriseRemoved,             // 0x13 - IRP_MN_QUERY_ID
   ACPIDispatchIrpSurpriseRemoved,             // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
   ACPIDispatchIrpSurpriseRemoved,             // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
   ACPIDispatchIrpSurpriseRemoved,             // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
   ACPIDispatchIrpSurpriseRemoved,             // 0x17 - IRP_MN_SURPRISE_REMOVAL
   ACPIDispatchIrpSurpriseRemoved              //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchSurpriseRemovedBusPnpTable[ACPIDispatchPnpTableSize] = {
   NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
   ACPIDispatchIrpSurpriseRemoved,             // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
   ACPIBusIrpRemoveDevice,                     // 0x02 - IRP_MN_REMOVE_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x04 - IRP_MN_STOP_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x05 - IRP_MN_QUERY_STOP_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
   ACPIDispatchIrpSurpriseRemoved,             // 0x08 - IRP_MN_QUERY_INTERFACE
   ACPIDispatchIrpSurpriseRemoved,             // 0x09 - IRP_MN_QUERY_CAPABILITIES
   ACPIDispatchIrpSurpriseRemoved,             // 0x0A - IRP_MN_QUERY_RESOURCES
   ACPIDispatchIrpSurpriseRemoved,             // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
   ACPIDispatchIrpSurpriseRemoved,             // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
   ACPIDispatchIrpSurpriseRemoved,             // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
   ACPIDispatchIrpSurpriseRemoved,             // 0x0E - NOT USED
   ACPIDispatchIrpSurpriseRemoved,             // 0x0F - IRP_MN_READ_CONFIG
   ACPIDispatchIrpSurpriseRemoved,             // 0x10 - IRP_MN_WRITE_CONFIG
   ACPIDispatchIrpSurpriseRemoved,             // 0x11 - IRP_MN_EJECT
   ACPIDispatchIrpSurpriseRemoved,             // 0x12 - IRP_MN_SET_LOCK
   ACPIDispatchIrpSurpriseRemoved,             // 0x13 - IRP_MN_QUERY_ID
   ACPIDispatchIrpSurpriseRemoved,             // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
   ACPIDispatchIrpSurpriseRemoved,             // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
   ACPIDispatchIrpSurpriseRemoved,             // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
   ACPIDispatchIrpSurpriseRemoved,             // 0x17 - IRP_MN_SURPRISE_REMOVAL
   ACPIDispatchIrpSurpriseRemoved              //      - UNHANDLED PNP IRP
};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
// These are the power dispatch tables for IRP_MJ_POWER
//
PDRIVER_DISPATCH    ACPIDispatchBusPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIWakeWaitIrp,                            // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchPowerIrpUnhandled,              // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPIBusIrpSetPower,                         // 0x02 - IRP_MN_SET_POWER
    ACPIBusIrpQueryPower,                       // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchPowerIrpUnhandled,              //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchDockPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIDispatchPowerIrpInvalid,                // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchPowerIrpUnhandled,              // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPIDockIrpSetPower,                        // 0x02 - IRP_MN_SET_POWER
    ACPIDockIrpQueryPower,                      // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchPowerIrpUnhandled,              //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchButtonPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIWakeWaitIrp,                            // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchPowerIrpUnhandled,              // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPICMButtonSetPower,                       // 0x02 - IRP_MN_SET_POWER
    ACPIDispatchPowerIrpSuccess,                // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchPowerIrpUnhandled,              //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchFilterPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIWakeWaitIrp,                            // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchForwardPowerIrp,                // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPIFilterIrpSetPower,                      // 0x02 - IRP_MN_SET_POWER
    ACPIFilterIrpQueryPower,                    // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchForwardPowerIrp,                //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchFdoPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIWakeWaitIrp,                            // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchForwardPowerIrp,                // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPIRootIrpSetPower,                        // 0x02 - IRP_MN_SET_POWER
    ACPIRootIrpQueryPower,                      // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchForwardPowerIrp,                //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchInternalDevicePowerTable[ACPIDispatchPowerTableSize] = {
    ACPIDispatchPowerIrpInvalid,                // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchPowerIrpUnhandled,              // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPIDispatchPowerIrpSuccess,                // 0x02 - IRP_MN_SET_POWER
    ACPIDispatchPowerIrpSuccess,                // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchPowerIrpUnhandled,              //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchLidPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIWakeWaitIrp,                            // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchPowerIrpUnhandled,              // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPICMLidSetPower,                          // 0x02 - IRP_MN_SET_POWER
    ACPIDispatchPowerIrpSuccess,                // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchPowerIrpUnhandled,              //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchSurpriseRemovedBusPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIDispatchPowerIrpSurpriseRemoved,        // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchPowerIrpSurpriseRemoved,        // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPIDispatchPowerIrpSuccess,                // 0x02 - IRP_MN_SET_POWER
    ACPIDispatchPowerIrpSuccess,                // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchIrpSurpriseRemoved,             //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchSurpriseRemovedFilterPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIDispatchForwardPowerIrp,                // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchForwardPowerIrp,                // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPIDispatchForwardPowerIrp,                // 0x02 - IRP_MN_SET_POWER
    ACPIDispatchForwardPowerIrp,                // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchForwardPowerIrp,                //      - UNHANDLED POWER IRP
};

//
// These are the device object specific dispatch tables
//

//
// Note that AcpiBusFilterIrpDispatch's Other handler "forwards" IRPs. In this
// case forwarding means everything else (Creates/Closes/Ioctls) to the parent
// stack (we did allocate the extra stack locations!)
//
IRP_DISPATCH_TABLE AcpiBusFilterIrpDispatch = {
    ACPIDispatchIrpInvalid,                    // CreateClose
    ACPIIrpDispatchDeviceControl,              // DeviceControl
    ACPIBusIrpStartDevice,                     // PnP Start Device
    ACPIDispatchBusFilterPnpTable,             // PnP irps
    ACPIDispatchBusPowerTable,                 // Power irps
    ACPIDispatchForwardIrp,                    // WMI irps
    ACPIDispatchForwardIrp,                    // Other
    NULL                                       // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiBusFilterIrpDispatchSucceedCreate = {
    ACPIDispatchIrpSuccess,                    // CreateClose
    ACPIIrpDispatchDeviceControl,              // DeviceControl
    ACPIBusIrpStartDevice,                     // PnP Start Device
    ACPIDispatchBusFilterPnpTable,             // PnP irps
    ACPIDispatchBusPowerTable,                 // Power irps
    ACPIDispatchForwardIrp,                    // WMI irps
    ACPIDispatchForwardIrp,                    // Other
    NULL                                       // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiDockPdoIrpDispatch = {
    ACPIDispatchIrpInvalid,                 // CreateClose
    ACPIIrpDispatchDeviceControl,           // DeviceControl
    ACPIDockIrpStartDevice,                 // PnP Start Device
    ACPIDispatchDockPnpTable,               // Pnp irps
    ACPIDispatchDockPowerTable,             // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiEIOBusIrpDispatch = {
    ACPIDispatchIrpInvalid,                 // CreateClose
    ACPIDispatchIrpInvalid,                 // DeviceControl
    ACPIBusIrpStartDevice,                  // PnpStartDevice
    ACPIDispatchEIOBusPnpTable,             // PnpIrps
    ACPIDispatchBusPowerTable,              // Power irps
    ACPIDispatchForwardIrp,                 // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiFanIrpDispatch = {
    ACPIDispatchIrpSuccess,                 // CreateClose
    ACPIDispatchIrpInvalid,                 // DeviceControl
    ACPIThermalFanStartDevice,              // PnP Start device
    ACPIDispatchRawDevicePnpTable,          // PnP irps
    ACPIDispatchInternalDevicePowerTable,   // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiFdoIrpDispatch = {
    ACPIDispatchIrpSuccess,                    // CreateClose
    ACPIIrpDispatchDeviceControl,              // DeviceControl
    ACPIRootIrpStartDevice,                    // PNP Start Device
    ACPIDispatchFdoPnpTable,                   // PnP irps
    ACPIDispatchFdoPowerTable,                 // Power irps
    ACPIDispatchWmiLog,                        // WMI Irps
    ACPIDispatchForwardIrp,                    // Other
    NULL                                       // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiFilterIrpDispatch = {
    ACPIDispatchForwardIrp,                    // CreateClose
    ACPIIrpDispatchDeviceControl,              // DeviceControl
    ACPIFilterIrpStartDevice,                  // PnP Start Device
    ACPIDispatchFilterPnpTable,                // Pnp irps
    ACPIDispatchFilterPowerTable,              // Power irps
    ACPIDispatchForwardIrp,                    // WMI irps
    ACPIDispatchForwardIrp,                    // Other
    NULL                                       // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiFixedButtonIrpDispatch = {
    ACPIDispatchIrpSuccess,                 // CreateClose
    ACPIButtonDeviceControl,                // DeviceControl
    ACPIButtonStartDevice,                  // PnP Start device
    ACPIDispatchInternalDevicePnpTable,     // PnP irps
    ACPIDispatchInternalDevicePowerTable,   // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiGenericBusIrpDispatch = {
    ACPIDispatchIrpInvalid,                 // CreateClose
    ACPIDispatchIrpInvalid,                 // DeviceControl
    ACPIBusIrpStartDevice,                  // PnpStartDevice
    ACPIDispatchBusFilterPnpTable,          // PnpIrps
    ACPIDispatchBusPowerTable,              // Power irps
    ACPIDispatchForwardIrp,                 // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiLidIrpDispatch = {
    ACPIDispatchIrpSuccess,                 // CreateClose
    ACPIButtonDeviceControl,                // DeviceControl
    ACPICMLidStart,                         // PnP Start device
    ACPIDispatchInternalDevicePnpTable,     // PnP irps
    ACPIDispatchLidPowerTable,              // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    ACPICMLidWorker                         // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiPdoIrpDispatch = {
    ACPIDispatchIrpInvalid,                    // CreateClose
    ACPIIrpDispatchDeviceControl,              // DeviceControl
    ACPIBusIrpStartDevice,                     // PnP Start Device
    ACPIDispatchPdoPnpTable,                   // Pnp irps
    ACPIDispatchBusPowerTable,                 // Power irps
    ACPIBusIrpUnhandled,                       // WMI irps
    ACPIDispatchIrpInvalid,                    // Other
    NULL                                       // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiPowerButtonIrpDispatch = {
    ACPIDispatchIrpSuccess,                 // CreateClose
    ACPIButtonDeviceControl,                // DeviceControl
    ACPICMPowerButtonStart,                 // PnP Start device
    ACPIDispatchInternalDevicePnpTable,     // PnP irps
    ACPIDispatchButtonPowerTable,           // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiProcessorIrpDispatch = {
    ACPIDispatchIrpInvalid,                 // CreateClose
    ACPIProcessorDeviceControl,             // DeviceControl
    ACPIProcessorStartDevice,               // PnpStartDevice
    ACPIDispatchRawDevicePnpTable,          // PnP irps
    ACPIDispatchBusPowerTable,              // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiRawDeviceIrpDispatch = {
    ACPIDispatchIrpInvalid,                 // CreateClose
    ACPIDispatchIrpInvalid,                 // DeviceControl
    ACPIBusIrpStartDevice,                  // PnpStartDevice
    ACPIDispatchRawDevicePnpTable,          // PnP irps
    ACPIDispatchBusPowerTable,              // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiRealTimeClockIrpDispatch = {
    ACPIDispatchIrpSuccess,                 // CreateClose
    ACPIDispatchIrpInvalid,                 // DeviceControl
    ACPIInternalDeviceClockIrpStartDevice,  // PnP Start device
    ACPIDispatchRawDevicePnpTable,          // PnP irps
    ACPIDispatchBusPowerTable,              // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiSleepButtonIrpDispatch = {
    ACPIDispatchIrpSuccess,                 // CreateClose
    ACPIButtonDeviceControl,                // DeviceControl
    ACPICMSleepButtonStart,                 // PnP Start device
    ACPIDispatchInternalDevicePnpTable,     // PnP irps
    ACPIDispatchButtonPowerTable,           // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiSurpriseRemovedFilterIrpDispatch = {
    ACPIDispatchForwardIrp,                       // CreateClose
    ACPIDispatchForwardIrp,                       // DeviceControl
    ACPIDispatchIrpSurpriseRemoved,               // PnP Start Device
    ACPISurpriseRemovedFilterPnPTable,            // PnP irps
    ACPIDispatchSurpriseRemovedFilterPowerTable,  // Power irps
    ACPIDispatchForwardIrp,                       // WMI irps
    ACPIDispatchForwardIrp,                       // Other
    NULL                                          // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiSurpriseRemovedPdoIrpDispatch = {
    ACPIDispatchIrpSurpriseRemoved,               // CreateClose
    ACPIDispatchIrpSurpriseRemoved,               // DeviceControl
    ACPIDispatchIrpSurpriseRemoved,               // PnP Start Device
    ACPIDispatchSurpriseRemovedBusPnpTable,       // PnP irps
    ACPIDispatchSurpriseRemovedBusPowerTable,     // Power irps
    ACPIDispatchIrpSurpriseRemoved,               // WMI irps
    ACPIDispatchIrpSurpriseRemoved,               // Other
    NULL                                          // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiThermalZoneIrpDispatch = {
    ACPIDispatchIrpSuccess,                 // CreateClose
    ACPIThermalDeviceControl,               // DeviceControl
    ACPIThermalStartDevice,                 // PnP Start device
    ACPIDispatchPdoPnpTable,                // PnP irps
    ACPIDispatchBusPowerTable,              // SetPower
    ACPIThermalWmi,                         // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    ACPIThermalWorker                       // Worker thread handler
};

//
// Any device in this table is considered to be 'special'
//
INTERNAL_DEVICE_TABLE AcpiInternalDeviceTable[] = {
    "ACPI0006",         &AcpiGenericBusIrpDispatch,
    "FixedButton",      &AcpiFixedButtonIrpDispatch,
    "PNP0000",          &AcpiRawDeviceIrpDispatch,
    "PNP0001",          &AcpiRawDeviceIrpDispatch,
    "PNP0002",          &AcpiRawDeviceIrpDispatch,
    "PNP0003",          &AcpiRawDeviceIrpDispatch,
    "PNP0004",          &AcpiRawDeviceIrpDispatch,
    "PNP0100",          &AcpiRawDeviceIrpDispatch,
    "PNP0101",          &AcpiRawDeviceIrpDispatch,
    "PNP0102",          &AcpiRawDeviceIrpDispatch,
    "PNP0200",          &AcpiRawDeviceIrpDispatch,
    "PNP0201",          &AcpiRawDeviceIrpDispatch,
    "PNP0202",          &AcpiRawDeviceIrpDispatch,
    "PNP0800",          &AcpiRawDeviceIrpDispatch,
    "PNP0A05",          &AcpiGenericBusIrpDispatch,
    "PNP0A06",          &AcpiEIOBusIrpDispatch,
    "PNP0B00",          &AcpiRealTimeClockIrpDispatch,
    "PNP0C00",          &AcpiRawDeviceIrpDispatch,
    "PNP0C01",          &AcpiRawDeviceIrpDispatch,
    "PNP0C02",          &AcpiRawDeviceIrpDispatch,
    "PNP0C04",          &AcpiRawDeviceIrpDispatch,
    "PNP0C05",          &AcpiRawDeviceIrpDispatch,
    "PNP0C0B",          &AcpiFanIrpDispatch,
    "PNP0C0C",          &AcpiPowerButtonIrpDispatch,
    "PNP0C0D",          &AcpiLidIrpDispatch,
    "PNP0C0E",          &AcpiSleepButtonIrpDispatch,
    "SNY5001",          &AcpiBusFilterIrpDispatchSucceedCreate,
    "IBM0062",          &AcpiBusFilterIrpDispatchSucceedCreate,
    "DockDevice",       &AcpiDockPdoIrpDispatch,
    "ThermalZone",      &AcpiThermalZoneIrpDispatch,
    "Processor",        &AcpiProcessorIrpDispatch,
    NULL,               NULL
} ;

//
// This is a table of IDs and Flags. If a newly enumerated device has
// an ID that matches an entry in this table, then its initialize flags
// are the one indicate in the table.
//
// Note on PNP0C01/PNP0C02 - These are not raw so that we don't attempt to
// start them. This lets resource manager hacks take effect, which swallow
// hal/pnp0c0x conflicts.
//
INTERNAL_DEVICE_FLAG_TABLE   AcpiInternalDeviceFlagTable[] = {
    "CPQB01D",          DEV_CAP_START_IN_D3,
    "IBM3760",          DEV_CAP_START_IN_D3,
    "ACPI0006",         DEV_MASK_INTERNAL_BUS | DEV_CAP_CONTAINER,
    "PNP0000",          DEV_CAP_PIC_DEVICE | DEV_MASK_INTERNAL_DEVICE,
    "PNP0001",          DEV_CAP_PIC_DEVICE | DEV_MASK_INTERNAL_DEVICE,
    "PNP0002",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0003",          DEV_CAP_PIC_DEVICE | DEV_MASK_INTERNAL_DEVICE,
    "PNP0004",          DEV_CAP_PIC_DEVICE | DEV_MASK_INTERNAL_DEVICE,
    "PNP0100",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0101",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0102",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0200",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0201",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0202",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0500",          DEV_CAP_SERIAL,
    "PNP0501",          DEV_CAP_SERIAL,
    "PNP0800",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0A00",          DEV_CAP_ISA,
    "PNP0A03",          DEV_CAP_PCI,
    "PNP0A05",          DEV_MASK_INTERNAL_BUS | DEV_CAP_EIO,
    "PNP0A06",          DEV_MASK_INTERNAL_BUS | DEV_CAP_EIO,
    "PNP0B00",          DEV_MASK_INTERNAL_DEVICE |
                        DEV_CAP_NO_DISABLE_WAKE | DEV_CAP_RAW, // Clock --- need start device
    "PNP0C00",          DEV_MASK_INTERNAL_DEVICE | DEV_CAP_NEVER_SHOW_IN_UI,
    "PNP0C01",          DEV_MASK_INTERNAL_DEVICE | DEV_CAP_NEVER_SHOW_IN_UI,
    "PNP0C02",          DEV_MASK_INTERNAL_DEVICE | DEV_CAP_NEVER_SHOW_IN_UI,
    "PNP0C04",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0C05",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0C09",          DEV_CAP_NO_STOP,
    "PNP0C0B",          DEV_CAP_RAW | DEV_MASK_INTERNAL_DEVICE,                    // Fan
    "PNP0C0C",          DEV_CAP_RAW | DEV_CAP_BUTTON |
                        DEV_CAP_NO_DISABLE_WAKE | DEV_MASK_INTERNAL_DEVICE,   // Power
    "PNP0C0D",          DEV_CAP_RAW | DEV_CAP_BUTTON |
                        DEV_CAP_NO_DISABLE_WAKE | DEV_MASK_INTERNAL_DEVICE,   // Lid
    "PNP0C0E",          DEV_CAP_RAW | DEV_CAP_BUTTON |
                        DEV_CAP_NO_DISABLE_WAKE | DEV_MASK_INTERNAL_DEVICE,   // Sleep
    "PNP0C0F",          DEV_CAP_NO_FILTER | DEV_TYPE_NEVER_PRESENT | DEV_CAP_LINK_NODE,
    "PNP0C80",          DEV_CAP_NO_REMOVE_OR_EJECT,
    "PNP8294",          DEV_CAP_SERIAL,                                            // HACK for Seattle ][
    "TOS6200",          DEV_CAP_RAW,                                               // As requested by Toshiba
//    "TOS700C",          DEV_CAP_START_IN_D3,
    NULL,               0
};

//
// For IRQ Arbiter
//
BOOLEAN             PciInterfacesInstantiated = FALSE;
BOOLEAN             AcpiInterruptRoutingFailed = FALSE;
ACPI_ARBITER        AcpiArbiter;

//
// This determines if we are allowed to process PowerIrps
//
BOOLEAN             AcpiSystemInitialized;

//
// Remember the sleep state that the system was last in
//
SYSTEM_POWER_STATE  AcpiMostRecentSleepState = PowerSystemWorking;

//
// This is the name of the Fixed Button device
//
UCHAR ACPIFixedButtonId[] = "ACPI\\FixedButton";
UCHAR ACPIThermalZoneId[] = "ACPI\\ThermalZone";
UCHAR AcpiProcessorCompatId[]   = "ACPI\\Processor";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\debug.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _DEBUG_H_
#define _DEBUG_H_

    //
    // These are the file indexes for when someone calls ACPIInternalError
    // They merely specifiy which file and which line of code the driver
    // died in. They are a strict result of inconsistencies in the ACPI
    // driver, which happen is someone really confuses it.
    //
    #define ACPI_DISPATCH           0x0001
    #define ACPI_CALLBACK           0x0002
    #define ACPI_AMLISUPP           0x0003
    #define ACPI_DETECT             0x0004
    #define ACPI_IRQARB             0x0005
    #define ACPI_GET                0x0006
    #define ACPI_THERMAL            0x0007
    #define ACPI_RANGESUP           0x0008
    #define ACPI_INTERNAL           0x0009
    #define ACPI_BUS                0x000A
    #define ACPI_SYSPOWER           0x000B
    #define ACPI_DEVPOWER           0x000C
    #define ACPI_ROOT               0x000D
    #define ACPI_WORKER             0x000E
    #define ACPI_CANNOT_HANDLE_LOW_MEMORY   0x000F  // BUGBUG - code that calls this should be fixed and this code then removed.

    #define ACPIInternalError(a) _ACPIInternalError( (a << 16) | __LINE__ )


    VOID
    _ACPIInternalError(
        IN  ULONG   Bugcode
        );

    #if DBG
        VOID
        ACPIDebugResourceDescriptor(
            IN  PIO_RESOURCE_DESCRIPTOR Descriptor,
            IN  ULONG                   ListCount,
            IN  ULONG                   DescCount
            );

        VOID
        ACPIDebugResourceList(
            IN  PIO_RESOURCE_LIST       List,
            IN  ULONG                   Count
            );

        VOID
        ACPIDebugResourceRequirementsList(
            IN  PIO_RESOURCE_REQUIREMENTS_LIST  List,
            IN  PDEVICE_EXTENSION               DeviceExtension
            );

        VOID
        ACPIDebugCmResourceList(
            IN  PCM_RESOURCE_LIST   List,
            IN  PDEVICE_EXTENSION   DeviceExtension
            );

        PCCHAR
        ACPIDebugGetIrpText(
            UCHAR MajorFunction,
            UCHAR MinorFunction
            );

        VOID
        ACPIDebugDeviceCapabilities(
            IN  PDEVICE_EXTENSION       DeviceExtension,
            IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
            IN  PUCHAR                  Message
            );

        VOID
        ACPIDebugPowerCapabilities(
            IN  PDEVICE_EXTENSION       DeviceExtension,
            IN  PUCHAR                  Message
            );

    #endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\dat.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dat.h

Abstract:

    This module contains the detector for the NT driver.
    This module makes extensive calls into the AMLI library

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _DAT_H_
#define _DAT_H_

extern IRP_DISPATCH_TABLE           AcpiBusFilterIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiDockPdoIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiEIOBusIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiFanIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiFdoIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiFilterIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiFixedButtonIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiGenericBusIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiLidIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiPdoIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiPowerButtonIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiProcessorIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiRawDeviceIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiRealTimeClockIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiSleepButtonIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiSurpriseRemovedFilterIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiSurpriseRemovedPdoIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiThermalZoneIrpDispatch;

extern INTERNAL_DEVICE_TABLE        AcpiInternalDeviceTable[];
extern INTERNAL_DEVICE_FLAG_TABLE   AcpiInternalDeviceFlagTable[];

extern BOOLEAN                      AcpiSystemInitialized;
extern SYSTEM_POWER_STATE           AcpiMostRecentSleepState;
extern UCHAR                        ACPIFixedButtonId[];
extern UCHAR                        ACPIThermalZoneId[];
extern UCHAR                        AcpiProcessorCompatId[];

#endif _DAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\debug.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

#if DBG
    #ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, ACPIDebugResourceDescriptor)
        #pragma alloc_text(PAGE, ACPIDebugResourceList)
        #pragma alloc_text(PAGE, ACPIDebugResourceRequirementsList)
        #pragma alloc_text(PAGE, ACPIDebugCmResourceList)
    #endif

    #define ACPI_DEBUG_BUFFER_SIZE   256

    PCCHAR  ACPIDispatchPnpTableNames[ACPIDispatchPnpTableSize] = {
            "IRP_MN_START_DEVICE",
            "IRP_MN_QUERY_REMOVE_DEVICE",
            "IRP_MN_REMOVE_DEVICE",
            "IRP_MN_CANCEL_REMOVE_DEVICE",
            "IRP_MN_STOP_DEVICE",
            "IRP_MN_QUERY_STOP_DEVICE",
            "IRP_MN_CANCEL_STOP_DEVICE",
            "IRP_MN_QUERY_DEVICE_RELATIONS",
            "IRP_MN_QUERY_INTERFACE",
            "IRP_MN_QUERY_CAPABILITIES",
            "IRP_MN_QUERY_RESOURCES",
            "IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
            "IRP_MN_QUERY_DEVICE_TEXT",
            "IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
            "INVALID MINOR IRP CODE",
            "IRP_MN_READ_CONFIG",
            "IRP_MN_WRITE_CONFIG",
            "IRP_MN_EJECT",
            "IRP_MN_SET_LOCK",
            "IRP_MN_QUERY_ID",
            "IRP_MN_QUERY_PNP_DEVICE_STATE",
            "IRP_MN_QUERY_BUS_INFORMATION",
            "IRP_MN_DEVICE_USAGE_NOTIFICATION",
            "IRP_MN_SURPRISE_REMOVAL",
            "UNKNOWN PNP MINOR CODE"
        };

    PCCHAR  ACPIDispatchPowerTableNames[ACPIDispatchPowerTableSize] = {
            "IRP_MN_WAIT_WAKE",
            "IRP_MN_POWER_SEQUENCE",
            "IRP_MN_SET_POWER",
            "IRP_MN_QUERY_POWER",
            "UNKNOWN POWER MINOR CODE"
        };

    PCCHAR  ACPIDispatchUnknownTableName[1] = {
            "IRP_MN_????"
        };
#endif

VOID
_ACPIInternalError(
    IN  ULONG   Bugcode
    )
{
    KeBugCheckEx (ACPI_DRIVER_INTERNAL, 0x1, Bugcode, 0, 0);
}

#if DBG
VOID
ACPIDebugPrint(
    ULONG   DebugPrintLevel,
    PCCHAR  DebugMessage,
    ...
    )
/*++

Routine Description:

    This is the debug print routine for the NT side of things. This is
    here because we don't want to use the 'shared' ACPIPrint() function
    since we can't control it.

Arguments:

    DebugPrintLevel - The bit mask that when anded with the debuglevel, must
                        equal itself
    DebugMessage    - The string to feed through vsprintf

Return Value:

    None

--*/
{
    va_list ap;

    //
    // Get the variable arguments
    //
    va_start( ap, DebugMessage );

    //
    // Call the kernel function to print the message
    //
    vDbgPrintEx( DPFLTR_ACPI_ID, DebugPrintLevel, DebugMessage, ap );

    //
    // We are done with the varargs
    //
    va_end( ap );
}

VOID
ACPIDebugDevicePrint(
    ULONG   DebugPrintLevel,
    PVOID   DebugExtension,
    PCCHAR  DebugMessage,
    ...
    )
/*++

Routine Description:

    This is the debug print routine for the NT side of things. This routine
    is here to handle the case where we are printing information that is
    associated with a device extension.

Arguments:

    DebugPrintLevel - The big mask that when and'ed with the debug level, must
                        equal itself
    DeviceExtension - The device associated with the message
    DebugMessage    - The string to feed through vsprintf

Return Value:

    NTSTATUS

---*/
{
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) DebugExtension;
    va_list ap;

    //
    // Get the variable arguments
    //
    va_start( ap, DebugMessage );

    //
    // What kind of device extension are we looking at?
    //
    if (deviceExtension->Flags & DEV_PROP_HID) {

        //
        // Now that we have a _HID, do we also have a _UID?
        //
        if (deviceExtension->Flags & DEV_PROP_UID) {

            DbgPrintEx(
                DPFLTR_ACPI_ID,
                DebugPrintLevel,
                "%p %s-%s ",
                deviceExtension,
                deviceExtension->DeviceID,
                deviceExtension->InstanceID
                );

        } else {

            DbgPrintEx(
                DPFLTR_ACPI_ID,
                DebugPrintLevel,
                "%p %s ",
                deviceExtension,
                deviceExtension->DeviceID
                );

        }

    } else if (deviceExtension->Flags & DEV_PROP_ADDRESS) {

        DbgPrintEx(
            DPFLTR_ACPI_ID,
            DebugPrintLevel,
            "%p %x ",
            deviceExtension,
            deviceExtension->Address
            );

    } else {

        DbgPrintEx(
            DPFLTR_ACPI_ID,
            DebugPrintLevel,
            "%p ",
            deviceExtension
            );

    }

    //
    // Call the kernel function to print the message
    //
    vDbgPrintEx( DPFLTR_ACPI_ID, DebugPrintLevel, DebugMessage, ap );

    //
    // We are done with the varargs
    //
    va_end( ap );
}

PCCHAR
ACPIDebugGetIrpText(
   UCHAR MajorFunction,
   UCHAR MinorFunction
   )
/*++

Routine Description:

    This function returns a const pointer to the text string appropriate for
    the passed in major and minor IRP.

Arguments:

    MajorFunction
    MinorFunction

Return Value:

    const pointer to descriptive IRP text.

--*/
{
    ULONG index ;
    PCCHAR *minorTable ;

    switch(MajorFunction) {

        case IRP_MJ_PNP:
           index = ACPIDispatchPnpTableSize - 1;
           minorTable = ACPIDispatchPnpTableNames ;
           break;

        case IRP_MJ_POWER:
           index = ACPIDispatchPowerTableSize - 1;
           minorTable = ACPIDispatchPowerTableNames ;
           break;

        default:
           index = 0 ;
           minorTable = ACPIDispatchUnknownTableName ;
           break;
    }

    if (MinorFunction < index) {

        index = MinorFunction;

    }

    return minorTable[index];
}

VOID
ACPIDebugResourceDescriptor(
    IN  PIO_RESOURCE_DESCRIPTOR Descriptor,
    IN  ULONG                   ListCount,
    IN  ULONG                   DescCount
    )
/*++

Routine Description:

    This function dumps the contents of a single resource descriptor.

Arguments:

    Descriptor  - What to dump
    ListCount   - The number of the current list
    DescCount   - The number of the current descriptor

--*/
{
    PAGED_CODE();
    ASSERT( Descriptor != NULL );

    //
    // Dump the appropriate info
    //
    switch (Descriptor->Type) {
        case CmResourceTypePort:
            ACPIPrint( (
                ACPI_PRINT_RESOURCES_1,
                "[%2d] [%2d] %-9s  MininumAddress = %#08lx  MaximumAddress = %#08lx\n"
                "                     Length         = %#08lx  Alignment      = %#08lx\n",
                ListCount,
                DescCount,
                "Port",
                Descriptor->u.Port.MinimumAddress.LowPart,
                Descriptor->u.Port.MaximumAddress.LowPart,
                Descriptor->u.Port.Length,
                Descriptor->u.Port.Alignment
                ) );
            break;
        case CmResourceTypeMemory:
            ACPIPrint( (
                ACPI_PRINT_RESOURCES_1,
                "[%2d] [%2d] %-9s  MinimumAddress = %#08lx  MaximumAddress = %#08lx\n"
                "                     Length         = %#08lx  Alignment      = %#08lx\n",
                ListCount,
                DescCount,
                "Memory",
                Descriptor->u.Memory.MinimumAddress.LowPart,
                Descriptor->u.Memory.MaximumAddress.LowPart,
                Descriptor->u.Memory.Length,
                Descriptor->u.Memory.Alignment
                ) );
            break;
        case CmResourceTypeInterrupt:
            ACPIPrint( (
                ACPI_PRINT_RESOURCES_1,
                "[%2d] [%2d] %-9s  MinimumVector  = %#08lx  MaximumVector  = %#08lx\n",
                ListCount,
                DescCount,
                "Interrupt",
                Descriptor->u.Interrupt.MinimumVector,
                Descriptor->u.Interrupt.MaximumVector
                ) );
            break;
        case CmResourceTypeDma:
            ACPIPrint( (
                ACPI_PRINT_RESOURCES_1,
                "[%2d] [%2d] %-9s  MinimumChannel = %#08lx  MaximumChannel = %#08lx\n",
                ListCount,
                DescCount,
                "Dma",
                Descriptor->u.Dma.MinimumChannel,
                Descriptor->u.Dma.MaximumChannel
                ) );
            break;
        default:
            ACPIPrint( (
                ACPI_PRINT_RESOURCES_1,
                "[%2d] [%2d] Type = (%d)\n",
                ListCount,
                DescCount,
                Descriptor->Type
                ) );

    } // switch

    //
    // Dump the common info
    //
    ACPIPrint( (
        ACPI_PRINT_RESOURCES_1,
        "                     Option,Share   = %#04lx%#04lx  Flags          = %#08lx\n",
        ListCount,
        DescCount,
        Descriptor->Option,
        Descriptor->ShareDisposition
        ) );

} // for

VOID
ACPIDebugResourceList(
    IN  PIO_RESOURCE_LIST       List,
    IN  ULONG                   Count
    )
/*++

Routine Description:

    This functions displays the contents of a single resource list, so that it
    can be checked by a human

Arguments:

    List    - List to dump
    Count   - The List number (for visual reference)

Return Value:

    None

--*/
{
    ULONG   i;

    PAGED_CODE();

    ASSERT( List != NULL );

    ACPIPrint( (
        ACPI_PRINT_RESOURCES_1,
        "[%2d]      %#04x       Version        = %#08lx  Revision       = %#08lx\n",
        Count,
        List->Count,
        List->Version,
        List->Revision
        ) );

    for (i = 0; i < List->Count; i++ ) {

        //
        // Print the info on the current element
        //
        ACPIDebugResourceDescriptor( &(List->Descriptors[i]), Count, i );

    }

}

VOID
ACPIDebugResourceRequirementsList(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST  List,
    IN  PDEVICE_EXTENSION               DeviceExtension
    )
/*++

Routine Description:

    This function displays a resource list in a method that can be checked
    for accuracy when the driver is loading up

Arguments:

    List    - The list to dump
    Object  - NameSpace object associated with this list

Return Value:

    None

--*/
{
    PUCHAR                  buffer;
    PIO_RESOURCE_LIST       list;
    ULONG                   i;
    ULONG                   size;

    PAGED_CODE();

    ACPIDevPrint( (
        ACPI_PRINT_RESOURCES_1,
        DeviceExtension,
        "IoResourceRequirementsList @ %x\n",
        List
        ) );

    if (List == NULL) {

        return;

    }

    ACPIPrint( (
        ACPI_PRINT_RESOURCES_1,
        "%x size: %xb alternatives: %x bus type: %x bus number %x\n",
        List,
        List->ListSize,
        List->AlternativeLists,
        List->InterfaceType,
        List->BusNumber
        ) );

    //
    // Point to the first list
    //
    list = &(List->List[0]);
    buffer = (PUCHAR) list;
    for (i = 0; i < List->AlternativeLists && buffer < ( (PUCHAR)List + List->ListSize ); i++) {

        //
        // Dump the current list
        //
        ACPIDebugResourceList( list, i );

        //
        // Determine the size of the list, and find the next one
        //
        size = sizeof(IO_RESOURCE_LIST) + (list->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR);
        buffer += size;

        //
        // This should be pointing at a list
        //
        list = (PIO_RESOURCE_LIST) buffer;

    }

}

VOID
ACPIDebugCmResourceList(
    IN  PCM_RESOURCE_LIST   List,
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This function displays a resource list in a method that can be checked
    for accuracy when the driver is loading up

Arguments:

    List    - The list to dump
    Device  - The associated device extension

Return Value:

    None

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    fullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partDesc;
    PUCHAR                          buffer;
    ULONG                           i;
    ULONG                           j;
    ULONG                           size;

    PAGED_CODE();

    ACPIDevPrint( (
        ACPI_PRINT_RESOURCES_1,
        DeviceExtension,
        "CmResourceList @ %x\n",
        List
        ) );

    if (List == NULL) {

        return;

    }
    if (List->Count == 0) {

        ACPIDevPrint( (
            ACPI_PRINT_RESOURCES_1,
            DeviceExtension,
            "There are no full resource descriptors in the list\n"
            ) );
        return;

    }

    //
    // Start to walk this data structure
    //
    fullDesc = &(List->List[0]);
    buffer = (PUCHAR) fullDesc;

    for (i = 0; i < List->Count; i++) {

        //
        // How long is the current list
        //
        size = sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
            (fullDesc->PartialResourceList.Count - 1) *
            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

        //
        // Point the buffer there
        //
        buffer += size;

        //
        // Dump the information about the current list
        //
        ACPIPrint( (
            ACPI_PRINT_RESOURCES_1,
            "[%2d] BusNumber = %#04x  Interface = %#04x\n"
            "[%2d]     Count = %#04x    Version = %#04x Revision = %#04x\n",
            i,
            fullDesc->BusNumber,
            fullDesc->InterfaceType,
            i,
            fullDesc->PartialResourceList.Count,
            fullDesc->PartialResourceList.Version,
            fullDesc->PartialResourceList.Revision
            ) );

        //
        // Walk this list
        //
        for (j = 0; j < fullDesc->PartialResourceList.Count; j++) {

            //
            // Current item
            //
            partDesc = &(fullDesc->PartialResourceList.PartialDescriptors[j]);

            //
            // Dump Principal Information...
            //
            switch (partDesc->Type) {
                case CmResourceTypePort:

                    ACPIPrint( (
                        ACPI_PRINT_RESOURCES_1,
                        "[%2d] [%2d] %12s  Start: %#08lx  Length: %#08lx\n",
                        i,
                        j,
                        "Port",
                        partDesc->u.Port.Start.LowPart,
                        partDesc->u.Port.Length
                        ) );
                    break;

                case CmResourceTypeInterrupt:

                    ACPIPrint( (
                        ACPI_PRINT_RESOURCES_1,
                        "[%2d] [%2d] %12s  Level: %#02x  Vector: %#02x  Affinity: %#08lx\n",
                        i,
                        j,
                        "Interrupt",
                        partDesc->u.Interrupt.Level,
                        partDesc->u.Interrupt.Vector,
                        partDesc->u.Interrupt.Affinity
                        ) );
                    break;

                case CmResourceTypeMemory:

                    ACPIPrint( (
                        ACPI_PRINT_RESOURCES_1,
                        "[%2d] [%2d] %12s  Start: %#08lx  Length: %#08lx\n",
                        i,
                        j,
                        "Memory",
                        partDesc->u.Memory.Start.LowPart,
                        partDesc->u.Memory.Length
                        ) );
                    break;

                case CmResourceTypeDma:

                    ACPIPrint( (
                        ACPI_PRINT_RESOURCES_1,
                        "[%2d] [%2d] %12s  Channel: %#02x  Port: %#02x  Reserved: %#02x\n",
                        i,
                        j,
                        "Dma",
                        partDesc->u.Dma.Channel,
                        partDesc->u.Dma.Port,
                        partDesc->u.Dma.Reserved1
                        ) );
                    break;

                default:

                    ACPIPrint( (
                        ACPI_PRINT_RESOURCES_1,
                        "[%2d] [%2d] Type: %2d   1: %#08lx  2: %#08lx  3: %#08lx\n",
                        i,
                        j,
                        partDesc->Type,
                        partDesc->u.DeviceSpecificData.DataSize,
                        partDesc->u.DeviceSpecificData.Reserved1,
                        partDesc->u.DeviceSpecificData.Reserved2
                        ) );
                    break;

            }

            //
            // Dump ancillary info
            //
            ACPIPrint( (
                ACPI_PRINT_RESOURCES_1,
                "                        Flags: %#08lx  Share: %#08lx\n",
                partDesc->Flags,
                partDesc->ShareDisposition
                ) );


        }

        //
        // Grab new list
        //
        fullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) buffer;

    }

}

VOID
ACPIDebugDeviceCapabilities(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
    IN  PUCHAR                  Message
    )
/*++

Routine Description:

    This will display the device capabilities in an interesting format

Arguments:

    DeviceExtension     The device whose' capabilities we are dumping
    DeviceCapabilites   The capabilities that we are interested in
    Message             Message to print

Return Value:

    None

--*/
{
    SYSTEM_POWER_STATE  index;

    ACPIDevPrint( (
        ACPI_PRINT_SXD,
        DeviceExtension,
        " - %s - Capabilities @ %08lx\n",
        Message,
        DeviceCapabilities
        ) );
    ACPIDevPrint( (
        ACPI_PRINT_SXD,
        DeviceExtension,
        " -"
        ) );

    for (index = PowerSystemWorking; index < PowerSystemMaximum; index++) {

        if (DeviceCapabilities->DeviceState[index] == PowerSystemUnspecified) {

            ACPIPrint( (
                ACPI_PRINT_SXD,
                " S%d -> None",
                (index - 1)
                ) );

        } else {

            ACPIPrint( (
                ACPI_PRINT_SXD,
                " S%d -> D%x",
                (index - 1),
                (DeviceCapabilities->DeviceState[index] - 1)
                ) );

        }

    }
    ACPIPrint( (
        ACPI_PRINT_SXD,
        "\n"
        ) );
    ACPIDevPrint( (
        ACPI_PRINT_SXD,
        DeviceExtension,
        " -"
        ) );

    if (DeviceCapabilities->SystemWake == PowerSystemUnspecified) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " SystemWake = None"
            ) );

    } else {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " SystemWake = S%d",
            (DeviceCapabilities->SystemWake - 1)
            ) );

    }

    if (DeviceCapabilities->DeviceWake == PowerDeviceUnspecified) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceWake = None"
            ) );

    } else {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceWake = D%d",
            (DeviceCapabilities->DeviceWake - 1)
            ) );

    }

    if (DeviceCapabilities->DeviceD1) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceD1"
            ) );

    }
    if (DeviceCapabilities->DeviceD2) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceD2"
            ) );

    }
    if (DeviceCapabilities->WakeFromD0) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD0"
            ) );

    }
    if (DeviceCapabilities->WakeFromD1) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD1"
            ) );

    }
    if (DeviceCapabilities->WakeFromD2) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD2"
            ) );

    }
    if (DeviceCapabilities->WakeFromD3) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD3"
            ) );

    }

    ACPIPrint( (
        ACPI_PRINT_SXD,
        "\n"
        ) );
}

VOID
ACPIDebugPowerCapabilities(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PUCHAR                  Message
    )
/*++

Routine Description:

    This will display the device capabilities in an interesting format

Arguments:

    DeviceExtension     The device whose' capabilities we are dumping
    Message             Identify where capabilities are fron

Return Value:

--*/
{
    PACPI_POWER_INFO    powerInfo = &(DeviceExtension->PowerInfo);
    SYSTEM_POWER_STATE  index;

    ACPIDevPrint( (
        ACPI_PRINT_SXD,
        DeviceExtension,
        " - %s - Internal Capabilities\n",
        Message
        ) );
    ACPIDevPrint( (
        ACPI_PRINT_SXD,
        DeviceExtension,
        " -"
        ) );


    for (index = PowerSystemWorking; index < PowerSystemMaximum; index++) {

        if (powerInfo->DevicePowerMatrix[index] == PowerSystemUnspecified) {

            ACPIPrint( (
                ACPI_PRINT_SXD,
                " S%d -> None",
                (index - 1)
                ) );

        } else {

            ACPIPrint( (
                ACPI_PRINT_SXD,
                " S%d -> D%x",
                (index - 1),
                (powerInfo->DevicePowerMatrix[index] - 1)
                ) );

        }

    }

    ACPIPrint( (
        ACPI_PRINT_SXD,
        "\n"
        ) );
    ACPIDevPrint( (
        ACPI_PRINT_SXD,
        DeviceExtension,
        " -"
        ) );
    if (powerInfo->SystemWakeLevel == PowerSystemUnspecified) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " SystemWake = None"
            ) );

    } else {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " SystemWake = S%d",
            (powerInfo->SystemWakeLevel - 1)
            ) );

    }

    if (powerInfo->DeviceWakeLevel == PowerDeviceUnspecified) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceWake = None"
            ) );

    } else {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceWake = D%d",
            (powerInfo->DeviceWakeLevel - 1)
            ) );

    }
    if (powerInfo->SupportDeviceD1) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceD1"
            ) );

    }
    if (powerInfo->SupportDeviceD2) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceD2"
            ) );

    }
    if (powerInfo->SupportWakeFromD0) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD0"
            ) );

    }
    if (powerInfo->SupportWakeFromD1) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD1"
            ) );

    }
    if (powerInfo->SupportWakeFromD2) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD2"
            ) );

    }
    if (powerInfo->SupportWakeFromD3) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD3"
            ) );

    }

    ACPIPrint( (
        ACPI_PRINT_SXD,
        "\n"
        ) );

}

VOID
ACPIDebugThermalPrint(
    ULONG       DebugPrintLevel,
    PVOID       DebugExtension,
    ULONGLONG   DebugTime,
    PCCHAR      DebugMessage,
    ...
    )
/*++

Routine Description:

    This is the debug print routine for the NT side of things. This routine
    is here to handle the case where we are printing information that is
    associated with a device extension.

Arguments:

    DebugPrintLevel - The big mask that when and'ed with the debug level, must
                        equal itself
    DeviceExtension - The device associated with the message
    DebugTime       - The time that event occured
    DebugMessage    - The string to feed through vsprintf

Return Value:

    NTSTATUS

---*/
{
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) DebugExtension;
    LARGE_INTEGER       curTime;
    TIME_FIELDS         exCurTime;
    va_list             ap;

    va_start( ap, DebugMessage );

    //
    // What kind of device extension are we looking at?
    //
    if (deviceExtension->Flags & DEV_PROP_HID) {

        //
        // Now that we have a _HID, do we also have a _UID?
        //
        if (deviceExtension->Flags & DEV_PROP_UID) {

            DbgPrintEx(
                DPFLTR_ACPI_ID,
                DebugPrintLevel,
                "%p %s-%s ",
                deviceExtension,
                deviceExtension->DeviceID,
                deviceExtension->InstanceID
                );

        } else {

            DbgPrintEx(
                DPFLTR_ACPI_ID,
                DebugPrintLevel,
                "%p %s ",
                deviceExtension,
                deviceExtension->DeviceID
                );

        }

    } else if (deviceExtension->Flags & DEV_PROP_ADDRESS) {

        DbgPrintEx(
            DPFLTR_ACPI_ID,
            DebugPrintLevel,
            "%p %x ",
            deviceExtension,
            deviceExtension->Address
            );

    } else {

        DbgPrintEx(
            DPFLTR_ACPI_ID,
            DebugPrintLevel,
            "%p ",
            deviceExtension
            );

    }

    //
    // Print the time string
    //
    curTime.QuadPart = DebugTime;
    RtlTimeToTimeFields( &curTime, &exCurTime );
    DbgPrintEx(
        DPFLTR_ACPI_ID,
        DebugPrintLevel,
        "%d:%02d:%02d.%03d ",
        exCurTime.Hour,
        exCurTime.Minute,
        exCurTime.Second,
        exCurTime.Milliseconds
        );

    //
    // Call the kernel function to print the message
    //
    vDbgPrintEx( DPFLTR_ACPI_ID, DebugPrintLevel, DebugMessage, ap );

    //
    // We are done with the varargs
    //
    va_end( ap );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\detect.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    detect.h

Abstract:

    This is the header for the detection part of the ACPI driver

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _DETECT_H_
#define _DETECT_H_

    #define ACPI_MAX_REMOVED_EXTENSIONS 0x20

    //
    // Exports from detect.c
    //
    extern  PDEVICE_EXTENSION       RootDeviceExtension;
    extern  NPAGED_LOOKASIDE_LIST   DeviceExtensionLookAsideList;
    extern  PDEVICE_EXTENSION       AcpiSurpriseRemovedDeviceExtensions[];
    extern  ULONG                   AcpiSurpriseRemovedIndex;
    extern  KSPIN_LOCK              AcpiDeviceTreeLock;
    extern  ULONG                   AcpiSupportedSystemStates;
    extern  ULONG                   AcpiOverrideAttributes;
    extern  UNICODE_STRING          AcpiRegistryPath;
    extern  ANSI_STRING             AcpiProcessorString;

    NTSTATUS
    ACPIDetectCouldExtensionBeInRelation(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PDEVICE_RELATIONS   DeviceRelations,
        IN  BOOLEAN             RequireADR,
        IN  BOOLEAN             RequireHID,
        OUT PDEVICE_OBJECT      *PdoObject
        );

    NTSTATUS
    ACPIDetectDockDevices(
        IN     PDEVICE_EXTENSION   DeviceExtension,
        IN OUT PDEVICE_RELATIONS   *DeviceRelations
        );

    VOID
    ACPIDetectDuplicateHID(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIDetectEjectDevices(
        IN     PDEVICE_EXTENSION   deviceExtension,
        IN OUT PDEVICE_RELATIONS   *DeviceRelations,
        IN     PDEVICE_EXTENSION   AdditionalExtension OPTIONAL
        );

    NTSTATUS
    ACPIDetectFilterDevices(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PDEVICE_RELATIONS   DeviceRelations
        );

    NTSTATUS
    ACPIDetectFilterMatch(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PDEVICE_RELATIONS   DeviceRelations,
        OUT PDEVICE_OBJECT      *PdoObject
        );

    NTSTATUS
    ACPIDetectPdoDevices(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PDEVICE_RELATIONS   *DeviceRelations
        );

    BOOLEAN
    ACPIDetectPdoMatch(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PDEVICE_RELATIONS   DeviceRelations
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\devpower.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dpower.c

Abstract:

    This handles requests to have devices set themselves at specific power
    levels

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    09-Oct-96 Initial Revision
    20-Nov-96 Interrupt Vector support
    31-Mar-97 Cleanup
    17-Sep-97 Major Rewrite
    06-Jan-98 Cleaned Up the SST code

--*/

#include "pch.h"

//
// This is the variable that indicates wether or not the DPC is running
//
BOOLEAN                 AcpiPowerDpcRunning;

//
// This is the variable that indicates wether or not the DPC has completed
// real work
//
BOOLEAN                 AcpiPowerWorkDone;

//
// This is the lock that is used to protect certain power resources and
// lists
//
KSPIN_LOCK              AcpiPowerLock;

//
// This is the lock that is used *only* within this module to queue requests
// onto the Phase0 list *and* to modify the state of some global variables
//
KSPIN_LOCK              AcpiPowerQueueLock;

//
// This is the list that the build dpc queue power requests onto until it
// has finished building all of the device extensions. Once the extensions
// are built, the contents of the list are moved onto the AcpiPowerQueueList
//
LIST_ENTRY              AcpiPowerDelayedQueueList;

//
// This is the only list that routines outside of the DPC can queue reqests
// onto
//
LIST_ENTRY              AcpiPowerQueueList;

//
// This is the list where we run the _STA to determine if the resources that
// we care about are still present
//
LIST_ENTRY              AcpiPowerPhase0List;

//
// This is the list for the phase where we run PS1-PS3 and figure out
// which PowerResources need to be in the 'on' state
//
LIST_ENTRY              AcpiPowerPhase1List;

//
// This is the list for when we process the System Requests. It turns out
// that we have to let all of the DeviceRequests through Phase1 before
// we can figure out which devices are on the hibernate path, and which
// arent
//
LIST_ENTRY              AcpiPowerPhase2List;

//
// This is the list for the phase where we run ON or OFF
//
LIST_ENTRY              AcpiPowerPhase3List;

//
// This is the list for the phase where we check to see if ON/OFF ran okay
//
LIST_ENTRY              AcpiPowerPhase4List;

//
// This is the list for the phase where we run PSW or PSW
//
LIST_ENTRY              AcpiPowerPhase5List;

//
// This is the list for the phase where we have WaitWake Irps pending
//
LIST_ENTRY              AcpiPowerWaitWakeList;

//
// This is the list for the synchronize power requests
//
LIST_ENTRY              AcpiPowerSynchronizeList;

//
// This is the list of Power Device Nodes objects
//
LIST_ENTRY              AcpiPowerNodeList;

//
// This is what we use to queue up the DPC
//
KDPC                    AcpiPowerDpc;

//
// This is where we remember if the system is in steady state or if it is going
// into standby
//
BOOLEAN                 AcpiPowerLeavingS0;

//
// This is the list that we use to pre-allocate storage for requests
//
NPAGED_LOOKASIDE_LIST   RequestLookAsideList;

//
// This is the list that we use to pre-allocate storage for object data
//
NPAGED_LOOKASIDE_LIST   ObjectDataLookAsideList;

//
// This table is used to map DevicePowerStates from the ACPI format to some
// thing the system can handle
//
DEVICE_POWER_STATE      DevicePowerStateTranslation[DEVICE_POWER_MAXIMUM] = {
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3
};

//
// This table is used to map SystemPowerStates from the ACPI format to some
// thing the system can handle
//
SYSTEM_POWER_STATE      SystemPowerStateTranslation[SYSTEM_POWER_MAXIMUM] = {
    PowerSystemWorking,
    PowerSystemSleeping1,
    PowerSystemSleeping2,
    PowerSystemSleeping3,
    PowerSystemHibernate,
    PowerSystemShutdown
};

//
// This table is used to map SystemPowerStates from the NT format to the
// ACPI format
//
ULONG                   AcpiSystemStateTranslation[PowerSystemMaximum] = {
    -1, // PowerSystemUnspecified
    0,  // PowerSystemWorking
    1,  // PowerSystemSleepingS1
    2,  // PowerSystemSleepingS2
    3,  // PowerSystemSleepingS3
    4,  // PowerSystemHibernate
    5   // PowerSystemShutdown
};

//
// This is the table used to map functions in the Phase0 case WORK_DONE_STEP_0
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase0Table1[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase0DeviceSubPhase1,
    ACPIDevicePowerProcessPhase0SystemSubPhase1,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase0 case WORK_DONE_STEP_1
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase0Table2[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase0DeviceSubPhase2,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};


//
// This is the dispatch table for Phase 0
//
PACPI_POWER_FUNCTION   *AcpiDevicePowerProcessPhase0Dispatch[] = {
    NULL,
    NULL,
    NULL,
    AcpiDevicePowerProcessPhase0Table1,
    AcpiDevicePowerProcessPhase0Table2
};

//
// This is the table used to map functions in the Phase1 case WORK_DONE_STEP_0
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase1Table1[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase1DeviceSubPhase1,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase1 case WORK_DONE_STEP_1
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase1Table2[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase1DeviceSubPhase2,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase1 case WORK_DONE_STEP_2
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase1Table3[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase1DeviceSubPhase3,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase1 case WORK_DONE_STEP_3
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase1Table4[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase1DeviceSubPhase4,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the dispatch table for Phase 1
//
PACPI_POWER_FUNCTION   *AcpiDevicePowerProcessPhase1Dispatch[] = {
    NULL,
    NULL,
    NULL,
    AcpiDevicePowerProcessPhase1Table1,
    AcpiDevicePowerProcessPhase1Table2,
    AcpiDevicePowerProcessPhase1Table3,
    AcpiDevicePowerProcessPhase1Table4
};

//
// This is the table used to map functions in the Phase2 case WORK_DONE_STEP_0
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase2Table1[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessPhase2SystemSubPhase1,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase2 case WORK_DONE_STEP_1
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase2Table2[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessPhase2SystemSubPhase2,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase3 case WORK_DONE_STEP_2
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase2Table3[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessPhase2SystemSubPhase3,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the dispatch table for Phase 2
//
PACPI_POWER_FUNCTION   *AcpiDevicePowerProcessPhase2Dispatch[] = {
    NULL,
    NULL,
    NULL,
    AcpiDevicePowerProcessPhase2Table1,
    AcpiDevicePowerProcessPhase2Table2,
    AcpiDevicePowerProcessPhase2Table3
};

//
// This is the table used to map functions in the Phase5 case WORK_DONE_STEP_0
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase5Table1[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase5DeviceSubPhase1,
    ACPIDevicePowerProcessPhase5SystemSubPhase1,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessPhase5WarmEjectSubPhase1,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase 5 case WORK_DONE_STEP_1
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase5Table2[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase5DeviceSubPhase2,
    ACPIDevicePowerProcessPhase5SystemSubPhase2,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessPhase5WarmEjectSubPhase2,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase 5 case WORK_DONE_STEP_2
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase5Table3[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase5DeviceSubPhase3,
    ACPIDevicePowerProcessPhase5SystemSubPhase3,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase 5 case WORK_DONE_STEP_3
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase5Table4[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase5DeviceSubPhase4,
    ACPIDevicePowerProcessPhase5SystemSubPhase4,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase 5 case WORK_DONE_STEP_4
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase5Table5[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase5DeviceSubPhase5,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase 5 case WORK_DONE_STEP_5
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase5Table6[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase5DeviceSubPhase6,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the dispatch table for Phase 5
//
PACPI_POWER_FUNCTION   *AcpiDevicePowerProcessPhase5Dispatch[] = {
    NULL,
    NULL,
    NULL,
    AcpiDevicePowerProcessPhase5Table1,
    AcpiDevicePowerProcessPhase5Table2,
    AcpiDevicePowerProcessPhase5Table3,
    AcpiDevicePowerProcessPhase5Table4,
    AcpiDevicePowerProcessPhase5Table5,
    AcpiDevicePowerProcessPhase5Table6
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIDevicePowerDetermineSupportedDeviceStates)
#endif


VOID
ACPIDeviceCancelWaitWakeIrp(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called when the system wants to cancel any pending
    WaitWake Irps

    Note: This routine is called at DPC level

Arguments:

    DeviceObject    - The target device for which the irp was sent to
    Irp             - The irp to be cancelled

Return Value:

    None

--*/
{
    NTSTATUS                status;
    PACPI_POWER_CALLBACK    callBack;
    PACPI_POWER_REQUEST     powerRequest;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PLIST_ENTRY              listEntry;
    PVOID                   context;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Let the world know that we are getting a cancel routine
    //
    ACPIDevPrint( (
        ACPI_PRINT_WARNING,
        deviceExtension,
        "(0x%08lx): ACPIDeviceCancelWaitWakeIrp - Start\n",
        Irp
        ) );

    //
    // We need to grab the lock so that we look for the irp in the lists
    // of pending WaitWake events. The cancel lock is already acquired
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Walk the list, looking for the Irp in question
    //
    listEntry = AcpiPowerWaitWakeList.Flink;
    while (listEntry != &AcpiPowerWaitWakeList) {

        //
        // Crack the record, and get ready to look at the next item
        //
        powerRequest = CONTAINING_RECORD(
            listEntry,
            ACPI_POWER_REQUEST,
            ListEntry
            );

        //
        // Does the power request match the current target? We also know that
        // for WaitWake requests, the context poitns to the Irp, so we make
        // sure that those match as well.
        //
        if (powerRequest->DeviceExtension != deviceExtension ||
            (PIRP) powerRequest->Context != Irp ) {

            listEntry = listEntry->Flink;
            continue;

        }

        ACPIDevPrint( (
            ACPI_PRINT_POWER,
            deviceExtension,
            "(0x%08lx): ACPIDeviceCancelWaitWakeIrp - Match 0x%08lx\n",
            Irp,
            powerRequest
            ) );

        //
        // Remove the request from the WaitWakeList
        //
        RemoveEntryList( listEntry );

        //
        // Rebuild the GPE mask
        //
        ACPIWakeRemoveDevicesAndUpdate( NULL, NULL );

        //
        // Grab whatever information we feel we need from the request
        //
        powerRequest->Status = STATUS_CANCELLED;
        callBack = powerRequest->CallBack;
        context = powerRequest->Context;

        //
        // Release the power spinlock and the Cancel spinlock
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
        IoReleaseCancelSpinLock( Irp->CancelIrql );

        //
        // Call the completion routine
        //
        (*callBack)(
            deviceExtension,
            Irp,
            STATUS_CANCELLED
            );

        //
        // Disable the device --- the CallBack *must* be invoked by this
        // routine, so we don't need to do it ourselves
        //
        status = ACPIWakeEnableDisableAsync(
            deviceExtension,
            FALSE,
            ACPIDeviceCancelWaitWakeIrpCallBack,
            powerRequest
            );

        //
        // We are done, so we can return now
        //
        return;

    } // while (listEntry != &AcpiPowerWaitWakeList)

    //
    // In this case, the irp isn't in our queue. Display and assert for
    // now
    //
    ACPIDevPrint( (
        ACPI_PRINT_WARNING,
        deviceExtension,
        "(0x%08lx): ACPIDeviceCancelWaitWakeIrp - Not Found!\n",
        Irp
        ) );

    //
    // We really shouldn't fall to this point,
    //
    ASSERT( FALSE );

    //
    // Release the spinlocks
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

}

VOID EXPORT
ACPIDeviceCancelWaitWakeIrpCallBack(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called after _PSW(Off) has been run as part of the
    task of cancelling the irp. This routine is here so that we can free
    the request and to allow us to keep track of things

Arguments:

    AcpiObject  - Points to the control method that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - ACPI_POWER_REQUEST

Return Value:

    NTSTATUS

--*/
{
    PACPI_POWER_REQUEST powerRequest = (PACPI_POWER_REQUEST) Context;
    PDEVICE_EXTENSION   deviceExtension = powerRequest->DeviceExtension;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "ACPIDeviceCancelWaitWakeIrpCallBack = 0x%08lx\n",
        Status
        ) );

    //
    // free the request
    //
    ExFreeToNPagedLookasideList(
        &RequestLookAsideList,
        powerRequest
        );

}

VOID
ACPIDeviceCompleteCommon(
    IN  PULONG  OldWorkDone,
    IN  ULONG   NewWorkDone
    )
/*++

Routine Description:

    Since the completion routines all have to do some bit of common work
    to get the DPC firing again, this routine reduces the code duplication

Arguments:

    OldWorkDone - Pointer to the old work done
    NewWorkDone - The new amount of work that has been completed

    NOTENOTE: There is an implicit assumption that the current value of
              WorkDone in the request is WORK_DONE_PENDING

Return Value:

    None

--*/
{
    KIRQL   oldIrql;

    //
    // Mark the request as being complete
    //
    InterlockedCompareExchange(
        OldWorkDone,
        NewWorkDone,
        WORK_DONE_PENDING
        );

    //
    // We need this lock to look at the following variables
    //
    KeAcquireSpinLock( &AcpiPowerQueueLock, &oldIrql );

    //
    // No matter what, work was done
    //
    AcpiPowerWorkDone = TRUE;

    //
    // Is the DPC already running?
    //
    if (!AcpiPowerDpcRunning) {

        //
        // Better make sure it does then
        //
        KeInsertQueueDpc( &AcpiPowerDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiPowerQueueLock, oldIrql );

}

VOID EXPORT
ACPIDeviceCompleteGenericPhase(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This is the generic completion handler. If the interpreter has
    successfully executed the method, it completes the request to the
    next desired WORK_DONE, otherwise it fails the request.

Arguments:

    AcpiObject  - Points to the control method that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - ACPI_POWER_REQUEST

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  deviceState;
    PACPI_POWER_REQUEST powerRequest = (PACPI_POWER_REQUEST) Context;
    PDEVICE_EXTENSION   deviceExtension = powerRequest->DeviceExtension;

    UNREFERENCED_PARAMETER( AcpiObject );
    UNREFERENCED_PARAMETER( ObjectData );

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "ACPIDeviceCompleteGenericPhase = 0x%08lx\n",
        Status
        ) );

    //
    // Decide what state we should transition to next
    //
    if (!NT_SUCCESS(Status)) {

        //
        // Then complete the request as failed
        //
        powerRequest->Status = Status;
        ACPIDeviceCompleteCommon( &(powerRequest->WorkDone), WORK_DONE_FAILURE);

    } else {

        //
        // Get ready to go the next stage
        //
        ACPIDeviceCompleteCommon(
            &(powerRequest->WorkDone),
            powerRequest->NextWorkDone
            );

    }
}

VOID EXPORT
ACPIDeviceCompleteInterpreterRequest(
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called after the interpreter has flushed its queue and
    marked itself as no longer accepting requests.

Arguments:

    Context - The context we told the interpreter to pass back to us

Return Value:

    None

--*/
{

    //
    // This is just a wrapper for CompleteRequest (because the interpreter
    // used different callbacks in this case)
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        STATUS_SUCCESS,
        NULL,
        Context
        );
}

VOID EXPORT
ACPIDeviceCompletePhase3Off(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called after _OFF has been run on a Power Resource

Arguments:

    AcpiObject  - Points to the control method that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - ACPI_POWER_DEVICE_NODE

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   oldIrql;
    PACPI_POWER_DEVICE_NODE powerNode = (PACPI_POWER_DEVICE_NODE) Context;

    UNREFERENCED_PARAMETER( AcpiObject );
    UNREFERENCED_PARAMETER( ObjectData );
    UNREFERENCED_PARAMETER( Status );

    ACPIPrint( (
        ACPI_PRINT_POWER,
        "ACPIDeviceCompletePhase3Off: PowerNode: 0x%08lx OFF = 0x%08lx\n",
        powerNode,
        Status
        ) );

    //
    // We need a spin lock for this
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // First step is to set the new flags for the node
    //
    if (NT_SUCCESS(Status)) {

        ACPIInternalUpdateFlags( &(powerNode->Flags), DEVICE_NODE_ON, TRUE );

    } else {

        ACPIInternalUpdateFlags( &(powerNode->Flags), DEVICE_NODE_FAIL, FALSE );

    }

    //
    // We can give up the lock now
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Done
    //
    ACPIDeviceCompleteCommon( &(powerNode->WorkDone), WORK_DONE_COMPLETE );
}

VOID EXPORT
ACPIDeviceCompletePhase3On(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called after _ON has been run on a Power Resource

Arguments:

    AcpiObject  - Points to the control method that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - ACPI_POWER_DEVICE_NODE

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   oldIrql;
    PACPI_POWER_DEVICE_NODE powerNode = (PACPI_POWER_DEVICE_NODE) Context;

    UNREFERENCED_PARAMETER( AcpiObject );
    UNREFERENCED_PARAMETER( ObjectData );
    UNREFERENCED_PARAMETER( Status );

    ACPIPrint( (
        ACPI_PRINT_POWER,
        "ACPIDeviceCompletePhase3On: PowerNode: 0x%08lx ON = 0x%08lx\n",
        powerNode,
        Status
        ) );

    //
    // We need a spin lock for this
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // First step is to set the new flags for the node
    //
    if (NT_SUCCESS(Status)) {

        ACPIInternalUpdateFlags( &(powerNode->Flags), DEVICE_NODE_ON, FALSE );

    } else {

        ACPIInternalUpdateFlags( &(powerNode->Flags), DEVICE_NODE_FAIL, FALSE );

    }

    //
    // We can give up the lock now
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Done
    //
    ACPIDeviceCompleteCommon( &(powerNode->WorkDone), WORK_DONE_COMPLETE );
}

VOID
ACPIDeviceCompleteRequest(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine invokes the callbacks on a given PowerRequest, dequeues the
    request from any list that it is on, and does any other post-processing
    that is required.

    Note: this is where *all* of the various special handling should be done.
    A prime example of something that should be done here is that we want
    to return STATUS_SUCCESS to any Dx irp that are more off

Arguments:

    None used

Return:

    Void

--*/
{
    KIRQL                   oldIrql;
    PACPI_POWER_CALLBACK    callBack = PowerRequest->CallBack;
    PACPI_POWER_REQUEST     nextRequest;
    PDEVICE_EXTENSION       deviceExtension = PowerRequest->DeviceExtension;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDeviceCompleteRequest = 0x%08lx\n",
        PowerRequest,
        PowerRequest->Status
        ) );

    if (PowerRequest->RequestType == AcpiPowerRequestDevice ) {

        if (deviceExtension->PowerInfo.PowerState != PowerDeviceUnspecified) {

            DEVICE_POWER_STATE  deviceState;

            //
            // If this is the first time we have seen the request, and it
            // is a failure, then we should undo whatever it was we did
            //
            if (PowerRequest->FailedOnce == FALSE &&
                !NT_SUCCESS(PowerRequest->Status) ) {

                //
                // Grab the queue Lock
                //
                KeAcquireSpinLock( &AcpiPowerQueueLock, &oldIrql );

                //
                // Transition back to the previous state
                //
                PowerRequest->u.DevicePowerRequest.DevicePowerState =
                    deviceExtension->PowerInfo.PowerState;
                PowerRequest->FailedOnce = TRUE;

                //
                // Remove the Request from the current list
                //
                RemoveEntryList( &(PowerRequest->ListEntry) );

                //
                // Insert the request back in the Phase0 list
                //
                InsertTailList(
                    &(AcpiPowerQueueList),
                    &(PowerRequest->ListEntry)
                    );

                //
                // Work was done --- we reinserted the request into the queues
                //
                AcpiPowerWorkDone = TRUE;

                //
                // Make sure that the dpc is running, start it if neccessary.
                //
                if ( !AcpiPowerDpcRunning ) {

                    KeInsertQueueDpc( &AcpiPowerDpc, NULL, NULL );

                }

                //
                // Done with the queue lock
                //
                KeReleaseSpinLock( &AcpiPowerQueueLock, oldIrql );

                //
                // we cannot continue
                //
                return;

            }

            //
            // Are we turning the device more off?
            //
            deviceState = PowerRequest->u.DevicePowerRequest.DevicePowerState;
            if (deviceExtension->PowerInfo.PowerState < deviceState ) {

                //
                // Yes, then no matter what, we succeeded
                //
                PowerRequest->Status = STATUS_SUCCESS;


            }

        }

    }

    //
    // Invoke the callback, if there is any
    //
    if (callBack != NULL) {

        (*callBack)(
            deviceExtension,
            PowerRequest->Context,
            PowerRequest->Status
            );

    }

    //
    // Grab the queue Lock
    //
    KeAcquireSpinLock( &AcpiPowerQueueLock, &oldIrql );

    //
    // Remove the Request from all lists
    //
    RemoveEntryList( &(PowerRequest->ListEntry) );
    RemoveEntryList( &(PowerRequest->SerialListEntry) );

    //
    // Should we queue up another request?
    //
    if (!IsListEmpty( &(deviceExtension->PowerInfo.PowerRequestListEntry) ) ) {

        //
        // No? Then make sure that the request gets processed
        //
        nextRequest = CONTAINING_RECORD(
            deviceExtension->PowerInfo.PowerRequestListEntry.Flink,
            ACPI_POWER_REQUEST,
            SerialListEntry
            );

        InsertTailList(
            &(AcpiPowerQueueList),
            &(nextRequest->ListEntry)
            );

        //
        // Remember this as the current request
        //
        deviceExtension->PowerInfo.CurrentPowerRequest = nextRequest;

    } else {

        deviceExtension->PowerInfo.CurrentPowerRequest = NULL;

    }

    //
    // Done with the queue lock
    //
    KeReleaseSpinLock( &AcpiPowerQueueLock, oldIrql );

    //
    // Free the allocate memory
    //
    ExFreeToNPagedLookasideList(
        &RequestLookAsideList,
        PowerRequest
        );

}

NTSTATUS
ACPIDeviceInitializePowerRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  POWER_STATE             Power,
    IN  PACPI_POWER_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  POWER_ACTION            PowerAction,
    IN  ACPI_POWER_REQUEST_TYPE RequestType,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

    This is the actual worker function that fills in a PowerRequest

Arguments:

    DeviceExtension - Target device
    PowerState      - Target S or D state
    CallBack        - routine to call when done
    CallBackContext - context to pass when done
    PowerAction     - The reason we are doing this
    RequestType     - What kind of request we are looking at
    Flags           - Some flags that will let us control the behavior more

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    PACPI_POWER_REQUEST powerRequest;

    //
    // Allocate a powerRequest structure
    //
    powerRequest = ExAllocateFromNPagedLookasideList(
        &RequestLookAsideList
        );
    if (powerRequest == NULL) {

        //
        // Call the completion routine
        //
        if (*CallBack != NULL) {

            (*CallBack)(
                DeviceExtension,
                CallBackContext,
                STATUS_INSUFFICIENT_RESOURCES
                );

        }
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Fill in the common parts of the structure powerRequest structure
    //
    RtlZeroMemory( powerRequest, sizeof(ACPI_POWER_REQUEST) );
    powerRequest->Signature         = ACPI_SIGNATURE;
    powerRequest->CallBack          = CallBack;
    powerRequest->Context           = CallBackContext;
    powerRequest->DeviceExtension   = DeviceExtension;
    powerRequest->WorkDone          = WORK_DONE_STEP_0;
    powerRequest->Status            = STATUS_SUCCESS;
    powerRequest->RequestType       = RequestType;
    InitializeListHead( &(powerRequest->ListEntry) );
    InitializeListHead( &(powerRequest->SerialListEntry) );

    //
    // At this point, we need the spinlock
    //
    KeAcquireSpinLock( &AcpiPowerQueueLock, &oldIrql );

    //
    // Fill in the request specific parts of the structure
    //
    switch (RequestType) {
    case AcpiPowerRequestDevice: {

        ULONG   count;

        count = InterlockedCompareExchange( &(DeviceExtension->HibernatePathCount), 0, 0);
        if (count) {

            //
            // If we are on the hibernate path, then special rules apply
            // We need to basically lock down all the power resources on the
            // device.
            //
            if (PowerAction == PowerActionHibernate &&
                Power.DeviceState == PowerDeviceD3) {

                Flags |= DEVICE_REQUEST_LOCK_HIBER;

            } else if (PowerAction != PowerActionHibernate &&
                       Power.DeviceState == PowerDeviceD0) {

                Flags |= DEVICE_REQUEST_UNLOCK_HIBER;

            }

        }

        powerRequest->u.DevicePowerRequest.DevicePowerState  = Power.DeviceState;
        powerRequest->u.DevicePowerRequest.Flags             = Flags;

        //
        // If the transition is *to* a lower Dx state, then we need to run
        // the function that lets the system that we are about to do this work
        //
        if (Power.DeviceState > DeviceExtension->PowerInfo.PowerState &&
            DeviceExtension->DeviceObject != NULL) {

            PoSetPowerState(
                DeviceExtension->DeviceObject,
                DevicePowerState,
                Power
                );

        }
        break;

    }
    case AcpiPowerRequestWaitWake: {

        NTSTATUS status;

        powerRequest->u.WaitWakeRequest.SystemPowerState     = Power.SystemState;
        powerRequest->u.WaitWakeRequest.Flags                = Flags;

        //
        // Release the spinlock --- no longer required, enable the wakeup for the
        // device and return
        //
        KeReleaseSpinLock( &AcpiPowerQueueLock, oldIrql );
        status = ACPIWakeEnableDisableAsync(
            DeviceExtension,
            TRUE,
            ACPIDeviceIrpWaitWakeRequestPending,
            powerRequest
            );
        if (status == STATUS_PENDING) {

            status = STATUS_MORE_PROCESSING_REQUIRED;

        }
        return status;

    }
    case AcpiPowerRequestSystem:
        powerRequest->u.SystemPowerRequest.SystemPowerState  = Power.SystemState;
        powerRequest->u.SystemPowerRequest.SystemPowerAction = PowerAction;
        break;

    case AcpiPowerRequestWarmEject:
        powerRequest->u.EjectPowerRequest.EjectPowerState    = Power.SystemState;
        powerRequest->u.EjectPowerRequest.Flags              = Flags;
        break;

    case AcpiPowerRequestSynchronize:
        powerRequest->u.SynchronizePowerRequest.Flags             = Flags;
        break;

    }

    //
    // Should we even queue the request?
    //
    if (Flags & DEVICE_REQUEST_NO_QUEUE) {

        goto ACPIDeviceInitializePowerRequestExit;

    }

    //
    // Add the request to the right place in the lists. Note that this function
    // must be called with the PowerQueueLock being held.
    //
    ACPIDeviceInternalQueueRequest(
        DeviceExtension,
        powerRequest,
        Flags
        );

ACPIDeviceInitializePowerRequestExit:

    //
    // Done with the spinlock
    //
    KeReleaseSpinLock( &AcpiPowerQueueLock, oldIrql );

    //
    // The request will not be completed immediately. Note that we return
    // MORE_PROCESSING requird just in case this routine was called within
    // the context of a completion routine. It is the caller's responsibility
    // to turn this into a STATUS_PENDING
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
ACPIDeviceInternalDelayedDeviceRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  DEVICE_POWER_STATE      DeviceState,
    IN  PACPI_POWER_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext
    )
/*++

Routine Description:

    This routine is called when a device extension wants to transition to
    another Device State. This one differs from the
    ACPIDeviceInternalDeviceRequest function in that the queue is only emptied
    by the build device DPC when it has flushed the device list

Arguments:

    DeviceExtension - The device which wants to transition
    DeviceState     - What the desired target state is
    CallBack        - The function to call when done
    CallBackContext - The argument to pass to that function

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    POWER_STATE         powerState;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceInternalDelayedDeviceRequest - "
        "Transition to D%d\n",
        CallBackContext,
        (DeviceState - PowerDeviceD0)
        ) );

    //
    // Cast the desired state
    //
    powerState.DeviceState = DeviceState;

    //
    // Queue the request
    //
    status = ACPIDeviceInitializePowerRequest(
        DeviceExtension,
        powerState,
        CallBack,
        CallBackContext,
        PowerActionNone,
        AcpiPowerRequestDevice,
        (DEVICE_REQUEST_DELAYED | DEVICE_REQUEST_UNLOCK_DEVICE)
        );
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = STATUS_PENDING;

    }
    return status;
}

NTSTATUS
ACPIDeviceInternalDeviceRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  DEVICE_POWER_STATE      DeviceState,
    IN  PACPI_POWER_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

    This routine is called when a device extension wants to transition to
    another Device State

Arguments:

    DeviceExtension - The device which wants to transition
    DeviceState     - What the desired target state is
    CallBack        - The function to call when done
    CallBackContext - The argument to pass to that function
    Flags           - Flags (lock, unlock, etc)

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    POWER_STATE         powerState;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceInternalDeviceRequest - Transition to D%d\n",
        CallBackContext,
        (DeviceState - PowerDeviceD0)
        ) );

    //
    // Cast the desired state
    //
    powerState.DeviceState = DeviceState;

    //
    // Queue the request
    //
    status = ACPIDeviceInitializePowerRequest(
        DeviceExtension,
        powerState,
        CallBack,
        CallBackContext,
        PowerActionNone,
        AcpiPowerRequestDevice,
        Flags
        );
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = STATUS_PENDING;

    }
    return status;

}

VOID
ACPIDeviceInternalQueueRequest(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PACPI_POWER_REQUEST PowerRequest,
    IN  ULONG               Flags
    )
/*++

Routine Description:

    This routine is called with the AcpiPowerQueueLock being held. The routine
    correctly adds the PowerRequest into the right list entries such that it
    will get processed in the correct order

Arguments:

    DeviceExtension - The device in question
    PowerRequest    - The request to queue
    Flags           - Useful information about the request

Return Value:

    None

--*/
{
    if (Flags & DEVICE_REQUEST_TO_SYNC_QUEUE) {

        //
        // add the request to the synchronize list
        //
        InsertHeadList(
            &AcpiPowerSynchronizeList,
            &(PowerRequest->ListEntry)
            );

    } else if (IsListEmpty( &(DeviceExtension->PowerInfo.PowerRequestListEntry) ) ) {

        //
        // We are going to add the request to both the device's serial list and
        // the main power queue.
        //
        InsertTailList(
            &(DeviceExtension->PowerInfo.PowerRequestListEntry),
            &(PowerRequest->SerialListEntry)
            );
        if (Flags & DEVICE_REQUEST_DELAYED) {

            InsertTailList(
                &(AcpiPowerDelayedQueueList),
                &(PowerRequest->ListEntry)
                );

        } else {

            InsertTailList(
                &(AcpiPowerQueueList),
                &(PowerRequest->ListEntry)
                );

        }

    } else {

        //
        // Serialize the request
        //
        InsertTailList(
            &(DeviceExtension->PowerInfo.PowerRequestListEntry),
            &(PowerRequest->SerialListEntry)
            );

    }

    //
    // Remember that Work *was* done
    //
    AcpiPowerWorkDone = TRUE;

    //
    // Make sure that the dpc is running, if it has to
    //
    if (!(Flags & DEVICE_REQUEST_DELAYED) && !AcpiPowerDpcRunning ) {

        KeInsertQueueDpc( &AcpiPowerDpc, NULL, NULL );

    }

    //
    // Done
    //
    return;
}

NTSTATUS
ACPIDeviceInternalSynchronizeRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PACPI_POWER_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

    This routine is called when a device wants to make sure that the power
    dpc is empty

Arguments:

    DeviceExtension - The device which wants to know
    CallBack        - The function to call when done
    CallBackContext - The argument to pass to that function
    Flags           - Flags (lock, unlock, etc)

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    POWER_STATE         powerState;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceInternalSynchronizeRequest\n"
        ) );

    //
    // We don't care about the state
    //
    powerState.DeviceState = PowerDeviceUnspecified;

    //
    // Queue the request
    //
    status = ACPIDeviceInitializePowerRequest(
        DeviceExtension,
        powerState,
        CallBack,
        CallBackContext,
        PowerActionNone,
        AcpiPowerRequestSynchronize,
        (Flags | DEVICE_REQUEST_TO_SYNC_QUEUE)
        );
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = STATUS_PENDING;

    }
    return status;

}

VOID
ACPIDeviceIrpCompleteRequest(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is one of the completion routines for Irp-based device power
    management requests

    This routine will always complete the request with the given status.

Arguments:

    DeviceExtension - Points to the DeviceExtension that was the target
    Context         - The Irp that was associated with the request
    Status          - The Result of the request

Return Value:

    None
--*/
{
    PIRP    irp = (PIRP) Context;
    LONG    oldReferenceValue;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceIrpCompleteRequest = 0x%08lx\n",
        irp,
        Status
        ) );

    //
    // Start the next power request
    //
    PoStartNextPowerIrp( irp );

    //
    // Mark it pending (again) because it was pending already
    //
    IoMarkIrpPending( irp );

    //
    // Complete this irp
    //
    irp->IoStatus.Status = Status;
    IoCompleteRequest( irp, IO_NO_INCREMENT );

    //
    // Remove our reference
    //
    ACPIInternalDecrementIrpReferenceCount( DeviceExtension );
}

VOID
ACPIDeviceIrpDelayedDeviceOffRequest(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is one of the completion routines for Irp-based device power
    management requests

    This routine completes the irp (on failure), or forwards it to
    the DeviceObject below this one (on success)

Arguments:

    DeviceExtension - Points to the DeviceExtension that was the target
    Context         - The Irp that was associated with the request
    Status          - The Result of the request

Return Value:

    None
--*/
{
    PIRP    irp = (PIRP) Context;
    LONG    oldReferenceValue;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceIrpDelayedDeviceOffRequest = 0x%08lx\n",
        irp,
        Status
        ) );

    if (!NT_SUCCESS(Status)) {

        //
        // Start the next power request
        //
        PoStartNextPowerIrp( irp );

        //
        // Complete this irp
        //
        irp->IoStatus.Status = Status;
        IoCompleteRequest( irp, IO_NO_INCREMENT );

    } else {

        //
        // We cannot call ForwardPowerIrp because that would blow away our
        // completion routine
        //

        //
        // Increment the OutstandingIrpCount since a completion routine
        // counts for this purpose
        //
        InterlockedIncrement( (&DeviceExtension->OutstandingIrpCount) );

        //
        // Forward the power irp to target device
        //
        IoCopyCurrentIrpStackLocationToNext( irp );

        //
        // We want the completion routine to fire. We cannot call
        // ACPIDispatchForwardPowerIrp here because we set this completion
        // routine
        //
        IoSetCompletionRoutine(
            irp,
            ACPIDeviceIrpDeviceFilterRequest,
            ACPIDeviceIrpCompleteRequest,
            TRUE,
            TRUE,
            TRUE
            );

        //
        // Start the next power irp
        //
        PoStartNextPowerIrp( irp );

        //
        // Let the person below us execute. Note: we can't block at
        // any time within this code path.
        //
        ASSERT( DeviceExtension->TargetDeviceObject != NULL);
        PoCallDriver( DeviceExtension->TargetDeviceObject, irp );

    }

    //
    // Remove our reference
    //
    ACPIInternalDecrementIrpReferenceCount( DeviceExtension );
}

VOID
ACPIDeviceIrpDelayedDeviceOnRequest(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is one of the completion routines for Irp-based device power
    management requests

    This routine completes the irp (on failure), or forwards it to
    the DeviceObject below this one (on success)

Arguments:

    DeviceExtension - Points to the DeviceExtension that was the target
    Context         - The Irp that was associated with the request
    Status          - The Result of the request

Return Value:

    None
--*/
{
    PIRP    irp = (PIRP) Context;
    LONG    oldReferenceValue;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceIrpDelayedDeviceOnRequest = 0x%08lx\n",
        irp,
        Status
        ) );

    if (!NT_SUCCESS(Status)) {

        //
        // Start the next power request
        //
        PoStartNextPowerIrp( irp );

        //
        // Complete this irp
        //
        irp->IoStatus.Status = Status;
        IoCompleteRequest( irp, IO_NO_INCREMENT );

    } else {

        //
        // We cannot call ForwardPowerIrp because that would blow away our
        // completion routine
        //

        //
        // Increment the OutstandingIrpCount since a completion routine
        // counts for this purpose
        //
        InterlockedIncrement( (&DeviceExtension->OutstandingIrpCount) );

        //
        // Forward the power irp to target device
        //
        IoCopyCurrentIrpStackLocationToNext( irp );

        //
        // We want the completion routine to fire. We cannot call
        // ACPIDispatchForwardPowerIrp here because we set this completion
        // routine
        //
        IoSetCompletionRoutine(
            irp,
            ACPIBuildRegOnRequest,
            ACPIDeviceIrpCompleteRequest,
            TRUE,
            TRUE,
            TRUE
            );

        //
        // Let the person below us execute. Note: we can't block at
        // any time within this code path.
        //
        ASSERT( DeviceExtension->TargetDeviceObject != NULL);
        PoCallDriver( DeviceExtension->TargetDeviceObject, irp );

    }

    //
    // Remove our reference
    //
    ACPIInternalDecrementIrpReferenceCount( DeviceExtension );
}

NTSTATUS
ACPIDeviceIrpDeviceFilterRequest(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PACPI_POWER_CALLBACK    CallBack
    )
/*++

Routine Description:

    This routine is called when an Irp wishes to do D-level power management

    Note: that we always pass the Irp back as the Context for the CallBack

Arguments:

    DeviceObject    - The target device object
    Irp             - The target irp
    CallBack        - The routine to call when done

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             unlockDevice = FALSE;
    DEVICE_POWER_STATE  deviceState;
    LONG                oldReferenceValue;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    POWER_ACTION        powerAction;
    POWER_STATE         powerState;

    //
    // Grab the requested device state
    //
    deviceState = irpStack->Parameters.Power.State.DeviceState;
    powerAction = irpStack->Parameters.Power.ShutdownType;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDeviceIrpDeviceFilterRequest - Transition to D%d\n",
        Irp,
        (deviceState - PowerDeviceD0)
        ) );

    //
    // Do we need to mark the irp as pending?
    //
    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );

    }

    //
    // Lets us look at the current status code for the request. On error,
    // we cannot call a completion routine because we would complete the
    // irp at that point. Double-completing an irp is bad.
    //
    status = Irp->IoStatus.Status;
    if (!NT_SUCCESS(status)) {

        //
        // Remove our reference
        //
        ACPIInternalDecrementIrpReferenceCount( deviceExtension );
        return status;

    }

    //
    // Cast the desired state
    //
    powerState.DeviceState = deviceState;

#if defined(ACPI_INTERNAL_LOCKING)
    //
    // Determine if we should unlock the device
    //
    if (powerAction == PowerActionShutdown ||
        powerAction == PowerActionShutdownReset ||
        powerAction == PowerActionShutdownOff) {

        unlockDevice = TRUE;

    }
#endif

    //
    // Queue the request --- this function will always return
    // MORE_PROCESSING_REQUIRED instead of PENDING, so we don't have
    // to mess with it
    //
    status = ACPIDeviceInitializePowerRequest(
        deviceExtension,
        powerState,
        CallBack,
        Irp,
        powerAction,
        AcpiPowerRequestDevice,
        (unlockDevice ? DEVICE_REQUEST_UNLOCK_DEVICE : 0)
        );
    return status;
}

NTSTATUS
ACPIDeviceIrpDeviceRequest(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PACPI_POWER_CALLBACK    CallBack
    )
/*++

Routine Description:

    This routine is called when an Irp wishes to do D-level power management

    Note: that we always pass the Irp back as the Context for the CallBack

Arguments:

    DeviceObject    - The target device object
    Irp             - The target irp
    CallBack        - The routine to call when done

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             unlockDevice = FALSE;
    DEVICE_POWER_STATE  deviceState;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    POWER_ACTION        powerAction;
    POWER_STATE         powerState;

    //
    // Grab the requested device state and power action
    //
    deviceState = irpStack->Parameters.Power.State.DeviceState;
    powerAction = irpStack->Parameters.Power.ShutdownType;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDeviceIrpDeviceRequest - Transition to D%d\n",
        Irp,
        (deviceState - PowerDeviceD0)
        ) );

    //
    // Do we need to mark the irp as pending?
    //
    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );

    }

    //
    // Lets us look at the current status code for the request. On error,
    // we will just call the completion right now, and it is responsible
    // for doing the 'right' thing
    //
    status = Irp->IoStatus.Status;
    if (!NT_SUCCESS(status)) {

        //
        // Call the completion routine and return
        //
        if (*CallBack != NULL ) {

            (*CallBack)(
                deviceExtension,
                Irp,
                status
                );
            return status;

        }

    }

    //
    // Cast the desired state
    //
    powerState.DeviceState = deviceState;

#if defined(ACPI_INTERNAL_LOCKING)
    //
    // Determine if we should unlock the device
    //
    if (powerAction == PowerActionShutdown ||
        powerAction == PowerActionShutdownReset ||
        powerAction == PowerActionShutdownOff) {

        unlockDevice = TRUE;

    }
#endif

    //
    // Queue the request --- this function will always return
    // MORE_PROCESSING_REQUIRED instead of PENDING, so we don't have
    // to mess with it
    //
    status = ACPIDeviceInitializePowerRequest(
        deviceExtension,
        powerState,
        CallBack,
        Irp,
        powerAction,
        AcpiPowerRequestDevice,
        (unlockDevice ? DEVICE_REQUEST_UNLOCK_DEVICE : 0)
        );
    return status;
}

VOID
ACPIDeviceIrpForwardRequest(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is one of the completion routines for Irp-based device power
    management requests

    This routine completes the irp (on failure), or forwards it to
    the DeviceObject below this one (on success)

Arguments:

    DeviceExtension - Points to the DeviceExtension that was the target
    Context         - The Irp that was associated with the request
    Status          - The Result of the request

Return Value:

    None
--*/
{
    PIRP    irp = (PIRP) Context;
    LONG    oldReferenceValue;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceIrpForwardRequest = 0x%08lx\n",
        irp,
        Status
        ) );

    if (!NT_SUCCESS(Status)) {

        //
        // Start the next power request
        //
        PoStartNextPowerIrp( irp );

        //
        // Complete this irp
        //
        irp->IoStatus.Status = Status;
        IoCompleteRequest( irp, IO_NO_INCREMENT );

    } else {

        PDEVICE_OBJECT      devObject;
        PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation( irp );

        devObject = irpSp->DeviceObject;

        //
        // Forward the request
        //
        ACPIDispatchForwardPowerIrp(
            devObject,
            irp
            );

    }

    //
    // Remove our reference
    //
    ACPIInternalDecrementIrpReferenceCount( DeviceExtension );
}

NTSTATUS
ACPIDeviceIrpSystemRequest(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PACPI_POWER_CALLBACK    CallBack
    )
/*++

Routine Description:

    This routine is called when an Irp wishes to do S-level power management

    Note: that we always pass the Irp back as the Context for the CallBack

Arguments:

    DeviceObject    - The target device object
    Irp             - The target irp
    CallBack        - The routine to call when done

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    POWER_ACTION        powerAction;
    POWER_STATE         powerState;
    SYSTEM_POWER_STATE  systemState;

    //
    // Grab the requested system state and system action
    //
    systemState = irpStack->Parameters.Power.State.SystemState;
    powerAction = irpStack->Parameters.Power.ShutdownType;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDeviceIrpSystemRequest - Transition to S%d\n",
        Irp,
        ACPIDeviceMapACPIPowerState(systemState)
        ) );

    //
    // Do we need to mark the irp as pending?
    //
    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );

    }

    //
    // Lets us look at the current status code for the request. On error,
    // we will just call the completion right now, and it is responsible
    // for doing the 'right' thing
    //
    status = Irp->IoStatus.Status;
    if (!NT_SUCCESS(status)) {

        //
        // Call the completion routine and return
        //
        (*CallBack)(
            deviceExtension,
            Irp,
            status
            );
        return status;

    }

    //
    // Cast the desired state
    //
    powerState.SystemState = systemState;

    //
    // Queue the request --- this function will always return
    // MORE_PROCESSING_REQUIRED instead of PENDING, so we don't have
    // to mess with it
    //
    status = ACPIDeviceInitializePowerRequest(
        deviceExtension,
        powerState,
        CallBack,
        Irp,
        powerAction,
        AcpiPowerRequestSystem,
        0
        );
    return status;
}

NTSTATUS
ACPIDeviceIrpWaitWakeRequest(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PACPI_POWER_CALLBACK    CallBack
    )
/*++

Routine Description:

    This routine is called when an Irp wishes to do wake support

    Note: that we always pass the Irp back as the Context for the CallBack

    Note: this function is coded differently then the other DeviceIrpXXXRequest
          functions --- there are no provisions made that this routine can
          be called as a IoCompletionRoutine, although the arguments could
          support it.

Arguments:

    DeviceObject    - The target device object
    Irp             - The target irp
    CallBack        - The routine to call when done

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    POWER_STATE         powerState;
    SYSTEM_POWER_STATE  systemState;

    //
    // Grab the requested device state
    //
    systemState = irpStack->Parameters.WaitWake.PowerState;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        deviceExtension,
        "(0x%08lx): ACPIDeviceIrpWaitWakeRequest - Wait Wake S%d\n",
        Irp,
        ACPIDeviceMapACPIPowerState(systemState)
        ) );

    //
    // Cast the desired state
    //
    powerState.SystemState = systemState;

    //
    // Queue the request --- this function will always return
    // MORE_PROCESSING_REQUIRED instead of PENDING, so we don't have
    // to mess with it
    //
    status = ACPIDeviceInitializePowerRequest(
        deviceExtension,
        powerState,
        CallBack,
        Irp,
        PowerActionNone,
        AcpiPowerRequestWaitWake,
        DEVICE_REQUEST_NO_QUEUE
        );
    return status;
}

VOID
ACPIDeviceIrpWaitWakeRequestComplete(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine is called when the WaitWake Irp is finally complete and we
    need to pass it back to whomever called us with it

Arguments:

    PowerRequest - The request that was completed

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // Make sure that we own the power lock for this
    //
    KeAcquireSpinLock( &AcpiPowerQueueLock, &oldIrql );

    //
    // Remember the device extension
    //
    deviceExtension = PowerRequest->DeviceExtension;

    //
    // Make sure that the request can no longer be cancelled
    //
    if (PowerRequest->u.WaitWakeRequest.Flags & DEVICE_REQUEST_HAS_CANCEL) {

        KIRQL   cancelIrql;
        PIRP    irp = (PIRP) PowerRequest->Context;

        IoAcquireCancelSpinLock( &cancelIrql );

        IoSetCancelRoutine( irp, NULL );
        PowerRequest->u.WaitWakeRequest.Flags &= ~DEVICE_REQUEST_HAS_CANCEL;

        IoReleaseCancelSpinLock( cancelIrql );

    }

    //
    // Add the request to the right place in the lists. Note this function
    // must be called with the PowerQueueLock being held
    //
    ACPIDeviceInternalQueueRequest(
        deviceExtension,
        PowerRequest,
        PowerRequest->u.WaitWakeRequest.Flags
        );

    //
    // Done with spinlock
    //
    KeReleaseSpinLock( &AcpiPowerQueueLock, oldIrql );
}

VOID EXPORT
ACPIDeviceIrpWaitWakeRequestPending(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called after _PSW has been run and we want to enable
    the GPE associated with the current object

Arguments:

    AcpiObject  - Points to the control method that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - ACPI_POWER_REQUEST

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   oldIrql;
    PACPI_POWER_REQUEST     powerRequest    = (PACPI_POWER_REQUEST) Context;
    PDEVICE_EXTENSION       deviceExtension = powerRequest->DeviceExtension;
    PIRP                    irp = (PIRP) powerRequest->Context;

    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        deviceExtension,
        "(0x%08lx): ACPIDeviceIrpWaitWakeRequestPending= 0x%08lx\n",
        powerRequest,
        Status
        ) );

    //
    // Did we fail the request?
    //
    if (!NT_SUCCESS(Status)) {

        powerRequest->Status = Status;
        ACPIDeviceIrpWaitWakeRequestComplete( powerRequest );
        return;

    }

    //
    // At this point, we need the power spin lock and the cancel spinlock
    //
    IoAcquireCancelSpinLock( &oldIrql );
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Remember that we have this request outstanding
    //
    InsertTailList(
        &(AcpiPowerWaitWakeList),
        &(powerRequest->ListEntry)
        );

    //
    // Has the irp been cancelled?
    //
    if (irp->Cancel) {

        //
        // Yes, so lets release release the power lock and call the
        // cancel routine
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
        ACPIDeviceCancelWaitWakeIrp(
            deviceExtension->DeviceObject,
            irp
            );

        //
        // Return now --- the cancel routine should have taken care off
        // everything else
        //
        return;

    }

    //
    // Remember that this request has a cancel routine
    //
    powerRequest->u.WaitWakeRequest.Flags |= DEVICE_REQUEST_HAS_CANCEL;

    //
    // Update the Gpe Wake Bits
    //
    ACPIWakeRemoveDevicesAndUpdate( NULL, NULL );

    //
    // Mark the Irp as cancelable
    //
    IoSetCancelRoutine( irp, ACPIDeviceCancelWaitWakeIrp );

    //
    // Done with the spinlocks
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
    IoReleaseCancelSpinLock( oldIrql );

} // ACPIDeviceIrpWaitWakeRequestPending

NTSTATUS
ACPIDeviceIrpWarmEjectRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PIRP                    Irp,
    IN  PACPI_POWER_CALLBACK    CallBack,
    IN  BOOLEAN                 UpdateHardwareProfile
    )
/*++

Routine Description:

    This routine is called when an Irp wishes to do S-level power management

    Note: that we always pass the Irp back as the Context for the CallBack

Arguments:

    DeviceExtension - Extension of the device with the _EJx methods to run
    Irp             - The target irp
    CallBack        - The routine to call when done
    Flags           - Update profiles, etc

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    POWER_ACTION        ejectAction;
    POWER_STATE         powerState;
    SYSTEM_POWER_STATE  ejectState;

    //
    // Grab the requested system state
    //
    ejectState  = irpStack->Parameters.Power.State.SystemState;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceIrpWarmEjectRequest - Transition to S%d\n",
        Irp,
        ACPIDeviceMapACPIPowerState(ejectState)
        ) );

    //
    // Do we need to mark the irp as pending?
    //
    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );

    }

    //
    // Lets us look at the current status code for the request. On error,
    // we will just call the completion right now, and it is responsible
    // for doing the 'right' thing
    //
    status = Irp->IoStatus.Status;
    if (!NT_SUCCESS(status)) {

        //
        // Call the completion routine and return
        //
        (*CallBack)(
            DeviceExtension,
            Irp,
            status
            );
        return status;

    }

    //
    // Cast the desired state
    //
    powerState.SystemState = ejectState;

    //
    // Queue the request --- this function will always return
    // MORE_PROCESSING_REQUIRED instead of PENDING, so we don't have
    // to mess with it
    //
    status = ACPIDeviceInitializePowerRequest(
        DeviceExtension,
        powerState,
        CallBack,
        Irp,
        PowerActionNone,
        AcpiPowerRequestWarmEject,
        UpdateHardwareProfile ? DEVICE_REQUEST_UPDATE_HW_PROFILE : 0
        );
    return status;
}

#if 0
ULONG
ACPIDeviceMapACPIPowerState(
    SYSTEM_POWER_STATE  Level
    )
/*++

Routine Description:

    This isn't a routine. Its a macro. It returns a ULONG that corresponds
    to ACPI based System Power State based on the NT SystemPower State

Arguments:

    Level   - The NT Based S state

Return Value:

    ULONG

--*/
{
}
#endif

#if 0
DEVICE_POWER_STATE
ACPIDeviceMapPowerState(
    ULONG   Level
    )
/*++

Routine Description:

    This isn't a routine. Its a macro. It returns a DEVICE_POWER_STATE
    that corresponds to the mapping provided in the ACPI spec

Arguments:

    Level   - The 0-based D level (0 == D0, 1 == D1, ..., 3 == D3)

Return Value:

    DEVICE_POWER_STATE
--*/
{
}
#endif

#if 0
SYSTEM_POWER_STATE
ACPIDeviceMapSystemState(
    ULONG   Level
    )
/*++

Routine Description:

    This isn't a routine. Its a macro. It returns a SYSTEM_POWER_STATE that
    corresponds to the mapping provided in the ACPI spec

Arguments:

    Level   - The 0-based S level (0 = Working, ..., 5 = Shutdown)

Return Value:

    SYSTEM_POWER_STATE

--*/
{
}
#endif

NTSTATUS
ACPIDevicePowerDetermineSupportedDeviceStates(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PULONG              SupportedPrStates,
    IN  PULONG              SupportedPsStates
    )
/*++

Routine Description:

    This routine calculates the bit masks that reflect which D states are
    supported via PRx methods and which D states are supported via PSx
    methods

Arguments:

    DeviceExtension     - Device Extension to determine D-States
    SupportedPrStates   - Bit Mask of supported D-States via _PRx
    SupportedPsStates   - Bit Mask of supported D-States via _PSx

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  index;
    PNSOBJ              object;
    ULONG               i;
    ULONG               prBitIndex = 0;
    ULONG               prNames[] = { PACKED_PR0, PACKED_PR1, PACKED_PR2 };
    ULONG               psBitIndex = 0;
    ULONG               psNames[] = { PACKED_PS0, PACKED_PS1, PACKED_PS2, PACKED_PS3 };
    ULONG               supportedIndex = 0;

    PAGED_CODE();

    ASSERT( DeviceExtension != NULL );
    ASSERT( SupportedPrStates != NULL );
    ASSERT( SupportedPsStates != NULL );

    //
    // Assume we support nothing
    //
    *SupportedPrStates = 0;
    *SupportedPsStates = 0;

    //
    // This is another place that we want to be able to call this code even
    // though there is no NameSpace Object associated with this extension.
    // This special case code lets us avoid adding a check to GetNamedChild
    //
    if (DeviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        //
        // Assume that we support 'PS' states 0 and 3
        //
        psBitIndex = ( 1 << PowerDeviceD0 ) + ( 1 << PowerDeviceD3 );
        goto ACPIDevicePowerDetermineSupportedDeviceStatesExit;

    }

    //
    // Look for all of the _PS methods
    //
    for (i = 0, index = PowerDeviceD0; index <= PowerDeviceD3; i++, index++) {

        //
        // Does the object exist?
        //
        object = ACPIAmliGetNamedChild(
            DeviceExtension->AcpiObject,
            psNames[i]
            );
        if (object != NULL) {

            psBitIndex |= (1 << index);

        }

    }

    //
    // Look for all of the _PR methods
    //
    for (i = 0, index = PowerDeviceD0; index <= PowerDeviceD2; i++, index++) {

        //
        // Does the object exist?
        //
        object = ACPIAmliGetNamedChild(
            DeviceExtension->AcpiObject,
            prNames[i]
            );
        if (object != NULL) {

            prBitIndex |= (1 << index);

            //
            // We always support D3 'passively'
            //
            prBitIndex |= (1 << PowerDeviceD3);

        }

    }

    //
    // The supported index is the union of which _PR and which _PS are
    // present
    supportedIndex = (prBitIndex | psBitIndex);

    //
    // If we didn't find anything, then there is nothing for us to do
    //
    if (!supportedIndex) {

        //
        // Done
        //
        return STATUS_SUCCESS;

    }

    //
    // One of the rules that we have setup is that we must support D3 and
    // D0 if we support any power states at all. Make sure that this is
    // true.
    //
    if ( !(supportedIndex & (1 << PowerDeviceD0) ) ) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "does not support D0 power state!\n"
            ) );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) DeviceExtension,
            (prBitIndex != 0 ? PACKED_PR0 : PACKED_PS0),
            0
            );

    }
    if ( !(supportedIndex & (1 << PowerDeviceD3) ) ) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "does not support D3 power state!\n"
            ) );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) DeviceExtension,
            PACKED_PS3,
            0
            );
        ACPIInternalError( ACPI_INTERNAL );

    }
    if ( prBitIndex != 0 && psBitIndex != 0 && prBitIndex != psBitIndex) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "has mismatch between power plane and power source information!\n"
            ) );
        prBitIndex &= psBitIndex;
        psBitIndex &= prBitIndex;

    }

ACPIDevicePowerDetermineSupportedDeviceStatesExit:

    //
    // Give the answer of what we support
    //
    *SupportedPrStates = prBitIndex;
    *SupportedPsStates = psBitIndex;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

VOID
ACPIDevicePowerDpc(
    IN  PKDPC   Dpc,
    IN  PVOID   DpcContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    )
/*++

Routine Description:

    This routine is where all of the Power-related work is done. It looks
    at queued requests and processes them as appropriate.

Arguments:

    None used

Return Value:

    Void

--*/
{
    LIST_ENTRY  tempList;
    NTSTATUS    status;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( DpcContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    //
    // First step is to acquire the DPC Lock, and check to see if another
    // DPC is already running
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerQueueLock );
    if (AcpiPowerDpcRunning) {

        //
        // The DPC is already running, so we need to exit now
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiPowerQueueLock );
        return;

    }

    //
    // Remember that the DPC is now running
    //
    AcpiPowerDpcRunning = TRUE;

    //
    // Initialize the list that will hold the synchronize items
    //
    InitializeListHead( &tempList );

    //
    // We must try to do *some* work
    //
    do {

        //
        // Assume that we won't do any work
        //
        AcpiPowerWorkDone = FALSE;

        //
        // If there are items in the Queue list, move them to the Phase0 list
        //
        if (!IsListEmpty( &AcpiPowerQueueList ) ) {

            ACPIInternalMovePowerList(
                &AcpiPowerQueueList,
                &AcpiPowerPhase0List
                );

        }

        //
        // We can release the spin lock now
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiPowerQueueLock );

        //
        // If there are items in the Phase0 list, process the list
        //
        if (!IsListEmpty( &AcpiPowerPhase0List ) ) {

            status = ACPIDevicePowerProcessGenericPhase(
                &AcpiPowerPhase0List,
                AcpiDevicePowerProcessPhase0Dispatch,
                FALSE
                );
            if (NT_SUCCESS(status) && status != STATUS_PENDING) {

                //
                // This indicates that we have completed all the work
                // on the Phase0 list, so we are ready to move all the
                // items to the next list
                //
                ACPIInternalMovePowerList(
                    &AcpiPowerPhase0List,
                    &AcpiPowerPhase1List
                    );

            }

        }

        //
        // If there are items in Phase1 list, process the list
        //
        if (!IsListEmpty( &AcpiPowerPhase1List ) &&
            IsListEmpty( &AcpiPowerPhase0List) ) {

            status = ACPIDevicePowerProcessGenericPhase(
                &AcpiPowerPhase1List,
                AcpiDevicePowerProcessPhase1Dispatch,
                FALSE
                );
            if (NT_SUCCESS(status) && status != STATUS_PENDING) {

                //
                // This indicates that we have completed all the work
                // on the Phase1 list, so we are ready to move all the
                // items to the next list
                //
                ACPIInternalMovePowerList(
                    &AcpiPowerPhase1List,
                    &AcpiPowerPhase2List
                    );

            }

        }

        //
        // If there are items in the Phase2 list, then process those
        //
        if (IsListEmpty( &AcpiPowerPhase0List) &&
            IsListEmpty( &AcpiPowerPhase1List) &&
            !IsListEmpty( &AcpiPowerPhase2List) ) {

            status = ACPIDevicePowerProcessGenericPhase(
                &AcpiPowerPhase2List,
                AcpiDevicePowerProcessPhase2Dispatch,
                FALSE
                );
            if (NT_SUCCESS(status) && status != STATUS_PENDING) {

                //
                // This indicates that we have completed all the work
                // on the Phase1 list, so we are ready to move all the
                // items to the next list
                //
                ACPIInternalMovePowerList(
                    &AcpiPowerPhase2List,
                    &AcpiPowerPhase3List
                    );

            }

        }

        //
        // We cannot do this step if the Phase1List or Phase2List are non-empty
        //
        if (IsListEmpty( &AcpiPowerPhase0List) &&
            IsListEmpty( &AcpiPowerPhase1List) &&
            IsListEmpty( &AcpiPowerPhase2List) &&
            !IsListEmpty( &AcpiPowerPhase3List) ) {

            status = ACPIDevicePowerProcessPhase3( );
            if (NT_SUCCESS(status) && status != STATUS_PENDING) {

                //
                // This indicates that we have completed all the work
                // on the Phase2 list, so we are ready to move all the
                // itmes to the Phase3 list
                //
                ACPIInternalMovePowerList(
                    &AcpiPowerPhase3List,
                    &AcpiPowerPhase4List
                    );

            }

        }

        //
        // We can always empty the Phase4 list
        //
        if (!IsListEmpty( &AcpiPowerPhase4List ) ) {

            status = ACPIDevicePowerProcessPhase4( );
            if (NT_SUCCESS(status) && status != STATUS_PENDING) {

                //
                // This indicates that we have completed all the work
                // on the Phase1 list, so we are ready to move all the
                // items to the Phase2 list
                //
                ACPIInternalMovePowerList(
                    &AcpiPowerPhase4List,
                    &AcpiPowerPhase5List
                    );

            }

        }

        //
        // We can always empty the Phase5 list
        //
        if (!IsListEmpty( &AcpiPowerPhase5List) ) {

            status = ACPIDevicePowerProcessGenericPhase(
                &AcpiPowerPhase5List,
                AcpiDevicePowerProcessPhase5Dispatch,
                TRUE
                );

        }

        //
        // We need the lock again, since we are about to check to see if
        // we have completed some work
        //
        KeAcquireSpinLockAtDpcLevel( &AcpiPowerQueueLock );

    } while ( AcpiPowerWorkDone );

    //
    // The DPC is no longer running
    //
    AcpiPowerDpcRunning = FALSE;

    //
    // Have we flushed all of our queues?
    //
    if (IsListEmpty( &AcpiPowerPhase0List ) &&
        IsListEmpty( &AcpiPowerPhase1List ) &&
        IsListEmpty( &AcpiPowerPhase2List ) &&
        IsListEmpty( &AcpiPowerPhase3List ) &&
        IsListEmpty( &AcpiPowerPhase4List ) &&
        IsListEmpty( &AcpiPowerPhase5List ) ) {

        //
        // Let the world know
        //
        ACPIPrint( (
            ACPI_PRINT_POWER,
            "ACPIDevicePowerDPC: Queues Empty. Terminating.\n"
            ) );

        //
        // Do we have a synchronization request?
        //
        if (!IsListEmpty( &AcpiPowerSynchronizeList ) ) {

            //
            // Move all the item from the Sync list to the temp list
            //
            ACPIInternalMovePowerList(
                &AcpiPowerSynchronizeList,
                &tempList
                );

        }

    }

    //
    // We no longer need the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerQueueLock );

    //
    // Do we have any work in the synchronize list?
    //
    if (!IsListEmpty( &tempList) ) {

        ACPIDevicePowerProcessSynchronizeList( &tempList );

    }
}

NTSTATUS
ACPIDevicePowerFlushQueue(
    PDEVICE_EXTENSION       DeviceExtension
    )
/*++

Routine Description:

    This routine will block until the Power queues have been flushed

Arguments:

    DeviceExtension - The device extension which wants to flush

Return Value:

    NTSTATUS

--*/
{
    KEVENT      event;
    NTSTATUS    status;

    //
    // Initialize the event that we will wait on
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Now, push a request onto the stack such that when the power lists
    // have been emptied, we unblock this thread
    //
    status = ACPIDeviceInternalSynchronizeRequest(
        DeviceExtension,
        ACPIDevicePowerNotifyEvent,
        &event,
        0
        );

    //
    // Block until its done
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = STATUS_SUCCESS;
    }

    //
    // Let the world know
    //
    return status;
}

VOID
ACPIDevicePowerNotifyEvent(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This routine is called when all the power queues are empty

Arguments:

    DeviceExtension - The device that asked to be notified
    Context         - KEVENT
    Status          - The result of the operation

--*/
{
    PKEVENT event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER( DeviceExtension );
    UNREFERENCED_PARAMETER( Status );

    //
    // Set the event
    //
    KeSetEvent( event, IO_NO_INCREMENT, FALSE );
}

NTSTATUS
ACPIDevicePowerProcessForward(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine is called in liew of another PowerProcessPhaseXXX routine.
    It is called because there is no real work to do in the current phase
    on the selected request

Arguments:

    PowerRequest    - The request that we must process

Return Value:

    NTSTATUS

--*/
{
    InterlockedCompareExchange(
        &(PowerRequest->WorkDone),
        WORK_DONE_COMPLETE,
        WORK_DONE_PENDING
        );

    //
    // Remember that we have completed some work
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerQueueLock );
    AcpiPowerWorkDone = TRUE;
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerQueueLock );

    //
    // We always succeed
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDevicePowerProcessGenericPhase(
    IN  PLIST_ENTRY             ListEntry,
    IN  PACPI_POWER_FUNCTION    **DispatchTable,
    IN  BOOLEAN                 Complete
    )
/*++

Routine Description:

    This routine dispatches an item on the queue to the proper handler,
    based on what type of request is present

Arguments:

    ListEntry       - The list we are currently walking
    DispatchTable   - Where to find which functions to call
    Complete        - Do we need complete the request when done?

Return Value:

    NTSTATUS

        - If any request is not marked as being complete, then STATUS_PENDING
          is returned, otherwise, STATUS_SUCCESS is returned

--*/
{
    BOOLEAN                 allWorkComplete = TRUE;
    NTSTATUS                status          = STATUS_SUCCESS;
    PACPI_POWER_FUNCTION    *powerTable;
    PACPI_POWER_REQUEST     powerRequest;
    PLIST_ENTRY             currentEntry    = ListEntry->Flink;
    PLIST_ENTRY             tempEntry;
    ULONG                   workDone;

    //
    // Look at all the items in the list
    //
    while (currentEntry != ListEntry) {

        //
        // Turn this into a device request
        //
        powerRequest = CONTAINING_RECORD(
            currentEntry,
            ACPI_POWER_REQUEST,
            ListEntry
            );

        //
        // Set the temporary pointer to the next element
        //
        tempEntry = currentEntry->Flink;

        //
        // Check to see if we have any work to do on the request
        //
        workDone = InterlockedCompareExchange(
            &(powerRequest->WorkDone),
            WORK_DONE_PENDING,
            WORK_DONE_PENDING
            );

        //
        // Do we have a table associated with this level of workdone?
        //
        powerTable = DispatchTable[ workDone ];
        if (powerTable != NULL) {

            //
            // Mark the request as pending
            //
            workDone = InterlockedCompareExchange(
                &(powerRequest->WorkDone),
                WORK_DONE_PENDING,
                workDone
                );

            //
            // Call the function
            //
            status = (powerTable[powerRequest->RequestType])( powerRequest );

            //
            // Did we succeed?
            //
            if (NT_SUCCESS(status)) {

                //
                // Go to the next request
                //
                continue;

            }

            //
            // If we got an error before, then we must assume that we
            // have completed the work request
            //
            workDone = WORK_DONE_COMPLETE;

        }

        //
        // Grab the next entry
        //
        currentEntry = tempEntry;

        //
        // Check the status of the request
        //
        if (workDone != WORK_DONE_COMPLETE) {

            allWorkComplete = FALSE;

        }

        //
        // Do we need to complete the request or not?
        //
        if (workDone == WORK_DONE_FAILURE ||
            (Complete == TRUE && workDone == WORK_DONE_COMPLETE)) {

            //
            // We are done with the request
            //
            ACPIDeviceCompleteRequest(
                powerRequest
                );

        }

    }

    //
    // Have we completed all of our work?
    //
    return (allWorkComplete ? STATUS_SUCCESS : STATUS_PENDING);
} // ACPIPowerProcessGenericPhase

NTSTATUS
ACPIDevicePowerProcessInvalid(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine is called in liew of another PowerProcessPhaseXXX routine.
    It is called because the request is invalid

Arguments:

    PowerRequest    - The request that we must process

Return Value:

    NTSTATUS

--*/
{

    //
    // Note the status of the request as having failed
    //
    PowerRequest->Status = STATUS_INVALID_PARAMETER_1;

    //
    // Complete the request
    //
    ACPIDeviceCompleteRequest( PowerRequest );

    //
    // Remember that we have completed some work
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerQueueLock );
    AcpiPowerWorkDone = TRUE;
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerQueueLock );

    //
    // We always fail
    //
    return STATUS_INVALID_PARAMETER_1;
} // ACPIPowerProcessInvalid

NTSTATUS
ACPIDevicePowerProcessPhase0DeviceSubPhase1(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine looks for the _STA object and evalutes it. We will base
    many things on wether or not the device is present

Arguments:

    PowerRequest    - The request that we are asked to process

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    POBJDATA            resultData      = &(PowerRequest->ResultData);

    //
    // The next step is STEP_1
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_1;

    //
    // Initialize the result data
    //
    RtlZeroMemory( resultData, sizeof(OBJDATA) );

    //
    // Get the device presence
    //
    status = ACPIGetDeviceHardwarePresenceAsync(
        deviceExtension,
        ACPIDeviceCompleteGenericPhase,
        PowerRequest,
        &(resultData->uipDataValue),
        &(resultData->dwDataLen)
        );
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase0DeviceSubPhase1 = 0x%08lx\n",
        PowerRequest,
        status
        ) );
    if (status == STATUS_PENDING) {

        return status;

    }

    //
    // Call the completion routine by brute force. Note that at this
    // point, we count everything as being SUCCESS
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        status,
        resultData,
        PowerRequest
        );
    return STATUS_SUCCESS;

} // ACPIDevicePowerProcessPhase0DeviceSubPhase1

NTSTATUS
ACPIDevicePowerProcessPhase0DeviceSubPhase2(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine is called after the _STA method on a device has been run.
    If the method was successfull, or not present, then we can continue to
    process the request

Arguments:

    PowerRequest    - The request that we are asked to process

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    POBJDATA            resultData      = &(PowerRequest->ResultData);

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase0DeviceSubPhase2\n",
        PowerRequest
        ) );

    //
    // If the bit isn't set as being present, then we must abort this
    // request
    //
    if (!(resultData->uipDataValue & STA_STATUS_PRESENT) ) {

        //
        // The next work done phase is WORK_DONE_FAILURE. This allows the
        // request to be completed right away. We will mark the status as
        // success however, so that processing can continue
        //
        PowerRequest->NextWorkDone = WORK_DONE_FAILURE;
        PowerRequest->Status = STATUS_SUCCESS;

    } else {

        //
        // We are done with this work
        //
        PowerRequest->NextWorkDone = WORK_DONE_COMPLETE;

    }

    //
    // Call the completion routine by brute force. Note that at this
    // point, we count everything as being SUCCESS
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        STATUS_SUCCESS,
        NULL,
        PowerRequest
        );
    return STATUS_SUCCESS;

} // ACPIDevicePowerProcessPhase0DeviceSubPhase2

NTSTATUS
ACPIDevicePowerProcessPhase0SystemSubPhase1(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine unpauses the interpreter (if so required)

Arguments:

    PowerRequest    - The request we are currently processing

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    SYSTEM_POWER_STATE  systemState;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase0SystemSubPhase1\n",
        PowerRequest
        ) );

    //
    // We are done the first phase
    //
    PowerRequest->NextWorkDone = WORK_DONE_COMPLETE;

    //
    // Fetch the target system state
    //
    systemState = PowerRequest->u.SystemPowerRequest.SystemPowerState;

    //
    // If we are going to S0, then tell the interperter to resume
    //
    if (systemState == PowerSystemWorking) {

        AMLIResumeInterpreter();

    }

    //
    // Call the completion routine
    //
    ACPIDeviceCompleteInterpreterRequest(
        PowerRequest
        );

    //
    // We are successfull
    //
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase0SystemSubPhase1

NTSTATUS
ACPIDevicePowerProcessPhase1DeviceSubPhase1(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    Any device that is going to transition to the D3 state should have
    have it resources disabled. This function detects if this is the
    case and runs the _DIS object, if appropriate

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    DEVICE_POWER_STATE  deviceState;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ              disObject       = NULL;
    ULONG               flags;

    //
    // Get some data from the request
    //
    deviceState = PowerRequest->u.DevicePowerRequest.DevicePowerState;
    flags       = PowerRequest->u.DevicePowerRequest.Flags;

    //
    // We are going to need to fake the value from an _STA, so lets do
    // that now
    //
    RtlZeroMemory( &(PowerRequest->ResultData), sizeof(OBJDATA) );
    PowerRequest->ResultData.dwDataType = OBJTYPE_INTDATA;
    PowerRequest->ResultData.uipDataValue = 0;


    //
    // Decide what the next subphase will be. The rule here is that if we
    // are going to D0, then we can skip to Step 3, otherwise, we must go
    // to Step 1. We also skip to step3 if we are on the hibernate path
    //
    if (deviceState == PowerDeviceD0 ||
        (flags & DEVICE_REQUEST_LOCK_HIBER) ) {

        PowerRequest->NextWorkDone = WORK_DONE_STEP_3;
        goto ACPIDevicePowerProcessPhase1DeviceSubPhase1Exit;

    } else if (deviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        PowerRequest->NextWorkDone = WORK_DONE_STEP_2;
        goto ACPIDevicePowerProcessPhase1DeviceSubPhase1Exit;

    } else {

        PowerRequest->NextWorkDone = WORK_DONE_STEP_1;
        if (deviceState != PowerDeviceD3) {

            goto ACPIDevicePowerProcessPhase1DeviceSubPhase1Exit;

        }
    }

    //
    // See if the _DIS object exists
    //
    disObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        PACKED_DIS
        );
    if (disObject != NULL) {

        //
        // Lets run that method
        //
        status = AMLIAsyncEvalObject(
            disObject,
            NULL,
            0,
            NULL,
            ACPIDeviceCompleteGenericPhase,
            PowerRequest
            );

        //
        // If we got a pending back, then we should return now
        //
        if (status == STATUS_PENDING) {

            return status;

        }
    }

ACPIDevicePowerProcessPhase1DeviceSubPhase1Exit:

    //
    // Call the completion routine by brute force. Note that at this
    // point, we count everything as being SUCCESS
    //
    ACPIDeviceCompleteGenericPhase(
        disObject,
        status,
        NULL,
        PowerRequest
        );
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase1DeviceSubPhase1

NTSTATUS
ACPIDevicePowerProcessPhase1DeviceSubPhase2(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine runs the _PS1, _PS2, or _PS3 control methods

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    DEVICE_POWER_STATE  deviceState;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ              powerObject     = NULL;

    //
    // The next phase that we will go to is Step_2
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_2;

    //
    // Since we cannot get to this subphase when transitioning to D0, its
    // safe to just look for the object to run
    //
    deviceState = PowerRequest->u.DevicePowerRequest.DevicePowerState;
    powerObject = deviceExtension->PowerInfo.PowerObject[ deviceState ];

    //
    // If there is an object, then run the control method
    //
    if (powerObject != NULL) {

        status = AMLIAsyncEvalObject(
            powerObject,
            NULL,
            0,
            NULL,
            ACPIDeviceCompleteGenericPhase,
            PowerRequest
            );

        ACPIDevPrint( (
            ACPI_PRINT_POWER,
            deviceExtension,
            "(0x%08lx): ACPIDevicePowerProcessPhase1DeviceSubPhase2 "
            "= 0x%08lx\n",
            PowerRequest,
            status
            ) );

        //
        // If we cannot complete the work ourselves, we must stop now
        //
        if (status == STATUS_PENDING) {

            return status;

        }

    }

    //
    // Call the completion routine by brute force.
    //
    ACPIDeviceCompleteGenericPhase(
        powerObject,
        status,
        NULL,
        PowerRequest
        );
    return STATUS_SUCCESS;

} // ACPIPowerProcessPhase1DeviceSubPhase2

NTSTATUS
ACPIDevicePowerProcessPhase1DeviceSubPhase3(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine runs the _STA of the device to make sure that it has in
    fact been turned off

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    POBJDATA            resultData      = &(PowerRequest->ResultData);
    PNSOBJ              staObject       = NULL;
    PNSOBJ              acpiObject      = NULL;

    //
    // The next stage is STEP_3
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_3;

    //
    // We already have space allocate for the result of the _STA. Make
    // that there is no garbage present
    //
    RtlZeroMemory( resultData, sizeof(OBJDATA) );

    //
    // Is there an _STA object present on this device?
    //

    if (deviceExtension->Flags & DEV_PROP_DOCK) {

        ASSERT( deviceExtension->Dock.CorrospondingAcpiDevice );
        acpiObject = deviceExtension->Dock.CorrospondingAcpiDevice->AcpiObject;

    } else {

        acpiObject = deviceExtension->AcpiObject;
    }

    staObject = ACPIAmliGetNamedChild(
        acpiObject,
        PACKED_STA
        );
    if (staObject != NULL) {

        status = AMLIAsyncEvalObject(
            staObject,
            resultData,
            0,
            NULL,
            ACPIDeviceCompleteGenericPhase,
            PowerRequest
            );
        ACPIDevPrint( (
            ACPI_PRINT_POWER,
            deviceExtension,
            "(0x%08lx): ACPIDevicePowerProcessPhase1DeviceSubPhase3 "
            "= 0x%08lx\n",
            PowerRequest,
            status
            ) );

    } else {

        //
        // Lets fake the data. Note that in this case we will pretend that
        // the value is 0x0, even though the spec says that the default
        // is (ULONG) - 1. The reason we are doing this is that in this
        // case we want to approximate the behaviour of the real _STA...
        //
        resultData->dwDataType = OBJTYPE_INTDATA;
        resultData->uipDataValue = STA_STATUS_PRESENT;
        status = STATUS_SUCCESS;

    }

    //
    // Do we have to call the completion routine ourselves?
    //
    if (status != STATUS_PENDING) {

        ACPIDeviceCompleteGenericPhase(
            staObject,
            status,
            NULL,
            PowerRequest
            );

    }

    //
    // Always return success
    //
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase1DeviceSubPhase3

NTSTATUS
ACPIDevicePowerProcessPhase1DeviceSubPhase4(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This function determines which device nodes need to be looked at. The
    generic rule is that we need to remember which nodes belong to a device
    that is either starting or stopping to use that node. Generally, these
    are the nodes in the current power state and the nodes in the desired
    power state

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    DEVICE_POWER_STATE      deviceState;
    KIRQL                   oldIrql;
    PACPI_DEVICE_POWER_NODE deviceNode      = NULL;
    PDEVICE_EXTENSION       deviceExtension = PowerRequest->DeviceExtension;
    POBJDATA                resultData      = &(PowerRequest->ResultData);
    ULONG                   flags;

    //
    // Clear the result
    //
    AMLIFreeDataBuffs( resultData, 1 );
    RtlZeroMemory( resultData, sizeof(OBJDATA) );

    //
    // We cannot walk any data structures without holding a lock
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // First step is to find the list of nodes which are in use by this
    // device
    //
    deviceState = deviceExtension->PowerInfo.PowerState;
    if (deviceState >= PowerDeviceD0 && deviceState <= PowerDeviceD2) {

        //
        // In this case, we have to look at the current and the desired
        // device states only
        //
        deviceNode = deviceExtension->PowerInfo.PowerNode[ deviceState ];

        //
        // Next step is to look at all the nodes and mark the power objects
        // as requiring an update
        //
        while (deviceNode != NULL) {

            InterlockedExchange(
                &(deviceNode->PowerNode->WorkDone),
                WORK_DONE_STEP_0
                );
            deviceNode = deviceNode->Next;

        }

        //
        // Now, we need to find the list of nodes which are going to be used
        //
        deviceState = PowerRequest->u.DevicePowerRequest.DevicePowerState;
        if (deviceState >= PowerDeviceD0 && deviceState <= PowerDeviceD2) {

            deviceNode = deviceExtension->PowerInfo.PowerNode[ deviceState ];

        }

        //
        // Next step is to look at all the nodes and mark the power objects
        // as requiring an update
        //
        while (deviceNode != NULL) {

            InterlockedExchange(
                &(deviceNode->PowerNode->WorkDone),
                WORK_DONE_STEP_0
                );
            deviceNode = deviceNode->Next;

        }

    } else {

        //
        // In this case, we have to look at all possible Device states
        //
        for (deviceState = PowerDeviceD0;
             deviceState < PowerDeviceD3;
             deviceState++) {

             deviceNode = deviceExtension->PowerInfo.PowerNode[ deviceState ];

             //
             // Next step is to look at all the nodes and mark the power objects
             // as requiring an update
             //
             while (deviceNode != NULL) {

                 InterlockedExchange(
                     &(deviceNode->PowerNode->WorkDone),
                     WORK_DONE_STEP_0
                     );
                 deviceNode = deviceNode->Next;

             }

        }

        //
        // This is the device state that we will go to
        //
        deviceState = PowerRequest->u.DevicePowerRequest.DevicePowerState;

    }

    //
    // If this is a request on the hibernate path, the mark all the nodes
    // for the D0 as being required Hibernate nodes
    //
    flags = PowerRequest->u.DevicePowerRequest.Flags;
    if (flags & DEVICE_REQUEST_LOCK_HIBER) {

        deviceNode = deviceExtension->PowerInfo.PowerNode[ PowerDeviceD0 ];

        //
        // Next step is to look at all the nodes and mark the power objects
        // as requiring an update
        //
        while (deviceNode != NULL) {

            ACPIInternalUpdateFlags(
                &(deviceNode->PowerNode->Flags),
                (DEVICE_NODE_HIBERNATE_PATH | DEVICE_NODE_OVERRIDE_ON),
                FALSE
                );
            ACPIInternalUpdateFlags(
                &(deviceNode->PowerNode->Flags),
                DEVICE_NODE_OVERRIDE_OFF,
                TRUE
                );
            InterlockedExchange(
                &(deviceNode->PowerNode->WorkDone),
                WORK_DONE_STEP_0
                );
            deviceNode = deviceNode->Next;

        }

    } else if (flags & DEVICE_REQUEST_UNLOCK_HIBER) {

        deviceNode = deviceExtension->PowerInfo.PowerNode[ PowerDeviceD0 ];
        //
        // Next step is to look at all the nodes and mark the power objects
        // as requiring an update
        //
        while (deviceNode != NULL) {

            ACPIInternalUpdateFlags(
                &(deviceNode->PowerNode->Flags),
                (DEVICE_NODE_HIBERNATE_PATH | DEVICE_NODE_OVERRIDE_ON),
                TRUE
                );
            InterlockedExchange(
                &(deviceNode->PowerNode->WorkDone),
                WORK_DONE_STEP_0
                );
            deviceNode = deviceNode->Next;

        }


    }

    //
    // Remember the desired state
    //
    deviceExtension->PowerInfo.DesiredPowerState = deviceState;

    //
    // Also, consider that the device is now in an unknown state ---
    // if we fail something, the is the power state that we will be left
    // at
    //
    deviceExtension->PowerInfo.PowerState = PowerDeviceUnspecified;

    //
    // We no longer need the PowerLock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Done
    //
    ACPIDeviceCompleteCommon( &(PowerRequest->WorkDone), WORK_DONE_COMPLETE );
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDevicePowerProcessPhase2SystemSubPhase1(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine updates the PowerObject references so that we can run
    _ON or _OFF methods as needed

    This also cause _WAK() to be run on the system

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    BOOLEAN                 restart         = FALSE;
    NTSTATUS                status          = STATUS_SUCCESS;
    OBJDATA                 objData;
    PACPI_DEVICE_POWER_NODE deviceNode      = NULL;
    PACPI_POWER_DEVICE_NODE powerNode       = NULL;
    PDEVICE_EXTENSION       deviceExtension = PowerRequest->DeviceExtension;
    PLIST_ENTRY             deviceList;
    PLIST_ENTRY             powerList;
    PNSOBJ                  sleepObject     = NULL;
    POWER_ACTION            systemAction;
    SYSTEM_POWER_STATE      systemState;
    SYSTEM_POWER_STATE      wakeFromState;
    ULONG                   hibernateCount;

    //
    // The next stage after this one is STEP_1
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_1;

    //
    // Get the desired system state
    //
    systemState = PowerRequest->u.SystemPowerRequest.SystemPowerState;
    systemAction = PowerRequest->u.SystemPowerRequest.SystemPowerAction;

    //
    // Is the system restarting?
    //
    restart = ( (systemState == PowerSystemShutdown) &&
        (systemAction == PowerActionShutdownReset) );

    //
    // We need to hold this lock before we can walk this list
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Get the first power node
    //
    powerList = AcpiPowerNodeList.Flink;

    //
    // Walk the list and see which devices need to be turned on or
    // turned off
    //
    while (powerList != &AcpiPowerNodeList) {

        //
        // Obtain the power node from the listEntry
        //
        powerNode = CONTAINING_RECORD(
            powerList,
            ACPI_POWER_DEVICE_NODE,
            ListEntry
            );

        //
        // Next node
        //
        powerList = powerList->Flink;

        //
        // We need to walk the list of device nodes to see if any of
        // the devices are in the hibernate path.
        //
        deviceList = powerNode->DevicePowerListHead.Flink;
        while (deviceList != &(powerNode->DevicePowerListHead) ) {

            //
            // Obtain the devicenode from the list pointer
            //
            deviceNode = CONTAINING_RECORD(
                deviceList,
                ACPI_DEVICE_POWER_NODE,
                DevicePowerListEntry
                );

            //
            // Point to the next node
            //
            deviceList = deviceList->Flink;

            //
            // Grab the associated device extension
            //
            deviceExtension = deviceNode->DeviceExtension;

            //
            // Does the node belong on the hibernate path
            //
            hibernateCount = InterlockedCompareExchange(
                &(deviceExtension->HibernatePathCount),
                0,
                0
                );
            if (hibernateCount) {

                break;

            }

        }

        //
        // Mark the node as being in the hibernate path, or not, as the
        // case might be
        //
        ACPIInternalUpdateFlags(
            &(powerNode->Flags),
            DEVICE_NODE_HIBERNATE_PATH,
            (BOOLEAN) !hibernateCount
            );

        //
        // First check is to see if the node is on the hibernate path and
        // this is a hibernate request, or if the system is restarting
        //
        if ( (hibernateCount && systemState == PowerSystemHibernate) ||
             (restart == TRUE) ) {

            if (powerNode->Flags & DEVICE_NODE_OVERRIDE_OFF) {

                //
                // make sure that the Override Off flag is disabled
                //
                ACPIInternalUpdateFlags(
                    &(powerNode->Flags),
                    DEVICE_NODE_OVERRIDE_OFF,
                    TRUE
                    );

                //
                // Mark the node as requiring an update
                //
                InterlockedExchange(
                    &(powerNode->WorkDone),
                    WORK_DONE_STEP_0
                    );

            }

        } else {

            //
            // Does the node support the indicates system state?
            //
            if (powerNode->SystemLevel < systemState) {

                //
                // No --- we must disable it, but if we cannot always be on.
                //
                if ( !(powerNode->Flags & DEVICE_NODE_ALWAYS_ON) ) {

                    ACPIInternalUpdateFlags(
                        &(powerNode->Flags),
                        DEVICE_NODE_OVERRIDE_OFF,
                        FALSE
                        );

                }

                //
                // Mark the node as requiring an update
                //
                InterlockedExchange(
                    &(powerNode->WorkDone),
                    WORK_DONE_STEP_0
                    );

            } else if (powerNode->Flags & DEVICE_NODE_OVERRIDE_OFF) {

                //
                // Disable this flag
                //
                ACPIInternalUpdateFlags(
                    &(powerNode->Flags),
                    DEVICE_NODE_OVERRIDE_OFF,
                    TRUE
                    );

                //
                // Mark the node as requiring an update
                //
                InterlockedExchange(
                    &(powerNode->WorkDone),
                    WORK_DONE_STEP_0
                    );

            }

        }


    }

    //
    // Set the WakeFromState while we still hold the power lock.
    //
    wakeFromState = AcpiMostRecentSleepState;

    //
    // We don't need to hold lock anymore
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // We can only do the following if we are transitioning to the S0 state
    //
    if (systemState == PowerSystemWorking) {

        //
        // Always run the _WAK method (this clears the PTS(S5) if that is
        // the last thing we did, otherwise it is the proper action to take
        //
        sleepObject = ACPIAmliGetNamedChild(
            PowerRequest->DeviceExtension->AcpiObject->pnsParent,
            PACKED_WAK
            );

        //
        // We only try to evaluate a method if we found an object
        //
        if (sleepObject != NULL) {

            //
            // Remember that AMLI doesn't use our definitions, so we will
            // have to normalize the S value
            //
            RtlZeroMemory( &objData, sizeof(OBJDATA) );
            objData.dwDataType = OBJTYPE_INTDATA;
            objData.uipDataValue = ACPIDeviceMapACPIPowerState(
                wakeFromState
                );

            //
            // Safely run the control method
            //
            status = AMLIAsyncEvalObject(
                sleepObject,
                NULL,
                1,
                &objData,
                ACPIDeviceCompleteGenericPhase,
                PowerRequest
                );

            //
            // If we got STATUS_PENDING, then we cannot do any more work here.
            //
            if (status == STATUS_PENDING) {

                return status;

            }

        }

    }

    //
    // Always call the completion routine
    //
    ACPIDeviceCompleteGenericPhase(
        sleepObject,
        status,
        NULL,
        PowerRequest
        );

    //
    // Never return anything other then STATUS_SUCCESS
    //
    return STATUS_SUCCESS;

} // ACPIPowerProcessPhase2SystemSubPhase1

NTSTATUS
ACPIDevicePowerProcessPhase2SystemSubPhase2(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This phase is called after the _WAK method has been run

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    SYSTEM_POWER_STATE      systemState;

    //
    // The next stage is STEP_2
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_2;

    //
    // We need to make sure that the IRQ arbiter has been restored
    // if we are making an S0 transition
    //
    systemState = PowerRequest->u.SystemPowerRequest.SystemPowerState;
    if (systemState == PowerSystemWorking) {

        //
        // Restore the IRQ arbiter
        //
        status = IrqArbRestoreIrqRouting(
            ACPIDeviceCompleteGenericPhase,
            (PVOID) PowerRequest
            );
        if (status == STATUS_PENDING) {

            //
            // Do not do any more work here
            //
            return status;

        }

    }

    //
    // Call the next completion routine
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        status,
        NULL,
        PowerRequest
        );

    //
    // Always return success
    //
    return STATUS_SUCCESS;

} // ACPIDevicePowerProcessPhase2SystemSubPhase2

NTSTATUS
ACPIDevicePowerProcessPhase2SystemSubPhase3(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This phase is used to see if we need to re-run the _PSW for all the
    devices. We need to do this when we restore from the hibernate state

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    SYSTEM_POWER_STATE      systemState;
    SYSTEM_POWER_STATE      wakeFromState;

    //
    // The next stage is COMPLETE
    //
    PowerRequest->NextWorkDone = WORK_DONE_COMPLETE;

    //
    // If we just transitioned from Hibernate, then we must re-enable all
    // the wake devices
    //
    systemState = PowerRequest->u.SystemPowerRequest.SystemPowerState;

    //
    // Grab the current most recent sleep state and make sure to hold the
    // locks while doing so
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );
    wakeFromState = AcpiMostRecentSleepState;
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    if (systemState == PowerSystemWorking &&
        wakeFromState == PowerSystemHibernate) {

        //
        // Restore the IRQ arbiter
        //
        status = ACPIWakeRestoreEnables(
            ACPIWakeRestoreEnablesCompletion,
            PowerRequest
            );
        if (status == STATUS_PENDING) {

            //
            // Do not do any more work here
            //
            return status;

        }

    }

    //
    // Call the next completion routine
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        status,
        NULL,
        PowerRequest
        );

    //
    // Always return success
    //
    return STATUS_SUCCESS;

} // ACPIDevicePowerProcessPhase2SystemSubPhase3

NTSTATUS
ACPIDevicePowerProcessPhase3(
    VOID
    )
/*++

Routine Description:

    This routine ensures that the Power Resources are in sync

Arguments:

    NONE

Return Value:

    NTSTATUS

        - If any request is not marked as being complete, then STATUS_PENDING
          is returned, otherwise, STATUS_SUCCESS is returned

--*/
{
    BOOLEAN                 returnPending   = FALSE;
    NTSTATUS                status          = STATUS_SUCCESS;
    PACPI_DEVICE_POWER_NODE deviceNode;
    PACPI_POWER_DEVICE_NODE powerNode;
    PDEVICE_EXTENSION       deviceExtension;
    PLIST_ENTRY             deviceList;
    PLIST_ENTRY             powerList;
    ULONG                   useCounts;
    ULONG                   wakeCount;
    ULONG                   workDone;

    //
    // Grab the PowerLock that we need for this
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Grab the first node in the PowerNode list
    //
    powerList = AcpiPowerNodeList.Flink;

    //
    // Walk the list forward to device what to turn on
    //
    while (powerList != &AcpiPowerNodeList) {

        //
        // Look at the current power node
        //
        powerNode = CONTAINING_RECORD(
            powerList,
            ACPI_POWER_DEVICE_NODE,
            ListEntry
            );

        //
        // Next item in the list
        //
        powerList = powerList->Flink;

        //
        // Have we marked the node has having some potential work that
        // needs to be done?
        //
        workDone = InterlockedCompareExchange(
            &(powerNode->WorkDone),
            WORK_DONE_STEP_1,
            WORK_DONE_STEP_0
            );

        //
        // If we don't have any work to do, then loop back to the start
        //
        if (workDone != WORK_DONE_STEP_0) {

            continue;

        }

        //
        // We need to walk the list of device nodes to see if
        // any of the devices are in need of this power resource
        //
        useCounts = 0;
        deviceList = powerNode->DevicePowerListHead.Flink;
        while (deviceList != &(powerNode->DevicePowerListHead) ) {

            //
            // Obtain the deviceNode from the list pointer
            //
            deviceNode = CONTAINING_RECORD(
                deviceList,
                ACPI_DEVICE_POWER_NODE,
                DevicePowerListEntry
                );

            //
            // Point to the next node
            //
            deviceList = deviceList->Flink;

            //
            // Grab the associated device extension
            //
            deviceExtension = deviceNode->DeviceExtension;

            //
            // Grab the number of wake counts on the node
            //
            wakeCount = InterlockedCompareExchange(
                &(deviceExtension->PowerInfo.WakeSupportCount),
                0,
                0
                );

            //
            // Does the device node belong to the desired state? The
            // other valid state is if the node is required to wake the
            // device and we have functionality enabled.
            //
            if (deviceExtension->PowerInfo.DesiredPowerState ==
                deviceNode->AssociatedDeviceState ||
                (wakeCount && deviceNode->WakePowerResource) ) {

                useCounts++;

            }

        }

        //
        // Set the number of use counts in the PowerResource
        //
        InterlockedExchange(
            &(powerNode->UseCounts),
            useCounts
            );

        //
        // See if the override bits are set properly
        //
        if ( (powerNode->Flags & DEVICE_NODE_TURN_OFF) ) {

            //
            // Do not run anything
            //
            continue;

        }
        if ( !(powerNode->Flags & DEVICE_NODE_TURN_ON) &&
             useCounts == 0 ) {

            //
            // Do not run anything
            //
            continue;

        }

        //
        // We are going to do some work on this node, so mark it as
        // such, so that we don't accidently run the _OFF method for
        // this device
        //
        workDone = InterlockedCompareExchange(
            &(powerNode->WorkDone),
            WORK_DONE_PENDING,
            WORK_DONE_STEP_1
            );

        //
        // We cannot hold the spin lock while we eval the method
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

        //
        // Evaluate the method to turn this node on
        //
        status = AMLIAsyncEvalObject(
            powerNode->PowerOnObject,
            NULL,
            0,
            NULL,
            ACPIDeviceCompletePhase3On,
            powerNode
            );

        //
        // Let the world know
        //
        ACPIPrint( (
            ACPI_PRINT_POWER,
            "ACPIDevicePowerProcessPhase3: PowerNode: 0x%08lx ON = 0x%08lx\n",
            powerNode,
            status
            ) );

        if (status != STATUS_PENDING) {

            //
            // Fake a call to the callback
            //
            ACPIDeviceCompletePhase3On(
                powerNode->PowerOnObject,
                status,
                NULL,
                powerNode
                );

        } else {

            //
            // Remember that a function returned Pending
            //
            returnPending = TRUE;

        }

        //
        // Reacquire the spinlock so that we can loop again
        //
        KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    } // while

    //
    // Grab the blink so that we can start walking the list backward
    //
    powerList = AcpiPowerNodeList.Blink;

    //
    // Walk the list backward
    //
    while (powerList != &AcpiPowerNodeList) {

        //
        // Look at the current power node
        //
        powerNode = CONTAINING_RECORD(
            powerList,
            ACPI_POWER_DEVICE_NODE,
            ListEntry
            );

        //
        // Next item in the list
        //
        powerList = powerList->Blink;

        //
        // Have we marked the node has having some potential work that
        // needs to be done?
        //
        workDone = InterlockedCompareExchange(
            &(powerNode->WorkDone),
            WORK_DONE_PENDING,
            WORK_DONE_STEP_1
            );

        //
        // To do work on this node, we need to see WORK_DONE_STEP_1
        //
        if (workDone != WORK_DONE_STEP_1) {

            //
            // While we are here, we can check to see if the request is
            // complete --- if it isn't then we must return STATUS_PENDING
            //
            if (workDone != WORK_DONE_COMPLETE) {

                returnPending = TRUE;

            }
            continue;

        }

        //
        // Release the spinlock since we cannot own it while we call
        // the interpreter
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

        //
        // If we are here, we *must* run the _OFF method
        //
        status = AMLIAsyncEvalObject(
            powerNode->PowerOffObject,
            NULL,
            0,
            NULL,
            ACPIDeviceCompletePhase3Off,
            powerNode
            );

        //
        // Let the world know
        //
        ACPIPrint( (
            ACPI_PRINT_POWER,
            "ACPIDevicePowerProcessPhase3: PowerNode: 0x%08lx OFF = 0x%08lx\n",
            powerNode,
            status
            ) );

        if (status != STATUS_PENDING) {

            //
            // Fake a call to the callback
            //
            ACPIDeviceCompletePhase3Off(
                powerNode->PowerOffObject,
                status,
                NULL,
                powerNode
                );

        } else {

            //
            // Remember that a function returned Pending
            //
            returnPending = TRUE;

        }

        //
        // Reacquire the spinlock so that we can loop again
        //
        KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    }

    //
    // We no longer need the spin lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // Do we need to return status pending?
    //
    return (returnPending ? STATUS_PENDING : STATUS_SUCCESS);

} // ACPIPowerProcessPhase3

NTSTATUS
ACPIDevicePowerProcessPhase4(
    VOID
    )
/*++

Routine Description:

    This routine looks at the all the PowerNodes again and determines wether
    or not to fail a given request by wether or not a powernode failed to
    go to the desired state

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    PACPI_DEVICE_POWER_NODE deviceNode;
    PACPI_POWER_DEVICE_NODE powerNode;
    PACPI_POWER_REQUEST     powerRequest;
    PDEVICE_EXTENSION       deviceExtension;
    PLIST_ENTRY             listEntry = AcpiPowerPhase4List.Flink;
    PLIST_ENTRY             nodeList;
    PLIST_ENTRY             requestList;

    //
    // Now, we have to look at all the power nodes, and clear the fail flags
    // This has to be done under spinlock protection
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    listEntry = AcpiPowerNodeList.Flink;
    while (listEntry != &AcpiPowerNodeList) {

        powerNode = CONTAINING_RECORD(
            listEntry,
            ACPI_POWER_DEVICE_NODE,
            ListEntry
            );
        listEntry = listEntry->Flink;

        if (powerNode->Flags & DEVICE_NODE_FAIL) {

            //
            // Clear the failure flag
            //
            ACPIInternalUpdateFlags(
                &(powerNode->Flags),
                DEVICE_NODE_FAIL,
                TRUE
                );

            //
            // Loop for all the device extensions
            //
            nodeList = powerNode->DevicePowerListHead.Flink;
            while (nodeList != &(powerNode->DevicePowerListHead)) {

                deviceNode = CONTAINING_RECORD(
                    nodeList,
                    ACPI_DEVICE_POWER_NODE,
                    DevicePowerListEntry
                    );
                nodeList = nodeList->Flink;

                //
                // We must do the next part not under spinlock
                //
                KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

                //
                // Grab the device extension associated with this node
                //
                deviceExtension = deviceNode->DeviceExtension;

                //
                // Loop on all the requests
                //
                requestList = AcpiPowerPhase4List.Flink;
                while (requestList != &AcpiPowerPhase4List) {

                    powerRequest = CONTAINING_RECORD(
                        requestList,
                        ACPI_POWER_REQUEST,
                        ListEntry
                        );
                    requestList = requestList->Flink;

                    //
                    // Do we have a match?
                    //
                    if (powerRequest->DeviceExtension != deviceExtension) {

                        //
                        // No? Then continue
                        //
                        continue;

                    }

                    //
                    // Yes? Then fail the request
                    //
                    powerRequest->Status = STATUS_ACPI_POWER_REQUEST_FAILED;
                    ACPIDeviceCompleteRequest( powerRequest );

                }

                //
                // Reacquire the lock
                //
                KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

            }

        }

    }

    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // Always return success
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIDevicePowerProcessPhase5DeviceSubPhase1(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine runs the _PS0 control method

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    BOOLEAN                 nodeOkay        = TRUE;
    DEVICE_POWER_STATE      deviceState;
    KIRQL                   oldIrql;
    NTSTATUS                status          = STATUS_SUCCESS;
    PACPI_DEVICE_POWER_NODE deviceNode      = NULL;
    PACPI_POWER_DEVICE_NODE powerNode       = NULL;
    PACPI_POWER_INFO        powerInfo;
    PDEVICE_EXTENSION       deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ                  powerObject     = NULL;

    //
    // What is our desired device state?
    //
    deviceState = PowerRequest->u.DevicePowerRequest.DevicePowerState;

    //
    // Grab the power Information structure
    //
    powerInfo = &(deviceExtension->PowerInfo);

    //
    // Decide what the next subphase will be. The rule here is that if we
    // are not going to D0, then we can skip to STEP_2, otherwise, we must go
    // to STEP_1
    //
    if (deviceState != PowerDeviceD0) {

        PowerRequest->NextWorkDone = WORK_DONE_STEP_2;

    } else {

        PowerRequest->NextWorkDone = WORK_DONE_STEP_1;

        //
        // We cannot walk any data structures without holding a lock
        //
        KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

        //
        // Look at the device nodes for D0
        //
        deviceNode = powerInfo->PowerNode[PowerDeviceD0];

        //
        // Next step is to look at all the nodes and mark the power objects
        // as requiring an update
        //
        while (deviceNode != NULL) {

            //
            // Grab the associated power node
            //
            powerNode = deviceNode->PowerNode;

            //
            // Make sure that the power node is in the ON state
            //
            if ( !(powerNode->Flags & DEVICE_NODE_ON) ) {

                nodeOkay = FALSE;
                break;

            }

            //
            // Look at the next node
            //
            deviceNode = deviceNode->Next;

        }

        //
        // We are done with the lock
        //
        KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

        //
        // Are all the nodes in the correct state?
        //
        if (!nodeOkay) {

            status = STATUS_UNSUCCESSFUL;

        } else {

            //
            // Otherwise, see if there is a _PS0 method to run
            //
            powerObject = powerInfo->PowerObject[ deviceState ];

            //
            // If there is an object, then run the control method
            //
            if (powerObject != NULL) {

                status = AMLIAsyncEvalObject(
                    powerObject,
                    NULL,
                    0,
                    NULL,
                    ACPIDeviceCompleteGenericPhase,
                    PowerRequest
                    );

            }

            ACPIDevPrint( (
                ACPI_PRINT_POWER,
                deviceExtension,
                "(0x%08lx): ACPIDevicePowerProcessPhase5DeviceSubPhase1 "
                "= 0x%08lx\n",
                PowerRequest,
                status
                ) );

            //
            // If we cannot complete the work ourselves, we must stop now
            //
            if (status == STATUS_PENDING) {

                return status;

            } else {

                status = STATUS_SUCCESS;
            }

        }

    }

    //
    // Call the completion routine by brute force. Note that at this
    // point, we count everything as being SUCCESS
    //
    ACPIDeviceCompleteGenericPhase(
        powerObject,
        status,
        NULL,
        PowerRequest
        );
    return STATUS_SUCCESS;

} // ACPIPowerProcessPhase5DeviceSubPhase1

NTSTATUS
ACPIDevicePowerProcessPhase5DeviceSubPhase2(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine runs the _SRS control method

    Note: that we only come down this path if we are transitioning to D0

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    DEVICE_POWER_STATE      deviceState     =
        PowerRequest->u.DevicePowerRequest.DevicePowerState;
    KIRQL                   oldIrql;
    NTSTATUS                status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION       deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ                  srsObject       = NULL;

    //
    // The next phase is STEP_2
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_2;

    if (!(deviceExtension->Flags & DEV_PROP_NO_OBJECT)) {

        //
        // Is there an _SRS object present on this device?
        //
        srsObject = ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_SRS
            );
    }

    if (srsObject != NULL) {

        //
        // We must hold this lock while we run the Control Method.
        //
        // Note: Because the interpreter will make a copy of the data
        // arguments passed to it, we only need to hold the lock as long
        // as it takes for the interpreter to return
        //
        KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
        if (deviceExtension->PnpResourceList != NULL) {

            //
            // Evalute the method
            //
            status = AMLIAsyncEvalObject(
                srsObject,
                NULL,
                1,
                deviceExtension->PnpResourceList,
                ACPIDeviceCompleteGenericPhase,
                PowerRequest
                );

            ACPIDevPrint( (
                ACPI_PRINT_POWER,
                deviceExtension,
                "(0x%08lx): ACPIDevicePowerProcessPhase5DeviceSubPhase2 "
                "= 0x%08lx\n",
                PowerRequest,
                status
                ) );

        }

        //
        // Mo longer need the lock
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

        if (status == STATUS_PENDING) {

            return status;

        }

    } else {

        //
        // Consider the request successfull
        //
        status = STATUS_SUCCESS;

    }

    //
    // Call the completion routine brute force
    //
    ACPIDeviceCompleteGenericPhase(
        srsObject,
        status,
        NULL,
        PowerRequest
        );

    //
    // Always return success
    //
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase5DeviceSubPhase2

NTSTATUS
ACPIDevicePowerProcessPhase5DeviceSubPhase3(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine enables or disables the lock on the device

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    DEVICE_POWER_STATE  deviceState;
    NTSTATUS            status          = STATUS_SUCCESS;
    OBJDATA             objData;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ              lckObject       = NULL;
    ULONG               flags;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(%#08lx): ACPIDevicePowerProcessPhase5DeviceSubPhase4\n",
        PowerRequest
        ) );

    //
    // What is our desired device state and action?
    //
    deviceState = PowerRequest->u.DevicePowerRequest.DevicePowerState;
    flags       = PowerRequest->u.DevicePowerRequest.Flags;

    //
    // If we aren't going to D0, then skip to the end
    //
    if (deviceState != PowerDeviceD0) {

        //
        // The next stage is STEP_5
        //
        PowerRequest->NextWorkDone = WORK_DONE_STEP_5;

    } else {

        //
        // The next stage is STEP_3
        //
        PowerRequest->NextWorkDone = WORK_DONE_STEP_3;

    }

    if (deviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        goto ACPIDevicePowerProcessPhase5DeviceSubPhase3Exit;

    }

    //
    // Is there an _LCK object present on this device?
    //
    lckObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        PACKED_LCK
        );

    if (lckObject == NULL) {

        goto ACPIDevicePowerProcessPhase5DeviceSubPhase3Exit;

    }

    //
    // Initialize the argument that we will pass to the function
    //
    RtlZeroMemory( &objData, sizeof(OBJDATA) );
    objData.dwDataType = OBJTYPE_INTDATA;

    //
    // Look at the flags and see if we should lock or unlock the device
    //
    if (flags & DEVICE_REQUEST_LOCK_DEVICE) {

        objData.uipDataValue = 1; // Lock the device

    } else if (flags & DEVICE_REQUEST_UNLOCK_DEVICE) {

        objData.uipDataValue = 0; // Unlock the device

    } else {

        goto ACPIDevicePowerProcessPhase5DeviceSubPhase3Exit;

    }

    //
    // Run the control method now
    //
    status = AMLIAsyncEvalObject(
        lckObject,
        NULL,
        1,
        &objData,
        ACPIDeviceCompleteGenericPhase,
        PowerRequest
        );
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase5DeviceSubPhase3 "
        "= 0x%08lx\n",
        PowerRequest,
        status
        ) );

ACPIDevicePowerProcessPhase5DeviceSubPhase3Exit:

    //
    // Do we have to call the completion routine ourselves?
    //
    if (status != STATUS_PENDING) {

        ACPIDeviceCompleteGenericPhase(
            lckObject,
            status,
            NULL,
            PowerRequest
            );

    }

    //
    // Always return success
    //
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase5DeviceSubPhase3

NTSTATUS
ACPIDevicePowerProcessPhase5DeviceSubPhase4(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine runs the _STA control method

    Note: that we only come down this path if we are transitioning to D0

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    POBJDATA            resultData      = &(PowerRequest->ResultData);

    //
    // The next phase is STEP_4
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_4;

    //
    // Make sure to initialize the structure. Since we are using the
    // objdata structure in request, we need to make sure that it will
    // look like something that the interpreter will understand
    //
    RtlZeroMemory( resultData, sizeof(OBJDATA) );

    //
    // Get the status of the device
    //
    status = ACPIGetDeviceHardwarePresenceAsync(
        deviceExtension,
        ACPIDeviceCompleteGenericPhase,
        PowerRequest,
        &(resultData->uipDataValue),
        &(resultData->dwDataLen)
        );
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase5DeviceSubPhase4 "
        "= 0x%08lx\n",
        PowerRequest,
        status
        ) );
    if (status == STATUS_PENDING) {

        return status;

    }

    //
    // Call the completion routine ourselves
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        status,
        NULL,
        PowerRequest
        );

    //
    // Always return success
    //
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase5DeviceSubPhase4

NTSTATUS
ACPIDevicePowerProcessPhase5DeviceSubPhase5(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This is the where we look at the device state.

Arguments:

    PowerRequest    - The request we are currently handling

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    POBJDATA            resultData = &(PowerRequest->ResultData);

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase5DeviceSubPhase5\n",
        PowerRequest
        ) );

    //
    // The next phase is STEP_5
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_5;

    //
    // First things first --- we just ran _STA (or faked it), so we
    // must check the return data
    //
    if (!(resultData->uipDataValue & STA_STATUS_PRESENT) ||
        !(resultData->uipDataValue & STA_STATUS_WORKING_OK) ||
        ( !(resultData->uipDataValue & STA_STATUS_ENABLED) &&
          !(deviceExtension->Flags & DEV_TYPE_FILTER) ) ) {

        //
        // This device is not working
        //
        PowerRequest->Status = STATUS_INVALID_DEVICE_STATE;
        ACPIDeviceCompleteCommon(
            &(PowerRequest->WorkDone),
            WORK_DONE_FAILURE
            );
        return STATUS_SUCCESS;

    }

    //
    // We don't clear the result or do anything on the resultData structure
    // because we only used some of its storage --- the entire structure
    // is not valid. However, just to be safe, we will zero everything out
    //
    RtlZeroMemory( resultData, sizeof(OBJDATA) );

    //
    // Call the completion routine by brute force. Note that at this
    // point, we count everything as being SUCCESS
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        STATUS_SUCCESS,
        NULL,
        PowerRequest
        );

    //
    // Always return success
    //
    return STATUS_SUCCESS;

} // ACPIDevicePowerProcessPhase5DeviceSubPhase5

NTSTATUS
ACPIDevicePowerProcessPhase5DeviceSubPhase6(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This is the final routine in the device path. This routines
    determines if everything is okay and updates the system book-keeping.

Arguments:

    PowerRequest    - The request we are currently handling

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    POBJDATA            resultData      = &(PowerRequest->ResultData);
    POWER_STATE         state;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase5DeviceSubPhase6\n",
        PowerRequest
        ) );

    //
    // We need a spinlock to touch these values
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Update the current PowerState with the requested PowerState
    //
    deviceExtension->PowerInfo.PowerState =
        deviceExtension->PowerInfo.DesiredPowerState;

    //
    // We also need to store the new device state so that we can notify
    // the system
    //
    state.DeviceState = deviceExtension->PowerInfo.PowerState;

    //
    // Remember the device object
    //
    deviceObject = deviceExtension->DeviceObject;

    //
    // Just release the spin lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // If this deviceExtension has an associated deviceObject, then
    // we had better tell the system about which state we are in
    //
    if (deviceObject != NULL) {

        //
        // Notify the system
        //
        PoSetPowerState(
            deviceObject,
            DevicePowerState,
            state
            );

    }

    //
    // Make sure that we set the current status in the PowerRequest
    // to indicate what happened
    //
    PowerRequest->Status = STATUS_SUCCESS;

    //
    // We are done
    //
    ACPIDeviceCompleteCommon( &(PowerRequest->WorkDone), WORK_DONE_COMPLETE );

    //
    // Always return success
    //
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase5DeviceSubPhase6

NTSTATUS
ACPIDevicePowerProcessPhase5SystemSubPhase1(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine runs the _PTS, or _WAK method

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    OBJDATA             objData;
    PACPI_POWER_INFO    powerInfo;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ              sleepObject     = NULL;
    SYSTEM_POWER_STATE  systemState     =
        PowerRequest->u.SystemPowerRequest.SystemPowerState;

    //
    // The next phase is STEP_1
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_1;

    //
    // If we are going back to the working state, then don't run any _PTS
    // code
    //
    if (systemState != PowerSystemWorking) {

        //
        // First step it to initialize the objData so that we can remember
        // what arguments we want to pass to the AML Interpreter
        //
        RtlZeroMemory( &objData, sizeof(OBJDATA) );
        objData.dwDataType = OBJTYPE_INTDATA;

        //
        // Obtain the correct NameSpace object to run
        //
        sleepObject = ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject->pnsParent,
            PACKED_PTS
            );

        //
        // We only try to evaluate a method if we found an object
        //
        if (sleepObject != NULL) {

            //
            // Remember that AMLI doesn't use our definitions, so we will
            // have to normalize the S value
            //
            objData.uipDataValue = ACPIDeviceMapACPIPowerState( systemState );

            //
            // Safely run the control method
            //
            status = AMLIAsyncEvalObject(
                sleepObject,
                NULL,
                1,
                &objData,
                ACPIDeviceCompleteGenericPhase,
                PowerRequest
                );

            //
            // If we got STATUS_PENDING, then we cannot do any more work here.
            //
            if (status == STATUS_PENDING) {

                return status;

            }

        }

    }

    //
    // Call the completion routine
    //
    ACPIDeviceCompleteGenericPhase(
        sleepObject,
        status,
        NULL,
        PowerRequest
        );

    //
    // We are successfull
    //
    return STATUS_SUCCESS;

} // ACPIPowerProcessPhase5SystemSubPhase1

NTSTATUS
ACPIDevicePowerProcessPhase5SystemSubPhase2(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine runs the _SST method

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    OBJDATA             objData;
    PACPI_POWER_INFO    powerInfo;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ              sstObject       = NULL;
    SYSTEM_POWER_STATE  systemState     =
        PowerRequest->u.SystemPowerRequest.SystemPowerState;

    //
    // The next phase is STEP_2
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_2;

    //
    // First step it to initialize the objData so that we can remember
    // what arguments we want to pass to the AML Interpreter
    //
    RtlZeroMemory( &objData, sizeof(OBJDATA) );
    objData.dwDataType = OBJTYPE_INTDATA;

    //
    // Obtain the correct NameSpace object to run
    //
    sstObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject->pnsParent,
        PACKED_SI
        );
    if (sstObject != NULL) {

        sstObject = ACPIAmliGetNamedChild(
            sstObject,
            PACKED_SST
            );

    }

    //
    // We only try to evaluate a method if we found an object
    //
    if (sstObject != NULL) {

        switch (systemState) {
            case PowerSystemWorking:
                objData.uipDataValue = 1;
                break;

            case PowerSystemHibernate:
                objData.uipDataValue = 4;
                break;

            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
            case PowerSystemSleeping3:
                objData.uipDataValue = 3;
                break;

            default:
                objData.uipDataValue = 0;

        }

        //
        // Safely run the control method
        //
        status = AMLIAsyncEvalObject(
            sstObject,
            NULL,
            1,
            &objData,
            ACPIDeviceCompleteGenericPhase,
            PowerRequest
            );

        //
        // If we got STATUS_PENDING, then we cannot do any more work here.
        //
        if (status == STATUS_PENDING) {

            return status;

        }

    } else {

        //
        // Consider the request successfull
        //
        status = STATUS_SUCCESS;

    }

    //
    // Call the completion routine
    //
    ACPIDeviceCompleteGenericPhase(
        sstObject,
        status,
        NULL,
        PowerRequest
        );

    //
    // We are successfull
    //
    return STATUS_SUCCESS;

} // ACPIPowerProcessPhase5SystemSubPhase2

NTSTATUS
ACPIDevicePowerProcessPhase5SystemSubPhase3(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine will pause the interpreter if requird

Arguments:

    PowerRequest    - The request we are currently processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    SYSTEM_POWER_STATE  systemState;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase5SystemSubPhase3\n",
        PowerRequest
        ) );

    //
    // The next phase is STEP_3
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_3;

    //
    // Fetch the target system state
    //
    systemState = PowerRequest->u.SystemPowerRequest.SystemPowerState;

    //
    // If we are going to a system state other than S0, then we need to pause
    // the interpreter. After this call completes, no one can execute a control
    // method
    //
    if (systemState != PowerSystemWorking) {

        status = AMLIPauseInterpreter(
            ACPIDeviceCompleteInterpreterRequest,
            PowerRequest
            );
        if (status == STATUS_PENDING) {

            return status;

        }

    }

    //
    // Call the completion routine
    //
    ACPIDeviceCompleteInterpreterRequest(
        PowerRequest
        );

    //
    // We are successfull
    //
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase5SystemSubPhase3

NTSTATUS
ACPIDevicePowerProcessPhase5SystemSubPhase4(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This is the final routine in the system path. It updates the bookkeeping

Arguments:

    PowerRequest    - The request we are currently processing

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PDEVICE_OBJECT      deviceObject;
    POWER_STATE         state;
    SYSTEM_POWER_STATE  systemState;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase5SystemSubPhase4\n",
        PowerRequest
        ) );

    //
    // Fetch the target system state
    //
    systemState = PowerRequest->u.SystemPowerRequest.SystemPowerState;

    //
    // Grab the spinlock
    //
    IoAcquireCancelSpinLock( &oldIrql );
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Remember this as being our most recent sleeping state
    //
    AcpiMostRecentSleepState = systemState;

    //
    // Update the Gpe Wake Bits
    //
    ACPIWakeRemoveDevicesAndUpdate( NULL, NULL );

    //
    // Fetch the associated device object
    //
    deviceObject = deviceExtension->DeviceObject;

    //
    // We are done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
    IoReleaseCancelSpinLock( oldIrql );

    //
    // Is there an ACPI device object?
    //
    if (deviceObject != NULL) {

        //
        // Notify the system of the new S state
        //
        state.SystemState = systemState;
        PoSetPowerState(
            deviceObject,
            SystemPowerState,
            state
            );

    }

    //
    // Make sure that we set the current status in the PowerRequest
    // to indicate what happened.
    //
    PowerRequest->Status = STATUS_SUCCESS;

    //
    // Finally, we mark the power request has having had all of its works
    // done
    //
    ACPIDeviceCompleteCommon( &(PowerRequest->WorkDone), WORK_DONE_COMPLETE );
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase5SystemSubPhase4

NTSTATUS
ACPIDevicePowerProcessPhase5WarmEjectSubPhase1(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This is the method that runs the _EJx method appropriate for this
    device

Arguments:

    PowerRequest    - The request we are currently processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    OBJDATA             objData;
    PACPI_POWER_INFO    powerInfo;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ              ejectObject     = NULL;
    SYSTEM_POWER_STATE  ejectState      =
        PowerRequest->u.EjectPowerRequest.EjectPowerState;
    ULONG               ejectNames[]    = { 0, 0, PACKED_EJ1, PACKED_EJ2,
                                          PACKED_EJ3, PACKED_EJ4, 0 };
    ULONG               flags;

    //
    // The next phase is STEP_1 if we have profile work to do, otherwise we're
    // done.
    //
    flags = PowerRequest->u.EjectPowerRequest.Flags;

    PowerRequest->NextWorkDone = (flags & DEVICE_REQUEST_UPDATE_HW_PROFILE) ?
        WORK_DONE_STEP_1 :
        WORK_DONE_COMPLETE;

    //
    // Obtain the correct NameSpace object to run
    //
    ejectObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        ejectNames[ejectState]
        );

    //
    // If we didn't find the object, then something terrible happened
    // and we cannot continue
    //
    if (ejectObject == NULL) {

        ACPIInternalError( ACPI_DEVPOWER );

    }

    //
    // Kiss the device goodbye
    //
    status = ACPIGetNothingEvalIntegerAsync(
        deviceExtension,
        ejectNames[ejectState],
        1,
        ACPIDeviceCompleteGenericPhase,
        PowerRequest
        );
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(%0x%08lx) : ACPIDevicePowerProcessPhase5WarmEjectSubPhase1 = %08lx\n",
        PowerRequest,
        status
        ) );
    if (status == STATUS_PENDING) {

        return status;

    }

    //
    // Call the completion routine by brute force. Note that at this
    // point, we count everything as being SUCCESS
    //
    ACPIDeviceCompleteGenericPhase(
        ejectObject,
        status,
        NULL,
        PowerRequest
        );
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDevicePowerProcessPhase5WarmEjectSubPhase2(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This is the method that runs the _DCK method appropriate for this
    device

Arguments:

    PowerRequest    - The request we are currently processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    OBJDATA             objData;
    PACPI_POWER_INFO    powerInfo;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PDEVICE_EXTENSION   dockExtension;
    PNSOBJ              dckObject       = NULL;

    //
    // The next phase is WORK_DONE_COMPLETE
    //
    PowerRequest->NextWorkDone = WORK_DONE_COMPLETE;

    //
    // Obtain the correct NameSpace object to run
    //
    dckObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        PACKED_DCK
        );

    //
    // We might not find the _DCK method if this isn't a dock.
    //
    if (dckObject != NULL) {

        dockExtension = ACPIDockFindCorrespondingDock( deviceExtension );

        if (dockExtension &&
            (dockExtension->Dock.IsolationState == IS_ISOLATION_DROPPED)) {

            //
            // Kiss the dock connect goodbye. Note that we don't even care
            // about the return value because of the spec says that if it
            // is called with 0, it should be ignored
            //
            dockExtension->Dock.IsolationState = IS_ISOLATED;

            KdDisableDebugger();

            status = ACPIGetNothingEvalIntegerAsync(
                deviceExtension,
                PACKED_DCK,
                0,
                ACPIDeviceCompleteGenericPhase,
                PowerRequest
                );

            KdEnableDebugger();

            ACPIDevPrint( (
                ACPI_PRINT_POWER,
                deviceExtension,
                "(%0x%08lx) : ACPIDevicePowerProcessPhase5WarmEjectSubPhase2 = %08lx\n",
                PowerRequest,
                status
                ) );
            if (status == STATUS_PENDING) {

                return status;

            }

        }

    }

    //
    // Call the completion routine by brute force. Note that at this
    // point, we count everything as being SUCCESS
    //
    ACPIDeviceCompleteGenericPhase(
        dckObject,
        status,
        NULL,
        PowerRequest
        );
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDevicePowerProcessSynchronizeList(
    IN  PLIST_ENTRY             ListEntry
    )
/*++

Routine Description:

    This routine completes all of the synchronize requests...

Arguments:

    ListEntry       - The list we are currently walking

Return Value:

    NTSTATUS

        - If any request is not marked as being complete, then STATUS_PENDING
          is returned, otherwise, STATUS_SUCCESS is returned

--*/
{
    NTSTATUS                status          = STATUS_SUCCESS;
    PACPI_POWER_REQUEST     powerRequest;
    PLIST_ENTRY             currentEntry    = ListEntry->Flink;
    PLIST_ENTRY             tempEntry;

    //
    // Look at all the items in the list
    //
    while (currentEntry != ListEntry) {

        //
        // Turn this into a device request
        //
        powerRequest = CONTAINING_RECORD(
            currentEntry,
            ACPI_POWER_REQUEST,
            ListEntry
            );

        //
        // Set the temporary pointer to the next element
        //
        tempEntry = currentEntry->Flink;

        //
        // We are done with the request
        //
        ACPIDeviceCompleteRequest(
            powerRequest
            );

        //
        // Grab the next entry
        //
        currentEntry = tempEntry;

    }

    //
    // Have we completed all of our work?
    //
    return (STATUS_SUCCESS);
} // ACPIDevicePowerProcessSynchronizeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\detect.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    detect.c

Abstract:

    This module contains the detector for the NT driver.

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July 7, 1997    - Complete rewrite

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIDetectCouldExtensionBeInRelation)
#pragma alloc_text(PAGE, ACPIDetectFilterMatch)
#pragma alloc_text(PAGE, ACPIDetectPdoMatch)
#endif

//
// This is the root device extension
//
PDEVICE_EXTENSION       RootDeviceExtension;

//
// This is the pool that controls the allocations for Device Extensions
//
NPAGED_LOOKASIDE_LIST   DeviceExtensionLookAsideList;

//
// This is the list entry for all the surprise removed extensions
//
PDEVICE_EXTENSION       AcpiSurpriseRemovedDeviceExtensions[ACPI_MAX_REMOVED_EXTENSIONS];

//
// This is the index into the Surprise Removed Index array
//
ULONG                   AcpiSurpriseRemovedIndex;

//
// This is the lock that is required when modifying the links between
// the device extension structures
//
KSPIN_LOCK              AcpiDeviceTreeLock;

//
// This is the ulong that will remember which S states are supported by the
// system. The convention for using this ulong is that we 1 << SupportedState
// into it
//
ULONG                   AcpiSupportedSystemStates;

//
// This is where acpi will store the various overrides
//
ULONG                   AcpiOverrideAttributes;

//
// This is where acpi will store its registry path
//
UNICODE_STRING          AcpiRegistryPath;

//
// This is the processor revision string...
//
ANSI_STRING             AcpiProcessorString;


NTSTATUS
ACPIDetectCouldExtensionBeInRelation(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PDEVICE_RELATIONS   DeviceRelations,
    IN  BOOLEAN             RequireADR,
    IN  BOOLEAN             RequireHID,
    OUT PDEVICE_OBJECT      *PdoObject
    )
/*++

Routine Description:

    This routine takes a given extension and a set of relations and decides
    whether a the given extension *could* be represented in the relation
    list. This is done by seeing if any of the passed in relations match
    the hardware described by the extension. If the extension's object is
    already a member of the list, the corrosponding Pdo will be written
    into the PdoObject parameter. If success is returned without a PdoObject,
    a filter or Pdo should probably be created (note that this routine does
    not check to see if the devices are present).


Arguments:

    DeviceExtension - Extension we wish to match in the relation
    DeviceRelations - Relations we should examine
    RequireADR      - If set, nodes must have _ADR's
    RequireHID      - If set, nodes must have _HID's
    PdoObject       - Where to store the match if found

Return Value:

    NTSTATUS    - STATUS_SUCCESS if extension might be or is in list.
    PdoObject   - Non-Null means that this PDO corrosponds to the passed in
                  extension.

--*/
{
    BOOLEAN         match       = FALSE;
    BOOLEAN         testADR     = FALSE;
    BOOLEAN         testHID     = FALSE;
    NTSTATUS        status;
    UNICODE_STRING  acpiUnicodeID;
    ULONG           address;
    ULONG           i;

    PAGED_CODE();

    ASSERT( PdoObject != NULL);
    if (PdoObject == NULL) {

        return STATUS_INVALID_PARAMETER_1;

    }
    *PdoObject = NULL;

    //
    // Make sure to initialize the UNICODE_STRING
    //
    RtlZeroMemory( &acpiUnicodeID, sizeof(UNICODE_STRING) );

    //
    // Check to see if there is an _ADR present
    //
    if (RequireADR) {

        //
        // Filters must have _ADR's
        //
        if ( !(DeviceExtension->Flags & DEV_PROP_ADDRESS) ) {

            return STATUS_OBJECT_NAME_NOT_FOUND;

        }

    }

    //
    // Check to see if there is an _HID present
    //
    if (RequireHID) {

        //
        // Non-Filters require _HID's
        //
        if (DeviceExtension->DeviceID == NULL ||
            !(DeviceExtension->Flags & DEV_PROP_HID) ) {

            return STATUS_OBJECT_NAME_NOT_FOUND;

        }

    }

    //
    // Check to see if the relation is non-empty. If it isn't, there isn't
    // any work to do. This device obviously could be a Pdo child (as opposed
    // to a filter) but it sure isn't at the moment.
    //
    if (DeviceRelations == NULL || DeviceRelations->Count == 0) {

        //
        // No match
        //
        return STATUS_SUCCESS;

    }

    //
    // If we get to this point, and there is an _ADR present, we will test with
    // it. We also obtain the address at this time
    //
    if ( (DeviceExtension->Flags & DEV_MASK_ADDRESS) ) {

        testADR = TRUE;
        status = ACPIGetAddressSync(
            DeviceExtension,
            &address,
            NULL
            );

    }

    //
    // If we get to this point, and there is an _HID present, then we will
    // test with it. We will build the unicode address at this time
    //
    if ( (DeviceExtension->Flags & DEV_MASK_HID) ) {

        status = ACPIGetPnpIDSyncWide(
            DeviceExtension,
            &(acpiUnicodeID.Buffer),
            &(acpiUnicodeID.Length)
            );
        if (!NT_SUCCESS(status)) {

            return status;

        }

        //
        // Make sure that we have the maximum length of the string
        //
        acpiUnicodeID.MaximumLength = acpiUnicodeID.Length;

        //
        // Remember to test fora _HID
        //
        testHID = TRUE;

    }

    //
    // Loop for all the object in the extension
    //
    for (i = 0; i < DeviceRelations->Count; i++) {

        //
        // Assume we don't have a match
        //
        match = FALSE;

        //
        // Check to see if we match the address
        //

        if (testHID) {

            status = ACPIMatchHardwareId(
                DeviceRelations->Objects[i],
                &acpiUnicodeID,
                &match
                );

            if (!NT_SUCCESS(status)) {

                //
                // If we failed, then I guess we can just ignore it and
                // proceed
                //
                continue;

            }

        }

        //
        // Did we match?
        //
        // NB: the test for AddrObject is a hack specially reserved for
        // PCI. The issue is this. Some buses, have no concept of PnP ids
        // so the above test will never succeed. However, those buses are
        // expected to have ADR, so we can use ADR's to determine if we
        // we have a match. So if we don't have a match and we don't have
        // an ADR, then we just continue. But if we have ADR and don't have
        // a match, we might just have a match, so we will try again
        //
        if (match == FALSE && testADR == FALSE) {

            //
            // Then just continue
            //
            continue;

        }

        //
        // If there is an ADR, then we must check for that as well
        //
        if (testADR) {

            match = FALSE;
            status = ACPIMatchHardwareAddress(
                DeviceRelations->Objects[i],
                address,
                &match
                );
            if (!NT_SUCCESS(status)) {

                //
                // If we failed, then I guess we
                continue;

            }

            //
            // Did we match?
            //
            if (match == FALSE) {

                //
                // Then just continue
                //
                continue;

            }

        } // if (addrObject ... )

        //
        // At this point, there is no doubt, there is a match
        //
        *PdoObject = DeviceRelations->Objects[i];
        break ;

    } // for

    //
    // We have exhausted all options --- thus there is no match
    //
    return STATUS_SUCCESS ;
}

NTSTATUS
ACPIDetectDockDevices(
    IN     PDEVICE_EXTENSION   DeviceExtension,
    IN OUT PDEVICE_RELATIONS   *DeviceRelations
    )
/*++

Routine Description

Arguments:

    deviceExtension           - The device extension of the object whose
                                relations we care to know about
    DeviceRelations           - Pointer to Pointer to the array of device
                                relations

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN                 matchFound;
    EXTENSIONLIST_ENUMDATA  eled ;
    LONG                    oldReferenceCount;
    KIRQL                   oldIrql;
    PDEVICE_OBJECT          tempPdo ;
    NTSTATUS                status              = STATUS_SUCCESS;
    PDEVICE_EXTENSION       providerExtension   = NULL;
    PDEVICE_EXTENSION       targetExtension     = NULL;
    PDEVICE_RELATIONS       currentRelations    = NULL;
    PDEVICE_RELATIONS       newRelations        = NULL;
    PLIST_ENTRY             listEntry           = NULL;
    ULONG                   i                   = 0;
    ULONG                   j                   = 0;
    ULONG                   index               = 0;
    ULONG                   newRelationSize     = 0;
    ULONG                   deviceStatus;

    //
    // Determine the current size of the device relation (if any exists)
    //
    if (DeviceRelations != NULL && *DeviceRelations != NULL) {

        //
        // We need this value to help us build an MDL. After that is done,
        // we will refetch it
        //
        currentRelations = (*DeviceRelations);
        newRelationSize = currentRelations->Count;

    }

    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_REFERENCE_ENTRIES
        ) ;

    for(providerExtension = ACPIExtListStartEnum(&eled);
                            ACPIExtListTestElement(&eled, (BOOLEAN) NT_SUCCESS(status));
        providerExtension = ACPIExtListEnumNext(&eled)) {

        if (providerExtension == NULL) {

            ACPIExtListExitEnumEarly( &eled );
            break;

        }

        //
        // Only profile providers for this walk...
        //
        if (!(providerExtension->Flags & DEV_PROP_DOCK)) {

            continue;
        }

        //
        // Is it physically present?
        //
        status = ACPIGetDevicePresenceSync(
            providerExtension,
            (PVOID *) &deviceStatus,
            NULL
            );

        if (!(providerExtension->Flags & DEV_MASK_NOT_PRESENT)) {

            //
            // This profile provider should be in the list
            //
            if (providerExtension->DeviceObject == NULL) {

                //
                // Build it
                //
                status = ACPIBuildPdo(
                    DeviceExtension->DeviceObject->DriverObject,
                    providerExtension,
                    DeviceExtension->DeviceObject,
                    FALSE
                    );
                if (!NT_SUCCESS(status)) {

                    ASSERT(providerExtension->DeviceObject == NULL) ;

                }

            }

            if (providerExtension->DeviceObject != NULL) {

                if (!ACPIExtListIsMemberOfRelation(
                    providerExtension->DeviceObject,
                    currentRelations
                    )) {

                    newRelationSize++;

                }

            }

        } // if (providerExtension ... )

    }

    if (!NT_SUCCESS(status)) {

        //
        // Hmm... Let the world know that this happened
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            providerExtension,
            "ACPIDetectDockDevices: ACPIBuildPdo = %08lx\n",
            status
            ) );
        return status;

    }

    //
    // At this point, we can see if we need to change the size of the
    // device relations
    //
    if ( (currentRelations != NULL && newRelationSize == currentRelations->Count) ||
         (currentRelations == NULL && newRelationSize == 0) ) {

        //
        // Done
        //
        return STATUS_SUCCESS;

    }

    //
    // Determine the size of the new relations. Use index as a
    // scratch buffer
    //
    index = sizeof(DEVICE_RELATIONS) +
        ( sizeof(PDEVICE_OBJECT) * (newRelationSize - 1) );

    //
    // Allocate the new device relation buffer. Use nonpaged pool since we
    // are at dispatch
    //
    newRelations = ExAllocatePoolWithTag(
        NonPagedPool,
        index,
        ACPI_DEVICE_POOLTAG
        );
    if (newRelations == NULL) {

        //
        // Return failure
        //
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Initialize DeviceRelations data structure
    //
    RtlZeroMemory( newRelations, index );

    //
    // If there are existing relations, we must determine
    if (currentRelations) {

        //
        // Copy old relations, and determine the starting index for the
        // first of the PDOs created by this driver. We will put off freeing
        // the old relations till we are no longer holding the lock
        //
        RtlCopyMemory(
            newRelations->Objects,
            currentRelations->Objects,
            currentRelations->Count * sizeof(PDEVICE_OBJECT)
            );
        index = currentRelations->Count;
        j = currentRelations->Count;

    } else {

        //
        // There will not be a lot of work to do in this case
        //
        index = j = 0;

    }

    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_HOLD_SPINLOCK
        ) ;

    //
    // We need the spin lock so that we can walk the tree again. This time
    // we don't need to let it go until we are done since we don't need
    // to call anything that will at PASSIVE_LEVEL
    //

    for(providerExtension = ACPIExtListStartEnum(&eled);
                            ACPIExtListTestElement(&eled, (BOOLEAN) (newRelationSize!=index));
        providerExtension = ACPIExtListEnumNext(&eled)) {

        //
        // The only objects that we care about are those that are marked as
        // PDOs and have a physical object associated with them
        //
        if (!(providerExtension->Flags & DEV_MASK_NOT_PRESENT)     &&
             (providerExtension->Flags & DEV_PROP_DOCK) &&
              providerExtension->DeviceObject != NULL ) {

            //
            // We don't ObReferenceO here because we are still at
            // dispatch level (and for efficiency's sake, we don't
            // want to drop down)
            //
            newRelations->Objects[index] =
                providerExtension->PhysicalDeviceObject;

            //
            // Update the location for the next object in the
            // relation
            //
            index++ ;

        } // if (providerExtension->Flags ... )

    } // for

    //
    // Update the size of the relations by the number of matches that we
    // successfully made
    //
    newRelations->Count = index;
    newRelationSize = index;

    //
    // We have to reference all of the objects that we added
    //
    index = (currentRelations != NULL ? currentRelations->Count : 0);
    for (; index < newRelationSize; index++) {

        //
        // Attempt to reference the object
        //
        status = ObReferenceObjectByPointer(
            newRelations->Objects[index],
            0,
            NULL,
            KernelMode
            );
        if (!NT_SUCCESS(status) ) {

            PDEVICE_OBJECT  tempDeviceObject;

            //
            // Hmm... Let the world know that this happened
            //
            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                "ACPIDetectDockDevices: ObjReferenceObject(0x%08lx) "
                "= 0x%08lx\n",
                newRelations->Objects[index],
                status
                ) );

            //
            // Swap the bad element for the last one in the chain
            //
            newRelations->Count--;
            tempDeviceObject = newRelations->Objects[newRelations->Count];
            newRelations->Objects[newRelations->Count] =
                newRelations->Objects[index];
            newRelations->Objects[index] = tempDeviceObject;

        }

    }

    //
    // Free the old device relations (if it is present)
    //
    if (currentRelations) {

        ExFreePool( *DeviceRelations );

    }

    //
    // Update the device relation pointer
    //
    *DeviceRelations = newRelations;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

VOID
ACPIDetectDuplicateADR(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine looks at all the sibling devices of the specified
    device and determines if there are devices with duplicate _ADRs

Arguments:

    DeviceExtension - The DeviceExtension that we are trying to detect
                      duplicate's on

Return Value:

    VOID

--*/
{
    BOOLEAN                 resetDeviceAddress = FALSE;
    EXTENSIONLIST_ENUMDATA  eled;
    PDEVICE_EXTENSION       childExtension;
    PDEVICE_EXTENSION       parentExtension = DeviceExtension->ParentExtension;

    //
    // Is this the root of the device tree?
    //
    if (parentExtension == NULL) {

        return;

    }

    //
    // Do we fail to eject a PDO for this device? Or does this device not have
    // an _ADR?
    //
    if ( (DeviceExtension->Flags & DEV_TYPE_NEVER_PRESENT) ||
         (DeviceExtension->Flags & DEV_TYPE_NOT_PRESENT) ||
        !(DeviceExtension->Flags & DEV_MASK_ADDRESS) ) {

        return;

    }

    //
    // Walk the children --- spinlock is taken
    //
    ACPIExtListSetupEnum(
        &eled,
        &(parentExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_HOLD_SPINLOCK
        );
    for (childExtension = ACPIExtListStartEnum( &eled );
                          ACPIExtListTestElement( &eled, TRUE );
         childExtension = ACPIExtListEnumNext( &eled ) ) {

        if (childExtension == NULL) {

            ACPIExtListExitEnumEarly( &eled );
            break;

        }

        //
        // If the child and target extension matches, then we are looking
        // at ourselves. This is not a very interesting comparison
        //
        if (childExtension == DeviceExtension) {

            continue;

        }

        //
        // Does the child have an _ADR? If not, then its boring to compare
        //
        if ( (childExtension->Flags & DEV_TYPE_NEVER_PRESENT) ||
             (childExtension->Flags & DEV_MASK_NOT_PRESENT) ||
             (childExtension->Flags & DEV_PROP_UNLOADING) ||
            !(childExtension->Flags & DEV_PROP_ADDRESS) ) {

            continue;

        }

        //
        // If we don't have matching ADRs, this is a boring comparison to make
        // also
        //
        if (childExtension->Address != DeviceExtension->Address) {

            continue;

        }

        //
        // At this point, we are hosed. We have two different devices with the
        // same ADR. Very Bad. We need to remember that we have a match so that
        // we can reset the current device extension address as well, once
        // we have scanned all the siblings
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIDetectDuplicateADR - matches with %08lx\n",
            childExtension
            ) );
        resetDeviceAddress = TRUE;

        //
        // Reset the child's Address. We do this by OR'ing in 0xFFFF which
        // effectively resets the Function Number to -1.
        //
        childExtension->Address |= 0xFFFF;
        ACPIInternalUpdateFlags(
            &(childExtension->Flags),
            DEV_PROP_FIXED_ADDRESS,
            FALSE
            );


    }

    //
    // Do we reset the DeviceExtension's address?
    //
    if (resetDeviceAddress) {

        DeviceExtension->Address |= 0xFFFF;
        ACPIInternalUpdateFlags(
            &(DeviceExtension->Flags),
            DEV_PROP_FIXED_ADDRESS,
            FALSE
            );

    }
}

VOID
ACPIDetectDuplicateHID(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine looks at all the sibling devices of the specified
    device and determines if there are devices with duplicate HIDs and
    UIDs

Arguments:

    DeviceExtension - The DeviceExtension that we are trying to detect
                      duplicate's on

Return Value:

    VOID    -or- Bugcheck

--*/
{
    EXTENSIONLIST_ENUMDATA  eled;
    PDEVICE_EXTENSION       childExtension;
    PDEVICE_EXTENSION       parentExtension = DeviceExtension->ParentExtension;

    //
    // Is this the root of the device tree?
    //
    if (parentExtension == NULL) {

        return;

    }

    //
    // Do we fail to eject a PDO for this device? Or does this device not have
    // an _HID?
    //
    if ( (DeviceExtension->Flags & DEV_TYPE_NEVER_PRESENT) ||
         (DeviceExtension->Flags & DEV_MASK_NOT_PRESENT) ||
        !(DeviceExtension->Flags & DEV_MASK_HID) ) {

        return;

    }

    //
    // Walk the children --- spinlock is taken
    //
    ACPIExtListSetupEnum(
        &eled,
        &(parentExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_HOLD_SPINLOCK
        );
    for (childExtension = ACPIExtListStartEnum( &eled );
                          ACPIExtListTestElement( &eled, TRUE );
         childExtension = ACPIExtListEnumNext( &eled ) ) {

        if (childExtension == NULL) {

            ACPIExtListExitEnumEarly( &eled );
            break;

        }

        //
        // If the child and target extension matches, then we are looking
        // at ourselves. This is not a very interesting comparison
        //
        if (childExtension == DeviceExtension) {

            continue;

        }

        //
        // Does the child have an _HID? If not, then its boring to compare
        //
        if ( (childExtension->Flags & DEV_TYPE_NEVER_PRESENT) ||
             (childExtension->Flags & DEV_MASK_NOT_PRESENT) ||
             (childExtension->Flags & DEV_PROP_UNLOADING) ||
            !(childExtension->Flags & DEV_MASK_HID) ) {

            continue;

        }

        //
        // If we don't have matching HIDs, this is a boring comparison to make
        // also
        //
        if (!strstr(childExtension->DeviceID, DeviceExtension->DeviceID) ) {

            continue;

        }

        //
        // Work around OSCeola bugs
        //
        if ( (childExtension->Flags & DEV_MASK_UID) &&
             (DeviceExtension->Flags & DEV_MASK_UID) ) {

            //
            // Check to see if their UIDs match
            //
            if (strcmp(childExtension->InstanceID, DeviceExtension->InstanceID) ) {

                continue;

            }

            //
            // At this point, we are hosed. We have two different devices with the
            // same PNP id, but no UIDs. Very bad
            //
            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                DeviceExtension,
                "ACPIDetectDuplicateHID - has _UID match with %08lx\n"
                "\t\tContact the Machine Vendor to get this problem fixed\n",
                childExtension
                ) );

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_REQUIRED_METHOD_NOT_PRESENT,
                (ULONG_PTR) DeviceExtension,
                PACKED_UID,
                1
                );

        }

        //
        // At this point, we are hosed. We have two different devices with the
        // same PNP id, but no UIDs. Very bad
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIDetectDuplicateHID - matches with %08lx\n",
            childExtension
            ) );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) DeviceExtension,
            PACKED_UID,
            0
            );

        //
        // Make sure to only muck with the DeviceExtension UID if it doesn't
        // already have one
        //
        if (!(DeviceExtension->Flags & DEV_MASK_UID) ) {

            //
            // Build a fake instance ID for the device
            //
            DeviceExtension->InstanceID = ExAllocatePoolWithTag(
                NonPagedPool,
                9 * sizeof(UCHAR),
                ACPI_STRING_POOLTAG
                );
            if (DeviceExtension->InstanceID == NULL) {

                ACPIDevPrint( (
                    ACPI_PRINT_CRITICAL,
                    DeviceExtension,
                    "ACPIDetectDuplicateHID - no memory!\n"
                    ) );
                ACPIInternalError( ACPI_DETECT );

            }
            RtlZeroMemory( DeviceExtension->InstanceID, 9 * sizeof(UCHAR) );
            sprintf( DeviceExtension->InstanceID, "%lx", DeviceExtension->AcpiObject->dwNameSeg );

            //
            // Remember that we have a fixed uid
            //
            ACPIInternalUpdateFlags(
                &(DeviceExtension->Flags),
                DEV_PROP_FIXED_UID,
                FALSE
                );

        }

        //
        // Make sure to only muck with the ChildExtension UID if it doesn't
        // already have one
        //
        if (!(childExtension->Flags & DEV_MASK_UID) ) {

            //
            // Build a fake instance ID for the duplicate
            //
            childExtension->InstanceID = ExAllocatePoolWithTag(
                NonPagedPool,
                9 * sizeof(UCHAR),
                ACPI_STRING_POOLTAG
                );
            if (childExtension->InstanceID == NULL) {

                ACPIDevPrint( (
                    ACPI_PRINT_CRITICAL,
                    DeviceExtension,
                    "ACPIDetectDuplicateHID - no memory!\n"
                    ) );
                ACPIInternalError( ACPI_DETECT );

            }
            RtlZeroMemory( childExtension->InstanceID, 9 * sizeof(UCHAR) );
            sprintf( childExtension->InstanceID, "%lx", childExtension->AcpiObject->dwNameSeg );

            //
            // Update the flags for both devices to indicate the fixed UID
            //
            ACPIInternalUpdateFlags(
                &(childExtension->Flags),
                DEV_PROP_FIXED_UID,
                FALSE
                );

        }

    }

}

NTSTATUS
ACPIDetectEjectDevices(
    IN     PDEVICE_EXTENSION   DeviceExtension,
    IN OUT PDEVICE_RELATIONS   *DeviceRelations,
    IN     PDEVICE_EXTENSION   AdditionalExtension OPTIONAL
    )
/*++

Routine Description

Arguments:

    DeviceExtension           - The device extension of the object whose
                                relations we care to know about
    DeviceRelations           - Pointer to Pointer to the array of device
                                relations
    AdditionalExtension       - If set, non-NULL AdditionalExtension's
                                DeviceObject will be added to the list (this
                                is for the profile providers)

    ADRIAO N.B 07/14/1999 -
        A more clever way to solve the profile provider issue is listed here.
    1) Add a new phase in buildsrc after the _EJD phase, call it PhaseDock
    2) When PhaseDock finds a _DCK node, it creates a seperate extension,
       RemoveEntryList's the EjectHead and Inserts the list on the new extension
       (ie, new extension hijacks old extensions _EJD's)
    3) New extension adds old as an ejection relation
    4) Old extension adds new as it's *only* ejection relation

    (We're not taking this design due to the ship schedule, it's safer to hack
     the existing one).

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN                 inRelation;
    EXTENSIONLIST_ENUMDATA  eled ;
    LONG                    oldReferenceCount;
    KIRQL                   oldIrql;
    NTSTATUS                status;
    PDEVICE_OBJECT          tempPdo ;
    PDEVICE_EXTENSION       ejecteeExtension    = NULL;
    PDEVICE_EXTENSION       targetExtension     = NULL;
    PDEVICE_RELATIONS       currentRelations    = NULL;
    PDEVICE_RELATIONS       newRelations        = NULL;
    PLIST_ENTRY             listEntry           = NULL;
    ULONG                   i                   = 0;
    ULONG                   index               = 0;
    ULONG                   newRelationSize     = 0;

    //
    // We might not have resolved all our ejection dependencies, so lets do
    // that now...
    //
    ACPIBuildMissingEjectionRelations();

    //
    // Determine the current size of the device relation (if any exists)
    //
    if (DeviceRelations != NULL && *DeviceRelations != NULL) {

        //
        // We need this value to help us build an MDL. After that is done,
        // we will refetch it
        //
        currentRelations = (*DeviceRelations);
        newRelationSize = currentRelations->Count;

    }

    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->EjectDeviceHead),
        &AcpiDeviceTreeLock,
        EjectDeviceList,
        WALKSCHEME_REFERENCE_ENTRIES
        ) ;

    for(ejecteeExtension = ACPIExtListStartEnum(&eled);
                           ACPIExtListTestElement(&eled, TRUE);
        ejecteeExtension = ACPIExtListEnumNext(&eled)) {

        //
        // Is it physically present?
        //
        if (!(ejecteeExtension->Flags & DEV_MASK_NOT_PRESENT)      &&
            !(ejecteeExtension->Flags & DEV_PROP_FAILED_INIT)      &&
             (ejecteeExtension->PhysicalDeviceObject != NULL) ) {

            //
            // Is there a match between the device relations and the current
            // device extension?
            //
            status = ACPIDetectCouldExtensionBeInRelation(
                ejecteeExtension,
                currentRelations,
                FALSE,
                FALSE,
                &tempPdo
                ) ;
            if ( tempPdo == NULL && NT_SUCCESS(status) ) {

                //
                // We are here if we an extension that does not match any
                // of the hardware represented by the current contents of
                // the relation.
                //
                if (ejecteeExtension->PhysicalDeviceObject != NULL) {

                    inRelation = ACPIExtListIsMemberOfRelation(
                        ejecteeExtension->PhysicalDeviceObject,
                        currentRelations
                        );
                    if (inRelation == FALSE) {

                        newRelationSize++;

                    }

                }

            }

        } // if (ejecteeExtension ... )

    }

    //
    // Do we have an extra device to include in the list?
    //
    if (ARGUMENT_PRESENT(AdditionalExtension) &&
        !(AdditionalExtension->Flags & DEV_MASK_NOT_PRESENT) &&
        (AdditionalExtension->PhysicalDeviceObject != NULL)) {

        inRelation = ACPIExtListIsMemberOfRelation(
            AdditionalExtension->PhysicalDeviceObject,
            currentRelations);
        if (inRelation == FALSE) {

            newRelationSize++;

        }

    }

    //
    // At this point, we can see if we need to change the size of the
    // device relations
    //
    if ( (currentRelations != NULL && newRelationSize == currentRelations->Count) ||
         (currentRelations == NULL && newRelationSize == 0) ) {

        //
        // Done
        //
        return STATUS_SUCCESS;

    }

    //
    // Determine the size of the new relations. Use index as a
    // scratch buffer
    //
    index = sizeof(DEVICE_RELATIONS) +
        ( sizeof(PDEVICE_OBJECT) * (newRelationSize - 1) );

    //
    // Allocate the new device relation buffer. Use nonpaged pool since we
    // are at dispatch
    //
    newRelations = ExAllocatePoolWithTag(
        PagedPool,
        index,
        ACPI_DEVICE_POOLTAG
        );
    if (newRelations == NULL) {

        //
        // Return failure
        //
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Initialize DeviceRelations data structure
    //
    RtlZeroMemory( newRelations, index );

    //
    // If there are existing relations, we must determine
    if (currentRelations) {

        //
        // Copy old relations, and determine the starting index for the
        // first of the PDOs created by this driver. We will put off freeing
        // the old relations till we are no longer holding the lock
        //
        RtlCopyMemory(
            newRelations->Objects,
            currentRelations->Objects,
            currentRelations->Count * sizeof(PDEVICE_OBJECT)
            );
        index = currentRelations->Count;

    } else {

        //
        // There will not be a lot of work to do in this case
        //
        index = 0;

    }

    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->EjectDeviceHead),
        &AcpiDeviceTreeLock,
        EjectDeviceList,
        WALKSCHEME_REFERENCE_ENTRIES
        ) ;

    //
    // We need the spin lock so that we can walk the tree again. This time
    // we don't need to let it go until we are done since we don't need
    // to call anything that will at PASSIVE_LEVEL
    //

    for(ejecteeExtension = ACPIExtListStartEnum(&eled);
                           ACPIExtListTestElement(&eled, (BOOLEAN) (newRelationSize!=index));
        ejecteeExtension = ACPIExtListEnumNext(&eled)) {

        if (ejecteeExtension == NULL) {

            ACPIExtListExitEnumEarly( &eled );
            break;

        }

        //
        // The only objects that we care about are those that are marked as
        // PDOs and have a phsyical object associated with them
        //
        if (!(ejecteeExtension->Flags & DEV_MASK_NOT_PRESENT)      &&
            !(ejecteeExtension->Flags & DEV_PROP_DOCK) &&
             (ejecteeExtension->PhysicalDeviceObject != NULL) ) {

            //
            // See if the object is already in the relations. Note that it
            // actually correct to use currentRelations for the test instead
            // of newRelations. This is because we only want to compare
            // against those object which were handed to us, not the ones
            // that we added.
            //
            inRelation = ACPIExtListIsMemberOfRelation(
                ejecteeExtension->PhysicalDeviceObject,
                currentRelations
                );
            if (inRelation == FALSE) {

                //
                // We don't ObReferenceO here because we are still at
                // dispatch level (and for efficiency's sake, we don't
                // want to drop down). We also update the location for
                // the next object in the relation
                //
                newRelations->Objects[index++] =
                    ejecteeExtension->PhysicalDeviceObject;

            }

        } // if (ejecteeExtension->Flags ... )

    } // for

    //
    // Do we have an extra device to include in the list? If so, add it now
    //
    if (ARGUMENT_PRESENT(AdditionalExtension) &&
        !(AdditionalExtension->Flags & DEV_MASK_NOT_PRESENT) &&
        (AdditionalExtension->PhysicalDeviceObject != NULL)) {

        inRelation = ACPIExtListIsMemberOfRelation(
            AdditionalExtension->PhysicalDeviceObject,
            currentRelations);
        if (inRelation == FALSE) {

            newRelations->Objects[index++] =
                AdditionalExtension->PhysicalDeviceObject;

        }

    }

    //
    // Update the size of the relations by the number of matches that we
    // successfully made
    //
    newRelations->Count = index;
    newRelationSize = index;

    //
    // We have to reference all of the objects that we added
    //
    index = (currentRelations != NULL ? currentRelations->Count : 0);
    for (; index < newRelationSize; index++) {

        //
        // Attempt to reference the object
        //
        status = ObReferenceObjectByPointer(
            newRelations->Objects[index],
            0,
            NULL,
            KernelMode
            );
        if (!NT_SUCCESS(status) ) {

            PDEVICE_OBJECT  tempDeviceObject;

            //
            // Hmm... Let the world know that this happened
            //
            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                "ACPIDetectEjectDevices: ObjReferenceObject(0x%08lx) "
                "= 0x%08lx\n",
                newRelations->Objects[index],
                status
                ) );

            //
            // Swap the bad element for the last one in the chain
            //
            newRelations->Count--;
            tempDeviceObject = newRelations->Objects[newRelations->Count];
            newRelations->Objects[newRelations->Count] =
                newRelations->Objects[index];
            newRelations->Objects[index] = tempDeviceObject;

        }

    }

    //
    // Free the old device relations (if it is present)
    //
    if (currentRelations) {

        ExFreePool( *DeviceRelations );

    }

    //
    // Update the device relation pointer
    //
    *DeviceRelations = newRelations;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDetectFilterDevices(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PDEVICE_RELATIONS   DeviceRelations
    )
/*++

Routine Description:
    This is one of the two routines that is used for QueryDeviceRelations.
    This routine is called on the IRPs way *up* the stack. Its purpose is
    to create FILTERS for device which are in the relation and are known
    to ACPI

Arguments:

    DeviceObject    - The object whose relations we care to know about
    DeviceRelations - Pointer to array of device relations

Return Value:

    NTSTATUS

--*/
{
    LONG                oldReferenceCount   = 0;
    KIRQL               oldIrql;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension     = NULL;
    PDEVICE_EXTENSION   parentExtension     = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION   targetExtension     = NULL;
    PDEVICE_OBJECT      pdoObject           = NULL;
    PLIST_ENTRY         listEntry           = NULL;
    ULONG               deviceStatus;

    //
    // Sync with the build surprise removal code...
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Do we have missing children?
    //
    if (parentExtension->Flags & DEV_PROP_REBUILD_CHILDREN) {

        ACPIInternalUpdateFlags(
            &(parentExtension->Flags),
            DEV_PROP_REBUILD_CHILDREN,
            TRUE
            );
        ACPIBuildMissingChildren( parentExtension );

    }

    //
    // Done with the sync part
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // No matter what, we must make sure that we are synchronized with the
    // build engine.
    //
    status = ACPIBuildFlushQueue( parentExtension );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            parentExtension,
           "ACPIBuildFlushQueue = %08lx\n",
            status
            ) );
        return status;

    }

    //
    // We must walk the tree at dispatch level <sigh>
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Sanity check
    //
    if (IsListEmpty( &(parentExtension->ChildDeviceList) ) ) {

        //
        // We have nothing to do here
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
        return STATUS_SUCCESS;

    }

    //
    // Grab the first child
    //
    deviceExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
        parentExtension->ChildDeviceList.Flink,
        DEVICE_EXTENSION,
        SiblingDeviceList
        );

    //
    // Always update the reference count to make sure that no one will
    // ever delete the node without our knowing it
    //
    InterlockedIncrement( &(deviceExtension->ReferenceCount) );

    //
    // Relinquish the spin lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Loop until we get back to the parent
    //
    while (deviceExtension != NULL) {

        //
        // Note: Do *NOT* set the NOT_ENUMERATED bit here. We have already
        // set the bit in ACPIDetectPdoDevices()
        //

        //
        // Update the device status. Make sure that we call at PASSIVE
        // level, since we will be calling synchronously
        //
        status = ACPIGetDevicePresenceSync(
            deviceExtension,
            (PVOID *) &deviceStatus,
            NULL
            );
        if ( NT_SUCCESS(status) &&
             !(deviceExtension->Flags & DEV_MASK_NOT_PRESENT) ) {

            //
            // Is there a match between the device relations and the current
            // device extension?
            //
            status = ACPIDetectFilterMatch(
                deviceExtension,
                DeviceRelations,
                &pdoObject
                );
            if (NT_SUCCESS(status) ) {

                if (pdoObject != NULL) {

                    //
                    // We have to build a filter object here
                    //
                    status = ACPIBuildFilter(
                        DeviceObject->DriverObject,
                        deviceExtension,
                        pdoObject
                        );
                    if (!NT_SUCCESS(status)) {

                        ACPIDevPrint( (
                            ACPI_PRINT_FAILURE,
                            deviceExtension,
                           "ACPIDetectFilterDevices = %08lx\n",
                            status
                            ) );

                    }

                }

            } else {

                ACPIDevPrint( (
                    ACPI_PRINT_FAILURE,
                    deviceExtension,
                    "ACPIDetectFilterMatch = 0x%08lx\n",
                    status
                    ) );

            }

        }

        //
        // Reacquire the spin lock
        //
        KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

        //
        // Decrement the reference count on the node
        //
        oldReferenceCount = InterlockedDecrement(
            &(deviceExtension->ReferenceCount)
            );

        //
        // Check to see if we have gone all the way around the list
        // list
        if (deviceExtension->SiblingDeviceList.Flink ==
            &(parentExtension->ChildDeviceList) ) {

            //
            // Remove the node, if necessary
            //
            if (oldReferenceCount == 0) {

                //
                // Free the memory allocated by the extension
                //
                ACPIInitDeleteDeviceExtension( deviceExtension );

            }

            //
            // Release the spin lock
            //
            KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

            //
            // Stop the loop
            //
            break;

        } // if

        //
        // Next element
        //
        deviceExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
            deviceExtension->SiblingDeviceList.Flink,
            DEVICE_EXTENSION,
            SiblingDeviceList
            );

        //
        // Remove the old node, if necessary
        //
        if (oldReferenceCount == 0) {

            //
            // Unlink the extension from the tree
            //
            listEntry = RemoveTailList(
                &(deviceExtension->SiblingDeviceList)
                );

            //
            // It is not possible for this to point to the parent without
            // having succeeded the previous test
            //
            targetExtension = CONTAINING_RECORD(
                listEntry,
                DEVICE_EXTENSION,
                SiblingDeviceList
                );

            //
            // Free the memory allocated for the extension
            //
            ACPIInitDeleteDeviceExtension( targetExtension );

        }

        //
        // Increment the reference count on this node so that it too
        // cannot be deleted
        //
        InterlockedIncrement( &(deviceExtension->ReferenceCount) );

        //
        // Now, we release the spin lock
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    } // while

    //
    //  We succeeded
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDetectFilterMatch(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PDEVICE_RELATIONS   DeviceRelations,
    OUT PDEVICE_OBJECT      *PdoObject
    )
/*++

Routine Description:

    This routine takes a given extension and a set of relations and decides
    whether a new filter should be attached to one of the PDO's listed in
    the relation list.

Arguments:

    DeviceExtension - Extension we wish to match in the relation
    DeviceRelations - Relations we should examine
    PdoObject       - Where to store the match

Return Value:

    NTSTATUS
    PdoObject   - Non-Null means that PdoObject needs a filter attached to it.

--*/
{
    NTSTATUS    status;

    PAGED_CODE();

    ASSERT( PdoObject != NULL);
    if (PdoObject == NULL) {

        return STATUS_INVALID_PARAMETER_1;

    }
    *PdoObject = NULL;

    //
    // For this to work, we must set the DEV_TYPE_NOT_FOUND flag when we
    // first create the device and at any time when there is no device object
    // associated with the extension
    //
    if ( !(DeviceExtension->Flags & DEV_TYPE_NOT_FOUND) ||
        (DeviceExtension->Flags & DEV_PROP_DOCK) ||
         DeviceExtension->DeviceObject != NULL) {

        ULONG count;

        //
        // If we don't have any relations, then we can't match anything
        //
        if (DeviceRelations == NULL || DeviceRelations->Count == 0) {

            return STATUS_SUCCESS;
        }

        //
        // Look at all the PDOs in the relation and see if they match what
        // a device object that we are attached to
        //
        for (count = 0; count < DeviceRelations->Count; count++) {

            if (DeviceExtension->PhysicalDeviceObject == DeviceRelations->Objects[count]) {

                //
                // Clear the flag that says that we haven't enumerated
                // this
                //
                ACPIInternalUpdateFlags(
                    &(DeviceExtension->Flags),
                    DEV_TYPE_NOT_ENUMERATED,
                    TRUE
                    );

            }

        }
        return STATUS_SUCCESS;

    }

    status = ACPIDetectCouldExtensionBeInRelation(
        DeviceExtension,
        DeviceRelations,
        TRUE,
        FALSE,
        PdoObject
        ) ;
    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // Harmless cleanup, we just checked a node on a non-ACPI bus that
        // doesn't have an _ADR (likely it has a _HID, and will make it's
        // own PDO)
        //
        status = STATUS_SUCCESS;

    }

    return status ;
}

NTSTATUS
ACPIDetectPdoDevices(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PDEVICE_RELATIONS   *DeviceRelations
    )
/*++

Routine Description

    This is one of the two functions that is used for QueryDeviceRelations.
    This routine is called on the IRPs way *down* the stack. Its purpose is
    to create PDOs for device which are not in the relation

Arguments:

    DeviceObject    - The object whose relations we care to know about
    DeviceRelations - Pointer to Pointer to the array of device relations

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             matchFound;
    LONG                oldReferenceCount;
    KIRQL               oldIrql;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension     = NULL;
    PDEVICE_EXTENSION   parentExtension     = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION   targetExtension     = NULL;
    PDEVICE_RELATIONS   currentRelations    = NULL;
    PDEVICE_RELATIONS   newRelations        = NULL;
    PLIST_ENTRY         listEntry           = NULL;
    ULONG               i                   = 0;
    ULONG               j                   = 0;
    ULONG               index               = 0;
    ULONG               newRelationSize     = 0;
    ULONG               deviceStatus;

    //
    // Determine the current size of the device relation (if any exists)
    //
    if (DeviceRelations != NULL && *DeviceRelations != NULL) {

        //
        // We need this value to help us build an MDL. After that is done,
        // we will refetch it
        //
        currentRelations = (*DeviceRelations);
        newRelationSize = currentRelations->Count;

    }

    //
    // Sync with the build surprise removal code...
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Do we have missing children?
    //
    if (parentExtension->Flags & DEV_PROP_REBUILD_CHILDREN) {

        ACPIInternalUpdateFlags(
            &(parentExtension->Flags),
            DEV_PROP_REBUILD_CHILDREN,
            TRUE
            );
        ACPIBuildMissingChildren( parentExtension );

    }

    //
    // Done with the sync part
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
    //
    // The first step is to actually try to make sure that we are currently
    // synchronized with the build engine
    //
    status = ACPIBuildFlushQueue( parentExtension );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            parentExtension,
           "ACPIBuildFlushQueue = %08lx\n",
            status
            ) );
        return status;

    }

    //
    // We must walk the tree at dispatch level <sigh>
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Sanity check
    //
    if (IsListEmpty( &(parentExtension->ChildDeviceList) ) ) {

        //
        // We have nothing to do here
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

        //
        // Do we currently have some relations? If so, then we just return
        // those and don't need to add anything to them
        //
        if (currentRelations) {

            return STATUS_SUCCESS;

        }

        //
        // We still need to return an information context with a count of 0
        //
        newRelations = ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(DEVICE_RELATIONS),
            ACPI_DEVICE_POOLTAG
            );
        if (newRelations == NULL) {

            //
            // Return failure
            //
            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Initialize DeviceRelations data structure
        //
        RtlZeroMemory( newRelations, sizeof(DEVICE_RELATIONS) );

        //
        // We don't need to this, but its better to be explicit
        //
        newRelations->Count = 0;

        //
        // Remember the new relations and return
        //
        *DeviceRelations = newRelations;
        return STATUS_SUCCESS;

    }

    //
    // Grab the first child
    //
    deviceExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
        parentExtension->ChildDeviceList.Flink,
        DEVICE_EXTENSION,
        SiblingDeviceList
        );

    //
    // Always update the reference count to make sure that no one will
    // ever delete the node without our knowing it
    //
    InterlockedIncrement( &(deviceExtension->ReferenceCount) );

    //
    // Relinquish the spin lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Loop until we get back to the parent
    //
    while (deviceExtension != NULL) {

        //
        // Always consider the device as never having been enumerated.
        //
        // NOTE:
        //  The reason that we do this here (and only here) is because
        // ACPIDetectFilterMatch() is called later on and we need to know
        // which device objects were detected as PDOs and which ones were
        // also detected as Filters. Setting this flag twice would defeat that
        // purpose.
        //
        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            DEV_TYPE_NOT_ENUMERATED,
            FALSE
            );

        //
        // Update the current device status
        //
        status = ACPIGetDevicePresenceSync(
            deviceExtension,
            (PVOID *) &deviceStatus,
            NULL
            );

        //
        // If the device exists
        //
        if ( NT_SUCCESS(status) &&
            !(deviceExtension->Flags & DEV_MASK_NOT_PRESENT) ) {

            //
            // Is there a match between the device relations and the current
            // device extension?
            //
            matchFound = ACPIDetectPdoMatch(
                deviceExtension,
                currentRelations
                );
            if (matchFound == FALSE) {

                //
                // NOTE: we use this here to prevent having to typecase later
                // on
                //
                matchFound =
                    (parentExtension->Flags & DEV_TYPE_FDO) ? FALSE : TRUE;

                //
                // Build a new PDO
                //
                status = ACPIBuildPdo(
                    DeviceObject->DriverObject,
                    deviceExtension,
                    parentExtension->PhysicalDeviceObject,
                    matchFound
                    );
                if (NT_SUCCESS(status)) {

                    //
                    // We have created a device object that we will have to
                    // add into the device relations
                    //
                    newRelationSize += 1;

                }

            } else if (deviceExtension->Flags & DEV_TYPE_PDO &&
                deviceExtension->DeviceObject != NULL) {

                //
                // Just we because the device_extension matched doesn't mean
                // that it is included in the device relations. What we will
                // do here is look to see if
                //      a) the extension is a PDO
                //      b) there is a device object associated with the
                //         extension
                //      c) the device object is *not* in the device relation
                //
                matchFound = FALSE;
                if (currentRelations != NULL) {

                    for (index = 0; index < currentRelations->Count; index++) {

                        if (currentRelations->Objects[index] ==
                            deviceExtension->DeviceObject) {

                            //
                            // Match found
                            //
                            matchFound = TRUE;
                            break;

                        }

                    } // for

                }

                //
                // Did we not find a match?
                //
                if (!matchFound) {

                    //
                    // We need to make sure that its in the relation
                    //
                    newRelationSize += 1;

                    //
                    // And at the same time, clear the flag that says that
                    // we haven't enumerated this
                    //
                    ACPIInternalUpdateFlags(
                        &(deviceExtension->Flags),
                        DEV_TYPE_NOT_ENUMERATED,
                        TRUE
                        );


                }

            } // if (ACPIDetectPDOMatch ... )

        } // if (deviceExtension ... )

        //
        // Reacquire the spin lock
        //
        KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

        //
        // Decrement the reference count on the node
        //
        oldReferenceCount = InterlockedDecrement(
            &(deviceExtension->ReferenceCount)
            );

        //
        // Check to see if we have gone all the way around the list
        // list
        if (deviceExtension->SiblingDeviceList.Flink ==
            &(parentExtension->ChildDeviceList) ) {

            //
            // Remove the node, if necessary
            //
            if (oldReferenceCount == 0) {

                //
                // Free the memory allocated by the extension
                //
                ACPIInitDeleteDeviceExtension( deviceExtension );

            }

            //
            // Now, we release the spin lock
            //
            KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

            //
            // Stop the loop
            //
            break;

        } // if

        //
        // Next element
        //
        deviceExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
            deviceExtension->SiblingDeviceList.Flink,
            DEVICE_EXTENSION,
            SiblingDeviceList
            );

        //
        // Remove the old node, if necessary
        //
        if (oldReferenceCount == 0) {

            //
            // Unlink the obsolete extension
            //
            listEntry = RemoveTailList(
                &(deviceExtension->SiblingDeviceList)
                );

            //
            // It is not possible for this to point to the parent without
            // having succeeded the previous test
            //
            targetExtension = CONTAINING_RECORD(
                listEntry,
                DEVICE_EXTENSION,
                SiblingDeviceList
                );

            //
            // Deleted the old extension
            //
            ACPIInitDeleteDeviceExtension( targetExtension );
        }

        //
        // Increment the reference count on this node so that it too
        // cannot be deleted
        //
        InterlockedIncrement( &(deviceExtension->ReferenceCount) );

        //
        // Now, we release the spin lock
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    } // while

    //
    // At this point, we can see if we need to change the size of the
    // device relations
    //
    if ( (currentRelations && newRelationSize == currentRelations->Count) ||
         (currentRelations == NULL && newRelationSize == 0) ) {

        //
        // Done
        //
        return STATUS_SUCCESS;

    }

    //
    // Determine the size of the new relations. Use index as a
    // scratch buffer
    //
    index = sizeof(DEVICE_RELATIONS) +
        ( sizeof(PDEVICE_OBJECT) * (newRelationSize - 1) );

    //
    // Allocate the new device relation buffer. Use nonpaged pool since we
    // are at dispatch
    //
    newRelations = ExAllocatePoolWithTag(
        NonPagedPool,
        index,
        ACPI_DEVICE_POOLTAG
        );
    if (newRelations == NULL) {

        //
        // Return failure
        //
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Initialize DeviceRelations data structure
    //
    RtlZeroMemory( newRelations, index );

    //
    // If there are existing relations, we must determine
    if (currentRelations) {

        //
        // Copy old relations, and determine the starting index for the
        // first of the PDOs created by this driver. We will put off freeing
        // the old relations till we are no longer holding the lock
        //
        RtlCopyMemory(
            newRelations->Objects,
            currentRelations->Objects,
            currentRelations->Count * sizeof(PDEVICE_OBJECT)
            );
        index = currentRelations->Count;
        j = currentRelations->Count;

    } else {

        //
        // There will not be a lot of work to do in this case
        //
        index = j = 0;

    }

    //
    // We need the spin lock so that we can walk the tree again. This time
    // we don't need to let it go until we are done since we don't need
    // to call anything that will at PASSIVE_LEVEL
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Sanity check
    //
    if (IsListEmpty( &(parentExtension->ChildDeviceList) ) ) {

        //
        // We have nothing to do here
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
        ExFreePool( newRelations );
        return STATUS_SUCCESS;

    }

    //
    // Walk the tree one more time and add all PDOs that aren't present in
    // the device relations
    //
    deviceExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
        parentExtension->ChildDeviceList.Flink,
        DEVICE_EXTENSION,
        SiblingDeviceList
        );

    //
    // Loop until we get back to the parent
    //
    while (deviceExtension != NULL) {

        //
        // The only objects that we care about are those that are marked as
        // PDOs and have a phsyical object associated with them
        //
        if (deviceExtension->Flags & DEV_TYPE_PDO &&
            deviceExtension->DeviceObject != NULL &&
            !(deviceExtension->Flags & DEV_MASK_NOT_PRESENT) ) {

            //
            // We don't ObReferenceO here because we are still at
            // dispatch level (and for efficiency's sake, we don't
            // want to drop down)
            //
            newRelations->Objects[index] =
                deviceExtension->DeviceObject;

            //
            // Update the location for the next object in the
            // relation
            //
            index += 1;

            //
            // And at the same time, clear the flag that says that
            // we haven't enumerated this
            //
            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                DEV_TYPE_NOT_ENUMERATED,
                TRUE
                );

        } // if (deviceExtension->Flags ... )

        //
        // Check to see if we have found all the objects that we care
        // about. As in, don't mess the system by walking past the end
        // of the device relations
        //
        if (newRelationSize == index) {

            //
            // Done
            //
            break;

        }

        //
        // Check to see if we have gone all the way around the list
        // list
        if (deviceExtension->SiblingDeviceList.Flink ==
            &(parentExtension->ChildDeviceList) ) {

            break;

        } // if

        //
        // Next element
        //
        deviceExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
            deviceExtension->SiblingDeviceList.Flink,
            DEVICE_EXTENSION,
            SiblingDeviceList
            );

    } // while (deviceExtension ... )

    //
    // Update the size of the relations by the number of matches that we
    // successfully made
    //
    newRelations->Count = index;
    newRelationSize = index;

    //
    // At this point, we are well and truely done with the spinlock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // We have to reference all of the objects that we added
    //
    index = (currentRelations != NULL ? currentRelations->Count : 0);
    for (; index < newRelationSize; index++) {

        //
        // Attempt to reference the object
        //
        status = ObReferenceObjectByPointer(
            newRelations->Objects[index],
            0,
            NULL,
            KernelMode
            );
        if (!NT_SUCCESS(status) ) {

            PDEVICE_OBJECT  tempDeviceObject;

            //
            // Hmm... Let the world know that this happened
            //
            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                "ACPIDetectPdoDevices: ObjReferenceObject(0x%08lx) "
                "= 0x%08lx\n",
                newRelations->Objects[index],
                status
                ) );

            //
            // Swap the bad element for the last one in the chain
            //
            newRelations->Count--;
            tempDeviceObject = newRelations->Objects[newRelations->Count];
            newRelations->Objects[newRelations->Count] =
                newRelations->Objects[index];
            newRelations->Objects[index] = tempDeviceObject;

        }

    }

    //
    // Free the old device relations (if it is present)
    //
    if (currentRelations) {

        ExFreePool( *DeviceRelations );

    }

    //
    // Update the device relation pointer
    //
    *DeviceRelations = newRelations;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

BOOLEAN
ACPIDetectPdoMatch(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PDEVICE_RELATIONS   DeviceRelations
    )
/*++

Routine Description:

    This routine takes a given extension and a set of relations and decides
    whether a new PDO should be created for the extension. Return result
    is *FALSE* if one should be created, *TRUE* if one was already created.

    NB:     This routine is called by a parent who owns the AcpiDeviceTreeLock...
    NNB:    This means that this routine is always called at DISPATCH_LEVEL

Arguments:

    DeviceExtension - What we are trying to match too
    DeviceRelations - What we are trying to match with

Return Value:

    TRUE    - The DeviceExtension can be ignored
    FALSE   - A device object needs to be created for the extension

--*/
{
    NTSTATUS       status;
    PDEVICE_OBJECT devicePdoObject = NULL ;

    PAGED_CODE();

    //
    // For this to work, we must set the DEV_TYPE_NOT_FOUND flag when we
    // first create the device and at any time when there is no device object
    // associated with the extension
    //
    if (!(DeviceExtension->Flags & DEV_TYPE_NOT_FOUND) ||
         (DeviceExtension->Flags & DEV_PROP_DOCK)      ||
         DeviceExtension->DeviceObject != NULL) {

        return TRUE;

    }

    //
    // deviceObject will be filled in if the extension in question is
    // already in the relation. The status will not be successful if the
    // extension could not be in the relation.
    //
    status = ACPIDetectCouldExtensionBeInRelation(
        DeviceExtension,
        DeviceRelations,
        FALSE,
        TRUE,
        &devicePdoObject
        ) ;

    return (devicePdoObject||(!NT_SUCCESS(status))) ? TRUE : FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\errlog.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    errlog.h

Abstract:

    This module contains the err log header

Author:

    Hanumant Yadav (hanumany)
    
Environment:

    NT Kernel Model Driver only

--*/

#ifndef _ERRLOG_H_
    #define _ERRLOG_H_

    extern  PDRIVER_OBJECT  AcpiDriverObject;

    
    NTSTATUS
    ACPIWriteEventLogEntry (
    IN  ULONG     ErrorCode,
    IN  PVOID     InsertionStrings, OPTIONAL
    IN  ULONG     StringCount,      OPTIONAL
    IN  PVOID     DumpData, OPTIONAL
    IN  ULONG     DataSize  OPTIONAL
    );

    PDEVICE_OBJECT 
    ACPIGetRootDeviceObject(
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\devpower.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dpower.h

Abstract:

    This handles requests to have devices set themselves at specific power
    levels

Author:

    Jason Clark (jasoncl)
    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    09-Oct-96 Initial Revision
    20-Nov-96 Interrupt Vector support
    31-Mar-97 Cleanup
    29-Sep-97 Major Rewrite

--*/

#ifndef _DEVPOWER_H_
#define _DEVPOWER_H_

    #define DEVICE_POWER_MAXIMUM    4
    #define SYSTEM_POWER_MAXIMUM    6

    //
    // Prototype function pointer
    //
    typedef NTSTATUS (*PACPI_POWER_FUNCTION)( IN PACPI_POWER_REQUEST);


    extern  BOOLEAN                 AcpiPowerDpcRunning;
    extern  BOOLEAN                 AcpiPowerWorkDone;
    extern  KSPIN_LOCK              AcpiPowerLock;
    extern  KSPIN_LOCK              AcpiPowerQueueLock;
    extern  LIST_ENTRY              AcpiPowerDelayedQueueList;
    extern  LIST_ENTRY              AcpiPowerQueueList;
    extern  LIST_ENTRY              AcpiPowerPhase0List;
    extern  LIST_ENTRY              AcpiPowerPhase1List;
    extern  LIST_ENTRY              AcpiPowerPhase2List;
    extern  LIST_ENTRY              AcpiPowerPhase3List;
    extern  LIST_ENTRY              AcpiPowerPhase4List;
    extern  LIST_ENTRY              AcpiPowerPhase5List;
    extern  LIST_ENTRY              AcpiPowerWaitWakeList;
    extern  LIST_ENTRY              AcpiPowerSynchronizeList;
    extern  LIST_ENTRY              AcpiPowerNodeList;
    extern  KDPC                    AcpiPowerDpc;
    extern  BOOLEAN                 AcpiPowerLeavingS0;
    extern  NPAGED_LOOKASIDE_LIST   ObjectDataLookAsideList;
    extern  NPAGED_LOOKASIDE_LIST   RequestLookAsideList;
    extern  DEVICE_POWER_STATE      DevicePowerStateTranslation[DEVICE_POWER_MAXIMUM];
    extern  SYSTEM_POWER_STATE      SystemPowerStateTranslation[SYSTEM_POWER_MAXIMUM];
    extern  ULONG                   AcpiSystemStateTranslation[PowerSystemMaximum];

    VOID
    ACPIDeviceCancelWaitWakeIrp(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID EXPORT
    ACPIDeviceCancelWaitWakeIrpCallBack(
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    ObjectData,
        IN  PVOID       Context
        );

    VOID
    ACPIDeviceCompleteCommon(
        IN  PULONG      OldWorkDone,
        IN  ULONG       NewWorkDone
        );

    VOID EXPORT
    ACPIDeviceCompleteGenericPhase(
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    ObjectData,
        IN  PVOID       Context
        );

    VOID EXPORT
    ACPIDeviceCompleteInterpreterRequest(
        IN  PVOID       Context
        );

    VOID EXPORT
    ACPIDeviceCompletePhase3Off(
        IN  PNSOBJ          AcpiObject,
        IN  NTSTATUS        Status,
        IN  POBJDATA        ObjectData,
        IN  PVOID           Context
        );

    VOID EXPORT
    ACPIDeviceCompletePhase3On(
        IN  PNSOBJ          AcpiObject,
        IN  NTSTATUS        Status,
        IN  POBJDATA        ObjectData,
        IN  PVOID           Context
        );

    VOID
    ACPIDeviceCompleteRequest(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDeviceInitializePowerRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  POWER_STATE             Power,
        IN  PACPI_POWER_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  POWER_ACTION            PowerAction,
        IN  ACPI_POWER_REQUEST_TYPE RequestType,
        IN  ULONG                   Flags
        );

    NTSTATUS
    ACPIDeviceInternalDelayedDeviceRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  DEVICE_POWER_STATE      DeviceState,
        IN  PACPI_POWER_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext
        );

    NTSTATUS
    ACPIDeviceInternalDeviceRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  DEVICE_POWER_STATE      DeviceState,
        IN  PACPI_POWER_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  ULONG                   Flags
        );

    VOID
    ACPIDeviceInternalQueueRequest(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PACPI_POWER_REQUEST PowerRequest,
        IN  ULONG               Flags
        );

    VOID
    ACPIDeviceIrpCompleteRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PVOID                   Context,
        IN  NTSTATUS                Status
        );

    VOID
    ACPIDeviceIrpDelayedDeviceOffRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PVOID                   Context,
        IN  NTSTATUS                Status
        );

    VOID
    ACPIDeviceIrpDelayedDeviceOnRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PVOID                   Context,
        IN  NTSTATUS                Status
        );

    NTSTATUS
    ACPIDeviceIrpDeviceFilterRequest(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PACPI_POWER_CALLBACK    CallBack
        );

    NTSTATUS
    ACPIDeviceIrpDeviceRequest(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PACPI_POWER_CALLBACK    CallBack
        );

    VOID
    ACPIDeviceIrpForwardRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PVOID                   Context,
        IN  NTSTATUS                Status
        );

    NTSTATUS
    ACPIDeviceIrpSystemRequest(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PACPI_POWER_CALLBACK    CallBack
        );

    NTSTATUS
    ACPIDeviceIrpWaitWakeRequest(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PACPI_POWER_CALLBACK    CallBack
        );

    VOID
    ACPIDeviceIrpWaitWakeRequestComplete(
        IN  PACPI_POWER_REQUEST     PowerRequest
        );

    VOID EXPORT
    ACPIDeviceIrpWaitWakeRequestPending(
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    ObjectData,
        IN  PVOID       Context
        );

    NTSTATUS
    ACPIDeviceIrpWarmEjectRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PIRP                    Irp,
        IN  PACPI_POWER_CALLBACK    CallBack,
        IN  BOOLEAN                 UpdateHardwareProfile
        );

    #define ACPIDeviceMapACPIPowerState( STATE )            \
        (STATE >= PowerSystemMaximum ?                      \
            (ULONG) -1 : AcpiSystemStateTranslation[STATE])
    #define ACPIDeviceMapPowerState( STATE )                \
        (STATE >= DEVICE_POWER_MAXIMUM ?                    \
            PowerDeviceUnspecified :                        \
            DevicePowerStateTranslation[STATE])
    #define ACPIDeviceMapSystemState( STATE)                \
        (STATE >= SYSTEM_POWER_MAXIMUM ?                    \
            PowerSystemUnspecified :                        \
            SystemPowerStateTranslation[STATE])

    NTSTATUS
    ACPIDevicePowerDetermineSupportedDeviceStates(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PULONG              SupportedPrStates,
        IN  PULONG              SupportedPsStates
        );

    VOID
    ACPIDevicePowerDpc(
        IN  PKDPC   Dpc,
        IN  PVOID   DpcContext,
        IN  PVOID   SystemArgument1,
        IN  PVOID   SystemArgument2
        );

    NTSTATUS
    ACPIDevicePowerFlushQueue(
        PDEVICE_EXTENSION       DeviceExtension
        );

    VOID
    ACPIDevicePowerNotifyEvent(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PVOID               Context,
        IN  NTSTATUS            Status
        );

    NTSTATUS
    ACPIDevicePowerProcessForward(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessGenericPhase(
        IN  PLIST_ENTRY             ListEntry,
        IN  PACPI_POWER_FUNCTION    **DispatchTable,
        IN  BOOLEAN                 Complete
        );

    NTSTATUS
    ACPIDevicePowerProcessInvalid(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase0DeviceSubPhase1(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase0DeviceSubPhase2(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase0SystemSubPhase1(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase1DeviceSubPhase1(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase1DeviceSubPhase2(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase1DeviceSubPhase3(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase1DeviceSubPhase4(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase2SystemSubPhase1(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase2SystemSubPhase2(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase2SystemSubPhase3(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase3(
        VOID
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase4(
        VOID
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5DeviceSubPhase1(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5DeviceSubPhase2(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5DeviceSubPhase3(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5DeviceSubPhase4(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5DeviceSubPhase5(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5DeviceSubPhase6(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5SystemSubPhase1(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5SystemSubPhase2(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5SystemSubPhase3(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5SystemSubPhase4(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5WarmEjectSubPhase1(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5WarmEjectSubPhase2(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessSynchronizeList(
        IN  PLIST_ENTRY             ListEntry
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\dispatch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dispatch.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _DISPATCH_H_
#define _DISPATCH_H_

    #define ACPIDispatchPnpTableSize    25
    #define ACPIDispatchPowerTableSize  5

    NTSTATUS
    ACPIDispatchAddDevice(
        IN  PDRIVER_OBJECT  DriverObject,
        IN  PDEVICE_OBJECT  PhysicalDeviceObject
        );

    NTSTATUS
    ACPIDispatchForwardIrp(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchForwardOrFailPowerIrp(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchForwardPowerIrp(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchPowerIrpUnhandled(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchIrp (
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDispatchIrpInvalid (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchIrpSuccess (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchIrpSurpriseRemoved(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchPowerIrpFailure(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchPowerIrpInvalid (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchPowerIrpSuccess (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchPowerIrpSurpriseRemoved(
       IN PDEVICE_OBJECT   DeviceObject,
       IN PIRP             Irp
       );

    VOID
    ACPIUnload(
        IN  PDRIVER_OBJECT  DriverObject
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\errlog.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    errlog.c

Abstract:

    This module contains routines for writting to the error log

Author:

    Hanumant Yadav

Environment:

    NT Kernel Model Driver only

Revision History:
    10/19/2000 Fixed event log function, removed dead code.

--*/

#include "pch.h"

//
// We need to know the name of the driver when we write log errors
//
PDRIVER_OBJECT  AcpiDriverObject;



NTSTATUS
ACPIWriteEventLogEntry (
    IN  ULONG     ErrorCode,
    IN  PVOID     InsertionStrings, OPTIONAL
    IN  ULONG     StringCount,      OPTIONAL
    IN  PVOID     DumpData, OPTIONAL
    IN  ULONG     DataSize  OPTIONAL
    )
/*++

Routine Description: Write a entry to the Event Log.

    

Arguments:

    ErrorCode           - ACPI error code (acpilog.mc). 
    InsertionStrings    - Strings to substitute in the .mc file error.
    StringCount         - number of strings being passed in InsertionStrings.
    DumpData            - Dump data.
    DataSize            - Dump data size.

Return Value:

    NTSTATUS            - STATUS_SUCCESS on success
                          STATUS_INSUFFICIENT_RESOURCES
                          STATUS_UNSUCCESSFUL
--*/
{
    NTSTATUS  status = STATUS_SUCCESS;
    ULONG     totalPacketSize = 0;
    ULONG     i, stringSize = 0;
    PWCHAR    *strings, temp;
    PIO_ERROR_LOG_PACKET  logEntry = NULL;


    //  
    // Calculate total string length, including NULL.
    //

    strings = (PWCHAR *) InsertionStrings;

    for (i = 0; i < StringCount; i++) 
    {
        UNICODE_STRING  unicodeString;

        RtlInitUnicodeString(&unicodeString, strings[i]);
        stringSize += unicodeString.Length + sizeof(UNICODE_NULL);
    }

    //
    // Calculate total packet size to allocate.  The packet must be
    // at least sizeof(IO_ERROR_LOG_PACKET) and not larger than
    // ERROR_LOG_MAXIMUM_SIZE or the IoAllocateErrorLogEntry call will fail.
    //

    totalPacketSize = (sizeof(IO_ERROR_LOG_PACKET)) + DataSize + stringSize;

    if (totalPacketSize <= ERROR_LOG_MAXIMUM_SIZE) 
    {
        //
        // Allocate the error log packet
        //
        logEntry = IoAllocateErrorLogEntry((PDRIVER_OBJECT) AcpiDriverObject,
                                         (UCHAR) totalPacketSize);

        if (logEntry) 
        {
            RtlZeroMemory(logEntry, totalPacketSize);

            //
            // Fill out the packet
            //
            logEntry->DumpDataSize          = (USHORT) DataSize;
            logEntry->NumberOfStrings       = (USHORT) StringCount;
            logEntry->ErrorCode             = ErrorCode;

            if (StringCount) 
            {
                logEntry->StringOffset = (USHORT) ((sizeof(IO_ERROR_LOG_PACKET)) + DataSize);
            }

            //
            // Copy Dump Data
            //
            if (DataSize) 
            {
                RtlCopyMemory((PVOID) logEntry->DumpData,
                              DumpData,
                              DataSize);
            }

            //
            // Copy String Data
            //
            temp = (PWCHAR) ((PUCHAR) logEntry + logEntry->StringOffset);

            for (i = 0; i < StringCount; i++) 
            {
                PWCHAR  ptr = strings[i];

                //
                // This routine will copy the null terminator on the string
                //
                while ((*temp++ = *ptr++) != UNICODE_NULL);
            }

            //
            // Submit error log packet
            //
            IoWriteErrorLogEntry(logEntry);
            
        }
        else
        {
            ACPIPrint((
                        ACPI_PRINT_CRITICAL,
                        "ACPIWriteEventLogEntry: Failed IoAllocateErrorLogEntry().\n"
                     ));
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        ACPIPrint((
                    ACPI_PRINT_CRITICAL,
                    "ACPIWriteEventLogEntry: Error Log Entry too large.\n"
                 ));

        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}


PDEVICE_OBJECT 
    ACPIGetRootDeviceObject(
    VOID
    )
/*++

Routine Description: Get the value of the ACPI root device object.

    

Arguments:

    None
    
Return Value:

    PDEVICE_OBJECT -	ACPI Root Device Object.	
    
--*/

{
    if(RootDeviceExtension)
    {
        return RootDeviceExtension->DeviceObject;
    }
    
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\extlist.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    extlist.c

Abstract:

    This module contains routines for managing ACPI extension lists

Author:

    Adrian J. Oney (AdriaO)

Environment:

    NT Kernel Model Driver only

    These routines are meant to be used as a for loop, ie:

       Iterate over the list using:

       ACPIExtListSetupEnum(...);

       for(
           ACPIExtListStartEnum(...);
           ACPIExtListTestElement(...);
           ACPIExtListEnumNext(...)
          ) {

          if (GoingToBreak) {

              ACPIExtListExitEnumEarly(...);
              break ;
          }
       }


Revision History:

    Feb 11, 1998    - Authored

--*/

#include "pch.h"

BOOLEAN
ACPIExtListIsFinished(
    IN PEXTENSIONLIST_ENUMDATA PExtList_EnumData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ACPIDebugEnter( "ACPIExtListIsFinished" );


    if (CONTAINING_LIST(PExtList_EnumData->pDevExtCurrent,
       PExtList_EnumData->ExtOffset) == PExtList_EnumData->pListHead) {

        return TRUE ;
    } 
    return FALSE ;

    ACPIDebugExit( "ACPIExtListIsFinished" );
}

PDEVICE_EXTENSION
EXPORT
ACPIExtListStartEnum(
    IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ACPIDebugEnter( "ACPIExtListStartEnum" );

    //
    // We must walk the tree at dispatch level <sigh>
    //
    if (PExtList_EnumData->WalkScheme != WALKSCHEME_NO_PROTECTION) {
       
        KeAcquireSpinLock(
          PExtList_EnumData->pSpinLock,
          &PExtList_EnumData->oldIrql
          );
    }

    //
    // Grab the first element
    //

    PExtList_EnumData->pDevExtCurrent = CONTAINING_EXTENSION(
        PExtList_EnumData->pListHead->Flink,
        PExtList_EnumData->ExtOffset
        );

    //
    // Return null if the list is empty (leave the internal pointer alone
    // though...
    //
    if (ACPIExtListIsFinished(PExtList_EnumData)) {
        return NULL ;
    }

    return PExtList_EnumData->pDevExtCurrent ;

    ACPIDebugExit( "ACPIExtListStartEnum" );
}

BOOLEAN
EXPORT
ACPIExtListTestElement(
    IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData,
    IN     BOOLEAN                 ContinueEnumeration
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{   
    ACPIDebugEnter( "ACPIExtListTestElement" );
    //
    // If finished or stopping, simply release the spinlock
    //
    if (ACPIExtListIsFinished(PExtList_EnumData)||(!ContinueEnumeration)) {

        if (PExtList_EnumData->WalkScheme != WALKSCHEME_NO_PROTECTION) {
          
            KeReleaseSpinLock(
              PExtList_EnumData->pSpinLock,
              PExtList_EnumData->oldIrql
              );  
        }

        return FALSE ;
    }

    if (PExtList_EnumData->WalkScheme == WALKSCHEME_REFERENCE_ENTRIES) {

        //
        // Always update the reference count to make sure that no one will
        // ever delete the node while our spinlock is down
        //
        InterlockedIncrement(
          &(PExtList_EnumData->pDevExtCurrent->ReferenceCount)
          );

         //
         // Relinquish the spin lock
         //
         KeReleaseSpinLock(
           PExtList_EnumData->pSpinLock,
           PExtList_EnumData->oldIrql
           );
    }

    return TRUE ;

    ACPIDebugExit( "ACPIExtListTestElement" );
}

PDEVICE_EXTENSION
EXPORT
ACPIExtListEnumNext(
    IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    LONG              oldReferenceCount ;
    PDEVICE_EXTENSION nextExtension ;
    BOOLEAN           enumComplete ;
    PLIST_ENTRY       listEntry ;

    ACPIDebugEnter( "ACPIExtListEnumNext" );

    if (PExtList_EnumData->WalkScheme != WALKSCHEME_REFERENCE_ENTRIES) {

        PExtList_EnumData->pDevExtCurrent = CONTAINING_EXTENSION(
            CONTAINING_LIST(PExtList_EnumData->pDevExtCurrent,
            PExtList_EnumData->ExtOffset)->Flink,
            PExtList_EnumData->ExtOffset
            );

        enumComplete = ACPIExtListIsFinished(PExtList_EnumData) ;

        return enumComplete ? NULL : PExtList_EnumData->pDevExtCurrent ;
    }

    //
    // Reacquire the spin lock
    //
    KeAcquireSpinLock(
      PExtList_EnumData->pSpinLock,
      &PExtList_EnumData->oldIrql 
      );

    //
    // Decrement the reference count on the node
    //
    oldReferenceCount = InterlockedDecrement(
        &(PExtList_EnumData->pDevExtCurrent->ReferenceCount)
        );

    ASSERT(!ACPIExtListIsFinished(PExtList_EnumData)) ;

    //
    // Next element
    //
    nextExtension = CONTAINING_EXTENSION(
        CONTAINING_LIST(PExtList_EnumData->pDevExtCurrent,
        PExtList_EnumData->ExtOffset)->Flink,
        PExtList_EnumData->ExtOffset
        );

    //
    // Remove the node, if necessary
    //
    if (oldReferenceCount == 0) {

        //
        // Deleted the old extension
        //
        ACPIInitDeleteDeviceExtension( PExtList_EnumData->pDevExtCurrent );
    }

    PExtList_EnumData->pDevExtCurrent = nextExtension ;

    enumComplete = ACPIExtListIsFinished(PExtList_EnumData) ;

    return enumComplete ? NULL : PExtList_EnumData->pDevExtCurrent ;
    ACPIDebugExit( "ACPIExtListEnumNext" );
} 

VOID
EXPORT
ACPIExtListExitEnumEarly(
    IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{   
    ACPIDebugEnter( "ACPIExtListExitEnumEarly" );

    //
    // Relinquish the spin lock
    //
    if (PExtList_EnumData->WalkScheme == WALKSCHEME_HOLD_SPINLOCK) {

        KeReleaseSpinLock(
          PExtList_EnumData->pSpinLock,
          PExtList_EnumData->oldIrql
          );
    }

    return ;
    ACPIDebugExit( "ACPIExtListExitEnumEarly" );
}


BOOLEAN
EXPORT
ACPIExtListIsMemberOfRelation(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PDEVICE_RELATIONS   DeviceRelations
    )
/*++

Routine Description:

    This routine takes a given device object and a set of relations and
    checks to see if the object is already in the relation list.

Arguments:

    DeviceObject    - Device object to look for
    DeviceRelations - Relations we should examine

Return Value:

    BOOLEAN         - TRUE if DeviceObject is a member of the relation.

--*/
{
    ULONG index = 0;

    ACPIDebugEnter( "ACPIExtListIsMemberOfRelation" );

    //
    // If the list is empty, the answer is obvious...
    //
    if (DeviceRelations == NULL) return FALSE ;

    for (index = 0; index < DeviceRelations->Count; index++) {

        if (DeviceRelations->Objects[index] == DeviceObject) {

            return TRUE ;
        }
    }

    return FALSE ;

    ACPIDebugExit( "ACPIExtListIsMemberOfRelation" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\dispatch.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains the dispatch code for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    Eric F. Nelson (enelson)   October, '98 -  Add GUID_ACPI_REGS_INTERFACE_...

--*/

#include "pch.h"


extern KEVENT ACPITerminateEvent;
extern PETHREAD ACPIThread;

//
// Local procedure to query HAL for ACPI register access routines
//
NTSTATUS
ACPIGetRegisterInterfaces(
    IN PDEVICE_OBJECT PciPdo
    );

//
// Local procedure to query HAL for port range rountines.
//
NTSTATUS
ACPIGetPortRangeInterfaces(
    IN PDEVICE_OBJECT Pdo
    );


NTSTATUS
ACPIDispatchAddDevice(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    )
/*++

Routine Description:

    This function contains code that is remarkably similar to the ACPIBuildNewXXX
    routines. However there are certain core differences (and thus why this routine
    is not named ACPIBuildNewFDO). The first difference is that at this time we do
    not yet know the address of the ACPI _SB object. The second is that none of the
    names need to be generated.

Arguments:

    DriverObject        - Represents this device driver
    PhysicalDeviceObject- This is 1/2 of the Win9X dev node

Return Value:

    Are we successfull or what?

--*/
{
    KIRQL               oldIrql;
    NTSTATUS            status;
    PACPI_POWER_INFO    powerInfo;
    PDEVICE_EXTENSION   deviceExtension     = NULL;
    PDEVICE_OBJECT      newDeviceObject     = NULL;
    PDEVICE_OBJECT      tempDeviceObject    = NULL;
    PUCHAR              buffer              = NULL;
    PUCHAR              deviceID            = NULL;
    PUCHAR              instanceID          = NULL;

    //
    // Note: This code isn't actually pagable --- it must be called
    // PASSIVE_LEVEL
    //
    PAGED_CODE();

    //
    // Generate a Device ID (fake)
    //
    deviceID = ExAllocatePoolWithTag( NonPagedPool, 14, ACPI_STRING_POOLTAG);
    if (deviceID == NULL) {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIDispatchAddDevice: Could not allocate %#08lx bytes\n",
            14
            ) );
        status =  STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIDispatchAddDeviceExit;

    }
    strcpy( deviceID, "ACPI\\PNP0C08" );

    //
    // Generate an Instance ID (Fake)
    //
    instanceID = ExAllocatePoolWithTag( NonPagedPool, 11, ACPI_STRING_POOLTAG);
    if (instanceID == NULL) {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIDispatchAddDevice: Could not allocate %#08lx bytes\n",
            11
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIDispatchAddDeviceExit;

    }
    strcpy( instanceID, "0x5F534750" );

    //
    // Create a new object for the device
    //
    status = IoCreateDevice(
        DriverObject,
        0,
        NULL,
        FILE_DEVICE_ACPI,
        0,
        FALSE,
        &newDeviceObject
        );

    //
    // Did we make the device object?
    //
    if (!NT_SUCCESS(status)) {

        //
        // Let the world know we failed
        //
        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIDispatchAddDevice: %s - %#08lx\n",
            deviceID, status
            ) );
        goto ACPIDispatchAddDeviceExit;

    }

    //
    // Attempt to attach to the PDO
    //
    tempDeviceObject = IoAttachDeviceToDeviceStack(
        newDeviceObject,
        PhysicalDeviceObject
        );
    if (tempDeviceObject == NULL) {

        //
        // An error occured while referencing the device...
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIDispatchAddDevice: IoAttachDeviceToDeviceStack(%#08lx,%#08lx) "
            "== NULL\n",
            newDeviceObject, PhysicalDeviceObject
            ) );

        //
        // No such device
        //
        status = STATUS_NO_SUCH_DEVICE;
        goto ACPIDispatchAddDeviceExit;

    }

    //
    // At this point, we can attempt to create the device extension.
    //
    deviceExtension = ExAllocateFromNPagedLookasideList(
            &DeviceExtensionLookAsideList
            );
    if (deviceExtension == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIDispatchAddDevice: Could not allocate memory for extension\n"
            ) );

        //
        // Memory failure
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIDispatchAddDeviceExit;

    }

    //
    // First, lets begin with a clean extension
    //
    RtlZeroMemory( deviceExtension, sizeof(DEVICE_EXTENSION) );

    //
    // Initialize the reference count mechanism.
    //
    InterlockedIncrement( &(deviceExtension->ReferenceCount) );
    InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

    //
    // Initialize the link fields
    //
    newDeviceObject->DeviceExtension        = deviceExtension;
    deviceExtension->DeviceObject           = newDeviceObject;
    deviceExtension->PhysicalDeviceObject   = PhysicalDeviceObject;
    deviceExtension->TargetDeviceObject     = tempDeviceObject;

    //
    // Initialize the data fields
    //
    deviceExtension->Signature              = ACPI_SIGNATURE;
    deviceExtension->DispatchTable          = &AcpiFdoIrpDispatch;
    deviceExtension->DeviceID               = deviceID;
    deviceExtension->InstanceID             = instanceID;

    //
    // Initialize the power info
    //
    powerInfo = &(deviceExtension->PowerInfo);
    powerInfo->DevicePowerMatrix[PowerSystemUnspecified] =
        PowerDeviceUnspecified;
    powerInfo->DevicePowerMatrix[PowerSystemWorking]    = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemSleeping1]  = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemSleeping2]  = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemSleeping3]  = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemHibernate]  = PowerDeviceD3;
    powerInfo->DevicePowerMatrix[PowerSystemShutdown]   = PowerDeviceD3;
    powerInfo->SystemWakeLevel = PowerSystemUnspecified;
    powerInfo->DeviceWakeLevel = PowerDeviceUnspecified;

    //
    // Initialize the flags
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_TYPE_FDO | DEV_CAP_NO_STOP | DEV_PROP_UID | DEV_PROP_HID |
        DEV_PROP_FIXED_HID | DEV_PROP_FIXED_UID,
        FALSE
        );

    //
    // Initialize the list entry fields
    //
    InitializeListHead( &(deviceExtension->ChildDeviceList) );
    InitializeListHead( &(deviceExtension->SiblingDeviceList) );
    InitializeListHead( &(deviceExtension->EjectDeviceHead) );
    InitializeListHead( &(deviceExtension->EjectDeviceList) );

    //
    // Initialize the queue for power requests
    //
    InitializeListHead( &(deviceExtension->PowerInfo.PowerRequestListEntry) );

    //
    // Yes! Now, setup the root device extension. We need a spinlock for this
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
    RootDeviceExtension = deviceExtension;
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Query for ACPI register interfaces
    //
    ACPIGetRegisterInterfaces(PhysicalDeviceObject);

    //
    // Query for HAL port range interfaces.
    //
    ACPIGetPortRangeInterfaces(PhysicalDeviceObject);

#ifdef WMI_TRACING
    //
    // Initialize WMI Loging.
    //
    ACPIWmiInitLog(newDeviceObject);
    //
    // Enable WMI Logging for boot.
    //
    ACPIGetWmiLogGlobalHandle();

#endif //WMI_TRACING

    //
    // Clear the Initialization Flag
    //
    newDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;


ACPIDispatchAddDeviceExit:

    //
    // Free things if the status is not success
    //
    if (!NT_SUCCESS(status)) {

        if (deviceID != NULL) {

            ExFreePool( deviceID );

        }

        if (instanceID != NULL) {

            ExFreePool( instanceID );

        }

        if (tempDeviceObject != NULL) {

            IoDetachDevice( tempDeviceObject );

        }

        if (newDeviceObject != NULL) {

            IoDeleteDevice( newDeviceObject );

        }

        if (deviceExtension != NULL) {

            ExFreeToNPagedLookasideList(
                &DeviceExtensionLookAsideList,
                deviceExtension
                );

        }

    }

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIDispatchAddDevice: %08lx\n",
        status
        ) );
    return status;
}

NTSTATUS
ACPIDispatchForwardIrp(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine is called when the driver doesn't want to handle the
    irp explicitly, but rather pass it along

Arguments:

    DeviceObject    - The target for the request
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            status;

    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    if (deviceExtension->TargetDeviceObject) {

        //
        // Forward to target device
        //
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (deviceExtension->TargetDeviceObject, Irp);

    } else {

        //
        // Don't touch the IRP
        //
#if DBG
        UCHAR majorFunction;

        majorFunction = IoGetCurrentIrpStackLocation(Irp)->MajorFunction;

        ASSERT((majorFunction == IRP_MJ_PNP) ||
               (majorFunction == IRP_MJ_DEVICE_CONTROL) ||
               (majorFunction == IRP_MJ_SYSTEM_CONTROL));
#endif

        status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}

NTSTATUS
ACPIDispatchForwardOrFailPowerIrp(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine is called when the driver doesn't want to handle the Power
    Irp any longer

Arguments:

    DeviceObject    - The target of the power request
    Irp             - The power Request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;

    PoStartNextPowerIrp( Irp );
    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    //
    // Forward the irp along, *unless* we are a PDO. In the later case,
    // the irp is at the bottom of its stack (even if there is a target
    // device object)
    //
    if ( !(deviceExtension->Flags & DEV_TYPE_PDO) &&
           deviceExtension->TargetDeviceObject       ) {

        //
        // Forward power irp to target device
        //
        IoCopyCurrentIrpStackLocationToNext ( Irp );
        status = PoCallDriver (deviceExtension->TargetDeviceObject, Irp);

    } else {

        //
        // Complate/fail the irp with the not implemented code
        //
        status = Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return status;
}

NTSTATUS
ACPIDispatchForwardPowerIrp(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine is called when the driver doesn't want to handle the Power
    Irp any longer.

Arguments:

    DeviceObject    - The target of the power request
    Irp             - The power Request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;

    PoStartNextPowerIrp( Irp );
    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    //
    // Forward the irp along, *unless* we are a PDO. In the later case,
    // the irp is at the bottom of its stack (even if there is a target
    // device object)
    //
    if (deviceExtension->TargetDeviceObject &&
        !(deviceExtension->Flags & DEV_TYPE_PDO)
        ) {

        //
        // Forward power irp to target device
        //
        IoSkipCurrentIrpStackLocation( Irp );
        status = PoCallDriver (deviceExtension->TargetDeviceObject, Irp);

    } else {

        //
        // Complate/fail the irp with it's current status code
        //
        status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}

NTSTATUS
ACPIDispatchPowerIrpUnhandled(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine is called when an unhandled power IRP is received by an ACPI
    enumerated PDO.

Arguments:

    DeviceObject    - The target of the power request
    Irp             - The power Request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;

#if DBG
    PDEVICE_EXTENSION   deviceExtension;

    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    ASSERT(deviceExtension->Flags & DEV_TYPE_PDO);
#endif

    PoStartNextPowerIrp( Irp );

    //
    // Complate/fail the irp with it's current status code
    //
    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}

NTSTATUS
ACPIDispatchIrp (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    KIRQL                   oldIrql;
    LONG                    oldReferenceCount;
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      irpSp;
    PIRP_DISPATCH_TABLE     dispatchTable;
    PDRIVER_DISPATCH        dispatch;
    BOOLEAN                 remove;
    KEVENT                  removeEvent;
    UCHAR                   minorFunction;


    //
    // We need the IrpStack no matter what happens
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // This is evil. But we have to do this is we are to remain in
    // sync with the surprise removal code path. Note that we specifically
    // do not call the ACPIInternalGetDeviceExtension() function here
    // because that would ignore the surprise removed extension, which we
    // want to know about here.
    //
    status = ACPIInternalGetDispatchTable(
        DeviceObject,
        &deviceExtension,
        &dispatchTable
        );

    //
    // We have the device extension. Now see if it exists. If it does not,
    // then it is because we have deleted the object, but the system hasn't
    // gotten around to destroying it
    //
    if (deviceExtension == NULL ||
        deviceExtension->Flags & DEV_TYPE_REMOVED ||
        deviceExtension->Signature != ACPI_SIGNATURE
        ) {

        //
        // Let the world know
        //
        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "ACPIDispatchIrp: Deleted Device 0x%08lx got Irp 0x%08lx\n",
            DeviceObject,
            Irp
            ) );

        //
        // Is this a power irp?
        //
        if (irpSp->MajorFunction == IRP_MJ_POWER) {

            return ACPIDispatchPowerIrpSurpriseRemoved( DeviceObject, Irp );

        } else {

            return ACPIDispatchIrpSurpriseRemoved( DeviceObject, Irp );

        }

    }

    //
    // Get the dispatch table that we will be using and the minor code as well,
    // so that we can look it when required
    //
    minorFunction = irpSp->MinorFunction;

    //
    // Should be true because no IRPs should be received while we are removing
    // ourselves. Anyone sending such an IRP missed a broadcast somewhere, and
    // is thus in error.
    //
    ASSERT(deviceExtension->RemoveEvent == NULL) ;

    //
    // Handle the irp differently based on the major code that we are seeing
    //
    switch (irpSp->MajorFunction) {
    case IRP_MJ_POWER:

        if (minorFunction < (ACPIDispatchPowerTableSize-1) ) {

            //
            // Obtain the function pointer from the dispatch table
            //
            dispatch = dispatchTable->Power[ minorFunction ];

        } else {

            //
            // Use the default dispatch point from the table
            //
            dispatch = dispatchTable->Power[ ACPIDispatchPowerTableSize -1 ];

        }

        //
        // Reference the device
        //
        InterlockedIncrement(&deviceExtension->OutstandingIrpCount);

        //
        // Dispatch to handler, then remove our reference
        //
        status = dispatch (DeviceObject, Irp);

        //
        // Remove our reference, if the count goes to zero then signal
        // for remove complete
        //
        ACPIInternalDecrementIrpReferenceCount( deviceExtension );
        break;

    case IRP_MJ_PNP:

        if (minorFunction == IRP_MN_START_DEVICE) {

            //
            // Dispatch to start device handler
            //
            dispatch = dispatchTable->PnpStartDevice;

        } else if (minorFunction < (ACPIDispatchPnpTableSize-1)) {

            //
            // Dispatch based on minor function. Not that we don't store
            // IRP_MN_START_DEVICE (0x0) in this table, so we have to
            // sub one from the minor code
            //
            dispatch = dispatchTable->Pnp[minorFunction];

        } else {

            //
            // Out of dispatch tables range
            //
            dispatch = dispatchTable->Pnp[ACPIDispatchPnpTableSize-1];

        }

        //
        // If this is a PnP remove device event, then perform special
        // remove processing
        //
        if ((minorFunction == IRP_MN_REMOVE_DEVICE)||
            (minorFunction == IRP_MN_SURPRISE_REMOVAL)) {

            //
            // Mark the device as removed (ie: block new irps from entering)
            // and remember what the target event is
            //
            KeInitializeEvent (
                &removeEvent,
                SynchronizationEvent,
                FALSE);
            deviceExtension->RemoveEvent = &removeEvent;

            //
            // There may be some wake requests pending on this device. Lets
            // cancel those irps now
            //
            ACPIWakeEmptyRequestQueue (deviceExtension );

            //
            // Are we the last irp to go through the device?
            //
            oldReferenceCount =
               InterlockedDecrement(&deviceExtension->OutstandingIrpCount) ;

            ASSERT(oldReferenceCount >= 0) ;
            if ( oldReferenceCount != 0 ) {

                //
                // Wait for other irps to terminate
                //
                KeWaitForSingleObject (
                    &removeEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL
                    );

            }

            //
            // Increment the outstanding IRP count. We do this because the
            // device may not actually go away, in which case this needs to
            // be at one after the IRP returns. Therefore the remove dispatch
            // routine must not drop the IRP reference count of course...
            //
            InterlockedIncrement(&deviceExtension->OutstandingIrpCount);

            //
            // Dispatch to remove handler
            //
            deviceExtension->RemoveEvent = NULL;
            status = dispatch (DeviceObject, Irp);

        } else {

            //
            // Increment the reference count on the device
            //
            InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

            //
            // Dispatch to handler, then remove our reference
            //
            status = dispatch (DeviceObject, Irp);

            //
            // Decrement the reference count on the device
            //
            ACPIInternalDecrementIrpReferenceCount(
                deviceExtension
                );

        }
        break;

    default:

        //
        // These cases are similar
        //
        if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) {

            dispatch = dispatchTable->DeviceControl;

        } else if (irpSp->MajorFunction == IRP_MJ_CREATE ||
            minorFunction == IRP_MJ_CLOSE) {

            dispatch = dispatchTable->CreateClose;

        } else if (irpSp->MajorFunction == IRP_MJ_SYSTEM_CONTROL) {

            dispatch = dispatchTable->SystemControl;

        } else {

            dispatch = dispatchTable->Other;
        }

        //
        // Reference the device
        //
        InterlockedIncrement(&deviceExtension->OutstandingIrpCount);

        //
        // Dispatch to handler
        //
        status = dispatch (DeviceObject, Irp);

        //
        // Remove our reference
        //
        ACPIInternalDecrementIrpReferenceCount( deviceExtension );
        break;

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIDispatchIrpInvalid (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    //
    // Fail the Irp as something that we don't support
    //
    Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
ACPIDispatchIrpSuccess (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDispatchIrpSurpriseRemoved(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_NO_SUCH_DEVICE;
}

NTSTATUS
ACPIDispatchPowerIrpFailure(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PoStartNextPowerIrp( Irp );
    Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
ACPIDispatchPowerIrpInvalid (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PoStartNextPowerIrp( Irp );
    Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
ACPIDispatchPowerIrpSuccess (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PoStartNextPowerIrp( Irp );
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDispatchPowerIrpSurpriseRemoved (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PoStartNextPowerIrp( Irp );
    Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE ;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_NO_SUCH_DEVICE;
}

VOID
ACPIUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
/*++

Routine Description:

    This routine is called when the driver is supposed to unload

    Since this is a PnP driver, I'm not to sure what I need to do here.
    Lets just assume that the system is responsible for sending me removes
    for all my device objects, and I can just clean up the rest

Arguments:

    DriverObject    - The pointer to ourselves

Return Value:

    NONE

--*/
{
    UNREFERENCED_PARAMETER(DriverObject);

    //
    // Signal termination to the worker thread.
    //
    KeSetEvent(&ACPITerminateEvent, 0, FALSE);

    //
    // And wait for the worker thread to die.
    //
    KeWaitForSingleObject(ACPIThread, Executive, KernelMode, FALSE, 0);

    ObDereferenceObject (ACPIThread);

    //
    // Make ourselves clean up
    //
    ACPICleanUp();

    //
    // Free Memory
    //
    ExDeleteNPagedLookasideList(&BuildRequestLookAsideList);
    ExDeleteNPagedLookasideList(&RequestLookAsideList);
    ExDeleteNPagedLookasideList(&DeviceExtensionLookAsideList);
    ExDeleteNPagedLookasideList(&ObjectDataLookAsideList);
    ExDeleteNPagedLookasideList(&PswContextLookAsideList);
    if (AcpiRegistryPath.Buffer != NULL) {

        ExFreePool( AcpiRegistryPath.Buffer );

    }
    if (AcpiProcessorString.Buffer != NULL) {

        ExFreePool( AcpiProcessorString.Buffer );

    }

    //
    // Done
    //
    ACPIPrint( (
        ACPI_PRINT_WARNING,
        "ACPIUnload: Called --- unloading ACPI driver\n"
        ) );

    ASSERT( DriverObject->DeviceObject == NULL );
}



NTSTATUS
ACPIGetRegisterInterfaces(
    IN PDEVICE_OBJECT PciPdo
    )
/*++

Routine Description:

    This function queries the PCI bus for interfaces used to access
    the ACPI registers

Arguments:

    PciPdo - PDO for the PCI bus

Return Value:

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      topDeviceInStack;
    KEVENT              irpCompleted;
    PIRP                irp;
    IO_STATUS_BLOCK     statusBlock;
    PIO_STACK_LOCATION  irpStack;

    extern PREAD_ACPI_REGISTER   AcpiReadRegisterRoutine;
    extern PWRITE_ACPI_REGISTER  AcpiWriteRegisterRoutine;

    ACPI_REGS_INTERFACE_STANDARD AcpiRegsInterfaceStd;

    PAGED_CODE();

    KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);

    //
    // Send an IRP to the PCI bus to get ACPI register interfaces.
    //
    topDeviceInStack = IoGetAttachedDeviceReference(PciPdo);
    if (!topDeviceInStack) {

        return STATUS_NO_SUCH_DEVICE;

    }

    irp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        topDeviceInStack,
        NULL,    // Buffer
        0,       // Length
        0,       // StartingOffset
        &irpCompleted,
        &statusBlock
        );
    if (!irp) {

        ObDereferenceObject( topDeviceInStack );
        return STATUS_UNSUCCESSFUL;

    }
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;
    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set the function codes and parameters.
    //
    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpStack->Parameters.QueryInterface.InterfaceType =
        &GUID_ACPI_REGS_INTERFACE_STANDARD;
    irpStack->Parameters.QueryInterface.Size =
        sizeof(ACPI_REGS_INTERFACE_STANDARD);
    irpStack->Parameters.QueryInterface.Version = 1;
    irpStack->Parameters.QueryInterface.Interface =
        (PINTERFACE)&AcpiRegsInterfaceStd;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Call the driver and wait for completion
    //
    status = IoCallDriver(topDeviceInStack, irp);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &irpCompleted,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = statusBlock.Status;

    }

    //
    // Done with object reference...
    //
    ObDereferenceObject( topDeviceInStack );

    //
    // Did we get some interfaces?
    //
    if (NT_SUCCESS(status)) {

        AcpiReadRegisterRoutine  = AcpiRegsInterfaceStd.ReadAcpiRegister;
        AcpiWriteRegisterRoutine = AcpiRegsInterfaceStd.WriteAcpiRegister;

    }
    return status;
}

NTSTATUS
ACPIGetPortRangeInterfaces(
    IN PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:

    This function queries the HAL for interfaces used to manage
    the port ranges registers

--*/
{
    NTSTATUS            Status;
    PDEVICE_OBJECT      topDeviceInStack;
    KEVENT              irpCompleted;
    PIRP                irp;
    IO_STATUS_BLOCK     StatusBlock;
    PIO_STACK_LOCATION  irpStack;

    PAGED_CODE();

    KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);

    //
    // Send an IRP to the PCI bus to get ACPI register interfaces.
    //
    topDeviceInStack = IoGetAttachedDeviceReference(Pdo);
    if (!topDeviceInStack) {
        return STATUS_NO_SUCH_DEVICE;
    }

    irp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        topDeviceInStack,
        NULL,    // Buffer
        0,       // Length
        0,       // StartingOffset
        &irpCompleted,
        &StatusBlock
        );
    if (!irp) {

        ObDereferenceObject( topDeviceInStack );
        return STATUS_UNSUCCESSFUL;

    }
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;
    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set the function codes and parameters.
    //
    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpStack->Parameters.QueryInterface.InterfaceType =
        &GUID_ACPI_PORT_RANGES_INTERFACE_STANDARD;
    irpStack->Parameters.QueryInterface.Size =
        sizeof(HAL_PORT_RANGE_INTERFACE);
    irpStack->Parameters.QueryInterface.Version = 0;
    irpStack->Parameters.QueryInterface.Interface =
        (PINTERFACE)&HalPortRangeInterface;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Call the driver and wait for completion
    //
    Status = IoCallDriver(topDeviceInStack, irp);
    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &irpCompleted,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        Status = StatusBlock.Status;
    }

    //
    // Done with object reference...
    //
    ObDereferenceObject( topDeviceInStack );

    //
    // Did we get some interfaces?
    //
    if (NT_SUCCESS(Status)) {
        // XXX
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\extlist.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    extlist.h

Abstract:

    This is the header for managing ACPI extension lists

Author:

    Adrian J. Oney (AdriaO)


Environment:

    NT Kernel Model Driver only

--*/

#ifndef _EXTLIST_H_
#define _EXTLIST_H_

typedef enum {
   
   WALKSCHEME_NO_PROTECTION,
   WALKSCHEME_REFERENCE_ENTRIES,
   WALKSCHEME_HOLD_SPINLOCK

} WALKSCHEME ;

//
// The following structures and functions are used to simiplify (ok, abstract)
// walking lists of device extensions that happen to be stored inside other
// extensions (eg Children, Ejectee's, etc)
//

typedef struct {

    PLIST_ENTRY       pListHead ;
    PKSPIN_LOCK       pSpinLock ;
    KIRQL             oldIrql;
    PDEVICE_EXTENSION pDevExtCurrent ;
    ULONG_PTR         ExtOffset ;
    WALKSCHEME        WalkScheme ;

} EXTENSIONLIST_ENUMDATA, *PEXTENSIONLIST_ENUMDATA ;

//
// This is like CONTAINING_RECORD, only it's hardcoded for DEVICE_EXTENSION
// type and it uses precalculated field offsets instead of record names
//

#define CONTAINING_EXTENSION(address, fieldoffset) \
  ((PDEVICE_EXTENSION) ((PCHAR)(address) - (ULONG_PTR)(fieldoffset)))

#define CONTAINING_LIST(address, fieldoffset) \
  ((PLIST_ENTRY) ((PCHAR)(address)+(ULONG_PTR)(fieldoffset)))

#define ACPIExtListSetupEnum(PExtList_EnumData, pListHeadArg, pSpinLockArg, OffsetField, WalkSchemeArg) \
  { \
   PEXTENSIONLIST_ENUMDATA peled = (PExtList_EnumData) ; \
    peled->pListHead  = (pListHeadArg) ; \
    peled->pSpinLock  = (pSpinLockArg) ; \
    peled->ExtOffset = FIELD_OFFSET(DEVICE_EXTENSION, OffsetField) ; \
    peled->WalkScheme = (WalkSchemeArg) ; \
  }

    PDEVICE_EXTENSION
    EXPORT
    ACPIExtListStartEnum(
        IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData
        ) ;

    BOOLEAN
    EXPORT
    ACPIExtListTestElement(
        IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData,
        IN     BOOLEAN ContinueEnumeration
        ) ;

    PDEVICE_EXTENSION
    EXPORT
    ACPIExtListEnumNext(
        IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData
        ) ;

    VOID
    EXPORT
    ACPIExtListExitEnumEarly(
        IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData
        );

    BOOLEAN
    EXPORT
    ACPIExtListIsMemberOfRelation(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PDEVICE_RELATIONS   DeviceRelations
        );

#endif // _EXTLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\gpe.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    gpe.h

Abstract:

    contains all structures protyptes for connecting external
    vectors to the Gpe Engine

Environment

    Kernel mode only

Revision History:

    03/22/00 - Initial Revision

--*/

#ifndef _GPE_H_
#define _GPE_H_

    //
    // Lock to protect all the table accesses
    //
    extern KSPIN_LOCK           GpeTableLock;
    extern PUCHAR               GpeEnable;
    extern PUCHAR               GpeCurEnable;
    extern PUCHAR               GpeIsLevel;
    extern PUCHAR               GpeHandlerType;
    //
    // Possible wake bits that are currently enabled
    //
    extern PUCHAR               GpeWakeEnable;
    //
    // These are wake bits with methods
    //
    extern PUCHAR               GpeWakeHandler;
    extern PUCHAR               GpeSpecialHandler;
    //
    // These are the GPEs that have been processed
    //
    extern PUCHAR               GpePending;
    extern PUCHAR               GpeRunMethod;
    extern PUCHAR               GpeComplete;
    extern PUCHAR               GpeMap;
    //
    // This is what lets us remember state
    //
    extern PUCHAR               GpeSavedWakeMask;
    extern PUCHAR               GpeSavedWakeStatus;

    //
    // For PNP/QUERY_INTERFACE
    //
    extern ACPI_INTERFACE_STANDARD  ACPIInterfaceTable;

    //
    // For logging errors
    //
    typedef struct _ACPI_GPE_ERROR_CONTEXT {
        WORK_QUEUE_ITEM Item;
        ULONG           GpeIndex;
    } ACPI_GPE_ERROR_CONTEXT, *PACPI_GPE_ERROR_CONTEXT;

    VOID
    ACPIGpeBuildEventMasks(
        VOID
        );

    VOID
    ACPIGpeBuildWakeMasks(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    VOID
    ACPIGpeClearEventMasks(
        VOID
        );

    VOID
    ACPIGpeClearRegisters(
        VOID
        );

    VOID
    ACPIGpeEnableDisableEvents(
        BOOLEAN                 Enable
        );

    VOID
    ACPIGpeHalEnableDisableEvents(
        BOOLEAN                 Enable
        );

    VOID
    ACPIGpeEnableWakeEvents(
        VOID
        );

    ULONG
    ACPIGpeIndexToByteIndex(
        ULONG                   Index
        );

    ULONG
    ACPIGpeIndexToGpeRegister(
        ULONG                   Index
        );

    BOOLEAN
    ACPIGpeInstallRemoveIndex(
        ULONG                   GpeIndex,
        ULONG                   Action,
        ULONG                   Type,
        PBOOLEAN                HasControlMethod
        );

    VOID
    ACPIGpeInstallRemoveIndexErrorWorker(
        IN  PVOID   Context
        );

    BOOLEAN
    ACPIGpeIsEvent(
        VOID
        );

    ULONG
    ACPIGpeRegisterToGpeIndex(
        ULONG                   Register,
        ULONG                   BitPosition
        );

    VOID
    ACPIGpeUpdateCurrentEnable(
        IN  ULONG               GpeRegister,
        IN  UCHAR               Completed
        );

    BOOLEAN
    ACPIGpeValidIndex(
        ULONG                   Index
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\filter.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    filter.c

Abstract:

    This module contains the filter dispatcher for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July-09-97  Removed ACPIFilterIrpQueryId

--*/

#include "pch.h"

extern ACPI_INTERFACE_STANDARD  ACPIInterfaceTable;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIFilterIrpDeviceUsageNotification)
#pragma alloc_text(PAGE, ACPIFilterIrpEject)
#pragma alloc_text(PAGE, ACPIFilterIrpQueryCapabilities)
#pragma alloc_text(PAGE, ACPIFilterIrpQueryDeviceRelations)
#pragma alloc_text(PAGE, ACPIFilterIrpQueryInterface)
#pragma alloc_text(PAGE, ACPIFilterIrpQueryPnpDeviceState)
#pragma alloc_text(PAGE, ACPIFilterIrpSetLock)
#pragma alloc_text(PAGE, ACPIFilterIrpStartDevice)
#pragma alloc_text(PAGE, ACPIFilterIrpStartDeviceWorker)
#pragma alloc_text(PAGE, ACPIFilterIrpStopDevice)
#endif

VOID
ACPIFilterFastIoDetachCallback(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PDEVICE_OBJECT  LowerDeviceObject
    )
/*++

Routine Description:

    This routine is called when the device object beneath this bus filter
    has called IoDeleteDevice. We detach and delete ourselves now...

Arguments:

    DeviceObject    - The DeviceObject that must be removed
    Irp             - The request to remove ourselves

Return Value:

--*/
{
    PDEVICE_EXTENSION   deviceExtension;

    //
    // Get the device extension that is attached to this device
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    ACPIDevPrint( (
        ACPI_PRINT_REMOVE,
        deviceExtension,
        "ACPIFilterFastIoDetachCallBack invoked\n"
        ) );

    if ( (deviceExtension->Flags & (DEV_TYPE_FILTER | DEV_TYPE_PDO)) !=
         DEV_TYPE_FILTER) {

        //
        // This case should only occur if we were called for our FDO leaving.
        // In no other cases should any device objects be below ours.
        //
        ASSERT(deviceExtension->Flags & DEV_TYPE_FDO) ;
        return;

    }

    //
    // Set the device state as 'removed'. Note that we should not disappear
    // except in the context of a remove IRP.
    //
    ASSERT(deviceExtension->DeviceState == Stopped);
    deviceExtension->DeviceState = Removed ;

    //
    // Delete all the children of this device
    //
    ACPIInitDeleteChildDeviceList( deviceExtension );

    //
    // Reset this extension to the default values
    //
    ACPIInitResetDeviceExtension( deviceExtension );
}

NTSTATUS
ACPIFilterIrpDeviceUsageNotification(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called to let ACPI know that the device is on one
    particulare type of path.

Argument:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    PAGED_CODE();

    //
    // Copy the stack location...
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // Set the completion event to be called...
    //
    IoSetCompletionRoutine(
        Irp,
        ACPIFilterIrpDeviceUsageNotificationCompletion,
        NULL,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // We have a callback routine --- so we need to make sure to
    // increment the ref count since we will handle it later
    //
    InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

    //
    // Pass the IRP along
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, IRP_MN_DEVICE_USAGE_NOTIFICATION),
        status
        ) );
    return status;
}

NTSTATUS
ACPIFilterIrpDeviceUsageNotificationCompletion (
    IN  PDEVICE_OBJECT   DeviceObject,
    IN  PIRP             Irp,
    IN  PVOID            Context
    )
/*++

Routine Description:

    This routine will wait until the parent is done with the device
    notification and then perform whatever is required to finish the
    task

Arguments:

    DeviceObject    - The device that was notified
    Irp             - The notification
    Context         - Not Used

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpSp           = IoGetCurrentIrpStackLocation (Irp);

    //
    // Since we aren't returning STATUS_MORE_PROCESSING_REQUIRED and
    // synchronizing this IRP, we must migrate upwards the pending bit...
    //
    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );
    }

    //
    // Grab the 'real' status
    //
    status = Irp->IoStatus.Status;

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx (processing)\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, IRP_MN_DEVICE_USAGE_NOTIFICATION),
        status
        ) );

    //
    // Did we succeed the request?
    //
    if (NT_SUCCESS(status)) {

        //
        // Do we care about the usage type?
        //
        if (irpSp->Parameters.UsageNotification.Type ==
            DeviceUsageTypeHibernation) {

            //
            // Yes --- then perform the addition or subtraction required
            //
            IoAdjustPagingPathCount(
                &(deviceExtension->HibernatePathCount),
                irpSp->Parameters.UsageNotification.InPath
                );

        }

    }

    //
    // No matter what happens, we need to see if the DO_POWER_PAGABLE bit
    // is still set. If it isn't, then we need to clear it out
    //
    if ( (deviceExtension->Flags & DEV_TYPE_FILTER) ) {

        if ( (deviceExtension->TargetDeviceObject->Flags & DO_POWER_PAGABLE) ) {

            deviceExtension->DeviceObject->Flags |= DO_POWER_PAGABLE;

        } else {

            deviceExtension->DeviceObject->Flags &= ~DO_POWER_PAGABLE;

        }

    }

    //
    // Remove our reference
    //
    ACPIInternalDecrementIrpReferenceCount( deviceExtension );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIFilterIrpEject(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_EJECT requests sent
    to the PDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    return ACPIIrpSetPagableCompletionRoutineAndForward(
        DeviceObject,
        Irp,
        ACPIBusAndFilterIrpEject,
        NULL,
        FALSE,
        TRUE,
        FALSE,
        FALSE
        );
}

NTSTATUS
ACPIFilterIrpQueryCapabilities(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_CAPABILITIES
    requests sent to the PDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    return ACPIIrpSetPagableCompletionRoutineAndForward(
        DeviceObject,
        Irp,
        ACPIBusAndFilterIrpQueryCapabilities,
        NULL,
        TRUE,
        TRUE,
        FALSE,
        FALSE
        );
}

NTSTATUS
ACPIFilterIrpQueryDeviceRelations(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_DEVICE_RELATIONS
    requests sent to the Filter Device Objects

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             filterRelations = FALSE;
    KEVENT              queryEvent;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_RELATIONS   deviceRelations;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;
    NTSTATUS            detectStatus;

    PAGED_CODE();

    //
    // Get the current status of the IRP
    //
    status = Irp->IoStatus.Status;

    //
    // We can't ignore any device relations that have already been given.
    //
    if (NT_SUCCESS(status)) {

        deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;

    } else {

        deviceRelations = NULL;
    }

    switch(irpStack->Parameters.QueryDeviceRelations.Type) {

        case BusRelations:

            //
            // Remember that we have to filter the relations
            //
            filterRelations = TRUE;
            status = ACPIRootIrpQueryBusRelations(
                DeviceObject,
                Irp,
                &deviceRelations
                );
            break ;

        case EjectionRelations:

            status = ACPIBusAndFilterIrpQueryEjectRelations(
                DeviceObject,
                Irp,
                &deviceRelations
                );
            break ;

        default:
            status = STATUS_NOT_SUPPORTED ;
            break ;
    }

    if (status != STATUS_NOT_SUPPORTED) {

        //
        // Pass the IRP status along
        //
        Irp->IoStatus.Status = status;

    }

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s (d) = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    //
    // If we failed, then we cannot simply pass the irp along
    //
    if (!NT_SUCCESS(status) && status != STATUS_NOT_SUPPORTED) {

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;

    }

    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

    } else if (status != STATUS_NOT_SUPPORTED) {

        //
        // If we haven't succeed the irp, then we can also fail it
        //
        Irp->IoStatus.Information = (ULONG_PTR) NULL;
    }

    //
    // Initialize an event so that we can block
    //
    KeInitializeEvent( &queryEvent, SynchronizationEvent, FALSE );

    //
    // If we succeeded, then we must set a completion routine so that we
    // can do some post-processing
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );
    IoSetCompletionRoutine(
        Irp,
        ACPIRootIrpCompleteRoutine,
        &queryEvent,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Pass the irp along
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Wait for it to come back...
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &queryEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab the 'real' status
        //
        status = Irp->IoStatus.Status;

    }

    //
    // If we succeeded, then we should try to load the filters
    //
    if (NT_SUCCESS(status) && filterRelations) {

        //
        // Grab the device relations
        //
        detectStatus = ACPIDetectFilterDevices(
            DeviceObject,
            (PDEVICE_RELATIONS) Irp->IoStatus.Information
            );
        ACPIDevPrint( (
            ACPI_PRINT_IRP,
            deviceExtension,
            "(0x%08lx): %s (u) = %#08lx\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            detectStatus
            ) );

    }

    //
    // Done with the IRP
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIFilterIrpQueryPnpDeviceState(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_DEVICE_STATE
    requests sent to the Filter Device Objects

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    return ACPIIrpSetPagableCompletionRoutineAndForward(
        DeviceObject,
        Irp,
        ACPIBusAndFilterIrpQueryPnpDeviceState,
        NULL,
        TRUE,
        TRUE,
        FALSE,
        FALSE
        );
}

NTSTATUS
ACPIFilterIrpQueryPower(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This handles a request for legal power states to transition into.

Arguments:

    DeviceObject    - The PDO target of the request
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpSp           = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              acpiObject;
    PNSOBJ              ejectObject;
    SYSTEM_POWER_STATE  systemState;
    ULONG               packedEJx;

    //
    // Get the Current stack location to determine if we are a system
    // irp or a device irp. We ignore device irps here and any system
    // irp that isn't of type PowerActionWarmEject
    //
    if (irpSp->Parameters.Power.Type != SystemPowerState) {

        //
        // We don't handle this irp
        //
        return ACPIDispatchForwardPowerIrp(DeviceObject, Irp);

    }
    if (irpSp->Parameters.Power.ShutdownType != PowerActionWarmEject) {

        //
        // No eject work - forward along the IRP.
        //
        return ACPIDispatchForwardPowerIrp(DeviceObject, Irp);

    }

    //
    // What system state are we looking at?
    //
    systemState = irpSp->Parameters.Power.State.SystemState;

    //
    // Restrict power states if a warm eject has been queued.
    //
    acpiObject = deviceExtension->AcpiObject ;

    if (ACPIDockIsDockDevice(acpiObject)) {

        //
        // Don't touch this device, the profile provider manages eject
        // transitions.
        //
        return ACPIDispatchForwardPowerIrp(DeviceObject, Irp);
    }

    switch (systemState) {
        case PowerSystemSleeping1: packedEJx = PACKED_EJ1; break;
        case PowerSystemSleeping2: packedEJx = PACKED_EJ2; break;
        case PowerSystemSleeping3: packedEJx = PACKED_EJ3; break;
        case PowerSystemHibernate: packedEJx = PACKED_EJ4; break;
        default: return ACPIDispatchPowerIrpFailure( DeviceObject, Irp );
    }

    //
    // Does the appropriate object exist for this device?
    //
    ejectObject = ACPIAmliGetNamedChild( acpiObject, packedEJx) ;
    if (ejectObject == NULL) {

        //
        // Fail the request, as we cannot eject in this case.
        //
        return ACPIDispatchPowerIrpFailure( DeviceObject, Irp );

    }

    //
    // Mark the irp as succeeded and pass it down
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    return ACPIDispatchForwardPowerIrp( DeviceObject, Irp );
}

NTSTATUS
ACPIFilterIrpQueryId(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine will override the PDOs QueryID routine in the case
    that the device contains a PCI Bar Target Operation Region.

    This is required so that we can load the PCI Bar Target driver
    on top of the stack instead of whatever driver would have been
    attached anyways.

    Note:   This is what the returned strings from this function should
            look like. This is from mail that lonny sent.

            DeviceID    = ACPI\PNPxxxx
            InstanceID  = yyyy
            HardwareID  = ACPI\PNPxxxx,*PNPxxxx

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    BUS_QUERY_ID_TYPE   type;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    // Get the device extension. We need to make a decision based upon
    // wether or not the device is marked as a PCI Bar Target...
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    if (!(deviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET)) {

        //
        // Let the underlying PDO handle the request...
        //
        return ACPIDispatchForwardIrp( DeviceObject, Irp );

    }

    //
    // The only thing we are really interested in smashing are the
    // device and hardware ids... So, if this isn't one of those types,
    // then let the PDO handle it...
    //
    type = irpStack->Parameters.QueryId.IdType;
    if (type != BusQueryDeviceID &&
        type != BusQueryCompatibleIDs &&
        type != BusQueryHardwareIDs) {

        //
        // Let the underlying PDO handle the request...
        //
        return ACPIDispatchForwardIrp( DeviceObject, Irp );

    }

    //
    // At this point we have to handle the QueryID request ourselves and
    // not let the PDO see it.
    //
    return ACPIBusIrpQueryId( DeviceObject, Irp );
}

NTSTATUS
ACPIFilterIrpQueryInterface(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine will smash Translator Interfaces for interrupts
    that have been provided by the devnode's FDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    CM_RESOURCE_TYPE    resource;
    GUID                *interfaceType;
    NTSTATUS            status          = STATUS_NOT_SUPPORTED;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    ULONG               count;

    PAGED_CODE();

    //
    // Obtain the info we will need from the irp
    //
    resource = (CM_RESOURCE_TYPE)
        PtrToUlong(irpStack->Parameters.QueryInterface.InterfaceSpecificData);
    interfaceType = (LPGUID) irpStack->Parameters.QueryInterface.InterfaceType;

#if DBG
    {
        NTSTATUS        status2;
        UNICODE_STRING  guidString;

        status2 = RtlStringFromGUID( interfaceType, &guidString );
        if (NT_SUCCESS(status2)) {

            ACPIDevPrint( (
                ACPI_PRINT_IRP,
                deviceExtension,
                "(0x%08lx): %s - Res %x Type = %wZ\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, irpStack->MinorFunction),
                resource,
                &guidString
                ) );

            RtlFreeUnicodeString( &guidString );

        }
    }
#endif

    //
    // *Only* Handle the Guids that we know about. Do Not Ever touch
    // any other GUID
    //
    if (CompareGuid(interfaceType, (PVOID) &GUID_ACPI_INTERFACE_STANDARD)) {

        PACPI_INTERFACE_STANDARD    interfaceDestination;

        //
        // Only copy up to current size of the ACPI_INTERFACE structure
        //
        if (irpStack->Parameters.QueryInterface.Size >
            sizeof (ACPI_INTERFACE_STANDARD) ) {

            count = sizeof (ACPI_INTERFACE_STANDARD);

        } else {

            count = irpStack->Parameters.QueryInterface.Size;

        }

        //
        // Find where we will store the interface
        //
        interfaceDestination = (PACPI_INTERFACE_STANDARD)
            irpStack->Parameters.QueryInterface.Interface;

        //
        // Copy from the global table to the caller's table, using size
        // specified.  Give caller only what was asked for, for
        // backwards compatibility.
        //
        RtlCopyMemory (
            interfaceDestination,
            &ACPIInterfaceTable,
            count
            );

        //
        // Make sure that we can give the user back the correct context. To do
        // this we need to calculate that the number of bytes we are giving back
        // is at least more than that is required to store a pointer at the
        // correct place in the structure
        //
        if (count > (FIELD_OFFSET(ACPI_INTERFACE_STANDARD, Context) + sizeof(PVOID) ) ) {

            interfaceDestination->Context = DeviceObject;

        }

        //
        // Done with the irp
        //
        status = STATUS_SUCCESS;

    } else if (CompareGuid(interfaceType, (PVOID) &GUID_TRANSLATOR_INTERFACE_STANDARD) &&
                   (resource == CmResourceTypeInterrupt)) {

        //
        // Smash any interface that has already been reported because we
        // want to arbitrate UNTRANSLATED resources.  We can be certain
        // that the HAL underneath will provide the translator interface that
        // has to be there.
        //

        // TEMPTEMP HACKHACK  This should last only as long as the PCI
        // driver is building its IRQ translator.
        //
        // EFN: Remove this HACKHACK on Alpha
        //
#ifndef _ALPHA_
        if (IsPciBus(DeviceObject)) {
            SmashInterfaceQuery(Irp);
        }
#endif // _ALPHA_

    }

    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;

        if (!NT_SUCCESS(status)) {

            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return status;
        }
    }

    //
    // Send the irp along
    //
    return ACPIDispatchForwardIrp( DeviceObject, Irp );
}

NTSTATUS
ACPIFilterIrpRemoveDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called when a filter object get's a remove IRP. Note that
    we only detach and delete if the PDO did so (which we will find out via our
    fast-IO-detach callback)

Arguments:

    DeviceObject    - The DeviceObject that must be removed
    Irp             - The request to remove ourselves

Return Value:

--*/
{
    LONG                oldReferenceCount;
    KIRQL               oldIrql;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;
    KEVENT              removeEvent ;
    ACPI_DEVICE_STATE   incomingState ;
    BOOLEAN             pciDevice;

    //
    // Get the current extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // All IRPs we own should already have been processed at this point, and
    // the outstanding irp count should be exactly one. Similarly, the
    // device extension reference count should be at least one.
    //
    ASSERT(deviceExtension->OutstandingIrpCount == 1) ;
    ASSERT(deviceExtension->ReferenceCount > 0) ;

    incomingState = deviceExtension->DeviceState ;
    if (incomingState != SurpriseRemoved) {

        if ( IsPciBusExtension(deviceExtension) ) {

            //
            // If this is PCI bridge, then we
            // may have _REG methods to evaluate.
            //
            EnableDisableRegions(deviceExtension->AcpiObject, FALSE);

         }

    }

    //
    // Dereference any outstanding interfaces
    //
    ACPIDeleteFilterInterfaceReferences( deviceExtension );

    //
    // Increment the ref count by one so the node doesn't go away while the
    // IRP is below us. We do this so we can stop the device after the IRP
    // comes back. This is neccessary because we are also held down by the
    // FastIoDetach callback of the filter.
    //
    InterlockedIncrement(&deviceExtension->ReferenceCount);

    //
    // Set the device state as 'stopped' . It doesn't become 'removed' until
    // the device object under it has been deleted.
    //
    deviceExtension->DeviceState = Stopped;

    //
    // Initialize an event so that we can block
    //
    KeInitializeEvent( &removeEvent, SynchronizationEvent, FALSE );

    //
    // If we succeeded, then we must set a completion routine so that we
    // can do some post-processing
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );
    IoSetCompletionRoutine(
        Irp,
        ACPIRootIrpCompleteRoutine,
        &removeEvent,
        TRUE,
        TRUE,
        TRUE
        );
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Wait for it to come back...
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &removeEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab the 'real' status
        //
        status = Irp->IoStatus.Status;

    }

    ACPIDevPrint( (
        ACPI_PRINT_REMOVE,
        deviceExtension,
        "(%#08lx): %s (pre) = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    if (!NT_SUCCESS(status)) {

        //
        // I guess someone can fail the request..
        //
        goto ACPIFilterIrpRemoveDeviceExit;

    }

    //
    // Attempt to stop the device (if possible)
    //
    // N.B. If the PDO was deleted, the device object's extension field is now
    //      NULL. On both NT and 9x, enumerations and starts are gaurenteed
    //      not to occur until a remove IRP has completed and the stack has
    //      unwound. Thus we should never get in the case where a new device
    //      object is attached to our extension while we are finishing up a
    //      remove IRP.
    //
    if (incomingState != SurpriseRemoved) {

        ACPIInitStopDevice( deviceExtension, TRUE );

    }

    //
    // Has our ACPI namespace entry left? See if the reference count drops to
    // zero when we release it.
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    oldReferenceCount = InterlockedDecrement(&deviceExtension->ReferenceCount);

    //
    // This might be zero if the table entry in ACPI has been removed, the node
    // under us deleted itself, and now we ourselves have left.
    //
    ASSERT(oldReferenceCount >= 0) ;

    //
    // Do we get to delete the node?
    //
    if (oldReferenceCount == 0) {

        //
        // We should already have detached, deleted, and changed state.
        //
        ASSERT(deviceExtension->DeviceState == Removed) ;

        //
        // Delete the extension. Bye bye.
        //
        ACPIInitDeleteDeviceExtension( deviceExtension );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

ACPIFilterIrpRemoveDeviceExit:

    //
    // Use PDO's return result. If he fails, we do too.
    //
    status = Irp->IoStatus.Status ;
    IoCompleteRequest(Irp, IO_NO_INCREMENT) ;
    return status;

}

NTSTATUS
ACPIFilterIrpSetLock(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_SET_LOCK requests sent
    to the PDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    return ACPIIrpSetPagableCompletionRoutineAndForward(
        DeviceObject,
        Irp,
        ACPIBusAndFilterIrpSetLock,
        NULL,
        TRUE,
        TRUE,
        FALSE,
        FALSE
        );
}

NTSTATUS
ACPIFilterIrpSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Power requests sent to filter objects are handled here

Arguments:

    DeviceObject    - The target of the power request
    Irp             - The power request

Return value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  deviceState;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              regMethod       = NULL;

    //
    // What we do depends on wether or not we want to power on or off
    // the device
    //
    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        if (irpStack->Parameters.Power.ShutdownType != PowerActionWarmEject) {

            //
            // Send the irp along
            //
            return ACPIDispatchForwardPowerIrp(
                DeviceObject,
                Irp
                );

        }

        //
        // In this case, we need to run an eject request before we pass the
        // irp along. Since we are going to do some work on the irp, mark it
        // as being successfull for now
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // We must call IoMarkIrpPending here, because after this point,
        // it will be too late (ie: the Irp will already be in the queues)
        // this basically means that we must return STATUS_PENDING from
        // this case, reguardless of the actual status
        //
        IoMarkIrpPending( Irp );

        //
        // This counts as setting a completion routine
        //
        InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

        //
        // We must handle the request before the Pdo sees it. After we
        // are done, we can forward the irp along
        //
        status = ACPIDeviceIrpWarmEjectRequest(
            deviceExtension,
            Irp,
            ACPIDeviceIrpForwardRequest,
            FALSE
            );

        //
        // If we got back STATUS_MORE_PROCESSING_REQUIRED, then that is
        // just an alias for STATUS_PENDING, so we make that change now
        //
        if (status == STATUS_MORE_PROCESSING_REQUIRED) {

            status = STATUS_PENDING;

        }
        return status;

    }

    //
    // Does this object have a reg method?
    //
    if (!(deviceExtension->Flags & DEV_PROP_NO_OBJECT) ) {

        regMethod = ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_REG
            );

    }

    deviceState = irpStack->Parameters.Power.State.DeviceState;
    if (deviceState == PowerDeviceD0) {

        //
        // We are going to some work on this Irp, so mark it as being
        // successfull for now
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // We must call IoMarkIrpPending here, because after this point,
        // it will be too late (ie: the Irp will already be in the queues)
        // this basically means that we must return STATUS_PENDING from
        // this case, reguardless of the actual status
        //
        IoMarkIrpPending( Irp );

        //
        // This counts as setting a completion routine
        //
        InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

        //
        // we must only do the _REG method stuff if one actually
        // exists for *this* device
        //

        //
        // We must handle the request before the Pdo sees it. After we
        // are done, we can forward the irp along
        //
        status = ACPIDeviceIrpDeviceRequest(
            DeviceObject,
            Irp,
            (regMethod ? ACPIDeviceIrpDelayedDeviceOnRequest :
                         ACPIDeviceIrpForwardRequest)
            );

        //
        // If we got back STATUS_MORE_PROCESSING_REQUIRED, then that is
        // just an alias for STATUS_PENDING, so we make that change now
        //
        if (status == STATUS_MORE_PROCESSING_REQUIRED) {

            status = STATUS_PENDING;

        }

    } else if (regMethod) {

        //
        // We are going to some work on this Irp, so mark it as being
        // successfull for now
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // We must call IoMarkIrpPending here, because after this point,
        // it will be too late (ie: the Irp will already be in the queues)
        // this basically means that we must return STATUS_PENDING from
        // this case, reguardless of the actual status
        //
        IoMarkIrpPending( Irp );

        //
        // This counts as setting a completion routine
        //
        InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

        //
        // We must handle the request and the turn off the _REG methods before
        // the Pdo sees it. After we are done, we can set a completion routine
        // so that we can then power off the device
        //
        status = ACPIBuildRegOffRequest(
            DeviceObject,
            Irp,
            ACPIDeviceIrpDelayedDeviceOffRequest
            );

        //
        // If we got back STATUS_MORE_PROCESSING_REQUIRED, then that is
        // just an alias for STATUS_PENDING, so we make that change now
        //
        if (status == STATUS_MORE_PROCESSING_REQUIRED) {

            status = STATUS_PENDING;

        }

    } else {

        //
        // Increment the OutstandingIrpCount since a completion routine
        // counts for this purpose
        //
        InterlockedIncrement( (&deviceExtension->OutstandingIrpCount) );

        //
        // Forward the power irp to target device
        //
        IoCopyCurrentIrpStackLocationToNext( Irp );

        //
        // We want the completion routine to fire. We cannot call
        // ACPIDispatchForwardPowerIrp here because we set this completion
        // routine
        //
        IoSetCompletionRoutine(
            Irp,
            ACPIDeviceIrpDeviceFilterRequest,
            ACPIDeviceIrpCompleteRequest,
            TRUE,
            TRUE,
            TRUE
            );

        //
        // Start the next power irp
        //
        PoStartNextPowerIrp( Irp );

        //
        // Let the person below us execute. Note: we can't block at
        // any time within this code path.
        //
        ASSERT( deviceExtension->TargetDeviceObject != NULL);
        PoCallDriver( deviceExtension->TargetDeviceObject, Irp );
        status = STATUS_PENDING;

    }

    return status;
}

NTSTATUS
ACPIFilterIrpStartDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to start the device...

Arguments:

    DeviceObject    - The device to start
    Irp             - The request with the appropriate information in it...

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS                    status;
    PDEVICE_EXTENSION           deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION          irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR                       minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Print that we got a start
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = %#08lx (enter)\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        Irp->IoStatus.Status
        ) );

    //
    // Start the filter
    //
    status = ACPIInitStartDevice(
        DeviceObject,
        irpStack->Parameters.StartDevice.AllocatedResources,
        ACPIFilterIrpStartDeviceCompletion,
        Irp,
        Irp
        );

    //
    // This IRP is completed later.  So return STATUS_PENDING.
    //
    if (NT_SUCCESS(status)) {

        return STATUS_PENDING;

    } else {

        return status;

    }

}

VOID
ACPIFilterIrpStartDeviceCompletion(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is the call back routine that is invoked when we have finished
    programming the resources

    This routine queues a work item since we cannot pass the START_IRP down
    at DPC level. Note, however, that we can complete the START_IRP at DPC
    level.

Arguments:

    DeviceExtension - Extension of the device that was started
    Context         - The Irp
    Status          - The result

Return Value:

    None

--*/
{
    PIRP                irp         = (PIRP) Context;
    PWORK_QUEUE_CONTEXT workContext = &(DeviceExtension->Filter.WorkContext);

    irp->IoStatus.Status = Status;
    if (NT_SUCCESS(Status)) {

        DeviceExtension->DeviceState = Started;

    } else {

        IoCompleteRequest( irp, IO_NO_INCREMENT );
        return;

    }

    //
    // We can't run EnableDisableRegions at DPC level,
    // so queue a worker item.
    //
    ExInitializeWorkItem(
          &(workContext->Item),
          ACPIFilterIrpStartDeviceWorker,
          workContext
          );
    workContext->DeviceObject = DeviceExtension->DeviceObject;
    workContext->Irp = irp;
    ExQueueWorkItem(
          &(workContext->Item),
          DelayedWorkQueue
          );
}

VOID
ACPIFilterIrpStartDeviceWorker(
    IN  PVOID   Context
    )
/*++

Routine Description:

    This funtion gets called before the PDO has seen the start and
    before the FDO has.  This is important for PCI to PCI bridges
    because we need to let ASL go in and configure the devices
    between these two operations.

    We need to let PDO see the start before we tell the ASL to go in
    and configure the devices between the PCI-PCI bridges.

Arguments:

    Context - The WORK_QUEUE_CONTEXT

Return Value:

    None

--*/
{
    KEVENT              event;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      deviceObject;
    PIRP                irp;
    PIO_STACK_LOCATION  irpStack;
    PWORK_QUEUE_CONTEXT workContext = (PWORK_QUEUE_CONTEXT) Context;
    UCHAR               minorFunction;

    PAGED_CODE();

    //
    // Grab the parameters that we need out of the Context
    //
    deviceObject    = workContext->DeviceObject;
    deviceExtension = ACPIInternalGetDeviceExtension( deviceObject );
    irp             = workContext->Irp;
    irpStack        = IoGetCurrentIrpStackLocation( irp );
    minorFunction   = irpStack->MinorFunction;
    status          = irp->IoStatus.Status;

    //
    // Setup the event so that we are notified of when this is done. This is
    // a cheap mechanism to ensure that we will always run the completion
    // code at PASSIVE_LEVEL
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Copy the stack location
    //
    IoCopyCurrentIrpStackLocationToNext( irp );

    //
    // We want our completion routine to fire...
    //  (we reuse the one from the Root since the same things must be done)
    //
    IoSetCompletionRoutine(
        irp,
        ACPIRootIrpCompleteRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx (forwarding)\n",
        irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );


    //
    // Let the IRP execute
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, irp );
    if (status == STATUS_PENDING) {

        //
        // Wait for it
        //
        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab the 'real' status
        //
        status = irp->IoStatus.Status;

    }

    //
    // What happened?
    //
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(%#08lx): %s = %#08lx (failed)\n",
            irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            status
            ) );
        //
        // Failure
        //
        goto ACPIFilterIrpStartDeviceWorkerExit;

    }

    //
    // Set the interfaces
    //
    ACPIInitBusInterfaces( deviceObject );

    //
    // Determine if this is a PCI device or bus or not...
    //
    status = ACPIInternalIsPci( deviceObject );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            " - failed ACPIInternalIsPciDevice = %#08lx\n",
            status
            ) );

        //
        // Failure
        //
        goto ACPIFilterIrpStartDeviceWorkerExit;

    }

    //
    // If this is a PCI bus, we have set the PCI bus flag
    //
    if ( ( deviceExtension->Flags & DEV_CAP_PCI) ) {

        //
        // Run all _REG methods under this device.
        //
        EnableDisableRegions(deviceExtension->AcpiObject, TRUE);

    }

    //
    // If we are a PCI bus or a PCI device, we must consider wether or
    // not we own setting or clearing the PCI PME pin
    //
    if ( (deviceExtension->Flags & DEV_MASK_PCI) ) {

        ACPIWakeInitializePciDevice(
            deviceObject
            );

    }

ACPIFilterIrpStartDeviceWorkerExit:
    //
    // Done with the irp
    //
    IoCompleteRequest( irp, IO_NO_INCREMENT );
}

NTSTATUS
ACPIFilterIrpStopDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to stop the device

Arguments:

    DeviceObject    - The device to stop
    Irp             - The request to tell us how to do it...

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    PAGED_CODE();

    //
    // Note: we can only stop a device from within the Inactive state...
    //
    if (deviceExtension->DeviceState != Inactive) {

        ASSERT( deviceExtension->DeviceState == Inactive );
        Irp->IoStatus.Status = status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        goto ACPIFilterIrpStopDeviceExit;

    }

    if (IsPciBus(deviceExtension->DeviceObject)) {

        //
        // If this is PCI bridge, then we
        // may have _REG methods to evaluate.
        //

        EnableDisableRegions(deviceExtension->AcpiObject, FALSE);
    }

    //
    // Copy the stack location...
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // Set the completion event to be called...
    //
    IoSetCompletionRoutine(
        Irp,
        ACPIFilterIrpStopDeviceCompletion,
        NULL,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // We have a callback routine --- so we need to make sure to
    // increment the ref count since we will handle it later
    //
    InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

    //
    // Send the request along
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

ACPIFilterIrpStopDeviceExit:
    //
    // done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx (forwarding)\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, IRP_MN_STOP_DEVICE),
        status
        ) );
    return status;
}

NTSTATUS
ACPIFilterIrpStopDeviceCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This routine is called when the PDO has stoped the device

Arguments:

    DeviceObject    - The Device to be stoped
    Irp             - The request
    Context         - Not Used

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = Irp->IoStatus.Status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx (processing)\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, IRP_MN_STOP_DEVICE),
        status
        ) );

    //
    // Migrate the pending bit as we are not returning
    // STATUS_MORE_PROCESSING_REQUIRED
    //
    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );

    }

    if (NT_SUCCESS(status)) {

        //
        // Set the device as 'Stopped'
        //
        deviceExtension->DeviceState = Stopped;

        //
        // Attempt to stop the device (if possible)
        //
        ACPIInitStopDevice( deviceExtension, FALSE );

    }

    //
    // Decrement our reference count
    //
    ACPIInternalDecrementIrpReferenceCount( deviceExtension );

    //
    // Done
    //
    return STATUS_SUCCESS ;
}

NTSTATUS
ACPIFilterIrpSurpriseRemoval(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called when a filter object get's a remove IRP. Note that
    we only detach and delete if the PDO did so (which we will find out via our
    fast-IO-detach callback)

Arguments:

    DeviceObject    - The DeviceObject that must be removed
    Irp             - The request to remove ourselves

Return Value:

--*/
{
    KIRQL               oldIrql;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;
    KEVENT              surpriseRemoveEvent;

    //
    // Get the current extension.
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // If the device is really gone, then consider it stopped
    //
    if ( !ACPIInternalIsReportedMissing(deviceExtension) ) {

        deviceExtension->DeviceState = Inactive;
        return ACPIFilterIrpStopDevice( DeviceObject, Irp );

    }

    //
    // All IRPs we own should already have been processed at this point, and
    // the outstanding irp count should be exactly one. Similarly, the
    // device extension reference count should be at least one.
    //
    ASSERT(deviceExtension->OutstandingIrpCount == 1) ;
    ASSERT(deviceExtension->ReferenceCount > 0) ;

    if (IsPciBus(deviceExtension->DeviceObject)) {

        //
        // If this is PCI bridge, then we
        // may have _REG methods to evaluate.
        //
        EnableDisableRegions(deviceExtension->AcpiObject, FALSE);

    }

    //
    // Set the device state as surprise removed
    //
    deviceExtension->DeviceState = SurpriseRemoved;

    //
    // Initialize an event so that we can block
    //
    KeInitializeEvent( &surpriseRemoveEvent, SynchronizationEvent, FALSE );

    //
    // If we succeeded, then we must set a completion routine so that we
    // can do some post-processing
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );
    IoSetCompletionRoutine(
        Irp,
        ACPIRootIrpCompleteRoutine,
        &surpriseRemoveEvent,
        TRUE,
        TRUE,
        TRUE
        );
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Wait for it to come back...
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &surpriseRemoveEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab the 'real' status
        //
        status = Irp->IoStatus.Status;

    }

    ACPIDevPrint( (
        ACPI_PRINT_REMOVE,
        deviceExtension,
        "(%#08lx): %s (pre) = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    //
    // Do nothing if other's aborted (ie, PDO doesn't support IRP.) Later, I
    // should check on the way down, as it is much more likely that the FDO
    // will not support this attempt.
    //
    if (!NT_SUCCESS(status)) {

        goto ACPIFilterIrpSurpriseRemovalExit;

    }

    //
    // Attempt to stop the device (if possible)
    //
    ACPIInitStopDevice( deviceExtension, TRUE );

    //
    // There are far better places to do this
    //
#if 0
    //
    // Free the resources that are specific to this instance
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
    if (deviceExtension->ResourceList != NULL) {

        ExFreePool( deviceExtension->ResourceList );

    }
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
#endif

    //
    // Is the device really gone? In other words, did ACPI not see it the
    // last time that it was enumerated?
    //
    ACPIBuildSurpriseRemovedExtension(deviceExtension);

ACPIFilterIrpSurpriseRemovalExit:
    ACPIDevPrint( (
        ACPI_PRINT_REMOVE,
        deviceExtension,
        "(%#08lx): %s (post) = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    //
    // Done with the request
    //
    Irp->IoStatus.Status = status ;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\gpe.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    gpe.c

Abstract:

    This module is how the ACPI driver interfaces with GPE Events

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Mode Driver Only

--*/

#include "pch.h"

//
// Global tables for GPE handling (Both GP0 and GP1)
//
PUCHAR  GpeEnable           = NULL;
PUCHAR  GpeCurEnable        = NULL;
PUCHAR  GpeWakeEnable       = NULL;
PUCHAR  GpeIsLevel          = NULL;
PUCHAR  GpeHandlerType      = NULL;
PUCHAR  GpeWakeHandler      = NULL;
PUCHAR  GpeSpecialHandler   = NULL;
PUCHAR  GpePending          = NULL;
PUCHAR  GpeRunMethod        = NULL;
PUCHAR  GpeComplete         = NULL;
PUCHAR  GpeSavedWakeMask    = NULL;
PUCHAR  GpeSavedWakeStatus  = NULL;
PUCHAR  GpeMap              = NULL;

//
// Lock to protect all GPE related information
//
KSPIN_LOCK          GpeTableLock;


VOID
ACPIGpeBuildEventMasks(
    VOID
    )
/*++

Routine Description:

    This routine looks at all the General Purpose Event sources and
    builds up a mask of which events should be enabled, which events
    are special, and which events are wake up events

Arguments:

    None

Return Value:

    None

--*/
{
    BOOLEAN     convertedToNumber;
    KIRQL       oldIrql;
    NTSTATUS    status;
    PNSOBJ      gpeObject;
    PNSOBJ      gpeMethod;
    ULONG       nameSeg;
    ULONG       gpeIndex;

    //
    // NOTENOTE --- Check to make sure sure that the following sequence
    // of acquiring locks is correct
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
    KeAcquireSpinLockAtDpcLevel( &GpeTableLock );

    //
    // First things first, we need to look at the \_GPE branch of the
    // tree to see which control methods, exist, if any
    //
    status = AMLIGetNameSpaceObject("\\_GPE", NULL, &gpeObject, 0);
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "ACPIGpeBuildEventMasks - Could not find \\_GPE object %x\n",
            status
            ) );
        goto ACPIGpeBuildEventMasksExit;

    }

    //
    // Get the first child of the GPE root --- we will need to look
    // at all the methods under the object
    //
    gpeMethod = NSGETFIRSTCHILD(gpeObject);

    //
    // Use a for loop instead of a while loop to keep down the
    // number of nested statements
    //
    for (;gpeMethod; gpeMethod = NSGETNEXTSIBLING(gpeMethod) ) {

        //
        // Make sure that we are dealing with a method
        //
        if (NSGETOBJTYPE(gpeMethod) != OBJTYPE_METHOD) {

            continue;

        }

        //
        // The name of the object contains the index that we want
        // to associated with the object. We need to convert the string
        // representation into a numerical representation
        //
        // The encoding is as follows:
        //     Object Name = _LXY [for example]
        //     Object->dwNameSeg = yxL_
        //     gpeIndex = (nameSeg >> 8) & 0xFF00 [the x]
        //     gpeIndex += (nameSeg >> 24) & 0xFF [the y]
        //
        nameSeg = gpeMethod->dwNameSeg;
        gpeIndex = ( (nameSeg & 0x00FF0000) >> 8);
        gpeIndex |= ( (nameSeg & 0xFF000000) >> 24);
        nameSeg = ( (nameSeg & 0x0000FF00) >> 8);

        convertedToNumber = ACPIInternalConvertToNumber(
            (UCHAR) ( (gpeIndex & 0x00FF) ),
            (UCHAR) ( (gpeIndex & 0xFF00) >> 8),
            &gpeIndex
            );
        if (!convertedToNumber) {

            continue;

        }

        //
        // Set the proper bits to remember this GPE
        // Note: we pass convertedToNumber as the argument
        // since we don't particularly care what it returns
        //
        if ( (UCHAR) nameSeg == 'L') {

            //
            // Install the event as level triggered
            //
            ACPIGpeInstallRemoveIndex(
                gpeIndex,
                ACPI_GPE_LEVEL_INSTALL,
                ACPI_GPE_CONTROL_METHOD,
                &convertedToNumber
                );

        } else if ( (UCHAR) nameSeg == 'E') {

            //
            // Install the Edge triggered GPE
            //
            ACPIGpeInstallRemoveIndex(
                gpeIndex,
                ACPI_GPE_EDGE_INSTALL,
                ACPI_GPE_CONTROL_METHOD,
                &convertedToNumber
                );

        }

    } // for (...)

ACPIGpeBuildEventMasksExit:

    //
    // We also need to look at all the vector objects and re-enable those
    //
    ACPIVectorBuildVectorMasks();

    //
    // At this point, we should re-enable the registers that should be
    // enabled
    //
    ACPIGpeEnableDisableEvents( TRUE );

    //
    // Done
    //
    KeReleaseSpinLockFromDpcLevel( &GpeTableLock );
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
}

VOID
ACPIGpeBuildWakeMasks(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This recursive routine walks the entire device extension space and
    tries to find device extension whose _PRW are special

    This routine is called with device tree and gpe table lock spinlocks
    owned

Argument:

    DeviceExtension - The device whose children we need to examine

Return Value:

    None

--*/
{
    EXTENSIONLIST_ENUMDATA  eled;
    PDEVICE_EXTENSION       childExtension;
    ULONG                   gpeRegister;
    ULONG                   gpeMask;

    //
    // Setup the data structures that we will use to walk the device
    // extension tree
    //
    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->ChildDeviceList),
        NULL,
        SiblingDeviceList,
        WALKSCHEME_NO_PROTECTION
        );

    //
    // Look at all children of the current device extension
    //
    for (childExtension = ACPIExtListStartEnum( &eled );
         ACPIExtListTestElement( &eled, TRUE);
         childExtension = ACPIExtListEnumNext( &eled) ) {

        //
        // Recurse first
        //
        ACPIGpeBuildWakeMasks( childExtension );

        //
        // Is there a _PRW on this extension?
        //
        if (!(childExtension->Flags & DEV_CAP_WAKE) ) {

            continue;

        }

        //
        // Remember which register and mask are used by this
        // gpe bit
        //
        gpeRegister = ACPIGpeIndexToGpeRegister(
            childExtension->PowerInfo.WakeBit
            );
        gpeMask     = 1 << ( (UCHAR) childExtension->PowerInfo.WakeBit % 8);

        //
        // Does this vector have a GPE?
        //
        if ( (GpeEnable[gpeRegister] & gpeMask) ) {

            //
            // If we got here, and we aren't marked as DEV_CAP_NO_DISABLE_WAKE,
            // then we should turn off the GPE since this is a Wake event.
            // The easiest way to do this is to make sure that GpeWakeHandler
            // is masked with the appropriate bit
            //
            if (!(childExtension->Flags & DEV_CAP_NO_DISABLE_WAKE) ) {

                //
                // It has a GPE mask, so remember that there is a wake handler
                // for it. This should prevent us from arming the GPE without
                // a request for it.
                //
                if (!(GpeSpecialHandler[gpeRegister] & gpeMask) ) {

                    GpeWakeHandler[gpeRegister] |= gpeMask;

                }

            } else {

                //
                // If we got here, then we should remember that we can
                // never consider this pin as *just* a wake handler
                //
                GpeSpecialHandler[gpeRegister] |= gpeMask;

                //
                // Make sure that the pin isn't set as a wake handler
                //
                GpeWakeHandler[gpeRegister] &= ~gpeMask;


            }

        }

    } // for ( ... )

}

VOID
ACPIGpeClearEventMasks(
    )
/*++

Routine Description:

    This routine is called when the system wants to make sure that no
    General Purpose Events are enabled.

    This is typically done at:
        -System Init Time
        -Just before we load a namespace table
        -Just before we unload a namespace table

Arguments:

    None

Return Value:

    None

--*/
{
    KIRQL   oldIrql;

    //
    // Need to hold the previous IRQL before we can touch these
    // registers
    //
    KeAcquireSpinLock( &GpeTableLock, &oldIrql );

    //
    // Disable all of the events
    //
    ACPIGpeEnableDisableEvents( FALSE );

    //
    // Clear all the events
    //
    ACPIGpeClearRegisters();

    //
    // Zero out all of these fields, since we will recalc them later
    //
    RtlZeroMemory( GpeCurEnable,      AcpiInformation->GpeSize );
    RtlZeroMemory( GpeEnable,         AcpiInformation->GpeSize );
    RtlZeroMemory( GpeWakeEnable,     AcpiInformation->GpeSize );
    RtlZeroMemory( GpeWakeHandler,    AcpiInformation->GpeSize );
    RtlZeroMemory( GpeSpecialHandler, AcpiInformation->GpeSize );
    RtlZeroMemory( GpeRunMethod,      AcpiInformation->GpeSize );
    RtlZeroMemory( GpePending,        AcpiInformation->GpeSize );
    RtlZeroMemory( GpeComplete,       AcpiInformation->GpeSize );
    RtlZeroMemory( GpeIsLevel,        AcpiInformation->GpeSize );
    RtlZeroMemory( GpeHandlerType,    AcpiInformation->GpeSize );

    //
    // Done with the spinlock
    //
    KeReleaseSpinLock( &GpeTableLock, oldIrql );
}

VOID
ACPIGpeClearRegisters(
    VOID
    )
/*++

Routine Description:

    Reset the contents of the GP Registers

Arguments:

    None

Return Value:

    None

--*/
{
    UCHAR   scratch;
    ULONG   i;

    //
    // Clear all GPE status registers
    //
    for (i = 0; i < AcpiInformation->GpeSize; i++) {

        //
        // Read the register and mask off uninteresting GPE levels
        //
        scratch = ACPIReadGpeStatusRegister (i);
        scratch &= GpeEnable[i] | GpeWakeEnable[i];

        //
        // Write back out to clear the status bits
        //
        ACPIWriteGpeStatusRegister (i, scratch);

    }
}

VOID
ACPIGpeEnableDisableEvents (
    BOOLEAN Enable
    )
/*++

Routine Description:

    Not Exported

    Enable or disables GP events

Arguments:

    Enable - TRUE if we want to enable GP events

Return Value

    None

--*/
{
    UCHAR           Mask;
    ULONG           i;

    //
    // Transfer the current enable masks to their corresponding GPE registers
    //
    Mask = Enable ? (UCHAR) -1 : 0;
    for (i = 0; i < AcpiInformation->GpeSize; i++) {

        ACPIWriteGpeEnableRegister( i, (UCHAR) (GpeCurEnable[i] & Mask) );

    }

}

VOID
ACPIGpeHalEnableDisableEvents(
    BOOLEAN Enable
    )
/*++

Routine Description:

    Called from the HAL only.

    Enables or disables GP events

    Will snapshot the appropriate registers

Arguments:

    Enable - TRUE if we want to enable GP events

Return Value:

    None

--*/
{
    ULONG   i;

    if (Enable) {

        //
        // We have presumably woken up, so remember the PM1 Status register
        // and the GPE Status Register
        //
        for (i = 0; i < AcpiInformation->GpeSize; i++) {

            GpeSavedWakeStatus[i] = ACPIReadGpeStatusRegister(i);

        }
        AcpiInformation->pm1_wake_status = READ_PM1_STATUS();

    } else {

        //
        // We are going to standby without enabling any events. Make
        // sure to clear all the masks
        //
        AcpiInformation->pm1_wake_mask = 0;
        RtlZeroMemory( GpeSavedWakeMask, AcpiInformation->GpeSize );

    }

    //
    // Make sure to still enable/disable the registers
    //
    ACPIGpeEnableDisableEvents( Enable );
}

VOID
ACPIGpeEnableWakeEvents(
    VOID
    )
/*++

Routine Description:

    This routine is called with interrupts disabled for the purpose of enabling
    those vectors that are required for wake support just before putting the
    system to sleep

    N.B. interrutps are disabled

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG   i;

    for (i = 0; i < AcpiInformation->GpeSize; i++) {

        ACPIWriteGpeEnableRegister (i, GpeWakeEnable[i]);
        GpeSavedWakeMask[i] = GpeWakeEnable[i];

    }
    AcpiInformation->pm1_wake_mask = READ_PM1_ENABLE();
}

ULONG
ACPIGpeIndexToByteIndex (
    ULONG           Index
    )
/*++

Routine Description:

    Translate a GpeIndex (event number) to a logical byte index (0 to GPE1 end, no hole).
    Handles the case where the GPE1 block event numbers are not immediately after the
    GPE0 event numbers (as specified by the GP1_Base_Index).

Arguments:

    Index   - The Gpe index to be translated (0-255);

Return Value:

    The logical byte index.

--*/
{
    if (Index < AcpiInformation->GP1_Base_Index) {

        //
        // GP0 case is very simple
        //
        return (Index);

    } else {

        //
        // GP1 case must take into account:
        //   1) The base index of the GPE1 block
        //   2) The number of (logical) GPE0 registers preceeding the GPE1 registers
        //
        return ((Index - AcpiInformation->GP1_Base_Index) +
                    AcpiInformation->Gpe0Size);

    }
}

ULONG
ACPIGpeIndexToGpeRegister (
    ULONG           Index
    )
/*++

Routine Description:

    Translate a GpeIndex (event number) to the logical Gpe register which contains it.
    Handles the case where the GPE1 block event numbers are not immediately after the
    GPE0 event numbers (as specified by the GP1_Base_Index).

Arguments:

    Index   - The Gpe index to be translated (0-255);

Return Value:

    The logical Gpe register which contains the index.

--*/
{
    if (Index < AcpiInformation->GP1_Base_Index) {

        //
        // GP0 case is very simple
        //
        return (Index / 8);

    } else {

        //
        // GP1 case must take into account:
        //   1) The base index of the GPE1 block
        //   2) The number of (logical) GPE0 registers preceeding the GPE1 registers
        //
        return (((Index - AcpiInformation->GP1_Base_Index) / 8) +
                    AcpiInformation->Gpe0Size);

    }
}

BOOLEAN
ACPIGpeInstallRemoveIndex (
    ULONG       GpeIndex,
    ULONG       Action,         // Edge = 0, Level = 1, Remove = 2
    ULONG       Type,
    PBOOLEAN    HasControlMethod
    )
/*++

Routine Description:

    Installs or removes GPEs from the global tables.
    NOTE: Should be called with the global GpeVectorTable locked, and GPEs disabled

Arguments:

    GPEIndex    - The GPE number to install or remove
    Action      - Action to be performed:
                    0 - Install this GPE as an edge-sensitive interrupt
                    1 - Install this GPE as a level-sensitive interrupt
                    2 - Remove this GPE
    Type        - Type of handler for this GPE:
                    0 - OS handler
                    1 - Control Method

Return Value:

    None

--*/
{
    ULONG               bitOffset;
    ULONG               i;
    ULONG               bit;

    //
    // Validate the GPE index (GPE number)
    //
    if (AcpiInformation->GP0_LEN == 0) {

        PACPI_GPE_ERROR_CONTEXT errContext;

        errContext = ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(ACPI_GPE_ERROR_CONTEXT),
            ACPI_MISC_POOLTAG
            );
        if (errContext) {

            errContext->GpeIndex = GpeIndex;
            ExInitializeWorkItem(
                &(errContext->Item),
                ACPIGpeInstallRemoveIndexErrorWorker,
                (PVOID) errContext
                );
            ExQueueWorkItem( &(errContext->Item), DelayedWorkQueue );

        }

        return FALSE;

    }
    if (!(ACPIGpeValidIndex (GpeIndex))) {

        return FALSE;

    }

    bitOffset = GpeIndex % 8;
    bit = (1 << bitOffset);
    i = ACPIGpeIndexToGpeRegister (GpeIndex);

    ASSERT( (i < (ULONG) AcpiInformation->GpeSize) );
    if (i >= (ULONG) AcpiInformation->GpeSize) {

        return FALSE;

    }

    //
    // Handler removal
    //
    if (Action == ACPI_GPE_REMOVE) {

        //
        // Fall back to using control method if there is one.
        // Otherwise, disable the event.
        //
        if (*HasControlMethod) {

            GpeEnable [i]      |= bit;
            GpeCurEnable [i]   |= bit;
            GpeHandlerType [i] |= bit;

        } else {

            GpeEnable [i]      &= ~bit;
            GpeCurEnable [i]   &= ~bit;
            GpeHandlerType [i] &= ~bit;
            ASSERT (!(GpeWakeEnable[i] & bit));

        }

        ACPIPrint ( (
            ACPI_PRINT_DPC,
            "ACPIGpeInstallRemoveIndex: Removing GPE #%d: Byte 0x%x bit %u\n",
            GpeIndex, i, bitOffset
            ) );
        return TRUE;

    }
    //
    // Handler installation
    //
    if ( (GpeEnable [i] & bit) ) {

        if ( !(GpeHandlerType[i] & bit) ) {

            //
            // a handler is already installed
            //
            return FALSE;

        }

        //
        // there is a control method (to be restored if handler removed)
        //
        *HasControlMethod = TRUE;

    } else {

        *HasControlMethod = FALSE;

    }

    //
    // Install this event
    //
    GpeEnable[i]    |= bit;
    GpeCurEnable[i] |= bit;
    if (Action == ACPI_GPE_LEVEL_INSTALL) {

        //
        // Level event
        //
        GpeIsLevel[i] |= bit;

    } else {

        //
        // Edge event
        //
        GpeIsLevel[i] &= ~bit;

    }

    if (Type == ACPI_GPE_CONTROL_METHOD) {

        GpeHandlerType [i] |= bit;

    } else {

        GpeHandlerType [i] &= ~bit;

    }

    ACPIPrint ( (
        ACPI_PRINT_DPC,
        "ACPIGpeInstallRemoveIndex: Setting GPE #%d: Byte 0x%x bit %u\n",
        GpeIndex, i, bitOffset
        ) );
    return TRUE;
}

VOID
ACPIGpeInstallRemoveIndexErrorWorker(
    IN  PVOID   Context
    )
{
    PACPI_GPE_ERROR_CONTEXT errContext = (PACPI_GPE_ERROR_CONTEXT) Context;
    PWCHAR                  prtEntry[1];
    UNICODE_STRING          indexName;
    WCHAR                   index[20];

    RtlInitUnicodeString(&indexName, index);
    if (NT_SUCCESS(RtlIntegerToUnicodeString( errContext->GpeIndex,0,&indexName))) {

        prtEntry[0] = index;
        ACPIWriteEventLogEntry(
            ACPI_ERR_NO_GPE_BLOCK,
            &prtEntry,
            1,
            NULL,
            0
            );

    }
    ExFreePool( errContext );
}


BOOLEAN
ACPIGpeIsEvent(
    VOID
    )
/*++

Routine Description:

    Not Exported

    Detects where or not the a GP event caused an interrupt. This routine is
    called at DIRQL or ISR time

Arguments:

    None

Return Value:

    TRUE    - Yes, it was our interrupt
    FALSE   - No, it was not
--*/
{
    UCHAR       sts;
    ULONG       i;

    //
    // Check all GPE registers to see if any of the status bits are set.
    //
    for (i = 0; i < AcpiInformation->GpeSize; i++) {

        sts = ACPIReadGpeStatusRegister (i);

        if (sts & GpeCurEnable[i]) {

            return TRUE;

        }

    }

    //
    // No GPE bits were set
    //
    return (FALSE);
}

ULONG
ACPIGpeRegisterToGpeIndex(
    ULONG           Register,
    ULONG           BitPosition
    )
/*++

Routine Description:

    Translate a logical Gpe register and bit position into the associated Gpe index (event
    number).  Handles the case where the GPE1 block event numbers are not immediately after the
    GPE0 event numbers (as specified by the GP1_Base_Index).

Arguments:

    Register    - The logical Gpe register
    BitPosition - Position of the index within the register

Return Value:

    The Gpe index associated with the register/bit-position.

--*/
{
    if (Register < AcpiInformation->Gpe0Size) {

        //
        // GP0 case is simple
        //
        return (Register * 8) +
                BitPosition;

    } else {

        //
        // GP1 case must adjust for:
        //   1) The number of (logical) GPE0 registers preceeding the GPE1 registers
        //   2) The base index of the GPE1 block.
        //
        return ((Register - AcpiInformation->Gpe0Size) * 8) +
                AcpiInformation->GP1_Base_Index +
                BitPosition;
    }
}

VOID
ACPIGpeUpdateCurrentEnable(
    IN  ULONG   GpeRegister,
    IN  UCHAR   Completed
    )
/*++

Routine Description:

    This routine is called to re-arm the GpeCurEnable data structure
    based on the contents of the GPE's that we have just processed

Arguments:

    GpeRegister - Which index into the register we handled
    Completed   - Bitmask of the handled GPEs

Return Value:

    None
--*/
{
    //
    // This vector is no longer pending
    //
    GpePending[GpeRegister] &= ~Completed;

    //
    // First, remove any events that aren't in the current list of
    // enables, either wake or run-time
    //
    Completed &= (GpeEnable[GpeRegister] | GpeWakeEnable[GpeRegister]);

    //
    // Next, remove any events for which there is a wake handler,
    // but is not in the list of wake enables
    //
    Completed &= ~(GpeWakeHandler[GpeRegister] & ~GpeWakeEnable[GpeRegister]);

    //
    // Okay, now the cmp value should be exactly the list of GPEs to
    // re-enable
    //
    GpeCurEnable[GpeRegister] |= Completed;
}

BOOLEAN
ACPIGpeValidIndex (
    ULONG           Index
    )
/*++

Routine Description:

    Verifies that a GPE index is valid on this machine.

    Note:  There can be a hole (in the GPE index values) between the GPE0 and the GPE1 blocks.
    This hole is defined by the size of the GPE0 block (which always starts at zero), and
    GP1_Base_Index (whose value is obtained from the FACP table).

Arguments:

    Index   - The Gpe index to be verified (0-255);

Return Value:

    TRUE if a valid index, FALSE otherwise.

--*/
{
    if (Index < AcpiInformation->GP1_Base_Index) {

        //
        // GP0 case: Gpe index must fall within the range 0 to the end of GPE0
        //
        if (Index < (ULONG) (AcpiInformation->Gpe0Size * 8)) {

            return TRUE;

        } else {

            return FALSE;
        }

    } else {

        //
        // GP1 case: Gpe index must fall within the range GP1_Base_Index to the end of GPE1
        //
        if (Index < (ULONG) (AcpiInformation->GP1_Base_Index + (AcpiInformation->Gpe1Size * 8))) {

            return TRUE;

        } else {

            return FALSE;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\filter.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    filter.h

Abstract:

    This module contains the filter dispatcher for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _FILTER_H_
#define _FILTER_H_

    NTSTATUS
    ACPIFilterIrpDeviceUsageNotification(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpDeviceUsageNotificationCompletion(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp,
        IN  PVOID           Context
        );

    NTSTATUS
    ACPIFilterIrpEject(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID
    ACPIFilterFastIoDetachCallback(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PDEVICE_OBJECT  LowerDeviceObject
        );

    NTSTATUS
    ACPIFilterIrpQueryCapabilities(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpQueryDeviceRelations(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpQueryId(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpQueryInterface(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpQueryPnpDeviceState(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpQueryPower(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIFilterIrpRemoveDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpSetLock(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpSetPower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpStartDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID
    ACPIFilterIrpStartDeviceCompletion(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PVOID               Context,
        IN  NTSTATUS            Status
        );

    VOID
    ACPIFilterIrpStartDeviceWorker(
        IN  PVOID   Context
        );

    NTSTATUS
    ACPIFilterIrpStopDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpStopDeviceCompletion(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp,
        IN  PVOID           Context
        );

    NTSTATUS
    ACPIFilterIrpSurpriseRemoval(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\get.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    get.h

Abstract:

    This contains some some high-level routines to access data from
    the interpreter and do some processing upon the result. The result
    requires some manipulation to be useful to the OS. An example would
    be reading the _HID and turning that into a DeviceID

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _GET_H_
#define _GET_H_

    #define ISDIGIT(c)  (((c) >= '0') && ((c) <= '9'))


    typedef struct _ACPI_GET_REQUEST {

        //
        // See below for what the bits within the flags mean. They are to
        // be exclusively used by the completion routine to determine what
        // the original request intended
        //
        union {
            ULONG               Flags;
            struct {
                ULONG           TypePackage:1;
                ULONG           TypeInteger:1;
                ULONG           TypeString:1;
                ULONG           TypeBuffer:1;
                ULONG           ConvertToWidestring:1;
                ULONG           ConvertToDeviceId:1;
                ULONG           ConvertToHardwareId:1;
                ULONG           ConvertToInstanceId:1;
                ULONG           ConvertToCompatibleId:1;
                ULONG           ConvertToPnpId:1;
                ULONG           ConvertToAddress:1;
                ULONG           ConvertToDevicePresense:1;
                ULONG           ConvertIgnoreOverride:1;
                ULONG           ConvertToSerialId:1;
                ULONG           ConvertValidateInteger:1;
                ULONG           Reserved1:1;
                ULONG           RequestBuffer:1;
                ULONG           RequestData:1;
                ULONG           RequestInteger:1;
                ULONG           RequestString:1;
                ULONG           RequestNothing:1;
                ULONG           Reserved2:3;
                ULONG           EvalSimpleInteger:1;
                ULONG           EvalSimpleString:1;
                ULONG           EvalSimpleBuff:1;
                ULONG           PropNsObjInterface:1;
                ULONG           PropAllocateNonPaged:1;
                ULONG           PropSkipCallback:1;
                ULONG           PropAsynchronous:1;
                ULONG           PropNoErrors:1;
            } UFlags;
        };

        //
        // This is the name of the control method to execute
        //
        ULONG               ObjectID;

        //
        // This is the list entry that keeps all of these requests
        //
        LIST_ENTRY          ListEntry;

        //
        // This is the device extension of the method that owns the method
        //
        PDEVICE_EXTENSION   DeviceExtension;

        //
        // Likewise, we should remember what the corresponding acpi nsobj
        // for this request is
        //
        PNSOBJ              AcpiObject;

        //
        // This is the callback routine to execute when the request has been
        // completed. This is specified by the person who created the request
        //
        PFNACB              CallBackRoutine;

        //
        // This is the context to the callback
        //
        PVOID               CallBackContext;

        //
        // This is where the user wants his data to be stored
        //
        PVOID               *Buffer;

        //
        // This the size of the data
        //
        ULONG               *BufferSize;

        //
        // This is where the result of the operation is stored
        //
        NTSTATUS            Status;

        //
        // This is the structure used to store the result from the
        // interpreter
        //
        OBJDATA             ResultData;

    } ACPI_GET_REQUEST, *PACPI_GET_REQUEST;

    //
    //  This is the list entry where we queue up the requests
    //
    LIST_ENTRY  AcpiGetListEntry;

    //
    // This is the spin lock that we use to protect the List
    //
    KSPIN_LOCK  AcpiGetLock;

    //
    // The various flag defines
    //
    #define GET_TYPE_PACKAGE                0x00000001
    #define GET_TYPE_INTEGER                0x00000002
    #define GET_TYPE_STRING                 0x00000004
    #define GET_TYPE_BUFFER                 0x00000008
    #define GET_CONVERT_TO_WIDESTRING       0x00000010
    #define GET_CONVERT_TO_DEVICEID         0x00000020
    #define GET_CONVERT_TO_HARDWAREID       0x00000040
    #define GET_CONVERT_TO_INSTANCEID       0x00000080
    #define GET_CONVERT_TO_COMPATIBLEID     0x00000100
    #define GET_CONVERT_TO_PNPID            0x00000200
    #define GET_CONVERT_TO_ADDRESS          0x00000400
    #define GET_CONVERT_TO_DEVICE_PRESENCE  0x00000800
    #define GET_CONVERT_IGNORE_OVERRIDES    0x00001000
    #define GET_CONVERT_TO_SERIAL_ID        0x00002000
    #define GET_CONVERT_VALIDATE_INTEGER    0x00004000
    #define GET_REQUEST_BUFFER              0x00010000
    #define GET_REQUEST_DATA                0x00020000
    #define GET_REQUEST_INTEGER             0x00040000
    #define GET_REQUEST_STRING              0x00080000
    #define GET_REQUEST_NOTHING             0x00100000
    #define GET_EVAL_SIMPLE_INTEGER         0x01000000
    #define GET_EVAL_SIMPLE_STRING          0x02000000
    #define GET_EVAL_SIMPLE_BUFFER          0x04000000
    #define GET_PROP_NSOBJ_INTERFACE        0x08000000
    #define GET_PROP_ALLOCATE_NON_PAGED     0x10000000
    #define GET_PROP_SKIP_CALLBACK          0x20000000
    #define GET_PROP_ASYNCHRONOUS           0x40000000
    #define GET_PROP_NO_ERRORS              0x80000000

    //
    // This is the mask for the requests
    //
    #define GET_REQUEST_MASK            (GET_REQUEST_BUFFER     |   \
                                         GET_REQUEST_DATA       |   \
                                         GET_REQUEST_INTEGER    |   \
                                         GET_REQUEST_STRING     |   \
                                         GET_REQUEST_NOTHING)

    //
    // This is the mask for the evals
    //
    #define GET_EVAL_MASK               (GET_EVAL_SIMPLE_INTEGER |  \
                                         GET_EVAL_SIMPLE_STRING  |  \
                                         GET_EVAL_SIMPLE_BUFFER)

    //
    // This macro is used to get an integer. It allows for the most flexible
    // arguments by the caller
    //
    #define ACPIGetAddress(             \
        DeviceExtension,                \
        Flags,                          \
        CallBack,                       \
        Context,                        \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGet(                        \
            DeviceExtension,            \
            PACKED_ADR,                 \
            (GET_REQUEST_INTEGER |      \
             GET_CONVERT_TO_ADDRESS |   \
             GET_TYPE_INTEGER |         \
             Flags),                    \
            NULL,                       \
            0,                          \
            CallBack,                   \
            Context,                    \
            (PVOID *) Buffer,           \
            (PULONG) BufferSize         \
            )

    //
    // This macro is used to get an integer asynchronously
    //
    #define ACPIGetAddressAsync(        \
        DeviceExtension,                \
        CallBack,                       \
        Context,                        \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGetAddress(                 \
            DeviceExtension,            \
            GET_PROP_ASYNCHRONOUS,      \
            CallBack,                   \
            Context,                    \
            Buffer,                     \
            BufferSize                  \
            )

    //
    // This macro is used to get an integer synchronously
    //
    #define ACPIGetAddressSync(         \
        DeviceExtension,                \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGetAddress(                 \
            DeviceExtension,            \
            GET_PROP_SKIP_CALLBACK,     \
            NULL,                       \
            NULL,                       \
            Buffer,                     \
            BufferSize                  \
            )

    //
    // This macro is used to get an integer asynchronously, using only
    // an nsobj
    //
    #define ACPIGetNSAddressAsync(      \
        DeviceExtension,                \
        CallBack,                       \
        Context,                        \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGetAddress(                 \
            DeviceExtension,            \
            (GET_PROP_ASYNCHRONOUS |    \
             GET_PROP_NSOBJ_INTERFACE), \
            CallBack,                   \
            Context,                    \
            Buffer,                     \
            BufferSize                  \
            )

    //
    // This macro is used to get an integer synchronously, using only
    // an nsobj
    //
    #define ACPIGetNSAddressSync(       \
        DeviceExtension,                \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGetAddress(                 \
            DeviceExtension,            \
            (GET_PROP_SKIP_CALLBACK |   \
             GET_PROP_NSOBJ_INTERFACE), \
            NULL,                       \
            NULL,                       \
            Buffer,                     \
            BufferSize                  \
            )

    //
    // This macro is used to get a buffer. It allows for the use of the most
    // possible arguments by the caller
    //
    #define ACPIGetBuffer(          \
        DeviceExtension,            \
        ObjectID,                   \
        Flags,                      \
        CallBack,                   \
        Context,                    \
        Buffer,                     \
        BufferSize                  \
        )                           \
        ACPIGet(                    \
            DeviceExtension,        \
            ObjectID,               \
            (GET_REQUEST_BUFFER |   \
             GET_TYPE_BUFFER |      \
             Flags),                \
            NULL,                   \
            0,                      \
            CallBack,               \
            Context,                \
            Buffer,                 \
            (PULONG) BufferSize     \
            )

    //
    // This macro is used to get a buffer asynchronously
    //
    #define ACPIGetBufferAsync(             \
        DeviceExtension,                    \
        ObjectID,                           \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetBuffer(                      \
            DeviceExtension,                \
            ObjectID,                       \
            (GET_PROP_ASYNCHRONOUS |        \
            GET_PROP_ALLOCATE_NON_PAGED),   \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a buffer synchronously
    //
    #define ACPIGetBufferSync(      \
        DeviceExtension,            \
        ObjectID,                   \
        Buffer,                     \
        BufferSize                  \
        )                           \
        ACPIGetBuffer(              \
            DeviceExtension,        \
            ObjectID,               \
            GET_PROP_SKIP_CALLBACK, \
            NULL,                   \
            NULL,                   \
            Buffer,                 \
            BufferSize              \
            )

    //
    // This macro is used to get a buffer asynchronously only trhough an nsobject
    //
    #define ACPIGetNSBufferAsync(           \
        DeviceExtension,                    \
        ObjectID,                           \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetBuffer(                      \
            DeviceExtension,                \
            ObjectID,                       \
            (GET_PROP_ASYNCHRONOUS |        \
            GET_PROP_NSOBJ_INTERFACE |      \
            GET_PROP_ALLOCATE_NON_PAGED),   \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )
    //
    // This macro is used to get a buffer synchronously only through an nsobject
    //
    #define ACPIGetNSBufferSync(        \
        DeviceExtension,                \
        ObjectID,                       \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGetBuffer(                  \
            DeviceExtension,            \
            ObjectID,                   \
            (GET_PROP_SKIP_CALLBACK |   \
             GET_PROP_NSOBJ_INTERFACE), \
            NULL,                       \
            NULL,                       \
            Buffer,                     \
            BufferSize                  \
            )

    //
    // This macro is used to get a compatible id. It allows for the use of the
    // most possible arguments by the caller
    //
    #define ACPIGetCompatibleID(            \
        DeviceExtension,                    \
        Flags,                              \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            PACKED_CID,                     \
            (GET_CONVERT_TO_COMPATIBLEID |  \
             GET_REQUEST_STRING |           \
             GET_TYPE_INTEGER |             \
             GET_TYPE_STRING |              \
             GET_TYPE_PACKAGE |             \
             Flags ),                       \
            NULL,                           \
            0,                              \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            (PULONG) BufferSize             \
            )

    //
    // This macro is used to get a compatible id asynchronously
    //
    #define ACPIGetCompatibleIDAsync(       \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetCompatibleID(                \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED),  \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a compatible id, in wide string format,
    // asynchronously
    //
    #define ACPIGetCompatibleIDAsyncWide(   \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetCompatibleID(                \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED |  \
             GET_CONVERT_TO_WIDESTRING),    \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a compatible id asynchronously
    //
    #define ACPIGetNSCompatibleIDAsync(     \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetCompatibleID(                \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_NSOBJ_INTERFACE |     \
             GET_PROP_ALLOCATE_NON_PAGED),  \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a compatible id, in wide string format,
    // asynchronously
    //
    #define ACPIGetNSCompatibleIDAsyncWide(   \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetCompatibleID(                \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_NSOBJ_INTERFACE |     \
             GET_PROP_ALLOCATE_NON_PAGED |  \
             GET_CONVERT_TO_WIDESTRING),    \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a compatible ID synchronously
    //
    #define ACPIGetCompatibleIDSync(        \
       DeviceExtension,                     \
       Buffer,                              \
       BufferSize                           \
       )                                    \
       ACPIGetCompatibleID(                 \
            DeviceExtension,                \
            GET_PROP_SKIP_CALLBACK,         \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a compatible ID, in wide string format,
    // asynchronously
    //
    #define ACPIGetCompatibleIDSyncWide(    \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetCompatibleID(                \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_CONVERT_TO_WIDESTRING),    \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a compatible ID synchronously
    //
    #define ACPIGetNSCompatibleIDSync(      \
       DeviceExtension,                     \
       Buffer,                              \
       BufferSize                           \
       )                                    \
       ACPIGetCompatibleID(                 \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_PROP_NSOBJ_INTERFACE),     \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a compatible ID, in wide string format,
    // asynchronously
    //
    #define ACPIGetNSCompatibleIDSyncWide(  \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetCompatibleID(                \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_PROP_NSOBJ_INTERFACE |     \
             GET_CONVERT_TO_WIDESTRING),    \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a data element. It is allows for the use of
    // the most possible arguments by the caller
    //
    #define ACPIGetData(            \
        DeviceExtension,            \
        ObjectID,                   \
        Flags,                      \
        CallBack,                   \
        Context,                    \
        Buffer)                     \
        ACPIGet(                    \
            DeviceExtension,        \
            ObjectID,               \
            (GET_REQUEST_DATA |     \
             Flags),                \
            NULL,                   \
            0,                      \
            CallBack,               \
            Context,                \
            (PVOID *) Buffer,       \
            (PULONG) NULL           \
            )
    //
    // This macro is used to get a data element asynchronously
    //
    #define ACPIGetDataAsync(       \
        DeviceExtension,            \
        ObjectID,                   \
        CallBack,                   \
        Context,                    \
        Buffer                      \
        )                           \
        ACPIGetData(                \
            DeviceExtension,        \
            ObjectID,               \
            GET_PROP_ASYNCHRONOUS,  \
            CallBack,               \
            Context,                \
            Buffer                  \
            )
    //
    // This macro is used to get a data element synchronously
    //
    #define ACPIGetDataSync(        \
        DeviceExtension,            \
        ObjectID,                   \
        Buffer                      \
        )                           \
        ACPIGetData(                \
            DeviceExtension,        \
            ObjectID,               \
            GET_PROP_SKIP_CALLBACK, \
            NULL,                   \
            NULL,                   \
            Buffer                  \
            )

    //
    // This macro is used to get a device id. It allows for the use of the most
    // possible arguments by the caller
    //
    #define ACPIGetDeviceID(                \
        DeviceExtension,                    \
        Flags,                              \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            PACKED_HID,                     \
            (GET_CONVERT_TO_DEVICEID |      \
             GET_REQUEST_STRING |           \
             GET_TYPE_INTEGER |             \
             GET_TYPE_STRING |              \
             Flags ),                       \
            NULL,                           \
            0,                              \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            (PULONG) BufferSize             \
            )

    //
    // This macro is used to get the device ID asynchronously
    //
    #define ACPIGetDeviceIDAsync(           \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetDeviceID(                    \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED),  \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This is used to get the device ID as a wide string, asynchronously
    //
    #define ACPIGetDeviceIDAsyncWide(       \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetDeviceID(                    \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED |  \
             GET_CONVERT_TO_WIDESTRING),    \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get the device ID synchronously
    //
    #define ACPIGetDeviceIDSync(            \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetDeviceID(                    \
            DeviceExtension,                \
            GET_PROP_SKIP_CALLBACK,         \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This is used to get the device ID as a wide string, synchronously
    //
    #define ACPIGetDeviceIDSyncWide(        \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetDeviceID(                    \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_CONVERT_TO_WIDESTRING),    \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get the device presence
    //
    #define ACPIGetDevicePresence(              \
        DeviceExtension,                        \
        Flags,                                  \
        CallBack,                               \
        Context,                                \
        Buffer,                                 \
        BufferSize                              \
        )                                       \
        ACPIGet(                                \
            DeviceExtension,                    \
            PACKED_STA,                         \
            (GET_REQUEST_INTEGER |              \
             GET_TYPE_INTEGER |                 \
             GET_CONVERT_TO_DEVICE_PRESENCE |   \
             Flags ),                           \
            NULL,                               \
            0,                                  \
            CallBack,                           \
            Context,                            \
            (PVOID *) Buffer,                   \
            (PULONG) BufferSize                 \
            )

    //
    // This macro is used to get the device status asynchronously
    //
    #define ACPIGetDevicePresenceAsync(         \
        DeviceExtension,                        \
        CallBack,                               \
        Context,                                \
        Buffer,                                 \
        BufferSize                              \
        )                                       \
        ACPIGetDevicePresence(                  \
            DeviceExtension,                    \
            GET_PROP_ASYNCHRONOUS,              \
            CallBack,                           \
            Context,                            \
            Buffer,                             \
            BufferSize                          \
            )

    //
    // This macro is used to get the device status synchronously
    //
    #define ACPIGetDevicePresenceSync(          \
        DeviceExtension,                        \
        Buffer,                                 \
        BufferSize                              \
        )                                       \
        ACPIGetDevicePresence(                  \
            DeviceExtension,                    \
            GET_PROP_SKIP_CALLBACK,             \
            NULL,                               \
            NULL,                               \
            Buffer,                             \
            BufferSize                          \
            )

    //
    // This macro is used to run a _STA. It differs from ACPIGetDevicePresence
    // in that overrides are ignored.
    //
    #define ACPIGetDeviceHardwarePresence(      \
        DeviceExtension,                        \
        Flags,                                  \
        CallBack,                               \
        Context,                                \
        Buffer,                                 \
        BufferSize                              \
        )                                       \
        ACPIGet(                                \
            DeviceExtension,                    \
            PACKED_STA,                         \
            (GET_REQUEST_INTEGER |              \
             GET_TYPE_INTEGER |                 \
             GET_CONVERT_TO_DEVICE_PRESENCE |   \
             GET_CONVERT_IGNORE_OVERRIDES |     \
             Flags ),                           \
            NULL,                               \
            0,                                  \
            CallBack,                           \
            Context,                            \
            (PVOID *) Buffer,                   \
            (PULONG) BufferSize                 \
            )

    //
    // This macro is used to run a _STA asynchronously. It differs from
    // ACPIGetDevicePresenceAsync in that overrides is ignored.
    //
    #define ACPIGetDeviceHardwarePresenceAsync( \
        DeviceExtension,                        \
        CallBack,                               \
        Context,                                \
        Buffer,                                 \
        BufferSize                              \
        )                                       \
        ACPIGetDeviceHardwarePresence(          \
            DeviceExtension,                    \
            GET_PROP_ASYNCHRONOUS,              \
            CallBack,                           \
            Context,                            \
            Buffer,                             \
            BufferSize                          \
            )

    //
    // This macro is used to run a _STA synchronously. It differs from
    // ACPIGetDevicePresenceSync in that overrides is ignored.
    //
    #define ACPIGetDeviceHardwarePresenceSync(  \
        DeviceExtension,                        \
        Buffer,                                 \
        BufferSize                              \
        )                                       \
        ACPIGetDeviceHardwarePresence(          \
            DeviceExtension,                    \
            GET_PROP_SKIP_CALLBACK,             \
            NULL,                               \
            NULL,                               \
            Buffer,                             \
            BufferSize                          \
            )

    //
    //
    // This macro is used to get a string ID, which is stored as either
    // a string or a packed integer
    //
    #define ACPIGetHardwareID(              \
        DeviceExtension,                    \
        Flags,                              \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            PACKED_HID,                     \
            (GET_REQUEST_STRING |           \
             GET_CONVERT_TO_HARDWAREID |    \
             GET_TYPE_INTEGER |             \
             GET_TYPE_STRING |              \
             Flags ),                       \
            NULL,                           \
            0,                              \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            (PULONG) BufferSize             \
            )

    //
    // This macro is used to get an string ID asynchronously
    //
    #define ACPIGetHardwareIDAsync(         \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetHardwareID(                  \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED),  \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in wide format, async
    //
    #define ACPIGetHardwareIDAsyncWide(      \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetHardwareID(                  \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED |  \
             GET_CONVERT_TO_WIDESTRING ),   \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, synchronously
    //
    #define ACPIGetHardwareIDSync(          \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetHardwareID(                  \
            DeviceExtension,                \
            GET_PROP_SKIP_CALLBACK,         \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in the wide format, sync
    //
    #define ACPIGetHardwareIDSyncWide(      \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetHardwareID(                  \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_CONVERT_TO_WIDESTRING),    \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get the instance ID. It allows for the use of the
    // most flexible arguments by the caller
    //
    #define ACPIGetInstanceID(              \
        DeviceExtension,                    \
        Flags,                              \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            PACKED_UID,                     \
            (GET_REQUEST_STRING |           \
             GET_TYPE_INTEGER |             \
             GET_TYPE_STRING |              \
             GET_CONVERT_TO_INSTANCEID |    \
             Flags ),                       \
            NULL,                           \
            0,                              \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            (PULONG) BufferSize             \
            )

    //
    // This macro is used to get an instance ID asynchronously
    //
    #define ACPIGetInstanceIDAsync(         \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetInstanceID(                  \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED),  \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in wide format, async
    //
    #define ACPIGetInstanceIDAsyncWide(     \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetInstanceID(                  \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED |  \
             GET_CONVERT_TO_WIDESTRING ),   \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, synchronously
    //
    #define ACPIGetInstanceIDSync(          \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetInstanceID(                  \
            DeviceExtension,                \
            GET_PROP_SKIP_CALLBACK,         \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in the wide format, sync
    //
    #define ACPIGetInstanceIDSyncWide(      \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetInstanceID(                  \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_CONVERT_TO_WIDESTRING),    \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an integer. It allows for the most flexible
    // arguments by the caller
    //
    #define ACPIGetInteger(         \
        DeviceExtension,            \
        ObjectID,                   \
        Flags,                      \
        CallBack,                   \
        Context,                    \
        Buffer,                     \
        BufferSize                  \
        )                           \
        ACPIGet(                    \
            DeviceExtension,        \
            ObjectID,               \
            (GET_REQUEST_INTEGER |  \
             GET_TYPE_INTEGER |     \
             Flags),                \
            NULL,                   \
            0,                      \
            CallBack,               \
            Context,                \
            (PVOID *) Buffer,       \
            (PULONG) BufferSize     \
            )

    //
    // This macro is used to get an integer asynchronously
    //
    #define ACPIGetIntegerAsync(    \
        DeviceExtension,            \
        ObjectID,                   \
        CallBack,                   \
        Context,                    \
        Buffer,                     \
        BufferSize                  \
        )                           \
        ACPIGetInteger(             \
            DeviceExtension,        \
            ObjectID,               \
            GET_PROP_ASYNCHRONOUS,  \
            CallBack,               \
            Context,                \
            Buffer,                 \
            BufferSize              \
            )

    //
    // This macro is used to get an integer synchronously.
    //
    // If an invalid value is returned, 0 is substituted for the result.
    //
    #define ACPIGetIntegerSync(     \
        DeviceExtension,            \
        ObjectID,                   \
        Buffer,                     \
        BufferSize                  \
        )                           \
        ACPIGetInteger(             \
            DeviceExtension,        \
            ObjectID,               \
            GET_PROP_SKIP_CALLBACK, \
            NULL,                   \
            NULL,                   \
            Buffer,                 \
            BufferSize              \
            )

    //
    // This macro is used to get an integer synchronously.
    //
    // If an invalid value is returned, STATUS_ACPI_INVALID_DATA is returned.
    //
    #define ACPIGetIntegerSyncValidate(     \
        DeviceExtension,                    \
        ObjectID,                           \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetInteger(                     \
            DeviceExtension,                \
            ObjectID,                       \
            GET_PROP_SKIP_CALLBACK |        \
            GET_CONVERT_VALIDATE_INTEGER,   \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an integer asynchronously, using only
    // an NSOBJ
    //
    #define ACPIGetNSIntegerAsync(      \
        DeviceExtension,                \
        ObjectID,                       \
        CallBack,                       \
        Context,                        \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGetInteger(                 \
            DeviceExtension,            \
            ObjectID,                   \
            (GET_PROP_NSOBJ_INTERFACE | \
             GET_PROP_ASYNCHRONOUS),    \
            CallBack,                   \
            Context,                    \
            Buffer,                     \
            BufferSize                  \
            )

    //
    // This macro is used to get an integer synchronously, using only
    // an NSOBJ
    //
    #define ACPIGetNSIntegerSync(       \
        DeviceExtension,                \
        ObjectID,                       \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGetInteger(                 \
            DeviceExtension,            \
            ObjectID,                   \
            (GET_PROP_SKIP_CALLBACK |   \
             GET_PROP_NSOBJ_INTERFACE), \
            NULL,                       \
            NULL,                       \
            Buffer,                     \
            BufferSize                  \
            )

    //
    // This macro is used to get an integer. It allows for the most flexible
    // arguments by the caller
    //
    #define ACPIGetIntegerEvalInteger(      \
        DeviceExtension,                    \
        ObjectID,                           \
        Flags,                              \
        Integer,                            \
        CallBack,                           \
        Context,                            \
        Buffer                              \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            ObjectID,                       \
            (GET_REQUEST_INTEGER |          \
             GET_EVAL_SIMPLE_INTEGER |      \
             GET_TYPE_INTEGER |             \
             Flags),                        \
            (PVOID) Integer,                \
            sizeof(ULONG),                  \
            CallBack,                       \
            Context,                        \
            (PVOID *) Buffer,               \
            (PULONG) NULL                   \
            )

    //
    // This macro is used to get an integer asynchronously
    //
    #define ACPIGetIntegerEvalIntegerAsync( \
        DeviceExtension,                    \
        ObjectID,                           \
        Integer,                            \
        CallBack,                           \
        Context,                            \
        Buffer                              \
        )                                   \
        ACPIGetIntegerEvalInteger(          \
            DeviceExtension,                \
            ObjectID,                       \
            GET_PROP_ASYNCHRONOUS,          \
            Integer,                        \
            CallBack,                       \
            Context,                        \
            Buffer                          \
            )

    //
    // This macro is used to get an integer synchronously
    //
    #define ACPIGetIntegerEvalIntegerSync(  \
        DeviceExtension,                    \
        ObjectID,                           \
        Integer,                            \
        Buffer                              \
        )                                   \
        ACPIGetIntegerEvalInteger(          \
            DeviceExtension,                \
            ObjectID,                       \
            GET_PROP_SKIP_CALLBACK,         \
            Integer,                        \
            NULL,                           \
            NULL,                           \
            Buffer                          \
            )

    //
    // This macro is used to get an integer. It allows for the most flexible
    // arguments by the caller
    //
    #define ACPIGetNothingEvalInteger(      \
        DeviceExtension,                    \
        ObjectID,                           \
        Flags,                              \
        Integer,                            \
        CallBack,                           \
        Context                             \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            ObjectID,                       \
            (GET_REQUEST_NOTHING |          \
             GET_EVAL_SIMPLE_INTEGER |      \
             Flags),                        \
            UlongToPtr(Integer),            \
            sizeof(ULONG),                  \
            CallBack,                       \
            Context,                        \
            NULL,                           \
            (PULONG) NULL                   \
            )

    //
    // This macro is used to get an integer asynchronously
    //
    #define ACPIGetNothingEvalIntegerAsync( \
        DeviceExtension,                    \
        ObjectID,                           \
        Integer,                            \
        CallBack,                           \
        Context                             \
        )                                   \
        ACPIGetNothingEvalInteger(          \
            DeviceExtension,                \
            ObjectID,                       \
            GET_PROP_ASYNCHRONOUS,          \
            Integer,                        \
            CallBack,                       \
            Context                         \
            )

    //
    // This macro is used to get an integer synchronously
    //
    #define ACPIGetNothingEvalIntegerSync(  \
        DeviceExtension,                    \
        ObjectID,                           \
        Integer                             \
        )                                   \
        ACPIGetNothingEvalInteger(          \
            DeviceExtension,                \
            ObjectID,                       \
            GET_PROP_SKIP_CALLBACK,         \
            Integer,                        \
            NULL,                           \
            NULL                            \
            )

    //
    // This macro is used to get a string ID, which is stored as either
    // a string or a packed integer
    //
    #define ACPIGetPnpID(                   \
        DeviceExtension,                    \
        Flags,                              \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            PACKED_HID,                     \
            (GET_REQUEST_STRING |           \
             GET_CONVERT_TO_PNPID |         \
             GET_TYPE_INTEGER |             \
             GET_TYPE_STRING |              \
             Flags ),                       \
            NULL,                           \
            0,                              \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            (PULONG) BufferSize             \
            )

    //
    // This macro is used to get an string ID asynchronously
    //
    #define ACPIGetPnpIDAsync(              \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED),  \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in wide format, async
    //
    #define ACPIGetPnpIDAsyncWide(          \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED |  \
             GET_CONVERT_TO_WIDESTRING ),   \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an string ID asynchronously, using only an
    // nsobject.
    //
    #define ACPIGetNSPnpIDAsync(            \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_NSOBJ_INTERFACE |     \
             GET_PROP_ALLOCATE_NON_PAGED),  \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in wide format, async, using
    // only an nsobject.
    //
    #define ACPIGetNSPnpIDAsyncWide(        \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED |  \
             GET_PROP_NSOBJ_INTERFACE |     \
             GET_CONVERT_TO_WIDESTRING ),   \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, synchronously
    //
    #define ACPIGetPnpIDSync(               \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            GET_PROP_SKIP_CALLBACK,         \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in the wide format, sync
    //
    #define ACPIGetPnpIDSyncWide(           \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_CONVERT_TO_WIDESTRING),    \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, synchronously, using only
    // an nsobject
    //
    #define ACPIGetNSPnpIDSync(             \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_PROP_NSOBJ_INTERFACE),     \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in the wide format, sync,
    // using only an nsobject
    //
    #define ACPIGetNSPnpIDSyncWide(         \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_PROP_NSOBJ_INTERFACE |     \
             GET_CONVERT_TO_WIDESTRING),    \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    #define ACPIGetSerialIDWide(            \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            PACKED_UID,                     \
            (GET_REQUEST_STRING |           \
             GET_CONVERT_TO_SERIAL_ID |     \
             GET_CONVERT_TO_WIDESTRING |    \
             GET_TYPE_INTEGER |             \
             GET_TYPE_STRING),              \
            NULL,                           \
            0,                              \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    NTSTATUS
    ACPIGet(
        IN  PVOID   Target,
        IN  ULONG   ObjectID,
        IN  ULONG   Flags,
        IN  PVOID   SimpleArgument,
        IN  ULONG   SimpleArgumentSize,
        IN  PFNACB  CallBackRoutine OPTIONAL,
        IN  PVOID   CallBackContext OPTIONAL,
        OUT PVOID   *Buffer,
        OUT ULONG   *BufferSize     OPTIONAL
        );

    NTSTATUS
    ACPIGetConvertToAddress(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToCompatibleID(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToCompatibleIDWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToDeviceID(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToDeviceIDWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToDevicePresence(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToHardwareID(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToHardwareIDWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToInstanceID(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToInstanceIDWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToPnpID(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToPnpIDWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToSerialIDWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize OPTIONAL
        );

    NTSTATUS
    ACPIGetConvertToString(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToStringWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize OPTIONAL
        );

    NTSTATUS
    ACPIGetProcessorID(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetProcessorIDWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetProcessorStatus(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  ULONG               Flags,
        OUT PULONG              DeviceStatus
        );

    VOID
    EXPORT
    ACPIGetWorkerForBuffer(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  PVOID               Context
        );

    VOID
    EXPORT
    ACPIGetWorkerForData(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  PVOID               Context
        );

    VOID
    EXPORT
    ACPIGetWorkerForInteger(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  PVOID               Context
        );

    VOID
    EXPORT
    ACPIGetWorkerForNothing(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  PVOID               Context
        );

    VOID
    EXPORT
    ACPIGetWorkerForString(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  PVOID               Context
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\get.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    get.c

Abstract:

    This contains some some high-level routines to access data from
    the interpreter and do some processing upon the result. The result
    requires some manipulation to be useful to the OS. An example would
    be reading the _HID and turning that into a DeviceID

    Note: There are four basic data types that can be processed by this
    module.

        The Integer and Data ones assume that the caller is providing the
        storage required for the answer

        The Buffer and String ones assume that the function should allocate
        memory for the answer

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

NTSTATUS
ACPIGet(
    IN  PVOID   Target,
    IN  ULONG   ObjectID,
    IN  ULONG   Flags,
    IN  PVOID   SimpleArgument,
    IN  ULONG   SimpleArgumentSize,
    IN  PFNACB  CallBackRoutine OPTIONAL,
    IN  PVOID   CallBackContext OPTIONAL,
    OUT PVOID   *Buffer,
    OUT ULONG   *BufferSize     OPTIONAL
    )
/*++

Routine Description:

    Every Macro calls the above function. It is the only one that is
    actually exported outside of this file. The purpose of the function
    is to provide a wrapper that others can call.

    This version allows the user to specificy an input argument

Arguments:

    AcpiObject      - The parent object
    ObjectID        - The name of the control method to run
    Flags           - Some things that help us in evaluating the result
    SimpleArgument  - The argument to use
    CallBackRoutine - If this is an Async call, then call this when done
    CallBackContext - Context to pass when completed
    Buffer          - Where to write the answer
    Buffersize      - How large the buffer is

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             async               = FALSE;
    KIRQL               oldIrql;
    NTSTATUS            status;
    OBJDATA             argument;
    POBJDATA            argumentPtr         = NULL;
    PACPI_GET_REQUEST   request             = NULL;
    PDEVICE_EXTENSION   deviceExtension     = NULL;
    PFNACB              completionRoutine   = NULL;
    PNSOBJ              acpiObject;
    ULONG               argumentCount       = 0;

    if ( (Flags & GET_PROP_ASYNCHRONOUS) ) {

        async = TRUE;

    }

    if ( (Flags & GET_PROP_NSOBJ_INTERFACE) ) {

        acpiObject = (PNSOBJ) Target;

    } else {

        deviceExtension = (PDEVICE_EXTENSION) Target;
        acpiObject = deviceExtension->AcpiObject;

    }

    //
    // Determine the completion routine that we should use
    //
    switch( (Flags & GET_REQUEST_MASK) ) {
    case GET_REQUEST_BUFFER:
        completionRoutine = ACPIGetWorkerForBuffer;
        break;
    case GET_REQUEST_DATA:
        completionRoutine = ACPIGetWorkerForData;
        break;
    case GET_REQUEST_INTEGER:
        completionRoutine = ACPIGetWorkerForInteger;

        //
        // If this is a GET_CONVERT_TO_DEVICE_PRESENCE request, and the target
        // is a dock profile provider, we need to use a different AcpiObject
        //
        if ( (Flags & GET_CONVERT_TO_DEVICE_PRESENCE) &&
            !(Flags & GET_PROP_NSOBJ_INTERFACE) ) {

            if (deviceExtension->Flags & DEV_PROP_DOCK) {

                ASSERT( deviceExtension->Dock.CorrospondingAcpiDevice );
                acpiObject = deviceExtension->Dock.CorrospondingAcpiDevice->AcpiObject;

            }

        }
        break;
    case GET_REQUEST_STRING:
        completionRoutine = ACPIGetWorkerForString;
        break;
    case GET_REQUEST_NOTHING:
        completionRoutine = ACPIGetWorkerForNothing;
        break;
    default:
        return STATUS_INVALID_PARAMETER_3;

    }

    //
    // Lets try to build the input argument (if possible)
    //
    if ( (Flags & GET_EVAL_MASK) ) {

        ASSERT( SimpleArgumentSize != 0 );

        //
        // Initialize the input argument
        //
        RtlZeroMemory( &argument, sizeof(OBJDATA) );

        //
        // Handle the various different cases
        //
        if ( (Flags & GET_EVAL_SIMPLE_INTEGER) ) {

            argument.dwDataType = OBJTYPE_INTDATA;
            argument.uipDataValue = ( (ULONG_PTR) SimpleArgument );

        } else if ( (Flags & GET_EVAL_SIMPLE_STRING) ) {

            argument.dwDataType = OBJTYPE_STRDATA;
            argument.dwDataLen = SimpleArgumentSize;
            argument.pbDataBuff = ( (PUCHAR) SimpleArgument );

        } else if ( (Flags & GET_EVAL_SIMPLE_BUFFER) ) {

            argument.dwDataType = OBJTYPE_BUFFDATA;
            argument.dwDataLen = SimpleArgumentSize;
            argument.pbDataBuff = ( (PUCHAR) SimpleArgument );

        } else {

            ACPIInternalError( ACPI_GET );

        }

        //
        // Remember that we have an argument
        //
        argumentCount = 1;
        argumentPtr = &argument;

    }

    //
    // We need to allocate the request to hold the context information
    // We have no choice but to allocate this from NonPagedPool --- the
    // interpreter will be calling us at DPC level
    //
    request = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(ACPI_GET_REQUEST),
        ACPI_MISC_POOLTAG
        );
    if (request == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( request, sizeof(ACPI_GET_REQUEST) );

    //
    // Propogate the information that the caller provided
    //
    request->Flags              = Flags;
    request->ObjectID           = ObjectID;
    request->DeviceExtension    = deviceExtension;
    request->AcpiObject         = acpiObject;
    request->CallBackRoutine    = CallBackRoutine;
    request->CallBackContext    = CallBackContext;
    request->Buffer             = Buffer;
    request->BufferSize         = BufferSize;

    //
    // Make sure that we queue the request onto the list that we use to
    // keep track of the requests
    //
    KeAcquireSpinLock( &AcpiGetLock, &oldIrql );
    InsertTailList(
        &(AcpiGetListEntry),
        &(request->ListEntry)
        );
    KeReleaseSpinLock( &AcpiGetLock, oldIrql );

    //
    // Do we have a node with a fake acpi object? This check is required
    // to support those devices that we really can run a control method on
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
         (deviceExtension->Flags & DEV_PROP_NO_OBJECT) &&
         (!(deviceExtension->Flags & DEV_PROP_DOCK)) ) {

        status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto ACPIGetExit;

    }

    //
    // Go out and see if the requested object is present
    //
    acpiObject = ACPIAmliGetNamedChild(
        acpiObject,
        ObjectID
        );
    if (!acpiObject) {

        status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto ACPIGetExit;

    }

    //
    // What we do now depends on wether or not the user wants us to
    // behave async or sync
    //
    if (async) {

        //
        // Evaluate the request
        //
        status = AMLIAsyncEvalObject(
            acpiObject,
            &(request->ResultData),
            argumentCount,
            argumentPtr,
            completionRoutine,
            request
            );
        if (status == STATUS_PENDING) {

            //
            // We cannot do anything else here. Wait for the completion routine
            // to fire
            //
            return status;

        }

    } else {

        //
        // Evaluate the request
        //
        status = AMLIEvalNameSpaceObject(
            acpiObject,
            &(request->ResultData),
            argumentCount,
            argumentPtr
            );

    }

    if (!NT_SUCCESS(status)) {

        //
        // We failed for some other reason
        //
        goto ACPIGetExit;

    }

ACPIGetExit:

    //
    // Remember to not execute the callback routine
    //
    request->Flags |= GET_PROP_SKIP_CALLBACK;

    //
    // Call the completion routine to actually do the post-processing
    //
    (completionRoutine)(
        acpiObject,
        status,
        &(request->ResultData),
        request
        );

    //
    // Get the real status value from the completion routine
    //
    status = request->Status;

    //
    // Done with the request
    //
    if (request != NULL) {

        //
        // Remove the request from the queue
        //
        KeAcquireSpinLock( &AcpiGetLock, &oldIrql );
        RemoveEntryList( &(request->ListEntry) );
        KeReleaseSpinLock( &AcpiGetLock, oldIrql );

        //
        // Free the storage
        //
        ExFreePool(  request );

    }

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIGetConvertToAddress(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine does all the handling required to convert the integer to
    an address

Arguments:

    DeviceExtension - The device asking for the address
    Status          - The result of the call to the interpreter
    Result          - The data passed back from the interpreter
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    ASSERT( Buffer != NULL );

    //
    // Did we succeed?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_ADDRESS) {

        *( (PULONG) Buffer) = DeviceExtension->Address;

    } else if (!NT_SUCCESS(Status)) {

        return Status;

    } else if (Result->dwDataType != OBJTYPE_INTDATA) {

        //
        // If we didn't get an integer, that's very bad.
        //
        return STATUS_ACPI_INVALID_DATA;

    } else {

        //
        // Set the value for the address
        //
        *( (PULONG) Buffer) = (ULONG)Result->uipDataValue;

    }

    //
    // Set the size of the buffer (if necessary)
    //
    if (BufferSize != NULL) {

        *BufferSize = sizeof(ULONG);

    }

    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToCompatibleID(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form *PNPxxxx\0<Repeat\0>\0.
    That is, there is at least one null-terminated elemented, followed
    by an arbiterary amount followed by another null. This string is in
    ANSI format.

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = Status;
    POBJDATA    currentObject;
    PPACKAGEOBJ packageObject;
    PUCHAR      buffer;
    PUCHAR      *localBufferArray;
    PUCHAR      ptr;
    ULONG       i                       = 0;
    ULONG       *localBufferSizeArray;
    ULONG       numElements;
    ULONG       newBufferSize           = 0;
    ULONG       memSize;

    //
    // Does this device have a fake CID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_CID) {

        //
        // It does. We can use that string in this one's place
        //
        memSize = strlen(DeviceExtension->Processor.CompatibleID) + 2;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Copy the memory
        //
        RtlCopyMemory( buffer, DeviceExtension->Processor.CompatibleID, memSize );

        //
        // Set the result string
        //
        *Buffer = buffer;
        if (BufferSize != NULL) {

            *BufferSize = newBufferSize;

        }

        //
        // Done
        //
        return STATUS_SUCCESS;

    }

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // Determine the number of data elements that we have.
    //
    //
    switch (Result->dwDataType) {
    case OBJTYPE_STRDATA:
    case OBJTYPE_INTDATA:

        numElements = 1;
        break;

    case OBJTYPE_PKGDATA:

        packageObject = ((PPACKAGEOBJ) Result->pbDataBuff );
        numElements = packageObject->dwcElements;
        break;

    default:
        return STATUS_ACPI_INVALID_DATA;

    }

    //
    // Now, lets allocate the storage that we will need to process those
    // elements
    //
    localBufferArray = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(PUCHAR) * numElements,
        ACPI_MISC_POOLTAG
        );
    if (localBufferArray == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( localBufferArray, sizeof(PUCHAR) * numElements );

    //
    // Lets allocate storage so that we know how big those elements are
    //
    localBufferSizeArray = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(ULONG) * numElements,
        ACPI_MISC_POOLTAG
        );
    if (localBufferSizeArray == NULL) {

        ExFreePool( localBufferArray );
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( localBufferSizeArray, sizeof(ULONG) * numElements );

    //
    // Process the data
    //
    switch (Result->dwDataType) {
    case OBJTYPE_STRDATA:

        status = ACPIGetConvertToString(
            DeviceExtension,
            Status,
            Result,
            Flags,
            &(localBufferArray[0]),
            &(localBufferSizeArray[0])
            );
        newBufferSize = localBufferSizeArray[0];

        break;

    case OBJTYPE_INTDATA:

        status = ACPIGetConvertToPnpID(
            DeviceExtension,
            Status,
            Result,
            Flags,
            &(localBufferArray[0]),
            &(localBufferSizeArray[0])
            );
        newBufferSize = localBufferSizeArray[0];

        break;

    case OBJTYPE_PKGDATA:

        //
        // Iterate over all the elements in the process
        //
        for (i = 0; i < numElements; i++) {

            //
            // Look at the element that we want to process
            //
            currentObject = &( packageObject->adata[i]);

            //
            // What kind of object to do we have?
            //
            switch (currentObject->dwDataType) {
            case OBJTYPE_STRDATA:

                status = ACPIGetConvertToString(
                    DeviceExtension,
                    Status,
                    currentObject,
                    Flags,
                    &(localBufferArray[i]),
                    &(localBufferSizeArray[i])
                    );
                break;

            case OBJTYPE_INTDATA:

                status = ACPIGetConvertToPnpID(
                    DeviceExtension,
                    Status,
                    currentObject,
                    Flags,
                    &(localBufferArray[i]),
                    &(localBufferSizeArray[i])
                    );
                break;

            default:

                ACPIInternalError( ACPI_GET );

            } // switch

            //
            // Did we fail?
            //
            if (!NT_SUCCESS(status)) {

                break;

            }

            //
            // Note that it is possible for the buffer to contain just the
            // string terminator. Since this would cause us to prematurely
            // terminate the resulting string. We must watch out for it
            //
            if (localBufferSizeArray[i] == 1) {

                localBufferSizeArray[i] = 0;

            }

            //
            // Keep running total of the size required
            //
            newBufferSize += localBufferSizeArray[i];

        } // for

        break;

    } // switch

    //
    // If we didn't succeed, then we must free all of the memory that
    // we tried to build up
    //
    if (!NT_SUCCESS(status)) {

        //
        // This is a little cheat that allows to share the cleanup code.
        // By making numElements equal to the current index, we place
        // a correct bound on the elements that must be freed
        //
        numElements = i;
        goto ACPIGetConvertToCompatibleIDExit;

    }

    //
    // If we have an empty list, or one that is only a null, then we
    // won't botther to return anything
    //
    if (newBufferSize <= 1) {

        status = STATUS_ACPI_INVALID_DATA;
        newBufferSize = 0;
        goto ACPIGetConvertToCompatibleIDExit;

    } else {

        //
        // Remember that we need to have an extra null at the end. Allocate
        // space for that null
        //
        newBufferSize++;

    }

    //
    // Allocate the memory
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        newBufferSize * sizeof(UCHAR),
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIGetConvertToCompatibleIDExit;

    }
    RtlZeroMemory( buffer, newBufferSize * sizeof(UCHAR) );

    //
    // Iterate over all pieces of the string
    //
    for (ptr = buffer, i = 0; i < numElements; i++) {

        if (localBufferArray[i] != NULL) {

            //
            // Copy over the interesting memory
            //
            RtlCopyMemory(
                ptr,
                localBufferArray[i],
                localBufferSizeArray[i] * sizeof(UCHAR)
                );

        }

        //
        // Increment the temp pointer to point to the next target location
        //
        ptr += localBufferSizeArray[i];

    }

    //
    // Set the result string
    //
    *Buffer = buffer;
    if (BufferSize != NULL) {

        *BufferSize = newBufferSize;

    }

ACPIGetConvertToCompatibleIDExit:

    //
    // Clean up
    //
    for (i = 0; i < numElements; i ++) {

        if (localBufferArray[i] != NULL ) {

            ExFreePool( localBufferArray[i] );

        }

    }
    ExFreePool( localBufferSizeArray );
    ExFreePool( localBufferArray );

    //
    // Return the appropriate status value
    //
    return status;
}

NTSTATUS
ACPIGetConvertToCompatibleIDWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form *PNPxxxx\0<Repeat\0>\0.
    That is, there is at least one null-terminated elemented, followed
    by an arbiterary amount followed by another null. This string is in
    UNICODE format.

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = Status;
    POBJDATA    currentObject;
    PPACKAGEOBJ packageObject;
    PWCHAR      buffer;
    PWCHAR      *localBufferArray;
    PWCHAR      ptr;
    ULONG       i                       = 0;
    ULONG       *localBufferSizeArray;
    ULONG       numElements             = 0;
    ULONG       newBufferSize           = 0;
    ULONG       memSize;

    //
    // Does this device have a fake CID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_CID) {

        //
        // It does. We can use that string in this one's place
        //
        memSize = strlen(DeviceExtension->Processor.CompatibleID) + 2;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Generate the string
        //
        swprintf( buffer, L"%S", DeviceExtension->Processor.CompatibleID );

        //
        // Set the result string
        //
        *Buffer = buffer;
        if (BufferSize != NULL) {

            *BufferSize = newBufferSize;

        }

        //
        // Done
        //
        return STATUS_SUCCESS;

    }

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // Determine the number of data elements that we have.
    //
    //
    switch (Result->dwDataType) {
    case OBJTYPE_STRDATA:
    case OBJTYPE_INTDATA:

        numElements = 1;
        break;

    case OBJTYPE_PKGDATA:

        packageObject = ((PPACKAGEOBJ) Result->pbDataBuff );
        numElements = packageObject->dwcElements;
        break;

    default:
        return STATUS_ACPI_INVALID_DATA;

    }

    //
    // Now, lets allocate the storage that we will need to process those
    // elements
    //
    localBufferArray = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(PWCHAR) * numElements,
        ACPI_MISC_POOLTAG
        );
    if (localBufferArray == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( localBufferArray, sizeof(PWCHAR) * numElements );

    //
    // Lets allocate storage so that we know how big those elements are
    //
    localBufferSizeArray = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(ULONG) * numElements,
        ACPI_MISC_POOLTAG
        );
    if (localBufferSizeArray == NULL) {

        ExFreePool( localBufferArray );
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( localBufferSizeArray, sizeof(ULONG) * numElements );

    //
    // Process the data
    //
    switch (Result->dwDataType) {
    case OBJTYPE_STRDATA:

        status = ACPIGetConvertToStringWide(
            DeviceExtension,
            Status,
            Result,
            Flags,
            &(localBufferArray[0]),
            &(localBufferSizeArray[0])
            );
        newBufferSize = localBufferSizeArray[0];

        break;

    case OBJTYPE_INTDATA:

        status = ACPIGetConvertToPnpIDWide(
            DeviceExtension,
            Status,
            Result,
            Flags,
            &(localBufferArray[0]),
            &(localBufferSizeArray[0])
            );
        newBufferSize = localBufferSizeArray[0];

        break;

    case OBJTYPE_PKGDATA:

        //
        // Iterate over all the elements in the process
        //
        for (i = 0; i < numElements; i++) {

            //
            // Look at the element that we want to process
            //
            currentObject = &( packageObject->adata[i]);

            //
            // What kind of object to do we have?
            //
            switch (currentObject->dwDataType) {
            case OBJTYPE_STRDATA:

                status = ACPIGetConvertToStringWide(
                    DeviceExtension,
                    Status,
                    currentObject,
                    Flags,
                    &(localBufferArray[i]),
                    &(localBufferSizeArray[i])
                    );
                break;

            case OBJTYPE_INTDATA:

                status = ACPIGetConvertToPnpIDWide(
                    DeviceExtension,
                    Status,
                    currentObject,
                    Flags,
                    &(localBufferArray[i]),
                    &(localBufferSizeArray[i])
                    );
                break;

            default:

                ACPIInternalError( ACPI_GET );

            } // switch

            //
            // Did we fail?
            //
            if (!NT_SUCCESS(status)) {

                break;

            }

            //
            // Note that it is possible for the buffer to contain just the
            // string terminator. Since this would cause us to prematurely
            // terminate the resulting string. We must watch out for it
            //
            if (localBufferSizeArray[i] == 1) {

                localBufferSizeArray[i] = 0;

            }

            //
            // Keep running total of the size required
            //
            newBufferSize += localBufferSizeArray[i];

        } // for

        //
        // If we didn't succeed, then we must free all of the memory that
        // we tried to build up
        //
        if (!NT_SUCCESS(status)) {

            //
            // This is a little cheat that allows to share the cleanup code.
            // By making numElements equal to the current index, we place
            // a correct bound on the elements that must be freed
            //
            numElements = i;

        }

        break;

    } // switch

    //
    // If we didn't succeed, then we must free all of the memory that
    // we tried to build up
    //
    if (!NT_SUCCESS(status)) {

        goto ACPIGetConvertToCompatibleIDWideExit;

    }

    //
    // If we have an empty list, or one that is only a null, then we
    // won't botther to return anything
    //
    if (newBufferSize <= 2) {

        status = STATUS_ACPI_INVALID_DATA;
        newBufferSize = 0;
        goto ACPIGetConvertToCompatibleIDWideExit;

    } else {

        //
        // Remember that we need to have an extra null at the end. Allocate
        // space for that null
        //
        newBufferSize += 2;

    }

    //
    // Allocate the memory. Note --- The memory has already been counted in
    // size of WCHARs.
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        newBufferSize,
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIGetConvertToCompatibleIDWideExit;

    }
    RtlZeroMemory( buffer, newBufferSize );

    //
    // Iterate over all pieces of the string
    //
    for (ptr = buffer, i = 0; i < numElements; i++) {

        if (localBufferArray[i] != NULL) {

            //
            // Copy over the interesting memory
            //
            RtlCopyMemory(
                ptr,
                localBufferArray[i],
                localBufferSizeArray[i]
                );

        }

        //
        // Increment the temp pointer to point to the next target location
        //
        ptr += localBufferSizeArray[i] / sizeof(WCHAR) ;

    }

    //
    // Set the result string
    //
    *Buffer = buffer;
    if (BufferSize != NULL) {

        *BufferSize = newBufferSize;

    }

ACPIGetConvertToCompatibleIDWideExit:

    //
    // Clean up
    //
    for (i = 0; i < numElements; i ++) {

        if (localBufferArray[i] != NULL ) {

            ExFreePool( localBufferArray[i] );

        }

    }
    ExFreePool( localBufferSizeArray );
    ExFreePool( localBufferArray );

    //
    // Return the appropriate status value
    //
    return status;
}

NTSTATUS
ACPIGetConvertToDeviceID(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form ACPI\PNPxxxx. This string
    is in ANSI format. The code is smart enough to check to see if the
    string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  buffer;
    PUCHAR  tempString;
    ULONG   memSize;

    //
    // First, check to see if we are a processor
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PROCESSOR) {

        //
        // If we don't have an _HID method, but we are a processor object,
        // then we can actually get the _HID through another mechanism
        //
        return ACPIGetProcessorID(
            DeviceExtension,
            Status,
            Result,
            Flags,
            Buffer,
            BufferSize
            );

    }

    //
    // Does this string have a fake HID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_HID) {

        //
        // It does. We can use that string in this one's place
        //
        memSize = strlen(DeviceExtension->DeviceID) + 1;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Copy the memory
        //
        RtlCopyMemory( buffer, DeviceExtension->DeviceID, memSize );

        //
        // Done
        //
        goto ACPIGetConvertToDeviceIDExit;

    }

    //
    // Are we a PCI Bar Target device? If so, then we have special handling
    // rules that we must follow
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // Right now, lets call the this a "PciBarTarget" device, which
        // is 13 characters long (including the NULL). We also need to add
        // 5 characters for the ACPI\ part of the name
        //
        memSize = 18;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Print the string
        //
        sprintf( buffer, "%s", "ACPI\\PciBarTarget" );

        //
        // Done
        //
        goto ACPIGetConvertToDeviceIDExit;

    }

    //
    // If we got to this point, then that means that there probably wasn't
    // an _HID method *or* the method error'ed out.
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // We need to handle things differently based on wether we have an
    // EISAID or a String
    //
    switch (Result->dwDataType) {
    case OBJTYPE_INTDATA:

        //
        // For a device ID, we need 4 (ACPI) + 1 (\\) + 7 (PNPxxxx) + 1 (\0)
        // = 13 characters
        //
        memSize = 13;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Put the leading characters in place
        //
        sprintf( buffer, "ACPI\\" );

        //
        // Convert the packed string
        //
        ACPIAmliDoubleToName( buffer+5, (ULONG)Result->uipDataValue, FALSE );

        //
        // Done
        //
        break;

    case OBJTYPE_STRDATA:

        //
        // Lets grab a pointer to the string that we will be using
        //
        tempString = Result->pbDataBuff;

        //
        // Does it have a leading '*'? If it does, then we must ignore
        // it
        //
        if (*tempString == '*') {

            tempString++;

        }

        //
        // For a string, make sure that there is no leading '*' and
        // account for the fact that we will preceed the string with
        // the words 'ACPI\\" and NULL
        //
        memSize = 6 + strlen(tempString);

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Put the leading characters in place
        //
        sprintf( buffer, "ACPI\\%s", tempString );

        //
        // Done
        //
        break;

    default:

        return STATUS_ACPI_INVALID_DATA;

    }

ACPIGetConvertToDeviceIDExit:

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = memSize;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToDeviceIDWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form ACPI\PNPxxxx. This string
    is in UNICODE format. The code is smart enough to check to see if the
    string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  tempString;
    PWSTR   buffer;
    ULONG   memSize;

    //
    // First, check to see if we are a processor
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PROCESSOR) {

        //
        // If we don't have an _HID method, but we are a processor object,
        // then we can actually get the _HID through another mechanism
        //
        return ACPIGetProcessorIDWide(
            DeviceExtension,
            Status,
            Result,
            Flags,
            Buffer,
            BufferSize
            );

    }

    //
    // Does this string have a fake HID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_HID) {

        //
        // It does. We can use that string in this one's place
        //
        memSize = strlen(DeviceExtension->DeviceID) + 1;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Generate the string
        //
        swprintf( buffer, L"%S", DeviceExtension->DeviceID );

        //
        // Done
        //
        goto ACPIGetConvertToDeviceIDWideExit;

    }

    //
    // Are we a PCI Bar Target device? If so, then we have special handling
    // rules that we must follow
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // Right now, lets call the this a "PciBarTarget" device, which
        // is 13 characters long (including the NULL). We also need to add
        // 5 characters for the ACPI\ part of the name
        //
        memSize = 18;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Print the string
        //
        swprintf( buffer, L"%S", "ACPI\\PciBarTarget" );

        //
        // Done
        //
        goto ACPIGetConvertToDeviceIDWideExit;

    }

    //
    // If we got to this point, then that means that there probably wasn't
    // an _HID method *or* the method error'ed out.
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // We need to handle things differently based on wether we have an
    // EISAID or a String
    //
    switch (Result->dwDataType) {
    case OBJTYPE_INTDATA:

        //
        // For a device ID, we need 4 (ACPI) + 1 (\\) + 7 (PNPxxxx) + 1 (\0)
        // = 13 characters
        //
        memSize = 13;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Put the leading characters in place
        //
        swprintf( buffer, L"ACPI\\" );

        //
        // Convert the packed string
        //
        ACPIAmliDoubleToNameWide( buffer+5, (ULONG)Result->uipDataValue, FALSE );

        //
        // Done
        //
        break;

    case OBJTYPE_STRDATA:

        //
        // Lets grab a pointer to the string that we will be using
        //
        tempString = Result->pbDataBuff;

        //
        // Does it have a leading '*'? If it does, then we must ignore
        // it
        //
        if (*tempString == '*') {

            tempString++;

        }

        //
        // For a string, make sure that there is no leading '*' and
        // account for the fact that we will preceed the string with
        // the words 'ACPI\\" and NULL
        //
        memSize = 6 + strlen(tempString);

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Put the leading characters in place
        //
        swprintf( buffer, L"ACPI\\%S", tempString );

        //
        // Done
        //
        break;

    default:

        return STATUS_ACPI_INVALID_DATA;

    }

ACPIGetConvertToDeviceIDWideExit:

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = (memSize * sizeof(WCHAR) );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToDevicePresence(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine does all the handling required to convert the integer to
    an status value.

    Note that this function is different then the GetStatus one because
    this one
        a) Updates the internal device status
        b) Allows the 'device' to be present even if there is no _STA

Arguments:

    DeviceExtension - The device asking for the address
    Status          - The result of the call to the interpreter
    Result          - The data passed back from the interpreter
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    ULONG       deviceStatus = STA_STATUS_DEFAULT;
    NTSTATUS    status;

    //
    // Profile providers are present if one of the following cases is true:
    // 1) The ACPI object corresponding to the dock is itself present
    // 2) The dock is unattached (ie, requesting attachment)
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) ) {

        if (DeviceExtension->Flags & DEV_PROP_DOCK) {

            if (DeviceExtension->Flags & DEV_CAP_UNATTACHED_DOCK) {

                goto ACPIGetConvertToDevicePresenceExit;

            }

            //
            // We should have handled the case where we need to run the
            // _STA on the proper target node...
            //

        } else if (DeviceExtension->Flags & DEV_PROP_NO_OBJECT) {

            goto ACPIGetConvertToDevicePresenceExit;

        }

        //
        // At this point, we can see what the control method returned. If the
        // control method returned STATUS_OBJECT_NAME_NOT_FOUND, then we know
        // that the control method doesn't exist. In that case, then we have
        // to use the default status for the device
        //
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // We do make exceptions in the case that this is a processor object
            // and we didn't find a control method. In this case, we check the
            // processor affinity mask to see if this processor exists. The reason
            // that we do this is that older multi-proc capable systems with only
            // a single processor will errorneously report both processors.
            //
            if (DeviceExtension->Flags & DEV_CAP_PROCESSOR) {

                //
                // Let the processor specific function to do all the
                // work.
                //
                status = ACPIGetProcessorStatus(
                    DeviceExtension,
                    Flags,
                    &deviceStatus
                    );
                if (!NT_SUCCESS(status)) {

                    //
                    // Something bad occured, so assume that the processor
                    // isn't present...
                    //
                    deviceStatus = 0;

                }

            }

            //
            // Skip a couple of useless steps...
            //
            goto ACPIGetConvertToDevicePresenceExit;

        } else if (!NT_SUCCESS(Status)) {

            deviceStatus = 0;
            goto ACPIGetConvertToDevicePresenceExit;

        }

        //
        // If the data isn't of the correct type, then we *really* should bugcheck
        //
        if (Result->dwDataType != OBJTYPE_INTDATA) {

            PNSOBJ  staObject;

            //
            // We need the sta Object for the bugcheck
            //
            staObject= ACPIAmliGetNamedChild(
                DeviceExtension->AcpiObject,
                PACKED_STA
                );
            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_EXPECTED_INTEGER,
                (ULONG_PTR) DeviceExtension,
                (ULONG_PTR) staObject,
                Result->dwDataType
                );

        }

        //
        // Get the real result
        //
        deviceStatus = (ULONG)Result->uipDataValue;

    } else {

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

            goto ACPIGetConvertToDevicePresenceExit2;

        }
        if (!NT_SUCCESS(Status)) {

            deviceStatus = 0;
            goto ACPIGetConvertToDevicePresenceExit2;

        }
        if (Result->dwDataType != OBJTYPE_INTDATA) {

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_EXPECTED_INTEGER,
                (ULONG_PTR) DeviceExtension,
                (ULONG_PTR) NULL,
                Result->dwDataType
                );

        }

        //
        // Get the real result
        //
        deviceStatus = (ULONG)Result->uipDataValue;
        goto ACPIGetConvertToDevicePresenceExit2;

    }


ACPIGetConvertToDevicePresenceExit:

    //
    // If the device is marked as NEVER_PRESENT, then we will always
    // have a status of NOT_PRESENT
    //
    if ((DeviceExtension->Flags & DEV_TYPE_NEVER_PRESENT)&&
        !(Flags & GET_CONVERT_IGNORE_OVERRIDES)) {

        deviceStatus &= ~STA_STATUS_PRESENT;

    }

    //
    // If the device is marked as NEVER_SHOW, then we will have have a
    // a status of !USER_INTERFACE
    //
    if (DeviceExtension->Flags & DEV_CAP_NEVER_SHOW_IN_UI) {

        deviceStatus &= ~STA_STATUS_USER_INTERFACE;

    }

    //
    // Update the device status
    //
    ACPIInternalUpdateDeviceStatus( DeviceExtension, deviceStatus );

ACPIGetConvertToDevicePresenceExit2:

    //
    // Set the value for the status
    //
    *( (PULONG) Buffer) = deviceStatus;
    if (BufferSize != NULL) {

        *BufferSize = sizeof(ULONG);

    }

    return STATUS_SUCCESS;

}

NTSTATUS
ACPIGetConvertToHardwareID(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form ACPI\PNPxxxx\0*PNPxxxx\0\0.
    This string is in ANSI format. The code is smart enough to check to see
    if the string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN     freeTempString = FALSE;
    NTSTATUS    status = Status;
    PUCHAR      buffer;
    PUCHAR      tempString;
    ULONG       deviceSize;
    ULONG       memSize;

    //
    // First, check to see if we are a processor
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PROCESSOR) {

        //
        // Use an alternate means to get the processor ID
        //
        status = ACPIGetProcessorID(
            DeviceExtension,
            Status,
            Result,
            Flags,
            &buffer,
            &memSize
            );
        goto ACPIGetConvertToHardwareIDSuccessExit;

    } else if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
               DeviceExtension->Flags & DEV_PROP_FIXED_HID) {

        //
        // Does this string have a fake HID?
        //

        //
        // It does. We can use that string in this one's place. We want a
        // string that subtracts the leading 'ACPI\\' and adds a '\0' at
        // the end.
        //
        deviceSize  = strlen(DeviceExtension->DeviceID) - 4;

        //
        // Allocate the memory
        //
        tempString = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            deviceSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (tempString == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ACPIGetConvertToHardwareIDExit;

        }
        RtlZeroMemory( tempString, deviceSize * sizeof(UCHAR) );
        freeTempString = TRUE;

        //
        // Generate the PNP ID. The offset of +5 will get rid of the
        // leading 'ACPI\\'
        //
        sprintf( tempString, "%s", DeviceExtension->DeviceID + 5 );

    } else if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
               DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // Are we a PCI Bar Target device? If so, then we have special handling
        // rules that we must follow
        //

        //
        // Right now, lets call the this a "PciBarTarget" device, which
        // is 13 characters long (including the NULL)
        //
        deviceSize = 13;

        //
        // Allocate the memory
        //
        tempString = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            deviceSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (tempString == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( tempString, deviceSize * sizeof(UCHAR) );
        freeTempString = TRUE;

        //
        // Print the string
        //
        sprintf( tempString, "%s", "PciBarTarget" );

    } else if (!NT_SUCCESS(Status)) {

        //
        // If we got to this point, and there isn't a successfull status,
        // then there is nothing we can do
        //
        return Status;

    } else {

        //
        // We need to handle things differently based on wether we have an
        // EISAID or a String
        //
        switch (Result->dwDataType) {
        case OBJTYPE_INTDATA:

            //
            // For a hardware ID, we need 7 (PNPxxxx) + 1 (\0)
            // = 8 characters
            //
            deviceSize = 8;

            //
            // Allocate the memory
            //
            tempString = ExAllocatePoolWithTag(
                ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
                deviceSize * sizeof(UCHAR),
                ACPI_STRING_POOLTAG
                );
            if (tempString == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto ACPIGetConvertToHardwareIDExit;

            }
            RtlZeroMemory( tempString, deviceSize * sizeof(UCHAR) );
            freeTempString = TRUE;

            //
            // Convert the packed string for the PNP ID
            //
            ACPIAmliDoubleToName( tempString, (ULONG)Result->uipDataValue, FALSE );

            //
            // Done
            //
            break;

        case OBJTYPE_STRDATA:

            //
            // Lets grab a pointer to the string that we will be using
            //
            tempString = Result->pbDataBuff;

            //
            // Does it have a leading '*'? If it does, then we must ignore
            // it
            //
            if (*tempString == '*') {

                tempString++;

            }

            //
            // We need to determine how long the string is
            //
            deviceSize = strlen(tempString) + 1;

            //
            // done
            //
            break;

        default:

            return STATUS_ACPI_INVALID_DATA;

        }
    }

    //
    // When we reach this point, we have a string that contains just the
    // PNPxxxx characters and nothing else. We need to generate a string
    // of the form 'ACPI\PNPxxxx\0*PNPxxxx\0\0'. So we take the string length
    // doubled, and add 7
    //
    memSize = 7 + (2 * deviceSize);

    //
    // Allocate the memory
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        memSize * sizeof(UCHAR),
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIGetConvertToHardwareIDExit;

    }
    RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

    //
    // Put the leading characters in place
    //
    sprintf( buffer, "ACPI\\%s", tempString );

    //
    // We need to generate the offset in to the second string. To do this
    // we need to add 5 to the original size
    //
    deviceSize += 5;

    //
    // Put the 2nd string in its place
    //
    sprintf( buffer + deviceSize, "*%s", tempString );

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
ACPIGetConvertToHardwareIDSuccessExit:
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = memSize;

    }
    status = STATUS_SUCCESS;

ACPIGetConvertToHardwareIDExit:

    //
    // Do we need to free the tempString?
    //
    if (freeTempString == TRUE) {

        ExFreePool( tempString );

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIGetConvertToHardwareIDWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form ACPI\PNPxxxx\0*PNPxxxx\0\0.
    This stringis in UNICODE format. The code is smart enough to check to see
    if the string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN     freeTempString = FALSE;
    NTSTATUS    status = Status;
    PUCHAR      tempString;
    PWCHAR      buffer;
    ULONG       deviceSize;
    ULONG       memSize;

    //
    // First, check to see if we are a processor
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PROCESSOR) {

        //
        // Use an alternate means to get the processor ID
        //
        status = ACPIGetProcessorIDWide(
            DeviceExtension,
            Status,
            Result,
            Flags,
            &buffer,
            &memSize
            );
        goto ACPIGetConvertToHardwareIDWideSuccessExit;

    } else if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
               DeviceExtension->Flags & DEV_PROP_FIXED_HID) {

        //
        // Does this string have a fake HID?
        //

        //
        // It does. We can use that string in this one's place. We want a
        // string that subtracts the leading 'ACPI\\' and adds a '\0' at
        // the end.
        //
        deviceSize  = strlen(DeviceExtension->DeviceID) - 4;

        //
        // Allocate the memory
        //
        tempString = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            deviceSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (tempString == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ACPIGetConvertToHardwareIDWideExit;

        }
        RtlZeroMemory( tempString, deviceSize * sizeof(UCHAR) );
        freeTempString = TRUE;

        //
        // Generate the PNP ID. The offset of +5 will get rid of the
        // leading 'ACPI\\'
        //
        sprintf( tempString, "%s", DeviceExtension->DeviceID + 5 );

    } else if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
               DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // Are we a PCI Bar Target device? If so, then we have special handling
        // rules that we must follow
        //

        //
        // Right now, lets call the this a "PciBarTarget" device, which
        // is 13 characters long (including the NULL)
        //
        deviceSize = 13;

        //
        // Allocate the memory
        //
        tempString = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            deviceSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (tempString == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( tempString, deviceSize * sizeof(UCHAR) );
        freeTempString = TRUE;

        //
        // Print the string
        //
        sprintf( tempString, "%s", "PciBarTarget" );

    } else if (!NT_SUCCESS(Status)) {

        //
        // If we got to this point, and there isn't a successfull status,
        // then there is nothing we can do
        //
        return Status;

    } else {

        //
        // We need to handle things differently based on wether we have an
        // EISAID or a String
        //
        switch (Result->dwDataType) {
        case OBJTYPE_INTDATA:

            //
            // For a hardware ID, we need 7 (PNPxxxx) + 1 (\0)
            // = 8 characters
            //
            deviceSize = 8;

            //
            // Allocate the memory
            //
            tempString = ExAllocatePoolWithTag(
                ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
                deviceSize * sizeof(UCHAR),
                ACPI_STRING_POOLTAG
                );
            if (tempString == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto ACPIGetConvertToHardwareIDWideExit;

            }
            RtlZeroMemory( tempString, deviceSize * sizeof(UCHAR) );
            freeTempString = TRUE;

            //
            // Convert the packed string for the PNP ID
            //
            ACPIAmliDoubleToName( tempString, (ULONG)Result->uipDataValue, FALSE );

            //
            // Done
            //
            break;

        case OBJTYPE_STRDATA:

            //
            // Lets grab a pointer to the string that we will be using
            //
            tempString = Result->pbDataBuff;

            //
            // Does it have a leading '*'? If it does, then we must ignore
            // it
            //
            if (*tempString == '*') {

                tempString++;

            }

            //
            // We need to determine how long the string is
            //
            deviceSize = strlen(tempString) + 1;

            //
            // done
            //
            break;

        default:

            return STATUS_ACPI_INVALID_DATA;

        }
    }

    //
    // When we reach this point, we have a string that contains just the
    // PNPxxxx characters and nothing else. We need to generate a string
    // of the form 'ACPI\PNPxxxx\0*PNPxxxx\0\0'. So we take the string length
    // doubled, and add 7
    //
    memSize = 7 + (2 * deviceSize);

    //
    // Allocate the memory
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        memSize * sizeof(WCHAR),
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIGetConvertToHardwareIDWideExit;

    }
    RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

    //
    // Put the leading characters in place
    //
    swprintf( buffer, L"ACPI\\%S", tempString );

    //
    // We need to generate the offset in to the second string. To do this
    // we need to add 5 to the original size
    //
    deviceSize += 5;

    //
    // Put the 2nd string in its place
    //
    swprintf( buffer + deviceSize, L"*%S", tempString );

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
ACPIGetConvertToHardwareIDWideSuccessExit:
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = (memSize * sizeof(WCHAR) );

    }
    status = STATUS_SUCCESS;

ACPIGetConvertToHardwareIDWideExit:

    //
    // Do we need to free the tempString?
    //
    if (freeTempString == TRUE) {

        ExFreePool( tempString );

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIGetConvertToInstanceID(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form XXXXX (in hex values).
    This string is in ANSI format. The code is smart enough to check to see
    if the string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  buffer;
    ULONG   memSize;

    //
    // Does this string have a fake HID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_UID) {

        //
        // It does. We can use that string in this one's place.
        //
        memSize = strlen(DeviceExtension->InstanceID) + 1;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Generate the PNP ID. The offset of +5 will get rid of the
        // leading 'ACPI\\'
        //
        RtlCopyMemory( buffer, DeviceExtension->InstanceID, memSize );

        //
        // Done
        //
        goto ACPIGetConvertToInstanceIDExit;

    }

    //
    // Are we a PCI Bar Target device? If so, then we have special handling
    // rules that we must follow
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // We are going to use the device's Address (which we should
        // have pre-cached inside the device extension) as the Unique ID.
        // We know that we will need at most nine characters since the
        // Address is limited to a DWORD in size.
        //
        memSize = 9;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Print the string
        //
        sprintf( buffer, "%lx", DeviceExtension->Address );

        //
        // Done
        //
        goto ACPIGetConvertToInstanceIDExit;

    }

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // We need to handle things differently based on wether we have an
    // EISAID or a String
    //
    switch (Result->dwDataType) {
    case OBJTYPE_INTDATA:

        //
        // For an Instance ID, we need at most 9 characters
        //
        memSize = 9;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Print the string
        //
        sprintf( buffer, "%lx", Result->uipDataValue );

        //
        // Done
        //
        break;

    case OBJTYPE_STRDATA:

        //
        // Just copy the string that was handed to us
        //
        memSize = strlen(Result->pbDataBuff) + 1;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Put the leading characters in place
        //
        RtlCopyMemory( buffer, Result->pbDataBuff, memSize );

        //
        // Done
        //
        break;

    default:

        return STATUS_ACPI_INVALID_DATA;

    }

ACPIGetConvertToInstanceIDExit:

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = memSize;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToInstanceIDWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form XXXXX (in hex values).
    This string is in ANSI format. The code is smart enough to check to see
    if the string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PWCHAR  buffer;
    ULONG   memSize;

    //
    // Does this string have a fake HID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_UID) {

        //
        // It does. We can use that string in this one's place.
        //
        memSize = strlen(DeviceExtension->InstanceID) + 1;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Generate the PNP ID. The offset of +5 will get rid of the
        // leading 'ACPI\\'
        //
        swprintf( buffer, L"%S", DeviceExtension->InstanceID );

        //
        // Done
        //
        goto ACPIGetConvertToInstanceIDWideExit;

    }

    //
    // Are we a PCI Bar Target device? If so, then we have special handling
    // rules that we must follow
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // We are going to use the device's Address (which we should
        // have pre-cached inside the device extension) as the Unique ID.
        // We know that we will need at most nine characters since the
        // Address is limited to a DWORD in size.
        //
        memSize = 9;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Print the string
        //
        swprintf( buffer, L"%lx", Result->uipDataValue );

        //
        // Done
        //
        goto ACPIGetConvertToInstanceIDWideExit;

    }

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // We need to handle things differently based on wether we have an
    // EISAID or a String
    //
    switch (Result->dwDataType) {
    case OBJTYPE_INTDATA:

        //
        // For an Instance ID, we need at most 9 characters
        //
        memSize = 9;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Print the string
        //
        swprintf( buffer, L"%lx", Result->uipDataValue );

        //
        // Done
        //
        break;

    case OBJTYPE_STRDATA:

        //
        // Just copy the string that was handed to us
        //
        memSize = strlen(Result->pbDataBuff) + 1;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Put the leading characters in place
        //
        swprintf( buffer, L"%S", Result->pbDataBuff );

        //
        // Done
        //
        break;

    default:

        return STATUS_ACPI_INVALID_DATA;

    }

ACPIGetConvertToInstanceIDWideExit:

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = (memSize * sizeof(WCHAR));

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToPnpID(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form *PNPxxxx\0.
    This stringis in ANSI format. The code is smart enough to check to see
    if the string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  buffer;
    PUCHAR  tempString;
    ULONG   memSize;

    //
    // Does this string have a fake HID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_HID) {

        //
        // It does. We can use that string in this one's place. We need
        // to subtract 3 because we need to account for the leading
        // 'ACPI\' (5) and the '*' and '\0' (2) = 3
        //
        memSize = strlen(DeviceExtension->DeviceID) - 3;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Generate the PNP ID. The offset of +5 will get rid of the
        // leading 'ACPI\\'
        //
        sprintf( buffer, "*%s", DeviceExtension->DeviceID + 5 );

        //
        // Done
        //
        goto ACPIGetConvertToPnpIDExit;

    }

    //
    // Are we a PCI Bar Target device? If so, then we have special handling
    // rules that we must follow
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // Right now, lets call the this a "*PciBarTarget" device, which
        // is 14 characters long (including the NULL)
        //
        memSize = 14;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Print the string
        //
        sprintf( buffer, "*%s", "PciBarTarget" );

        //
        // Done
        //
        goto ACPIGetConvertToPnpIDExit;

    }

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // We need to handle things differently based on wether we have an
    // EISAID or a String
    //
    switch (Result->dwDataType) {
    case OBJTYPE_INTDATA:

        //
        // For a pnp ID, we need 1 (*) + 7 (PNPxxxx) + 1 (\0)
        // = 9 characters
        //
        memSize = 9;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Convert the packed string
        //
        ACPIAmliDoubleToName( buffer, (ULONG)Result->uipDataValue, TRUE );

        //
        // Done
        //
        break;

    case OBJTYPE_STRDATA:

        //
        // Lets grab a pointer to the string that we will be using
        //
        tempString = Result->pbDataBuff;

        //
        // Does it have a leading '*'? If it does, then we must ignore
        // it
        //
        if (*tempString == '*') {

            tempString++;

        }

        //
        // For a string, make sure that there is no leading '*' and
        // account for the fact that we will preceed the string with
        // a '*' and NULL
        //
        memSize = 2 + strlen(tempString);

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Put the leading characters in place
        //
        sprintf( buffer, "*%s", tempString );

        //
        // Done
        //
        break;

    default:

        return STATUS_ACPI_INVALID_DATA;

    }

ACPIGetConvertToPnpIDExit:

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = memSize;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToPnpIDWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form *PNPxxxx\0.
    This stringis in ANSI format. The code is smart enough to check to see
    if the string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  tempString;
    PWCHAR  buffer;
    ULONG   memSize;

    //
    // Does this string have a fake HID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_HID) {

        //
        // It does. We can use that string in this one's place. We need
        // to subtract 3 because we need to account for the leading
        // 'ACPI\' (5) and the '*' and '\0' (2) = 3
        //
        memSize = strlen(DeviceExtension->DeviceID) - 3;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Generate the PNP ID. The offset of +5 will get rid of the
        // leading 'ACPI\\'
        //
        swprintf( buffer, L"*%S", DeviceExtension->DeviceID + 5 );

        //
        // Done
        //
        goto ACPIGetConvertToPnpIDWideExit;

    }

    //
    // Are we a PCI Bar Target device? If so, then we have special handling
    // rules that we must follow
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // Right now, lets call the this a "*PciBarTarget" device, which
        // is 14 characters long (including the NULL)
        //
        memSize = 14;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Print the string
        //
        swprintf( buffer, L"*%S", "PciBarTarget" );

        //
        // Done
        //
        goto ACPIGetConvertToPnpIDWideExit;

    }
    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // We need to handle things differently based on wether we have an
    // EISAID or a String
    //
    switch (Result->dwDataType) {
    case OBJTYPE_INTDATA:

        //
        // For a pnp ID, we need 1 (*) + 7 (PNPxxxx) + 1 (\0)
        // = 9 characters
        //
        memSize = 9;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Convert the packed string
        //
        ACPIAmliDoubleToNameWide( buffer, (ULONG)Result->uipDataValue, TRUE );

        //
        // Done
        //
        break;

    case OBJTYPE_STRDATA:

        //
        // Lets grab a pointer to the string that we will be using
        //
        tempString = Result->pbDataBuff;

        //
        // Does it have a leading '*'? If it does, then we must ignore
        // it
        //
        if (*tempString == '*') {

            tempString++;

        }

        //
        // For a string, make sure that there is no leading '*' and
        // account for the fact that we will preceed the string with
        // a '*' and NULL
        //
        memSize = 2 + strlen(tempString);

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Put the leading characters in place
        //
        swprintf( buffer, L"*%S", tempString );

        //
        // Done
        //
        break;

    default:

        return STATUS_ACPI_INVALID_DATA;

    }

ACPIGetConvertToPnpIDWideExit:

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = (memSize * sizeof(WCHAR) );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToSerialIDWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize OPTIONAL
    )
/*++

Routine Description:

    This routine generates an string or number of the form ????
    This string is in UNICODE format.

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PWCHAR buffer ;

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    switch (Result->dwDataType) {
    case OBJTYPE_INTDATA:

        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            9 * sizeof(WCHAR), // 9 WCHARS, or L"nnnnnnnn\0"
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Convert to string
        //
        swprintf( buffer, L"%X", (ULONG)Result->uipDataValue );

        *(Buffer) = buffer;
        if (BufferSize != NULL) {

            *(BufferSize) = (9 * sizeof(WCHAR) );
        }

        //
        // Done
        //
        return STATUS_SUCCESS;

    case OBJTYPE_STRDATA:

        return ACPIGetConvertToStringWide(
            DeviceExtension,
            Status,
            Result,
            Flags,
            Buffer,
            BufferSize
            ) ;

    default:

        return STATUS_ACPI_INVALID_DATA;
    }
}

NTSTATUS
ACPIGetConvertToString(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form ????
    This stringis in ANSI format.

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  buffer;
    ULONG   memSize;

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // Do we not have a string?
    //
    if (Result->dwDataType != OBJTYPE_STRDATA) {

        return STATUS_ACPI_INVALID_DATA;

    }

    //
    // For a string, make sure that there is no leading '*' and
    // account for the fact that we will preceed the string with
    // a '*' and NULL
    //
    memSize = strlen(Result->pbDataBuff) + 1;

    //
    // Allocate the memory
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        memSize * sizeof(UCHAR),
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

    //
    // Copy the string
    //
    RtlCopyMemory( buffer, Result->pbDataBuff, memSize );

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = memSize;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToStringWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize OPTIONAL
    )
/*++

Routine Description:

    This routine generates an string of the form ????
    This stringis in UNICODE format.

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PWCHAR  buffer;
    ULONG   memSize;

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // Do we not have a string?
    //
    if (Result->dwDataType != OBJTYPE_STRDATA) {

        return STATUS_ACPI_INVALID_DATA;

    }

    //
    // For a string, make sure that there is no leading '*' and
    // account for the fact that we will preceed the string with
    // a '*' and NULL
    //
    memSize = strlen(Result->pbDataBuff) + 1;

    //
    // Allocate the memory
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        memSize * sizeof(WCHAR),
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

    //
    // Generate the string
    //
    swprintf( buffer, L"%S", Result->pbDataBuff );

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = (memSize * sizeof(WCHAR) );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetProcessorID(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string in either the hardware or device form
    (see the Flags to decide which one to create). This string
    is in ANSI format. This function interogates the processor directly
    to determine which string to return

Arguments:

    DeviceExtension - The extension to use when building the ID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  buffer;
    PUCHAR  tempPtr;
    PUCHAR  defaultString;
    ULONG   i;
    ULONG   max;
    ULONG   memSize;
    ULONG   offset;

    //
    // We store the name of the processor string in a global...
    //
    defaultString = AcpiProcessorString.Buffer;

    //
    // Calculate how much space we need for the base string
    // (which is ACPI\\%s)
    //
    offset = AcpiProcessorString.Length;
    memSize = AcpiProcessorString.Length + 5;

    //
    // If we are building a Hardware ID, then we are going to
    // need to replicate the string a few times to generate some
    // substrings --- we could use an algorithm that gets us the correct
    // size, but its easier to just overshoot
    //
    if (Flags & GET_CONVERT_TO_HARDWAREID) {

        //
        // Walk the string from the end and try to determine how many subparts
        // there are to it
        //
        i = offset;
        max = 0;
        while (i > 0) {

            //
            // Is the character a number or not?
            //
            if (ISDIGIT(defaultString[i-1])) {

                //
                // Increment the number of parts that we need and try to
                // find the previous space
                //
                max++;
                i--;
                while (i > 0) {

                    if (defaultString[i-1] != ' ') {

                        i--;

                    }
                    break;

                }

                //
                // Since we made a hit, continue the while loop, which will
                // mean that we also don't decr i again
                //
                continue;

            }

            //
            // Look at the previous character
            //
            i--;

        }

        memSize *= (max * 2);

    }

    //
    // Allocate the memory
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        memSize * sizeof(UCHAR),
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        *(Buffer) = NULL;
        if (BufferSize != NULL) {

            *(BufferSize) = 0;

        }
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

    //
    // Lets just deal with the simple case of the device id string
    //
    if (Flags & GET_CONVERT_TO_DEVICEID) {

        sprintf( buffer, "ACPI\\%s", defaultString );
        goto ACPIGetProcessorIDExit;

    }


    //
    // At this point, we have to iterate over the entire buffer and fill
    // it in with parts of the Processor String. We will also take this
    // time to calculate the exact amount of memory required by this string
    //
    memSize = 2;
    tempPtr = buffer;
    for (i = 0; i < max; i++) {

        //
        // First step is to find the nearest "number" from the end of the
        // default string
        //
        while (offset > 0) {

            if (ISDIGIT(defaultString[offset-1])) {
              break;
            }
            offset--;

        }

        //
        // Generate the ACPI\\%s string
        //
        sprintf(tempPtr,"ACPI\\%*s",offset,defaultString);
        tempPtr += (offset + 5);
        *tempPtr = '\0';
        tempPtr++;
        memSize += (offset + 6);

        //
        // Generate the *%s string
        //
        sprintf(tempPtr,"*%*s",offset,defaultString);
        tempPtr += (offset + 1);
        *tempPtr = '\0';
        tempPtr++;
        memSize += (offset + 2);

        //
        // Now try to find the previous space in the substring so that we
        // don't accidently match on a two digit number
        //
        while (offset > 0) {

            if (defaultString[offset-1] == ' ') {

                break;

            }
            offset--;

        }

    }

    //
    // Put in the final null Character
    //
    *tempPtr = L'\0';

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
ACPIGetProcessorIDExit:
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = memSize;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIGetProcessorIDWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string in either the hardware or device form
    (see the Flags to decide which one to create). This string
    is in UNICODE format. This function interogates the processor directly
    to determine which string to return

Arguments:

    DeviceExtension - The extension to use when building the ID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  defaultString;
    PWCHAR  buffer;
    PWCHAR  tempPtr;
    ULONG   i;
    ULONG   max;
    ULONG   memSize;
    ULONG   offset;

    //
    // We store the name of the processor string in a global...
    //
    defaultString = AcpiProcessorString.Buffer;

    //
    // Calculate how much space we need for the base string
    // (which is ACPI\\%s)
    //
    offset = AcpiProcessorString.Length;
    memSize = AcpiProcessorString.Length + 5;

    //
    // If we are building a Hardware ID, then we are going to
    // need to replicate the string a few times to generate some
    // substrings --- we could use an algorithm that gets us the correct
    // size, but its easier to just overshoot
    //
    if (Flags & GET_CONVERT_TO_HARDWAREID) {

        //
        // Walk the string from the end and try to determine how many subparts
        // there are to it
        //
        i = offset;
        max = 0;
        while (i > 0) {

            //
            // Is the character a number or not?
            //
            if (ISDIGIT(defaultString[i-1])) {

                //
                // Increment the number of parts that we need and try to
                // find the previous space
                //
                max++;
                i--;
                while (i > 0) {

                    if (defaultString[i-1] != ' ') {

                        i--;

                    }
                    break;

                }

                //
                // Since we made a hit, continue the while loop, which will
                // mean that we also don't decr i again
                //
                continue;

            }

            //
            // Look at the previous character
            //
            i--;

        }

        memSize *= (max * 2);

    }

    //
    // Allocate the memory
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        memSize * sizeof(WCHAR),
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        *(Buffer) = NULL;
        if (BufferSize != NULL) {

            *(BufferSize) = 0;

        }
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

    //
    // Lets just deal with the simple case of the device id string
    //
    if (Flags & GET_CONVERT_TO_DEVICEID) {

        swprintf( buffer, L"ACPI\\%S", defaultString );
        goto ACPIGetProcessorIDWideExit;

    }

    //
    // At this point, we have to iterate over the entire buffer and fill
    // it in with parts of the Processor String. We will also take this
    // time to calculate the exact amount of memory required by this string
    //
    memSize = 2;
    tempPtr = buffer;
    for (i = 0; i < max; i++) {

        //
        // First step is to find the nearest "number" from the end of the
        // default string
        //
        while (offset > 0) {

            if (ISDIGIT(defaultString[offset-1])) {

                break;

            }
            offset--;

        }

        //
        // Generate the ACPI\\%s string
        //
        swprintf(tempPtr,L"ACPI\\%*S",offset,defaultString);
        tempPtr += (offset + 5);
        *tempPtr = L'\0';
        tempPtr++;
        memSize += (offset + 6);

        //
        // Generate the *%s string
        //
        swprintf(tempPtr,L"*%*S",offset,defaultString);
        tempPtr += (offset + 1);
        *tempPtr = L'\0';
        tempPtr++;
        memSize += (offset + 2);

        //
        // Now try to find the previous space in the substring so that we
        // don't accidently match on a two digit number
        //
        while (offset > 0) {

            if (defaultString[offset-1] == ' ') {

                break;

            }
            offset--;

        }

    }

    //
    // Put in the final null Character
    //
    *tempPtr = L'\0';

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
ACPIGetProcessorIDWideExit:
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = (memSize * sizeof(WCHAR));

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetProcessorStatus(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  ULONG               Flags,
    OUT PULONG              DeviceStatus
    )
/*++

Routine Description:

    This routine looks at the MAPIC table, finds the proper LOCAL APIC
    table and determines wether or not the processor is present. This
    routine is only called if there is no _STA method for the processor.

Arguments:

    DeviceExtension - The device asking for the address
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PAPICTABLE          apicEntry;
    PMAPIC              apicTable;
    PPROCLOCALAPIC      localApic;
    PPROCLOCALSAPIC     localSapic;
    PROCESSOROBJ        *procObj;
    PUCHAR              traversePtr;
    ULONG               deviceStatus = STA_STATUS_DEFAULT;
    ULONG_PTR           tableEnd;
    USHORT              entryFlags;
    BOOLEAN             foundMatch = FALSE;
    static UCHAR        processorCount;
    static UCHAR        processorId;

    //
    // Look at the device extension's acpi object and make sure that
    // this is a processor...
    //
    ASSERT( DeviceExtension->AcpiObject != NULL );
    ASSERT( NSGETOBJTYPE(DeviceExtension->AcpiObject) == OBJTYPE_PROCESSOR );
    if (!DeviceExtension->AcpiObject ||
        NSGETOBJTYPE(DeviceExtension->AcpiObject) != OBJTYPE_PROCESSOR ||
        DeviceExtension->AcpiObject->ObjData.pbDataBuff == NULL) {

        //
        // The effect of this code is that the ACPI Namespace's Processor
        // Object is 100% formed like we would expect it to be, then this
        // function will fail, and the calling function all assume that the
        // device is *NOT* present.
        //
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto ACPIGetProcessorStatusExit;

    }

    //
    // Store the pointer to the processor information
    //
    procObj = (PROCESSOROBJ *)DeviceExtension->AcpiObject->ObjData.pbDataBuff;

    //
    // Walk the MAPIC table
    //
    apicTable = AcpiInformation->MultipleApicTable;
    if (!apicTable) {

        //
        // If there is no MAPIC, then we assume there is only one processor
        // present.
        //

        //
        // First time through, we save the ProcessorId of the processor,
        // this is the only processor that we consider present from this
        // point forward.  NOTE: this could be problematic with table unloading
        // if there are multiple processors defined in the Acpi Namespace, and
        // the one we picked is in a table we later unload.
        //

        if (processorCount == 0) {
          processorId = procObj->bApicID;
          processorCount++;
        }


        if (processorId != procObj->bApicID) {
          deviceStatus = 0;
        }


        goto ACPIGetProcessorStatusExit;

    }

    //
    // Walk all the elements in the MAPIC table
    //
    traversePtr = (PUCHAR) apicTable->APICTables;
    tableEnd = (ULONG_PTR) apicTable + apicTable->Header.Length;
    while ( (ULONG_PTR) traversePtr < tableEnd) {

        //
        // Look at the current entry in the table and determine if its
        // a local processor APIC
        //
        apicEntry = (PAPICTABLE) traversePtr;
        if (apicEntry->Type == PROCESSOR_LOCAL_APIC &&
            apicEntry->Length == PROCESSOR_LOCAL_APIC_LENGTH) {


            //
            // At this point, we have found a processor local APIC, so
            // see if we can match the processor ID with the one in the
            // device extension
            //
            localApic = (PPROCLOCALAPIC) traversePtr;
            if (localApic->ACPIProcessorID != procObj->bApicID) {

                traversePtr += localApic->Length;
                continue;

            }

            //
            // Found matching Local APIC entry
            //
            foundMatch = TRUE;

            //
            // Is the processor enabled or not?
            //
            if (!(localApic->Flags & PLAF_ENABLED)) {

                //
                // No, then don't pretend that the device is here...
                //
                deviceStatus = 0;

            }

            //
            // If we found the correct APIC table, then there is nothing more
            // todo, so stop walking the MAPIC table...
            //
            break;

        }

        if (apicEntry->Type == LOCAL_SAPIC &&
            apicEntry->Length == PROCESSOR_LOCAL_SAPIC_LENGTH) {

            //
            // At this point, we have found a processor local SAPIC, so
            // see if we can match the processor ID with the one in the
            // device extension
            //
            localSapic = (PPROCLOCALSAPIC) traversePtr;
            if (localSapic->ACPIProcessorID != procObj->bApicID) {

                traversePtr += localSapic->Length;
                continue;

            }

            //
            // Found matching Local SAPIC entry
            //
            foundMatch = TRUE;

            //
            // Is the processor enabled or not?
            //
            if (!(localSapic->Flags & PLAF_ENABLED)) {

                //
                // No, then don't pretend that the device is here...
                //
                deviceStatus = 0;

            }

            //
            // If we found the correct APIC table, then there is nothing more
            // todo, so stop walking the MAPIC table...
            //
            break;

        }

        //
        // Sanity check to make sure that we abort tables with bogus length
        // entries
        //
        if (apicEntry->Length == 0) {

            break;

        }
        traversePtr += apicEntry->Length;
        continue;

    }

    //
    // if we didn't find a match, then processor must not be present
    //
    if (!foundMatch) {
      deviceStatus = 0;
    }


ACPIGetProcessorStatusExit:

    //
    // Set the value for the status
    //
    *DeviceStatus = deviceStatus;

    //
    // We are done ... return whatever status we calculated...
    //
    return status;
}

VOID
EXPORT
ACPIGetWorkerForBuffer(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    Result,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called to process the request to turn the result object
    into a buffer that can be handled by the requestor

Arguments:

    AcpiObject  - The AcpiObject that was executed
    Status      - The status result of the operation
    Result      - The data returned by the operation
    Context     - PACPI_GET_REQUEST

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             freeData = TRUE;
    KIRQL               oldIrql;
    NTSTATUS            status = Status;
    PACPI_GET_REQUEST   request = (PACPI_GET_REQUEST) Context;
    PUCHAR              buffer;

    //
    // If we didn't succeed, then do nothing here
    //
    if (!NT_SUCCESS(status)) {

        freeData = FALSE;
        goto ACPIGetWorkerForBufferExit;

    }

    //
    // Check to see that we got the correct data type
    //
    if ( Result->dwDataType != OBJTYPE_BUFFDATA ) {

        //
        // On this kind of error, we have to determine wether or not
        // to bugcheck
        //
        if ( (request->Flags & GET_PROP_NO_ERRORS) ) {

            ACPIInternalError( ACPI_GET );

        }

        status = STATUS_ACPI_INVALID_DATA;
        goto ACPIGetWorkerForBufferExit;

    }

    if ( !(Result->dwDataLen) ) {

        status = STATUS_ACPI_INVALID_DATA;
        goto ACPIGetWorkerForBufferExit;

    }

    //
    // Allocate a buffer
    //
    buffer = ExAllocatePoolWithTag(
        ( (request->Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        Result->dwDataLen,
        ACPI_BUFFER_POOLTAG
        );
    if (buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIGetWorkerForBufferExit;

    }

    //
    // Copy the data over to it
    //
    RtlCopyMemory( buffer, Result->pbDataBuff, Result->dwDataLen );

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    if (request->Buffer != NULL) {

        *(request->Buffer) = buffer;
        if (request->BufferSize != NULL) {

            *(request->BufferSize) = Result->dwDataLen;

        }

    }

ACPIGetWorkerForBufferExit:
    //
    // Make sure that the request is updated with the current state of
    // the request
    //
    request->Status = status;

    //
    // We need to free the AML object
    //
    if (freeData) {

        AMLIFreeDataBuffs( Result, 1 );

    }

    //
    // We are done, but we must check to see if we are the async or the
    // sync case. If we are the sync case, then we have much less cleanup
    // to perform
    //
    if ( !(request->Flags & GET_PROP_SKIP_CALLBACK) ) {

        //
        // Is there a callback routine to call?
        //
        if (request->CallBackRoutine != NULL) {

            (request->CallBackRoutine)(
                AcpiObject,
                status,
                NULL,
                request->CallBackContext
                );

        }

        //
        // Remove the request from the queue
        //
        KeAcquireSpinLock( &AcpiGetLock, &oldIrql );
        RemoveEntryList( &(request->ListEntry) );
        KeReleaseSpinLock( &AcpiGetLock, oldIrql );

        //
        // We can now free the request itself
        //
        ExFreePool( request );

    }

}

VOID
EXPORT
ACPIGetWorkerForData(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    Result,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called when the originator wants to handle the data
    directly. This is actually a pretty bad thing for the originator
    to do, but we must support some of the older code.

    This routine plays some tricks because it 'knows' what the behaviour
    of the GetSync and GetAsync routines are. Don't try this at home

Arguments:

    AcpiObject  - The AcpiObject that was executed
    Status      - The status result of the operation
    Result      - The data returned by the operation
    Context     - PACPI_GET_REQUEST

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             freeData = TRUE;
    KIRQL               oldIrql;
    NTSTATUS            status = Status;
    PACPI_GET_REQUEST   request = (PACPI_GET_REQUEST) Context;

    //
    // If we didn't succeed, then remember not to free the data
    //
    if (!NT_SUCCESS(status)) {

        freeData = FALSE;

    }

    //
    // For this one routine, the caller *must* provide storage on his end
    //
    ASSERT( request->Buffer != NULL );
    if (request->Buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If we didn't succeed, then do nothing here
    //
    if (!NT_SUCCESS(status)) {

        goto ACPIGetWorkerForDataExit;
    }

    //
    // Copy over the object --- the caller will call 'AmliFreeDataBuffs'
    // on this object
    //
    RtlCopyMemory( request->Buffer, Result, sizeof(OBJDATA) );

    //
    // Play some tricks on the result pointer. This will ensure that we
    // won't accidently free the result before the requestor has a chance
    // to see it
    //
    RtlZeroMemory( Result, sizeof(OBJDATA) );

    //
    // Remember not to free the data
    //
    freeData = FALSE;

ACPIGetWorkerForDataExit:
    //
    // Make sure that the request is updated with the current state of
    // the request
    //
    request->Status = status;

    //
    // We need to free the AML object
    //
    if (freeData) {

        AMLIFreeDataBuffs( Result, 1 );

    }

    //
    // We are done, but we must check to see if we are the async or the
    // sync case. If we are the sync case, then we have much less cleanup
    // to perform
    //
    if ( !(request->Flags & GET_PROP_SKIP_CALLBACK) ) {

        //
        // Is there a callback routine to call?
        //
        if (request->CallBackRoutine != NULL) {

            (request->CallBackRoutine)(
                AcpiObject,
                status,
                NULL,
                request->CallBackContext
                );

        }

        //
        // Remove the request from the queue
        //
        KeAcquireSpinLock( &AcpiGetLock, &oldIrql );
        RemoveEntryList( &(request->ListEntry) );
        KeReleaseSpinLock( &AcpiGetLock, oldIrql );

        //
        // We can now free the request itself
        //
        ExFreePool( request );

    }

}

VOID
EXPORT
ACPIGetWorkerForInteger(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    Result,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called when the originator wants to handle the integers.

Arguments:

    AcpiObject  - The AcpiObject that was executed
    Status      - The status result of the operation
    Result      - The data returned by the operation
    Context     - PACPI_GET_REQUEST

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             freeData = FALSE;
    KIRQL               oldIrql;
    NTSTATUS            status = Status;
    PACPI_GET_REQUEST   request = (PACPI_GET_REQUEST) Context;
    PULONG              buffer = NULL;

    //
    // If the call did succeed, then remember that we *must* free the data
    //
    if (NT_SUCCESS(status)) {

        freeData = TRUE;

    }

    //
    // For this one routine, the caller *must* provide storage on his end
    //
    ASSERT( request->Buffer != NULL );
    if (request->Buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIGetWorkerForIntegerExit;
    }

    //
    // Are we doing some kind of type conversion? Note that these routines may
    // choose to override an incoming failure...
    //
    if (request->Flags & GET_CONVERT_TO_ADDRESS) {

        status = ACPIGetConvertToAddress(
            request->DeviceExtension,
            Status,
            Result,
            request->Flags,
            request->Buffer,
            request->BufferSize
            );

    } else if (request->Flags & GET_CONVERT_TO_DEVICE_PRESENCE) {

        status = ACPIGetConvertToDevicePresence(
            request->DeviceExtension,
            Status,
            Result,
            request->Flags,
            request->Buffer,
            request->BufferSize
            );

    } else if (NT_SUCCESS(status)) {

        if ((request->Flags & GET_CONVERT_VALIDATE_INTEGER) &&
            (Result->dwDataType != OBJTYPE_INTDATA)) {

            status = STATUS_ACPI_INVALID_DATA;

        } else {

            //
            // Set the value to what we should return
            //
            *( (PULONG) (request->Buffer) ) = (ULONG)Result->uipDataValue;
            if (request->BufferSize != NULL) {

                *(request->BufferSize) = sizeof(ULONG);

            }
            status = STATUS_SUCCESS;
        }
    }

ACPIGetWorkerForIntegerExit:
    //
    // Make sure that the request is updated with the current state of
    // the request
    //
    request->Status = status;

    //
    // We need to free the AML object
    //
    if (freeData) {

        AMLIFreeDataBuffs( Result, 1 );

    }

    //
    // We are done, but we must check to see if we are the async or the
    // sync case. If we are the sync case, then we have much less cleanup
    // to perform
    //
    if ( !(request->Flags & GET_PROP_SKIP_CALLBACK) ) {

        //
        // Is there a callback routine to call?
        //
        if (request->CallBackRoutine != NULL) {

            (request->CallBackRoutine)(
                AcpiObject,
                status,
                NULL,
                request->CallBackContext
                );

        }

        //
        // Remove the request from the queue
        //
        KeAcquireSpinLock( &AcpiGetLock, &oldIrql );
        RemoveEntryList( &(request->ListEntry) );
        KeReleaseSpinLock( &AcpiGetLock, oldIrql );

        //
        // We can now free the request itself
        //
        ExFreePool( request );

    }

}

VOID
EXPORT
ACPIGetWorkerForNothing(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    Result,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called when the originator wants to handle the case
    where no data is returned

Arguments:

    AcpiObject  - The AcpiObject that was executed
    Status      - The status result of the operation
    Result      - The data returned by the operation
    Context     - PACPI_GET_REQUEST

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             freeData = FALSE;
    KIRQL               oldIrql;
    PACPI_GET_REQUEST   request = (PACPI_GET_REQUEST) Context;

    //
    // If the call did succeed, then remember that we *must* free the data
    //
    if (NT_SUCCESS(Status)) {

        freeData = TRUE;

    }

    //
    // Make sure that the request is updated with the current state of
    // the request
    //
    request->Status = Status;

    //
    // We need to free the AML object
    //
    if (freeData) {

        AMLIFreeDataBuffs( Result, 1 );

    }

    //
    // We are done, but we must check to see if we are the async or the
    // sync case. If we are the sync case, then we have much less cleanup
    // to perform
    //
    if ( !(request->Flags & GET_PROP_SKIP_CALLBACK) ) {

        //
        // Is there a callback routine to call?
        //
        if (request->CallBackRoutine != NULL) {

            (request->CallBackRoutine)(
                AcpiObject,
                Status,
                NULL,
                request->CallBackContext
                );

        }

        //
        // Remove the request from the queue
        //
        KeAcquireSpinLock( &AcpiGetLock, &oldIrql );
        RemoveEntryList( &(request->ListEntry) );
        KeReleaseSpinLock( &AcpiGetLock, oldIrql );

        //
        // We can now free the request itself
        //
        ExFreePool( request );

    }
}

VOID
EXPORT
ACPIGetWorkerForString(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    Result,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called when the originator wants to handle the strings.

Arguments:

    AcpiObject  - The AcpiObject that was executed
    Status      - The status result of the operation
    Result      - The data returned by the operation
    Context     - PACPI_GET_REQUEST

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             freeData = FALSE;
    KIRQL               oldIrql;
    NTSTATUS            status = Status;
    PACPI_GET_REQUEST   request = (PACPI_GET_REQUEST) Context;

    //
    // If the call did succeed, then remember that we *must* free the data
    //
    if (NT_SUCCESS(status)) {
        freeData = TRUE;
    }

    //
    // For this one routine, the caller *must* provide storage on his end
    //
    ASSERT( request->Buffer != NULL );
    if (request->Buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIGetWorkerForStringExit;

    }

    //
    // Make sure that we don't allocate empty storage
    //
    if (Result->dwDataType == OBJTYPE_STRDATA &&
        (Result->pbDataBuff == NULL || Result->dwDataLen == 0)) {

        status = STATUS_ACPI_INVALID_DATA;
        goto ACPIGetWorkerForStringExit;

    }

    //
    // Do do we want unicode or ansi output?
    //
    if (request->Flags & GET_CONVERT_TO_WIDESTRING) {

        //
        // Are we doing some other kind of conversion? Eg: DeviceID,
        // InstanceIDs, etc, etc?
        //
        if (request->Flags & GET_CONVERT_TO_DEVICEID) {

            status = ACPIGetConvertToDeviceIDWide(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_HARDWAREID) {

            status = ACPIGetConvertToHardwareIDWide(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_INSTANCEID) {

            status = ACPIGetConvertToInstanceIDWide(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_PNPID) {

            status = ACPIGetConvertToPnpIDWide(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_COMPATIBLEID) {

            status = ACPIGetConvertToCompatibleIDWide(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_SERIAL_ID) {

            status = ACPIGetConvertToSerialIDWide(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else {

            status = ACPIGetConvertToStringWide(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        }

    } else {

        //
        // Are we doing some other kind of conversion? Eg: DeviceID,
        // InstanceIDs, etc, etc?
        //
        if (request->Flags & GET_CONVERT_TO_DEVICEID) {

            status = ACPIGetConvertToDeviceID(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_HARDWAREID) {

            status = ACPIGetConvertToHardwareID(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_INSTANCEID) {

            status = ACPIGetConvertToInstanceID(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_PNPID) {

            status = ACPIGetConvertToPnpID(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_COMPATIBLEID) {

            status = ACPIGetConvertToCompatibleID(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else {

            status = ACPIGetConvertToString(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        }

    }

ACPIGetWorkerForStringExit:
    //
    // Make sure that the request is updated with the current state of
    // the request
    //
    request->Status = status;

    //
    // We need to free the AML object
    //
    if (freeData) {

        AMLIFreeDataBuffs( Result, 1 );

    }

    //
    // We are done, but we must check to see if we are the async or the
    // sync case. If we are the sync case, then we have much less cleanup
    // to perform
    //
    if ( !(request->Flags & GET_PROP_SKIP_CALLBACK) ) {

        //
        // Is there a callback routine to call?
        //
        if (request->CallBackRoutine != NULL) {

            (request->CallBackRoutine)(
                AcpiObject,
                status,
                NULL,
                request->CallBackContext
                );

        }

        //
        // Remove the request from the queue
        //
        KeAcquireSpinLock( &AcpiGetLock, &oldIrql );
        RemoveEntryList( &(request->ListEntry) );
        KeReleaseSpinLock( &AcpiGetLock, oldIrql );

        //
        // We can now free the request itself
        //
        ExFreePool( request );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\idevice.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    bus.c

Abstract:

    This module contains the bus dispatcher for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIInternalDeviceClockIrpStartDevice)
#pragma alloc_text(PAGE, ACPIInternalDeviceQueryCapabilities)
#pragma alloc_text(PAGE, ACPIInternalDeviceQueryDeviceRelations)
#endif


NTSTATUS
ACPIInternalDeviceClockIrpStartDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This function is called to start the Real-Time Clock in the system. This
    is similar to starting all the other devices in the system, except that
    in this case, we send a WAIT_WAKE irp to the device

Arguments:

    DeviceObject    - The real-time clock object
    Irp             - The start request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;

    PAGED_CODE();

    //
    // Start the device
    //
    status = ACPIInitStartDevice(
        DeviceObject,
        NULL,
        ACPIInternalDeviceClockIrpStartDeviceCompletion,
        Irp,
        Irp
        );
    if (NT_SUCCESS(status)) {

        return STATUS_PENDING;

    } else {

        return status;

    }
}

VOID
ACPIInternalDeviceClockIrpStartDeviceCompletion(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is the callback routine that is invoked when we have finished
    programming the resources

Arguments:

    DeviceExtension - Extension of the device that was started
    Context         - The Irp
    Status          - The Result

Return Value:

    None

--*/
{
    KIRQL               oldIrql;
    IO_STATUS_BLOCK     ioStatus;
    PIRP                irp = (PIRP) Context;
    POWER_STATE         state;

    irp->IoStatus.Status = Status;
    if (NT_SUCCESS(Status)) {

        //
        // Remember that the device is started
        //
        DeviceExtension->DeviceState = Started;

        //
        // If the device doesn't support Wakeup, then we don't have to
        // anything else here
        //
        if ( !(DeviceExtension->Flags & DEV_CAP_WAKE) ) {

            goto ACPIInternalDeviceClockIrpStartDeviceCompletionExit;

        }

        //
        // Make sure that we are holding the power lock
        //
        KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

        //
        // Remember the maximum state that the clock can wake the system
        //
        state.SystemState = DeviceExtension->PowerInfo.SystemWakeLevel;

        //
        // Done with the lock
        //
        KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

        //
        // Initialize the IO_STATUS_BLOCK that we will use to start the wait
        // wake loop
        //
        ioStatus.Status = STATUS_SUCCESS;
        ioStatus.Information = 0;

        //
        // Start the wait wake loop
        //
        Status = ACPIInternalWaitWakeLoop(
            DeviceExtension->DeviceObject,
            IRP_MN_WAIT_WAKE,
            state,
            NULL,
            &ioStatus
            );
        if (!NT_SUCCESS(Status)) {

            irp->IoStatus.Status = Status;
            goto ACPIInternalDeviceClockIrpStartDeviceCompletionExit;

        }

    }

ACPIInternalDeviceClockIrpStartDeviceCompletionExit:
    //
    // Complete the irp
    //
    IoCompleteRequest( irp, IO_NO_INCREMENT );
}

NTSTATUS
ACPIInternalDeviceQueryCapabilities(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_CAPABILITIES requests sent
    to the PDO

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status          = STATUS_SUCCESS;
    PDEVICE_CAPABILITIES    capabilities;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION      irpStack        = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    // Grab a pointer to the capabilities
    //
    capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;
#ifndef HANDLE_BOGUS_CAPS
    if (capabilities->Version < 1) {

        //
        // do not touch irp!
        //
        status = Irp->IoStatus.Status;
        goto ACPIInternalDeviceQueryCapabilitiesExit;

    }
#endif

    //
    // Set the current flags for the capabilities
    //
    capabilities->UniqueID = (deviceExtension->InstanceID == NULL ?
        FALSE : TRUE);

    capabilities->RawDeviceOK = (deviceExtension->Flags & DEV_CAP_RAW) ?
       TRUE : FALSE;

    capabilities->SilentInstall = TRUE;

    //
    // Do the power capabilities
    //
    status = ACPISystemPowerQueryDeviceCapabilities(
        deviceExtension,
        capabilities
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            " - Could query device capabilities - %08lx",
            status
            ) );
        goto ACPIInternalDeviceQueryCapabilitiesExit;

    }

ACPIInternalDeviceQueryCapabilitiesExit:

    //
    // Done...
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}

NTSTATUS
ACPIInternalDeviceQueryDeviceRelations(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_DEVICE_RELATION
    PNP minor function

Arguments:

    DeviceObject    - The object that we care about
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status ;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_RELATIONS   deviceRelations = NULL;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    switch(irpStack->Parameters.QueryDeviceRelations.Type) {

        case TargetDeviceRelation:

            status = ACPIBusIrpQueryTargetRelation(
                DeviceObject,
                Irp,
                &deviceRelations
                );
            break ;

        default:

            status = STATUS_NOT_SUPPORTED;

            ACPIDevPrint( (
                ACPI_PRINT_IRP,
                deviceExtension,
                "(0x%08lx): %s - Unhandled Type %d\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
                irpStack->Parameters.QueryDeviceRelations.Type
                ) );
            break ;
    }

    //
    // If we succeeds, then we can always write to the irp
    //
    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

    } else if (status != STATUS_NOT_SUPPORTED) {

        //
        // If we haven't succeed the irp, then we can also fail it
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) NULL;

    } else {

        //
        // Grab our status from what is already present
        //
        status = Irp->IoStatus.Status;

    }

    //
    // Done with the irp
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIInternalWaitWakeLoop(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This routine is called after the WAIT_WAKE on the RTC has been completed

Arguments:

    DeviceObject    - The RTC PDO
    MinorFunction   - IRP_MN_WAIT_WAKE
    PowerState      - The Sleep state that it could wake from
    Context         - NOT USED
    IoStatus        - The status of the request

Return Value:

    NTSTATUS

--*/
{
    if (!NT_SUCCESS(IoStatus->Status)) {

        return IoStatus->Status;

    }

    //
    // In this case, we just cause the same thing to happen again
    //
    PoRequestPowerIrp(
        DeviceObject,
        MinorFunction,
        PowerState,
        ACPIInternalWaitWakeLoop,
        Context,
        NULL
        );

    //
    // Done
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\init.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    init.h

Abstract:

    This module contains the init code header

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _INIT_H_
    #define _INIT_H_

    VOID
    ACPIInitDeleteChildDeviceList(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    VOID
    ACPIInitDeleteDeviceExtension(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIInitDosDeviceName(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIInitMultiString(
        PUNICODE_STRING MultiString,
        ...
        );

    VOID
    ACPIInitPowerRequestCompletion(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PVOID               Context,
        IN  NTSTATUS            Status
        );

    VOID
    ACPIInitReadRegistryKeys(
        );

    VOID
    ACPIInitRemoveDeviceExtension(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    VOID
    ACPIInitResetDeviceExtension(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIInitStartACPI(
        IN  PDEVICE_OBJECT  DeviceObject
        );

    NTSTATUS
    ACPIInitStartDevice(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PCM_RESOURCE_LIST       ResourceList,
        IN  PACPI_POWER_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIInitStopACPI(
        IN  PDEVICE_OBJECT  DeviceObject
        );

    NTSTATUS
    ACPIInitStopDevice(
        IN  PDEVICE_EXTENSION  DeviceExtension,
        IN  BOOLEAN            UnlockDevice
        );

    NTSTATUS
    ACPIInitUnicodeString(
        PUNICODE_STRING MultiString,
        PCHAR           Buffer
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\interfaces.h ===
#define TRANSLATION_RANGE_SPARSE        0x0001
#define TRANSLATION_DATA_PARENT_ADDRESS 0x6000

#define TRANSLATION_MEM_TO_IO           0x20
#define TRANSLATION_IO_TO_MEM           0x40


typedef struct {
    UCHAR               ParentType;
    UCHAR               ChildType;
    PHYSICAL_ADDRESS    ParentAddress;
    PHYSICAL_ADDRESS    ChildAddress;
    ULONGLONG           Length;
} BRIDGE_WINDOW, *PBRIDGE_WINDOW;

typedef struct {
    PNSOBJ          AcpiObject;
    ULONG           RangeCount;
    PBRIDGE_WINDOW  Ranges;
    PIO_RESOURCE_REQUIREMENTS_LIST  IoList;
} BRIDGE_TRANSLATOR, *PBRIDGE_TRANSLATOR;

NTSTATUS
TranslateEjectInterface(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
TranslateBridgeResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
TranslateBridgeRequirements(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );
    
NTSTATUS
PciBusEjectInterface(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

VOID
AcpiNullReference(
    PVOID Context
    );

    
extern HAL_PORT_RANGE_INTERFACE HalPortRangeInterface;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\idevice.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    idevice.h

Abstract:

    This module contains the bus dispatcher for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _IDEVICE_H_
#define _IDEVICE_H_

    NTSTATUS
    ACPIInternalDeviceClockIrpStartDevice(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PIRP                Irp
        );

    VOID
    ACPIInternalDeviceClockIrpStartDeviceCompletion(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PVOID               Context,
        IN  NTSTATUS            Status
        );

    NTSTATUS
    ACPIInternalDeviceQueryCapabilities(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PIRP                Irp
        );

    NTSTATUS
    ACPIInternalDeviceQueryDeviceRelations(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PIRP                Irp
        );

    NTSTATUS
    ACPIInternalWaitWakeLoop(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  UCHAR               MinorFunction,
        IN  POWER_STATE         PowerState,
        IN  PVOID               Context,
        IN  PIO_STATUS_BLOCK    IoStatus
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\init.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This modules contains the init code

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIInitMultiString)
#pragma alloc_text(PAGE,ACPIInitStopDevice)
#pragma alloc_text(PAGE,ACPIInitUnicodeString)
#endif

VOID
ACPIInitDeleteChildDeviceList(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine looks at all of the children of the current devnode and
    deletes their device objects, basically resetting them to the unenumerated
    state

Arguments:

    DeviceExtension - The extension whose children should go away

Return Value:

    None

--*/
{
    EXTENSIONLIST_ENUMDATA  eled;
    PDEVICE_EXTENSION       childExtension;

    //
    // Setup the list so that we can walk it
    //
    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_REFERENCE_ENTRIES
        );
    for (childExtension = ACPIExtListStartEnum( &eled );
                          ACPIExtListTestElement( &eled, (BOOLEAN) TRUE );
         childExtension = ACPIExtListEnumNext( &eled) ) {

        //
        // Reset the device
        //
        ACPIInitResetDeviceExtension( childExtension );

    }
}

VOID
ACPIInitDeleteDeviceExtension(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine does the cleanup associated with removing a device object

Arguments:

    DeviceExtension

ReturnValue:

    None

--*/
{
    PDEVICE_EXTENSION currentExtension, parentExtension ;

    //
    // We must be under the tree lock.
    //
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL) ; // Close enough...

    //
    // Nobody should care about this node.
    //
    ASSERT(!DeviceExtension->ReferenceCount) ;

    for(currentExtension = DeviceExtension ;
        currentExtension;
        currentExtension = parentExtension) {

        //
        // And there should be no children.
        //
        ASSERT( IsListEmpty( &currentExtension->ChildDeviceList ) );

        //
        // Unlink the dead extension (does nothing if alreeady unlinked)
        //
        RemoveEntryList(&currentExtension->SiblingDeviceList);

        //
        // We also don't want to be part of anyone's ejection list either
        // This also removes the extension from the unresolved list as well
        //
        RemoveEntryList(&currentExtension->EjectDeviceList);

        //
        // If this device had any ejection relations, most all of those
        // unto the unresolved list
        //
        if (!IsListEmpty( &(currentExtension->EjectDeviceHead) ) ) {

            ACPIInternalMoveList(
                &(currentExtension->EjectDeviceHead),
                &AcpiUnresolvedEjectList
                );

        }

        //
        // At this point, we need to check if the ACPI namespace
        // object associated with it is also going away
        //
        if (currentExtension->Flags & DEV_PROP_UNLOADING) {

            //
            // Let the world know
            //
            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                currentExtension,
                "- tell Interperter to unload %x\n",
                currentExtension->AcpiObject
                ) );
            AMLIDestroyFreedObjs( currentExtension->AcpiObject );

        }


        //
        // Free the common resources
        //
        if ( (currentExtension->Flags & DEV_PROP_HID) &&
            currentExtension->DeviceID != NULL) {

            ExFreePool( currentExtension->DeviceID );

        }

        if ( (currentExtension->Flags & DEV_PROP_UID) &&
            currentExtension->InstanceID != NULL) {

            ExFreePool( currentExtension->InstanceID );

        }

        if (currentExtension->ResourceList != NULL) {

            ExFreePool( currentExtension->ResourceList );

        }

        if (currentExtension->PnpResourceList != NULL) {

            ExFreePool( currentExtension->PnpResourceList );

        }

        if (currentExtension->Flags & DEV_PROP_FIXED_CID &&
            currentExtension->Processor.CompatibleID != NULL) {

            ExFreePool( currentExtension->Processor.CompatibleID );

        }

        //
        // Free any device-specific allocations we might have made
        //
        if (currentExtension->Flags & DEV_CAP_THERMAL_ZONE &&
            currentExtension->Thermal.Info != NULL) {

            ExFreePool( currentExtension->Thermal.Info );

        }

        //
        // Remember the parent's device extension
        //
        parentExtension = currentExtension->ParentExtension;

        //
        // Free the extension back to the proper place
        //
        ExFreeToNPagedLookasideList(
            &DeviceExtensionLookAsideList,
            currentExtension
            );

        //
        // Sanity check
        //
        if (parentExtension == NULL) {

            break;

        }
        if (InterlockedDecrement(&parentExtension->ReferenceCount)) {

            //
            // Parent still has a reference count, bail out.
            //
            break;
        }
    }

    return;
}

NTSTATUS
ACPIInitDosDeviceName(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    If this device has a _DDN method, it is evaluated and the result is
    stored within the Device Registry Key

    N.B. This routine must be called at Passive level

Arguments:

    DeviceExtension - The extension that we wish to find a _DDN for

Return Value:

    NTSTATUS

--*/
{
    ANSI_STRING     ansiString;
    HANDLE          devHandle;
    NTSTATUS        status;
    OBJDATA         objData;
    PNSOBJ          ddnObject;
    PWSTR           fixString  = L"FirmwareIdentified";
    PWSTR           pathString = L"DosDeviceName";
    ULONG           fixValue = 1;
    UNICODE_STRING  unicodeString;
    UNICODE_STRING  ddnString;

    //
    // Initialize the unicode string
    //
    RtlInitUnicodeString( &unicodeString, fixString);

    //
    // Open the handle that we need
    //
    status = IoOpenDeviceRegistryKey(
        DeviceExtension->PhysicalDeviceObject,
        PLUGPLAY_REGKEY_DEVICE,
        STANDARD_RIGHTS_WRITE,
        &devHandle
        );
    if (!NT_SUCCESS(status)) {

        //
        // Let the world know. But return success anyways
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIInitDosDeviceName - open failed %08lx\n",
            status
            ) );
        return STATUS_SUCCESS;

    }

    //
    // Try to set the value
    //
    status = ZwSetValueKey(
        devHandle,
        &unicodeString,
        0,
        REG_DWORD,
        &fixValue,
        sizeof(fixValue)
        );

    //
    // Initialize the unicode string
    //
    RtlInitUnicodeString( &unicodeString, pathString);

    //
    // Lets look for the _DDN
    //
    ddnObject = ACPIAmliGetNamedChild(
        DeviceExtension->AcpiObject,
        PACKED_DDN
        );
    if (ddnObject == NULL) {

        ZwClose( devHandle );
        return STATUS_SUCCESS;

    }

    //
    // Evaluate the method
    //
    status = AMLIEvalNameSpaceObject(
        ddnObject,
        &objData,
        0,
        NULL
        );
    if (!NT_SUCCESS(status)) {

        //
        // Let the world know. But return success anyways
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIInitDosDeviceName - eval returns %08lx\n",
            status
            ) );
        ZwClose( devHandle );
        return STATUS_SUCCESS;

    }
    if (objData.dwDataType != OBJTYPE_STRDATA) {

        //
        // Let the world know. But return success anyways
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIInitDosDeviceName - eval returns wrong type %d\n",
            objData.dwDataType
            ) );
        AMLIFreeDataBuffs( &objData, 1 );
        ZwClose( devHandle );
        return STATUS_SUCCESS;

    }

    //
    // Convert the string to an ansi string
    //
    RtlInitAnsiString( &ansiString, objData.pbDataBuff );
    status = RtlAnsiStringToUnicodeString(
        &ddnString,
        &ansiString,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIInitDosDeviceName - cannot convert to unicode string %x\n",
            status
            ) );
        AMLIFreeDataBuffs( &objData, 1 );
        ZwClose( devHandle );
        return status;

    }

    //
    // Try to set the value
    //
    status = ZwSetValueKey(
        devHandle,
        &unicodeString,
        0,
        REG_SZ,
        ddnString.Buffer,
        ddnString.Length
        );

    //
    // No longer need the object data and the handle
    //
    AMLIFreeDataBuffs( &objData, 1 );
    ZwClose( devHandle );

    //
    // What happened
    //
    if (!NT_SUCCESS(status)) {

        //
        // Let the world know. But return success anyways
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIInitDosDeviceName - set failed %08lx\n",
            status
            ) );

    }
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIInitMultiString(
    PUNICODE_STRING MultiString,
    ...
    )
/*++

Routine Description:

    This routine will take a null terminated list of ascii strings and combine
    them together to generate a unicode multi-string block

Arguments:

    MultiString - a unicode structure in which a multi-string will be built
    ...         - a null terminated list of narrow strings which will be combined
                  together. This list must contain at least a trailing NULL

Return Value:

    NTSTATUS

--*/
{
    ANSI_STRING     ansiString;
    NTSTATUS        status;
    PCSTR           rawString;
    PWSTR           unicodeLocation;
    ULONG           multiLength = 0;
    UNICODE_STRING  unicodeString;
    va_list         ap;

    PAGED_CODE();

    va_start(ap,MultiString);

    //
    // Make sure that we won't memory leak
    //
    ASSERT(MultiString->Buffer == NULL);

    rawString = va_arg(ap, PCSTR);
    while (rawString != NULL) {

        RtlInitAnsiString(&ansiString, rawString);
        multiLength += RtlAnsiStringToUnicodeSize(&(ansiString));
        rawString = va_arg(ap, PCSTR);

    } // while
    va_end( ap );

    if (multiLength == 0) {

        //
        // Done
        //
        RtlInitUnicodeString( MultiString, NULL );
        return STATUS_SUCCESS;

    }

    //
    // We need an extra null
    //
    multiLength += sizeof(WCHAR);
    MultiString->MaximumLength = (USHORT) multiLength;
    MultiString->Buffer = ExAllocatePoolWithTag(
        PagedPool,
        multiLength,
        ACPI_STRING_POOLTAG
        );
    if (MultiString->Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory(MultiString->Buffer, multiLength);

    unicodeString.Buffer = MultiString->Buffer;
    unicodeString.MaximumLength = (USHORT) multiLength;

    va_start( ap, MultiString);
    rawString = va_arg(ap, PCSTR);
    while (rawString != NULL) {

        RtlInitAnsiString(&ansiString,rawString);
        status = RtlAnsiStringToUnicodeString(
            &unicodeString,
            &ansiString,
            FALSE
            );

        //
        // We don't allocate memory, so if something goes wrong here,
        // its the function thats at fault
        //
        ASSERT( NT_SUCCESS(status) );

        //
        // Move the buffers along
        //
        unicodeString.Buffer += ( (unicodeString.Length/sizeof(WCHAR)) + 1);
        unicodeString.MaximumLength -= (unicodeString.Length + sizeof(WCHAR));
        unicodeString.Length = 0;

        //
        // Next
        //
        rawString = va_arg(ap, PCSTR);

    } // while
    va_end(ap);

    ASSERT(unicodeString.MaximumLength == sizeof(WCHAR));

    //
    // Stick the final null there
    //
    unicodeString.Buffer[0] = L'\0';
    MultiString->Length = MultiString->MaximumLength;

    return STATUS_SUCCESS;
}

VOID
ACPIInitPowerRequestCompletion(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This function is called when the PowerRequest from a StartDevice
    or a StopDevice has completed

Arguments:

    DeviceExtension - The DeviceExtension of the completed device
    Context         - KEVENT
    Status          - The result of the operation

Return Value:

    VOID

--*/
{
    PKEVENT event = (PKEVENT) Context;

    //
    // Set the event
    //
    KeSetEvent( event, IO_NO_INCREMENT, FALSE );

}

VOID
ACPIInitReadRegistryKeys(
    )
/*++

Routine Description:

    This routine is called by DriverEntry to read all the information
    from the registry that is global to the life of the driver

Arguments:

    None

Return Value:

    None

--*/
{
    HANDLE      processorKey = NULL;
    NTSTATUS    status;
    PUCHAR      identifierString = NULL;
    PUCHAR      processorString = NULL;
    PUCHAR      steppingString = NULL;
    PUCHAR      idString = NULL;
    ULONG       argSize;
    ULONG       baseSize;
    ULONG       identifierStringSize;
    ULONG       processorStringSize;

    //
    // Read the Override Attribute from the registry
    //
    argSize = sizeof(AcpiOverrideAttributes);
    status = OSReadRegValue(
        "Attributes",
        (HANDLE) NULL,
        &AcpiOverrideAttributes,
        &argSize
        );
    if (!NT_SUCCESS(status)) {

        AcpiOverrideAttributes = 0;

    }

    //
    // Make sure that we initialize the Processor String...
    //
    RtlZeroMemory( &AcpiProcessorString, sizeof(ANSI_STRING) );

    //
    // Open the Processor Handle
    //
    status = OSOpenHandle(
        ACPI_PROCESSOR_INFORMATION_KEY,
        NULL,
        &processorKey
        );
    if ( !NT_SUCCESS(status) ) {

        ACPIPrint ((
            ACPI_PRINT_FAILURE,
            "ACPIInitReadRegistryKeys: failed to open Processor Key (rc=%x)\n",
            status));
        return;

    }

    //
    // Default guess as to how many bytes we need for the processor string
    //
    baseSize = 40;

    //
    // Try to read the processor ID string
    //
    do {

        //
        // If we had allocated memory, then free it
        //
        if (processorString != NULL) {

            ExFreePool( processorString );

        }

        //
        // Allocate the amount of memory we think we need
        //
        processorString = ExAllocatePoolWithTag(
            PagedPool,
            baseSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (!processorString) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ACPIInitReadRegistryKeysExit;

        }
        RtlZeroMemory( processorString, baseSize * sizeof(UCHAR) );

        //
        // Update the amount we think we would need for next time
        //
        argSize = baseSize * sizeof(UCHAR);
        baseSize += 10;

        //
        // Try to read the key
        //
        status = OSReadRegValue(
            "Identifier",
            processorKey,
            processorString,
            &argSize
            );

    } while ( status == STATUS_BUFFER_OVERFLOW );

    //
    // Did we get the identifier?
    //
    if (!NT_SUCCESS( status )) {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIInitReadRegistryKeys: failed to read Identifier Value (rc=%x)\n",
            status
            ) );
        goto ACPIInitReadRegistryKeysExit;

    }

    //
    // Remove Stepping information from the identifier string.
    //
    steppingString = strstr(processorString, ACPI_PROCESSOR_STEPPING_IDENTIFIER);

    if (steppingString) {
      steppingString[-1] = 0;
    }

    //
    // Remember how many bytes are in the processorString
    //
    processorStringSize = strlen(processorString) + 1;

    //
    // Reset our guess for how many bytes we will need for the identifier
    //
    baseSize = 10;

    //
    // Try to read the vendor processor ID string
    //
    do {

        //
        // If we had allocated memory, then free it
        //
        if (identifierString != NULL) {

            ExFreePool( identifierString );

        }

        //
        // Allocate the amount of memory we think we need
        //
        identifierString = ExAllocatePoolWithTag(
            PagedPool,
            baseSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (!identifierString) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ACPIInitReadRegistryKeysExit;

        }
        RtlZeroMemory( identifierString, baseSize * sizeof(UCHAR) );

        //
        // Update the amount we think we would need for next time
        //
        argSize = baseSize * sizeof(UCHAR);
        baseSize += 10;

        //
        // Try to read the key
        //
        status = OSReadRegValue(
            "VendorIdentifier",
            processorKey,
            identifierString,
            &argSize
            );

    } while ( status == STATUS_BUFFER_OVERFLOW );

    //
    // Did we get the identifier?
    //
    if (!NT_SUCCESS( status )) {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIInitReadRegistryKeys: failed to read Vendor Value (rc=%x)\n",
            status
            ) );
        goto ACPIInitReadRegistryKeysExit;

    }

    //
    // Remember how many bytes are in the processorString
    //
    identifierStringSize = argSize;

    //
    // At this point, we can calculate how many bytes we will need for the
    // total string. Since the total string is the concatenatation of
    // identifierString + " - " + processorString, we just add 2 to the
    // sum of the both string sizes (since both sizes include the NULL
    // terminator at the end...
    //
    baseSize = 2 + identifierStringSize + processorStringSize;

    //
    // Allocate this memory. In the future, we will (probably) need to
    // touch this string at DPC level, so it must be fron Non-Paged-Pool
    //
    idString = ExAllocatePoolWithTag(
        NonPagedPool,
        baseSize * sizeof(UCHAR),
        ACPI_STRING_POOLTAG
        );
    if (!idString) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIInitReadRegistryKeysExit;

    }

    //
    // Generate the string
    //
    sprintf( idString, "%s - %s", identifierString, processorString );

    //
    // Remember the string for the future
    //
    AcpiProcessorString.Buffer = idString,
    AcpiProcessorString.Length = AcpiProcessorString.MaximumLength = (USHORT) baseSize;

    //
    // Clean up time
    //
ACPIInitReadRegistryKeysExit:
    if (processorKey) {

        OSCloseHandle(processorKey);

    }

    if (identifierString) {

        ExFreePool(identifierString);

    }
    if (processorString) {

        ExFreePool(processorString);

    }
}

VOID
ACPIInitRemoveDeviceExtension(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine removes the device extension the ACPI namespace tree add
    adds it to the list of surprised removed extensions (which is kept for
    debugging purposes only)

    This routine is called with the ACPI device tree lock owned

Arguments:

    DeviceExtension - the device to remove from the tree

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION currentExtension, parentExtension;

    //
    // We must be under the tree lock.
    //
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL) ; // Close enough...

    //
    // Unlink the dead extension (does nothing if alreeady unlinked)
    //
    RemoveEntryList(&DeviceExtension->SiblingDeviceList);

    //
    // We also don't want to be part of anyone's ejection list either.
    // This removes the device extension from the unresolved list as well...
    //
    RemoveEntryList(&DeviceExtension->EjectDeviceList);

    //
    // If this device has ejection relations, then move all of them
    // to the unresolved list
    //
    if (!IsListEmpty( &(DeviceExtension->EjectDeviceHead) ) ) {

        ACPIInternalMoveList(
            &(DeviceExtension->EjectDeviceHead),
            &AcpiUnresolvedEjectList
            );

    }

    //
    // We no longer have any parents
    //
    parentExtension = DeviceExtension->ParentExtension ;
    DeviceExtension->ParentExtension = NULL;

    //
    // Remember that we removed this extension...
    //
    AcpiSurpriseRemovedDeviceExtensions[AcpiSurpriseRemovedIndex] =
        DeviceExtension;
    AcpiSurpriseRemovedIndex = (AcpiSurpriseRemovedIndex + 1) %
        ACPI_MAX_REMOVED_EXTENSIONS;

    //
    // Now, we have to look at the parent and decrement its ref count
    // as is appropriate --- crawling up the tree and decrementing ref
    // counts as we go
    //
    for(currentExtension = parentExtension;
        currentExtension;
        currentExtension = parentExtension) {

        //
        // Decrement the reference on the current extension...
        // We have to do this because we previously unlinked one of its
        // children
        //
        if (InterlockedDecrement(&currentExtension->ReferenceCount)) {

            //
            // Parent still has a reference count, bail out.
            //
            break;

        }

        //
        // Get the parent
        //
        parentExtension = currentExtension->ParentExtension ;

        //
        // Remember that we removed this extension...
        //
        AcpiSurpriseRemovedDeviceExtensions[AcpiSurpriseRemovedIndex] =
            currentExtension;
        AcpiSurpriseRemovedIndex = (AcpiSurpriseRemovedIndex + 1) %
            ACPI_MAX_REMOVED_EXTENSIONS;

        //
        // We don't actually expect the device's ref count to drop to
        // zero, but if it does, then we must delete the extension
        //
        ACPIInitDeleteDeviceExtension( currentExtension );

    }

}

VOID
ACPIInitResetDeviceExtension(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    Clear up a device extension

Arguments:

    DeviceExtension - The extension we wish to reset

Return Value:

    None

--*/
{
    KIRQL               oldIrql;
    LONG                oldReferenceCount;
    PCM_RESOURCE_LIST   cmResourceList;
    PDEVICE_OBJECT      deviceObject = NULL;
    PDEVICE_OBJECT      targetObject = NULL;

    //
    // We require the spinlock for parts of this
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Clean up those parts that are associated with us being a filter
    //
    if (DeviceExtension->Flags & DEV_TYPE_FILTER) {

        if (DeviceExtension->Flags & DEV_TYPE_PDO) {

            //
            // If we are a PDO, then we need to release the reference we took on
            // TargetDeviceObject in Buildsrc.c
            //
            if (DeviceExtension->TargetDeviceObject) {

                ObDereferenceObject(DeviceExtension->TargetDeviceObject) ;

            }

        } else {

            //
            // If we are a Filter, then we need to remember to detach ourselves
            // from the device
            //
            targetObject = DeviceExtension->TargetDeviceObject;

        }

    }

    //
    // Step one is to zero out the things that we no longer care about
    //
    if (DeviceExtension->PnpResourceList != NULL) {

        ExFreePool( DeviceExtension->PnpResourceList );
        DeviceExtension->PnpResourceList = NULL;

    }
    cmResourceList = DeviceExtension->ResourceList;
    if (DeviceExtension->ResourceList != NULL) {

        DeviceExtension->ResourceList = NULL;

    }
    deviceObject = DeviceExtension->DeviceObject;
    if (deviceObject != NULL) {

        deviceObject->DeviceExtension = NULL;
        DeviceExtension->DeviceObject = NULL;

        //
        // The reference count should have value > 0
        //
        oldReferenceCount = InterlockedDecrement(
            &(DeviceExtension->ReferenceCount)
            );
        ASSERT(oldReferenceCount >= 0) ;
        if ( oldReferenceCount == 0) {

            //
            // Delete the extension
            //
            ACPIInitDeleteDeviceExtension( DeviceExtension );
            goto ACPIInitResetDeviceExtensionExit;

        }

    }

    //
    // If we got to this point, we aren't deleting the device extension
    //
    DeviceExtension->TargetDeviceObject = NULL;
    DeviceExtension->PhysicalDeviceObject = NULL;

    //
    // Mark the node as being fresh and untouched. Only do this if the device
    // isn't marked as NEVER_PRESENT. If its never present, we will just trust
    // the device to contain the correct information.
    //
    if (!(DeviceExtension->Flags & DEV_TYPE_NEVER_PRESENT)) {

        ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_MASK_TYPE, TRUE );
        ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_TYPE_NOT_FOUND, FALSE );
        ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_TYPE_REMOVED, FALSE );

    }

ACPIInitResetDeviceExtensionExit:
    //
    // Done with the spinlock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Now we can do the things we need to do at passive level
    //
    if (cmResourceList != NULL) {

        ExFreePool( cmResourceList );

    }
    if (targetObject != NULL) {

        IoDetachDevice( targetObject );

    }
    if (deviceObject != NULL) {

        IoDeleteDevice( deviceObject );

    }

}

NTSTATUS
ACPIInitStartACPI(
    IN  PDEVICE_OBJECT  DeviceObject
    )
/*++

Routine Description:

    This function is called as soon as we think that the
    START_DEVICE Irp for the ACPI driver FDO is going to
    complete successfully

Arguments:

    DeviceObject        - DeviceObject that is being started

Return Value:

    NTSTATUS

--*/
{
    KEVENT              event;
    KIRQL               oldIrql;
    NTSTATUS            status;
    OBJDATA             objData;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PNSOBJ              acpiObject      = NULL;
    PNSOBJ              sleepObject     = NULL;
    PNSOBJ              childObject     = NULL;
    POWER_STATE         state;

    //
    // This will prevent the system from processing power irps
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
    AcpiSystemInitialized = FALSE;
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Initialize the event
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Setup the synchronization request
    //
    status = ACPIBuildSynchronizationRequest(
        deviceExtension,
        ACPIBuildNotifyEvent,
        &event,
        &AcpiBuildDeviceList,
        FALSE
        );

    //
    // What happened?
    //
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Start the initilization
    //
    //  NOTE: This routine causes many things to happens. Namely, it starts
    //  the process of loading ACPI tables. This (eventually) causes the
    //  Driver to start building device extensions. For this function to
    //  work properly, after we call this function, we need to wait until
    //  we have finished building device extensions. That means that we
    //  must wait for the event to be signaled
    //
    if (ACPIInitialize( (PVOID) DeviceObject ) == FALSE) {

        return STATUS_DEVICE_DOES_NOT_EXIST;

    }

    //
    // At this point, we have to wait. The check for STATUS_PENDING is
    // just good programming practice sicne BuildSynchronizationRequest can
    // only return Failure or STATUS_PENDING
    //
    if (status == STATUS_PENDING) {

        //
        // We had better wait for the above to complete
        //
        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

    }

    //
    // Hand all the machine state stuff to the HAL
    //
    NotifyHalWithMachineStates();

    //
    // Register the Power Callback
    //
    ACPIInternalRegisterPowerCallBack(
        deviceExtension,
        (PCALLBACK_FUNCTION) ACPIRootPowerCallBack
        );

    //
    // Cause the Power DPC to be fired for the first time
    //
    KeAcquireSpinLock( &AcpiPowerQueueLock, &oldIrql );
    if (!AcpiPowerDpcRunning) {

        KeInsertQueueDpc( &AcpiPowerDpc, NULL, NULL );

    }
    KeReleaseSpinLock( &AcpiPowerQueueLock, oldIrql );

    //
    // This will allow the system to get power irps again
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
    AcpiSystemInitialized = TRUE;
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Start the IRQ arbiter so that we can handle children's resources.
    //
    AcpiInitIrqArbiter(DeviceObject);

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIInitStartDevice(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PCM_RESOURCE_LIST       SuppliedList,
    IN  PACPI_POWER_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  PIRP                    Irp
    )
/*++

Routine Description:

    This routine is tasked with starting the device by programming in the
    supplied resources

Arguments:

    DeviceObject    - The object that we care about
    SuppliedList    - The resources associated with the device
    CallBack        - The function to call when done
    Irp             - The argument to pass to the callback

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    NTSTATUS            status = STATUS_SUCCESS;
    OBJDATA             crsData;
    PCM_RESOURCE_LIST   resList;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PNSOBJ              acpiObject = deviceExtension->AcpiObject;
    PNSOBJ              crsObject;
    PNSOBJ              srsObject;
    POBJDATA            srsData;
    ULONG               resSize;
    ULONG               srsSize;
    ULONG               deviceStatus;

    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    //
    // Do we have resources? Or a valid list?
    //
    if (SuppliedList == NULL || SuppliedList->Count != 1) {

        //
        // Ignore this resource list
        //
        goto ACPIInitStartDeviceSendD0;

    }

    //
    // Can we program this device? That is there a _CRS and an _SRS child?
    //
    crsObject = ACPIAmliGetNamedChild( acpiObject, PACKED_CRS );
    srsObject = ACPIAmliGetNamedChild( acpiObject, PACKED_SRS );
    if (crsObject == NULL || srsObject == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_WARNING,
            deviceExtension,
            "ACPIInitStartDevice - No SRS or CRS\n"
            ) );
        goto ACPIInitStartDeviceSendD0;

    }

    //
    // Run the _CRS method
    //
    status = AMLIEvalNameSpaceObject(
        crsObject,
        &crsData,
        0,
        NULL
        );
    if (!NT_SUCCESS(status)) {

        //
        // Failed
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIInitStartDevice - _CRS failed %08lx\n",
            status
            ) );
        goto ACPIInitStartDeviceError;

    }
    if (crsData.dwDataType != OBJTYPE_BUFFDATA ||
        crsData.dwDataLen == 0 ||
        crsData.pbDataBuff == NULL) {

        //
        // Failed
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIInitStartDevice - _CRS return invalid data\n",
            crsData.dwDataType
            ) );
        AMLIFreeDataBuffs( &crsData, 1 );
        status = STATUS_UNSUCCESSFUL;
        goto ACPIInitStartDeviceError;

    }

    //
    // Dump the list
    //
#if DBG
    if (NT_SUCCESS(status)) {

        ACPIDebugCmResourceList( SuppliedList, deviceExtension );

    }
#endif

    //
    // Allocate memory and copy the list...
    //
    resSize = sizeof(CM_RESOURCE_LIST) +
        (SuppliedList->List[0].PartialResourceList.Count - 1) *
        sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
    resList = ExAllocatePoolWithTag(
        PagedPool,
        resSize,
        ACPI_STRING_POOLTAG
        );
    if (resList == NULL) {

        //
        // Not enough resources
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIInitStartDevice - Could not allocate %08lx bytes\n",
            resSize
            ) );
        AMLIFreeDataBuffs( &crsData, 1 );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIInitStartDeviceError;

    }
    RtlCopyMemory( resList, SuppliedList, resSize );

    //
    // Now, make a copy of the crs object, but store it in non paged pool
    // because it will be used at DPC level
    //
    srsSize = sizeof(OBJDATA) + crsData.dwDataLen;
    srsData = ExAllocatePoolWithTag(
        NonPagedPool,
        srsSize,
        ACPI_OBJECT_POOLTAG
        );
    if (srsData == NULL) {

        //
        // Not enough resources
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIInitStartDevice - Could not allocate %08lx bytes\n",
            srsSize
            ) );
        AMLIFreeDataBuffs( &crsData, 1 );
        ExFreePool( resList );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIInitStartDeviceError;

    }
    RtlCopyMemory( srsData, &crsData, sizeof(OBJDATA) );
    srsData->pbDataBuff = ( (PUCHAR) srsData ) + sizeof(OBJDATA);
    RtlCopyMemory( srsData->pbDataBuff, crsData.pbDataBuff, crsData.dwDataLen );

    //
    // At this point, we no longer care about the _CRS data
    //
    AMLIFreeDataBuffs( &crsData, 1 );

    //
    // Make the new _srs
    //
    status = PnpCmResourcesToBiosResources( resList, srsData->pbDataBuff );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIInitStartDevice - PnpCmResourceToBiosResources = %08lx\n",
            status
            ) );
        ExFreePool( resList );
        ExFreePool( srsData );
        goto ACPIInitStartDeviceError;

    }

    //
    // The call to make the _SRS is destructive --- recopy the original list
    //
    RtlCopyMemory( resList, SuppliedList, resSize );

    //
    // We need to hold this lock to set this resource
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
    if (deviceExtension->PnpResourceList != NULL) {

        ExFreePool( deviceExtension->PnpResourceList );

    }
    deviceExtension->PnpResourceList = srsData;
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // We keep this around for debug information
    //
    if (deviceExtension->ResourceList != NULL) {

        //
        // If we already have a resource list, make sure that we free it
        //
        ExFreePool( deviceExtension->ResourceList );

    }
    deviceExtension->ResourceList = resList;

ACPIInitStartDeviceSendD0:

    //
    // Mark the irp as pending... We need to this because InternalDevice will
    // return STATUS_PENDING if it behaves in the correct manner
    //
    IoMarkIrpPending( Irp );

    //
    // I don't want to block in this driver if I can help it. Since there
    // is already a mechanism for me to execute a D0 and execute a completion
    // routine, I will choose to exercise that option
    //
    status = ACPIDeviceInternalDeviceRequest(
        deviceExtension,
        PowerDeviceD0,
        CallBack,
        CallBackContext,
        DEVICE_REQUEST_LOCK_DEVICE
        );

    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        //
        // We do this to make sure that we don't also call the completion
        // routine
        //
        status = STATUS_PENDING;

    }

    //
    // Done
    //
    return status;

    //
    // This label is the the point where we should jump to if any device
    // cannot program its resources, but we are going to return success
    //
ACPIInitStartDeviceError:

    ASSERT(!NT_SUCCESS(status));

    //
    // We have a failure here. As the completion routine was *not* called, we
    // must do that ourselves.
    //
    CallBack(
        deviceExtension,
        CallBackContext,
        status
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIInitStopACPI(
    IN  PDEVICE_OBJECT  DeviceObject
    )
/*++

Routine Description:

    This routine stops the ACPI FDO

Arguments:

    DeviceObject    - The pointer to the ACPI FDO

Return Value:

    NTSTATUS
--*/
{
    //
    // We will *never* stop ACPI
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIInitStopDevice(
    IN  PDEVICE_EXTENSION  DeviceExtension,
    IN  BOOLEAN            UnlockDevice
    )
/*++

Routine Description:

    This routine stops a device

Arguments:

    DeviceExtension    - The extension of the device to stop. An extension
                         is passed in as the device object may have already
                         been deleted by the PDO below our device object.

    UnlockDevice       - True if the device should be unlocked after being
                         stopped.

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PNSOBJ              acpiObject      = DeviceExtension->AcpiObject;
    PNSOBJ              workObject;
    POWER_STATE         state;
    ULONG               deviceStatus;

    PAGED_CODE();

    //
    // First step is try to turn off the device. We should only do this
    // if the device is in an *known* state
    //
    if (DeviceExtension->PowerInfo.PowerState != PowerDeviceUnspecified) {

        KEVENT  event;

        KeInitializeEvent( &event, SynchronizationEvent, FALSE );
        status = ACPIDeviceInternalDeviceRequest(
            DeviceExtension,
            PowerDeviceD3,
            ACPIInitPowerRequestCompletion,
            &event,
            UnlockDevice ? DEVICE_REQUEST_UNLOCK_DEVICE : 0
            );
        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(
                &event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );

            status = STATUS_SUCCESS;

        }

    }

    //
    // Nothing to stop...
    //
    if (acpiObject == NULL) {

        goto ACPIInitStopDeviceExit;
    }

    //
    // Second step is try to disable the device...
    //
    if ( (workObject = ACPIAmliGetNamedChild( acpiObject, PACKED_DIS ) ) != NULL ) {

        //
        // There is a method to do this
        //
        status = AMLIEvalNameSpaceObject( workObject, NULL, 0, NULL );
        if (!NT_SUCCESS(status) ) {

            goto ACPIInitStopDeviceExit;

        }

        //
        // See if the device is disabled
        //
        status = ACPIGetDevicePresenceSync(
            DeviceExtension,
            &deviceStatus,
            NULL
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                DeviceExtension,
                "ACPIInitStopDevice - GetDevicePresenceSync = 0x%08lx\n",
                status
                ) );
            goto ACPIInitStopDeviceExit;

        }
        if (deviceStatus & STA_STATUS_ENABLED) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                DeviceExtension,
                "ACPIInitStopDevice - STA_STATUS_ENABLED - 0x%08lx\n",
                deviceStatus
                ) );
            goto ACPIInitStopDeviceExit;

        }

    }

ACPIInitStopDeviceExit:
    if (DeviceExtension->ResourceList != NULL) {

        ExFreePool( DeviceExtension->ResourceList );
        DeviceExtension->ResourceList = NULL;

    }

    return STATUS_SUCCESS;
}

NTSTATUS
ACPIInitUnicodeString(
    IN  PUNICODE_STRING UnicodeString,
    IN  PCHAR           Buffer
    )
/*++

Routine Description:

    This routine takes an ASCII string and converts it to a Unicode string. The
    Caller is responsible for call RtlFreeUnicodeString() on the returned string

Arguments:

    UnicodeString   - Where to store the new unicode string
    Buffer          - What we will convert to unicode

Return Value:

    NTSTATUS

--*/
{
    ANSI_STRING     ansiString;
    NTSTATUS        status;
    ULONG           maxLength;

    PAGED_CODE();

    //
    // Make sure that we won't memory leak
    //
    ASSERT(UnicodeString->Buffer == NULL);

    //
    // We need to do this first before we run the convertion code. Buidling a
    // counted Ansi String is important
    //
    RtlInitAnsiString(&ansiString, Buffer);

    //
    // How long is the ansi string
    //
    maxLength = RtlAnsiStringToUnicodeSize(&(ansiString));
    if (maxLength > MAXUSHORT) {

        return STATUS_INVALID_PARAMETER_2;

    }
    UnicodeString->MaximumLength = (USHORT) maxLength;

    //
    // Allocate a buffer for the string
    //
    UnicodeString->Buffer = ExAllocatePoolWithTag(
        PagedPool,
        maxLength,
        ACPI_STRING_POOLTAG
        );
    if (UnicodeString->Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Convert the counted ANSI string to a counted Unicode string
    //
    status = RtlAnsiStringToUnicodeString(
        UnicodeString,
        &ansiString,
        FALSE
        );

    //
    // Done
    //
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\interupt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    interupt.c

Abstract:

    This module contains the interupt handler for the ACPI driver

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

//
// From shared\acpiinit.c
// We need to know certain information about the system, such as how
// many GPE bits are present
//
extern PACPIInformation AcpiInformation;

//
// Ignore the first interrupt because some machines are busted
//
BOOLEAN FirstInterrupt = TRUE;

//
// This is the variable that indicates wether or not the DPC is running
//
BOOLEAN AcpiGpeDpcRunning;

//
// This is the variable that indicates wether or not we have requested that
// the DPC be running...
//
BOOLEAN AcpiGpeDpcScheduled;

//
// This is the variable that indicates wether or not the DPC has completed
// real work
//
BOOLEAN AcpiGpeWorkDone;

//
// This is the timer that we use to schedule the DPC...
//
KTIMER  AcpiGpeTimer;

//
// This is the DPC routine that we use to process the GPEs...
//
KDPC    AcpiGpeDpc;

VOID
ACPIInterruptDispatchEvents(
    )
/*++

Routine Description:

    Function reads and dispatches GPE events.

    N.B. This function is not re-entrant.  Caller disables & enables
    gpes with ACPIGpeEnableDisableEvents().

Arguments:

    None

Return Value:

    None

--*/
{
    NTSTATUS            status;
    UCHAR               edg;
    UCHAR               sts;
    ULONG               gpeRegister;
    ULONG               gpeSize;

    //
    // Remember the size of the GPE registers and that we need a spinlock to
    // touch the tables
    //
    gpeSize = AcpiInformation->GpeSize;
    KeAcquireSpinLockAtDpcLevel (&GpeTableLock);

    //
    // Pre-handler processing.  Read status bits and clear their enables.
    // Eoi any edge firing gpe before gpe handler is invoked
    //
    for (gpeRegister = 0; gpeRegister < gpeSize; gpeRegister++) {

        //
        // Read the list of currently trigged method from the hardware
        //
        sts = ACPIReadGpeStatusRegister(gpeRegister) & GpeCurEnable[gpeRegister];

        //
        // Remember which sts bits need processed
        //
        GpePending[gpeRegister]   |= sts;
        GpeRunMethod[gpeRegister] |= sts;

        //
        // Clear gpe enables for the events we are handling
        //
        GpeCurEnable[gpeRegister] &= ~sts;

        //
        // We will need to clear the Edge triggered interrupts, so remember
        // which ones are those
        //
        edg = sts & ~GpeIsLevel[gpeRegister];

        //
        // Eoi edge gpe sts bits
        //
        if (edg) {

            ACPIWriteGpeStatusRegister(gpeRegister, edg);

        }

    }

    //
    // Tell the DPC that we have work to do
    //
    AcpiGpeWorkDone = TRUE;

    //
    // If the DPC isn't running, then schedule it
    //
    if (!AcpiGpeDpcRunning && !AcpiGpeDpcScheduled) {

        AcpiGpeDpcScheduled = TRUE;
        KeInsertQueueDpc( &AcpiGpeDpc, 0, 0);

    }

    //
    // Done with GPE spinlock
    //
    KeReleaseSpinLockFromDpcLevel(&GpeTableLock);
}

VOID
ACPIInterruptDispatchEventDpc(
    IN  PKDPC       Dpc,
    IN  PVOID       DpcContext,
    IN  PVOID       SystemArgument1,
    IN  PVOID       SystemArgument2
    )
/*++

Routine Description:

    This is the DPC engine responsible for running all GPE based events. It
    looks at the outstanding events and executes methods as is appropriate

Arguments:

    None used

Return Value:

    Void

--*/
{
    static CHAR         methodName[] = "\\_GPE._L00";
    ASYNC_GPE_CONTEXT   asyncGpeEval;
    NTSTATUS            status;
    PGPE_VECTOR_OBJECT  gpeVectorObject;
    PNSOBJ              pnsobj;
    UCHAR               cmp;
    UCHAR               gpeSTS[MAX_GPE_BUFFER_SIZE];
    UCHAR               gpeLVL[MAX_GPE_BUFFER_SIZE];
    UCHAR               gpeCMP[MAX_GPE_BUFFER_SIZE];
    UCHAR               gpeWAK[MAX_GPE_BUFFER_SIZE];
    UCHAR               lvl;
    UCHAR               sts;
    ULONG               bitmask;
    ULONG               bitno;
    ULONG               gpeIndex;
    ULONG               gpeRegister;
    ULONG               gpeSize;
    ULONG               i;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( DpcContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    //
    // Remember how many gpe bytes we have
    //
    gpeSize = AcpiInformation->GpeSize;

    //
    // First step is to acquire the DPC lock
    //
    KeAcquireSpinLockAtDpcLevel( &GpeTableLock );

    //
    // Remember that the DPC is no longer scheduled...
    //
    AcpiGpeDpcScheduled = FALSE;

    //
    // check to see if another DPC is already running
    if (AcpiGpeDpcRunning) {

        //
        // The DPC is already running, so we need to exit now
        //
        KeReleaseSpinLockFromDpcLevel( &GpeTableLock );
        return;

    }

    //
    // Remember that the DPC is now running
    //
    AcpiGpeDpcRunning = TRUE;

    //
    // Make sure that we know that we haven't completed anything
    //
    RtlZeroMemory( gpeCMP, MAX_GPE_BUFFER_SIZE );

    //
    // We must try to do *some* work
    //
    do {

        //
        // Assume that we haven't done any work
        //
        AcpiGpeWorkDone = FALSE;

        //
        // Pre-handler processing.  Build up the list of GPEs that we are
        // going to run on this iteration of the loop
        //
        for (gpeRegister = 0; gpeRegister < gpeSize; gpeRegister++) {

            //
            // We have stored away the list of methods that need to be run
            //
            sts = GpeRunMethod[gpeRegister];

            //
            // Make sure that we don't run those methods again, unless
            // someone asks us too
            //
            GpeRunMethod[gpeRegister] = 0;

            //
            // Remember which of those methods are level trigged
            //
            lvl = GpeIsLevel[gpeRegister];

            //
            // Remember which sts bits need processed
            //
            gpeSTS[gpeRegister] = sts;
            gpeLVL[gpeRegister] = lvl;

            //
            // Update the list of bits that have been completed
            //
            gpeCMP[gpeRegister] |= GpeComplete[gpeRegister];
            GpeComplete[gpeRegister] = 0;

        }

        //
        // We want to remember which GPEs are currently armed for Wakeup
        // because we have a race condition if we check for GpeWakeEnable()
        // after we drop the lock
        //
        RtlCopyMemory( gpeWAK, GpeWakeEnable, gpeSize );

        //
        // At this point, we must release the lock
        //
        KeReleaseSpinLockFromDpcLevel( &GpeTableLock );

        //
        // Issue gpe handler for each set gpe
        //
        for (gpeRegister = 0; gpeRegister < gpeSize; gpeRegister++) {

            sts = gpeSTS[gpeRegister];
            lvl = gpeLVL[gpeRegister];
            cmp = 0;

            while (sts) {

                //
                // Determine which bits are set within the current index
                //
                bitno = FirstSetLeftBit[sts];
                bitmask = 1 << bitno;
                sts &= ~bitmask;
                gpeIndex = ACPIGpeRegisterToGpeIndex (gpeRegister, bitno);

                //
                // Do we have a method to run here?
                //
                if (GpeHandlerType[gpeRegister] & bitmask) {

                    //
                    // Run the control method for this gpe
                    //
                    methodName[7] = (lvl & bitmask) ? 'L' : 'E';
                    methodName[8] = HexDigit[gpeIndex >> 4];
                    methodName[9] = HexDigit[gpeIndex & 0x0f];
                    status = AMLIGetNameSpaceObject(
                        methodName,
                        NULL,
                        &pnsobj,
                        0
                        );

                    //
                    // Setup the evaluation context. Note that we cheat
                    // and instead of allocating a structure, we use the
                    // pointer to hold the information (since the info is
                    // so small)
                    //
                    asyncGpeEval.GpeRegister = (UCHAR) gpeRegister;
                    asyncGpeEval.StsBit      = (UCHAR) bitmask;
                    asyncGpeEval.Lvl         = lvl;

                    //
                    // Did we find a control method to execute?
                    //
                    if (!NT_SUCCESS(status)) {

                        //
                        // The GPE is not meaningful to us.  Simply disable it -
                        // which is a nop since it's already been removed
                        // from the GpeCurEnables.
                        //
                        continue;

                    }

                    status = AMLIAsyncEvalObject (
                        pnsobj,
                        NULL,
                        0,
                        NULL,
                        (PFNACB) ACPIInterruptEventCompletion,
                        (PVOID)ULongToPtr(asyncGpeEval.AsULONG)
                        );

                    //
                    // If the evalution has completed re-enable the gpe; otherwise,
                    // wait for the async completion routine to do it
                    //
                    if (NT_SUCCESS(status)) {

                        if (status != STATUS_PENDING) {

                            cmp |= bitmask;

                        }

                    } else {

                        LONGLONG    dueTime;

                        //
                        // We need to modify the table lock
                        //
                        KeAcquireSpinLockAtDpcLevel(&GpeTableLock);

                        //
                        // Remember that we have to run this method again
                        //
                        GpeRunMethod[gpeRegister] |= bitmask;

                        //
                        // Have we already scheduled the DPC?
                        //
                        if (!AcpiGpeDpcScheduled) {

                            //
                            // Remember that we have schedule the DPC...
                            //
                            AcpiGpeDpcScheduled = TRUE;

                            //
                            // We want approximately a 2 second delay in this case
                            //
                            dueTime = -2 * 1000* 1000 * 10;

                            //
                            // This is unconditional --- it will fire in 2 seconds
                            //
                            KeSetTimer(
                                &AcpiGpeTimer,
                                *(PLARGE_INTEGER) &dueTime,
                                &AcpiGpeDpc
                                );

                        }

                        //
                        // Done with the lock
                        //
                        KeReleaseSpinLockFromDpcLevel(&GpeTableLock);

                    }

                } else if (gpeWAK[gpeRegister] & bitmask) {

                    //
                    // Vector is used for exlucive wake signalling
                    //
                    OSNotifyDeviceWakeByGPEEvent(gpeIndex, gpeRegister, bitmask);

                    //
                    // Processing of this gpe complete
                    //
                    cmp |= bitmask;

                } else {

                    //
                    // Notify the target device driver
                    //
                    i = GpeMap[ACPIGpeIndexToByteIndex (gpeIndex)];
                    if (i < GpeVectorTableSize) {

                        gpeVectorObject = GpeVectorTable[i].GpeVectorObject;
                        if (gpeVectorObject) {

                            //
                            // Call the target driver
                            //
                            gpeVectorObject->Handler(
                                gpeVectorObject,
                                gpeVectorObject->Context
                                );

                        } else {

                            ACPIPrint( (
                                ACPI_PRINT_CRITICAL,
                                "ACPIInterruptDispatchEvents: No Handler for Gpe: 0x%x\n",
                                gpeIndex
                                ) );
                            ACPIBreakPoint();

                        }

                        //
                        // Processing of this gpe complete
                        //
                        cmp |= bitmask;

                    }
                }
            }

            //
            // Remember what GPEs have been completed
            //
            gpeCMP[gpeRegister] |= cmp;

        }

        //
        // Synchronize accesses to the ACPI tables
        //
        KeAcquireSpinLockAtDpcLevel (&GpeTableLock);

    } while ( AcpiGpeWorkDone );

    //
    // Post-handler processing.  EOI any completed lvl firing gpe and re-enable
    // any completed gpe event
    //
    for (gpeRegister = 0; gpeRegister < gpeSize; gpeRegister++) {

        cmp = gpeCMP[gpeRegister];
        lvl = gpeLVL[gpeRegister] & cmp;

        //
        // EOI any completed level gpes
        //
        if (lvl) {

            ACPIWriteGpeStatusRegister(gpeRegister, lvl);

        }

        //
        // Calculate which functions it is we have to re-enable
        //
        ACPIGpeUpdateCurrentEnable(
            gpeRegister,
            cmp
            );

    }

    //
    // Remember that we have exited the DPC...
    //
    AcpiGpeDpcRunning = FALSE;

    //
    // Before we exist, we should re-enable the GPEs...
    //
    ACPIGpeEnableDisableEvents( TRUE );

    //
    // Done with the table lock
    //
    KeReleaseSpinLockFromDpcLevel (&GpeTableLock);
}

VOID
EXPORT
ACPIInterruptEventCompletion (
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result  OPTIONAL,
    IN PVOID                Context
    )
/*++

Routine Description:

    This function is called when the interpreter has finished executing a
    GPE. The routine updates some book-keeping and restarts the DPC engine
    to handle these things

Arguments:

    AcpiObject  - The method that was run
    Status      - Whether or not the method succeeded
    Result      - Not used
    Context     - Specifies the information required to figure what GPE
                  we executed

Return Value:

    None

--*/
{
    ASYNC_GPE_CONTEXT       gpeContext;
    KIRQL                   oldIrql;
    LONGLONG                dueTime;
    ULONG                   gpeRegister;

    //
    // We store the context information as part of the pointer. Convert it
    // back to a ULONG so that it is useful to us
    //
    gpeContext.AsULONG  = PtrToUlong(Context);
    gpeContext.Lvl     &= gpeContext.StsBit;
    gpeRegister         = gpeContext.GpeRegister;

    //
    // Need to synchronize access to these values
    //
    KeAcquireSpinLock (&GpeTableLock, &oldIrql);

    //
    // We have a different policy if the method failed then if it succeeded
    //
    if (!NT_SUCCESS(Status)) {

        //
        // In the failure case, we need to cause to method to run again
        //
        GpeRunMethod[gpeRegister] |= gpeContext.StsBit;

        //
        // Did we already schedule the DPC?
        //
        if (!AcpiGpeDpcScheduled) {

            //
            // Remember that we have schedule the DPC...
            //
            AcpiGpeDpcScheduled = TRUE;

            //
            // We want approximately a 2 second delay in this case
            //
            dueTime = -2 * 1000 * 1000 * 10;

            //
            // This is unconditional --- it will fire in 2 seconds
            //
            KeSetTimer(
                &AcpiGpeTimer,
                *(PLARGE_INTEGER) &dueTime,
                &AcpiGpeDpc
                );
        }

    } else {

        //
        // Remember that we did some work
        //
        AcpiGpeWorkDone = TRUE;

        //
        // Remember that this GPE is now complete
        //
        GpeComplete[gpeRegister] |= gpeContext.StsBit;

        //
        // If the DPC isn't already running, schedule it...
        //
        if (!AcpiGpeDpcRunning) {

            KeInsertQueueDpc( &AcpiGpeDpc, 0, 0);

        }

    }

    //
    // Done with the table lock
    //
    KeReleaseSpinLock (&GpeTableLock, oldIrql);
}

BOOLEAN
ACPIInterruptServiceRoutine(
    IN  PKINTERRUPT Interrupt,
    IN  PVOID       Context
    )
/*++

Routine Description:

    The interrupt handler for the ACPI driver

Arguments:

    Interrupt   - Interrupt Object
    Context     - Pointer to the device object which interrupt is associated with

Return Value:

    TRUE        - It was our interrupt
    FALSE       - Not our interrupt

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    ULONG               IntStatus;
    ULONG               BitsHandled;
    ULONG               PrevStatus;
    ULONG               i;
    BOOLEAN             Handled;

    //
    // No need to look at the interrupt object
    //
    UNREFERENCED_PARAMETER( Interrupt );

    //
    // Setup ---
    //
    deviceExtension = (PDEVICE_EXTENSION) Context;
    Handled = FALSE;

    //
    // Determine source of interrupt
    //
    IntStatus = ACPIIoReadPm1Status();

    //
    // Unfortently due to a piix4 errata we need to check the GPEs because
    // a piix4 sometimes forgets to raise an SCI on an asserted GPE
    //
    if (ACPIGpeIsEvent()) {

        IntStatus |= PM1_GPE_PENDING;

    }

    //
    // Nasty hack --- if we don't have any bits to handle at this point,
    // that probably means that someone changed the GPE Enable register
    // behind our back. The way that we can correct this problem is by
    // forcing a check of the GPEs...
    //
    if (!IntStatus) {

        IntStatus |= PM1_GPE_PENDING;

    }

    //
    // Are any status bits set for events which are handled at ISR time?
    //
    BitsHandled = IntStatus & (PM1_TMR_STS | PM1_BM_STS);
    if (BitsHandled) {

        //
        // Clear their status bits then handle them
        // (Note no special handling is required for PM1_BM_STS)
        //
        ACPIIoClearPm1Status ((USHORT) BitsHandled);

        //
        // If the overflow bit is set handle it
        //
        if (IntStatus & PM1_TMR_STS) {

            HalAcpiTimerInterrupt();

        }
        IntStatus &= ~BitsHandled;

    }

    //
    // If more service bits are pending, they are for the DPC function
    //

    if (IntStatus) {

        //
        // If no new status bits, then make sure we check for GPEs
        //
        if (!(IntStatus & (~deviceExtension->Fdo.Pm1Status))) {

            IntStatus |= PM1_GPE_PENDING;

        }

        //
        // If we're going to process outstanding GPEs, disable them
        // for DPC processing
        //
        if (IntStatus & PM1_GPE_PENDING) {

            ACPIGpeEnableDisableEvents( FALSE );

        }

        //
        // Clear the status bits we've handled
        //
        ACPIIoClearPm1Status ((USHORT) IntStatus);

        //
        // Set status bits for DPC routine to process
        //
        IntStatus |= PM1_DPC_IN_PROGRESS;
        PrevStatus = deviceExtension->Fdo.Pm1Status;
        do {

            i = PrevStatus;
            PrevStatus = InterlockedCompareExchange(
                &deviceExtension->Fdo.Pm1Status,
                (i | IntStatus),
                i
                );

        } while (i != PrevStatus);

        //
        // Compute which bits are new for the DPC to process
        //
        BitsHandled |= IntStatus & ~PrevStatus;

        //
        // If one of the new bits is "dpc in progress", we had better queue a dpc
        //
        if (BitsHandled & PM1_DPC_IN_PROGRESS) {

            KeInsertQueueDpc(&deviceExtension->Fdo.InterruptDpc, NULL, NULL);

        }

    }

    //
    // Done
    //
    return BitsHandled ? TRUE : FALSE;
}

VOID
ACPIInterruptServiceRoutineDPC(
    IN  PKDPC       Dpc,
    IN  PVOID       Context,
    IN  PVOID       Arg1,
    IN  PVOID       Arg2
    )
/*++

Routine Description:

    This routine is called by the ISR. This is done so that our code is
    executing at DPC level, and not DIRQL

Arguments:

    Dpc     - Pointer to the DPC object
    Context - Pointer to the Device Object
    Arg1    - Not Used
    Arg2    - Not Used

--*/
{
    PDEVICE_EXTENSION           deviceExtension;
    ULONG                       IntStatus;
    ULONG                       NewStatus;
    ULONG                       PrevStatus;
    ULONG                       BitsHandled;
    ULONG                       FixedButtonEvent;

    deviceExtension  = (PDEVICE_EXTENSION) Context;

    UNREFERENCED_PARAMETER( Arg1 );
    UNREFERENCED_PARAMETER( Arg2 );

    //
    // Loop while there's work
    //
    BitsHandled = 0;
    IntStatus = 0;
    for (; ;) {

        //
        // Get the status bits form the ISR.  If there are no more
        // status bits then exit
        //
        PrevStatus = deviceExtension->Fdo.Pm1Status;
        do {

            IntStatus = PrevStatus;

            //
            // If there's no work pending, try to complete DPC
            //
            NewStatus = PM1_DPC_IN_PROGRESS;
            if (!(IntStatus & ~PM1_DPC_IN_PROGRESS)) {

                //
                // Note: The original code, after this call, would go
                // out and check to see if we handeld any GPE Events.
                // If we, did, then we would call ACPIGpeEnableDisableEvents
                // in this context.
                //
                // The unfortunate problem with that approach is that it
                // is makes us more suspectible to gpe storms. The reason
                // is that there isn't a guarantee that GPE DPC has been
                // triggered. So, at the price of increasing the latency
                // in re-enabling events, we moved the re-enabling of
                // GPEs ad the end of the GPE DPC

                //
                // Before we complete, reenable events
                //
                ACPIEnablePMInterruptOnly();

                NewStatus = 0;
                BitsHandled = 0;

            }

            PrevStatus = InterlockedCompareExchange (
                &deviceExtension->Fdo.Pm1Status,
                NewStatus,
                IntStatus
                );

        } while (IntStatus != PrevStatus);

        //
        // If NewStatus cleared DPC_IN_PROGRESS, then we're done
        //
        if (!NewStatus) {

            break;

        }

        //
        // Track if GPE ever handled
        //
        BitsHandled |= IntStatus;

        //
        // Handle fixed power & sleep button events
        //
        FixedButtonEvent = 0;
        if (IntStatus & PM1_PWRBTN_STS) {

            FixedButtonEvent |= SYS_BUTTON_POWER;

        }
        if (IntStatus & PM1_SLEEPBTN_STS) {

            FixedButtonEvent |= SYS_BUTTON_SLEEP;

        }
        if (FixedButtonEvent) {

            if (IntStatus & PM1_WAK_STS) {

                FixedButtonEvent = SYS_BUTTON_WAKE;

            }
            ACPIButtonEvent (FixedButtonDeviceObject, FixedButtonEvent, NULL);

        }

        //
        // PM1_GBL_STS is set whenever the BIOS has released the global
        // lock (and we are waiting for it).  Notify the global lock handler.
        //
        if (IntStatus & PM1_GBL_STS) {

            ACPIHardwareGlobalLockReleased();

        }

        //
        // Handle GP Registers
        //
        if (IntStatus & PM1_GPE_PENDING) {

            ACPIInterruptDispatchEvents();

        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\internal.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    internal.h

Abstract:

    This file contains the headers for internal.c

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    29-Sep-97:  Added Support for moving PowerRequest lists around

--*/

#ifndef _INTERNAL_H_
#define _INTERNAL_H_

    extern KSPIN_LOCK           AcpiUpdateFlagsLock;
    extern UCHAR                FirstSetLeftBit[];
    extern UCHAR                HexDigit[];

    BOOLEAN
    ACPIInternalConvertToNumber(
        IN  UCHAR               ValueLow,
        IN  UCHAR               ValueHigh,
        IN  PULONG              Output
        );

    VOID
    ACPIInternalDecrementIrpReferenceCount(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIInternalGetDeviceCapabilities(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PDEVICE_CAPABILITIES    DeviceCapabilities
        );

    PDEVICE_EXTENSION
    ACPIInternalGetDeviceExtension(
        IN  PDEVICE_OBJECT          DeviceObject
        );

    NTSTATUS
    ACPIInternalGetDispatchTable(
        IN  PDEVICE_OBJECT          DeviceObject,
        OUT PDEVICE_EXTENSION       *DeviceExtension,
        OUT PIRP_DISPATCH_TABLE     *DispatchTable
        );

    NTSTATUS
    ACPIInternalGrowBuffer(
        IN  OUT PVOID   *Buffer,
        IN      ULONG   OriginalSize,
        IN      ULONG   NewSize
        );

    NTSTATUS
    ACPIInternalIsPci(
        IN  PDEVICE_OBJECT  DeviceObject
        );

    BOOLEAN
    ACPIInternalIsReportedMissing(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    VOID
    ACPIInternalMoveList(
         IN  PLIST_ENTRY FromList,
         IN  PLIST_ENTRY ToList
         );

    VOID
    ACPIInternalMovePowerList(
         IN  PLIST_ENTRY FromList,
         IN  PLIST_ENTRY ToList
         );

    NTSTATUS
    ACPIInternalRegisterPowerCallBack(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PCALLBACK_FUNCTION  CallBackFunction
        );

    NTSTATUS
    ACPIInternalSendSynchronousIrp(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PIO_STACK_LOCATION  TopStackLocation,
        OUT PVOID               *Information
        );

    NTSTATUS
    ACPIInternalSetDeviceInterface(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  LPGUID          InterfaceGuid
        );

    VOID
    ACPIInternalUpdateDeviceStatus(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  ULONG               DeviceStatus
        );

    ULONGLONG
    ACPIInternalUpdateFlags(
        IN  PULONGLONG  FlagLocation,
        IN  ULONGLONG   NewFlags,
        IN  BOOLEAN     Clear
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\internal.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    internal.c

Abstract:

    This file contains those functions which didn't easily fit into any
    of the other project files. They are typically accessory functions
    used to prevent repeatitive and tedious coding.

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIInternalGetDeviceCapabilities)
#pragma alloc_text(PAGE,ACPIInternalIsPci)
#pragma alloc_text(PAGE,ACPIInternalGrowBuffer)
#pragma alloc_text(PAGE,ACPIInternalSendSynchronousIrp)
#endif

//
// For IA32 bit machines, which don't have a 64 bit compare-exchange
// instruction, we need a spinlock so that the OS can simulate it
//
KSPIN_LOCK AcpiUpdateFlagsLock;

//
// We need to have a table of HexDigits so that we can easily generate
// the proper nane for a GPE method
//
UCHAR HexDigit[] = "0123456789ABCDEF";

//
// This is a look-up table. The entry into the table corresponds to the
// first bit set (in an x86-architecture, this is the left most bit set to
// one...
//
UCHAR FirstSetLeftBit[256] = {
        0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
        };




BOOLEAN
ACPIInternalConvertToNumber(
    IN  UCHAR   ValueLow,
    IN  UCHAR   ValueHigh,
    IN  PULONG  Output
    )
/*++

Routine Description:

    This routine takes the supplied values (in ASCII format) and converts
    them into numerical format. The ValueLow is the the low nibble of a uchar,
    and the ValueHigh is the high nibble of a uchar. The input ASCII format
    is HEX

Arguments:

    ValueLow    - ASCII Hex representation of low nibble
    ValueHigh   - ASCII Hex representation of high nibble
    Output      - Where to write the resulting UCHAR.

Return Value:

    BOOLEAN - TRUE if converstion went okay
            - FALSE otherwise
--*/
{
    UCHAR Number;
    UCHAR Scratch;

    //
    // Calculate the high nibble
    //
    if ( (ValueHigh < '0') || (ValueHigh > '9') )   {

        if ( (ValueHigh < 'A') || (ValueHigh > 'F') )   {

            return FALSE;

        } else {

            Scratch = (ValueHigh - 'A') + 10;

        }

    } else {

        Scratch = (ValueHigh - '0');

    }

    //
    // We now have the high nibble
    //
    Number = (UCHAR)Scratch;
    Number <<=4;

    //
    // Calculate the low nibble
    //
    if ( (ValueLow < '0') || (ValueLow > '9') )   {

        if ( (ValueLow < 'A') || (ValueLow > 'F') )   {

            return FALSE;

        } else {

            Scratch = (ValueLow - 'A') + 10;

        }

    } else {

        Scratch = (ValueLow - '0' );

    }

    //
    // We now have the low nibble
    //
    Number |= ((UCHAR)Scratch);

    //
    // Store the result
    //
    if ( Output ) {

        *Output = Number;
        return TRUE;

    } else {

        return FALSE;

    }
}

VOID
ACPIInternalDecrementIrpReferenceCount(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine decrements the number of outstanding request count in the
    device extension and does the correct thing when this goes to zero

Arguments:

    DeviceExtension - The Extension to decrement the count

Return Value:

    NTSTATUS

--*/
{
    LONG   oldReferenceCount;

    //
    // Decrement the reference count since we are done processing
    // the irp by the time we get back here
    //
    oldReferenceCount = InterlockedDecrement(
        &(DeviceExtension->OutstandingIrpCount)
        );
    if (oldReferenceCount == 0) {

        KeSetEvent( DeviceExtension->RemoveEvent, 0, FALSE );

    }
}

NTSTATUS
ACPIInternalGetDeviceCapabilities(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    )
/*++

Routine Description:

    This routine sends get the capabilities of the given stack

Arguments:

    DeviceObject        - The object that we want to know about
    DeviceCapabilities  - The capabilities of that device

Return Value:

    NTSTATUS

--*/
{
    IO_STACK_LOCATION   irpSp;
    NTSTATUS            status;
    PUCHAR              dummy;

    PAGED_CODE();

    ASSERT( DeviceObject != NULL );
    ASSERT( DeviceCapabilities != NULL );

    //
    // Initialize the stack location that we will use
    //
    RtlZeroMemory( &irpSp, sizeof(IO_STACK_LOCATION) );
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_CAPABILITIES;
    irpSp.Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    //
    // Initialize the capabilities that we will send down
    //
    RtlZeroMemory( DeviceCapabilities, sizeof(DEVICE_CAPABILITIES) );
    DeviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
    DeviceCapabilities->Version = 1;
    DeviceCapabilities->Address = (ULONG) -1;
    DeviceCapabilities->UINumber = (ULONG) -1;

    //
    // Make the call now...
    //
    status = ACPIInternalSendSynchronousIrp(
        DeviceObject,
        &irpSp,
        (PVOID) &dummy
        );

    // Done
    //
    return status;
}

PDEVICE_EXTENSION
ACPIInternalGetDeviceExtension(
    IN  PDEVICE_OBJECT  DeviceObject
    )
/*++

Routine Description:

    The ACPI Driver can no longer just get the device extension by
    Dereferencing DeviceObject->DeviceExtension because it allows a
    race condition when dealing with the surprise remove case

    This routine is called to turn the Device Object into a Device Extension

Arguments:

    DeviceObject    - The Device Object

Return Value:

    PDEVICE_EXTENSION

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // Acquire the device tree lock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Dereference the device extension
    //
    deviceExtension = DeviceObject->DeviceExtension;

#if 0
    //
    // Is this a surprise removed device extension?
    //
    if (deviceExtension != NULL &&
        deviceExtension->Flags & DEV_TYPE_SURPRISE_REMOVED) {

        //
        // Get the "real" extension
        //
        deviceExtension = deviceExtension->Removed.OriginalAcpiExtension;

    }
#endif

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Return the device extension
    //
    return deviceExtension;
}

NTSTATUS
ACPIInternalGetDispatchTable(
    IN  PDEVICE_OBJECT      DeviceObject,
    OUT PDEVICE_EXTENSION   *DeviceExtension,
    OUT PIRP_DISPATCH_TABLE *DispatchTable
    )
/*++

Routine Description:

    This routine returns the deviceExtension and dispatch table that is
    to be used by the target object

Arguments:

    DeviceObject    - The Device Object
    DeviceExtension - Where to store the deviceExtension
    DispatchTable   - Where to store the dispatchTable
Return Value:

    PDEVICE_EXTENSION

--*/
{
    KIRQL               oldIrql;

    //
    // Acquire the device tree lock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Dereference the device extension
    //
    *DeviceExtension = DeviceObject->DeviceExtension;
    if (DeviceObject->DeviceExtension) {

        //
        // Dereference the dispatch table
        //
        *DispatchTable = (*DeviceExtension)->DispatchTable;

    } else {

        //
        // No dispatch table to hand back
        //
        *DispatchTable = NULL;

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Return
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIInternalGrowBuffer(
    IN  OUT PVOID   *Buffer,
    IN      ULONG   OriginalSize,
    IN      ULONG   NewSize
    )
/*++

Routine Description:

    This function is used to grow a buffer. It allocates memory, zeroes it out,
    and copies the original information over.

    Note: I suppose it can *shrink* a buffer as well, but I wouldn't bet my life
    on it. The caller is responsible for freeing allocated memory

Arguments

    Buffer          - Points to the Pointer to the Buffer that we want to change
    OriginalSize    - How big the buffer was originally
    NewSize         - How big we want to make the buffer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  temp;

    PAGED_CODE();
    ASSERT( Buffer != NULL );

    temp = ExAllocatePoolWithTag(
        PagedPool,
        NewSize,
        ACPI_RESOURCE_POOLTAG
        );
    if (temp == NULL) {

        if (*Buffer) {

            ExFreePool ( *Buffer );
            *Buffer = NULL;

        }
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlZeroMemory ( temp, NewSize );
    if ( *Buffer ) {

        RtlCopyMemory ( temp, *Buffer, OriginalSize );
        ExFreePool( *Buffer );

    }

    *Buffer = temp;
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIInternalIsPci(
    IN  PDEVICE_OBJECT  DeviceObject
    )
/*++

Routine Description:

    This routine determines if the specified device object is part of a
    PCI stack, either as a PCI device or as a PCI Bus.

    This routine will then set the flags that if it is a PCI device, then
    it will always be remembered as such

Arguments:

    DeviceObject    - The device object to check

--*/
{
    AMLISUPP_CONTEXT_PASSIVE    isPciDeviceContext;
    BOOLEAN                     pciDevice;
    KEVENT                      removeEvent;
    NTSTATUS                    status;
    PDEVICE_EXTENSION           deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    PAGED_CODE();

    //
    // Is this already a PCI device?
    //
    if ( (deviceExtension->Flags & DEV_CAP_PCI) ||
         (deviceExtension->Flags & DEV_CAP_PCI_DEVICE) ) {

        return STATUS_SUCCESS;

    }

    //
    // Is this a PCI bus?
    //
    if (IsPciBus(deviceExtension->DeviceObject)) {

        //
        // Remember that we are a PCI bus
        //
        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            (DEV_CAP_PCI),
            FALSE
            );
        return STATUS_SUCCESS;

    }

    //
    // Are we a PCI device?
    //
    isPciDeviceContext.Status = STATUS_NOT_FOUND;
    KeInitializeEvent(
        &isPciDeviceContext.Event,
        SynchronizationEvent,
        FALSE
        );
    status = IsPciDevice(
        deviceExtension->AcpiObject,
        AmlisuppCompletePassive,
        (PVOID) &isPciDeviceContext,
        &pciDevice
        );
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &isPciDeviceContext.Event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = isPciDeviceContext.Status;

    }
    if (NT_SUCCESS(status) && pciDevice) {

        //
        // Remember that we are a PCI device
        //
        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            (DEV_CAP_PCI_DEVICE),
            FALSE
            );

    }

    return status;
}

BOOLEAN
ACPIInternalIsReportedMissing(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   currentExtension;
    BOOLEAN             reportedMissing;

    //
    // Preinit
    //
    reportedMissing = FALSE;

    //
    // Acquire the device tree lock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    currentExtension = DeviceExtension;
    do {

        if ( currentExtension->Flags & DEV_TYPE_NOT_ENUMERATED ) {

            reportedMissing = TRUE;
            break;

        }

        currentExtension = currentExtension->ParentExtension;

    } while ( currentExtension );

    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    return reportedMissing;
}

VOID
ACPIInternalMoveList(
    IN  PLIST_ENTRY FromList,
    IN  PLIST_ENTRY ToList
    )
/*++

Routine Description:

    This routine moves entire list arounds.

Arguments:

    FromList    - the List to move items from
    ToList      - the List to move items to

Return Value:

    None

--*/
{
    PLIST_ENTRY oldHead;
    PLIST_ENTRY oldTail;
    PLIST_ENTRY newTail;

    //
    // We have to check to see if the from list is empty, otherwise, the
    // direct pointer hacking will make a mess of things
    //
    if (!IsListEmpty(FromList)) {

        newTail = ToList->Blink;
        oldTail = FromList->Blink;
        oldHead = FromList->Flink;

        //
        // Move the pointers around some
        //
        oldTail->Flink = ToList;
        ToList->Blink  = oldTail;
        oldHead->Blink = newTail;
        newTail->Flink = oldHead;
        InitializeListHead( FromList );

    }

}

VOID
ACPIInternalMovePowerList(
    IN  PLIST_ENTRY FromList,
    IN  PLIST_ENTRY ToList
    )
/*++

Routine Description:

    This routine moves entire list arounds. Since this routine is only
    used for Device Power Management, we also take the time to reset the
    amount of work done to NULL.

Arguments:

    FromList    - the List to move items from
    ToList      - the List to move items to

Return Value:

    None

--*/
{
    PACPI_POWER_REQUEST powerRequest;
    PLIST_ENTRY         oldHead = FromList->Flink;

    //
    // Before we do anything, walk the From and reset the amount of work that
    // was done
    //
    while (oldHead != FromList) {

        //
        // Obtain the power request that this entry contains
        //
        powerRequest = CONTAINING_RECORD(
            oldHead,
            ACPI_POWER_REQUEST,
            ListEntry
            );
#if DBG
        if (oldHead == &AcpiPowerPhase0List ||
            oldHead == &AcpiPowerPhase1List ||
            oldHead == &AcpiPowerPhase2List ||
            oldHead == &AcpiPowerPhase3List ||
            oldHead == &AcpiPowerPhase4List ||
            oldHead == &AcpiPowerPhase5List ||
            oldHead == &AcpiPowerWaitWakeList) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ACPIInternalMoveList: %08x is linked into %08lx\n",
                oldHead,
                FromList
                ) );
            DbgBreakPoint();

        }
#endif

        //
        // Grab the next entry
        //
        oldHead = oldHead->Flink;

        //
        // Reset the amount of work done. Note: This could be a CompareExchange
        // with the Comparand being WORK_DONE_COMPLETED
        //
        InterlockedExchange(
            &(powerRequest->WorkDone),
            WORK_DONE_STEP_0
            );

    }

    //
    // Actually Move the list here...
    //
    ACPIInternalMoveList( FromList, ToList );
}

NTSTATUS
ACPIInternalRegisterPowerCallBack(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PCALLBACK_FUNCTION  CallBackFunction
    )
/*++

Routine Description:

    This routine is called to register a Power Call on the appropriate
    device extension.

Arguments:

    DeviceExtension     - This will be the context field of the CallBackFunction
    CallBackFunction    - The function to invoke

Return Value:

    NSTATUS

--*/
{
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objAttributes;
    PCALLBACK_OBJECT    callBack;
    PVOID               callBackRegistration;
    UNICODE_STRING      callBackName;

    //
    // if there is already a callback present, this is a nop
    //
    if (DeviceExtension->Flags & DEV_PROP_CALLBACK) {

        return STATUS_SUCCESS;

    }

    //
    // Remember that we have a callback
    //
    ACPIInternalUpdateFlags(
        &(DeviceExtension->Flags),
        DEV_PROP_CALLBACK,
        FALSE
        );

    //
    // Register a callback that tells us when the user changes the
    // system power policy
    //
    RtlInitUnicodeString( &callBackName, L"\\Callback\\PowerState" );
    InitializeObjectAttributes(
        &objAttributes,
        &callBackName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL
        );
    status = ExCreateCallback(
        &callBack,
        &objAttributes,
        FALSE,
        TRUE
        );
    if (NT_SUCCESS(status)) {

        ExRegisterCallback(
            callBack,
            CallBackFunction,
            DeviceExtension
            );

    }
    if (!NT_SUCCESS(status)) {

        //
        // Ignored failed registrations
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIInternalRegisterPowerCallBack: Failed to register callback %x",
            status
            ) );
        status = STATUS_SUCCESS;

        //
        // Remember that we don't have a callback
        //
        ACPIInternalUpdateFlags(
            &(DeviceExtension->Flags),
            DEV_PROP_CALLBACK,
            TRUE
            );

    }
    return status;
}

NTSTATUS
ACPIInternalSendSynchronousIrp(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIO_STACK_LOCATION  TopStackLocation,
    OUT PVOID               *Information
    )
/*++

Routine Description:

    Builds a PNP Irp and sends it down to DeviceObject

Arguments:

    DeviceObject        - Target DeviceObject
    TopStackLocation    - Specifies the Parameters for the Irp
    Information         - The returned IoStatus.Information field

Return Value:

    NTSTATUS

--*/
{
    IO_STATUS_BLOCK     ioStatus;
    KEVENT              pnpEvent;
    NTSTATUS            status;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpStack;
    PIRP                pnpIrp;

    PAGED_CODE();

    //
    // Initialize the event
    //
    KeInitializeEvent( &pnpEvent, SynchronizationEvent, FALSE );

    //
    // Get the irp that we will send the request to
    //
    targetObject = IoGetAttachedDeviceReference( DeviceObject );

    //
    // Build an IRP
    //
    pnpIrp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        targetObject,
        NULL,   // I don't need a buffer
        0,      // Size is empty
        NULL,   // Don't have to worry about the starting location
        &pnpEvent,
        &ioStatus
        );

    if (pnpIrp == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIInternalSendSynchronousIrpExit;

    }

    //
    // PNP Irps all begin life as STATUS_NOT_SUPPORTED.
    //
    pnpIrp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
    pnpIrp->IoStatus.Information = 0;

    //
    // Get the top of stack ...
    //
    irpStack = IoGetNextIrpStackLocation ( pnpIrp );
    if (irpStack == NULL) {

        status = STATUS_INVALID_PARAMETER;
        goto ACPIInternalSendSynchronousIrpExit;

    }

    //
    // Set the top of stack
    //
    *irpStack = *TopStackLocation;

    //
    // Make sure that there are no completion routine set
    //
    IoSetCompletionRoutine(
        pnpIrp,
        NULL,
        NULL,
        FALSE,
        FALSE,
        FALSE
        );

    //
    // Call the driver
    //
    status = IoCallDriver( targetObject, pnpIrp );
    if (status == STATUS_PENDING) {

        //
        // If the status is STATUS_PENDING, than we must block until the irp completes
        // and pull the true status out
        //
        KeWaitForSingleObject(
            &pnpEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL);

        status = ioStatus.Status;

    }

    //
    // Tell the user how much information was passed (if necessary)
    //
    if (NT_SUCCESS(status) && (Information != NULL)) {

        *Information = (PVOID)ioStatus.Information;

    }

ACPIInternalSendSynchronousIrpExit:
    ACPIPrint( (
        ACPI_PRINT_IRP,
        "ACPIInternalSendSynchronousIrp: %#08lx Status = %#08lx\n",
        DeviceObject, status
        ) );

    //
    // Done with reference
    //
    ObDereferenceObject( targetObject );

    return status;
}

NTSTATUS
ACPIInternalSetDeviceInterface (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  LPGUID          InterfaceGuid
    )
/*++

Routine Description:

    This routine does all the grunt work for registering an interface and
    enabling it

Arguments:

    DeviceObject    - The device we wish to register the interface on
    InterfaceGuid   - The interface we wish to register

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    UNICODE_STRING      symbolicLinkName;

    //
    // Register the interface
    //
    status = IoRegisterDeviceInterface(
        DeviceObject,
        InterfaceGuid,
        NULL,
        &symbolicLinkName
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPIInternalSetDeviceInterface: IoRegisterDeviceInterface = %08lx",
            status
            ) );
        return status;

    }

    //
    // Turn on the interface
    //
    status = IoSetDeviceInterfaceState(&symbolicLinkName, TRUE);
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPIInternalSetDeviceInterface: IoSetDeviceInterfaceState = %08lx",
            status
            ) );
        goto ACPIInternalSetDeviceInterfaceExit;

    }

ACPIInternalSetDeviceInterfaceExit:
    //
    // Done
    //
    return status;
}

VOID
ACPIInternalUpdateDeviceStatus(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  ULONG               DeviceStatus
    )
/*++

Routine Description:

    This routine is called to update the status of the DeviceExtension based
    upon the result of the _STA, which are passed as DeviceStatus

Arguments:

    DeviceExtension - The extension whose status is to be updated
    DeviceState     - The status of the device

Return Value:

    VOID

--*/
{
    KIRQL               oldIrql;
    ULONGLONG           originalFlags;
    PDEVICE_EXTENSION   parentExtension = NULL;
    BOOLEAN             bPreviouslyPresent;

    //
    // Is the device working okay?
    //
    originalFlags = ACPIInternalUpdateFlags(
        &(DeviceExtension->Flags),
        DEV_PROP_DEVICE_FAILED,
        (BOOLEAN) (DeviceStatus & STA_STATUS_WORKING_OK)
        );

    //
    // Is the device meant to be shown in the UI?
    //
    originalFlags = ACPIInternalUpdateFlags(
        &(DeviceExtension->Flags),
        DEV_CAP_NO_SHOW_IN_UI,
        (BOOLEAN) (DeviceStatus & STA_STATUS_USER_INTERFACE)
        );

    //
    // Is the device decoding its resources?
    //
    originalFlags = ACPIInternalUpdateFlags(
        &(DeviceExtension->Flags),
        DEV_PROP_DEVICE_ENABLED,
        (BOOLEAN) !(DeviceStatus & STA_STATUS_ENABLED)
        );

    //
    // Update the extensions flags bassed on wether or not STA_STATUS_PRESENT is
    // set
    //
    originalFlags = ACPIInternalUpdateFlags(
        &(DeviceExtension->Flags),
        DEV_TYPE_NOT_PRESENT,
        (BOOLEAN) (DeviceStatus & STA_STATUS_PRESENT)
        );

    //
    // If the original flags do not contain the set value, but we are setting
    // the flags, then we must call IoInvalidDeviceRelations on the parent
    //
    if (!(originalFlags & DEV_TYPE_NOT_PRESENT) &&
        !(DeviceStatus & STA_STATUS_PRESENT)) {

        //
        // Need the device tree lock
        //
        KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

        parentExtension = DeviceExtension->ParentExtension;
        while (parentExtension && (parentExtension->Flags & DEV_TYPE_NOT_FOUND)) {

            parentExtension = parentExtension->ParentExtension;

        }

        IoInvalidateDeviceRelations(
            parentExtension->PhysicalDeviceObject,
            BusRelations
            );

        //
        // Done with the lock
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    }
}

ULONGLONG
ACPIInternalUpdateFlags(
    IN  PULONGLONG  FlagLocation,
    IN  ULONGLONG   NewFlags,
    IN  BOOLEAN     Clear
    )
/*++

Routine Description:

    This routine updates flags in the specified location

Arguments:

    FlagLocation    - Where the flags are located
    NewFlags        - The bits that should be set or cleared
    Clear           - Wether the bits should be set or cleared

Return Value:

    Original Flags

--*/
{
    ULONGLONG   originalFlags;
    ULONGLONG   tempFlags;
    ULONGLONG   flags;
    ULONG       uFlags;
    ULONG       uTempFlags;
    ULONG       uOriginalFlags;

#if 0
    if (Clear) {

        //
        // Clear the bits
        //
        originalFlags = *FlagLocation;
        do {

            tempFlags = originalFlags;
            flags = tempFlags & ~NewFlags;

            //
            // Calculate the low part
            //
            uFlags = (ULONG) flags;
            uTempFlags = (ULONG) tempFlags;
            originalFlags = InterlockedCompareExchange(
                (PULONG) FlagLocation,
                uFlags,
                uTempFlags
                );

            //
            // Calculate the high part
            //
            uFlags = (ULONG) (flags >> 32);
            uTempFlags = (ULONG) (tempFlags >> 32);
            uOriginalFlags = InterlockedCompareExchange(
                (PULONG) FlagLocation+1,
                uFlags,
                uTempFlags
                );

            //
            // Rebuild the original flags
            //
            originalFlags |= (uOriginalFlags << 32);
            tempFlags |= (uTempFlags << 32);

        } while ( tempFlags != originalFlags );

    } else {

        //
        // Set the bits
        //
        originalFlags = *FlagLocation;
        do {

            tempFlags = originalFlags;
            flags = tempFlags | NewFlags;

            //
            // Calculate the low part
            //
            uFlags = (ULONG) flags;
            uTempFlags = (ULONG) tempFlags;
            originalFlags = InterlockedCompareExchange(
                (PULONG) FlagLocation,
                uFlags,
                uTempFlags
                );

            //
            // Calculate the high part
            //
            uFlags = (ULONG) (flags >> 32);
            uTempFlags = (ULONG) (tempFlags >> 32);
            uOriginalFlags = InterlockedCompareExchange(
                (PULONG) FlagLocation+1,
                uFlags,
                uTempFlags
                );

            //
            // Rebuild the original flags
            //
            originalFlags |= (uOriginalFlags << 32);
            tempFlags |= (uTempFlags << 32);

        } while ( tempFlags != originalFlags );
    }
#else

    if (Clear) {

        //
        // Clear the bits
        //
        originalFlags = *FlagLocation;
        do {

            tempFlags = originalFlags;
            flags = tempFlags & ~NewFlags;

            //
            // Exchange the bits
            //
            originalFlags = ExInterlockedCompareExchange64(
                (PLONGLONG) FlagLocation,
                (PLONGLONG) &flags,
                (PLONGLONG) &tempFlags,
                &AcpiUpdateFlagsLock
                );

        } while ( tempFlags != originalFlags );

    } else {

        //
        // Set the bits
        //
        originalFlags = *FlagLocation;
        do {

            tempFlags = originalFlags;
            flags = tempFlags | NewFlags;

            //
            // Exchange teh bits
            //
            originalFlags = ExInterlockedCompareExchange64(
                (PLONGLONG) FlagLocation,
                (PLONGLONG) &flags,
                (PLONGLONG) &tempFlags,
                &AcpiUpdateFlagsLock
                );

        } while ( tempFlags != originalFlags );

    }
#endif

    //
    // return the original flags
    //
    return originalFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\interupt.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    interupt.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _INTERUPT_H_
#define _INTERUPT_H_

    typedef struct {
        union {
            struct {
                UCHAR   GpeRegister;
                UCHAR   StsBit;
                UCHAR   Lvl;
            } ;
            ULONG       AsULONG;
        } ;
    } ASYNC_GPE_CONTEXT, *PASYNC_GPE_CONTEXT;

    extern BOOLEAN  AcpiGpeDpcRunning;
    extern BOOLEAN  AcpiGpeDpcScheduled;
    extern BOOLEAN  AcpiGpeWorkDone;
    extern KTIMER   AcpiGpeTimer;
    extern KDPC     AcpiGpeDpc;

    VOID
    ACPIInterruptDispatchEvent(
        );

    VOID
    ACPIInterruptDispatchEventDpc(
        IN  PKDPC       Dpc,
        IN  PVOID       DpcContext,
        IN  PVOID       SystemArgument1,
        IN  PVOID       SystemArgument2
        );
    VOID
    EXPORT
    ACPIInterruptEventCompletion(
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    Result,
        IN  PVOID       Context
        );

    BOOLEAN
    ACPIInterruptServiceRoutine(
        IN  PKINTERRUPT Interrupt,
        IN  PVOID       Context
        );

    VOID
    ACPIInterruptServiceRoutineDPC(
        IN  PKDPC       Dpc,
        IN  PVOID       Context,
        IN  PVOID       Arg1,
        IN  PVOID       Arg2
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\match.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    match.h

Abstract:

    This module contains the routines that try to match a PNSOBJ with a DeviceObject

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _MATCH_H_
#define _MATCH_H_

    NTSTATUS
    ACPIMatchHardwareAddress(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  ULONG               Address,
        OUT BOOLEAN             *Success
        );

    NTSTATUS
    ACPIMatchHardwareId(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PUNICODE_STRING     AcpiUnicodeId,
        OUT BOOLEAN             *Success
        );

    extern PUCHAR *KdComPortInUse;

    VOID
    ACPIMatchKernelPorts(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  POBJDATA            Resources
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\match.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    match.c

Abstract:

    This module contains the routines that try to match a PNSOBJ with a DeviceObject

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"
#include "hdlsblk.h"
#include "hdlsterm.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIMatchHardwareAddress)
#pragma alloc_text(PAGE,ACPIMatchHardwareId)
#endif

NTSTATUS
ACPIMatchHardwareAddress(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  ULONG           DeviceAddress,
    OUT BOOLEAN         *Success
    )
/*++

Routine Description:

    This routine determines the device address of the two supplied objects and checks
    for a match

Arguments:

    DeviceObject    - The NT DeviceObject that we wish to check
    DeviceAddress   - The ACPI address of the device
    Success         - Pointer of where to store the result of the comparison

Return Value:

    NTSTATUS

--*/
{
    DEVICE_CAPABILITIES deviceCapabilities;
    NTSTATUS            status;

    PAGED_CODE();

    ASSERT( DeviceObject != NULL );
    ASSERT( Success != NULL );

    //
    // Assume that we don't succeed
    //
    *Success = FALSE;

    //
    // Get the capabilities
    //
    status = ACPIInternalGetDeviceCapabilities(
        DeviceObject,
        &deviceCapabilities
        );
    if (!NT_SUCCESS(status)) {

        goto ACPIMatchHardwareAddressExit;

    }

    //
    // Lets compare the two answers
    //
    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "%lx: ACPIMatchHardwareAddress - Device %08lx - %08lx\n",
        DeviceAddress,
        DeviceObject,
        deviceCapabilities.Address
        ) );
    if (DeviceAddress == deviceCapabilities.Address) {

        *Success = TRUE;

    }

ACPIMatchHardwareAddressExit:

    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "%lx: ACPIMatchHardwareAddress - Device: %#08lx - Status: %#08lx "
        "Success:%#02lx\n",
        DeviceAddress,
        DeviceObject,
        status,
        *Success
        ) );

    return status;
}

NTSTATUS
ACPIMatchHardwareId(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PUNICODE_STRING AcpiUnicodeId,
    OUT BOOLEAN         *Success
    )
/*++

Routine Description:

    This routine is responsible for determining if the supplied objects have the
    same device name

Arguments:

    DeviceObject    - The NT Device Object whose name we want to check
    UnicodeId       - The ID that we are trying to match with
    Success         - Where to store the success status

Return Value:

    NTSTATUS

--*/
{
    IO_STACK_LOCATION   irpSp;
    NTSTATUS            status;
    PWSTR               buffer;
    PWSTR               currentPtr;
    UNICODE_STRING      objectDeviceId;

    PAGED_CODE();

    ASSERT( DeviceObject != NULL );
    ASSERT( Success != NULL );

    *Success = FALSE;

    //
    // Initialize the stack location to pass to ACPIInternalSendSynchronousIrp()
    //
    RtlZeroMemory( &irpSp,          sizeof(IO_STACK_LOCATION) );
    RtlZeroMemory( &objectDeviceId, sizeof(UNICODE_STRING) );

    //
    // Set the function codes
    //
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_ID;
    irpSp.Parameters.QueryId.IdType = BusQueryHardwareIDs;

    //
    // Make the call now...
    //
    status = ACPIInternalSendSynchronousIrp( DeviceObject, &irpSp, &buffer );
    if (!NT_SUCCESS(status)) {

        goto ACPIMatchHardwareIdExit;

    }

    //
    // The return from the call is actually a MultiString, so we have to
    // walk all of its components
    //
    currentPtr = buffer;
    while (currentPtr && *currentPtr != L'\0') {

        //
        // At this point, we can make a Unicode String from the buffer...
        //
        RtlInitUnicodeString( &objectDeviceId, currentPtr );

        //
        // Increment the current pointer to the next part of the MultiString
        //
        currentPtr += (objectDeviceId.MaximumLength / sizeof(WCHAR) );

        //
        // Now try to compare the two unicode strings...
        //
        if (RtlEqualUnicodeString( &objectDeviceId, AcpiUnicodeId, TRUE) ) {

            *Success = TRUE;
            break;

        }

    }

    //
    // Done -- free resources
    //
    ExFreePool( buffer );

ACPIMatchHardwareIdExit:

    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "%ws: ACPIMatchHardwareId - %08lx - Status: %#08lx Success:%#02lx\n",
        AcpiUnicodeId->Buffer,
        DeviceObject,
        status,
        *Success
        ) );

    return status;
}

VOID
ACPIMatchKernelPorts(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  POBJDATA            Resources
    )
/*++

Routine Description:

    This routine is called to determine if the supplied deviceExtension
    is currently in use by the Kernel as the debugger port or the headless
    port. If it is so marked, then we handle it 'special'.

Arguments:

    DeviceExtension - Port to check
    Resources       - What resources the port is using

Return Value:

    None

--*/
{
    BOOLEAN  ioFound;
    BOOLEAN  matchFound          = FALSE;
    PUCHAR   buffer              = Resources->pbDataBuff;
    UCHAR    tagName             = *buffer;
    ULONG    baseAddress         = 0;
    ULONG    count               = 0;
    PUCHAR   headlessBaseAddress = NULL;
    USHORT   increment;
    SIZE_T   length;
    NTSTATUS status;
    HEADLESS_RSP_QUERY_INFO response;

    //
    // Get the information about headless
    //
    length = sizeof(HEADLESS_RSP_QUERY_INFO);
    status = HeadlessDispatch(HeadlessCmdQueryInformation,
                              NULL,
                              0,
                              &response,
                              &length
                             );

    if (NT_SUCCESS(status) && 
        (response.PortType == HeadlessSerialPort) &&
        response.Serial.TerminalAttached) {

        headlessBaseAddress = response.Serial.TerminalPortBaseAddress;

    }
        


    //
    // First of all, see if the any Kernel port is in use
    //
    if ((KdComPortInUse == NULL || *KdComPortInUse == 0) &&
        (headlessBaseAddress == NULL)) {

        //
        // No port in use
        //
        return;

    }

    //
    // Look through all the descriptors
    //
    while (count < Resources->dwDataLen) {

        //
        // We haven't found any IO ports
        //
        ioFound = FALSE;

        //
        // Determine the size of the PNP resource descriptor
        //
        if (!(tagName & LARGE_RESOURCE_TAG) ) {

            //
            // This is a small tag
            //
            increment = (USHORT) (tagName & SMALL_TAG_SIZE_MASK) + 1;
            tagName &= SMALL_TAG_MASK;

        } else {

            //
            // This is a large tag
            //
            increment = ( *(USHORT UNALIGNED *)(buffer+1) ) + 3;

        }

        //
        // We are done if the current tag is the end tag
        //
        if (tagName == TAG_END) {

            break;

        }

        switch (tagName) {
            case TAG_IO: {

                PPNP_PORT_DESCRIPTOR    desc = (PPNP_PORT_DESCRIPTOR) buffer;

                //
                // We found an IO port and so we will note that
                //
                baseAddress = (ULONG) desc->MinimumAddress;
                ioFound = TRUE;
                break;
            }
            case TAG_IO_FIXED: {

                PPNP_FIXED_PORT_DESCRIPTOR  desc = (PPNP_FIXED_PORT_DESCRIPTOR) buffer;

                //
                // We found an IO port so we will note that
                //
                baseAddress = (ULONG) (desc->MinimumAddress & 0x3FF);
                ioFound = TRUE;
                break;

            }
            case TAG_WORD_ADDRESS: {

                PPNP_WORD_ADDRESS_DESCRIPTOR    desc = (PPNP_WORD_ADDRESS_DESCRIPTOR) buffer;

                //
                // Is this an IO port?
                //
                if (desc->RFlag == PNP_ADDRESS_IO_TYPE) {

                    //
                    // We found an IO port, so we will note that
                    //
                    baseAddress = (ULONG) desc->MinimumAddress +
                        desc->TranslationAddress;
                    ioFound = TRUE;

                }
                break;

            }
            case TAG_DOUBLE_ADDRESS: {

                PPNP_DWORD_ADDRESS_DESCRIPTOR   desc = (PPNP_DWORD_ADDRESS_DESCRIPTOR) buffer;

                //
                // If this an IO port
                //
                if (desc->RFlag == PNP_ADDRESS_IO_TYPE) {

                    //
                    // We found an IO Port, so we will note that
                    //
                    baseAddress = (ULONG) desc->MinimumAddress +
                        desc->TranslationAddress;
                    ioFound = TRUE;

                }
                break;

            }
            case TAG_QUAD_ADDRESS: {

                PPNP_QWORD_ADDRESS_DESCRIPTOR   desc = (PPNP_QWORD_ADDRESS_DESCRIPTOR) buffer;

                //
                // If this an IO port
                //
                if (desc->RFlag == PNP_ADDRESS_IO_TYPE) {

                    //
                    // We found an IO Port, so we will note that
                    //
                    baseAddress = (ULONG) (desc->MinimumAddress +
                        desc->TranslationAddress);
                    ioFound = TRUE;

                }
                break;

            }

        } // switch

        //
        // Did we find an IO port?
        //
        if (ioFound == TRUE) {

           //
           // Does the minimum address match?
           //
           if (((KdComPortInUse != NULL) && (baseAddress == (ULONG_PTR) *KdComPortInUse)) ||
               ((headlessBaseAddress != NULL) && (baseAddress == (ULONG_PTR)headlessBaseAddress))) {

               //
               // Mark the node as being special
               //
               ACPIInternalUpdateFlags(
                   &(DeviceExtension->Flags),
                   (DEV_CAP_NO_OVERRIDE | DEV_CAP_NO_STOP | DEV_CAP_ALWAYS_PS0 |
                    DEV_TYPE_NOT_PRESENT | DEV_TYPE_NEVER_PRESENT),
                   FALSE);

               if ((KdComPortInUse != NULL) && (baseAddress == (ULONG_PTR) *KdComPortInUse)) {
                   ACPIDevPrint( (
                       ACPI_PRINT_LOADING,
                       DeviceExtension,
                       "ACPIMatchKernelPorts - Found KD Port at %lx\n",
                       baseAddress
                       ) );
               } else {
                   ACPIDevPrint( (
                       ACPI_PRINT_LOADING,
                       DeviceExtension,
                       "ACPIMatchKernelPorts - Found Headless Port at %lx\n",
                       baseAddress
                       ) );
               }

               break;

           }

        }

        //
        // Move of the next descriptor
        //
        count += increment;
        buffer += increment;
        tagName = *buffer;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\irqarb.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    This is the precompiled header for the ACPI NT subtree

Author:

    Jason Clark (jasoncl)

Environment:

    Kernel mode only.

Revision History:

--*/

#ifndef _ACPI_IRQ_ARB_H_
#define _ACPI_IRQ_ARB_H_

typedef struct {
    ARBITER_INSTANCE    ArbiterState;
    PDEVICE_OBJECT      DeviceObject;
} ACPI_ARBITER, *PACPI_ARBITER;

typedef struct {
    SINGLE_LIST_ENTRY   List;
    PDEVICE_OBJECT      Pdo;
} LINK_NODE_ATTACHED_DEVICES, *PLINK_NODE_ATTACHED_DEVICES;

typedef struct {
    LIST_ENTRY  List;
    ULONG       ReferenceCount;
    LONG        TempRefCount;
    PNSOBJ      NameSpaceObject;
    ULONGLONG   CurrentIrq;
    ULONGLONG   TempIrq;
    UCHAR       Flags;
    SINGLE_LIST_ENTRY   AttachedDevices;    // filled in only for debugging
} LINK_NODE, *PLINK_NODE;

#define LAST_PCI_IRQ_BUFFER_SIZE 10
typedef struct {
    LIST_ENTRY  LinkNodeHead;
    PNSOBJ      CurrentLinkNode;
    PINT_ROUTE_INTERFACE_STANDARD   InterruptRouting;
    ULONG       LastPciIrqIndex;
    ULONGLONG   LastPciIrq[LAST_PCI_IRQ_BUFFER_SIZE];
} ARBITER_EXTENSION, *PARBITER_EXTENSION;

typedef struct _VECTOR_BLOCK {
    union {
        struct {
            ULONG   Vector;
            UCHAR   Count;
            CHAR    TempCount;
            UCHAR   Flags;
            UCHAR   TempFlags;
        } Entry;
        struct {
            ULONG   Token;
            struct _VECTOR_BLOCK *Next;
        } Chain;
    };
} VECTOR_BLOCK, *PVECTOR_BLOCK;

#define TOKEN_VALUE 0x57575757
#define EMPTY_BLOCK_VALUE 0x58585858
#define VECTOR_HASH_TABLE_LENGTH 0x1f
#define VECTOR_HASH_TABLE_WIDTH 2
#define VECTOR_HASH_TABLE_SIZE (sizeof(VECTOR_BLOCK)            \
                                    * VECTOR_HASH_TABLE_LENGTH  \
                                    * VECTOR_HASH_TABLE_WIDTH)


NTSTATUS
AcpiInitIrqArbiter(
    PDEVICE_OBJECT  RootFdo
    );

NTSTATUS
AcpiArbInitializePciRouting(
    PDEVICE_OBJECT  PciPdo
    );

NTSTATUS
IrqArbRestoreIrqRouting(
    PFNACB      CompletionHandler,
    PVOID       CompletionContext
    );

extern ACPI_ARBITER    AcpiArbiter;
extern BOOLEAN PciInterfacesInstantiated;

#define PCI_PNP_ID "PNP0A03"
#define LINK_NODE_PNP_ID "PNP0C0F"

// Prototypes for stuff used by msi.c

NTSTATUS
GetVectorProperties(
    IN ULONG Vector,
    OUT UCHAR  *Flags
    );

NTSTATUS
AcpiArbGetLinkNodeOptions(
    IN PNSOBJ  LinkNode,
    IN OUT  PCM_RESOURCE_LIST   *LinkNodeIrqs,
    IN OUT  UCHAR               *Flags
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\irqarb.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    irqarb.c

Abstract:

    This module implements an arbiter for IRQs.

    In a traditional machine, the BIOS sets up the
    mapping of PCI interrupt sources (i.e. Bus 0, slot 4,
    funtion 1, INT B maps to IRQ 10.)  This mapping is
    then forever fixed.  On the other hand, an ACPI
    machine can possibly change these mappings by
    manipulating the "link nodes" in the AML namespace.
    Since the ACPI driver is the agent of change, it is the
    place to implement an arbiter.

Author:

    Jake Oshins (jakeo)     6-2-97

Environment:

    NT Kernel Model Driver only

Revision History:

--*/
#include "pch.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"

#if DBG
extern LONG ArbDebugLevel;

#define DEBUG_PRINT(Level, Message) \
    if (ArbDebugLevel >= Level) DbgPrint Message
#else
#define DEBUG_PRINT(Level, Message)
#endif

#define PciBridgeSwizzle(device, pin)       \
    ((((pin - 1) + (device % 4)) % 4) + 1)

NTSTATUS
AcpiArbUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
AcpiArbPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

LONG
AcpiArbScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
AcpiArbUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );

NTSTATUS
AcpiArbTestAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

NTSTATUS
AcpiArbBootAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

NTSTATUS
AcpiArbRetestAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

NTSTATUS
AcpiArbRollbackAllocation(
    PARBITER_INSTANCE Arbiter
    );

NTSTATUS
AcpiArbCommitAllocation(
    PARBITER_INSTANCE Arbiter
    );

BOOLEAN
AcpiArbGetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
AcpiArbCrackPRT(
    IN  PDEVICE_OBJECT  Pdo,
    IN  OUT PNSOBJ      *LinkNode,
    IN  OUT ULONG       *Vector
    );

PDEVICE_OBJECT
AcpiGetFilter(
    IN  PDEVICE_OBJECT Root,
    IN  PDEVICE_OBJECT Pdo
    );

BOOLEAN
ArbFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
AcpiArbFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

VOID
AcpiArbAddAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );

VOID
AcpiArbBacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );

BOOLEAN
AcpiArbOverrideConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
LinkNodeInUse(
    IN PARBITER_INSTANCE Arbiter,
    IN PNSOBJ            LinkNode,
    IN OUT ULONG         *Irq,  OPTIONAL
    IN OUT UCHAR         *Flags OPTIONAL
    );

NTSTATUS
AcpiArbReferenceLinkNode(
    IN PARBITER_INSTANCE    Arbiter,
    IN PNSOBJ               LinkNode,
    IN ULONG                Irq
    );

NTSTATUS
AcpiArbDereferenceLinkNode(
    IN PARBITER_INSTANCE    Arbiter,
    IN PNSOBJ               LinkNode
    );

NTSTATUS
AcpiArbSetLinkNodeIrq(
    IN PNSOBJ  LinkNode,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  LinkNodeIrq
    );

NTSTATUS
EXPORT
AcpiArbSetLinkNodeIrqWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

NTSTATUS
AcpiArbSetLinkNodeIrqAsync(
    IN PNSOBJ                           LinkNode,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  LinkNodeIrq,
    IN PFNACB                           CompletionHandler,
    IN PVOID                            CompletionContext
    );

NTSTATUS
AcpiArbPreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
AcpiArbQueryConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PIO_RESOURCE_DESCRIPTOR ConflictingResource,
    OUT PULONG ConflictCount,
    OUT PARBITER_CONFLICT_INFO *Conflicts
    );

NTSTATUS
EXPORT
IrqArbRestoreIrqRoutingWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

NTSTATUS
DisableLinkNodesAsync(
    IN PNSOBJ    Root,
    IN PFNACB    CompletionHandler,
    IN PVOID     CompletionContext
    );

NTSTATUS
EXPORT
DisableLinkNodesAsyncWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

NTSTATUS
UnreferenceArbitrationList(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

NTSTATUS
ClearTempLinkNodeCounts(
    IN PARBITER_INSTANCE    Arbiter
    );

NTSTATUS
MakeTempLinkNodeCountsPermanent(
    IN PARBITER_INSTANCE    Arbiter
    );

PVECTOR_BLOCK
HashVector(
    IN ULONG Vector
    );

NTSTATUS
AddVectorToTable(
    IN ULONG    Vector,
    IN UCHAR    ReferenceCount,
    IN UCHAR    TempRefCount,
    IN UCHAR    Flags
    );

VOID
ClearTempVectorCounts(
    VOID
    );

VOID
MakeTempVectorCountsPermanent(
    VOID
    );

VOID
DumpVectorTable(
    VOID
    );

VOID
DereferenceVector(
    IN ULONG Vector
    );

VOID
ReferenceVector(
    IN ULONG Vector,
    IN UCHAR Flags
    );

NTSTATUS
LookupIsaVectorOverride(
    IN ULONG IsaVector,
    IN OUT ULONG *RedirectionVector OPTIONAL,
    IN OUT UCHAR *Flags OPTIONAL
    );

NTSTATUS
GetLinkNodeFlags(
    IN PARBITER_INSTANCE Arbiter,
    IN PNSOBJ LinkNode,
    IN OUT UCHAR *Flags
    );

NTSTATUS
GetIsaVectorFlags(
    IN ULONG        Vector,
    IN OUT UCHAR    *Flags
    );

VOID
TrackDevicesConnectedToLinkNode(
    IN PNSOBJ LinkNode,
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
FindVectorInAlternatives(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State,
    IN ULONGLONG Vector,
    OUT ULONG *Alternative
    );

NTSTATUS
FindBootConfig(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State,
    IN ULONGLONG *Vector
    );

//
// The following is a hash table.  It is VECTOR_HASH_TABLE_LENGTH entries
// long and VECTOR_HASH_TABLE_WIDTH entries wide.  We hash on the numerical
// value of the IRQ modulo the length of the table.  We look across the
// table until we find the entry that matches the vector.  If we get to
// the end of the row and find an entry marked with TOKEN_VALUE, we follow
// the pointer to an extension of this row in the table.
//
// ---------------------------------------------------------------------
//| (IRQ number, ref counts, flags)  | (IRQ number, ref counts, flags)
//| (IRQ number, ref counts, flags)  | (IRQ number, ref counts, flags)
//| (IRQ number, ref counts, flags)  | (TOKEN_VALUE, pointer to new table row)
//| (IRQ number, ref counts, flags)  | (unused entry (0))
//| (IRQ number, ref counts, flags)  | (IRQ number, ref counts, flags)
//----------------------------------------------------------------------
//
// New table row, pointed to by pointer following TOKEN_VALUE:
//
//----------------------------------------------------------
//| (IRQ number, ref counts, flags)  | (unused entry (0))
//----------------------------------------------------------
//

#define HASH_ENTRY(x, y)                \
    (IrqHashTable + (x * VECTOR_HASH_TABLE_WIDTH) + y)

PVECTOR_BLOCK IrqHashTable;
ULONG   InterruptModel = 0;
ULONG   AcpiSciVector;
UCHAR   AcpiIrqDefaultBootConfig = 0;
UCHAR   AcpiArbPciAlternativeRotation = 0;
BOOLEAN AcpiArbCardbusPresent = FALSE;

enum {
    AcpiIrqDistributionDispositionDontCare = 0,
    AcpiIrqDistributionDispositionSpreadOut,
    AcpiIrqDistributionDispositionStackUp
} AcpiIrqDistributionDisposition = 0;

typedef enum {
    AcpiIrqNextRangeMinState = 0xfff,
    AcpiIrqNextRangeInit,
    AcpiIrqNextRangeInitPolicyNeutral,
    AcpiIrqNextRangeInitPic,
    AcpiIrqNextRangeInitLegacy,
    AcpiIrqNextRangeBootRegAlternative,
    AcpiIrqNextRangeSciAlternative,
    AcpiIrqNextRangeUseBootConfig,
    AcpiIrqNextRangeAlternativeZero,
    AcpiIrqNextRangeAlternativeN,
    AcpiIrqNextRangeMaxState
} NEXT_RANGE_STATE, *PNEXT_RANGE_STATE;

#define ARBITER_INTERRUPT_LEVEL_SENSATIVE   0x10
#define ARBITER_INTERRUPT_LATCHED           0x20
#define ARBITER_INTERRUPT_BITS (ARBITER_INTERRUPT_LATCHED | ARBITER_INTERRUPT_LEVEL_SENSATIVE)

#define ISA_PIC_VECTORS 16
#define ALTERNATIVE_SHUFFLE_SIZE 0x10

extern BOOLEAN AcpiInterruptRoutingFailed;
extern PACPIInformation AcpiInformation;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AcpiInitIrqArbiter)
#pragma alloc_text(PAGE, AcpiArbInitializePciRouting)
#pragma alloc_text(PAGE, AcpiArbUnpackRequirement)
#pragma alloc_text(PAGE, AcpiArbPackResource)
#pragma alloc_text(PAGE, AcpiArbScoreRequirement)
#pragma alloc_text(PAGE, AcpiArbUnpackResource)
#pragma alloc_text(PAGE, AcpiArbFindSuitableRange)
#pragma alloc_text(PAGE, AcpiArbAddAllocation)
#pragma alloc_text(PAGE, AcpiArbBacktrackAllocation)
#pragma alloc_text(PAGE, AcpiArbGetLinkNodeOptions)
#pragma alloc_text(PAGE, AcpiArbTestAllocation)
#pragma alloc_text(PAGE, AcpiArbBootAllocation)
#pragma alloc_text(PAGE, AcpiArbRetestAllocation)
#pragma alloc_text(PAGE, AcpiArbRollbackAllocation)
#pragma alloc_text(PAGE, AcpiArbCommitAllocation)
#pragma alloc_text(PAGE, AcpiArbReferenceLinkNode)
#pragma alloc_text(PAGE, AcpiArbDereferenceLinkNode)
#pragma alloc_text(PAGE, AcpiArbSetLinkNodeIrq)
#pragma alloc_text(PAGE, AcpiArbPreprocessEntry)
#pragma alloc_text(PAGE, AcpiArbOverrideConflict)
#pragma alloc_text(PAGE, AcpiArbQueryConflict)
#pragma alloc_text(PAGE, AcpiArbGetNextAllocationRange)
#pragma alloc_text(PAGE, LinkNodeInUse)
#pragma alloc_text(PAGE, GetLinkNodeFlags)
#pragma alloc_text(PAGE, UnreferenceArbitrationList)
#pragma alloc_text(PAGE, ClearTempLinkNodeCounts)
#pragma alloc_text(PAGE, MakeTempLinkNodeCountsPermanent)
#pragma alloc_text(PAGE, HashVector)
#pragma alloc_text(PAGE, GetVectorProperties)
#pragma alloc_text(PAGE, AddVectorToTable)
#pragma alloc_text(PAGE, ReferenceVector)
#pragma alloc_text(PAGE, DereferenceVector)
#pragma alloc_text(PAGE, ClearTempVectorCounts)
#pragma alloc_text(PAGE, MakeTempVectorCountsPermanent)
#pragma alloc_text(PAGE, TrackDevicesConnectedToLinkNode)
#pragma alloc_text(PAGE, LookupIsaVectorOverride)
#pragma alloc_text(PAGE, GetIsaVectorFlags)
#pragma alloc_text(PAGE, FindVectorInAlternatives)
#pragma alloc_text(PAGE, FindBootConfig)
#endif


NTSTATUS
AcpiInitIrqArbiter(
    PDEVICE_OBJECT  RootFdo
    )
{
    AMLISUPP_CONTEXT_PASSIVE    context;
    PARBITER_EXTENSION  arbExt;
    NTSTATUS            status;
    ULONG               rawVector, adjVector, level;
    UCHAR               flags;
    UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG  pciData;
    BOOLEAN             foundBootConfig, noBootConfigAgreement;
    ULONG               deviceNum, funcNum;
    UCHAR               lastBus, currentBus;
    PCI_SLOT_NUMBER     pciSlot;
    UNICODE_STRING      driverKey;
    HANDLE              driverKeyHandle = NULL;
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  regValue=NULL;

    PAGED_CODE();

    //
    // Set up arbiter.
    //

    arbExt = ExAllocatePoolWithTag(NonPagedPool, sizeof(ARBITER_EXTENSION), ACPI_ARBITER_POOLTAG);

    if (!arbExt) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(arbExt, sizeof(ARBITER_EXTENSION));

    InitializeListHead(&(arbExt->LinkNodeHead));

    AcpiArbiter.ArbiterState.Extension = arbExt;

    AcpiArbiter.DeviceObject = RootFdo;
    AcpiArbiter.ArbiterState.UnpackRequirement   = AcpiArbUnpackRequirement;
    AcpiArbiter.ArbiterState.PackResource        = AcpiArbPackResource;
    AcpiArbiter.ArbiterState.UnpackResource      = AcpiArbUnpackResource;
    AcpiArbiter.ArbiterState.ScoreRequirement    = AcpiArbScoreRequirement;
    AcpiArbiter.ArbiterState.FindSuitableRange   = AcpiArbFindSuitableRange;
    AcpiArbiter.ArbiterState.TestAllocation      = AcpiArbTestAllocation;
    AcpiArbiter.ArbiterState.BootAllocation      = AcpiArbBootAllocation;
    AcpiArbiter.ArbiterState.RetestAllocation    = AcpiArbRetestAllocation;
    AcpiArbiter.ArbiterState.RollbackAllocation  = AcpiArbRollbackAllocation;
    AcpiArbiter.ArbiterState.CommitAllocation    = AcpiArbCommitAllocation;
    AcpiArbiter.ArbiterState.AddAllocation       = AcpiArbAddAllocation;
    AcpiArbiter.ArbiterState.BacktrackAllocation = AcpiArbBacktrackAllocation;
    AcpiArbiter.ArbiterState.PreprocessEntry     = AcpiArbPreprocessEntry;
    AcpiArbiter.ArbiterState.OverrideConflict    = AcpiArbOverrideConflict;
    AcpiArbiter.ArbiterState.QueryConflict       = AcpiArbQueryConflict;
    AcpiArbiter.ArbiterState.GetNextAllocationRange = AcpiArbGetNextAllocationRange;

    IrqHashTable = ExAllocatePoolWithTag(PagedPool,
                                         VECTOR_HASH_TABLE_SIZE,
                                         ACPI_ARBITER_POOLTAG
                                         );

    if (!IrqHashTable) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto AcpiInitIrqArbiterError;
    }

    RtlFillMemory(IrqHashTable,
                  VECTOR_HASH_TABLE_SIZE,
                  (UCHAR)(EMPTY_BLOCK_VALUE & 0xff));

    //
    // Do the generic part of initialization.
    //
    status = ArbInitializeArbiterInstance(&AcpiArbiter.ArbiterState,
                                          RootFdo,
                                          CmResourceTypeInterrupt,
                                          L"ACPI_IRQ",
                                          L"Root",
                                          NULL
                                          );
    if (!NT_SUCCESS(status)) {
        status = STATUS_UNSUCCESSFUL;
        goto AcpiInitIrqArbiterError;
    }

    //
    // Now claim the IRQ that ACPI itself is using.
    //

    rawVector = AcpiInformation->FixedACPIDescTable->sci_int_vector;

    //
    // Assume that the ACPI vector is active low,
    // level triggered.  (This may be changed
    // by the MAPIC table.)
    //

    flags = VECTOR_LEVEL | VECTOR_ACTIVE_LOW;

    adjVector = rawVector;
    LookupIsaVectorOverride(adjVector,
                            &adjVector,
                            &flags);

    RtlAddRange(AcpiArbiter.ArbiterState.Allocation,
                (ULONGLONG)adjVector,
                (ULONGLONG)adjVector,
                0,
                RTL_RANGE_LIST_ADD_SHARED,
                NULL,
                ((PDEVICE_EXTENSION)RootFdo->DeviceExtension)->PhysicalDeviceObject
                );

    //
    // Record the status for this vector
    //

    ReferenceVector(adjVector,
                    flags);

    AcpiSciVector = adjVector;

    MakeTempVectorCountsPermanent();

    //
    // Disable all the link nodes in the namespace so that we
    // have a fresh slate to work with.
    //

    KeInitializeEvent(&context.Event, SynchronizationEvent, FALSE);
    context.Status = STATUS_UNSUCCESSFUL;

    status = DisableLinkNodesAsync(((PDEVICE_EXTENSION)RootFdo->DeviceExtension)->AcpiObject,
                                   AmlisuppCompletePassive,
                                   (PVOID)&context);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&context.Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = context.Status;
    }

    //
    // Scan the machine looking at its initial configuration.  If
    // it a) has a cardbus controller and b) all the boot configs
    // for PCI devices are the same, then record that boot config
    // vector for use in AcpiArbGetNextAllocationRange.
    //
    // Note:  This algorithm only scans the first PCI root and
    // its children.  The assumption is that multiple root machines
    // will be running in APIC mode or have many different boot
    // configs.
    //

    pciData = (PPCI_COMMON_CONFIG)buffer;
    lastBus = 0;
    currentBus = 0;
    foundBootConfig = FALSE;
    noBootConfigAgreement = FALSE;

    while (TRUE) {

        pciSlot.u.AsULONG = 0;

        for (deviceNum = 0; deviceNum < PCI_MAX_DEVICES; deviceNum++) {
            for (funcNum = 0; funcNum < PCI_MAX_FUNCTION; funcNum++) {

                pciSlot.u.bits.DeviceNumber = deviceNum;
                pciSlot.u.bits.FunctionNumber = funcNum;

                HalPciInterfaceReadConfig(NULL,
                                          currentBus,
                                          pciSlot.u.AsULONG,
                                          pciData,
                                          0,
                                          PCI_COMMON_HDR_LENGTH);

                if (pciData->VendorID != PCI_INVALID_VENDORID) {

                    if (PCI_CONFIGURATION_TYPE(pciData) == PCI_DEVICE_TYPE) {

                        if (pciData->u.type0.InterruptPin) {

                            //
                            // This device generates an interrupt.
                            //

                            if ((pciData->u.type0.InterruptLine > 0) &&
                                (pciData->u.type0.InterruptLine < 0xff)) {

                                //
                                // And it has a boot config.
                                //

                                if (foundBootConfig) {

                                    if (pciData->u.type0.InterruptLine != AcpiIrqDefaultBootConfig) {

                                        noBootConfigAgreement = TRUE;
                                        break;
                                    }

                                } else {

                                    //
                                    // Record this boot config
                                    //

                                    AcpiIrqDefaultBootConfig = pciData->u.type0.InterruptLine;
                                    foundBootConfig = TRUE;
                                }
                            }
                        }

                    } else {

                        //
                        // This is a bridge.  Update lastBus with the Subordinate
                        // bus if it is higher.
                        //

                        lastBus = lastBus > pciData->u.type1.SubordinateBus ?
                            lastBus : pciData->u.type1.SubordinateBus;

                        if (PCI_CONFIGURATION_TYPE(pciData) == PCI_CARDBUS_BRIDGE_TYPE) {
                            AcpiArbCardbusPresent = TRUE;
                        }
                    }

                    if (!PCI_MULTIFUNCTION_DEVICE(pciData) &&
                        (funcNum == 0)) {
                        break;
                    }

                } else {
                    break;
                }
            }
        }

        if (lastBus == currentBus++) {
            break;
        }
    }

    if (!foundBootConfig ||
        noBootConfigAgreement ||
        !AcpiArbCardbusPresent) {

        //
        // There is no single default boot config.
        //

        AcpiIrqDefaultBootConfig = 0;
    }

    //
    // Now look in the registry for configuration flags.
    //

    RtlInitUnicodeString( &driverKey,
       L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ACPI\\Parameters");


    status = OSOpenUnicodeHandle(
      &driverKey,
      NULL,
      &driverKeyHandle);

    if (NT_SUCCESS(status)) {

        status = OSGetRegistryValue(
           driverKeyHandle,
           L"IRQDistribution",
           &regValue);

        if (NT_SUCCESS(status)) {

            if ((regValue->DataLength != 0) &&
                (regValue->Type == REG_DWORD)) {

                //
                // We have successfully found the key for
                // IRQ Distribution Disposition.
                //

                AcpiIrqDistributionDisposition =
                    *((ULONG*)( ((PUCHAR)regValue->Data)));
            }

            ExFreePool(regValue);
        }

        status = OSGetRegistryValue(
           driverKeyHandle,
           L"ForcePCIBootConfig",
           &regValue);

        if (NT_SUCCESS(status)) {

            if ((regValue->DataLength != 0) &&
                (regValue->Type == REG_DWORD)) {

                //
                // We have successfully found the key for
                // PCI Boot Configs.
                //

                AcpiIrqDefaultBootConfig =
                    *(PUCHAR)regValue->Data;
            }

            ExFreePool(regValue);
        }

        OSCloseHandle(driverKeyHandle);
    }

    return STATUS_SUCCESS;

AcpiInitIrqArbiterError:

    if (arbExt) ExFreePool(arbExt);
    if (IrqHashTable) ExFreePool(IrqHashTable);
    if (driverKeyHandle) OSCloseHandle(driverKeyHandle);
    if (regValue) ExFreePool(regValue);

    return status;
}

NTSTATUS
AcpiArbInitializePciRouting(
    PDEVICE_OBJECT  PciPdo
    )
{
    PINT_ROUTE_INTERFACE_STANDARD interface;
    NTSTATUS            status;
    IO_STACK_LOCATION   irpSp;
    PWSTR               buffer;
    PDEVICE_OBJECT      topDeviceInStack;

    PAGED_CODE();

    //
    // Send an IRP to the PCI driver to get the Interrupt Routing Interface.
    //

    RtlZeroMemory( &irpSp, sizeof(IO_STACK_LOCATION) );

    interface = ExAllocatePoolWithTag(NonPagedPool, sizeof(INT_ROUTE_INTERFACE_STANDARD), ACPI_ARBITER_POOLTAG);

    if (!interface) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    topDeviceInStack = IoGetAttachedDeviceReference(PciPdo);

    //
    // Set the function codes and parameters.
    //
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_INT_ROUTE_INTERFACE_STANDARD;
    irpSp.Parameters.QueryInterface.Version = PCI_INT_ROUTE_INTRF_STANDARD_VER;
    irpSp.Parameters.QueryInterface.Size = sizeof (INT_ROUTE_INTERFACE_STANDARD);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) interface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Call the PCI driver (indirectly.)
    //

    status = ACPIInternalSendSynchronousIrp(topDeviceInStack,
                                            &irpSp,
                                            &buffer);

    if (NT_SUCCESS(status)) {

        //
        // Attach this interface to the Arbiter Extension.
        //
        ((PARBITER_EXTENSION)AcpiArbiter.ArbiterState.Extension)->InterruptRouting = interface;

        //
        // Reference it.
        //
        interface->InterfaceReference(interface->Context);

        PciInterfacesInstantiated = TRUE;

    } else {

        ExFreePool(interface);
    }

    ObDereferenceObject(topDeviceInStack);
    return status;
}


//
// Arbiter callbacks
//

NTSTATUS
AcpiArbUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )
{
    PAGED_CODE();

    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    *Minimum = (ULONGLONG) Descriptor->u.Interrupt.MinimumVector;
    *Maximum = (ULONGLONG) Descriptor->u.Interrupt.MaximumVector;
    *Length = 1;
    *Alignment = 1;

    return STATUS_SUCCESS;

}

LONG
AcpiArbScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )
{
    LONG score;

    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    //
    // TEMPTEMP HACKHACK
    // (Possibly) temporary hack that allows the PnP
    // manager to include invalid resources in the
    // arbitration list.
    //
    if (Descriptor->u.Interrupt.MinimumVector >
             Descriptor->u.Interrupt.MaximumVector) {

        return 0;
    }

    ASSERT(Descriptor->u.Interrupt.MinimumVector <=
             Descriptor->u.Interrupt.MaximumVector);

    score = Descriptor->u.Interrupt.MaximumVector -
        Descriptor->u.Interrupt.MinimumVector + 1;

    //
    // Give a little boost to any request above the
    // traditional ISA range.
    // N.B.  This will probably never matter, as
    // most machines will present all the choices
    // either inside or outside of the ISA range.
    //
    if (Descriptor->u.Interrupt.MaximumVector >= 16) {
        score += 5;
    }

    return score;
}

NTSTATUS
AcpiArbPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )
{
    PAGED_CODE();

    ASSERT(Descriptor);
    ASSERT(Start < ((ULONG)-1));
    ASSERT(Requirement);
    ASSERT(Requirement->Type == CmResourceTypeInterrupt);

    Descriptor->Type = CmResourceTypeInterrupt;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->u.Interrupt.Vector = (ULONG) Start;
    Descriptor->u.Interrupt.Level = (ULONG) Start;
    Descriptor->u.Interrupt.Affinity = 0xFFFFFFFF;

    return STATUS_SUCCESS;
}

NTSTATUS
AcpiArbUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )
{

    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    *Start = Descriptor->u.Interrupt.Vector;
    *Length = 1;

    return STATUS_SUCCESS;

}

BOOLEAN
AcpiArbOverrideConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
{
    //
    // Self-conflicts are not allowable with this arbiter.
    //

    PAGED_CODE();
    return FALSE;
}


NTSTATUS
AcpiArbPreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine is called from AllocateEntry to allow preprocessing of
    entries

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    None.

--*/
{

#define CM_RESOURE_INTERRUPT_LEVEL_LATCHED_BITS 0x0001

    PARBITER_ALTERNATIVE current;
    USHORT flags;


    PAGED_CODE();

    //
    // Check if this is a level (PCI) or latched (ISA) interrupt and set
    // RangeAttributes accordingly so we set the appropriate flag when we add the
    // range
    //

    if ((State->Alternatives[0].Descriptor->Flags
            & CM_RESOURE_INTERRUPT_LEVEL_LATCHED_BITS)
                == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {

        State->RangeAttributes &= ~ARBITER_INTERRUPT_BITS;
        State->RangeAttributes |= ARBITER_INTERRUPT_LEVEL_SENSATIVE;
        flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;

    } else {

        ASSERT(State->Alternatives[0].Descriptor->Flags
                    & CM_RESOURCE_INTERRUPT_LATCHED);

        State->RangeAttributes &= ~ARBITER_INTERRUPT_BITS;
        State->RangeAttributes |= ARBITER_INTERRUPT_LATCHED;
        flags = CM_RESOURCE_INTERRUPT_LATCHED;
    }

#if 0

    //
    // Make sure that all the alternatives are of the same type
    //

    FOR_ALL_IN_ARRAY(State->Alternatives,
                     State->Entry->AlternativeCount,
                     current) {

        ASSERT((current->Descriptor->Flags
                    & CM_RESOURE_INTERRUPT_LEVEL_LATCHED_BITS) == flags);
    }

#endif

    return STATUS_SUCCESS;
}


BOOLEAN
AcpiArbFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine finds an IRQ for a device object. For
    non-PCI devices, this is as simple as returning the
    result from PnpFindSuitableRange.  For PCI devices,
    this is done by examining the state of the "link
    nodes" described in the ACPI namespace.

Arguments:

    Arbiter - the ACPI IRQ arbiter
    State   - the current allocation under consideration

Return Value:

    TRUE if a suitable vector  has been found,
    FALSE otherwise.

Notes:

    Statement of algorithm for PCI devices:

    1) Find the entry in the _PRT that corresponds
       to the device for which we are arbitrating
       resources.

    2) Determine, from the _PRT information, whether
       this device is connected to a "link node."
       (A PCI device will typically be connected to
        a link node while in PIC mode but not in
       APIC mode.)

    3) If it is not, use the static mapping from the
       _PRT.

    4) If it is connected to a "link node," check
       to see if the "link node" is in use.

    5) If the link node is in use, then this
       device must use the same IRQ that the link node is currently
       using.  This implies that there is already
       some other device in the system connected to
       this interrupt and now the two (or more) will
       be sharing.  This is acceptable and inevitable.
       Two devices that have their interrupt lines
       wire-or'd should be sharing.  Two devices that
       don't have their interrupt lines wire-or'd
       should be represented by separate link nodes
       in the namespace.


    6) If the link node is not in use, pick an IRQ
       from the list that the link node can support
       and grant it to the device.  There is some
       attempt to pick an IRQ that is not currently
       in use.
--*/
{

    PCM_PARTIAL_RESOURCE_DESCRIPTOR     potentialIrq;
    PIO_RESOURCE_DESCRIPTOR             alternative;
    PARBITER_EXTENSION                  arbExtension;
    PCM_RESOURCE_LIST                   linkNodeResList = NULL;
    NTSTATUS    status;
    BOOLEAN     possibleAllocation;
    PNSOBJ      linkNode = NULL;
    ULONG       deviceIrq = 0;
    ULONG       linkNodeIrqCount, i;
    UCHAR       vectorFlags, deviceFlags;

    PAGED_CODE();

    arbExtension = (PARBITER_EXTENSION)Arbiter->Extension;
    ASSERT(arbExtension);

    //
    // First, see if this resource could even be made to work at all.
    // (I.e.  Has something already claimed this as non-sharable?)
    //

    possibleAllocation = ArbFindSuitableRange(Arbiter, State);

    if (!possibleAllocation) {
        return FALSE;
    }

    //
    // Is this Device connected to a link node?
    //

    status = AcpiArbCrackPRT(State->Entry->PhysicalDeviceObject,
                             &linkNode,
                             &deviceIrq);

    //
    // If this PDO is connected to a link node, we want to clip
    // the list of possible IRQ settings down.
    //
    switch (status) {
    case STATUS_SUCCESS:

        //
        // AcpiArbCrackPRT fills in either linkNode or deviceIrq.
        // If linkNode is filled in, then we need to look at it.
        // If deviceIrq is filled in, then we only need to clip
        // the list to that single IRQ.
        //
        if (linkNode) {

            //
            // If the link node is currently in use, then we can
            // just connect this device to the IRQ that the link
            // node is currently using.
            //
            if (LinkNodeInUse(Arbiter, linkNode, &deviceIrq, NULL)) {

                if ((State->CurrentMinimum <= deviceIrq) &&
                    (State->CurrentMaximum >= deviceIrq)) {

                    State->Start = deviceIrq;
                    State->End   = deviceIrq;
                    State->CurrentAlternative->Length = 1;

                    DEBUG_PRINT(1, ("FindSuitableRange found %x from a link node that is in use.\n",
                         (ULONG)(State->Start & 0xffffffff)));
                    ASSERT(HalIsVectorValid(deviceIrq));
                    return TRUE;

                } else {
                    DEBUG_PRINT(1, ("FindSuitableRange found %x from a link node that is in use.\n",
                                    deviceIrq));
                    DEBUG_PRINT(1, (" This was, however, not within the range of possibilites (%x-%x).\n",
                                    (ULONG)(State->Start & 0xffffffff),
                                    (ULONG)(State->End & 0xffffffff)));
                    return FALSE;
                }

            } else {

                //
                // Get the set of IRQs that this link node can
                // connect to.
                //

                status = AcpiArbGetLinkNodeOptions(linkNode,
                                                   &linkNodeResList,
                                                   &deviceFlags);

                DEBUG_PRINT(1, ("Link node contained CM(%p)\n", linkNodeResList));

                if (NT_SUCCESS(status)) {

                    ASSERT(linkNodeResList->Count == 1);

                    linkNodeIrqCount =
                        linkNodeResList->List[0].PartialResourceList.Count;


                    for (i = 0; i < linkNodeIrqCount; i++) {

                        potentialIrq =
                            &(linkNodeResList->List[0].PartialResourceList.PartialDescriptors[(i + AcpiArbPciAlternativeRotation) % linkNodeIrqCount]);

                        ASSERT(potentialIrq->Type == CmResourceTypeInterrupt);

                        //
                        // Check for a conflict in mode.
                        //
                        status = GetVectorProperties(potentialIrq->u.Interrupt.Vector,
                                                     &vectorFlags);

                        if (NT_SUCCESS(status)) {

                            //
                            // Success here means that this vector is currently allocated
                            // to somebody.  Check to see whether the link node being
                            // considered has the same mode and polarity as the other
                            // thing(s) assigned to this vector.
                            //

                            if (deviceFlags != vectorFlags) {

                                //
                                // The flags don't match.  So skip this possibility.
                                //

                                continue;
                            }
                        }

                        if ((potentialIrq->u.Interrupt.Vector >= State->CurrentMinimum) &&
                            (potentialIrq->u.Interrupt.Vector <= State->CurrentMaximum)) {

                            if (!HalIsVectorValid(potentialIrq->u.Interrupt.Vector)) {
                                deviceIrq = potentialIrq->u.Interrupt.Vector;
                                ExFreePool(linkNodeResList);
                                goto FindSuitableRangeError;
                            }

                            State->Start = potentialIrq->u.Interrupt.Vector;
                            State->End   = potentialIrq->u.Interrupt.Vector;
                            State->CurrentAlternative->Length = 1;

                            DEBUG_PRINT(1, ("FindSuitableRange found %x from an unused link node.\n",
                                     (ULONG)(State->Start & 0xffffffff)));

                            ExFreePool(linkNodeResList);

                            //
                            // Record the link node that we got this from.
                            //

                            arbExtension->CurrentLinkNode = linkNode;

                            //
                            // Record this as the last PCI IRQ that we are handing out.
                            //

                            arbExtension->LastPciIrq[arbExtension->LastPciIrqIndex] =
                                State->Start;

                            arbExtension->LastPciIrqIndex =
                                (arbExtension->LastPciIrqIndex + 1) % LAST_PCI_IRQ_BUFFER_SIZE;

                            return TRUE;
                        }
                    }

                    ExFreePool(linkNodeResList);
                }

                DEBUG_PRINT(1, ("FindSuitableRange: AcpiArbGetLinkNodeOptions returned %x.\n\tlinkNodeResList: %p\n",
                         status, linkNodeResList));
                // We didn't find a match.
                return FALSE;
            }

        } else {

            //
            // This is the case where the _PRT contains a static mapping.  Static
            // Mappings imply active-low, level-triggered interrupts.
            //

            status = GetVectorProperties(deviceIrq,
                                         &vectorFlags);
            if (NT_SUCCESS(status)) {

                //
                // The vector is in use.
                //

                if (((vectorFlags & VECTOR_MODE) != VECTOR_LEVEL) ||
                    ((vectorFlags & VECTOR_POLARITY) != VECTOR_ACTIVE_LOW)) {

                    //
                    // And it's flags don't match.
                    //
                    return FALSE;
                }

            }

            // Valid static vector

            if ((State->CurrentMinimum <= deviceIrq) &&
                (State->CurrentMaximum >= deviceIrq)) {

                DEBUG_PRINT(1, ("FindSuitableRange found %x from a static mapping.\n",
                     (ULONG)(State->Start & 0xffffffff)));

                if (!HalIsVectorValid(deviceIrq)) {
                    goto FindSuitableRangeError;
                }

                State->Start = deviceIrq;
                State->End   = deviceIrq;
                State->CurrentAlternative->Length = 1;

                return TRUE;

            } else {
                return FALSE;
            }
        }

        break;

    case STATUS_UNSUCCESSFUL:

        return FALSE;
        break;

    case STATUS_RESOURCE_REQUIREMENTS_CHANGED:

        //
        // Fall through to default.
        //

    default:

        //
        // Not PCI.
        //

        for (deviceIrq = (ULONG)(State->Start & 0xffffffff);
             deviceIrq <= (ULONG)(State->End & 0xffffffff); deviceIrq++) {

            status = GetIsaVectorFlags((ULONG)deviceIrq,
                                   &deviceFlags);

            if (!NT_SUCCESS(status)) {

               //
               // Not overridden.  Assume that the device flags conform to bus.
               //

               deviceFlags = (State->CurrentAlternative->Descriptor->Flags
                   == CM_RESOURCE_INTERRUPT_LATCHED) ?
                  VECTOR_EDGE | VECTOR_ACTIVE_HIGH :
                  VECTOR_LEVEL | VECTOR_ACTIVE_LOW;

            }

            status = GetVectorProperties((ULONG)deviceIrq,
                                     &vectorFlags);
            if (NT_SUCCESS(status)) {

               //
               // This vector is currently in use.  So if this is to be a suitable
               // range, then the flags must match.
               //

               if (deviceFlags != vectorFlags) {
                   continue;
               }
            }

            if (!HalIsVectorValid(deviceIrq)) {
                goto FindSuitableRangeError;
            }

            State->Start = deviceIrq;
            State->End   = deviceIrq;
            State->CurrentAlternative->Length = 1;

            return TRUE;
        }

        return FALSE;
    }

    return FALSE;

FindSuitableRangeError:

    {
        UNICODE_STRING  vectorName;
        PWCHAR  prtEntry[2];
        WCHAR   IRQARBname[20];
        WCHAR   vectorBuff[10];

        //
        // Make an errorlog entry saying that the chosen IRQ doesn't
        // exist.
        //

        swprintf( IRQARBname, L"IRQARB");
        RtlInitUnicodeString(&vectorName, vectorBuff);

        if (!NT_SUCCESS(RtlIntegerToUnicodeString(deviceIrq, 0, &vectorName))) {
            return FALSE;
        }

        prtEntry[0] = IRQARBname;
        prtEntry[1] = vectorBuff;

        ACPIWriteEventLogEntry(ACPI_ERR_ILLEGAL_IRQ_NUMBER,
                               &prtEntry,
                               2,
                               NULL,
                               0);
    }

    return FALSE;
}

VOID
AcpiArbAddAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     )
{
    NTSTATUS status;
    PNSOBJ linkNode;
    ULONG sourceIndex;
    ULONG rangeFlags = 0;
    PVOID referencedNode = NULL;
    UCHAR flags, previousFlags;
    ROUTING_TOKEN token;
    BOOLEAN inUse;
    UCHAR   attributes = 0;

    PAGED_CODE();
    ASSERT(State->CurrentAlternative->Descriptor->Type == CmResourceTypeInterrupt);

    DEBUG_PRINT(1, ("Adding allocation for IRQ %x for device %p\n",
                    (ULONG)(State->Start & 0xffffffff),
                    State->Entry->PhysicalDeviceObject));

    //
    // Identify the potential link node.
    //

    status = AcpiArbCrackPRT(State->Entry->PhysicalDeviceObject,
                             &linkNode,
                             &sourceIndex);

    if (NT_SUCCESS(status)) {

        //
        // PCI device.  Default flags are standard for PCI.
        //

        flags = VECTOR_LEVEL | VECTOR_ACTIVE_LOW;
        ASSERT(State->Start == State->End);

        if (!(State->Flags & ARBITER_STATE_FLAG_BOOT)) {

            //
            // Only keep track of link nodes manipulation if this is not
            // a boot config allocation.
            //

            //
            // If this device is connected to a link node, reference it.
            //

            if (linkNode) {

               AcpiArbReferenceLinkNode(Arbiter,
                                        linkNode,
                                        (ULONG)State->Start);

               referencedNode = (PVOID)linkNode;

               //
               // Find out what the flags for this link node are.
               // Note that this is only guaranteed to be valid
               // after we have referenced the link node.
               //

               inUse = LinkNodeInUse(Arbiter,
                                     linkNode,
                                     NULL,
                                     &flags);

               ASSERT(inUse);
               ASSERT((flags & ~(VECTOR_MODE | VECTOR_POLARITY | VECTOR_TYPE)) == 0);
               ASSERT(State->CurrentAlternative->Descriptor->Flags
                       == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE ?
                       (flags & VECTOR_MODE) == VECTOR_LEVEL :
                       (flags & VECTOR_MODE) == VECTOR_EDGE);


#if DBG
               TrackDevicesConnectedToLinkNode(linkNode,
                                               State->Entry->PhysicalDeviceObject);

               status = GetVectorProperties((ULONG)State->Start,
                                            &previousFlags);

               //
               // This next bit is a hack.  We need to make sure that
               // the boot config code doesn't try to allocate the same
               // vector for two different devices that need conflicting
               // modes.  This should never happen, as translation
               // should filter out the problemating ones before we
               // get to arbitration.
               //

               if (NT_SUCCESS(status)) {
                   //
                   // This vector is already in use for something.
                   //

                   ASSERT((previousFlags & ~(VECTOR_MODE | VECTOR_POLARITY | VECTOR_TYPE)) == 0);
                   ASSERT(flags == previousFlags);
               }
#endif

            } else {

               //
               // This is a PCI device that is not connected to a
               // link node.
               //

               ASSERT(sourceIndex == State->Start);
            }
        } else {

            if (InterruptModel == 1) {
                //
                // We are running in APIC mode.  And we know that
                // the PCI driver builds boot configs based on
                // the Interrupt Line register, which only relates
                // to PIC mode.  So just say no to boot configs.
                //

                DEBUG_PRINT(1, ("Skipping this allocation.  It's for a PCI device in APIC mode\n"));
                return;
            }
        }

    } else {

        //
        // Not a PCI device.
        //

        status = GetIsaVectorFlags((ULONG)State->Start,
                                   &flags);

        if (!NT_SUCCESS(status)) {

            //
            // Not overridden.  Assume that the device flags conform to bus.
            //

            flags = (State->CurrentAlternative->Descriptor->Flags
                == CM_RESOURCE_INTERRUPT_LATCHED) ?
                VECTOR_EDGE | VECTOR_ACTIVE_HIGH :
                VECTOR_LEVEL | VECTOR_ACTIVE_LOW;

        }

        ASSERT((flags & ~(VECTOR_MODE | VECTOR_POLARITY | VECTOR_TYPE)) == 0);
    }

    //
    // There is a possibility that this allocation is impossible.
    // (We may be setting a boot-config for a device after we
    // have already started using the vector elsewhere.)  Just
    // don't do it.
    //

    if (State->Flags & ARBITER_STATE_FLAG_BOOT) {

        attributes |= ARBITER_RANGE_BOOT_ALLOCATED;

        status = GetVectorProperties((ULONG)State->Start,
                                     &previousFlags);

        if ((NT_SUCCESS(status)) &&
            ((flags & ~VECTOR_TYPE) != (previousFlags & ~VECTOR_TYPE))) {
            DEBUG_PRINT(1, ("Skipping this allocation.  It's for a vector that's incompatible.\n"));
            return;
        }
    }

    ReferenceVector((ULONG)State->Start,
                    flags);

    // Figure out what flags we need to add the range

    if ((flags & VECTOR_TYPE) == VECTOR_SIGNAL) {

       // Non-MSI vectors can sometimes be shared and thus can have range conflicts, etc.

       rangeFlags = RTL_RANGE_LIST_ADD_IF_CONFLICT +
                    (State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED
                        ? RTL_RANGE_LIST_ADD_SHARED : 0);
    }

    //
    // Now do what the default function would do, marking this
    // allocation as new.
    //

    status = RtlAddRange(
                 Arbiter->PossibleAllocation,
                 State->Start,
                 State->End,
                 attributes,
                 rangeFlags,
                 referencedNode, // This line is different from the default function
                 State->Entry->PhysicalDeviceObject
                 );

    ASSERT(NT_SUCCESS(status));
}

VOID
AcpiArbBacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     )
{
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE  current;
    PNSOBJ linkNode;

    PAGED_CODE();

    DEBUG_PRINT(1, ("Backtracking allocation for IRQ %x for device %p\n",
                    State->CurrentAlternative->Descriptor->u.Interrupt.MinimumVector,
                    State->Entry->PhysicalDeviceObject));

    ASSERT(!(State->Flags & ARBITER_STATE_FLAG_BOOT));

    //
    // Backtrack this assignment in the Edge/Level table.
    //

    DereferenceVector((ULONG)State->Start);

    //
    // Look for the range that we are backing out.
    //

    FOR_ALL_RANGES(Arbiter->PossibleAllocation, &iterator, current) {

        if ((State->Entry->PhysicalDeviceObject == current->Owner) &&
            (State->End                         == current->End) &&
            (State->Start                       == current->Start)) {

            //
            // We stash the link node that we refereneced
            // into Workspace.
            //

            linkNode = (PNSOBJ)current->UserData;

            if (linkNode) {

                //
                // Dereference the link node that we referenced in
                // AcpiArbAddAllocation.
                //

                AcpiArbDereferenceLinkNode(Arbiter,
                                           linkNode);
            }

            break;
        }
    }

    //
    // Now call the default function.
    //

    ArbBacktrackAllocation(Arbiter, State);
}

NTSTATUS
UnreferenceArbitrationList(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )
{
    RTL_RANGE_LIST_ITERATOR iterator;
    PARBITER_LIST_ENTRY currentListEntry;
    PRTL_RANGE  currentRange;
    NTSTATUS    status;
    PNSOBJ      linkNode;
    ULONG       vector;
    UCHAR       flags;

    PAGED_CODE();

    //
    // In order to keep the reference counts in line,
    // we need to remove the counts that were added
    // by previous allocations for this device.  I.e.
    // if the device is being rebalanced, we need to
    // start by getting rid of the reference to the old
    // vector.
    //
    // This is also necessary for references that were
    // added as part of boot configs.  But boot configs
    // are a special case.  There are a (very) few devices
    // that want more than one IRQ.  And it is possible
    // that the boot config only reserved a single IRQ.
    // (There is a Lucent Winmodem that actually does
    // this.)  We need to make sure that we only
    // dereference the vector as many times as it was
    // previously referenced.
    //
    // Note that there are still a few cases that this
    // function doesn't handle.  If a device lowers
    // the number of IRQs that it wants dynamically,
    // separate from its boot config, we will get out
    // of synch.  If a vector has both a boot config
    // and a device that is not boot config'd on it,
    // then we may get out of synch, depending on
    // what combinations the PnP manager throws at us.
    // Fixing either of these would involve tagging all
    // vectors with a list of the PDOs that are connected
    // which would be a lot of work.  So unless these
    // situations actually exist in the future, I'm not
    // bothering to code for them now.  11/14/2000
    //

    FOR_ALL_RANGES(Arbiter->Allocation, &iterator, currentRange) {

        DEBUG_PRINT(4, ("Looking at range: %x-%x %p\n",
                        (ULONG)(currentRange->Start & 0xffffffff),
                        (ULONG)(currentRange->End & 0xffffffff),
                        currentRange->Owner));

        FOR_ALL_IN_LIST(ARBITER_LIST_ENTRY, ArbitrationList, currentListEntry) {

            DEBUG_PRINT(2, ("Unreferencing allocations for device %p\n",
                            currentListEntry->PhysicalDeviceObject));

            if (currentRange->Owner == currentListEntry->PhysicalDeviceObject) {

                //
                // Dereference the vector until there are no more
                // references.
                //

                for (vector = (ULONG)(currentRange->Start & 0xffffffff);
                     vector <= (ULONG)(currentRange->End & 0xffffffff);
                     vector++) {

                    status = GetVectorProperties(vector, &flags);

                    if (NT_SUCCESS(status)) {

                        DEBUG_PRINT(2, ("Dereferencing %x\n", vector));
                        DereferenceVector(vector);
                    }
                }

                if (!(currentRange->Attributes & ARBITER_RANGE_BOOT_ALLOCATED)) {

                    //
                    // Now find out if we have to dereference a link node too.
                    //

                    status = AcpiArbCrackPRT(currentListEntry->PhysicalDeviceObject,
                                             &linkNode,
                                             &vector);

                    if (NT_SUCCESS(status)) {

                        if (linkNode) {

                            //
                            // This device is connected to a link node.  So temporarily
                            // dereference this node.
                            //

                            ASSERT(LinkNodeInUse(Arbiter,
                                                  linkNode,
                                                  NULL,
                                                  NULL));

                            AcpiArbDereferenceLinkNode(Arbiter,
                                                       linkNode);
                        }
                    }
                }
            }
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
AcpiArbBootAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )
{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Start a new arbiter transaction and clear any
    // temporary vector counts.
    //
    // N.B.  This arbiter doesn't keep track of link
    // node data for boot configs. This means that we don't have
    // to worry about link node counts in this funtion.
    //

    ClearTempVectorCounts();

    status = ArbBootAllocation(Arbiter, ArbitrationList);

    MakeTempVectorCountsPermanent();

    return status;
}
NTSTATUS
AcpiArbTestAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )
{
    NTSTATUS status;

    PAGED_CODE();

    //
    // ArbTestAllocation is the beginning of a
    // new arbitration transaction.  So clear
    // out all temporary edge-level status and
    // link node ref counts.
    //

    ClearTempVectorCounts();

    status = ClearTempLinkNodeCounts(Arbiter);
    ASSERT(NT_SUCCESS(status));

    status = UnreferenceArbitrationList(Arbiter, ArbitrationList);
    ASSERT(NT_SUCCESS(status));

    return ArbTestAllocation(Arbiter, ArbitrationList);
}

NTSTATUS
AcpiArbRetestAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )
{
    NTSTATUS status;

    PAGED_CODE();

    //
    // ArbRetestAllocation (also) is the beginning
    // of a new arbitration transaction.  So clear
    // out all temporary edge-level status and
    // link node ref counts.
    //

    ClearTempVectorCounts();

    status = ClearTempLinkNodeCounts(Arbiter);
    ASSERT(NT_SUCCESS(status));

    status = UnreferenceArbitrationList(Arbiter, ArbitrationList);
    ASSERT(NT_SUCCESS(status));

    return ArbRetestAllocation(Arbiter, ArbitrationList);
}

NTSTATUS
AcpiArbRollbackAllocation(
    PARBITER_INSTANCE Arbiter
    )
{
    PAGED_CODE();

    return ArbRollbackAllocation(Arbiter);
}

NTSTATUS
AcpiArbCommitAllocation(
    PARBITER_INSTANCE Arbiter
    )

/*++

Routine Description:

    This provides the implementation of the CommitAllocation
    action.  It frees the old allocation and replaces it with
    the new allocation.  After that, it dereferences all the
    link nodes in the old allocation and references the ones
    in the new allocation.  This potentially results in the
    IRQ router being reprogrammed to match the new set of
    allocations.

Parameters:

    Arbiter - The arbiter instance data for the arbiter being called.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PINT_ROUTE_INTERFACE_STANDARD pciInterface = NULL;
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE_LIST temp;
    PRTL_RANGE  current;
    NTSTATUS    status;
    PNSOBJ      linkNode;
    ULONG       sourceIndex;

    ULONG               pciBus;
    PCI_SLOT_NUMBER     pciSlot;
    UCHAR               interruptLine;
    ULONG_PTR           dummy;
    ROUTING_TOKEN       token;

    PAGED_CODE();


    if (PciInterfacesInstantiated) {

        pciInterface = ((PARBITER_EXTENSION)AcpiArbiter.ArbiterState.Extension)->InterruptRouting;
        ASSERT(pciInterface);

        FOR_ALL_RANGES(Arbiter->PossibleAllocation, &iterator, current) {

            if (current->Owner) {

                //
                // Make sure that the InterruptLine register
                // matches the assignment.  (This is so that
                // broken drivers that rely on the contents
                // of the InterruptLine register instead of
                // the resources handed back in a StartDevice
                // still work.
                //

                pciBus = (ULONG)-1;
                pciSlot.u.AsULONG = (ULONG)-1;
                status = pciInterface->GetInterruptRouting(current->Owner,
                                                           &pciBus,
                                                           &pciSlot.u.AsULONG,
                                                           &interruptLine,
                                                           (PUCHAR)&dummy,
                                                           (PUCHAR)&dummy,
                                                           (PUCHAR)&dummy,
                                                           (PDEVICE_OBJECT*)&dummy,
                                                           &token,
                                                           (PUCHAR)&dummy);

                if (NT_SUCCESS(status)) {


                    if (interruptLine != (UCHAR)current->Start) {

                        //
                        // We need to update the hardware.
                        //

                        ASSERT(current->Start < MAXUCHAR);

                        pciInterface->UpdateInterruptLine(current->Owner,
                                                          (UCHAR)current->Start
                                                         );


                    }
                }
            }
        }
    }

    //
    // Free up the current allocation
    //

    RtlFreeRangeList(Arbiter->Allocation);

    //
    // Swap the allocated and duplicate lists
    //

    temp = Arbiter->Allocation;
    Arbiter->Allocation = Arbiter->PossibleAllocation;
    Arbiter->PossibleAllocation = temp;

    //
    // Since we have committed the new allocation, we
    // need to make the edge-level state and the new
    // link node counts permanent.
    //

    MakeTempVectorCountsPermanent();

    status = MakeTempLinkNodeCountsPermanent(Arbiter);

    return status;
}

NTSTATUS
AcpiArbQueryConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PIO_RESOURCE_DESCRIPTOR ConflictingResource,
    OUT PULONG ConflictCount,
    OUT PARBITER_CONFLICT_INFO *Conflicts
    )
{
    PINT_ROUTE_INTERFACE_STANDARD pciInterface = NULL;
    NTSTATUS            status;
    ROUTING_TOKEN       routingToken;
    ULONG_PTR           dummy;

    PAGED_CODE();

    if (PciInterfacesInstantiated) {

        pciInterface = ((PARBITER_EXTENSION)AcpiArbiter.ArbiterState.Extension)->InterruptRouting;
        ASSERT(pciInterface);

        status = pciInterface->GetInterruptRouting(PhysicalDeviceObject,
                                               (PULONG)&dummy,
                                               (PULONG)&dummy,
                                               &(UCHAR)dummy,
                                               &(UCHAR)dummy,
                                               &(UCHAR)dummy,
                                               &(UCHAR)dummy,
                                               (PDEVICE_OBJECT*)&dummy,
                                               &routingToken,
                                               &(UCHAR)dummy);

        if (NT_SUCCESS(status)) {

            //
            // This is a PCI device.  It's interrupt should not ever
            // show a conflict.
            //

            *ConflictCount = 0;
            return STATUS_SUCCESS;
        }

    }

    //
    // This isn't a PCI device.  Call the base arbiter code.
    //

    return ArbQueryConflict(Arbiter,
                            PhysicalDeviceObject,
                            ConflictingResource,
                            ConflictCount,
                            Conflicts);
}

NTSTATUS
FindVectorInAlternatives(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State,
    IN ULONGLONG Vector,
    OUT ULONG *Alternative
    )
{
    ULONG alt;

    for (alt = 0; alt < State->AlternativeCount; alt++) {

        if ((State->Alternatives[alt].Minimum <= Vector) &&
            (State->Alternatives[alt].Maximum >= Vector)) {

            *Alternative = alt;
            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}

NTSTATUS
FindBootConfig(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State,
    IN ULONGLONG *Vector
    )
{
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE  currentRange;

    FOR_ALL_RANGES(Arbiter->Allocation, &iterator, currentRange) {

        if (currentRange->Attributes & ARBITER_RANGE_BOOT_ALLOCATED) {

            //
            // We're only interested in boot configs.
            //

            if (State->Entry->PhysicalDeviceObject == currentRange->Owner) {

                //
                // This boot config is the one we are looking for.
                //

                ASSERT(currentRange->Start == currentRange->End);
                *Vector = currentRange->Start;
                return STATUS_SUCCESS;
            }
        }
    }

    return STATUS_NOT_FOUND;
}

BOOLEAN
AcpiArbGetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PARBITER_ALLOCATION_STATE State
    )
{
    BOOLEAN nextRange = FALSE;
    PINT_ROUTE_INTERFACE_STANDARD pciInterface;
    NTSTATUS            status;
    ROUTING_TOKEN       routingToken;
    ULONG_PTR           dummy;
    BOOLEAN             legacyFreeMachine;
    ULONGLONG           vector;
    ULONG               alternative;

    PAGED_CODE();

    if (State->Entry->PhysicalDeviceObject->DriverObject == AcpiDriverObject) {

        //
        // This is one of our PDOs.
        //

        ASSERT(((PDEVICE_EXTENSION)State->Entry->PhysicalDeviceObject->DeviceExtension)->Flags & DEV_TYPE_PDO);
        ASSERT(((PDEVICE_EXTENSION)State->Entry->PhysicalDeviceObject->DeviceExtension)->Signature == ACPI_SIGNATURE);

        if (((PDEVICE_EXTENSION)State->Entry->PhysicalDeviceObject->DeviceExtension)->Flags & DEV_CAP_PCI) {

            //
            // It's a PCI PDO, which means a root PCI bus,
            // which means that we should just handle this
            // as an ISA device.
            //

            return ArbGetNextAllocationRange(Arbiter, State);
        }
    }

    status = STATUS_NOT_FOUND;

    if (PciInterfacesInstantiated) {

        pciInterface = ((PARBITER_EXTENSION)AcpiArbiter.ArbiterState.Extension)->InterruptRouting;
        ASSERT(pciInterface);

        status = pciInterface->GetInterruptRouting(State->Entry->PhysicalDeviceObject,
                                                   (PULONG)&dummy,
                                                   (PULONG)&dummy,
                                                   &(UCHAR)dummy,
                                                   &(UCHAR)dummy,
                                                   &(UCHAR)dummy,
                                                   &(UCHAR)dummy,
                                                   (PDEVICE_OBJECT*)&dummy,
                                                   &routingToken,
                                                   &(UCHAR)dummy);

    }

    if (status != STATUS_SUCCESS) {

        //
        // This is not a PCI device.  Use the base function.
        //

        return ArbGetNextAllocationRange(Arbiter, State);
    }

#if defined(_X86_)
    legacyFreeMachine = (AcpiInformation->FixedACPIDescTable->Header.Revision > 1) &&
             !(AcpiInformation->FixedACPIDescTable->boot_arch & LEGACY_DEVICES);
#else
    legacyFreeMachine = TRUE;
#endif

    //
    // A PCI device.
    //

    if (!State->CurrentAlternative) {

        //
        // This is the first time we've called this function
        // with this alternative list.  Set up the state machine.
        //

        State->WorkSpace = AcpiIrqNextRangeInit;
    }

    while (TRUE) {

        ASSERT((State->WorkSpace > AcpiIrqNextRangeMinState) &&
               (State->WorkSpace < AcpiIrqNextRangeMaxState));

        DEBUG_PRINT(4, ("GetNextRange, State: %x\n", State->WorkSpace));

        switch (State->WorkSpace) {
        case AcpiIrqNextRangeInit:

            //
            // Top of the state machine.  See if the registry
            // contained policy.
            //

            switch (AcpiIrqDistributionDisposition) {
            case AcpiIrqDistributionDispositionSpreadOut:
                State->WorkSpace = AcpiIrqNextRangeAlternativeZero;
                break;
            case AcpiIrqDistributionDispositionStackUp:
                State->WorkSpace = AcpiIrqNextRangeInitLegacy;
                break;
            case AcpiIrqDistributionDispositionDontCare:
            default:
                State->WorkSpace = AcpiIrqNextRangeInitPolicyNeutral;
                break;
            }
            break;

        case AcpiIrqNextRangeInitPolicyNeutral:

            //
            // Look at the interrupt controller model.
            //

            if (InterruptModel == 0) {
                State->WorkSpace = AcpiIrqNextRangeInitPic;
            } else {
                State->WorkSpace = AcpiIrqNextRangeUseBootConfig;
            }
            break;

        case AcpiIrqNextRangeInitPic:

            //
            // There is a PIC interrupt controller.  So we are somewhat
            // IRQ constrained.  If this is a legacy-free machine, or if there
            // is no cardbus controller, we want to spread interrupts.
            //

            if (legacyFreeMachine || !AcpiArbCardbusPresent) {
                State->WorkSpace = AcpiIrqNextRangeUseBootConfig;
            } else {
                State->WorkSpace = AcpiIrqNextRangeInitLegacy;
            }
            break;

        case AcpiIrqNextRangeInitLegacy:

            //
            // See if all the devices were boot configged on the same
            // vector, or if there was a registry override specifying
            // the vector that we should favor.
            //

            if (AcpiIrqDefaultBootConfig) {
                State->WorkSpace = AcpiIrqNextRangeBootRegAlternative;
            } else {
                State->WorkSpace = AcpiIrqNextRangeSciAlternative;
            }
            break;

        case AcpiIrqNextRangeBootRegAlternative:

            //
            // If we re-enter this state machine after this state,
            // then it means that this alternative wasn't available.
            // So set the next state to AcpiIrqNextRangeAlternativeZero,
            // assuming that we failed.
            //

            State->WorkSpace = AcpiIrqNextRangeAlternativeZero;

            //
            // See if the machine-wide boot config or the registry
            // override is within the alternatives.
            //

            status = FindVectorInAlternatives(Arbiter,
                                              State,
                                              (ULONGLONG)AcpiIrqDefaultBootConfig,
                                              &alternative);

            if (NT_SUCCESS(status)) {

                State->CurrentAlternative = &State->Alternatives[alternative];
                State->CurrentMinimum = (ULONGLONG)AcpiIrqDefaultBootConfig;
                State->CurrentMaximum = (ULONGLONG)AcpiIrqDefaultBootConfig;
                goto GetNextAllocationSuccess;
            }
            break;

        case AcpiIrqNextRangeSciAlternative:

            //
            // If we re-enter this state machine after this state,
            // then it means that this alternative wasn't available.
            // So set the next state to AcpiIrqNextRangeUseBootConfig,
            // assuming that we failed.
            //

            State->WorkSpace = AcpiIrqNextRangeUseBootConfig;

            //
            // See if the SCI vector is within the alternatives.
            //

            status = FindVectorInAlternatives(Arbiter,
                                              State,
                                              (ULONGLONG)AcpiSciVector,
                                              &alternative);

            if (NT_SUCCESS(status)) {

                State->CurrentAlternative = &State->Alternatives[alternative];
                State->CurrentMinimum = (ULONGLONG)AcpiSciVector;
                State->CurrentMaximum = (ULONGLONG)AcpiSciVector;
                goto GetNextAllocationSuccess;
            }
            break;

        case AcpiIrqNextRangeUseBootConfig:

            //
            // If we re-enter this state machine after this state,
            // then it means that this alternative wasn't available.
            // So set the next state to AcpiIrqNextRangeAlternativeZero,
            // assuming that we failed.
            //

            State->WorkSpace = AcpiIrqNextRangeAlternativeZero;

            //
            // See if there is a boot config for this device
            // within the alternatives.
            //

            status = FindBootConfig(Arbiter,
                                    State,
                                    &vector);

            if (NT_SUCCESS(status)) {

                status = FindVectorInAlternatives(Arbiter,
                                                  State,
                                                  vector,
                                                  &alternative);

                if (NT_SUCCESS(status)) {

                    State->CurrentAlternative = &State->Alternatives[alternative];
                    State->CurrentMinimum = vector;
                    State->CurrentMaximum = vector;
                    goto GetNextAllocationSuccess;
                }
            }
            break;

        case AcpiIrqNextRangeAlternativeZero:

            //
            // If we re-enter this state machine after this state,
            // then it means that this alternative wasn't available.
            // So set the next state to AcpiIrqNextRangeAlternativeN,
            // assuming that we failed.
            //

            State->WorkSpace = AcpiIrqNextRangeAlternativeN;

            //
            // Try alternative 0.
            //

            State->CurrentAlternative = &State->Alternatives[0];
            State->CurrentMinimum = State->CurrentAlternative->Minimum;
            State->CurrentMaximum = State->CurrentAlternative->Maximum;
            goto GetNextAllocationSuccess;
            break;

        case AcpiIrqNextRangeAlternativeN:

            if (++State->CurrentAlternative < &State->Alternatives[State->AlternativeCount]) {

                //
                // There are multiple ranges.  Cycle through them.
                //

                DEBUG_PRINT(3, ("No next allocation range, exhausted all %08X alternatives", State->AlternativeCount));
                State->CurrentMinimum = State->CurrentAlternative->Minimum;
                State->CurrentMaximum = State->CurrentAlternative->Maximum;
                goto GetNextAllocationSuccess;

            } else {

                //
                // We're done.  There is no solution among these alternatives.
                //

                return FALSE;
            }
        }
    }

GetNextAllocationSuccess:

    DEBUG_PRINT(3, ("Next allocation range 0x%I64x-0x%I64x\n", State->CurrentMinimum, State->CurrentMaximum));
    AcpiArbPciAlternativeRotation++;
    return TRUE;
}

VOID
ReferenceVector(
    IN ULONG Vector,
    IN UCHAR Flags
    )
/*++

Routine Description:

    This routine adds one to either the permanent or the
    temporary reference count.

Parameters:

    Vector  - the IRQ

    Flags   - mode and polarity

Return Value:

    none

--*/
{
    PVECTOR_BLOCK   block;

    PAGED_CODE();
    ASSERT((Flags & ~(VECTOR_MODE | VECTOR_POLARITY | VECTOR_TYPE)) == 0);

    block = HashVector(Vector);

    DEBUG_PRINT(5, ("Referencing vector %x : %d %d\n", Vector,
                    block ? block->Entry.Count : 0,
                    block ? block->Entry.TempCount : 0));

    if (block == NULL) {

        AddVectorToTable(Vector,
                         0,
                         1,
                         Flags);
        return;
    }

    if ((block->Entry.TempCount + block->Entry.Count) == 0) {

        //
        // This vector has been temporarily set to an
        // aggregate count of zero.  This means that the arbiter
        // is re-allocating it.  Record the new flags.
        //

        block->Entry.TempFlags = Flags;
    }

    block->Entry.TempCount++;

    ASSERT(Flags == block->Entry.TempFlags);
    ASSERT(block->Entry.Count <= 255);
}

VOID
DereferenceVector(
    IN ULONG Vector
    )
{
    PVECTOR_BLOCK   block;

    PAGED_CODE();

    block = HashVector(Vector);

    ASSERT(block);

    DEBUG_PRINT(5, ("Dereferencing vector %x : %d %d\n", Vector,
                    block->Entry.Count,
                    block->Entry.TempCount));

    block->Entry.TempCount--;
    ASSERT((block->Entry.TempCount * -1) <= block->Entry.Count);
}


PVECTOR_BLOCK
HashVector(
    IN ULONG Vector
    )
/*++

Routine Description:

    This function takes a "Global System Interrupt Vector"
    and returns a pointer to its entry in the hash table.

Arguments:

    Vector - an IRQ

Return Value:

    pointer to the entry in the hash table, or NULL if not found

--*/
{
    PVECTOR_BLOCK   block;
    ULONG row, column;

    PAGED_CODE();

    row = Vector % VECTOR_HASH_TABLE_LENGTH;

    block = HASH_ENTRY(row, 0);

    while (TRUE) {

        //
        // Search across the hash table looking for our Vector
        //

        for (column = 0; column < VECTOR_HASH_TABLE_WIDTH; column++) {

            //
            // Check to see if we should follow a chain
            //

            if (block->Chain.Token == TOKEN_VALUE) {
                break;
            }

            if (block->Entry.Vector == Vector) {
                return block;
            }

            if ((block->Entry.Vector == EMPTY_BLOCK_VALUE) ||
                (column == VECTOR_HASH_TABLE_WIDTH - 1)) {

                //
                // Didn't find this vector in the table.
                //

                return NULL;
            }

            block += 1;
        }

        ASSERT(block->Chain.Token == TOKEN_VALUE);

        block = block->Chain.Next;
    }
    return NULL;
}

NTSTATUS
GetVectorProperties(
    IN ULONG Vector,
    OUT UCHAR  *Flags
    )
/*++

Routine Description:

    This function takes a "Global System Interrupt Vector"
    and returns the associated flags.

    N.B.  This function returns flags based on the
          *temporary* reference count.  I.e. if the vector
          has been temporarily dereferenced, then the
          funtion will indicate that the vector is available
          for allocation by returning STATUS_NOT_FOUND.

Arguments:

    Vector - an IRQ

    Flags - to be filled in with the flags

Return Value:

    status

--*/
{
    PVECTOR_BLOCK   block;

    PAGED_CODE();

    block = HashVector(Vector);

    if (!block) {
        return STATUS_NOT_FOUND;
    }

    if (block->Entry.Vector == EMPTY_BLOCK_VALUE) {
        return STATUS_NOT_FOUND;
    }

    ASSERT(block->Entry.Vector == Vector);

    if (block->Entry.Count + block->Entry.TempCount == 0) {

        //
        // This vector has an aggregate reference count of
        // zero.  This means that it is effectively
        // unallocated.
        //

        return STATUS_NOT_FOUND;
    }

    *Flags = block->Entry.TempFlags;

    return STATUS_SUCCESS;
}

NTSTATUS
AddVectorToTable(
    IN ULONG    Vector,
    IN UCHAR    ReferenceCount,
    IN UCHAR    TempRefCount,
    IN UCHAR    Flags
    )
{
    PVECTOR_BLOCK   block, newRow;
    ULONG row, column;

    PAGED_CODE();
    ASSERT((Flags & ~(VECTOR_MODE | VECTOR_POLARITY | VECTOR_TYPE)) == 0);

    row = Vector % VECTOR_HASH_TABLE_LENGTH;

    block = HASH_ENTRY(row, 0);

    while (TRUE) {

        //
        // Search across the hash table looking for our Vector
        //

        for (column = 0; column < VECTOR_HASH_TABLE_WIDTH; column++) {

            //
            // Check to see if we should follow a chain
            //

            if (block->Chain.Token == TOKEN_VALUE) {
                break;
            }

            if (block->Entry.Vector == EMPTY_BLOCK_VALUE) {

                block->Entry.Vector = Vector;
                block->Entry.Count = ReferenceCount;
                block->Entry.TempCount = TempRefCount;
                block->Entry.Flags = Flags;
                block->Entry.TempFlags = Flags;

                return STATUS_SUCCESS;
            }

            if (column == VECTOR_HASH_TABLE_WIDTH - 1) {

                //
                // We have just looked at the last entry in
                // the row and it wasn't empty.  Create
                // an extension to this row.
                //

                newRow = ExAllocatePoolWithTag(PagedPool,
                                               sizeof(VECTOR_BLOCK)
                                                   * VECTOR_HASH_TABLE_WIDTH,
                                               ACPI_ARBITER_POOLTAG
                                               );

                if (!newRow) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                RtlFillMemory(newRow,
                              sizeof(VECTOR_BLOCK) * VECTOR_HASH_TABLE_WIDTH,
                              (UCHAR)(EMPTY_BLOCK_VALUE & 0xff));

                //
                // Move last entry into new row.
                //

                RtlMoveMemory(newRow, block, sizeof(VECTOR_BLOCK));

                //
                // Chain the old row to the new row.
                //

                block->Chain.Token = TOKEN_VALUE;
                block->Chain.Next = newRow;

                break;
            }

            block += 1;
        }

        block = block->Chain.Next;
    }
    return STATUS_INSUFFICIENT_RESOURCES;
}

VOID
ClearTempVectorCounts(
    VOID
    )
{
    PVECTOR_BLOCK   block;
    ULONG row, column;

    PAGED_CODE();


    for (row = 0; row < VECTOR_HASH_TABLE_LENGTH; row++) {

        block = HASH_ENTRY(row, 0);

        //
        // Search across the hash table looking for our Vector
        //

ClearTempCountsStartRow:

        for (column = 0; column < VECTOR_HASH_TABLE_WIDTH; column++) {

            //
            // Check to see if we should follow a chain
            //

            if (block->Chain.Token == TOKEN_VALUE) {
                block = block->Chain.Next;
                goto ClearTempCountsStartRow;
            }

            if (block->Entry.Vector == EMPTY_BLOCK_VALUE) {
                break;
            }

            //
            // This must be a valid entry.
            //

            block->Entry.TempCount = 0;
            block->Entry.TempFlags = block->Entry.Flags;
            block += 1;
        }
    }
}

VOID
MakeTempVectorCountsPermanent(
    VOID
    )
{
    PVECTOR_BLOCK   block;
    ULONG row, column;

    PAGED_CODE();


    for (row = 0; row < VECTOR_HASH_TABLE_LENGTH; row++) {

        block = HASH_ENTRY(row, 0);

        //
        // Search across the hash table looking for our Vector
        //

MakeTempVectorCountsPermanentStartRow:

        for (column = 0; column < VECTOR_HASH_TABLE_WIDTH; column++) {

            //
            // Check to see if we should follow a chain
            //

            if (block->Chain.Token == TOKEN_VALUE) {
                block = block->Chain.Next;
                goto MakeTempVectorCountsPermanentStartRow;
            }

            if (block->Entry.Vector == EMPTY_BLOCK_VALUE) {
                break;
            }

            //
            // This must be a valid entry.
            //

            if ((block->Entry.Count + block->Entry.TempCount != 0) &&
                ((block->Entry.Count == 0) ||
                 (block->Entry.TempFlags != block->Entry.Flags))) {

                //
                // This vector has just been allocated or it has
                // been re-allocated.  Tell the HAL which flags
                // to use.
                //

                HalSetVectorState(block->Entry.Vector,
                                  block->Entry.TempFlags);
            }

            //
            // Record new flags and aggregate count.
            //

            block->Entry.Flags = block->Entry.TempFlags;
            block->Entry.Count += block->Entry.TempCount;

            block += 1;
        }
    }
}
#ifdef DBG
VOID
DumpVectorTable(
    VOID
    )
{
    PVECTOR_BLOCK   block;
    ULONG row, column;

    PAGED_CODE();

    DEBUG_PRINT(1, ("\nIRQARB: Dumping vector table\n"));

    for (row = 0; row < VECTOR_HASH_TABLE_LENGTH; row++) {

        block = HASH_ENTRY(row, 0);

        //
        // Search across the hash table looking for our Vector
        //

DumpVectorTableStartRow:

        for (column = 0; column < VECTOR_HASH_TABLE_WIDTH; column++) {

            //
            // Check to see if we should follow a chain
            //

            if (block->Chain.Token == TOKEN_VALUE) {
                block = block->Chain.Next;
                goto DumpVectorTableStartRow;
            }

            if (block->Entry.Vector == EMPTY_BLOCK_VALUE) {
                break;
            }

            DEBUG_PRINT(1, ("Vector: %x\tP: %d T: %d\t%s %s\n",
                            block->Entry.Vector,
                            block->Entry.Count,
                            (LONG)block->Entry.TempCount,
                            IS_LEVEL_TRIGGERED(block->Entry.Flags) ? "level" : "edge",
                            IS_ACTIVE_LOW(block->Entry.Flags) ? "low" : "high"));

            block += 1;
        }

    }
}
#endif

//
// This section of the file contains functions used for
// reading and manipulating the AML code.
//
NTSTATUS
AcpiArbGetLinkNodeOptions(
    IN PNSOBJ  LinkNode,
    IN OUT  PCM_RESOURCE_LIST   *LinkNodeIrqs,
    IN OUT  UCHAR               *Flags
    )
/*++

Routine Description:

    This routine looks in the AML namespace for the named
    link node and returns the range of IRQs that it can
    trigger.

Arguments:

    LinkNodeName    - The name of the IRQ router (link node)
    LInkNodeIrqs    - The list of possible settings for the link node
    Flags           - flags associated with this link node

Return Value:

    NTSTATUS

--*/
{
    PIO_RESOURCE_REQUIREMENTS_LIST  ioList = NULL;
    PCM_RESOURCE_LIST               cmList = NULL;
    PUCHAR      prsBuff = NULL;
    NTSTATUS    status;
    PULONG      polarity;

    PAGED_CODE();

    ASSERT(LinkNode);

    //
    // Read the _PRS
    //

    ACPIGetNSBufferSync(
        LinkNode,
        PACKED_PRS,
        &prsBuff,
        NULL);

    if (!prsBuff) {

        return STATUS_NOT_FOUND;
    }

    status = PnpBiosResourcesToNtResources(prsBuff, 0, &ioList);

    ExFreePool(prsBuff);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Huge HACK!  Get the polarity for the Flags.
    //
    // An IO_RES_LIST has no real way of representing the polarity
    // of an interrupt.  So, in PnpiBiosExtendedIrqToIoDescriptor I
    // stuck the information in the DWORD past 'MaximumVector.'
    //

    *Flags = 0;

    ASSERT(ioList->AlternativeLists == 1);
    polarity = (PULONG)(&ioList->List[0].Descriptors[0].u.Interrupt.MaximumVector) + 1;

    *Flags |= (UCHAR)*polarity;

    //
    // Get the mode for the flags.
    //

    *Flags |= (ioList->List[0].Descriptors[0].Flags == CM_RESOURCE_INTERRUPT_LATCHED) ?
                VECTOR_EDGE : VECTOR_LEVEL;

    //
    // Turn the list into a CM_RESOURCE_LIST
    //
    status = PnpIoResourceListToCmResourceList(
        ioList,
        &cmList
        );

    ExFreePool(ioList);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    *LinkNodeIrqs = cmList;

    return STATUS_SUCCESS;
}


typedef enum {
    StateInitial,
    StateGotPrs,
    StateRanSrs
} SET_LINK_WORKER_STATE;

typedef struct {
    PNSOBJ      LinkNode;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR  LinkNodeIrq;
    PUCHAR      PrsBuff;
    PUCHAR      SrsBuff;
    SET_LINK_WORKER_STATE State;
    LONG        RunCompletionHandler;
    OBJDATA     ObjData;
    PFNACB      CompletionHandler;
    PVOID       CompletionContext;

} SET_LINK_NODE_STATE, *PSET_LINK_NODE_STATE;

NTSTATUS
AcpiArbSetLinkNodeIrq(
    IN PNSOBJ  LinkNode,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  LinkNodeIrq
    )
/*++

Routine Description:

    This routine sets the named link node to trigger
    a particular IRQ.

    N.B.  This routine could simply build the right
          buffer and call the _SRS method, but there
          isn't enough information in a
          CM_PARTIAL_RESOURCE_DESCRIPTOR to know whether
          an interrupt will be delivered active-high
          or active-low.  So the algorithm here runs
          the _PRS method and copies the buffer returned
          by _PRS into the buffer sent to _SRS.  This
          way all the flags are preserved.

Arguments:

    LinkNodeName    - The name of the IRQ router (link node)
    LinkNodeIrq     - The IRQ that the link node will be programmed
                      to trigger.  If it is NULL, then the link node
                      will be disabled.

Return Value:

    NTSTATUS

--*/
{
    AMLISUPP_CONTEXT_PASSIVE  getDataContext;
    NTSTATUS                status;

    PAGED_CODE();

    KeInitializeEvent(&getDataContext.Event, SynchronizationEvent, FALSE);
    getDataContext.Status = STATUS_NOT_FOUND;

    status = AcpiArbSetLinkNodeIrqAsync(LinkNode,
                                        LinkNodeIrq,
                                        AmlisuppCompletePassive,
                                        (PVOID)&getDataContext
                                        );

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&getDataContext.Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = getDataContext.Status;
    }

    return status;
}

NTSTATUS
AcpiArbSetLinkNodeIrqAsync(
    IN PNSOBJ                           LinkNode,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  LinkNodeIrq,
    IN PFNACB                           CompletionHandler,
    IN PVOID                            CompletionContext
    )
{
    PSET_LINK_NODE_STATE    state;
    NTSTATUS                status;

    ASSERT(LinkNode);

    state = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(SET_LINK_NODE_STATE),
                                  ACPI_ARBITER_POOLTAG);

    if (!state) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(state, sizeof(SET_LINK_NODE_STATE));

    state->LinkNode             = LinkNode;
    state->LinkNodeIrq          = LinkNodeIrq;
    state->CompletionHandler    = CompletionHandler;
    state->CompletionContext    = CompletionContext;
    state->State                = StateInitial;
    state->RunCompletionHandler = INITIAL_RUN_COMPLETION;

    return AcpiArbSetLinkNodeIrqWorker(LinkNode,
                                       STATUS_SUCCESS,
                                       NULL,
                                       (PVOID)state
                                       );
}

NTSTATUS
EXPORT
AcpiArbSetLinkNodeIrqWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
{
    BOOLEAN                         foundTag       = FALSE;
    BOOLEAN                         useEndChecksum = FALSE;
    BOOLEAN                         useExtendedTag = FALSE;
    NTSTATUS                        status;
    PNSOBJ                          childobj;
    PPNP_EXTENDED_IRQ_DESCRIPTOR    largeIrq;
    PPNP_IRQ_DESCRIPTOR             smallIrq;
    PSET_LINK_NODE_STATE            state;
    PUCHAR                          resource = NULL;
    PUCHAR                          irqTag = NULL;
    PUCHAR                          sumchar;
    UCHAR                           sum = 0;
    UCHAR                           tagName;
    ULONG                           length = 0;
    USHORT                          increment;
    USHORT                          irqTagLength = 0;

    state = (PSET_LINK_NODE_STATE)Context;

    if (!NT_SUCCESS(Status)) {
        status = Status;
        goto AcpiArbSetLinkNodeIrqWorkerExit;
    }

    ASSERT(state->LinkNodeIrq->Type == CmResourceTypeInterrupt);

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //

    InterlockedIncrement(&state->RunCompletionHandler);

    switch (state->State) {
    case StateInitial:

        //
        // Read the _PRS, so that we can choose the appropriate
        // entry and write that back into the _SRS.
        //

        state->State = StateGotPrs;
        status = ACPIGetNSBufferAsync(
            state->LinkNode,
            PACKED_PRS,
            AcpiArbSetLinkNodeIrqWorker,
            (PVOID)state,
            &state->PrsBuff,
            NULL
            );
        if (status == STATUS_PENDING) {
            return status;
        } else if (!NT_SUCCESS(status)) {
            goto AcpiArbSetLinkNodeIrqWorkerExit;
        }

        //
        // Fallthrough to next state
        //
    case StateGotPrs:
        state->State = StateRanSrs;
        if (!state->PrsBuff) {
            status = STATUS_NOT_FOUND;
            goto AcpiArbSetLinkNodeIrqWorkerExit;
        }

        DEBUG_PRINT(7, ("Read _PRS buffer %p\n", state->PrsBuff));

        resource = state->PrsBuff;
        while ( *resource ) {

            tagName = *resource;
            if ( !(tagName & LARGE_RESOURCE_TAG)) {
                increment = (USHORT) (tagName & SMALL_TAG_SIZE_MASK) + 1;
                tagName &= SMALL_TAG_MASK;
            } else {
                increment = ( *(USHORT UNALIGNED *)(resource + 1) ) + 3;

            }

            if (tagName == TAG_END) {
                length += increment;
                if (increment > 1) {
                    useEndChecksum = TRUE;
                }
                break;
            }

            //
            // This is the check to see if find a resource that correctly
            // matches the assignment
            //
            // This code is weak. It need to check to see
            // if the flags and interrupt match the descriptor we just found.
            // It is possible for a vendor to use overlapping descriptors that
            // would describe different interrupt settings.
            //
            if (tagName == TAG_IRQ || tagName == TAG_EXTENDED_IRQ) {
                irqTag = resource;
                if (tagName == TAG_EXTENDED_IRQ) {
                    irqTagLength = sizeof(PNP_EXTENDED_IRQ_DESCRIPTOR);
                    useExtendedTag = TRUE;
                } else {
                    irqTagLength = increment;

                }
                length += (ULONG) irqTagLength;
                foundTag = TRUE;
            }

            resource += increment;
        }

        //
        // Did we find the tag that we are looking for?
        //
        if (foundTag == FALSE) {
            ExFreePool( state->PrsBuff );
            status = STATUS_NOT_FOUND;
            goto AcpiArbSetLinkNodeIrqWorkerExit;
        }

        //
        // The next task is to fashion a buffer containing an ACPI-style
        // resource descriptor with exactly one interrupt destination in
        // it. We do this by allocating one
        //

        state->SrsBuff = ExAllocatePoolWithTag(
            NonPagedPool,
            length,
            ACPI_ARBITER_POOLTAG
            );

        if (!state->SrsBuff) {
            ExFreePool(state->PrsBuff);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto AcpiArbSetLinkNodeIrqWorkerExit;
        }

        ASSERT(irqTagLength <= length);
        RtlCopyMemory(state->SrsBuff, irqTag, irqTagLength);
        ExFreePool(state->PrsBuff);

        //
        // Change the buffer to reflect our choice of interrupts.
        //

        if (!useExtendedTag) {

            // small IRQ
            smallIrq = (PPNP_IRQ_DESCRIPTOR)state->SrsBuff;
            smallIrq->IrqMask = (USHORT)(1 << state->LinkNodeIrq->u.Interrupt.Level);

        } else {

            DEBUG_PRINT(7, ("Found large IRQ descriptor\n"));

            // large IRQ
            largeIrq = (PPNP_EXTENDED_IRQ_DESCRIPTOR)state->SrsBuff;
            largeIrq->Length = irqTagLength - 3;
            largeIrq->TableSize = 1;
            largeIrq->Table[0] = state->LinkNodeIrq->u.Interrupt.Level;

        }

        //
        // Work on the END descriptor
        //
        resource = (state->SrsBuff + irqTagLength);
        *resource = TAG_END;
        if (useEndChecksum) {

            *resource |= 1; // The one is to represent the checksum

            //
            // Calculate the Checksum
            sumchar = state->SrsBuff;
            while (*sumchar != *resource) {
                sum = *sumchar++;
            }
            *(resource+1) = 256 - sum;

        }

        //
        // Now run the _SRS method with this buffer
        //

        //
        // Get the object that we are looking for
        //
        childobj = ACPIAmliGetNamedChild(
             state->LinkNode,
             PACKED_SRS
             );
        if (childobj == NULL) {
            status = STATUS_OBJECT_NAME_NOT_FOUND;
            ExFreePool( state->SrsBuff );
            goto AcpiArbSetLinkNodeIrqWorkerExit;
        }

        state->ObjData.dwDataType = OBJTYPE_BUFFDATA;
        state->ObjData.dwDataLen = length;
        state->ObjData.pbDataBuff = state->SrsBuff;

        DEBUG_PRINT(7, ("Running _SRS\n"));

        status = AMLIAsyncEvalObject(
            childobj,
            NULL,
            1,
            &state->ObjData,
            AcpiArbSetLinkNodeIrqWorker,
            (PVOID)state
            );
        if (status == STATUS_PENDING) {
            return status;
        } else if (!NT_SUCCESS(status)) {
            goto AcpiArbSetLinkNodeIrqWorkerExit;
        }

    case StateRanSrs:
        //
        // We are done.
        //
        ExFreePool(state->SrsBuff);
        status = STATUS_SUCCESS;
        break;

    default:
        ACPIInternalError( ACPI_IRQARB );
    }

AcpiArbSetLinkNodeIrqWorkerExit:

    if (state->RunCompletionHandler) {

        state->CompletionHandler(
            AcpiObject,
            status,
            NULL,
            state->CompletionContext
            );

    }
    ExFreePool(state);
    return status;
}

NTSTATUS
AcpiArbCrackPRT(
    IN  PDEVICE_OBJECT  Pdo,
    IN  OUT PNSOBJ      *LinkNode,
    IN  OUT ULONG       *Vector
    )
/*++

Routine Description:

    This routine takes a PDO for a device and returns the
    associated link node, if any.  The ACPI spec says that
    a _PRT can optionally return a single interrupt vector
    instead of a link node.  If this is the case, this function
    returns that vector.

Arguments:

    Pdo             - The PDO of the device that needs to be granted an
                      IRQ.

    LinkNode        - A pointer to the link node, or NULL if the device
                      isn't connected to a link node.

    Vector          - The global system interrupt vector that this PCI
                      device is connected to.  This is meaningless if
                      LinkNode is not NULL.

Return Value:

    If we find a link node or a vector for this device, STATUS_SUCCESS.

    If this isn't a PCI device, STATUS_DEVICE_NOT_FOUND.

    If this is an IDE device, then we have to treat it specially, so
    we return STATUS_RESOURCE_REQUIREMENTS_CHANGED.

--*/
{
    PINT_ROUTE_INTERFACE_STANDARD pciInterface;
    NTSTATUS            status;
    PDEVICE_OBJECT      filter;
    PDEVICE_OBJECT      parent;
    PDEVICE_EXTENSION   filterExtension;
    OBJDATA             adrData;
    OBJDATA             pinData;
    OBJDATA             prtData;
    OBJDATA             linkData;
    OBJDATA             indexData;
    PNSOBJ              pciBusObj;
    PNSOBJ              prtObj;
    ULONG               prtElement = 0;
    BOOLEAN             found = FALSE;
    KIRQL               oldIrql;

    PCI_SLOT_NUMBER     pciSlot;
    PCI_SLOT_NUMBER     parentSlot;
    ULONG               pciBus;
    UCHAR               interruptLine;
    UCHAR               interruptPin;
    UCHAR               parentPin;
    UCHAR               classCode;
    UCHAR               subClassCode;
    UCHAR               flags;
    UCHAR               interfaceByte;
    ROUTING_TOKEN       routingToken;
    ULONG               dummy;
    ULONG               bus;


    if (Pdo->DriverObject == AcpiDriverObject) {

        //
        // This is one of our PDOs.
        //

        ASSERT(((PDEVICE_EXTENSION)Pdo->DeviceExtension)->Flags & DEV_TYPE_PDO);
        ASSERT(((PDEVICE_EXTENSION)Pdo->DeviceExtension)->Signature == ACPI_SIGNATURE);

        if (((PDEVICE_EXTENSION)Pdo->DeviceExtension)->Flags & DEV_CAP_PCI) {

            //
            // It's a PCI PDO, which means a root PCI bus,
            // which means that we should just handle this
            // as an ISA device.
            //

            return STATUS_NOT_FOUND;
        }
    }

    ASSERT(PciInterfacesInstantiated);

    *LinkNode = NULL;

    pciInterface = ((PARBITER_EXTENSION)AcpiArbiter.ArbiterState.Extension)->InterruptRouting;

    ASSERT(pciInterface);

    //
    // Call into the PCI driver to find out what we are dealing with.
    //

    pciBus = (ULONG)-1;
    pciSlot.u.AsULONG = (ULONG)-1;
    status = pciInterface->GetInterruptRouting(Pdo,
                                               &pciBus,
                                               &pciSlot.u.AsULONG,
                                               &interruptLine,
                                               &interruptPin,
                                               &classCode,
                                               &subClassCode,
                                               &parent,
                                               &routingToken,
                                               &flags);

    if (!NT_SUCCESS(status)) {
        return STATUS_NOT_FOUND;
    }

    if ((classCode == PCI_CLASS_MASS_STORAGE_CTLR) &&
        (subClassCode == PCI_SUBCLASS_MSC_IDE_CTLR)) {

        HalPciInterfaceReadConfig(NULL,
                                  (UCHAR)pciBus,
                                  pciSlot.u.AsULONG,
                                  &interfaceByte,
                                  FIELD_OFFSET (PCI_COMMON_CONFIG,
                                                ProgIf),
                                  1);

        if ((interfaceByte & 0x5) == 0) {

            //
            // PCI IDE devices in legacy mode don't use interrupts
            // the PCI way.  So bail if this is an IDE device without
            // any native-mode bits set.
            //

            return STATUS_RESOURCE_REQUIREMENTS_CHANGED;
        }
    }

    //
    // See if we have cached this lookup.
    //

    if ((routingToken.LinkNode != 0) ||
        (routingToken.Flags & PCI_STATIC_ROUTING)) {

        if (routingToken.LinkNode) {

            *LinkNode = routingToken.LinkNode;

        } else {

            *Vector = routingToken.StaticVector;
        }

        return STATUS_SUCCESS;
    }

    //
    // Now look for a parent PCI bus that has a _PRT.  We may have to
    // look up the tree a bit.
    //

    while (TRUE) {

        //
        // Find the parent's filter
        //
        KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
        filter = AcpiGetFilter(AcpiArbiter.DeviceObject, parent);
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

        if (filter) {
            //
            // This is a PCI bus that we either enumerated or
            // filtered.
            //

            ASSERT(IsPciBus(filter));

            filterExtension = filter->DeviceExtension;
            pciBusObj = filterExtension->AcpiObject;

            //
            // Look for a _PRT for this PCI bus.
            //
            prtObj = ACPIAmliGetNamedChild(pciBusObj, PACKED_PRT);

            if (prtObj) {

                //
                // We found the _PRT we are looking for.
                //
                break;
            }
        }

        //
        // We didn't find a _PRT.  So go up the PCI tree one
        // and look again.
        //

        bus = (ULONG)-1;
        parentSlot.u.AsULONG = (ULONG)-1;
        status = pciInterface->GetInterruptRouting(parent,
                                                   &bus,
                                                   &parentSlot.u.AsULONG,
                                                   (PUCHAR)&dummy,
                                                   &parentPin,
                                                   &classCode,
                                                   &subClassCode,
                                                   &parent,
                                                   &routingToken,
                                                   (PUCHAR)&dummy);

        if (!NT_SUCCESS(status) ||
            classCode != PCI_CLASS_BRIDGE_DEV) {
            //
            // The parent was not also a PCI device.  So
            // this means that there is no _PRT related to
            // this device.  Just return the contents of
            // the Interrupt Line register.
            //

            *Vector = interruptLine;

            AcpiInterruptRoutingFailed = TRUE;
            return STATUS_SUCCESS;
        }

        if (subClassCode == PCI_SUBCLASS_BR_PCI_TO_PCI) {

            //
            // Swizzle the interrupt pin according to
            // the PCI-PCI bridge spec.
            //

            interruptPin = PciBridgeSwizzle((UCHAR)pciSlot.u.bits.DeviceNumber, interruptPin);
            pciSlot.u.AsULONG = parentSlot.u.AsULONG;

        } else if (subClassCode == PCI_SUBCLASS_BR_CARDBUS) {

            //
            // Swizzle the interrupt pin according to
            // the Cardbus bridge spec.
            //

            interruptPin = parentPin;
            pciSlot.u.AsULONG = parentSlot.u.AsULONG;

        } else {

            //
            // Bail.
            //

            *Vector = interruptLine;
            AcpiInterruptRoutingFailed = TRUE;
            return STATUS_SUCCESS;
        }
    }

    if (AcpiInterruptRoutingFailed == TRUE) {

        //
        // We succeeded in finding a _PRT to work with,
        // but we have failed in the past.  This situation
        // is unrecoverable because we now have dependencies
        // on IRQ routers that we might now accidentally
        // change
        //

        KeBugCheckEx(ACPI_BIOS_ERROR,
                     ACPI_CANNOT_ROUTE_INTERRUPTS,
                     (ULONG_PTR) Pdo,
                     (ULONG_PTR)parent,
                     (ULONG_PTR)prtObj);

    }

    // convert interrupt pin from PCI units to ACPI units
    interruptPin--;

    DEBUG_PRINT(2, ("PCI Device %p had _ADR of %x\n", Pdo, pciSlot.u.AsULONG));
    DEBUG_PRINT(2, ("This device connected to Pin %x\n", interruptPin));
    DEBUG_PRINT(2, ("prtObj: %p\n", prtObj));

    //
    // Cycle through all the elements in the _PRT package
    // (each one of which is also a package) looking for
    // the one that describes the link node that we are
    // looking for.
    //
    do {
        status = AMLIEvalPackageElement(prtObj,
                                        prtElement++,
                                        &prtData);

        if (!NT_SUCCESS(status)) break;

        ASSERT(prtData.dwDataType == OBJTYPE_PKGDATA);

        if (NT_SUCCESS(AMLIEvalPkgDataElement(&prtData,
                                              0,
                                              &adrData))) {

            if (pciSlot.u.bits.DeviceNumber == (adrData.uipDataValue >> 16)) {

                if ((adrData.uipDataValue & 0xffff) != 0xffff) {
                  ////
                  //// An _ADR in a _PRT must be of the form xxxxFFFF,
                  //// which means that the PCI Device Number is specified,
                  //// but the Function Number isn't.  If it isn't done this
                  //// way, then the machine vendor can introduce
                  //// dangerous ambiguities.  (Beside that, Pierre makes
                  //// Memphis bugcheck if it sees this and I'm trying to
                  //// be consistent.)  So bugcheck.
                  ////
                  //KeBugCheckEx(ACPI_BIOS_ERROR,
                  //             ACPI_PRT_HAS_INVALID_FUNCTION_NUMBERS,
                  //             (ULONG_PTR)prtObj,
                  //             prtElement,
                  //             adrData.uipDataValue);


                    DEBUG_PRINT(0, ("PRT entry has ambiguous address %x\n", adrData.uipDataValue));

                    status = STATUS_INVALID_PARAMETER;
                    pciSlot.u.bits.DeviceNumber = (ULONG)(adrData.uipDataValue >> 16) & 0xffff;
                    pciSlot.u.bits.FunctionNumber = (ULONG)(adrData.uipDataValue & 0xffff);
                    AMLIFreeDataBuffs(&adrData, 1);
                    AMLIFreeDataBuffs(&prtData, 1);
                    goto AcpiArbCrackPRTError;
                }

                //
                // This sub-package does refer to the PCI device
                // that we are concerned with.  Now look to see if
                // we have found the link node that is connected
                // to the PCI interrupt PIN that this device will trigger.
                //
                // N.B.  We only have to compare the top 16 bits
                //       because the function number is irrelevent
                //       when considering interrupts.  We get the
                //       pin from config space.
                //

                if (NT_SUCCESS(AMLIEvalPkgDataElement(&prtData,
                                                      1,
                                                      &pinData))) {

                    if (pinData.uipDataValue == interruptPin) {
                        //
                        // This is the package that describes the link node we
                        // are interested in.  Get the name of the link node.
                        //
                        if (NT_SUCCESS(AMLIEvalPkgDataElement(&prtData,
                                                              2,
                                                              &linkData))) {
                            found = TRUE;
                        }

                        //
                        // Look at the Source Index, too.
                        //
                        if (NT_SUCCESS(AMLIEvalPkgDataElement(&prtData,
                                                              3,
                                                              &indexData))) {
                            found = TRUE;
                        }
                    }
                    AMLIFreeDataBuffs(&pinData, 1);
                }
            }
            AMLIFreeDataBuffs(&adrData, 1);
        }

        AMLIFreeDataBuffs(&prtData, 1);

    } while (found == FALSE);

    status = STATUS_NOT_FOUND;

    if (found) {

        //
        // First check to see if linkData is valid.  If it is,
        // then we use it.
        //
        if (linkData.dwDataType == OBJTYPE_STRDATA) {
            if (linkData.pbDataBuff) {

                status = AMLIGetNameSpaceObject(linkData.pbDataBuff,
                                                prtObj,
                                                LinkNode,
                                                0);

                if (NT_SUCCESS(status)) {

                    routingToken.LinkNode = *LinkNode;
                    routingToken.StaticVector = 0;
                    routingToken.Flags = 0;

                    pciInterface->SetInterruptRoutingToken(Pdo,
                                                           &routingToken);

                    goto AcpiArbCrackPRTExit;
                }

                status = STATUS_OBJECT_NAME_NOT_FOUND;
                goto AcpiArbCrackPRTError;

            }

        }

        //
        // If linkData didn't pan out, then use indexData.
        //
        if (indexData.dwDataType == OBJTYPE_INTDATA) {
            //
            // We have an integer which describes the "Global System Interrupt Vector"
            // that this PCI device will trigger.
            //
            *Vector = (ULONG)indexData.uipDataValue;

            status = STATUS_SUCCESS;

            routingToken.LinkNode = 0;
            routingToken.StaticVector = *Vector;
            routingToken.Flags = PCI_STATIC_ROUTING;

            pciInterface->SetInterruptRoutingToken(Pdo,
                                                   &routingToken);

            goto AcpiArbCrackPRTExit;

        }

        status = STATUS_INVALID_IMAGE_FORMAT;

AcpiArbCrackPRTExit:
    AMLIFreeDataBuffs(&linkData, 1);
    AMLIFreeDataBuffs(&indexData, 1);

    }
    else

AcpiArbCrackPRTError:
    {
        ANSI_STRING     ansiString;
        UNICODE_STRING  unicodeString;
        UNICODE_STRING  slotName;
        UNICODE_STRING  funcName;
        PWCHAR  prtEntry[4];
        WCHAR   IRQARBname[20];
        WCHAR   slotBuff[10];
        WCHAR   funcBuff[10];

        swprintf( IRQARBname, L"IRQARB");
        RtlInitUnicodeString(&slotName, slotBuff);
        RtlInitUnicodeString(&funcName, funcBuff);

        if (!NT_SUCCESS(RtlIntegerToUnicodeString(pciSlot.u.bits.DeviceNumber, 0, &slotName))) {
            return status;
        }

        if (!NT_SUCCESS(RtlIntegerToUnicodeString(pciSlot.u.bits.FunctionNumber, 0, &funcName))) {
            return status;
        }

        prtEntry[0] = IRQARBname;
        prtEntry[1] = slotBuff;
        prtEntry[2] = funcBuff;

        switch (status) {
        case STATUS_OBJECT_NAME_NOT_FOUND:

            RtlInitAnsiString(&ansiString,
                              linkData.pbDataBuff);

            RtlAnsiStringToUnicodeString(&unicodeString,
                                         &ansiString,
                                         TRUE);

            prtEntry[3] = unicodeString.Buffer;

            ACPIWriteEventLogEntry(ACPI_ERR_MISSING_LINK_NODE,
                                   &prtEntry,
                                   4,
                                   NULL,
                                   0);

            RtlFreeUnicodeString(&unicodeString);

            DEBUG_PRINT(0, ("Couldn't find link node (%s)\n", linkData.pbDataBuff));
            //KeBugCheckEx(ACPI_BIOS_ERROR,
            //             ACPI_PRT_CANNOT_FIND_LINK_NODE,
            //             (ULONG_PTR)Pdo,
            //             (ULONG_PTR)linkData.pbDataBuff,
            //             (ULONG_PTR)prtObj);

            break;

        case STATUS_NOT_FOUND:

            ACPIWriteEventLogEntry(ACPI_ERR_MISSING_PRT_ENTRY,
                                   &prtEntry,
                                   3,
                                   NULL,
                                   0);

            DEBUG_PRINT(0, ("The ACPI _PRT package didn't contain a mapping for the PCI\n"));
            DEBUG_PRINT(0, ("device at _ADR %x\n", pciSlot.u.AsULONG));
            //KeBugCheckEx(ACPI_BIOS_ERROR,
            //             ACPI_PRT_CANNOT_FIND_DEVICE_ENTRY,
            //             (ULONG_PTR)Pdo,
            //             pciSlot.u.AsULONG,
            //             (ULONG_PTR)prtObj);
            break;

        case STATUS_INVALID_PARAMETER:

            ACPIWriteEventLogEntry(ACPI_ERR_AMBIGUOUS_DEVICE_ADDRESS,
                                   &prtEntry,
                                   3,
                                   NULL,
                                   0);
            break;
        }

        status = STATUS_UNSUCCESSFUL;

    }

    return status;
}


PDEVICE_OBJECT
AcpiGetFilter(
    IN  PDEVICE_OBJECT Root,
    IN  PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:

    This routine takes a PDO for a device and returns the
    DO of the filter that ACPI has slapped onto it.  In the
    case that this PDO belongs to the ACPI driver, then
    it is returned.

Arguments:

    Root    - The device object that we are using as the
              root of the search.

    Pdo     - The PDO of the device who's filter we seek

Return Value:

    a DEVICE_OBJECT, if ACPI is filtering this Pdo, NULL otherwise

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_EXTENSION   childExtension;
    PDEVICE_EXTENSION   firstChild;
    PDEVICE_OBJECT      filter;

    deviceExtension = Root->DeviceExtension;

    //
    // If Root is the filter, we are done.
    //
    if (((deviceExtension->Flags & DEV_TYPE_PDO) ||
         (deviceExtension->Flags & DEV_TYPE_FILTER)) &&
        (deviceExtension->PhysicalDeviceObject == Pdo)) {

        ASSERT(Root->Type == IO_TYPE_DEVICE);

        return Root;
    }

    //
    // Return NULL if this device has no children,
    // (which is signified by the ChildDeviceList pointer
    // pointing to itself.
    //
    if (deviceExtension->ChildDeviceList.Flink ==
        (PVOID)&(deviceExtension->ChildDeviceList.Flink)) {

        return NULL;
    }

    firstChild = (PDEVICE_EXTENSION) CONTAINING_RECORD(
        deviceExtension->ChildDeviceList.Flink,
        DEVICE_EXTENSION,
        SiblingDeviceList );

    childExtension = firstChild;

    do {
        //
        // Make sure the device extension is complete.
        //
        if (childExtension->DeviceObject) {
            filter = AcpiGetFilter(childExtension->DeviceObject, Pdo);

            if (filter) {
                return filter;
            }
        }

        childExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
            childExtension->SiblingDeviceList.Flink,
            DEVICE_EXTENSION,
            SiblingDeviceList );

    } while (childExtension != firstChild);

    //
    // Must not be on this branch...
    //

    return NULL;
}

BOOLEAN
LinkNodeInUse(
    IN PARBITER_INSTANCE Arbiter,
    IN PNSOBJ            LinkNode,
    IN OUT ULONG         *Irq,  OPTIONAL
    IN OUT UCHAR         *Flags OPTIONAL
    )
/*++

Routine Description:

    This routine indicates whether a link node is current
    in use and, if so, returns the IRQ that it is currently
    connected to.

Arguments:

    Arbiter     - current arbiter state

    LinkNode    - link node in question

    Irq         - "Global System Interrupt Vector" that
                  the link node is currently using.

    Flags       - flags associated with the vector that
                  the link node is connected to.

Return Value:

    TRUE if the link node is currently being used.

--*/
{

    PLIST_ENTRY linkNodes;
    PLINK_NODE  linkNode;
    NTSTATUS    status;

    PAGED_CODE();

    ASSERT(LinkNode);

    linkNodes = &((PARBITER_EXTENSION)(Arbiter->Extension))->LinkNodeHead;

    if (IsListEmpty(linkNodes)) {
        //
        // There are no link nodes in use.
        //
        DEBUG_PRINT(3, ("LinkNode list empty\n"));
        return FALSE;
    }

    linkNode = (PLINK_NODE)linkNodes->Flink;

    while (linkNode != (PLINK_NODE)linkNodes) {
        //
        // Is this the node we were looking for?
        //
        if (linkNode->NameSpaceObject == LinkNode) {

            if((LONG)(linkNode->ReferenceCount + linkNode->TempRefCount) > 0) {

                //
                // This link node is on the list and it is currently referenced.
                //

                if (Irq) *Irq = (ULONG)linkNode->TempIrq;
                if (Flags) *Flags = linkNode->Flags;

                DEBUG_PRINT(3, ("Link Node %p is in use\n", LinkNode));
                return TRUE;

            } else {
                DEBUG_PRINT(3, ("Link Node %p is currently unreferenced\n", LinkNode));
                return FALSE;
            }
        }

        linkNode = (PLINK_NODE)linkNode->List.Flink;
    }

    DEBUG_PRINT(3, ("Didn't find our link node (%p) on the Link Node List\n", LinkNode));
    //
    // Didn't ever find the link node we were looking for.
    //
    return FALSE;
}

NTSTATUS
GetLinkNodeFlags(
    IN PARBITER_INSTANCE Arbiter,
    IN PNSOBJ LinkNode,
    IN OUT UCHAR *Flags
    )
{
    NTSTATUS status;
    BOOLEAN inUse;

    PAGED_CODE();

    //
    // This guarantees that LinkNodeInUse will succeed
    // and will contain the valid flags.
    //
    status = AcpiArbReferenceLinkNode(Arbiter,
                                      LinkNode,
                                      0);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    inUse = LinkNodeInUse(Arbiter,
                          LinkNode,
                          NULL,
                          Flags);

    ASSERT(inUse);

    //
    // Set the state back to the way we found it.
    //

    status = AcpiArbDereferenceLinkNode(Arbiter,
                                        LinkNode);

    ASSERT(NT_SUCCESS(status));

    return STATUS_SUCCESS;
}


NTSTATUS
AcpiArbReferenceLinkNode(
    IN PARBITER_INSTANCE    Arbiter,
    IN PNSOBJ               LinkNode,
    IN ULONG                Irq
    )
/*++

Routine Description:

    This routine keeps two reference counts.  The first
    is a permanent count, representing hardware resources
    that have been committed.  The second is a delta
    representing what is currently under consideration.

Arguments:

    Arbiter     - current arbiter state

    LinkNode    - link node in question

    Irq         - "Global System Interrupt Vector" that
                  the link node is connected to.

    Permanently - indicates whether this reference is
                  for a committed allocation


Return Value:

    status

--*/
{
    PCM_RESOURCE_LIST resList = NULL;
    PLIST_ENTRY linkNodes;
    PLINK_NODE  linkNode;
    BOOLEAN     found = FALSE;
    NTSTATUS    status;
    UCHAR       flags;

    PAGED_CODE();

    DEBUG_PRINT(3, ("Referencing link node %p, Irq: %x\n",
                    LinkNode,
                    Irq));

    ASSERT(LinkNode);

    linkNodes = &((PARBITER_EXTENSION)(Arbiter->Extension))->LinkNodeHead;
    linkNode = (PLINK_NODE)linkNodes->Flink;

    //
    // Search to see if we are already know about this link node.
    //
    while (linkNode != (PLINK_NODE)linkNodes) {

        if (linkNode->NameSpaceObject == LinkNode) {

            found = TRUE;
            break;
        }

        linkNode = (PLINK_NODE)linkNode->List.Flink;
    }

    //
    // If not, then we need to keep track of it.  And
    // the hardware needs to be made to match it.
    //
    if (!found) {

        //
        // This is the first permanent reference. So
        // program the link node hardware.
        //

        linkNode = ExAllocatePoolWithTag(NonPagedPool, sizeof(LINK_NODE), ACPI_ARBITER_POOLTAG);

        if (!linkNode) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(linkNode, sizeof(LINK_NODE));

        linkNode->NameSpaceObject = LinkNode;
        linkNode->CurrentIrq      = Irq;
        linkNode->TempIrq         = Irq;
        linkNode->AttachedDevices.Next = (PSINGLE_LIST_ENTRY)&linkNode->AttachedDevices;

        InsertTailList(linkNodes, ((PLIST_ENTRY)(linkNode)));

        //
        // Figure out what the flags ought to be.
        //

        status = AcpiArbGetLinkNodeOptions(LinkNode,
                                           &resList,
                                           &flags);

        if (NT_SUCCESS(status)) {

            ExFreePool(resList);    // not actually needed here

            //
            // Record the flags associated with this link node.
            //

            linkNode->Flags = flags;

        } else {

            ASSERT(NT_SUCCESS(status));

            //
            // Something is wrong.  Make up reasonable flags.
            //

            linkNode->Flags = VECTOR_LEVEL | VECTOR_ACTIVE_LOW;
        }

        DEBUG_PRINT(3, ("Link node object connected to vector %x\n", Irq));

    }
#if DBG
      else {

        if (!((linkNode->ReferenceCount == 0) &&
              (linkNode->TempRefCount == 0))) {

            //
            // Make sure that we maintain consistency
            // with the flags.
            //

            //
            // Check to see that the link node hasn't changed.
            //
            status = AcpiArbGetLinkNodeOptions(LinkNode,
                                               &resList,
                                               &flags);

            if (resList) ExFreePool(resList);  // not actually needed here
            ASSERT(NT_SUCCESS(status));
            ASSERT(flags == linkNode->Flags);
        }
    }
#endif

    DEBUG_PRINT(3, ("  %d:%d\n", linkNode->ReferenceCount, linkNode->TempRefCount));

    //
    // Increase its reference count.
    //

    linkNode->TempIrq = Irq;
    linkNode->TempRefCount++;

    return STATUS_SUCCESS;
}

NTSTATUS
AcpiArbDereferenceLinkNode(
    IN PARBITER_INSTANCE    Arbiter,
    IN PNSOBJ               LinkNode
    )
/*++

Routine Description:

    This routine is the converse of the one above.

Arguments:

    Arbiter     - current arbiter state

    LinkNode    - link node in question

    Permanently - indicates whether this reference is
                  for a committed allocation

Return Value:

    status

--*/
{
    PSINGLE_LIST_ENTRY attachedDev;
    PLIST_ENTRY linkNodes;
    PLINK_NODE  linkNode;
    BOOLEAN     found = FALSE;

    PAGED_CODE();

    ASSERT(LinkNode);

    linkNodes = &((PARBITER_EXTENSION)(Arbiter->Extension))->LinkNodeHead;
    linkNode = (PLINK_NODE)linkNodes->Flink;

    //
    // Search for this link node.
    //

    while (linkNode != (PLINK_NODE)linkNodes) {

        if (linkNode->NameSpaceObject == LinkNode) {

            found = TRUE;
            break;
        }

        linkNode = (PLINK_NODE)linkNode->List.Flink;
    }

    ASSERT(found);
    DEBUG_PRINT(3, ("Dereferencing link node %p  %d:%d\n", LinkNode, linkNode->ReferenceCount, linkNode->TempRefCount));

    linkNode->TempRefCount--;

    return STATUS_SUCCESS;
}

NTSTATUS
ClearTempLinkNodeCounts(
    IN PARBITER_INSTANCE    Arbiter
    )
/*++

Routine Description:

    This routine resets all the temporary counts (deltas)
    to zero because the allocations being considered are
    being thrown away instead of being committed.

Arguments:

    Arbiter     - current arbiter state

Return Value:

    status

--*/
{
    PLIST_ENTRY linkNodes;
    PLINK_NODE  linkNode;

    PAGED_CODE();

    linkNodes = &((PARBITER_EXTENSION)(Arbiter->Extension))->LinkNodeHead;

    linkNode = (PLINK_NODE)linkNodes->Flink;

    //
    // Run through the link nodes.
    //

    while (linkNode != (PLINK_NODE)linkNodes) {

        linkNode->TempRefCount = 0;
        linkNode->TempIrq = linkNode->CurrentIrq;

        linkNode = (PLINK_NODE)linkNode->List.Flink;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MakeTempLinkNodeCountsPermanent(
    IN PARBITER_INSTANCE    Arbiter
    )
/*++

Routine Description:

    This routine reconciles the temporary and
    permanent references because the resources being
    considered are being committed.

Arguments:

    Arbiter     - current arbiter state

Return Value:

    status

--*/
{
    CM_PARTIAL_RESOURCE_DESCRIPTOR irqDesc;
    PLIST_ENTRY linkNodes;
    PLINK_NODE  linkNode, nextNode;
    UCHAR       flags;
    PNSOBJ      dis;

    PAGED_CODE();
    DEBUG_PRINT(3, ("MakeTempLinkNodeCountsPermanent\n"));

    //
    // Run through the link nodes.
    //

    linkNodes = &((PARBITER_EXTENSION)(Arbiter->Extension))->LinkNodeHead;
    linkNode = (PLINK_NODE)linkNodes->Flink;

    while (linkNode != (PLINK_NODE)linkNodes) {

        nextNode = (PLINK_NODE)linkNode->List.Flink;

        DEBUG_PRINT(3, ("LinkNode: %p -- Perm: %d, Temp: %d\n",
                        linkNode,
                        linkNode->ReferenceCount,
                        linkNode->TempRefCount));

        //
        // Attempt to sanity check this link node.
        //

        ASSERT(linkNode);
        ASSERT(linkNode->List.Flink);
        ASSERT(linkNode->ReferenceCount <= 70);
        ASSERT(linkNode->TempRefCount <= 70);
        ASSERT(linkNode->TempRefCount >= -70);
        ASSERT(linkNode->CurrentIrq < 0x80000000);
        ASSERT((linkNode->Flags & ~(VECTOR_MODE | VECTOR_POLARITY)) == 0);

        //
        // Program the link node if either the previous reference count
        // was 0 or if the previous IRQ was different.  *And* the current
        // reference count is non-zero.
        //

        if (((linkNode->ReferenceCount == 0) ||
             (linkNode->CurrentIrq != linkNode->TempIrq)) &&
             ((linkNode->ReferenceCount + linkNode->TempRefCount) != 0)) {

            irqDesc.Type = CmResourceTypeInterrupt;
            irqDesc.ShareDisposition = CmResourceShareShared;
            irqDesc.Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
            irqDesc.u.Interrupt.Level = (ULONG)linkNode->TempIrq;
            irqDesc.u.Interrupt.Vector = (ULONG)linkNode->TempIrq;
            irqDesc.u.Interrupt.Affinity = 0xffffffff;

            AcpiArbSetLinkNodeIrq(linkNode->NameSpaceObject,
                                  &irqDesc);

        }

        if ((linkNode->ReferenceCount + linkNode->TempRefCount) == 0) {

            //
            // This link node has no more references.  Disable it.
            //

            dis = ACPIAmliGetNamedChild(linkNode->NameSpaceObject, PACKED_DIS);
            if (dis) {
                AMLIEvalNameSpaceObject(dis, NULL, 0, NULL);
            }
        }


        linkNode->ReferenceCount = linkNode->ReferenceCount +
            linkNode->TempRefCount;
        linkNode->TempRefCount = 0;
        linkNode->CurrentIrq = linkNode->TempIrq;

        linkNode = nextNode;
    }

    return STATUS_SUCCESS;
}
#ifdef DBG
VOID
TrackDevicesConnectedToLinkNode(
    IN PNSOBJ LinkNode,
    IN PDEVICE_OBJECT Pdo
    )
{
    PLINK_NODE_ATTACHED_DEVICES attachedDevs, newPdo;
    PLIST_ENTRY linkNodes;
    PLINK_NODE  linkNode, nextNode;
    BOOLEAN     found = FALSE;

    PAGED_CODE();

    //
    // Run through the link nodes.
    //

    linkNodes = &((PARBITER_EXTENSION)(AcpiArbiter.ArbiterState.Extension))->LinkNodeHead;
    linkNode = (PLINK_NODE)linkNodes->Flink;

    while (linkNode != (PLINK_NODE)linkNodes) {
        if (linkNode->NameSpaceObject == LinkNode) {

            found = TRUE;
            break;
        }

        linkNode = (PLINK_NODE)linkNode->List.Flink;
    }

    if (found) {

        attachedDevs = (PLINK_NODE_ATTACHED_DEVICES)linkNode->AttachedDevices.Next;
        found = FALSE;

        while (attachedDevs != (PLINK_NODE_ATTACHED_DEVICES)&linkNode->AttachedDevices.Next) {

            if (attachedDevs->Pdo == Pdo) {
                found = TRUE;
                break;
            }

            attachedDevs = (PLINK_NODE_ATTACHED_DEVICES)attachedDevs->List.Next;
        }

        if (!found) {

            newPdo = ExAllocatePoolWithTag(PagedPool,
                                           sizeof(LINK_NODE_ATTACHED_DEVICES),
                                           ACPI_ARBITER_POOLTAG);
            if (!newPdo) {
                return;
            }

            RtlZeroMemory(newPdo, sizeof(LINK_NODE_ATTACHED_DEVICES));

            newPdo->Pdo = Pdo;

            PushEntryList(&linkNode->AttachedDevices,
                          (PSINGLE_LIST_ENTRY)newPdo);

        }
    }
}
#endif

typedef enum {
    RestoreStateInitial,
    RestoreStateDisabled,
    RestoreStateEnabled
} RESTORE_IRQ_STATE, *PRESTORE_IRQ_STATE;

typedef struct {
    CM_PARTIAL_RESOURCE_DESCRIPTOR  IrqDesc;
    PLIST_ENTRY LinkNodes;
    PLINK_NODE  LinkNode;
    RESTORE_IRQ_STATE State;
    KSPIN_LOCK  SpinLock;
    KIRQL       OldIrql;
    BOOLEAN     CompletingSetLink;
    LONG        RunCompletion;
    PFNACB      CompletionHandler;
    PVOID       CompletionContext;
} RESTORE_ROUTING_STATE, *PRESTORE_ROUTING_STATE;

NTSTATUS
IrqArbRestoreIrqRouting(
    PFNACB      CompletionHandler,
    PVOID       CompletionContext
    )
/*++

Routine Description:

    This routine will set all the IRQ router settings
    to whatever is described in the Link Node list.
    This is useful when the machine is coming out
    of hibernation.

Arguments:

Return Value:

    status

Notes:

    This function is expected to run at DPC level
    during machine wakeup.  It is assumed that no
    other part of the arbiter code will be running
    at that time.  Since we can't wait for the
    arbiter lock at DPC level, we will have to
    assume it is not taken.

--*/
{
    PRESTORE_ROUTING_STATE   state;
    PARBITER_INSTANCE        arbiter;
    NTSTATUS    status;

    //
    // First check to see if there is any work to do.
    //

    if (HalPicStateIntact()) {
        return STATUS_SUCCESS;
    }

    state = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(RESTORE_ROUTING_STATE),
                                  ACPI_ARBITER_POOLTAG);

    if (!state) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(state, sizeof(RESTORE_ROUTING_STATE));

    state->State = RestoreStateInitial;
    state->RunCompletion = INITIAL_RUN_COMPLETION;
    state->CompletionHandler = CompletionHandler;
    state->CompletionContext = CompletionContext;
    state->IrqDesc.Type = CmResourceTypeInterrupt;
    state->IrqDesc.ShareDisposition = CmResourceShareShared;
    state->IrqDesc.Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
    state->IrqDesc.u.Interrupt.Affinity = 0xffffffff;

    arbiter = &AcpiArbiter.ArbiterState;
    state->LinkNodes = &((PARBITER_EXTENSION)(arbiter->Extension))->LinkNodeHead;

    state->LinkNode = (PLINK_NODE)state->LinkNodes->Flink;

    KeInitializeSpinLock(&state->SpinLock);

    return IrqArbRestoreIrqRoutingWorker(state->LinkNode->NameSpaceObject,
                                         STATUS_SUCCESS,
                                         NULL,
                                         (PVOID)state
                                         );
}

NTSTATUS
EXPORT
IrqArbRestoreIrqRoutingWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
{
    NTSTATUS                status = Status;
    PDEVICE_EXTENSION       deviceExtension;
    PRESTORE_ROUTING_STATE  state;

    state = (PRESTORE_ROUTING_STATE)Context;

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //

    InterlockedIncrement(&state->RunCompletion);

    switch (state->State) {
    case RestoreStateInitial:


        state->State = RestoreStateDisabled;
        deviceExtension = ACPIInternalGetDeviceExtension( AcpiArbiter.DeviceObject );
        status = DisableLinkNodesAsync(
                     deviceExtension->AcpiObject,
                     IrqArbRestoreIrqRoutingWorker,
                     (PVOID)state);

        if (status == STATUS_PENDING) {
            return status;
        }

        //
        // Fall through
        //

    case RestoreStateDisabled:

        KeAcquireSpinLock(&state->SpinLock,
                          &state->OldIrql);

        while (state->LinkNode != (PLINK_NODE)state->LinkNodes) {

            if (state->LinkNode->ReferenceCount > 0) {

                //
                // Program the link node.
                //
                state->IrqDesc.u.Interrupt.Level = (ULONG)state->LinkNode->CurrentIrq;
                state->IrqDesc.u.Interrupt.Vector = (ULONG)state->LinkNode->CurrentIrq;

                if (!state->CompletingSetLink) {

                    status = AcpiArbSetLinkNodeIrqAsync(state->LinkNode->NameSpaceObject,
                                                        &state->IrqDesc,
                                                        IrqArbRestoreIrqRoutingWorker,
                                                        (PVOID)state
                                                        );

                    if (status == STATUS_PENDING) {
                        state->CompletingSetLink = TRUE;
                        KeReleaseSpinLock(&state->SpinLock,
                                          state->OldIrql);
                        return status;
                    }
                }
            }

            state->CompletingSetLink = FALSE;
            state->LinkNode = (PLINK_NODE)state->LinkNode->List.Flink;
        }

        state->State = RestoreStateEnabled;

        KeReleaseSpinLock(&state->SpinLock,
                          state->OldIrql);

    case RestoreStateEnabled:

        //
        // Now that we are done programming all the link nodes,
        // we need to restore the ELCR and unmask all the
        // device interrupts.
        //

        HalRestorePicState();

        if (state->RunCompletion) {

            state->CompletionHandler(AcpiObject,
                                     status,
                                     NULL,
                                     state->CompletionContext
                                     );
        }

    }

    ExFreePool(state);
    return status;
}

typedef enum {
    DisableStateInitial,
    DisableStateGotHid,
    DisableStateRanDis,
    DisableStateGetChild,
    DisableStateRecursing
} DISABLE_LINK_NODES_STATE;

typedef struct {
    DISABLE_LINK_NODES_STATE State;
    PNSOBJ  RootDevice;
    PUCHAR  Hid;
    PNSOBJ  Dis;
    PNSOBJ  Sibling;
    PNSOBJ  NextSibling;
    LONG    RunCompletionHandler;
    PFNACB  CompletionHandler;
    PVOID   CompletionContext;
} DISABLE_LINK_NODES_CONTEXT, *PDISABLE_LINK_NODES_CONTEXT;

NTSTATUS
DisableLinkNodesAsync(
    IN PNSOBJ    Root,
    IN PFNACB    CompletionHandler,
    IN PVOID     CompletionContext
    )
{
    PDISABLE_LINK_NODES_CONTEXT context;
    NTSTATUS status;

    context = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(DISABLE_LINK_NODES_CONTEXT),
                                    ACPI_ARBITER_POOLTAG);

    if (!context) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(context, sizeof(DISABLE_LINK_NODES_CONTEXT));

    context->State = DisableStateInitial;
    context->RootDevice = Root;
    context->CompletionHandler = CompletionHandler;
    context->CompletionContext = CompletionContext;
    context->RunCompletionHandler = INITIAL_RUN_COMPLETION;

    return DisableLinkNodesAsyncWorker(Root,
                                       STATUS_SUCCESS,
                                       NULL,
                                       (PVOID)context
                                       );
}

NTSTATUS
EXPORT
DisableLinkNodesAsyncWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
{
    PDISABLE_LINK_NODES_CONTEXT context;
    NTSTATUS    status = STATUS_SUCCESS;
    PNSOBJ      sib;
    PNSOBJ      dis;

    context = (PDISABLE_LINK_NODES_CONTEXT)Context;
    ASSERT(context);

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //

    InterlockedIncrement(&context->RunCompletionHandler);

DisableLinkNodeStartState:

    switch (context->State) {
    case DisableStateInitial:

        //
        // Get the _HID of this device to see if
        // it is a link node.
        //

        context->State = DisableStateGotHid;
        status = ACPIGetNSPnpIDAsync(
            context->RootDevice,
            DisableLinkNodesAsyncWorker,
            context,
            &context->Hid,
            NULL);

        if (status == STATUS_PENDING) {
            return status;
        } else if (!NT_SUCCESS(status)) {

            context->State = DisableStateGetChild;
            goto DisableLinkNodeStartState;
        }

        //
        // Fall through to next state.
        //

    case DisableStateGotHid:

        context->State = DisableStateGetChild;

        if (context->Hid) {

            if (strstr(context->Hid, LINK_NODE_PNP_ID)) {

                //
                // We found a _HID of PNP0C0F, which is a
                // link node.  So disable it.
                //

                dis = ACPIAmliGetNamedChild(context->RootDevice,
                                            PACKED_DIS);

                if (dis) {

                    context->State = DisableStateRanDis;
                    status = AMLIAsyncEvalObject(dis,
                                                 NULL,
                                                 0,
                                                 NULL,
                                                 DisableLinkNodesAsyncWorker,
                                                 (PVOID)context
                                                 );

                    if (status == STATUS_PENDING) {
                        return status;

                    } else if (NT_SUCCESS(status)) {

                        //
                        // We're done.  Jump to the cleanup code.
                        //
                        break;
                    }

                } else {

                    //
                    // Link nodes must be disablable.
                    //

                    KeBugCheckEx(ACPI_BIOS_ERROR,
                                 ACPI_LINK_NODE_CANNOT_BE_DISABLED,
                                 (ULONG_PTR)context->RootDevice,
                                 0,
                                 0);
                }
            }
        }

    case DisableStateGetChild:

        //
        // Recurse to all of the children.  Propagate any errors,
        // but don't stop for them.
        //

        context->Sibling = NSGETFIRSTCHILD(context->RootDevice);

        if (!context->Sibling) {
            status = STATUS_SUCCESS;
            break;
        }

        context->State = DisableStateRecursing;

    case DisableStateRecursing:

        while (context->Sibling) {

            //
            // Cycle through all the children (child and its
            // siblings)
            //

            sib = context->Sibling;
            context->Sibling = NSGETNEXTSIBLING(context->Sibling);

            switch (NSGETOBJTYPE(sib)) {
            case OBJTYPE_DEVICE:

                //
                // This name child of Root is also a device.
                // Recurse.
                //

                status = DisableLinkNodesAsync(sib,
                                               DisableLinkNodesAsyncWorker,
                                               (PVOID)context);
                break;

            default:
                break;
            }

            if (status == STATUS_PENDING) {
                return status;
            }
        }

    case DisableStateRanDis:
        break;
    }

    //
    // Done.  Clean up and return.
    //

    if (context->RunCompletionHandler) {

        context->CompletionHandler(context->RootDevice,
                                   status,
                                   NULL,
                                   context->CompletionContext
                                   );
    }

    if (context->Hid) ExFreePool(context->Hid);
    ExFreePool(context);
    return status;
}

NTSTATUS
GetIsaVectorFlags(
    IN ULONG        Vector,
    IN OUT UCHAR    *Flags
    )
{
    ULONG i;
    ULONG irq;
    UCHAR flags;
    NTSTATUS returnStatus = STATUS_NOT_FOUND;
    NTSTATUS status;

    PAGED_CODE();

    for (i = 0; i < ISA_PIC_VECTORS; i++) {

        status = LookupIsaVectorOverride(i,
                                         &irq,
                                         &flags);

        if (NT_SUCCESS(status)) {

            if (irq == Vector) {

                //
                // This vector's flags have been overriden.
                //

                *Flags = flags;

                ASSERT((*Flags & ~(VECTOR_MODE | VECTOR_POLARITY | VECTOR_TYPE)) == 0);
                returnStatus = STATUS_SUCCESS;
                break;
            }
        }
    }
    return returnStatus;
}

NTSTATUS
LookupIsaVectorOverride(
    IN ULONG IsaVector,
    IN OUT ULONG *RedirectionVector OPTIONAL,
    IN OUT UCHAR *Flags OPTIONAL
    )
/*++

Routine Description:

    This function looks to see if this vector has
    been overridden in the MAPIC table.

Arguments:

    IsaVector - ISA vector

    RedirectionVector - vector that the ISA vector
        will actually trigger

    Flags  - flags in the override table

Return Value:

    STATUS_SUCCESS if the ISA vector exists in the
        MAPIC table

    STATUS_NOT_FOUND if it doesn't

--*/
{
    PAPICTABLE  ApicEntry;
    PISA_VECTOR IsaEntry;
    PUCHAR      TraversePtr;
    PMAPIC      ApicTable;
    USHORT      entryFlags;
    ULONG_PTR   TableEnd;

    PAGED_CODE();

    if (InterruptModel == 0) {

        //
        // This machine is running in PIC mode, so
        // we should ignore anything from an APIC table.
        //

        return STATUS_NOT_FOUND;
    }

    if (IsaVector >= ISA_PIC_VECTORS) {

        //
        // This vector was never an ISA vector.
        //

        return STATUS_NOT_FOUND;
    }

    //
    // Walk the MAPIC table.
    //

    ApicTable = AcpiInformation->MultipleApicTable;

    if (!ApicTable) {

        //
        // This machine didn't have an MAPIC table.  So it
        // must not be running in APIC mode.  So there must
        // not be any overrides.
        //

        return STATUS_NOT_FOUND;
    }

    TraversePtr = (PUCHAR)ApicTable->APICTables;
    TableEnd = (ULONG_PTR)ApicTable +ApicTable->Header.Length;
    while ((ULONG_PTR)TraversePtr < TableEnd) {

        ApicEntry = (PAPICTABLE) TraversePtr;
        if (ApicEntry->Type == ISA_VECTOR_OVERRIDE &&
            ApicEntry->Length == ISA_VECTOR_OVERRIDE_LENGTH) {

            //
            // Found an ISA vector redirection entry.
            //
            IsaEntry = (PISA_VECTOR) TraversePtr;
            if (IsaEntry->Source == IsaVector) {

                if (RedirectionVector) {

                    *RedirectionVector = IsaEntry->GlobalSystemInterruptVector;
                }

                if (Flags) {

                    entryFlags = IsaEntry->Flags;

                    *Flags = 0;

                    if (((entryFlags & PO_BITS) == POLARITY_HIGH) ||
                        ((entryFlags & PO_BITS) == POLARITY_CONFORMS_WITH_BUS)) {

                        *Flags |= VECTOR_ACTIVE_HIGH;

                    } else {

                        *Flags |= VECTOR_ACTIVE_LOW;
                    }

                    if (((entryFlags & EL_BITS) == EL_EDGE_TRIGGERED) ||
                        ((entryFlags & EL_BITS) == EL_CONFORMS_WITH_BUS)) {

                        *Flags |= VECTOR_EDGE;

                    } else {

                        *Flags |= VECTOR_LEVEL;
                    }
                }

                return STATUS_SUCCESS;
            }

        }

        //
        // Sanity check to make sure that we abort tables with bogus length
        // entries
        //
        if (ApicEntry->Length == 0) {

            break;

        }
        TraversePtr += (ApicEntry->Length);

    }

    return STATUS_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\osnotify.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    osnotify.h

Abstract:

    This module implements all the callbacks that are NT specific from
    the AML Interperter

Environment

    Kernel mode only

Revision History:

    01-Mar-98 Initial Revision [split from callback.h]

--*/

#ifndef _OSNOTIFY_H_
#define _OSNOTIFY_H_

    typedef struct _ACPI_FATAL_ERROR_CONTEXT {
        WORK_QUEUE_ITEM Item;
        ULONG           Param1;
        ULONG           Param2;
        ULONG           Param3;
        ULONG_PTR       Context;
    } ACPI_FATAL_ERROR_CONTEXT, *PACPI_FATAL_ERROR_CONTEXT;

    extern  ACPI_FATAL_ERROR_CONTEXT    AcpiFatalContext;
    extern  KSPIN_LOCK                  AcpiFatalLock;
    extern  BOOLEAN                     AcpiFatalOutstanding;

    NTSTATUS
    EXPORT
    OSNotifyCreate(
        IN  ULONG       ObjType,
        IN  PNSOBJ      AcpiObject
        );

    NTSTATUS
    OSNotifyCreateDevice(
        IN  PNSOBJ      AcpiObject,
        IN  ULONGLONG   OptionalFlags
        );

    NTSTATUS
    OSNotifyCreateOperationRegion(
        IN  PNSOBJ      AcpiObject
        );

    NTSTATUS
    OSNotifyCreatePowerResource(
        IN  PNSOBJ      AcpiObject
        );

    NTSTATUS
    OSNotifyCreateProcessor(
        IN  PNSOBJ      AcpiObject,
        IN  ULONGLONG   OptionalFlags
        );

    NTSTATUS
    OSNotifyCreateThermalZone(
        IN  PNSOBJ      AcpiObject,
        IN  ULONGLONG   OptionalFlags
        );

    VOID
    EXPORT
    OSNotifyDeviceWakeCallBack(
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    ObjectData,
        IN  PVOID       Context
        );

    NTSTATUS
    EXPORT
    OSNotifyFatalError(
        IN  ULONG       Param1,
        IN  ULONG       Param2,
        IN  ULONG       Param3,
        IN  ULONG_PTR   AmlContext,
        IN  ULONG_PTR   Context
        );

    VOID
    OSNotifyFatalErrorWorker(
        IN  PVOID       Context
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\osnotify.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    osnotify.c

Abstract:

    This module implements all the callbacks that are NT specific from
    the AML Interpreter

Environment

    Kernel mode only

Revision History:

    01-Mar-98 Initial Revision [split from callback.c]

--*/

#include "pch.h"

//
// Make sure that we have permanent storage for our fatal error context
//
ACPI_FATAL_ERROR_CONTEXT    AcpiFatalContext;

//
// Spinlock to protect the entire thing
KSPIN_LOCK                  AcpiFatalLock;

//
// Is there an outstanding Fatal Error Context?
//
BOOLEAN                     AcpiFatalOutstanding;


NTSTATUS
EXPORT
OSNotifyCreate(
    IN  ULONG   ObjType,
    IN  PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    This routine is called whenever a new object is created by the interpreter
    This routine dispatches based on what object type it is.

Arguments:

    ObjType     - What type of object it is
    AcpiObject  - Pointer to the new ACPI Object

Return Value:

    NTSTATUS

--*/
{
    KIRQL       oldIrql;
    NTSTATUS    status = STATUS_SUCCESS;
    ASSERT( AcpiObject != NULL );

    //
    // We will touch the device tree. So we need to hold the correct lock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    switch(ObjType) {
        case OBJTYPE_DEVICE:

            status = OSNotifyCreateDevice( AcpiObject, 0 );
            break;

        case OBJTYPE_OPREGION:

            status = OSNotifyCreateOperationRegion( AcpiObject );
            break;

        case OBJTYPE_POWERRES:

            status = OSNotifyCreatePowerResource( AcpiObject );
            break;

        case OBJTYPE_PROCESSOR:

            status = OSNotifyCreateProcessor( AcpiObject, 0 );
            break;
        case OBJTYPE_THERMALZONE:

            status = OSNotifyCreateThermalZone( AcpiObject, 0 );
            break;

        default:
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "OSNotifyCreate: received unhandled type %x\n",
                ObjType
                ) );
            status = STATUS_SUCCESS;
    }

    //
    // Done with this lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // What happened?
    //
    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "OSNotifyCreate: %p (%s) = %08lx\n",
        AcpiObject,
        ACPIAmliNameObject( AcpiObject ),
        status
        ) );

    //
    // Done --- Always succeed
    //
    return STATUS_SUCCESS;
}

NTSTATUS
OSNotifyCreateDevice(
    IN  PNSOBJ      AcpiObject,
    IN  ULONGLONG   OptionalFlags
    )
/*++

Routine Description:

    This routine is called whenever a new device appears. This routine is
    callable at DispatchLevel.

Arguments:

    AcpiObject      - Pointer to new ACPI Object
    OptionalFlags   - Properties of the Device Extension that should be
                      set when its created.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = NULL;
    PDEVICE_EXTENSION   parentExtension;
    PNSOBJ              parentObject;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( AcpiObject != NULL);

    //
    // First, we need a pointer to the parent node
    //
    parentObject = AcpiObject->pnsParent;
    ASSERT( parentObject != NULL );

    //
    // Grab the device extension associated with the parent. We need
    // this information to help link the parent properly into the tree
    //
    parentExtension = (PDEVICE_EXTENSION) parentObject->Context;
    if (parentExtension == NULL) {

        //
        // In this case, we can assume that the parent extension is the root
        // device extension.
        //
        parentExtension = RootDeviceExtension;

    }
    ASSERT( parentExtension != NULL );

    //
    // Now build an extension for the node
    //
    status = ACPIBuildDeviceExtension(
        AcpiObject,
        parentExtension,
        &deviceExtension
        );
    if (deviceExtension == NULL) {

        status = STATUS_UNSUCCESSFUL;

    }
    if (NT_SUCCESS(status)) {

        //
        // Incremement the reference count on the node. We do this because
        // we are going to be doing work (which will take a long time
        // to complete, anyways), and we don't want to hold the lock for that
        // entire time. If we incr the reference count, then we guarantee that
        // no one can come along and kick the feet out from underneath us
        //
        InterlockedIncrement( &(deviceExtension->ReferenceCount) );

    }

    //
    // What happend to the creation of the extension?
    //
    if (!NT_SUCCESS(status)) {

        //
        // We should have succeeded at whatever we are doing --- so this is
        // a bad place to be
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreateDevice: NSObj %p Failed %08lx\n",
            AcpiObject,
            status
            ) );
        goto OSNotifyCreateDeviceExit;

    }

    //
    // Set the optional flags if there are any
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        OptionalFlags,
        FALSE
        );

    //
    // Make sure to queue the request
    //
    status = ACPIBuildDeviceRequest(
        deviceExtension,
        NULL,
        NULL,
        FALSE
        );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreateDevice: ACPIBuildDeviceRequest(%p) = %08lx\n",
            deviceExtension,
            status
            ) );
        goto OSNotifyCreateDeviceExit;

    }

OSNotifyCreateDeviceExit:

    //
    // There is some work that will be done later
    //
    return status;
}

NTSTATUS
OSNotifyCreateOperationRegion(
    IN  PNSOBJ      AcpiObject
    )
/*++

Routine Description:

    This routine is called whenever a new operation region is created.
    This routine is callable at DispatchLevel.

Arguments:

    AcpiObject      - Pointer to the new ACPI Operation Region Object

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   parentExtension;
    PNSOBJ              parentObject;
    POPREGIONOBJ        opRegion;

    //
    // Sanity Check
    //
    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( AcpiObject != NULL );
    ASSERT( NSGETOBJTYPE(AcpiObject) == OBJTYPE_OPREGION );
    ASSERT( AcpiObject->ObjData.pbDataBuff != NULL );

    //
    // Get the OpRegion Object from the namespace object
    //
    opRegion = (POPREGIONOBJ) AcpiObject->ObjData.pbDataBuff;
    if (opRegion->bRegionSpace != REGSPACE_PCIBARTARGET) {

        //
        // This isn't a PCI Bar Target Operation Region, so there
        // is nothing to do
        //
        return STATUS_SUCCESS;

    }

    //
    // There are two cases to consider. The first case is the
    // one where the Operation Region is "static" in nature and
    // thus exists under some sort of device. The second case is
    // the one where the Operation Region is "dynamic" in nature
    // and thus exists under some sort of method. So, we want to
    // look at parent objects until we hit one that isn't a method
    // or is a device...
    //
    parentObject = AcpiObject->pnsParent;
    while (parentObject != NULL) {

        //
        // If the parent object is a method, then look at its parent
        //
        if (NSGETOBJTYPE(parentObject) == OBJTYPE_METHOD) {

            parentObject = parentObject->pnsParent;
            continue;

        }

        //
        // If the parent object isn't a device, then stop...
        //
        if (NSGETOBJTYPE(parentObject) != OBJTYPE_DEVICE) {

            break;

        }

        //
        // Grab the device extension (bad things happen if it doesn't
        // already exist
        //
        parentExtension = (PDEVICE_EXTENSION) parentObject->Context;
        if (parentExtension) {

            ACPIInternalUpdateFlags(
                &(parentExtension->Flags),
                DEV_CAP_PCI_BAR_TARGET,
                FALSE
                );

        }
        break;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
OSNotifyCreatePowerResource(
    IN  PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    This routine is called whenever a new power resource appears. This routine
    is callable at DispatchLevel.

Arguments:

    AcpiObject      - Pointer to new ACPI Object

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PACPI_POWER_DEVICE_NODE powerNode;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( AcpiObject != NULL);

    //
    // Build the power extension
    //
    status = ACPIBuildPowerResourceExtension( AcpiObject, &powerNode );

    //
    // What happened?
    //
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreatePowerResource: %p = %08lx\n",
            AcpiObject,
            status
            ) );
        goto OSNotifyCreatePowerResourceExit;

    }

    //
    // Make sure to request that this node gets processed
    //
    status = ACPIBuildPowerResourceRequest(
        powerNode,
        NULL,
        NULL,
        FALSE
        );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreatePowerResource:  "
            "ACPIBuildPowerResourceRequest(%p) = %08lx\n",
            powerNode,
            status
            ) );
        goto OSNotifyCreatePowerResourceExit;

    }

OSNotifyCreatePowerResourceExit:

    //
    // Done
    //
    return status;
}

NTSTATUS
OSNotifyCreateProcessor(
    IN  PNSOBJ      AcpiObject,
    IN  ULONGLONG   OptionalFlags
    )
/*++

Routine Description:

    This routine is called whenever a new processor appears. This routine
    is callable at DispatchLevel.

Arguments:

    AcpiObject      - Pointer to the new ACPI object
    OptionalFlags   - Properties of the Device Extension that should be
                      set when its created.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = NULL;
    PDEVICE_EXTENSION   parentExtension;
    PNSOBJ              parentObject;
    UCHAR               index = 0;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( AcpiObject != NULL);

    //
    // Note: ProcessorList is now implicitly protected by the device tree
    // lock since we need to acquire that lock before calling this function
    //
    //
    while (ProcessorList[index] && index < ACPI_SUPPORTED_PROCESSORS) {

        index++;

    }

    //
    // We must make sure that the current entry is empty...
    //
    if (index >= ACPI_SUPPORTED_PROCESSORS || ProcessorList[index] != NULL) {

        return STATUS_UNSUCCESSFUL;

    }


    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "OSNotifyCreateProcessor: Processor Object #%x: %x\n",
        index+1,
        AcpiObject
        ) );

    //
    // Remember that to store where the new processor object is located
    //
    ProcessorList[index] = AcpiObject;

    //
    // First, we need a pointer to the parent node
    //
    parentObject = AcpiObject->pnsParent;
    ASSERT( parentObject != NULL );

    //
    // Grab the device extension associated with the parent. We need
    // this information to help link the parent properly into the tree
    //
    parentExtension = (PDEVICE_EXTENSION) parentObject->Context;
    if (parentExtension == NULL) {

        //
        // In this case, we can assume that the parent extension is the root
        // device extension.
        //
        parentExtension = RootDeviceExtension;

    }
    ASSERT( parentExtension != NULL );
    //
    // Now build an extension for the node
    //
    status = ACPIBuildProcessorExtension(
        AcpiObject,
        parentExtension,
        &deviceExtension,
        index
        );

    if (NT_SUCCESS(status)) {

        //
        // Incremement the reference count on the node. We do this because
        // we are going to be doing work (which will take a long time
        // to complete, anyways), and we don't want to hold the lock for that
        // entire time. If we incr the reference count, then we guarantee that
        // no one can come along and kick the feet out from underneath us
        //
        InterlockedIncrement( &(deviceExtension->ReferenceCount) );

    }

    //
    // What happend to the creation of the extension?
    //
    if (!NT_SUCCESS(status)) {

        //
        // We should have succeeded at whatever we are doing --- so this is
        // a bad place to be
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreateProcessor: NSObj %p Failed %08lx\n",
            AcpiObject,
            status
            ) );
        goto OSNotifyCreateProcessorExit;

    }

    //
    // Set the optional flags if there are any
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        OptionalFlags,
        FALSE
        );

    //
    // Make sure to queue the request
    //
    status = ACPIBuildProcessorRequest(
        deviceExtension,
        NULL,
        NULL,
        FALSE
        );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreateProcessor: "
            "ACPIBuildProcessorRequest(%p) = %08lx\n",
            deviceExtension,
            status
            ) );
        goto OSNotifyCreateProcessorExit;

    }

OSNotifyCreateProcessorExit:

    //
    // There is some work that will be done later
    //
    return status;
}

NTSTATUS
OSNotifyCreateThermalZone(
    IN  PNSOBJ      AcpiObject,
    IN  ULONGLONG   OptionalFlags
    )
/*++

Routine Description:

    This routine is called whenever a new thermal zone appears. This routine is
    callable at DispatchLevel.

Arguments:

    AcpiObject      - Pointer to new ACPI Object
    OptionalFlags   - Properties of the Device Extension that should be
                      set when its created.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = NULL;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( AcpiObject != NULL);

    //
    // Now build an extension for the node
    //
    status = ACPIBuildThermalZoneExtension(
        AcpiObject,
        RootDeviceExtension,
        &deviceExtension
        );

    if (NT_SUCCESS(status)) {

        //
        // Incremement the reference count on the node. We do this because
        // we are going to be doing work (which will take a long time
        // to complete, anyways), and we don't want to hold the lock for that
        // entire time. If we incr the reference count, then we guarantee that
        // no one can come along and kick the feet out from underneath us
        //
        InterlockedIncrement( &(deviceExtension->ReferenceCount) );

    }

    //
    // What happend to the creation of the extension?
    //
    if (!NT_SUCCESS(status)) {

        //
        // We should have succeeded at whatever we are doing --- so this is
        // a bad place to be
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreateThermalZone: NSObj %p Failed %08lx\n",
            AcpiObject,
            status
            ) );
        goto OSNotifyCreateThermalZoneExit;

    }

    //
    // Set the optional flags if there are any
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        OptionalFlags,
        FALSE
        );

    //
    // Make sure to queue the request
    //
    status = ACPIBuildThermalZoneRequest(
        deviceExtension,
        NULL,
        NULL,
        FALSE
        );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreateThermalZone: "
            "ACPIBuildThermalZoneRequest(%p) = %08lx\n",
            deviceExtension,
            status
            ) );
        goto OSNotifyCreateThermalZoneExit;

    }

OSNotifyCreateThermalZoneExit:

    //
    // There is some work that will be done later
    //
    return status;
}

NTSTATUS
EXPORT
OSNotifyDeviceCheck(
    IN  PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    This routine is called when the AML Interpreter signals that the
    System should check the presence of a device. If the device remains
    present, nothing is done. If the device appears or disappears the
    appropriate action is taken.

    For legacy reasons, if the device is a dock we initiate an undock request.
    Newer ACPI BIOS's should use Notify(,3).

Arguments:

    AcpiObject  - The device we should check for new/missing children.

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension;

    ASSERT( AcpiObject != NULL );

    //
    // Let the world know
    //
    ACPIPrint( (
        ACPI_PRINT_PNP,
        "OSNotifyDeviceCheck: 0x%p (%s)\n",
        AcpiObject,
        ACPIAmliNameObject( AcpiObject )
        ) );

    deviceExtension = (PDEVICE_EXTENSION) AcpiObject->Context;
    if (deviceExtension == NULL) {

        return STATUS_SUCCESS;

    }

    //
    // Notify(,1) on a dock node is an eject request request. Handle specially.
    //
    if (ACPIDockIsDockDevice(AcpiObject)) {

        //
        // We only let BIOS's get away with this because we rev'd the spec
        // after Win98. Both OS's will agree with the release of NT5 and
        // Win98 SP1
        //
        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "OSNotifyDeviceCheck: BIOS issued Notify(dock,1), should use "
            " Notify(dock,3) to request ejection of a dock.\n",
            AcpiObject,
            ACPIAmliNameObject( AcpiObject )
            ) );

        return OSNotifyDeviceEject(AcpiObject) ;
    }

    //
    // Search for the parent of the first device that the OS is aware, and
    // issue a device check notify
    //
    // N.B.
    //     There is currently no way in WDM to do a "light" device check. Once
    // this is amended, the following code should be updated to do something
    // more efficient.
    //
    deviceExtension = deviceExtension->ParentExtension;
    while (deviceExtension) {

        if (!(deviceExtension->Flags & DEV_TYPE_NOT_FOUND)) {

            //
            // Invalid the device relations for this device tree
            //
            IoInvalidateDeviceRelations(
                deviceExtension->PhysicalDeviceObject,
                BusRelations
                );
            break;

        }

        //
        // Try the parent device
        //
        deviceExtension = deviceExtension->ParentExtension;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
EXPORT
OSNotifyDeviceEnum(
    IN  PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    This routine is called when the AML Interpreter signals that the
    System should re-enumerate the device

Arguments:

    AcpiObject  - The device we should check for new/missing children.

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_EXTENSION   dockExtension;

    ASSERT( AcpiObject != NULL );

    //
    // Let the world know
    //
    ACPIPrint( (
        ACPI_PRINT_PNP,
        "OSNotifyDeviceEnum: 0x%p (%s)\n",
        AcpiObject,
        ACPIAmliNameObject( AcpiObject )
        ) );

    deviceExtension = (PDEVICE_EXTENSION) AcpiObject->Context;
    if (deviceExtension == NULL) {

        return STATUS_SUCCESS;

    }

    //
    // Notify(,0) on a dock node is a dock request. Handle specially.
    //
    if (ACPIDockIsDockDevice(AcpiObject)) {

        dockExtension = ACPIDockFindCorrespondingDock( deviceExtension );

        if (!dockExtension) {

            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                "OSNotifyDeviceEnum: Dock device 0x%p (%s) "
                "does not have a profile provider!\n",
                AcpiObject,
                ACPIAmliNameObject( AcpiObject )
                ) );

            return STATUS_SUCCESS;

        }

        //
        // If this node is marked "Unknown", move it to "Isolated" as
        // Notify(Dock,0) was ran. If we never saw Notify(Dock,0) but the
        // dock's _STA said "here", we would assume _DCK(0) was ran by the BIOS
        // itself.
        //
        InterlockedCompareExchange(
            (PULONG) &dockExtension->Dock.IsolationState,
            IS_ISOLATED,
            IS_UNKNOWN
            );

        if (dockExtension->Dock.IsolationState == IS_ISOLATED) {

            if (dockExtension->Flags&DEV_TYPE_NOT_FOUND) {

                //
                // We haven't made a PDO for the docking station yet. This may
                // be a request to bring it online. Mark the profile provider
                // so that we notice the new dock appearing
                //
                ACPIInternalUpdateFlags(
                    &dockExtension->Flags,
                    DEV_CAP_UNATTACHED_DOCK,
                    FALSE
                    );

            }

            //
            // Invalidate the beginning of the tree. This will cause our fake
            // dock node to start.
            //
            IoInvalidateDeviceRelations(
                RootDeviceExtension->PhysicalDeviceObject,
                SingleBusRelations
                );

        }

        return STATUS_SUCCESS;

    }

    //
    // Search for the parent of the first device that the OS is aware, and
    // issue a device check notify
    //
    while (deviceExtension) {

        if (!(deviceExtension->Flags & DEV_TYPE_NOT_FOUND)) {

            //
            // Invalid the device relations for this device tree
            //
            IoInvalidateDeviceRelations(
                deviceExtension->PhysicalDeviceObject,
                BusRelations
                );
            break;

        }

        //
        // Try the parent device
        //
        deviceExtension = deviceExtension->ParentExtension;
    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
EXPORT
OSNotifyDeviceEject(
    IN  PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    This routine is called when the device's eject button is pressed


Arguments:

    AcpiObject  - The device to be ejected

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension;

    ASSERT( AcpiObject != NULL );

    //
    // Let the world know
    //
    ACPIPrint( (
        ACPI_PRINT_REMOVE,
        "OSNotifyDeviceEject: 0x%p (%s)\n",
        AcpiObject,
        ACPIAmliNameObject( AcpiObject )
        ) );


    //
    // Inform the OS of which device wants to go away.  If the OS doesn't
    // know about the device, then don't bother
    //
    deviceExtension = (PDEVICE_EXTENSION) AcpiObject->Context;

    //
    // If this is a dock, queue the eject against the profile provider.
    //
    if (ACPIDockIsDockDevice(AcpiObject)) {

        deviceExtension = ACPIDockFindCorrespondingDock( deviceExtension );

        if (!deviceExtension) {

            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                 "OSNotifyDeviceEject: Dock device 0x%p (%s) "
                 "does not have a profile provider!\n",
                 AcpiObject,
                 ACPIAmliNameObject( AcpiObject )
                 ) );

            return STATUS_SUCCESS;
        }
    }

    if (deviceExtension  &&  !(deviceExtension->Flags & DEV_TYPE_NOT_FOUND)) {

        IoRequestDeviceEject (deviceExtension->PhysicalDeviceObject);
    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
EXPORT
OSNotifyDeviceWake(
    IN  PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    This is called when a device has woken the computer

Arguments:

    AcpiObject  - The device which woke the computer

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PLIST_ENTRY         powerList;

    ASSERT( AcpiObject != NULL );

    //
    // Grab the device extension associated with this NS object
    //
    deviceExtension = (PDEVICE_EXTENSION) AcpiObject->Context;
    ASSERT( deviceExtension != NULL );

    //
    // Let the world know
    //
    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        deviceExtension,
        "OSNotifyDeviceWake - 0x%p (%s)\n",
        AcpiObject,
        ACPIAmliNameObject( AcpiObject )
        ) );

    //
    // Initialize the list that will hold the requests
    //
    powerList = ExAllocatePoolWithTag(
       NonPagedPool,
       sizeof(LIST_ENTRY),
       ACPI_MISC_POOLTAG
       );
    if (powerList == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "OSNotifyDeviceWake - Cannot Allocate LIST_ENTRY\n"
            ) );
        return STATUS_SUCCESS;

    }
    InitializeListHead( powerList );

    //
    // Remove the affected requests from the wait list
    //
    IoAcquireCancelSpinLock( &oldIrql );
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );
    ACPIWakeRemoveDevicesAndUpdate( deviceExtension, powerList );
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
    IoReleaseCancelSpinLock( oldIrql );

    //
    // If the list is non-empty, then disable those requests
    //
    if (!IsListEmpty( powerList ) ) {

        status = ACPIWakeDisableAsync(
            deviceExtension,
            powerList,
            OSNotifyDeviceWakeCallBack,
            powerList
            );
        if (status != STATUS_PENDING) {

            OSNotifyDeviceWakeCallBack(
                NULL,
                status,
                NULL,
                powerList
                );

        }

        ACPIDevPrint( (
             ACPI_PRINT_WAKE,
             deviceExtension,
             "OSNotifyDeviceWake - ACPIWakeDisableAsync = %08lx\n",
             status
             ) );

    } else {

        //
        // We must free this memory ourselves
        //
        ExFreePool( powerList );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

VOID
EXPORT
OSNotifyDeviceWakeCallBack(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called when we have completed _PSW(off) on a device

Arguments:

    AcpiObject  - Points to the control method that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - P{DEVICE_EXTENSION

Return Value:

    NTSTATUS

--*/
{
#if DBG
    PACPI_POWER_REQUEST powerRequest;
    PDEVICE_EXTENSION   deviceExtension;
#endif
    PLIST_ENTRY         powerList = (PLIST_ENTRY) Context;

    //
    // Do we have some work to do?
    //
    if (IsListEmpty( powerList ) ) {

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "OSNotifyDeviceWakeCallBack: %p is an empty list\n",
            powerList
            ) );
        ExFreePool( powerList );
        return;

    }

#if DBG
    //
    // Get the first record, so that we have a clue as to the device
    // that was completed
    //
    powerRequest = CONTAINING_RECORD(
        powerList->Flink,
        ACPI_POWER_REQUEST,
        ListEntry
        );
    ASSERT( powerRequest->Signature == ACPI_SIGNATURE );

    //
    // Grab the device extension
    //
    deviceExtension = powerRequest->DeviceExtension;

    //
    // Tell the world
    //
    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        deviceExtension,
        "OSNotifyDeviceWakeCallBack = 0x%08lx\n",
        Status
        ) );
#endif

    //
    // Complete the requests
    //
    ACPIWakeCompleteRequestQueue(
        powerList,
        Status
        );

    //
    // Free the list pointer
    //
    ExFreePool( powerList );

}

VOID
EXPORT
OSNotifyDeviceWakeByGPEEvent(
    IN  ULONG   GpeIndex,
    IN  ULONG   GpeRegister,
    IN  ULONG   GpeMask
    )
/*++

Routine Description:

    This is called when a device has woken the computer

Arguments:

    GpeIndex    - The index bit of the GPE that woke the computer
    GpeRegister - The register index
    GpeMask     - The enabled bits for that register

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    NTSTATUS            status;
    PACPI_POWER_REQUEST powerRequest;
    PDEVICE_EXTENSION   deviceExtension;
    PLIST_ENTRY         listEntry;
    PLIST_ENTRY         powerList;

    //
    // Let the world know
    //
    ACPIPrint( (
        ACPI_PRINT_WAKE,
        "OSNotifyDeviceWakeByGPEEvent: %02lx[%x] & %02lx\n",
        GpeRegister, GpeIndex, GpeMask
        ) );

    //
    // Initialize the list that will hold the requests
    //
    powerList = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(LIST_ENTRY),
        ACPI_MISC_POOLTAG
        );
    if (powerList == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyDeviceWakeByGPEEvent: Cannot Allocate LIST_ENTRY\n"
            ) );
        return;

    }
    InitializeListHead( powerList );

    //
    // We need to be holding these locks
    //
    IoAcquireCancelSpinLock( &oldIrql );
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Look for a matching power request for this GPE
    //
    for (listEntry = AcpiPowerWaitWakeList.Flink;
         listEntry != &AcpiPowerWaitWakeList;
         listEntry = listEntry->Flink) {

        //
        // Grab the request
        //
        powerRequest = CONTAINING_RECORD(
            listEntry,
            ACPI_POWER_REQUEST,
            ListEntry
            );
        ASSERT( powerRequest->Signature == ACPI_SIGNATURE );
        deviceExtension = powerRequest->DeviceExtension;

        //
        // See if this request matches
        //
        if (deviceExtension->PowerInfo.WakeBit == GpeIndex) {

            //
            // Get all of the wait requests for this device
            //
            ACPIWakeRemoveDevicesAndUpdate( deviceExtension, powerList );
            break;

        }

    }

    //
    // This is an exclusive wake gpe bit --- verify there are not multiple
    // devices waiting for it, as that would be a design which could cause a
    // deadlock
    //
    if (!IsListEmpty( powerList ) ) {

        ASSERT( !(GpeWakeEnable[GpeRegister] & GpeMask) );

    }

    //
    // No longer need these locks
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
    IoReleaseCancelSpinLock( oldIrql );

    //
    // If the list is non-empty, then disable those requests
    //
    if (!IsListEmpty( powerList ) ) {

        status = ACPIWakeDisableAsync(
            deviceExtension,
            powerList,
            OSNotifyDeviceWakeCallBack,
            powerList
            );
        if (status != STATUS_PENDING) {

            OSNotifyDeviceWakeCallBack(
                NULL,
                status,
                NULL,
                powerList
                );

        }

        ACPIDevPrint( (
             ACPI_PRINT_WAKE,
             deviceExtension,
             "OSNotifyDeviceWakeByGPEIndex - ACPIWakeDisableAsync = %08lx\n",
             status
             ) );

    } else {

        //
        // We must free this memory ourselves
        //
        ExFreePool( powerList );

    }

    //
    // Done
    //
    return;
}

NTSTATUS
EXPORT
OSNotifyFatalError(
    IN  ULONG       Param1,
    IN  ULONG       Param2,
    IN  ULONG       Param3,
    IN  ULONG_PTR   AmlContext,
    IN  ULONG_PTR   Context
    )
/*++

Routine Description:

    This routine is called whenever the AML code detects a condition that the
    machine can no longer handle. It
--*/
{
    KIRQL   oldIrql;

    //
    // Acquire the spinlock and see if there is an outstanding fatal error
    // pending already
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );
    if (AcpiFatalOutstanding != FALSE) {

        //
        // There is one outstanding already... don't do anything
        //
        KeReleaseSpinLock( &AcpiPowerLock, oldIrql );
        return STATUS_SUCCESS;

    }

    //
    // Remember that there is an outstanding fatal context and release the lock
    AcpiFatalOutstanding = TRUE;
    KeReleaseSpinLock(&AcpiPowerLock, oldIrql);

    //
    // Initialize the work queue
    //
    ExInitializeWorkItem(
        &(AcpiFatalContext.Item),
        OSNotifyFatalErrorWorker,
        &AcpiFatalContext
        );
    AcpiFatalContext.Param1  = Param1;
    AcpiFatalContext.Param2  = Param2;
    AcpiFatalContext.Param3  = Param3;
    AcpiFatalContext.Context = AmlContext;


    //
    // Queue the work item and return
    //
    ExQueueWorkItem( &(AcpiFatalContext.Item), DelayedWorkQueue );
    return STATUS_SUCCESS;
}

VOID
OSNotifyFatalErrorWorker(
    IN  PVOID   Context
    )
/*++

Routine Description:

    This is the routine that actually shuts down the machine on a fatal
    error

Arguments:

    Context - Points to the fatal error context

Return Value:

    None

--*/
{
    PACPI_FATAL_ERROR_CONTEXT   fatal = (PACPI_FATAL_ERROR_CONTEXT) Context;
#if 0
    PWCHAR                      stringData[1];
    ULONG                       data[3];

    //
    // Generate the parameters for an error log message
    //
    stringData[0] = L"Acpi";
    data[0] = fatal->Param1;
    data[1] = fatal->Param2;
    data[2] = fatal->Param3;

    //
    // Write the error log message
    //
    ACPIErrLogWriteEventLogEntry(
        ACPI_ERR_BIOS_FATAL,
        0,
        1,
        &stringData,
        sizeof(ULONG) * 3,
        data
        );
#else
    //
    // Now, we can bugcheck
    //
    PoShutdownBugCheck(
        TRUE,
        ACPI_BIOS_FATAL_ERROR,
        fatal->Param1,
        fatal->Param2,
        fatal->Param3,
        fatal->Context
        );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\msi.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    msi.h

Abstract:

    This file defines structures and data types used by the 
    MSI (Message Signalled Interrupt) support
    functionality of the ACPI IRQ arbiter.

Author:

    Elliot Shmukler (t-ellios) 7-15-98

Environment:

    Kernel mode only.

Revision History:

--*/

#ifndef _ACPI_MSI_H_
#define _ACPI_MSI_H_

//
//  APIC Version Register 
//
struct _ApicVersion {
    UCHAR Version;              // either 0.x or 1.x
    UCHAR Reserved1:7;
    UCHAR MSICapable:1;         // is this APIC an MSI receiver?
    UCHAR MaxRedirEntries;      // Number of INTIs on unit
    UCHAR Reserved2;
};

typedef struct _ApicVersion APIC_VERSION, *PAPIC_VERSION;

//
// The Offset from the IO APIC base address of the APIC Assertion Register.
// It is this register that is the target of MSI writes.
//

#define APIC_ASSERTION_REGISTER_OFFSET 0x20

//
// Useful info maintained by the arbiter about an individual IO APIC
//

typedef struct _IOAPIC_MSI_INFO
{
   BOOLEAN MSICapable;           // Is this IO APIC an MSI receiver?
   ULONG VectorBase;             // The Global System Interrupt Vector base for this APIC
   ULONG MaxVectors;             // The number of vectors supported by this APIC
   ULONG BaseAddress;            // The IO APIC Unit base address

} IOAPIC_MSI_INFO, *PIOAPIC_MSI_INFO;

//
// MSI information structure 
// (basically the APIC information needed for MSI vector allocation 
//   & routing)
//

typedef struct _MSI_INFORMATION
{
   BOOLEAN PRTMappingsScanned;               // Have we determined the _PRT mapped vectors?
   PRTL_BITMAP PRTMappedVectors;             // A BitMap of the vectors mapped by the _PRT
   USHORT NumIOApics;                        // The number of IO APICs in this system
   IOAPIC_MSI_INFO ApicInfo[ANYSIZE_ARRAY];  // Information about each IO APIC in the system
} MSI_INFORMATION, *PMSI_INFORMATION;

//
// Global variable to hold MSI information
// (this is non-NULL only if this system supports MSI)
//

extern PMSI_INFORMATION MsiInformation;

//
// Prototype of a callback used by AcpiArbFindAndProcessEachPRT to initiate the processing
// of each PRT it finds
//


typedef
VOID
(*PACPI_ARB_PROCESS_PRT)(IN PSNOBJ);


// Prototypes from msi.c (used by arbiter)

VOID AcpiMSIInitializeInfo(VOID);
BOOLEAN AcpiMSIFindAvailableVector(OUT PULONG Vector);
BOOLEAN AcpiMSICreateRoutingToken(IN ULONG Vector, IN OUT PROUTING_TOKEN Token);

VOID AcpiArbFindAndProcessEachPRT(IN PDEVICE_OBJECT Root, 
                                  IN PACPI_ARB_PROCESS_PRT ProcessCallback
                                  );
VOID AcpiMSIExtractMappedVectorsFromPRT(IN PNSOBJ prtObj);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\pciopregion.h ===
#define PCISUPP_CHECKED_HID               1
#define PCISUPP_CHECKED_PCI_DEVICE        2
#define PCISUPP_CHECKED_ADR               8
#define PCISUPP_IS_PCI_DEVICE             0x10
#define PCISUPP_CHECKED_PARENT            0x20
#define PCISUPP_CHECKED_PCI_BRIDGE        0x40
#define PCISUPP_CHECKED_CID               0x80
#define PCISUPP_GOT_SLOT_INFO             0x100
#define PCISUPP_GOT_BUS_INFO              0x200
#define PCISUPP_CHECKED_CRS               0x400
#define PCISUPP_COMPLETING_IS_PCI         0x800
#define PCISUPP_GOT_SCOPE                 0x1000
#define PCISUPP_CHECKED_BBN               0x2000

#define PCISUPP_COMPLETION_HANDLER_PFNAA  0
#define PCISUPP_COMPLETION_HANDLER_PFNACB 1

#define INITIAL_RUN_COMPLETION  -1

NTSTATUS
EXPORT
PciConfigSpaceHandler (
    ULONG                   AccessType,
    PNSOBJ                  OpRegion,
    ULONG                   Address,
    ULONG                   Size,
    PULONG                  Data,
    ULONG                   Context,
    PFNAA                   CompletionHandler,
    PVOID                   CompletionContext
    );

NTSTATUS
EXPORT
PciConfigSpaceHandlerWorker(
    IN PNSOBJ    AcpiObject,
    IN NTSTATUS  Status,
    IN POBJDATA  Result,
    IN PVOID     Context
    );

VOID
ACPIInitBusInterfaces(
    PDEVICE_OBJECT  Filter
    );

VOID
ACPIDeleteFilterInterfaceReferences(
    IN  PDEVICE_EXTENSION   DeviceExtension
    );


BOOLEAN
IsPciBus(
    IN PDEVICE_OBJECT   DeviceObject
    );

BOOLEAN
IsPciBusExtension(
    IN  PDEVICE_EXTENSION   DeviceObject
    );

NTSTATUS
IsPciBusAsync(
    IN  PNSOBJ  AcpiObject,
    IN  PFNACB  CompletionHandler,
    IN  PVOID   CompletionContext,
    OUT BOOLEAN *Result
    );

NTSTATUS
EXPORT
IsPciBusAsyncWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

NTSTATUS
IsPciDevice(
    IN  PNSOBJ  AcpiObj,
    IN  PFNACB  CompletionHandler,
    IN  PVOID   CompletionContext,
    OUT BOOLEAN *Result
    );

NTSTATUS
EXPORT
IsPciDeviceWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

BOOLEAN
IsNsobjPciBus(
    IN PNSOBJ Device
    );

NTSTATUS
EnableDisableRegions(
    IN PNSOBJ NameSpaceObj,
    IN BOOLEAN Enable
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\processor.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    processor.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _PROCESSOR_H_
#define _PROCESSOR_H_

extern KSPIN_LOCK     AcpiProcessorLock;
extern LIST_ENTRY     AcpiProcessorList;
//extern PDEVICE_OBJECT FixedProcessorDeviceObject;

VOID
ACPIProcessorCancelRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

BOOLEAN
ACPIProcessorCompletePendingIrps(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  ULONG           ProcessorEvent
    );


NTSTATUS
ACPIProcessorDeviceControl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ACPIProcessorStartDevice (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    This is the precompiled header for the ACPI NT subtree

Author:

    Jason Clark (jasoncl)

Environment:

    Kernel mode only.

Revision History:

--*/

#define _NTDRIVER_
#define _NTSRV_
#define _NTDDK_

#include <stdarg.h>
#include <stdio.h>
#include <ntos.h>
#include <pci.h>
#include <dockintf.h>

#ifndef SPEC_VER
    #define SPEC_VER   100
#endif

#ifndef FAR
    #define FAR
#endif

#include <poclass.h>
#include <wdmguid.h>
#include <zwapi.h>
#include <ntpoapi.h>
#include <arbiter.h>

#include <wmistr.h>
#include <wmiguid.h>
#include <wmilib.h>

//
// This is the header for interfacing with the HAL
//
#include <ntacpi.h>


//
// These are the global include files for this project
//
#include "acpitabl.h"
#include "amli.h"
#include "aml.h"
#include "acpios.h"
#include "ospower.h"
#include "callback.h"
#include "acpi.h"
#include "acpidbg.h"
#include "acpiregs.h"
#include "devioctl.h"
#include "acpipriv.h"
#include "acpiioct.h"
#include "acpictl.h"
#include "acpienbl.h"
#include "acpigpio.h"
#include "acpiinit.h"
#include "acpiio.h"
#include "acpilock.h"
#include "acpintfy.h"
#include "acpioprg.h"
#include "acpiterm.h"

//
// These are the directory dependent files for this project
//
#include "acpiirp.h"
#include "acpilog.h"
#include "acpiosnt.h"
#include "amlisupp.h"
#include "acpidock.h"
#include "buildsrc.h"
#include "bus.h"
#include "button.h"
#include "cmbutton.h"
#include "dat.h"
#include "debug.h"
#include "detect.h"
#include "devpower.h"
#include "dispatch.h"
#include "errlog.h"
#include "extlist.h"
#include "filter.h"
#include "get.h"
#include "gpe.h"
#include "idevice.h"
#include "init.h"
#include "interfaces.h"
#include "internal.h"
#include "interupt.h"
#include "irqarb.h"
#include "msi.h"
#include "match.h"
#include "osnotify.h"
#include "pciopregion.h"
#include "processor.h"
#include "rangesup.h"
#include "res_bios.h"
#include "res_cm.h"
#include "root.h"
#include "rtl.h"
#include "syspower.h"
#include "table.h"
#include "thermal.h"
#include "vector.h"
#include "wake.h"
#include "wmilog.h"
#include "worker.h"


//
// Make sure to have the correct tag
//
#ifdef ExAllocatePool
    #undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'ipcA')
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\rangesup.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rangesup.c

Abstract:

    This handles the subtraction of a set of CmResList from an IoResList
    IoResList

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    Aug-05-97   - Initial Revision

--*/

#include "pch.h"


NTSTATUS
ACPIRangeAdd(
    IN  OUT PIO_RESOURCE_REQUIREMENTS_LIST  *GlobalList,
    IN      PIO_RESOURCE_REQUIREMENTS_LIST  AddList
    )
/*++

Routine Description:

    This routine is called to add an Io List to another. This is not a
    straightforward operation

Arguments:

    IoList  - The list that contains both lists
    AddList - The list what will be added to the other. We are desctructive
              to this list

Return Value:

    NTSTATUS:

--*/
{
    BOOLEAN                         proceed;
    NTSTATUS                        status;
    PIO_RESOURCE_DESCRIPTOR         addDesc;
    PIO_RESOURCE_DESCRIPTOR         newDesc;
    PIO_RESOURCE_LIST               addList;
    PIO_RESOURCE_LIST               globalList;
    PIO_RESOURCE_LIST               newList;
    PIO_RESOURCE_REQUIREMENTS_LIST  globalResList;
    PIO_RESOURCE_REQUIREMENTS_LIST  newResList;
    ULONG                           addCount    = 0;
    ULONG                           addIndex    = 0;
    ULONG                           ioCount     = 0;
    ULONG                           ioIndex     = 0;
    ULONG                           maxSize     = 0;
    ULONG                           size        = 0;

    if (GlobalList == NULL) {

        return STATUS_INVALID_PARAMETER_1;

    }
    globalResList = *GlobalList;

    //
    // Make sure that we have a list to add
    //
    if (AddList == NULL || AddList->AlternativeLists == 0) {

        return STATUS_SUCCESS;

    }

    //
    // Figure out how much space we need in the
    //
    addList = &(AddList->List[0]);
    maxSize = addCount = addList->Count;
    ACPIRangeSortIoList( addList );

    //
    // Worst case is that the new list is as big as both lists combined
    //
    size = AddList->ListSize;

    //
    // Do we have a global list to add to?
    //
    if (globalResList == NULL || globalResList->AlternativeLists == 0) {

        //
        // No? Then just copy the old list
        //
        newResList = ExAllocatePoolWithTag(
            NonPagedPool,
            size,
            ACPI_RESOURCE_POOLTAG
            );
        if (newResList == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlCopyMemory(
            newResList,
            AddList,
            size
            );

    } else {

        //
        // Yes, so calculate how much space the first one will take
        //
        globalList = &(globalResList->List[0]);
        ioCount = globalList->Count;
        maxSize += ioCount;
        size += (ioCount * sizeof(IO_RESOURCE_DESCRIPTOR) );

        //
        // Allocate the list
        //
        newResList = ExAllocatePoolWithTag(
            NonPagedPool,
            size,
            ACPI_RESOURCE_POOLTAG
            );
        if (newResList == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Copy both lists into the new one
        //
        RtlZeroMemory( newResList, size );
        RtlCopyMemory(
            newResList,
            AddList,
            AddList->ListSize
            );
        RtlCopyMemory(
            &(newResList->List[0].Descriptors[addCount]),
            globalList->Descriptors,
            (ioCount * sizeof(IO_RESOURCE_DESCRIPTOR) )
            );

        //
        // We no longer need this list
        //
        ExFreePool( *GlobalList );

    }

    //
    // Make sure that we update the list count
    //
    newResList->ListSize = size;
    newList = &(newResList->List[0]);
    newList->Count = ioCount = addCount = maxSize;

    //
    // Sort the new list
    //
    status = ACPIRangeSortIoList( newList );
    if (!NT_SUCCESS(status)) {

        //
        // We failed, so exit now
        //
        ExFreePool( newResList );
        return status;

    }

    //
    // Add all the resource we can together
    //
    for (ioIndex = 0; ioIndex < maxSize; ioIndex++) {

        //
        // First step is to copy the current desc from the master list to
        // the new list
        //
        newDesc = &(newList->Descriptors[ioIndex]);

        //
        // Is it interesting?
        //
        if (newDesc->Type == CmResourceTypeNull) {

            //
            // No
            //
            continue;

        }

        //
        // Do we care about it?
        //
        if (newDesc->Type != CmResourceTypeMemory &&
            newDesc->Type != CmResourceTypePort &&
            newDesc->Type != CmResourceTypeDma &&
            newDesc->Type != CmResourceTypeInterrupt) {

            //
            // We do not care
            //
            newDesc->Type = CmResourceTypeNull;
            ioCount--;
            continue;

        }

        //
        // Try to get as far as possible
        //
        proceed = TRUE;

        //
        // Now we try to find any lists that we can merge in that location
        //
        for (addIndex = ioIndex + 1; addIndex < maxSize; addIndex++) {

            addDesc = &(newList->Descriptors[addIndex]);

            //
            // If they are not the same type, then next
            //
            if (newDesc->Type != addDesc->Type) {

                continue;

            }

            //
            // What we do next is dependent on the type
            //
            switch (newDesc->Type) {
            case CmResourceTypePort:
            case CmResourceTypeMemory:

                //
                // Does the new descriptor lie entirely before the add
                // descriptor?
                //
                if (addDesc->u.Port.MinimumAddress.QuadPart >
                    newDesc->u.Port.MaximumAddress.QuadPart + 1) {

                    //
                    // Then we are done with this newDesc
                    //
                    proceed = FALSE;
                    break;

                }

                //
                // does part of the current new descriptor lie in part
                // of the add one?
                //
                if (newDesc->u.Port.MaximumAddress.QuadPart <=
                    addDesc->u.Port.MaximumAddress.QuadPart) {

                    //
                    // Update the current new descriptor to refect the
                    // correct range and length
                    //
                    newDesc->u.Port.MaximumAddress.QuadPart =
                        addDesc->u.Port.MaximumAddress.QuadPart;
                    newDesc->u.Port.Length = (ULONG)
                        (newDesc->u.Port.MaximumAddress.QuadPart -
                        newDesc->u.Port.MinimumAddress.QuadPart + 1);
                    newDesc->u.Port.Alignment = 1;

                }

                //
                // Nuke the add descriptor since it has been swallowed up
                //
                ioCount--;
                addDesc->Type = CmResourceTypeNull;
                break;

            case CmResourceTypeDma:
            case CmResourceTypeInterrupt:

                //
                // Does the current new descriptor lie entirely before the
                // one we are looking at now?
                //
                if (addDesc->u.Dma.MinimumChannel >
                    newDesc->u.Dma.MaximumChannel + 1) {

                    proceed = FALSE;
                    break;

                }

                //
                // does part of the current new descriptor lie in part
                // of the add one?
                //
                if (newDesc->u.Dma.MaximumChannel <=
                    addDesc->u.Dma.MaximumChannel ) {

                    //
                    // Update the current new descriptor to reflect the
                    // correct range
                    //
                    newDesc->u.Dma.MaximumChannel =
                        addDesc->u.Dma.MaximumChannel;

                }

                //
                // Nuke the add descriptor since it has been swallowed up
                //
                ioCount--;
                addDesc->Type = CmResourceTypeNull;

                break;
            } // switch

            //
            // Do we need to stop?
            //
            if (proceed == FALSE) {

                break;

            }

        }

    } // for

    //
    // Do we have any items left that we care about?
    //
    if (ioCount == 0) {

        //
        // No then free everything and return an empty list
        //
        ExFreePool( newResList );
        return STATUS_SUCCESS;

    }

    //
    // Now we can build the proper list. See how many items we must allocate
    //
    size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) + (ioCount - 1) *
        sizeof(IO_RESOURCE_DESCRIPTOR);
    globalResList = ExAllocatePoolWithTag(
        NonPagedPool,
        size,
        ACPI_RESOURCE_POOLTAG
        );
    if (globalResList == NULL) {

        ExFreePool( newResList );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Initialize the new list by copying the header from the working list
    //
    RtlZeroMemory( globalResList, size );
    RtlCopyMemory(
        globalResList,
        newResList,
        sizeof(IO_RESOURCE_REQUIREMENTS_LIST)
        );
    globalResList->ListSize = size;
    globalList = &(globalResList->List[0]);
    globalList->Count = ioCount;

    //
    // Copy all of the valid items into this new list
    //
    for (addIndex = 0, ioIndex = 0;
         ioIndex < ioCount && addIndex < maxSize;
         addIndex++) {

        addDesc = &(newList->Descriptors[addIndex]);

        //
        // If the type is null, skip it
        //
        if (addDesc->Type == CmResourceTypeNull) {

            continue;

        }

        //
        // Copy the new list
        //
        RtlCopyMemory(
            &(globalList->Descriptors[ioIndex]),
            addDesc,
            sizeof(IO_RESOURCE_DESCRIPTOR)
            );
        ioIndex++;

    }

    //
    // Free the old list
    //
    ExFreePool( newResList );

    //
    // Point the global to the new list
    //
    *GlobalList = globalResList;

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIRangeAddCmList(
    IN  OUT PCM_RESOURCE_LIST   *GlobalList,
    IN      PCM_RESOURCE_LIST   AddList
    )
/*++

Routine Description:

    This routine is called to add an Cm List to another. This is not a
    straightforward operation

Arguments:

    CmList  - The list that contains both lists
    AddList - The list what will be added to the other. We are desctructive
              to this list

Return Value:

    NTSTATUS:

--*/
{

    BOOLEAN                         proceed;
    NTSTATUS                        status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR addDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR newDesc;
    PCM_PARTIAL_RESOURCE_LIST       addPartialList;
    PCM_PARTIAL_RESOURCE_LIST       cmPartialList;
    PCM_PARTIAL_RESOURCE_LIST       newPartialList;
    PCM_RESOURCE_LIST               globalList;
    PCM_RESOURCE_LIST               newList;
    ULONG                           addCount    = 0;
    ULONG                           addIndex    = 0;
    ULONG                           cmCount     = 0;
    ULONG                           cmIndex     = 0;
    ULONG                           maxSize     = 0;
    ULONG                           size        = 0;
    ULONGLONG                       maxAddr1;
    ULONGLONG                       maxAddr2;

    if (GlobalList == NULL) {

        return STATUS_INVALID_PARAMETER_1;

    }
    globalList = *GlobalList;

    //
    // Make sure that we have a list to add
    //
    if (AddList == NULL || AddList->Count == 0) {

        return STATUS_SUCCESS;

    }
    addPartialList = &(AddList->List[0].PartialResourceList);
    addCount = addPartialList->Count;

    //
    // If we have no global list, then we just copy over the other one
    //
    if (globalList == NULL || globalList->Count == 0) {

        //
        // Just copy over the original list
        //
        size = sizeof(CM_RESOURCE_LIST) + (addCount - 1) *
            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
        maxSize = addCount;
        newList = ExAllocatePoolWithTag(
            NonPagedPool,
            size,
            ACPI_RESOURCE_POOLTAG
            );
        if (newList == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlCopyMemory(
            newList,
            AddList,
            size
            );

    } else {

        cmPartialList = &( globalList->List[0].PartialResourceList);
        cmCount = cmPartialList->Count;
        maxSize = addCount + cmCount;

        //
        // Allocate space for both lists
        //
        size = sizeof(CM_RESOURCE_LIST) + (maxSize - 1) *
            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
        newList = ExAllocatePoolWithTag(
            NonPagedPool,
            size,
            ACPI_RESOURCE_POOLTAG
            );
        if (newList == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Merge both sets of descriptors into one list
        //
        RtlZeroMemory( newList, size );
        RtlCopyMemory(
            newList,
            AddList,
            size - (cmCount * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR))
            );
        RtlCopyMemory(
            ( (PUCHAR) newList) +
                (size - (cmCount * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR ) ) ),
            &(cmPartialList->PartialDescriptors[0]),
            cmCount * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
            );

        //
        // Make sure to preserver the version id from the global list
        //
        newList->List->PartialResourceList.Version =
            globalList->List->PartialResourceList.Version;
        newList->List->PartialResourceList.Revision =
            globalList->List->PartialResourceList.Revision;

        ExFreePool( globalList );

    }

    //
    // Obtain a pointer to the descriptors of the new list, and update the
    // number of descriptors in the list
    //
    newPartialList = &(newList->List[0].PartialResourceList);
    newPartialList->Count = cmCount = addCount = maxSize;

    //
    // Make sure to sort the combined list
    //
    status = ACPIRangeSortCmList( newList );
    if (!NT_SUCCESS(status)) {

        ExFreePool( newList );
        return status;

    }

    //
    // Add all the resource we can together
    //
    for (cmIndex = 0; cmIndex < maxSize; cmIndex++) {

        //
        // Grab a pointer to the current descriptor
        //
        newDesc = &(newPartialList->PartialDescriptors[cmIndex]);

        //
        // Is it interesting?
        //
        if (newDesc->Type == CmResourceTypeNull) {

            //
            // No
            //
            continue;

        }

        //
        // Do we care about it?
        //
        if (newDesc->Type != CmResourceTypeMemory &&
            newDesc->Type != CmResourceTypePort &&
            newDesc->Type != CmResourceTypeDma &&
            newDesc->Type != CmResourceTypeInterrupt) {

            //
            // We do not care
            //
            newDesc->Type = CmResourceTypeNull;
            cmCount--;
            continue;

        }

        //
        // Try to get as far as possible
        //
        proceed = TRUE;

        //
        // Try to merge the following items
        //
        for (addIndex = cmIndex + 1; addIndex < maxSize; addIndex++) {

            addDesc = &(newPartialList->PartialDescriptors[addIndex]);

            //
            // If they are not the same type, then we are done here
            //
            if (newDesc->Type != addDesc->Type) {

                continue;

            }

            switch (newDesc->Type) {
            case CmResourceTypePort:
            case CmResourceTypeMemory:
                //
                // Obtain the max addresses
                //
                maxAddr1 = newDesc->u.Port.Start.QuadPart +
                    newDesc->u.Port.Length;
                maxAddr2 = addDesc->u.Port.Start.QuadPart +
                    addDesc->u.Port.Length;

                //
                // does the current new descriptor lie entirely before the
                // add one?
                //
                if (maxAddr1 < (ULONGLONG) addDesc->u.Port.Start.QuadPart ) {

                    //
                    // Yes, so we are done with this newDesc;
                    //
                    proceed = FALSE;
                    break;

                }

                //
                // does part of the current new descriptor lie in part of the
                // add one?
                //
                if (maxAddr1 <= maxAddr2) {

                    //
                    // Update the current new descriptor to reflect the
                    // correct length
                    //
                    newDesc->u.Port.Length = (ULONG) (maxAddr2 -
                        newDesc->u.Port.Start.QuadPart);

                }

                //
                // Nuke the add descriptor since it has been swallowed up
                //
                cmCount--;
                addDesc->Type = CmResourceTypeNull;
                break;

            case CmResourceTypeDma:

                //
                // Do the resource match?
                //
                if (addDesc->u.Dma.Channel != newDesc->u.Dma.Channel) {

                    //
                    // No, then stop
                    //
                    proceed = FALSE;
                    break;

                }

                //
                // We can ignore the duplicate copy
                //
                addDesc->Type = CmResourceTypeNull;
                cmCount--;
                break;

            case CmResourceTypeInterrupt:

                //
                // Do the resource match?
                //
                if (addDesc->u.Interrupt.Vector !=
                    newDesc->u.Interrupt.Vector) {

                    //
                    // No, then stop
                    //
                    proceed = FALSE;
                    break;

                }

                //
                // We can ignore the duplicate copy
                //
                addDesc->Type = CmResourceTypeNull;
                cmCount--;
                break;
            } // switch

            //
            // Do we have to stop?
            //
            if (proceed == FALSE) {

                break;
            }

        } // for

    } // for

    //
    // Do we have any items that we care about left?
    //
    if (cmCount == 0) {

        //
        // No, then free everything and return an empty list
        //
        ExFreePool( newList );
        return STATUS_SUCCESS;

    }

    //
    // Now we can build the proper list. See how many items we must
    // allocate
    //
    size = sizeof(CM_RESOURCE_LIST) + (cmCount - 1) *
        sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
    globalList = ExAllocatePoolWithTag(
        NonPagedPool,
        size,
        ACPI_RESOURCE_POOLTAG
        );
    if (globalList == NULL) {

        ExFreePool( newList );
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    //
    // Initialize the list by copying the header from the AddList
    //
    RtlZeroMemory( globalList, size );
    RtlCopyMemory(
        globalList,
        AddList,
        sizeof(CM_RESOURCE_LIST)
        );
    cmPartialList = &(globalList->List[0].PartialResourceList);
    cmPartialList->Count = cmCount;

    //
    // Copy all of the valid resources into this new list
    //
    for (cmIndex = 0, addIndex = 0;
         cmIndex < maxSize && addIndex < cmCount;
         cmIndex++) {

        newDesc = &(newPartialList->PartialDescriptors[cmIndex]);

        //
        // If the type is null, skip it
        //
        if (newDesc->Type == CmResourceTypeNull) {

            continue;

        }

        //
        // Copy the new list
        //
        RtlCopyMemory(
            &(cmPartialList->PartialDescriptors[addIndex]),
            newDesc,
            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
            );
        addIndex++;

    }

    //
    // Free the old lists
    //
    ExFreePool( newList );

    //
    // Point the global to the new list
    //
    *GlobalList = globalList;

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIRangeFilterPICInterrupt(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST  IoResList
    )
/*++

Routine Description:

    This routine is called to remove Interrupt #2 from the list of
    resources that are returned by the PIC

Arguments:

    IoResList   - The IO Resource List to smash

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PIO_RESOURCE_LIST   ioList;
    ULONG               i;
    ULONG               j;
    ULONG               size;

    //
    // Sanity checks
    //
    if (IoResList == NULL) {

        //
        // No work to do
        //
        return STATUS_SUCCESS;

    }

    //
    // Walk the resource requirements list
    //
    ioList = &(IoResList->List[0]);
    for (i = 0; i < IoResList->AlternativeLists; i++) {

        //
        // Walk the IO list
        //
        for (j = 0; j < ioList->Count; j++) {

            if (ioList->Descriptors[j].Type != CmResourceTypeInterrupt) {

                continue;

            }

            //
            // Do we have the case where the minimum starts on int 2?
            //
            if (ioList->Descriptors[j].u.Interrupt.MinimumVector == 2) {

                //
                // If the maximum is on 2, then we snuff out this
                // descriptors, otherwise, we change the minimum
                //
                if (ioList->Descriptors[j].u.Interrupt.MaximumVector == 2) {

                    ioList->Descriptors[j].Type = CmResourceTypeNull;

                } else {

                    ioList->Descriptors[j].u.Interrupt.MinimumVector++;

                }
                continue;

            }

            //
            // Do we have the case where the maximum ends on int 2?
            // Note that the minimum cannot be on 2...
            //
            if (ioList->Descriptors[j].u.Interrupt.MaximumVector == 2) {

                ioList->Descriptors[j].u.Interrupt.MaximumVector--;
                continue;

            }

            //
            // If INT2 is in the middle of the ranges, then prune them
            // one way or the other...
            //
            if (ioList->Descriptors[j].u.Interrupt.MinimumVector < 2 &&
                ioList->Descriptors[j].u.Interrupt.MaximumVector > 2) {

                ioList->Descriptors[j].u.Interrupt.MinimumVector = 3;

            }

        }

        //
        // Next list
        //
        size = sizeof(IO_RESOURCE_LIST) +
            ( (ioList->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) );
        ioList = (PIO_RESOURCE_LIST) ( ( (PUCHAR) ioList ) + size );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIRangeSortCmList(
    IN  PCM_RESOURCE_LIST   CmResList
    )
/*++

Routine Description:

    This routine ensures that the elements of a CmResList are sorted in
    assending order (by type)

Arguments:

    CmResList   - The list to sort

Return Value:

    NTSTATUS

--*/
{
    CM_PARTIAL_RESOURCE_DESCRIPTOR  tempDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR curDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR subDesc;
    PCM_PARTIAL_RESOURCE_LIST       cmList;
    ULONG                           cmIndex;
    ULONG                           cmSize;
    ULONG                           cmSubLoop;

    //
    // Setup the pointer to the cmList
    //
    cmList = &(CmResList->List[0].PartialResourceList);
    cmSize = cmList->Count;

    for (cmIndex = 0; cmIndex < cmSize; cmIndex++) {

        curDesc = &(cmList->PartialDescriptors[cmIndex]);

        for (cmSubLoop = cmIndex + 1; cmSubLoop < cmSize; cmSubLoop++) {

            subDesc = &(cmList->PartialDescriptors[cmSubLoop]);

            //
            // Is this a compatible descriptor?
            //
            if (curDesc->Type != subDesc->Type) {

                continue;

            }

            //
            // Test by type
            //
            if (curDesc->Type == CmResourceTypePort ||
                curDesc->Type == CmResourceTypeMemory) {

                if (subDesc->u.Port.Start.QuadPart <
                    curDesc->u.Port.Start.QuadPart) {

                    curDesc = subDesc;

                }

            } else if (curDesc->Type == CmResourceTypeInterrupt) {

                if (subDesc->u.Interrupt.Vector < curDesc->u.Interrupt.Vector) {

                    curDesc = subDesc;

                }

            } else if (curDesc->Type == CmResourceTypeDma) {

                if (subDesc->u.Dma.Channel < curDesc->u.Dma.Channel) {

                    curDesc = subDesc;

                }

            }

        }

        //
        // Did we find a smaller element?
        //
        if (curDesc == &(cmList->PartialDescriptors[cmIndex])) {

            continue;

        }

        //
        // We have found the smallest element. Swap them
        //
        RtlCopyMemory(
            &tempDesc,
            &(cmList->PartialDescriptors[cmIndex]),
            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
            );
        RtlCopyMemory(
            &(cmList->PartialDescriptors[cmIndex]),
            curDesc,
            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
            );
        RtlCopyMemory(
            curDesc,
            &tempDesc,
            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
            );

    }

    //
    // Success
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIRangeSortIoList(
    IN  PIO_RESOURCE_LIST   IoList
    )
/*++

Routine Description:

    This routine ensures that the elements of a CmResList are sorted in
    assending order (by type)

Arguments:

    CmResList   - The list to sort

Return Value:

    NTSTATUS

--*/
{
    IO_RESOURCE_DESCRIPTOR          tempDesc;
    PIO_RESOURCE_DESCRIPTOR         curDesc;
    PIO_RESOURCE_DESCRIPTOR         subDesc;
    ULONG                           ioIndex;
    ULONG                           ioSize;
    ULONG                           ioSubLoop;

    //
    // Count the number of element ioList
    //
    ioSize = IoList->Count;

    for (ioIndex = 0; ioIndex < ioSize; ioIndex++) {

        curDesc = &(IoList->Descriptors[ioIndex]);

        for (ioSubLoop = ioIndex + 1; ioSubLoop < ioSize; ioSubLoop++) {

            subDesc = &(IoList->Descriptors[ioSubLoop]);

            //
            // Is this a compatible descriptor?
            //
            if (curDesc->Type != subDesc->Type) {

                continue;

            }

            //
            // Test by type
            //
            if (curDesc->Type == CmResourceTypePort ||
                curDesc->Type == CmResourceTypeMemory) {

                if (subDesc->u.Port.MinimumAddress.QuadPart <
                    curDesc->u.Port.MinimumAddress.QuadPart) {

                    curDesc = subDesc;

                }

            } else if (curDesc->Type == CmResourceTypeInterrupt ||
                       curDesc->Type == CmResourceTypeDma) {

                if (subDesc->u.Interrupt.MinimumVector <
                    curDesc->u.Interrupt.MinimumVector) {

                    curDesc = subDesc;

                }

            }

        }

        //
        // Did we find a smaller element?
        //
        if (curDesc == &(IoList->Descriptors[ioIndex])) {

            continue;

        }

        //
        // We have found the smallest element. Swap them
        //
        RtlCopyMemory(
            &tempDesc,
            &(IoList->Descriptors[ioIndex]),
            sizeof(IO_RESOURCE_DESCRIPTOR)
            );
        RtlCopyMemory(
            &(IoList->Descriptors[ioIndex]),
            curDesc,
            sizeof(IO_RESOURCE_DESCRIPTOR)
            );
        RtlCopyMemory(
            curDesc,
            &tempDesc,
            sizeof(IO_RESOURCE_DESCRIPTOR)
            );

    }

    //
    // Success
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIRangeSubtract(
    IN  OUT PIO_RESOURCE_REQUIREMENTS_LIST   *IoResReqList,
    IN      PCM_RESOURCE_LIST               CmResList
    )
/*++

Routine Description:

    This routine takes a IoResReqList, and subtracts the CmResList
    from each one of the IoResList, and returns the new list

Arguments:

    IoResReqList    The original list and where to store the new one
    CmResList       What to subtract

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                        status;
    PIO_RESOURCE_LIST               curList;
    PIO_RESOURCE_LIST               *resourceArray;
    PIO_RESOURCE_REQUIREMENTS_LIST  newList;
    PUCHAR                          buffer;
    ULONG                           listIndex;
    ULONG                           listSize = (*IoResReqList)->AlternativeLists;
    ULONG                           newSize;
    ULONG                           size;

    //
    // Sort the CmResList
    //
    status = ACPIRangeSortCmList( CmResList );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIRangeSubtract: AcpiRangeSortCmList 0x%08lx Failed 0x%08lx\n",
            CmResList,
            status
            ) );
        return status;

    }

    //
    // Allocate an array to hold all the alternatives
    //
    resourceArray = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(PIO_RESOURCE_LIST) * listSize,
        ACPI_RESOURCE_POOLTAG
        );
    if (resourceArray == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( resourceArray, sizeof(PIO_RESOURCE_LIST) * listSize );

    //
    // Get the first list to work on
    //
    curList = &( (*IoResReqList)->List[0]);
    buffer = (PUCHAR) curList;
    newSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) - sizeof(IO_RESOURCE_LIST);

    //
    // Sort the IoResList
    //
    status = ACPIRangeSortIoList( curList );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIRangeSubtract: AcpiRangeSortIoList 0x%08lx Failed 0x%08lx\n",
            *curList,
            status
            ) );
        return status;

    }


    //
    // Process all the elements in the list
    //
    for (listIndex = 0; listIndex < listSize; listIndex++) {

        //
        // Process that list
        //
        status = ACPIRangeSubtractIoList(
            curList,
            CmResList,
            &(resourceArray[listIndex])
            );
        if (!NT_SUCCESS(status)) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ACPIRangeSubtract: Failed - 0x%08lx\n",
                status
                ) );
            while (listIndex) {

                ExFreePool( resourceArray[listIndex] );
                listIndex--;

            }
            ExFreePool( resourceArray );
            return status;

        }

        //
        // Help calculate the size of the new res req descriptor
        //
        newSize += sizeof(IO_RESOURCE_LIST) +
            ( ( (resourceArray[listIndex])->Count - 1) *
            sizeof(IO_RESOURCE_DESCRIPTOR) );

        //
        // Find the next list
        //
        size = sizeof(IO_RESOURCE_LIST) + (curList->Count - 1) *
            sizeof(IO_RESOURCE_DESCRIPTOR);
        buffer += size;
        curList = (PIO_RESOURCE_LIST) buffer;

    }

    //
    // Allocate the new list
    //
    newList = ExAllocatePoolWithTag(
        NonPagedPool,
        newSize,
        ACPI_RESOURCE_POOLTAG
        );
    if (newList == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIRangeSubtract: Failed to allocate 0x%08lx bytes\n",
            size
            ) );
        do {

            listSize--;
            ExFreePool( resourceArray[listSize] );

        } while (listSize);
        ExFreePool( resourceArray );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Copy the head of the res req list
    //
    RtlZeroMemory( newList, newSize );
    RtlCopyMemory(
        newList,
        *IoResReqList,
        sizeof(IO_RESOURCE_REQUIREMENTS_LIST) -
        sizeof(IO_RESOURCE_LIST)
        );
    newList->ListSize = newSize;
    curList = &(newList->List[0]);
    buffer = (PUCHAR) curList;

    for (listIndex = 0; listIndex < listSize; listIndex++) {

        //
        // Determine the size to copy
        //
        size = sizeof(IO_RESOURCE_LIST) +
            ( ( ( (resourceArray[listIndex])->Count) - 1) *
              sizeof(IO_RESOURCE_DESCRIPTOR) );

        //
        // Copy the new resource to the correct place
        //
        RtlCopyMemory(
            curList,
            resourceArray[ listIndex ],
            size
            );

        //
        // Find the next list
        //
        buffer += size;
        curList = (PIO_RESOURCE_LIST) buffer;

        //
        // Done with this list
        //
        ExFreePool( resourceArray[listIndex] );

    }

    //
    // Done with this area of memory
    //
    ExFreePool( resourceArray );

    //
    // Free Old list
    //
    ExFreePool( *IoResReqList );

    //
    // Return the new list
    //
    *IoResReqList = newList;

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIRangeSubtractIoList(
    IN  PIO_RESOURCE_LIST   IoResList,
    IN  PCM_RESOURCE_LIST   CmResList,
    OUT PIO_RESOURCE_LIST   *Result
    )
/*++

Routine Description:

    This routine is responsible for subtracting the elements of the
    CmResList from the IoResList

Arguments:

    IoResList   - The list to subtract from
    CmResList   - The list to subtract
    Result      - The answer

Return Value:

    NTSTATUS

--*/
{
    //
    // The current CM descriptor
    //
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDesc;
    //
    // The current CM resource list that we are processing
    //
    PCM_PARTIAL_RESOURCE_LIST       cmList;
    //
    // The current IO descriptor
    //
    PIO_RESOURCE_DESCRIPTOR         ioDesc;
    //
    // The working copy of the result list
    //
    PIO_RESOURCE_LIST               workList;
    //
    // The current index into the cm res list
    //
    ULONG                           cmIndex;
    //
    // The number of elements there are in the cm res list
    //
    ULONG                           cmSize;
    //
    // The current index into the io res list
    //
    ULONG                           ioIndex;
    //
    // The number of elements there are in the io res list
    //
    ULONG                           ioSize;
    //
    // The current index into the result. This is where the 'next' resource
    // descriptor goes into.
    //
    ULONG                           resultIndex = 0;
    //
    // How many elements there are in the result
    //
    ULONG                           resultSize;
    //
    // These are the max and min of the cm desc
    //
    ULONGLONG                       cmMax, cmMin;
    //
    // These are the max and min of the io desc
    //
    ULONGLONG                       ioMax, ioMin;
    //
    // The length of the resource
    //
    ULONGLONG                       length;

    //
    // Step one: Obtain the pointers we need to the start of the cm list
    // and the size of the supplied lists
    //
    cmList = &(CmResList->List[0].PartialResourceList);
    cmSize = cmList->Count;
    ioSize = IoResList->Count;

    //
    // Step two: Calculate the number of Io descriptors needed in the
    // worst case. That is 2x the number of cm descriptors plut the number
    // of original io descriptors.
    //
    resultSize = cmSize * 2 + ioSize * 2;

    //
    // Step three: Allocate enough memory for those descriptors
    //
    workList = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(IO_RESOURCE_LIST) +
            (sizeof(IO_RESOURCE_DESCRIPTOR) * (resultSize - 1) ),
        ACPI_RESOURCE_POOLTAG
        );
    if (workList == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( workList, sizeof(IO_RESOURCE_LIST) +
        (sizeof(IO_RESOURCE_DESCRIPTOR) * (resultSize - 1) ) );
    RtlCopyMemory(
        workList,
        IoResList,
        sizeof(IO_RESOURCE_LIST) - sizeof(IO_RESOURCE_DESCRIPTOR)
        );

    //
    // Step four: walk through the entire io res list
    //
    for (ioIndex = 0; ioIndex < ioSize; ioIndex++) {

        //
        // Step five: copy the current descriptor to the result, and
        // keep a pointer to it. Remember where to store the next io
        // descriptor.
        //
        RtlCopyMemory(
            &(workList->Descriptors[resultIndex]),
            &(IoResList->Descriptors[ioIndex]),
            sizeof(IO_RESOURCE_DESCRIPTOR)
            );
        ACPIPrint( (
            ACPI_PRINT_RESOURCES_2,
            "Copied Desc %d (0x%08lx) to Index %d (0x%08lx)\n",
            ioIndex,
            &(IoResList->Descriptors[ioIndex]),
            resultIndex,
            &(workList->Descriptors[resultIndex])
            ) );
        ioDesc = &(workList->Descriptors[resultIndex]);
        resultIndex += 1;

        //
        // Step six: Walk the Cm Res list, looking for resources to
        // subtract from this descriptor
        //
        for (cmIndex = 0; cmIndex < cmSize; cmIndex++) {

            //
            // If we don't have a resource descriptor any more, then
            // we stop looping
            //
            if (ioDesc == NULL) {

                break;

            }

            //
            // Step seven: determine the current cm descriptor
            //
            cmDesc = &(cmList->PartialDescriptors[cmIndex]);

            //
            // Step eight: is the current cm descriptor of the same type
            // as the io descriptor?
            //
            if (cmDesc->Type != ioDesc->Type) {

                //
                // No
                //
                continue;

            }

            //
            // Step nine: we must handle each resource type indepently.
            //
            switch (ioDesc->Type) {
            case CmResourceTypeMemory:
            case CmResourceTypePort:

                ioMin = ioDesc->u.Port.MinimumAddress.QuadPart;
                ioMax = ioDesc->u.Port.MaximumAddress.QuadPart;
                cmMin = cmDesc->u.Port.Start.QuadPart;
                cmMax = cmDesc->u.Port.Start.QuadPart +
                    cmDesc->u.Port.Length - 1;

                ACPIPrint( (
                    ACPI_PRINT_RESOURCES_2,
                    "ACPIRangeSubtractIoRange: ioMin 0x%lx ioMax 0x%lx "
                    "cmMin 0x%lx cmMax 0x%lx resultIndex 0x%lx\n",
                    (ULONG) ioMin,
                    (ULONG) ioMax,
                    (ULONG) cmMin,
                    (ULONG) cmMax,
                    resultIndex
                    ) );

                //
                // Does the descriptors overlap?
                //
                if (ioMin > cmMax || ioMax < cmMin) {

                    break;

                }

                //
                // Do we need to remove the descriptor from the list?
                //
                if (ioMin >= cmMin && ioMax <= cmMax) {

                    resultIndex -= 1;
                    ioDesc = NULL;
                    break;

                }

                //
                // Do we need to truncate the lowpart of the io desc?
                //
                if (ioMin >= cmMin && ioMax > cmMax) {

                    ioDesc->u.Port.MinimumAddress.QuadPart = (cmMax + 1);
                    length = ioMax - cmMax;

                }

                //
                // Do we need to truncate the highpart of the io desc?
                //
                if (ioMin < cmMin && ioMax <= cmMax) {

                    ioDesc->u.Port.MaximumAddress.QuadPart = (cmMin - 1);
                    length = cmMin - ioMin;

                }

                //
                // Do we need to split the descriptor into two parts
                //
                if (ioMin < cmMin && ioMax > cmMax) {

                    //
                    // Create a new descriptors
                    //
                    RtlCopyMemory(
                        &(workList->Descriptors[resultIndex]),
                        ioDesc,
                        sizeof(IO_RESOURCE_DESCRIPTOR)
                        );
                    ACPIPrint( (
                        ACPI_PRINT_RESOURCES_2,
                        "Copied Desc (0x%08lx) to Index %d (0x%08lx)\n",
                        &(IoResList->Descriptors[ioIndex]),
                        resultIndex,
                        &(workList->Descriptors[resultIndex])
                        ) );
                    ioDesc->u.Port.MaximumAddress.QuadPart = (cmMin - 1);
                    ioDesc->u.Port.Alignment = 1;
                    length = cmMin - ioMin;
                    if ( (ULONG) length < ioDesc->u.Port.Length) {

                        ioDesc->u.Port.Length = (ULONG) length;

                    }

                    //
                    // Next descriptor
                    //
                    ioDesc = &(workList->Descriptors[resultIndex]);
                    ioDesc->u.Port.MinimumAddress.QuadPart = (cmMax + 1);
                    ioDesc->u.Port.Alignment = 1;
                    length = ioMax - cmMax;
                    resultIndex += 1;

                }

                //
                // Do we need to update the length?
                //
                if ( (ULONG) length < ioDesc->u.Port.Length) {

                    ioDesc->u.Port.Length = (ULONG) length;

                }
                break;

            case CmResourceTypeInterrupt:

                //
                // Do the descriptors overlap?
                //
                if (ioDesc->u.Interrupt.MinimumVector >
                    cmDesc->u.Interrupt.Vector ||
                    ioDesc->u.Interrupt.MaximumVector <
                    cmDesc->u.Interrupt.Vector) {

                    break;

                }

                //
                // Do we have to remove the descriptor
                //
                if (ioDesc->u.Interrupt.MinimumVector ==
                    cmDesc->u.Interrupt.Vector &&
                    ioDesc->u.Interrupt.MaximumVector ==
                    cmDesc->u.Interrupt.Vector) {

                    resultIndex =- 1;
                    ioDesc = NULL;
                    break;

                }

                //
                // Do we clip the low part?
                //
                if (ioDesc->u.Interrupt.MinimumVector ==
                    cmDesc->u.Interrupt.Vector) {

                    ioDesc->u.Interrupt.MinimumVector++;
                    break;

                }

                //
                // Do we clip the high part
                //
                if (ioDesc->u.Interrupt.MaximumVector ==
                    cmDesc->u.Interrupt.Vector) {

                    ioDesc->u.Interrupt.MaximumVector--;
                    break;

                }

                //
                // Split the record
                //
                RtlCopyMemory(
                    &(workList->Descriptors[resultIndex]),
                    ioDesc,
                    sizeof(IO_RESOURCE_DESCRIPTOR)
                    );
                ACPIPrint( (
                    ACPI_PRINT_RESOURCES_2,
                    "Copied Desc (0x%08lx) to Index %d (0x%08lx)\n",
                    &(IoResList->Descriptors[ioIndex]),
                    resultIndex,
                    &(workList->Descriptors[resultIndex])
                    ) );
                ioDesc->u.Interrupt.MaximumVector =
                    cmDesc->u.Interrupt.Vector - 1;
                ioDesc = &(workList->Descriptors[resultIndex]);
                ioDesc->u.Interrupt.MinimumVector =
                    cmDesc->u.Interrupt.Vector + 1;
                resultIndex += 1;
                break;

            case CmResourceTypeDma:

                //
                // Do the descriptors overlap?
                //
                if (ioDesc->u.Dma.MinimumChannel >
                    cmDesc->u.Dma.Channel ||
                    ioDesc->u.Dma.MaximumChannel <
                    cmDesc->u.Dma.Channel) {

                    break;

                }

                //
                // Do we have to remove the descriptor
                //
                if (ioDesc->u.Dma.MinimumChannel ==
                    cmDesc->u.Dma.Channel &&
                    ioDesc->u.Dma.MaximumChannel ==
                    cmDesc->u.Dma.Channel) {

                    resultIndex -= 1;
                    ioDesc = NULL;
                    break;

                }

                //
                // Do we clip the low part?
                //
                if (ioDesc->u.Dma.MinimumChannel ==
                    cmDesc->u.Dma.Channel) {

                    ioDesc->u.Dma.MinimumChannel++;
                    break;

                }

                //
                // Do we clip the high part
                //
                if (ioDesc->u.Dma.MaximumChannel ==
                    cmDesc->u.Dma.Channel) {

                    ioDesc->u.Dma.MaximumChannel--;
                    break;

                }

                //
                // Split the record
                //
                RtlCopyMemory(
                    &(workList->Descriptors[resultIndex]),
                    ioDesc,
                    sizeof(IO_RESOURCE_DESCRIPTOR)
                    );
                ACPIPrint( (
                    ACPI_PRINT_RESOURCES_2,
                    "Copied Desc (0x%08lx) to Index %d (0x%08lx)\n",
                    &(IoResList->Descriptors[ioIndex]),
                    resultIndex,
                    &(workList->Descriptors[resultIndex])
                    ) );
                ioDesc->u.Dma.MaximumChannel =
                    cmDesc->u.Dma.Channel - 1;
                ioDesc = &(workList->Descriptors[resultIndex]);
                ioDesc->u.Dma.MinimumChannel =
                    cmDesc->u.Dma.Channel + 1;
                resultIndex += 1;
                break;
            } // switch

        } // for

        //
        // Step ten, make a backup copy of the original descriptor, and
        // mark it as a DeviceSpecific resource
        //
        RtlCopyMemory(
            &(workList->Descriptors[resultIndex]),
            &(IoResList->Descriptors[ioIndex]),
            sizeof(IO_RESOURCE_DESCRIPTOR)
            );
        ACPIPrint( (
            ACPI_PRINT_RESOURCES_2,
            "Copied Desc %d (0x%08lx) to Index %d (0x%08lx) for backup\n",
            ioIndex,
            &(IoResList->Descriptors[ioIndex]),
            resultIndex,
            &(workList->Descriptors[resultIndex])
            ) );

        ioDesc = &(workList->Descriptors[resultIndex]);
        ioDesc->Type = CmResourceTypeDevicePrivate;
        resultIndex += 1;

    } // for

    //
    // Step 11: Calculate the number of resources in the new list
    //
    workList->Count = resultIndex;

    //
    // Step 12: Allocate the block for the return value. Don't waste
    // any memory here
    //
    *Result = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(IO_RESOURCE_LIST) +
            (sizeof(IO_RESOURCE_DESCRIPTOR) * (resultIndex - 1) ),
        ACPI_RESOURCE_POOLTAG
        );
    if (*Result == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Step 13: Copy the result over and free the work buffer
    //
    RtlCopyMemory(
        *Result,
        workList,
        sizeof(IO_RESOURCE_LIST) +
            (sizeof(IO_RESOURCE_DESCRIPTOR) * (resultIndex - 1) )
        );

    //
    // Step 14: Done
    //
    return STATUS_SUCCESS;
}

VOID
ACPIRangeValidatePciMemoryResource(
    IN  PIO_RESOURCE_LIST       IoList,
    IN  ULONG                   Index,
    IN  PACPI_BIOS_MULTI_NODE   E820Info,
    OUT ULONG                   *BugCheck
    )
/*++

Routine Description:

    This routine checks the specified descriptor in the resource list does
    not in any way overlap or conflict with any of the descriptors in the
    E820 information structure

Arguments:

    IoResList   - The IoResourceList to check
    Index       - The descript we are currently looking at
    E820Info    - The BIOS's memory description table (Chapter 14 of ACPI Spec)
    BugCheck    - The number of bugcheckable offences commited


Return Value:

    None

--*/
{
    ULONG       i;
    ULONGLONG   absMin;
    ULONGLONG   absMax;

    ASSERT( IoList != NULL );

    //
    // Make sure that there is an E820 table before we look at it
    //
    if (E820Info == NULL) {

        return;
    }

    //
    // Calculate the absolute maximum and minimum size of the memory window
    //
    absMin = IoList->Descriptors[Index].u.Memory.MinimumAddress.QuadPart;
    absMax = IoList->Descriptors[Index].u.Memory.MaximumAddress.QuadPart;

    //
    // Look at all the entries in the E820Info and see if there is an
    // overlap
    //
    for (i = 0; i < E820Info->Count; i++) {

        //
        // Hackhack --- if this is a "Reserved" address, then don't consider
        // those a bugcheck
        //
        if (E820Info->E820Entry[i].Type == AcpiAddressRangeReserved) {

            continue;

        }

        //
        // Do some fixups firsts
        //
        if (E820Info->E820Entry[i].Type == AcpiAddressRangeNVS ||
            E820Info->E820Entry[i].Type == AcpiAddressRangeACPI) {

            ASSERT( E820Info->E820Entry[i].Length.HighPart == 0);
            if (E820Info->E820Entry[i].Length.HighPart != 0) {

                ACPIPrint( (
                    ACPI_PRINT_WARNING,
                    "ACPI: E820 Entry #%d (type %d) Length = %016I64x > 32bit\n",
                    i,
                    E820Info->E820Entry[i].Type,
                    E820Info->E820Entry[i].Length.QuadPart
                    ) );
                E820Info->E820Entry[i].Length.HighPart = 0;

            }

        }

        //
        // Is the descriptor beyond what we are looking for?
        //
        if (absMax < (ULONGLONG) E820Info->E820Entry[i].Base.QuadPart) {

            continue;
        }

        //
        // Is it before what we are looking for?
        //
        if (absMin >= (ULONGLONG) (E820Info->E820Entry[i].Base.QuadPart + E820Info->E820Entry[i].Length.QuadPart) ) {

            continue;

        }

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPI: E820 Entry %d (type %I64d) (%I64x-%I64x) overlaps\n"
            "ACPI: PCI  Entry %d Min:%I64x Max:%I64x Length:%lx Align:%lx\n",
            i, E820Info->E820Entry[i].Type,
            E820Info->E820Entry[i].Base.QuadPart,
            (E820Info->E820Entry[i].Base.QuadPart + E820Info->E820Entry[i].Length.QuadPart),
            Index,
            IoList->Descriptors[Index].u.Memory.MinimumAddress.QuadPart,
            IoList->Descriptors[Index].u.Memory.MaximumAddress.QuadPart,
            IoList->Descriptors[Index].u.Memory.Length,
            IoList->Descriptors[Index].u.Memory.Alignment
            ) );

        //
        // Is this an NVS area? Are we doing an override of this?
        //
        if ( (AcpiOverrideAttributes & ACPI_OVERRIDE_NVS_CHECK) &&
             (E820Info->E820Entry[i].Type == AcpiAddressRangeNVS) ) {

            if (absMax >= (ULONGLONG) E820Info->E820Entry[i].Base.QuadPart &&
                absMin < (ULONGLONG) E820Info->E820Entry[i].Base.QuadPart) {

                //
                // We can attempt to do a helpfull fixup here
                //
                IoList->Descriptors[Index].u.Memory.MaximumAddress.QuadPart =
                    (ULONGLONG) E820Info->E820Entry[i].Base.QuadPart - 1;
                IoList->Descriptors[Index].u.Memory.Length = (ULONG)
                    (IoList->Descriptors[Index].u.Memory.MaximumAddress.QuadPart -
                    IoList->Descriptors[Index].u.Memory.MinimumAddress.QuadPart + 1);

                ACPIPrint( (
                    ACPI_PRINT_CRITICAL,
                    "ACPI: PCI  Entry %d Changed to\n"
                    "ACPI: PCI  Entry %d Min:%I64x Max:%I64x Length:%lx Align:%lx\n",
                    Index,
                    Index,
                    IoList->Descriptors[Index].u.Memory.MinimumAddress.QuadPart,
                    IoList->Descriptors[Index].u.Memory.MaximumAddress.QuadPart,
                    IoList->Descriptors[Index].u.Memory.Length,
                    IoList->Descriptors[Index].u.Memory.Alignment
                    ) );

            }

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ACPI: E820 Entry %d Overrides PCI Entry\n",
                i
                ) );

            continue;

        }

        //
        // If we got here, then there is an overlap, and we need to bugcheck
        //
        (*BugCheck)++;

    }
}

VOID
ACPIRangeValidatePciResources(
    IN  PDEVICE_EXTENSION               DeviceExtension,
    IN  PIO_RESOURCE_REQUIREMENTS_LIST  IoResList
    )
/*++

Routine Description:

    This routine is called to make sure that the resource that we will
    hand of to PCI have a chance of making the system boot.

    This is what the list will allow
        MEM -   A0000 - DFFFF,
                <Physical Base> - 4GB
        IO  -   Any
        BUS -   Any

    The code checks to make sure that the Length = Max - Min + 1, and that
    the Alignment value is correct

Arguments:

    IoResList -    The list to check

Return Value:

    Nothing

--*/
{
    NTSTATUS                        status;
    PACPI_BIOS_MULTI_NODE           e820Info;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartialDesc;
    PCM_PARTIAL_RESOURCE_LIST       cmPartialList;
    PIO_RESOURCE_LIST               ioList;
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  keyInfo;
    ULONG                           bugCheck = 0;
    ULONG                           i;
    ULONG                           j;
    ULONGLONG                       length;
    ULONG                           size;

    if (IoResList == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIRangeValidPciResources: No IoResList\n"
            ) );

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_ROOT_PCI_RESOURCE_FAILURE,
            (ULONG_PTR) DeviceExtension,
            2,
            0
            );

    }

    //
    // Read the key for the AcpiConfigurationData
    //
    status = OSReadAcpiConfigurationData( &keyInfo );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIRangeValidatePciResources: Cannot get Information %08lx\n",
            status
            ) );
        return;

    }

    //
    // Crack the structure to get the E820Table entry
    //
    cmPartialList = (PCM_PARTIAL_RESOURCE_LIST) (keyInfo->Data);
    cmPartialDesc = &(cmPartialList->PartialDescriptors[0]);
    e820Info = (PACPI_BIOS_MULTI_NODE) ( (PUCHAR) cmPartialDesc +
        sizeof(CM_PARTIAL_RESOURCE_LIST) );

    //
    // Walk the resource requirements list
    //
    ioList = &(IoResList->List[0]);
    for (i = 0; i < IoResList->AlternativeLists; i++) {

        //
        // Walk the IO list
        //
        for (j = 0; j < ioList->Count; j++) {

            if (ioList->Descriptors[j].Type == CmResourceTypePort ||
                ioList->Descriptors[j].Type == CmResourceTypeMemory) {

                length = ioList->Descriptors[j].u.Port.MaximumAddress.QuadPart -
                    ioList->Descriptors[j].u.Port.MinimumAddress.QuadPart + 1;

                //
                // Does the length match?
                //
                if (length != ioList->Descriptors[j].u.Port.Length) {

                    ACPIPrint( (
                        ACPI_PRINT_CRITICAL,
                        "ACPI: Invalid IO/Mem Length - ( (Max - Min + 1) != Length)\n"
                        "ACPI: PCI  Entry %d Min:%I64x Max:%I64x Length:%lx Align:%lx\n",
                        ioList->Descriptors[j].u.Memory.MinimumAddress.QuadPart,
                        ioList->Descriptors[j].u.Memory.MaximumAddress.QuadPart,
                        ioList->Descriptors[j].u.Memory.Length,
                        ioList->Descriptors[j].u.Memory.Alignment
                        ) );
                    bugCheck++;
                    ioList->Descriptors[j].u.Port.Length = (ULONG) length;

                }

                //
                // Is the alignment non-zero?
                //
                if (ioList->Descriptors[j].u.Port.Alignment == 0) {

                    ACPIPrint( (
                        ACPI_PRINT_CRITICAL,
                        "ACPI: Invalid IO/Mem Alignment"
                        "ACPI: PCI  Entry %d Min:%I64x Max:%I64x Length:%lx Align:%lx\n",
                        ioList->Descriptors[j].u.Memory.MinimumAddress.QuadPart,
                        ioList->Descriptors[j].u.Memory.MaximumAddress.QuadPart,
                        ioList->Descriptors[j].u.Memory.Length,
                        ioList->Descriptors[j].u.Memory.Alignment
                        ) );
                    bugCheck++;
                    ioList->Descriptors[j].u.Port.Alignment = 1;

                }

                //
                // The alignment cannot intersect with the min value
                //
                if (ioList->Descriptors[j].u.Port.MinimumAddress.LowPart &
                    (ioList->Descriptors[j].u.Port.Alignment - 1) ) {

                    ACPIPrint( (
                        ACPI_PRINT_CRITICAL,
                        "ACPI: Invalid IO/Mem Alignment - (Min & (Align - 1) )\n"
                        "ACPI: PCI  Entry %d Min:%I64x Max:%I64x Length:%lx Align:%lx\n",
                        ioList->Descriptors[j].u.Memory.MinimumAddress.QuadPart,
                        ioList->Descriptors[j].u.Memory.MaximumAddress.QuadPart,
                        ioList->Descriptors[j].u.Memory.Length,
                        ioList->Descriptors[j].u.Memory.Alignment
                        ) );
                    bugCheck++;
                    ioList->Descriptors[j].u.Port.Alignment = 1;

                }

            }

            if (ioList->Descriptors[j].Type == CmResourceTypeBusNumber) {

                length = ioList->Descriptors[j].u.BusNumber.MaxBusNumber -
                    ioList->Descriptors[j].u.BusNumber.MinBusNumber + 1;

                //
                // Does the length match?
                //
                if (length != ioList->Descriptors[j].u.BusNumber.Length) {

                    ACPIPrint( (
                        ACPI_PRINT_CRITICAL,
                        "ACPI: Invalid BusNumber Length - ( (Max - Min + 1) != Length)\n"
                        "ACPI: PCI  Entry %d Min:%x Max:%x Length:%lx\n",
                        ioList->Descriptors[j].u.BusNumber.MinBusNumber,
                        ioList->Descriptors[j].u.BusNumber.MaxBusNumber,
                        ioList->Descriptors[j].u.BusNumber.Length
                        ) );
                    bugCheck++;
                    ioList->Descriptors[j].u.BusNumber.Length = (ULONG) length;

                }

            }

            if (ioList->Descriptors[j].Type == CmResourceTypeMemory) {

                ACPIRangeValidatePciMemoryResource(
                    ioList,
                    j,
                    e820Info,
                    &bugCheck
                    );

            }

        }

        //
        // Next list
        //
        size = sizeof(IO_RESOURCE_LIST) +
            ( (ioList->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) );
        ioList = (PIO_RESOURCE_LIST) ( ( (PUCHAR) ioList ) + size );

    }

    //
    // Do we errors?
    //
    if (bugCheck) {

         ACPIPrint( (
             ACPI_PRINT_CRITICAL,
             "ACPI:\n"
             "ACPI: FATAL BIOS ERROR - Need new BIOS to fix PCI problems\n"
             "ACPI:\n"
             "ACPI: This machine will not boot after 8/26/98!!!!\n"
             ) );

        //
        // No, well, bugcheck
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_ROOT_PCI_RESOURCE_FAILURE,
            (ULONG_PTR) DeviceExtension,
            (ULONG_PTR) IoResList,
            (ULONG_PTR) e820Info
            );

    }

    //
    // Free the E820 info
    //
    ExFreePool( keyInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\ospower.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ospower.c

Abstract:

    This module abstracts the power information structures to each of the
    OSes

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

PACPI_POWER_INFO
OSPowerFindPowerInfo(
    PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    Return the Power Information (which contains the device state and the
    device dependencies)

Arguments:

    AcpiObject  - The NameSpace object that we want to know about

Return Value:

    PACPI_POWER_INFO

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension;

    ASSERT( AcpiObject != NULL);

    //
    // Grab the spinlock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Check for the case that there is no device object associated with
    // this AcpiObject - can happen if there is no HID associated with
    // the device in the AML.
    //
    deviceExtension = AcpiObject->Context;
    if (deviceExtension) {

        ASSERT( deviceExtension->Signature == ACPI_SIGNATURE );
	KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
        return &(deviceExtension->PowerInfo);

    }
    
    //
    // Done with the spinlock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
    return NULL;
}

PACPI_POWER_INFO
OSPowerFindPowerInfoByContext(
    PVOID   Context
    )
/*++

Routine Description:

    Return the Power Information (which contains the device state and the
    device dependencies)

    The difference between this function and the previous is that it searches
    the list based on the context pointer. On NT, this is a NOP since the
    context pointer is actually an NT device object, and we store the structure
    within the device extension. But this isn't the same for Win9x <sigh>

Arguments:

    Context - Actually is a DeviceObject

Return Value:

    PACPI_POWER_INFO

--*/
{
    PDEVICE_OBJECT      deviceObject = (PDEVICE_OBJECT) Context;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) Context;

    ASSERT( Context != NULL );


    //
    // Get the real extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( deviceObject );
    ASSERT( deviceExtension->Signature == ACPI_SIGNATURE );

    //
    // We store the Power info in the device extension
    //
    return &(deviceExtension->PowerInfo);
}

PACPI_POWER_DEVICE_NODE
OSPowerFindPowerNode(
    PNSOBJ  PowerObject
    )
/*++

Routine Description:

    Return the Power Device Node (which contains the current state of the
    power resource, the power resource, and the use counts)

Arguments:

    PowerObject  - The NameSpace object that we want to know about

Return Value:

    PACPI_POWER_DEVICE_NODE

--*/
{
    KIRQL                   oldIrql;
    PACPI_POWER_DEVICE_NODE powerNode = NULL;

    //
    // Before we touch the power list, we need to have a spinlock
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // Boundary check
    //
    if (AcpiPowerNodeList.Flink == &AcpiPowerNodeList) {

        //
        // At end
        //
        goto OSPowerFindPowerNodeExit;

    }

    //
    // Start from the first node and check to see if they match the
    // required NameSpace object
    //
    powerNode = (PACPI_POWER_DEVICE_NODE) AcpiPowerNodeList.Flink;
    while (powerNode != (PACPI_POWER_DEVICE_NODE) &AcpiPowerNodeList) {

        //
        // Check to see if the node that we are looking at matches the
        // name space object in question
        //
        if (powerNode->PowerObject == PowerObject) {

            //
            // Match
            //
            goto OSPowerFindPowerNodeExit;

        }

        //
        // Next object
        //
        powerNode = (PACPI_POWER_DEVICE_NODE) powerNode->ListEntry.Flink;

    }

    //
    // No match
    //
    powerNode = NULL;

OSPowerFindPowerNodeExit:
    //
    // No longer need the spin lock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Return the node we found
    //
    return powerNode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\processor.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    processor.c

Abstract:

    Processor support

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    Adapted for processors from buttons - JakeO (3-28-2000)

--*/

#include "pch.h"
#include "..\shared\acpictl.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIButtonStartDevice)
#endif

//
// Spinlock to protect the processor list
//
KSPIN_LOCK  AcpiProcessorLock;

//
// List entry to store the thermal requests on
//
LIST_ENTRY  AcpiProcessorList;


VOID
ACPIProcessorCancelRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine cancels an outstanding processor request

Arguments:

    DeviceObject    - the device which as a request being cancelled
    Irp             - the cancelling irp

Return Value:

    None

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    //
    // We no longer need the cancel lock
    //
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    // We do however need the processor queue lock
    //
    KeAcquireSpinLock( &AcpiProcessorLock, &oldIrql );

    //
    // Remove the irp from the list that it is on
    //
    RemoveEntryList( &(Irp->Tail.Overlay.ListEntry) );

    //
    // Complete the irp now
    //
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
}

BOOLEAN
ACPIProcessorCompletePendingIrps(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  ULONG           ProcessorEvent
    )
/*++

Routine Description:

    This routine completes any pending processor irp sent to the specified
    device object with the knowledge of which processor events have occured

    The respective's processor's spinlock is held during this call

Arguments:

    DeviceObject    - the target processor object
    ProcessorEvent     - the processor event that occured

Return Value:

    TRUE if we completed an irp, FALSE, otherwise

--*/
{
    BOOLEAN             handledRequest = FALSE;
    KIRQL               oldIrql;
    LIST_ENTRY          doneList;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpSp;
    PIRP                irp;
    PLIST_ENTRY         listEntry;
    PULONG              resultBuffer;

    //
    // Initialize the list that will hold the requests that we need to
    // complete
    //
    InitializeListHead( &doneList );

    //
    // Acquire the thermal lock so that we can pend these requests
    //
    KeAcquireSpinLock( &AcpiProcessorLock, &oldIrql );

    //
    // Walk the list of pending irps to see which ones match this extension
    //
    listEntry = AcpiProcessorList.Flink;
    while (listEntry != &AcpiProcessorList) {

        //
        // Grab the irp from the list entry and update the next list entry
        // that we will look at
        //
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        listEntry = listEntry->Flink;

        //
        // We need the current irp stack location
        //
        irpSp = IoGetCurrentIrpStackLocation( irp );

        //
        // what is the target object for this irp?
        //
        targetObject = irpSp->DeviceObject;

        //
        // Is this an irp that we care about? IE: does the does target mage
        // the ones specified in this function
        //
        if (targetObject != DeviceObject) {

            continue;

        }

        //
        // At this point, we need to set the cancel routine to NULL because
        // we are going to take care of this irp and we don't want it cancelled
        // underneath us
        //
        if (IoSetCancelRoutine(irp, NULL) == NULL) {

            //
            // Cancel routine is active. stop processing this irp and move on
            //
            continue;

        }

        //
        // set the data to return in the irp
        //
        resultBuffer  = (PULONG) irp->AssociatedIrp.SystemBuffer;
        *resultBuffer = ProcessorEvent;
        irp->IoStatus.Status = STATUS_SUCCESS;
        irp->IoStatus.Information = sizeof(ULONG);

        //
        // Remove the entry from the list
        //
        RemoveEntryList( &(irp->Tail.Overlay.ListEntry) );

        //
        // Insert the list onto the next queue, so that we know how to
        // complete it later on
        //
        InsertTailList( &doneList, &(irp->Tail.Overlay.ListEntry) );

    }

    //
    // At this point, droup our processor lock
    //
    KeReleaseSpinLock( &AcpiProcessorLock, oldIrql );

    //
    // Walk the list of irps to be completed
    //
    listEntry = doneList.Flink;
    while (listEntry != &doneList) {

        //
        // Grab the irp from the list entry, update the next list entry
        // that we will look at, and complete the request
        //
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        listEntry = listEntry->Flink;
        RemoveEntryList( &(irp->Tail.Overlay.ListEntry) );

        //
        // Complete the request and remember that we handled a request
        //
        IoCompleteRequest( irp, IO_NO_INCREMENT );
        handledRequest = TRUE;


    }

    //
    // Return wether or not we handled a request
    //
    return handledRequest;
}

NTSTATUS
ACPIProcessorDeviceControl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    Fixed processor device IOCTL handler

Arguments:

    DeviceObject    - fixed feature processor device object
    Irp             - the ioctl request

Return Value:

    Status

--*/
{
    KIRQL                   oldIrql;
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION      irpSp           = IoGetCurrentIrpStackLocation(Irp);
    PULONG                  resultBuffer;
    OBJDATA                 data;

    //
    // Do not allow user mode IRPs in this routine
    //
    if (Irp->RequestorMode != KernelMode) {

        return ACPIDispatchIrpInvalid( DeviceObject, Irp );

    }

    resultBuffer = (PULONG) Irp->AssociatedIrp.SystemBuffer;

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_GET_PROCESSOR_OBJ_INFO:

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < 
            sizeof(IOCTL_GET_PROCESSOR_OBJ_INFO)) {

            Irp->IoStatus.Status = status = STATUS_INFO_LENGTH_MISMATCH;
            Irp->IoStatus.Information = 0;
        
        } else {

            status = AMLIEvalNameSpaceObject(deviceExtension->AcpiObject,
                                             &data,
                                             0,
                                             NULL);

            if (NT_SUCCESS(status)) {
                
                ASSERT (data.dwDataType == OBJTYPE_PROCESSOR);
                ASSERT (data.pbDataBuff != NULL);

                (*(PPROCESSOR_OBJECT_INFO)resultBuffer).PhysicalID = 
                    ((PROCESSOROBJ *)data.pbDataBuff)->bApicID;

                (*(PPROCESSOR_OBJECT_INFO)resultBuffer).PBlkAddress = 
                    ((PROCESSOROBJ *)data.pbDataBuff)->dwPBlk;

                (*(PPROCESSOR_OBJECT_INFO)resultBuffer).PBlkLength = 
                    (UCHAR)((PROCESSOROBJ *)data.pbDataBuff)->dwPBlkLen;
                
                AMLIFreeDataBuffs(&data, 1);

                status = STATUS_SUCCESS;
                Irp->IoStatus.Information = sizeof(PROCESSOR_OBJECT_INFO);
            
            }
            
            Irp->IoStatus.Status = status;
        }

        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;

    case IOCTL_ACPI_ASYNC_EVAL_METHOD:

        //
        // Handle this elsewhere
        //
        status = ACPIIoctlAsyncEvalControlMethod(
            DeviceObject,
            Irp,
            irpSp
            );
        break;

    case IOCTL_ACPI_EVAL_METHOD:

        //
        // Handle this elsewhere
        //
        status = ACPIIoctlEvalControlMethod(
            DeviceObject,
            Irp,
            irpSp
            );
        break;

    default:

        status = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;
    }
    
    return status;
}

NTSTATUS
ACPIProcessorStartDevice (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    Start device function for the fixed feature power and sleep device

Arguments:

    DeviceObject    - fixed feature processor device object
    Irp             - the start request

Return Value:

    Status

--*/
{
    NTSTATUS        Status;

    Status = ACPIInternalSetDeviceInterface (
        DeviceObject,
        (LPGUID) &GUID_DEVICE_PROCESSOR
        );

    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\pciinterface.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pciopregion.c

Abstract:

    This module implements PCI_BUS_INTERFACE_STANDARD,
    which allows the PCI driver to get utility functions
    from its parent.

Author:

    Jake Oshins (jakeo)     11-14-97

Environment:

    NT Kernel Model Driver only

--*/
#include "pch.h"

VOID
PciInterfacePinToLine(
    IN PVOID Context,
    IN PPCI_COMMON_CONFIG PciData
    );

VOID
PciInterfaceLineToPin(
    IN PVOID Context,
    IN PPCI_COMMON_CONFIG PciNewData,
    IN PPCI_COMMON_CONFIG PciOldData
    );

ULONG
PciInterfaceReadConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
PciInterfaceWriteConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciInterfacePinToLine)
#pragma alloc_text(PAGE, PciInterfaceLineToPin)
#pragma alloc_text(PAGE, PciBusEjectInterface)
#endif

NTSTATUS
PciBusEjectInterface(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
{
    PIO_RESOURCE_REQUIREMENTS_LIST  ioList = NULL;
    PPCI_BUS_INTERFACE_STANDARD     pciInterface;
    PIO_STACK_LOCATION              irpSp;
    PDEVICE_EXTENSION               devExtension;
    NTSTATUS                        status;
    BOOLEAN                         foundBusNumber = FALSE;
    OBJDATA                         crsData;
    ULONG                           i, busNumber;


    PAGED_CODE();

    ASSERT(HalPciInterfaceReadConfig);
    ASSERT(HalPciInterfaceWriteConfig);

    devExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    ASSERT(devExtension);
    ASSERT(devExtension->AcpiObject);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(irpSp->Parameters.QueryInterface.Size >=
             sizeof(PCI_BUS_INTERFACE_STANDARD));

    pciInterface = (PPCI_BUS_INTERFACE_STANDARD)irpSp->Parameters.QueryInterface.Interface;

    ASSERT(pciInterface);

    status = ACPIGetDataSync(devExtension, PACKED_CRS, &crsData);

    if (NT_SUCCESS(status)) {

        ASSERT(crsData.dwDataType == OBJTYPE_BUFFDATA);

        //
        // Turn it into something meaningful.
        //
        status = PnpBiosResourcesToNtResources(
            crsData.pbDataBuff,
            PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES,
            &ioList
            );

        if (NT_SUCCESS(status)) {

            //
            // A _CRS shouldn't have choices.
            //
            ASSERT(ioList->AlternativeLists == 1);

            //
            // Look for the Bus Number resource.
            //
            for (i = 0; i < ioList->List[0].Count; i++) {

                if (ioList->List[0].Descriptors[i].Type == CmResourceTypeBusNumber) {
                    break;
                }
            }

            if (i != ioList->List[0].Count) {

                busNumber = (ULONG)ioList->List[0].Descriptors[i].u.BusNumber.MinBusNumber;
                foundBusNumber = TRUE;
            }

        }

        AMLIFreeDataBuffs(&crsData, 1);

    }

    if (!foundBusNumber) {

        //
        // Punt.  Assume this is for PCI bus 0.
        //

        busNumber = 0;
    }

    pciInterface->Size = sizeof(PCI_BUS_INTERFACE_STANDARD);
    pciInterface->Version = 1;
    pciInterface->Context = (PVOID)UlongToPtr(busNumber);
    pciInterface->InterfaceReference = AcpiNullReference;
    pciInterface->InterfaceDereference = AcpiNullReference;
    pciInterface->ReadConfig = HalPciInterfaceReadConfig;
    pciInterface->WriteConfig = HalPciInterfaceWriteConfig;
    pciInterface->PinToLine = PciInterfacePinToLine;
    pciInterface->LineToPin = PciInterfaceLineToPin;

    status = STATUS_SUCCESS;

    if (ioList) {
        ExFreePool(ioList);
    }

    Irp->IoStatus.Status = status;

    return status;
}

VOID
PciInterfacePinToLine(
    IN PVOID Context,
    IN PPCI_COMMON_CONFIG PciData
    )
{
    return;
}

VOID
PciInterfaceLineToPin(
    IN PVOID Context,
    IN PPCI_COMMON_CONFIG PciNewData,
    IN PPCI_COMMON_CONFIG PciOldData
    )
{
    return;
}

VOID
AcpiNullReference(
    PVOID Context
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\pciopregion.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pciopregion.c

Abstract:

    This module implements PCI Operational Region
    support, which allows AML code to read and
    write PCI configuration space.

Author:

    Jake Oshins (jakeo)     7-14-97

Environment:

    NT Kernel Model Driver only

--*/
#include "pch.h"

NTSTATUS
AcpiRegisterPciRegionSupport(
    PDEVICE_OBJECT  PciDeviceFilter
    );

NTSTATUS
GetPciAddress(
    IN      PNSOBJ              PciObj,
    IN      PFNACB              CompletionRoutine,
    IN      PVOID               Context,
    IN OUT  PUCHAR              Bus,
    IN OUT  PPCI_SLOT_NUMBER    Slot
    );

NTSTATUS
EXPORT
GetPciAddressWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

NTSTATUS
GetOpRegionScope(
    IN  PNSOBJ  OpRegion,
    IN  PFNACB  CompletionHandler,
    IN  PVOID   CompletionContext,
    OUT PNSOBJ  *PciObj
    );

NTSTATUS
EXPORT
GetOpRegionScopeWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

UCHAR
GetBusNumberFromCRS(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PUCHAR              CRS
    );

#define MAX(a, b)       \
    ((a) > (b) ? (a) : (b))

#define MIN(a, b)       \
    ((a) < (b) ? (a) : (b))

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AcpiRegisterPciRegionSupport)
#pragma alloc_text(PAGE, ACPIInitBusInterfaces)
#pragma alloc_text(PAGE, ACPIDeleteFilterInterfaceReferences)
#pragma alloc_text(PAGE, IsPciBus)
#pragma alloc_text(PAGE, IsNsobjPciBus)
#pragma alloc_text(PAGE, EnableDisableRegions)
#endif


VOID
ACPIInitBusInterfaces(
    PDEVICE_OBJECT  Filter
    )
/*++

Routine Description:

    This routine determines whether this filter is for a PCI
    device.  If it is, then we call AcpiRegisterPciRegionSupport.

Arguments:

    Filter - device object for the filter we are looking at

Return Value:

    Status

Notes:

--*/
{
    PDEVICE_EXTENSION   filterExt = Filter->DeviceExtension;
    PDEVICE_EXTENSION   parentExt;
    NTSTATUS            status;

    PAGED_CODE();

    parentExt = filterExt->ParentExtension;

    if (!IsPciBus(parentExt->DeviceObject)) {
        return;
    }

    AcpiRegisterPciRegionSupport(Filter);
}

VOID
ACPIDeleteFilterInterfaceReferences(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine is called for all filters when they are removed to see if
    we need to free some interfaces

Arguments:

    DeviceExtension - The device whose extension we have to dereference

Return Value:

    NTSTATUS

--*/
{
    AMLISUPP_CONTEXT_PASSIVE    isPciDeviceContext;
    BOOLEAN                     pciDevice;
    NTSTATUS                    status;

    PAGED_CODE();

    if ( (DeviceExtension->Flags & DEV_PROP_NO_OBJECT) ) {

        return;

    }

    KeInitializeEvent(&isPciDeviceContext.Event, SynchronizationEvent, FALSE);
    isPciDeviceContext.Status = STATUS_NOT_FOUND;
    status = IsPciDevice(
        DeviceExtension->AcpiObject,
        AmlisuppCompletePassive,
        (PVOID)&isPciDeviceContext,
        &pciDevice);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &isPciDeviceContext.Event,
            Executive,
            KernelMode,
            FALSE,
            NULL);
        status = isPciDeviceContext.Status;

    }
    if (!NT_SUCCESS(status) || !pciDevice) {

        return;
    }

    //
    // This is a PCI device, so we need to relinquish
    // the interfaces that we got from the PCI driver.
    //
    if (!DeviceExtension->Filter.Interface) {

        //
        // There were no interfaces to release.
        //
        return;

    }

    //
    // Dereference it.
    //
    DeviceExtension->Filter.Interface->InterfaceDereference(
        DeviceExtension->Filter.Interface->Context
        );
    ExFreePool(DeviceExtension->Filter.Interface);
    DeviceExtension->Filter.Interface = NULL;
}

NTSTATUS
AcpiRegisterPciRegionSupport(
    PDEVICE_OBJECT  PciDeviceFilter
    )
/*++

Routine Description:

    This routine queries the PCI driver for read and write functions
    for PCI config space.  It then attaches these interfaces to the
    device extension for this filter.  Then, if it hasn't been done
    already, it registers PCI Operational Region support with the
    AML interpretter.

Arguments:

    PciDeviceFilter - A filter for a PCI device

Return Value:

    Status

Notes:

--*/
{
    PBUS_INTERFACE_STANDARD interface;
    PCI_COMMON_CONFIG   pciData;
    NTSTATUS            status;
    IO_STACK_LOCATION   irpSp;
    PWSTR               buffer;
    PDEVICE_EXTENSION   pciFilterExt;
    PDEVICE_OBJECT      topDeviceInStack;
    ULONG               bytes;

    PAGED_CODE();

    RtlZeroMemory( &irpSp, sizeof(IO_STACK_LOCATION) );

    //
    // If we have already registered a handler for this
    // device, then we don't need to do it again.
    //

    pciFilterExt = PciDeviceFilter->DeviceExtension;

    if (pciFilterExt->Filter.Interface) {
        return STATUS_SUCCESS;
    }

    interface = ExAllocatePoolWithTag(NonPagedPool, sizeof(BUS_INTERFACE_STANDARD), ACPI_INTERFACE_POOLTAG);

    if (!interface) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    topDeviceInStack = IoGetAttachedDeviceReference(pciFilterExt->TargetDeviceObject);

    //
    // Set the function codes and parameters.
    //
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_BUS_INTERFACE_STANDARD;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.Size = sizeof (BUS_INTERFACE_STANDARD);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) interface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Call the PCI driver.
    //
    status = ACPIInternalSendSynchronousIrp(topDeviceInStack,
                                            &irpSp,
                                            &buffer);
    if (NT_SUCCESS(status)) {

        //
        // Attach this interface to the PCI bus PDO.
        //

        pciFilterExt->Filter.Interface = interface;

        //
        // Reference it.
        //

        pciFilterExt->Filter.Interface->InterfaceReference(pciFilterExt->Filter.Interface->Context);

        //
        // HACKHACK.  The ACPI HAL doesn't really know much about busses.  But
        // it needs to maintain legacy HAL behavior.  And to do that, it needs to
        // know how many PCI busses are in the system.  Since we are now looking
        // at a PCI bus that we are filtering, we now give the HAL a heads-up that
        // this bus exists.
        //

        bytes = interface->GetBusData(interface->Context,
                                      0,
                                      &pciData,
                                      0,
                                      PCI_COMMON_HDR_LENGTH);

        ASSERT(bytes != 0);

        if ((PCI_CONFIGURATION_TYPE((&pciData)) == PCI_BRIDGE_TYPE) ||
            (PCI_CONFIGURATION_TYPE((&pciData)) == PCI_CARDBUS_BRIDGE_TYPE)) {

            //
            // This is actually a PCI to PCI bridge.
            //

            if (pciData.u.type1.SecondaryBus != 0) {

                //
                // And it has a bus number.  So notify the HAL.
                //

                HalSetMaxLegacyPciBusNumber(pciData.u.type1.SecondaryBus);
            }
        }

    } else {

        ExFreePool(interface);
    }

    ObDereferenceObject(topDeviceInStack);

    return status;
}

typedef struct {
    //
    // Arguments to PciConfigSpaceHandler
    //
    ULONG   AccessType;
    PNSOBJ  OpRegion;
    ULONG   Address;
    ULONG   Size;
    PULONG  Data;
    ULONG   Context;
    PVOID   CompletionHandler;
    PVOID   CompletionContext;

    //
    // Function state
    //
    PNSOBJ          PciObj;
    PNSOBJ          ParentObj;
    ULONG           CompletionHandlerType;
    ULONG           Flags;
    LONG            RunCompletion;
    PCI_SLOT_NUMBER Slot;
    UCHAR           Bus;
    BOOLEAN         IsPciDeviceResult;
} PCI_CONFIG_STATE, *PPCI_CONFIG_STATE;

NTSTATUS
EXPORT
PciConfigSpaceHandler (
    ULONG                   AccessType,
    PNSOBJ                  OpRegion,
    ULONG                   Address,
    ULONG                   Size,
    PULONG                  Data,
    ULONG                   Context,
    PFNAA                   CompletionHandler,
    PVOID                   CompletionContext
    )
/*++

Routine Description:

    This routine handles requests to service the PCI operation region

Arguments:

    AccessType          - Read or Write data
    OpRegion            - Operation region object
    Address             - Address within PCI Configuration space
    Size                - Number of bytes to transfer
    Data                - Data buffer to transfer to/from
    Context             - unused
    CompletionHandler   - AMLI handler to call when operation is complete
    CompletionContext   - Context to pass to the AMLI handler

Return Value:

    Status

Notes:

--*/
{
    PPCI_CONFIG_STATE   state;

    state = ExAllocatePoolWithTag(NonPagedPool, sizeof(PCI_CONFIG_STATE), ACPI_INTERFACE_POOLTAG);

    if (!state) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(state, sizeof(PCI_CONFIG_STATE));

    state->AccessType           = AccessType;
    state->OpRegion             = OpRegion;
    state->Address              = Address;
    state->Size                 = Size;
    state->Data                 = Data;
    state->Context              = Context;
    state->CompletionHandler    = CompletionHandler;
    state->CompletionContext    = CompletionContext;
    state->PciObj               = OpRegion->pnsParent;
    state->RunCompletion        = INITIAL_RUN_COMPLETION;

    return PciConfigSpaceHandlerWorker(state->PciObj,
                                       STATUS_SUCCESS,
                                       NULL,
                                       (PVOID)state);
}

typedef struct {
    PCI_CONFIG_STATE    HandlerState;
    NSOBJ               FakeOpRegion;
} PCI_INTERNAL_STATE, *PPCI_INTERNAL_STATE;

NTSTATUS
PciConfigInternal(
    IN      ULONG   AccessType,
    IN      PNSOBJ  PciObject,
    IN      ULONG   Offset,
    IN      ULONG   Length,
    IN      PFNACB  CompletionHandler,
    IN      PVOID   CompletionContext,
    IN OUT  PUCHAR  Data
    )
/*++

Routine Description:

    This routine does PCI configuration space reads or writes.
    It does the same thing as PciConfigSpaceHandler, except
    that it takes an arbitrary PNSOBJ instead of an OpRegion.

Arguments:

    AccessType          - Read or Write data
    PciObject           - name space object for the PCI device
    Offset              - Address within PCI Configuration space
    Length              - Number of bytes to transfer
    Context             - unused
    CompletionHandler   - AMLI handler to call when operation is complete
    CompletionContext   - Context to pass to the AMLI handler
    Data                - Data buffer to transfer to/from

Return Value:

    Status

Notes:

(1) This function is intended to be used only internally.  It does
    not check to see if the PNSOBJ actually represents a PCI device.

(2) This function will not allow writes to the first 0x40 bytes of
    any device's PCI configuration space.  This is the common area
    and it is owned by the PCI driver.

--*/
{
    PPCI_INTERNAL_STATE internal;
    PPCI_CONFIG_STATE   state;
    PNSOBJ              opRegion;

    internal = ExAllocatePoolWithTag(NonPagedPool, sizeof(PCI_INTERNAL_STATE), ACPI_INTERFACE_POOLTAG);

    if (!internal) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(internal, sizeof(PCI_INTERNAL_STATE));

    internal->FakeOpRegion.Context = PciObject;

    state = (PPCI_CONFIG_STATE)internal;

    state->AccessType           = AccessType;
    state->OpRegion             = &internal->FakeOpRegion;
    state->Address              = Offset;
    state->Size                 = Length;
    state->Data                 = (PULONG)Data;
    state->Context              = 0;
    state->CompletionHandler    = CompletionHandler;
    state->CompletionContext    = CompletionContext;
    state->PciObj               = PciObject;
    state->CompletionHandlerType = PCISUPP_COMPLETION_HANDLER_PFNACB;
    state->RunCompletion        = INITIAL_RUN_COMPLETION;

    return PciConfigSpaceHandlerWorker(PciObject,
                                       STATUS_SUCCESS,
                                       NULL,
                                       (PVOID)state);
}

//
// This structure defines ranges in PCI configuration
// space that AML may not write.  This list must be
// monotonic increasing.
//
USHORT PciOpRegionDisallowedRanges[4][2] =
{   //
    // Everything below the subsystem ID registers
    //
    {0,0x2b},

    //
    // Everthing between the subsystem ID registers and
    // the Max_Lat register
    //
    {0x30, 0x3b},

    //
    // Disallow anything above MAXUCHAR
    //
    {0x100, 0xffff},

    // End tag.
    {0,0}
};

NTSTATUS
EXPORT
PciConfigSpaceHandlerWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             CompletionStatus,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
{
    PBUS_INTERFACE_STANDARD interface;
    PDEVICE_EXTENSION       pciDeviceFilter;
    PPCI_CONFIG_STATE       state;
    NTSTATUS                status;
    ULONG                   range, offset, length, bytes = 0;
    ULONG                   bytesWritten;
    PFNAA                   simpleCompletion;
    PFNACB                  lessSimpleCompletion;
    KIRQL                   oldIrql;
#if DBG
    BOOLEAN                 Complain = FALSE;
#endif

    state = (PPCI_CONFIG_STATE)Context;
    status = CompletionStatus;

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //

    InterlockedIncrement(&state->RunCompletion);

    //
    // If the interpretter failed, just bail.
    //
    if (!NT_SUCCESS(CompletionStatus)) {
        status = STATUS_SUCCESS;
    #if DBG
        Complain = TRUE;
    #endif
        goto PciConfigSpaceHandlerWorkerDone;
    }

    //
    // If we have not seen this OpRegion before, we need to
    // fill in the dwContext with the PNSOBJ of the
    // PCI device which the OpRegion relates to.
    //

    if (!state->OpRegion->Context) {

        if (!(state->Flags & PCISUPP_GOT_SCOPE)) {

            state->Flags |= PCISUPP_GOT_SCOPE;

            status = GetOpRegionScope(state->OpRegion,
                                      PciConfigSpaceHandlerWorker,
                                      (PVOID)state,
                                      &((PNSOBJ)(state->OpRegion->Context)));

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                status = STATUS_SUCCESS;
                goto PciConfigSpaceHandlerWorkerDone;
            }
        }
    }

    //
    // Identify the PCI device, that device's extension,
    // and the pointer to the interface within the PCI
    // driver that does PCI config space reads and writes.
    //

    state->PciObj = (PNSOBJ)state->OpRegion->Context;

    pciDeviceFilter = (PDEVICE_EXTENSION)state->PciObj->Context;

    if (pciDeviceFilter == NULL) {

        //
        // The device has not been initialized yet, we cannot perform
        // PCI config cycles to it. Fail gracefully and return all 0xFF
        //
        bytes = 0;
        status = STATUS_SUCCESS;
        goto PciConfigSpaceHandlerWorkerDone;
    }

    ASSERT(pciDeviceFilter);

    interface = pciDeviceFilter->Filter.Interface;

    ASSERT(interface ? (interface->Size == sizeof(BUS_INTERFACE_STANDARD)) : TRUE);

    //
    // If interface is non-zero, we have enumerated this PCI
    // device.  So use the PCI driver to do config ops.
    // If it is zero, make some attempt to figure out what
    // device this request is for.  The result will be
    // used in calls to the HAL.
    //

    if (!interface) {

        if (!(state->Flags & PCISUPP_GOT_SLOT_INFO)) {

            state->Flags |= PCISUPP_GOT_SLOT_INFO;

            status = GetPciAddress(state->PciObj,
                                   PciConfigSpaceHandlerWorker,
                                   (PVOID)state,
                                   &state->Bus,
                                   &state->Slot);

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                status = STATUS_SUCCESS;
                goto PciConfigSpaceHandlerWorkerDone;
            }
        }
    }

    status = STATUS_SUCCESS;

    oldIrql = KeGetCurrentIrql();

    switch (state->AccessType) {
    case RSACCESS_READ:

        if (interface) {

            //
            // Do config space op through PCI driver.  Do it
            // at DISPATCH_LEVEL because the PCI driver expects
            // that, if we are running at passive level, it can
            // do things that page.  Which may not be true here
            // after we have powered off the disk.
            //

            if (oldIrql < DISPATCH_LEVEL) {
                KeRaiseIrql(DISPATCH_LEVEL,
                            &oldIrql);
            }

            bytes = interface->GetBusData(interface->Context,
                                          0,
                                          state->Data,
                                          state->Address,
                                          state->Size);

            if (oldIrql < DISPATCH_LEVEL) {
                KeLowerIrql(oldIrql);
            }

        } else {

            //
            // Do config space op through HAL
            //

            bytes = HalGetBusDataByOffset(PCIConfiguration,
                                          state->Bus,
                                          state->Slot.u.AsULONG,
                                          state->Data,
                                          state->Address,
                                          state->Size);

        }

        break;

    case RSACCESS_WRITE:
        {
            static BOOLEAN ErrorLogged = FALSE;

            offset = state->Address;
            length = state->Size;
            bytesWritten = 0;

            //
            // Crop any writes down to the regions that are allowed.
            //

            range = 0;

            while (PciOpRegionDisallowedRanges[range][1] != 0) {

                if (offset < PciOpRegionDisallowedRanges[range][0]) {

                    //
                    // At least part of this write falls below this
                    // disallowed range.  Write all the data up to
                    // the beggining of the next allowed range.
                    //

                    length = MIN(state->Address + state->Size - offset,
                                 PciOpRegionDisallowedRanges[range][0] - offset);

                    if (interface) {

                        if (oldIrql < DISPATCH_LEVEL) {
                            KeRaiseIrql(DISPATCH_LEVEL,
                                        &oldIrql);
                        }

                        bytes = interface->SetBusData(interface->Context,
                                                      0,
                                                      (PUCHAR)(state->Data + offset - state->Address),
                                                      offset,
                                                      length);

                        if (oldIrql < DISPATCH_LEVEL) {
                            KeLowerIrql(oldIrql);
                        }

                    } else {

                        bytes = HalSetBusDataByOffset(PCIConfiguration,
                                                      state->Bus,
                                                      state->Slot.u.AsULONG,
                                                      (PUCHAR)(state->Data + offset - state->Address),
                                                      offset,
                                                      length);
                    }

                    //
                    // Keep track of what we wrote.
                    //

                    bytesWritten += length;
                }

                //
                // Now advance offset past the end of the disallowed range.
                //

                offset = MAX(state->Address,
                             (ULONG)(PciOpRegionDisallowedRanges[range][1] + 1));

                if (offset >= state->Address + state->Size) {

                    //
                    // The current possible write is beyond the end
                    // of the requested buffer.  So we are done.
                    //

                    break;
                }

                range++;
            }

            if (bytesWritten == 0) {

                if(!ErrorLogged) {
                    PWCHAR IllegalPCIOpRegionAddress[2];
                    WCHAR ACPIName[] = L"ACPI";
                    WCHAR addressBuffer[13];

                    //
                    // None of this write was possible. Log the problem.
                    //

                    //
                    // Turn the address into a string
                    //
                    swprintf( addressBuffer, L"0x%x", state->Address );

                    //
                    // Build the list of arguments to pass to the function that will write the
                    // error log to the registry
                    //
                    IllegalPCIOpRegionAddress[0] = ACPIName;
                    IllegalPCIOpRegionAddress[1] = addressBuffer;

                    //
                    // Log error to event log
                    //
                    ACPIWriteEventLogEntry(ACPI_ERR_ILLEGAL_PCIOPREGION_WRITE,
                                           &IllegalPCIOpRegionAddress,
                                           2,
                                           NULL,
                                           0
                                          );
                    ErrorLogged = TRUE;
                }
            #if DBG
                Complain = TRUE;
            #endif
               goto PciConfigSpaceHandlerWorkerExit;
            }

            bytes = bytesWritten;
            break;
        }
    default:
        status = STATUS_NOT_IMPLEMENTED;
    }

PciConfigSpaceHandlerWorkerDone:

    if (bytes == 0) {

        //
        // The handler from the HAL or the PCI driver didn't
        // succeed for some reason.  Fill the buffer with 0xff,
        // which is what the AML will expect on failure.
        //

        RtlFillMemory(state->Data, state->Size, 0xff);
    }

PciConfigSpaceHandlerWorkerExit:

    if (state->RunCompletion) {

        if (state->CompletionHandlerType ==
             PCISUPP_COMPLETION_HANDLER_PFNAA) {

            simpleCompletion = (PFNAA)state->CompletionHandler;

            simpleCompletion(state->CompletionContext);

        } else {

            lessSimpleCompletion = (PFNACB)state->CompletionHandler;

            lessSimpleCompletion(state->PciObj,
                                 status,
                                 NULL,
                                 state->CompletionContext);
        }
    }

#if DBG
    if ((!NT_SUCCESS(status)) || Complain) {
        UCHAR   opRegion[5] = {0};
        UCHAR   parent[5] = {0};

        RtlCopyMemory(opRegion, ACPIAmliNameObject(state->OpRegion), 4);

        if (state->PciObj) {
            RtlCopyMemory(parent, ACPIAmliNameObject(state->PciObj), 4);
        }

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "Op Region %s failed (parent PCI device was %s)\n",
            opRegion, parent
            ) );
    }
#endif
    ExFreePool(state);
    return status;
}

typedef struct {
    PNSOBJ              PciObject;
    PUCHAR              Bus;
    PPCI_SLOT_NUMBER    Slot;

    UCHAR               ParentBus;
    PCI_SLOT_NUMBER     ParentSlot;
    ULONG               Flags;
    ULONG               Address;
    ULONG               BaseBusNumber;
    LONG                RunCompletion;
    PFNACB              CompletionRoutine;
    PVOID               CompletionContext;

} GET_ADDRESS_CONTEXT, *PGET_ADDRESS_CONTEXT;

NTSTATUS
GetPciAddress(
    IN      PNSOBJ              PciObj,
    IN      PFNACB              CompletionRoutine,
    IN      PVOID               Context,
    IN OUT  PUCHAR              Bus,
    IN OUT  PPCI_SLOT_NUMBER    Slot
    )
/*++

Routine Description:

    This routine takes a PNSOBJ that represents a PCI device
    and returns the Bus/Slot information for that device.

Arguments:

    PciObj              - PNSOBJ that represents a PCI device
    CompletionRoutine   - funtion to call after a STATUS_PENDING
    Context             - argument to the CompletionRoutine
    Bus                 - pointer to fill in with the bus number
    Slot                - pointer to fill in with the slot information

Return Value:

    Status

Notes:

    N.B.  This is not guaranteed to produce correct results.
          It is intended to be used only when before the PCI
          driver takes control of a device.  It is a best-effort
          function that will almost always work early in the
          boot process.

--*/
{
    PGET_ADDRESS_CONTEXT    state;

    ASSERT(CompletionRoutine);

    state = ExAllocatePoolWithTag(NonPagedPool, sizeof(GET_ADDRESS_CONTEXT), ACPI_INTERFACE_POOLTAG);

    if (!state) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(state, sizeof(GET_ADDRESS_CONTEXT));

    state->PciObject            = PciObj;
    state->CompletionRoutine    = CompletionRoutine;
    state->CompletionContext    = Context;
    state->Bus                  = Bus;
    state->Slot                 = Slot;
    state->RunCompletion        = INITIAL_RUN_COMPLETION;

    return GetPciAddressWorker(PciObj,
                               STATUS_SUCCESS,
                               NULL,
                               (PVOID)state);

}

NTSTATUS
EXPORT
GetPciAddressWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
{
    PIO_RESOURCE_REQUIREMENTS_LIST  resources;
    PGET_ADDRESS_CONTEXT            state;
    PPCI_COMMON_CONFIG              pciConfig;
    NTSTATUS                        status;
    PNSOBJ                          bus;
    PNSOBJ                          tempObj;
    ULONG                           bytesRead, i;
    UCHAR                           buffer[PCI_COMMON_HDR_LENGTH];

    ASSERT(Context);
    state = (PGET_ADDRESS_CONTEXT)Context;
    status = Status;

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //
    InterlockedIncrement(&state->RunCompletion);

    //
    // If Status isn't success, then one of the worker
    // functions we called puked.  Bail.
    //
    if (!NT_SUCCESS(Status)) {
        goto GetPciAddressWorkerExit;

    }

    //
    // First, determine the slot number.
    //
    if (!(state->Flags & PCISUPP_CHECKED_ADR)) {

        //
        // Get the _ADR.
        //
        state->Flags |= PCISUPP_CHECKED_ADR;
        status = ACPIGetNSAddressAsync(
                    state->PciObject,
                    GetPciAddressWorker,
                    (PVOID)state,
                    &(state->Address),
                    NULL
                    );

        if (status == STATUS_PENDING) {
            return status;
        }

        if (!NT_SUCCESS(status)) {
            goto GetPciAddressWorkerExit;
        }
    }

    if (!(state->Flags & PCISUPP_GOT_SLOT_INFO)) {

        //
        // Build a PCI_SLOT_NUMBER out of the integer returned
        // from the interpretter.
        //
        state->Slot->u.bits.FunctionNumber = (state->Address) & 0x7;
        state->Slot->u.bits.DeviceNumber = ( (state->Address) >> 16) & 0x1f;
        state->Flags |= PCISUPP_GOT_SLOT_INFO;

    }

    //
    // Next, get the bus number, if possible.
    //
    *state->Bus = 0;   // default value, in case we have to guess

    //
    // Check first to see if this bus has a _HID.
    //  (It might be a root PCI bridge.)
    //
    bus = state->PciObject;
    tempObj = ACPIAmliGetNamedChild(bus, PACKED_HID);
    if (!tempObj) {

        //
        // This device had no _HID.  So look up
        // to the parent and see if it is a
        // root PCI bridge.
        //
        bus = state->PciObject->pnsParent;
        tempObj = ACPIAmliGetNamedChild(bus, PACKED_HID);

    }

    if (!tempObj) {

        //
        // This PCI device is on a PCI bus that
        // is created by a PCI-PCI bridge.
        //
        if (!(state->Flags & PCISUPP_CHECKED_PARENT)) {

            state->Flags |= PCISUPP_CHECKED_PARENT;
            status = GetPciAddress(
                        bus,
                        GetPciAddressWorker,
                        (PVOID)state,
                        &state->ParentBus,
                        &state->ParentSlot
                        );

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                goto GetPciAddressWorkerExit;
            }
        }

        //
        // Read the config space for this device.
        //
        bytesRead = HalGetBusDataByOffset(PCIConfiguration,
                                          state->ParentBus,
                                          state->ParentSlot.u.AsULONG,
                                          buffer,
                                          0,
                                          PCI_COMMON_HDR_LENGTH);

        if (bytesRead == 0) {
            //
            // Make a guess that the bus number was 0.
            //
            status = STATUS_SUCCESS;
            goto GetPciAddressWorkerExit;
        }

        pciConfig = (PPCI_COMMON_CONFIG)buffer;

        if (pciConfig->HeaderType != PCI_BRIDGE_TYPE) {

            //
            // Make a guess that the bus number was 0.
            //
            status = STATUS_SUCCESS;
            goto GetPciAddressWorkerExit;
        }

        //
        // Success.  Record the actual bus number of
        // the secondary PCI bus and exit.
        //
        *state->Bus = pciConfig->u.type1.SecondaryBus;

        status = STATUS_SUCCESS;
        goto GetPciAddressWorkerExit;

    }

    //
    // Is there a _BBN to run?
    //
    tempObj = ACPIAmliGetNamedChild(bus, PACKED_BBN);
    if (tempObj) {

        //
        // This device must be the child of a root PCI bus.
        //
        if (!(state->Flags & PCISUPP_CHECKED_BBN)) {

            state->Flags |= PCISUPP_CHECKED_BBN;
            status = ACPIGetNSIntegerAsync(
                        bus,
                        PACKED_BBN,
                        GetPciAddressWorker,
                        (PVOID)state,
                        &(state->BaseBusNumber),
                        NULL
                        );

            if (status == STATUS_PENDING) {
                return(status);
            }

            if (!NT_SUCCESS(status)) {
                goto GetPciAddressWorkerExit;
            }
        }

        //
        // At this point, we must have a Boot Bus Number. This is the correct
        // number for this bus
        //
        ASSERT( state->BaseBusNumber <= 0xFF );
        *(state->Bus) = (UCHAR) (state->BaseBusNumber);

        //
        // HACKHACK.  The ACPI HAL doesn't really know much about busses.  But
        // it needs to maintain legacy HAL behavior.  And to do that, it needs to
        // know how many PCI busses are in the system.  Since we just looked at
        // a root PCI bus, we now give the HAL a heads-up that this bus exists.
        //

        HalSetMaxLegacyPciBusNumber(state->BaseBusNumber);

        status = STATUS_SUCCESS;

    } else {

        //
        // There is a no _BBN, so the bus number MUST be Zero
        //
        *(state->Bus) = 0;
        status = STATUS_SUCCESS;

    }

GetPciAddressWorkerExit:

    if (state->RunCompletion) {

        state->CompletionRoutine(AcpiObject,
                                 status,
                                 NULL,
                                 state->CompletionContext);

    }

    ExFreePool(state);
    return status;
}

typedef struct {
    PNSOBJ  AcpiObject;
    ULONG   Flags;
    ULONG   Adr;
    PUCHAR  Hid;
    PUCHAR  Cid;
    BOOLEAN IsPciDeviceResult;
    LONG    RunCompletion;
    PFNACB  CompletionHandler;
    PVOID   CompletionContext;
    BOOLEAN *Result;
} IS_PCI_DEVICE_STATE, *PIS_PCI_DEVICE_STATE;

NTSTATUS
IsPciDevice(
    IN  PNSOBJ  AcpiObject,
    IN  PFNACB  CompletionHandler,
    IN  PVOID   CompletionContext,
    OUT BOOLEAN *Result
    )
/*++

Routine Description:

    This checks to see if the PNSOBJ is a PCI device.

Arguments:

    AcpiObject  - the object to be checked
    Result      - pointer to a boolean for the result

Return Value:

    Status

Notes:

--*/
{
    PIS_PCI_DEVICE_STATE    state;
    NTSTATUS                status;

    state = ExAllocatePoolWithTag(NonPagedPool, sizeof(IS_PCI_DEVICE_STATE), ACPI_INTERFACE_POOLTAG);

    if (!state) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(state, sizeof(IS_PCI_DEVICE_STATE));

    state->AcpiObject        = AcpiObject;
    state->CompletionHandler = CompletionHandler;
    state->CompletionContext = CompletionContext;
    state->Result            = Result;
    state->RunCompletion     = INITIAL_RUN_COMPLETION;

    return IsPciDeviceWorker(AcpiObject,
                             STATUS_SUCCESS,
                             NULL,
                             (PVOID)state);
}

NTSTATUS
EXPORT
IsPciDeviceWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
/*++

Routine Description:

    This is the worker function for determining whether
    or not a namespace object represents a PCI device.
    The algorithm is as follows:

    1)  Does this device have a _HID of PNP0A03?  If
        so, it is a PCI device.

    2)  Does this device have a _CID of PNP0A03?  If
        so, it is a PCI device.

    3)  Does this device have an _ADR?

        a) No, not a PCI device.

        b) Yes, check to see if the parent qualifies
           as a PCI device.  If it does, this must
           also be a PCI device.  If not, then it is not.

Arguments:

    AcpiObject  - the object most recently under scrutiny
    Status      - current status
    Result      - OBJDATA structure necessary for worker functions
    Context     - pointer to the context structure

Return Value:

    Status

Notes:

    This function is re-entrant.  It may block at any time and
    return.  All state is in the Context structure.

--*/
{
    PIS_PCI_DEVICE_STATE    state;
    NTSTATUS                status;
    PNSOBJ                  hidObj;
    PNSOBJ                  cidObj;

    state = (PIS_PCI_DEVICE_STATE)Context;
    status = Status;

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //
    InterlockedIncrement(&state->RunCompletion);

    //
    // If Status isn't success, then one of the worker
    // functions we called puked.  Bail.
    //
    if (!NT_SUCCESS(status)) {
        *state->Result = FALSE;
        goto IsPciDeviceExit;
    }

    //
    // Step 0), check to see if this is actually a "device" type
    // namespace object.
    //

    if (NSGETOBJTYPE(state->AcpiObject) != OBJTYPE_DEVICE) {
        *state->Result = FALSE;
        goto IsPciDeviceExit;
    }

    //
    // Step 1), check the _HID.
    //

    if (!(state->Flags & PCISUPP_CHECKED_HID)) {

        state->Flags |= PCISUPP_CHECKED_HID;
        state->Hid = NULL;

        hidObj = ACPIAmliGetNamedChild( state->AcpiObject, PACKED_HID );

        if (hidObj) {

            status = ACPIGetNSPnpIDAsync(
                        state->AcpiObject,
                        IsPciDeviceWorker,
                        (PVOID)state,
                        &state->Hid,
                        NULL);

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                *state->Result = FALSE;
                goto IsPciDeviceExit;
            }
        }
    }

    if (state->Hid) {

        if (strstr(state->Hid, PCI_PNP_ID)) {
            //
            // Was PCI.
            //
            *state->Result = TRUE;
            goto IsPciDeviceExit;
        }
        ExFreePool(state->Hid);
        state->Hid = NULL;
    }

    //
    // Step 2), check the _CID.
    //

    if (!(state->Flags & PCISUPP_CHECKED_CID)) {

        state->Flags |= PCISUPP_CHECKED_CID;
        state->Cid = NULL;

        cidObj = ACPIAmliGetNamedChild( state->AcpiObject, PACKED_CID );

        if (cidObj) {

            status = ACPIGetNSCompatibleIDAsync(
                state->AcpiObject,
                IsPciDeviceWorker,
                (PVOID)state,
                &state->Cid,
                NULL);

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                *state->Result = FALSE;
                goto IsPciDeviceExit;
            }
        }
    }

    if (state->Cid) {

        if (strstr(state->Cid, PCI_PNP_ID)) {
            //
            // Was PCI.
            //
            *state->Result = TRUE;
            goto IsPciDeviceExit;
        }
        ExFreePool(state->Cid);
        state->Cid = NULL;
    }

    //
    // Step 3), check the _ADR.
    //

    if (!(state->Flags & PCISUPP_CHECKED_ADR)) {

        state->Flags |= PCISUPP_CHECKED_ADR;
        status = ACPIGetNSAddressAsync(
                    state->AcpiObject,
                    IsPciDeviceWorker,
                    (PVOID)state,
                    &(state->Adr),
                    NULL);

        if (status == STATUS_PENDING) {
            return status;
        }

        if (!NT_SUCCESS(status)) {
            *state->Result = FALSE;
            goto IsPciDeviceExit;
        }
    }

    //
    // If we got here, it has an _ADR.  Check to see if the
    // parent device is a PCI device.
    //

    if (!(state->Flags & PCISUPP_CHECKED_PARENT)) {

        state->Flags |= PCISUPP_CHECKED_PARENT;
        state->IsPciDeviceResult = FALSE;
        status = IsPciDevice(state->AcpiObject->pnsParent,
                             IsPciDeviceWorker,
                             (PVOID)state,
                             &state->IsPciDeviceResult);

        if (status == STATUS_PENDING) {
            return status;
        }

        if (!NT_SUCCESS(status)) {
            *state->Result = FALSE;
            goto IsPciDeviceExit;
        }
    }

    //
    // Fall through to the result.  If the parent was a PCI
    // device, IsPciDeviceResult will now be TRUE.
    //

IsPciDeviceExit:

    if (state->IsPciDeviceResult) {

        //
        // Record the result.
        //

        *state->Result = state->IsPciDeviceResult;
    }

    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
        status = STATUS_SUCCESS;
    }

    if (state->RunCompletion) {

        state->CompletionHandler(state->AcpiObject,
                                 status,
                                 NULL,
                                 state->CompletionContext);
    }

    if (state->Hid) ExFreePool(state->Hid);
    if (state->Cid) ExFreePool(state->Cid);
    ExFreePool(state);
    return status;
}

typedef struct {
    PNSOBJ  AcpiObject;
    ULONG   Flags;
    PUCHAR  Hid;
    PUCHAR  Cid;
    ULONG   Adr;
    BOOLEAN IsPciDevice;
    LONG    RunCompletion;
    PFNACB  CompletionHandler;
    PVOID   CompletionContext;
    BOOLEAN *Result;
    UCHAR   Buffer[PCI_COMMON_HDR_LENGTH];

} IS_PCI_BUS_STATE, *PIS_PCI_BUS_STATE;

NTSTATUS
IsPciBusAsync(
    IN  PNSOBJ  AcpiObject,
    IN  PFNACB  CompletionHandler,
    IN  PVOID   CompletionContext,
    OUT BOOLEAN *Result
    )
/*++

Routine Description:

    This checks to see if the PNSOBJ represents a PCI bus.

Arguments:

    AcpiObject  - the object to be checked
    Result      - pointer to a boolean for the result

Return Value:

    Status

Notes:

    The PNSOBJ may also be a PCI device, in which case
    it is a PCI to PCI bridge.

--*/
{
    PIS_PCI_BUS_STATE   state;

    state = ExAllocatePoolWithTag(NonPagedPool, sizeof(IS_PCI_BUS_STATE), ACPI_INTERFACE_POOLTAG);

    if (!state) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(state, sizeof(IS_PCI_BUS_STATE));

    state->AcpiObject        = AcpiObject;
    state->CompletionHandler = CompletionHandler;
    state->CompletionContext = CompletionContext;
    state->Result            = Result;
    state->RunCompletion     = INITIAL_RUN_COMPLETION;

    *Result = FALSE;

    return IsPciBusAsyncWorker(AcpiObject,
                               STATUS_SUCCESS,
                               NULL,
                               (PVOID)state);
}

NTSTATUS
EXPORT
IsPciBusAsyncWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
{
    PIS_PCI_BUS_STATE   state;
    PNSOBJ              hidObj;
    PNSOBJ              cidObj;
    PPCI_COMMON_CONFIG  pciData;
    NTSTATUS            status;

    ASSERT(Context);

    state = (PIS_PCI_BUS_STATE)Context;
    status = Status;

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //
    InterlockedIncrement(&state->RunCompletion);

    //
    // Definitely not a PCI bus...
    //
    if (state->AcpiObject == NULL) {

        *state->Result = FALSE;
        goto IsPciBusAsyncExit;
    }

    //
    // If Status isn't success, then one of the worker
    // functions we called puked.  Bail.
    //
    if (!NT_SUCCESS(status)) {
        *state->Result = FALSE;
        goto IsPciBusAsyncExit;
    }

    if (!(state->Flags & PCISUPP_CHECKED_HID)) {

        state->Flags |= PCISUPP_CHECKED_HID;
        state->Hid = NULL;

        //
        // Is there an _HID?
        //
        hidObj = ACPIAmliGetNamedChild( state->AcpiObject, PACKED_HID );

        if (hidObj) {

            status = ACPIGetNSPnpIDAsync(
                        state->AcpiObject,
                        IsPciBusAsyncWorker,
                        (PVOID)state,
                        &(state->Hid),
                        NULL);

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                *state->Result = FALSE;
                goto IsPciBusAsyncExit;
            }
        }
    }

    if (state->Hid) {

        if (strstr(state->Hid, PCI_PNP_ID)) {
            //
            // Was PCI.
            //
            *state->Result = TRUE;
            goto IsPciBusAsyncExit;
        }
        ExFreePool(state->Hid);
        state->Hid = NULL;
    }

    if (!(state->Flags & PCISUPP_CHECKED_CID)) {

        state->Flags |= PCISUPP_CHECKED_CID;
        state->Cid = NULL;

        //
        // Is there a _CID?
        //
        cidObj = ACPIAmliGetNamedChild( state->AcpiObject, PACKED_CID );
        if (cidObj) {

            status = ACPIGetNSCompatibleIDAsync(
                        state->AcpiObject,
                        IsPciBusAsyncWorker,
                        (PVOID)state,
                        &(state->Cid),
                        NULL);

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                *state->Result = FALSE;
                goto IsPciBusAsyncExit;
            }
        }
    }

    if (state->Cid) {

        if (strstr(state->Cid, PCI_PNP_ID)) {
            //
            // Was PCI.
            //
            *state->Result = TRUE;
            goto IsPciBusAsyncExit;
        }
        ExFreePool(state->Cid);
        state->Cid = NULL;
    }

    if (!(state->Flags & PCISUPP_CHECKED_PCI_DEVICE)) {

        state->Flags |= PCISUPP_CHECKED_PCI_DEVICE;
        status = IsPciDevice(state->AcpiObject,
                             IsPciBusAsyncWorker,
                             (PVOID)state,
                             &state->IsPciDevice);

        if (status == STATUS_PENDING) {
            return status;
        }

        if (!NT_SUCCESS(status)) {
            *state->Result = FALSE;
            goto IsPciBusAsyncExit;
        }
    }

    if (state->IsPciDevice) {

        if (!(state->Flags & PCISUPP_CHECKED_ADR)) {

            state->Flags |= PCISUPP_CHECKED_ADR;
            status = ACPIGetNSAddressAsync(
                        state->AcpiObject,
                        IsPciBusAsyncWorker,
                        (PVOID)state,
                        &(state->Adr),
                        NULL
                        );

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                *state->Result = FALSE;
                goto IsPciBusAsyncExit;
            }
        }

        if (!(state->Flags & PCISUPP_CHECKED_PCI_BRIDGE)) {

            //
            // Now read PCI config space to see if this is a bridge.
            //
            state->Flags |= PCISUPP_CHECKED_PCI_BRIDGE;
            status = PciConfigInternal(RSACCESS_READ,
                                       state->AcpiObject,
                                       0,
                                       PCI_COMMON_HDR_LENGTH,
                                       IsPciBusAsyncWorker,
                                       (PVOID)state,
                                       state->Buffer);

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                *state->Result = FALSE;
                goto IsPciBusAsyncExit;
            }
        }

        pciData = (PPCI_COMMON_CONFIG)state->Buffer;

        if ((PCI_CONFIGURATION_TYPE(pciData) == PCI_BRIDGE_TYPE) ||
            (PCI_CONFIGURATION_TYPE(pciData) == PCI_CARDBUS_BRIDGE_TYPE)) {

            *state->Result = TRUE;

        } else {

            *state->Result = FALSE;
        }

    }

IsPciBusAsyncExit:

    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
        status = STATUS_SUCCESS;
    }

    if (state->RunCompletion) {

        state->CompletionHandler(state->AcpiObject,
                                 status,
                                 NULL,
                                 state->CompletionContext);
    }

    if (state->Hid) ExFreePool(state->Hid);
    if (state->Cid) ExFreePool(state->Cid);
    ExFreePool(state);
    return status;
}

BOOLEAN
IsPciBus(
    IN PDEVICE_OBJECT   DeviceObject
    )
/*++

Routine Description:

    This checks to see if the DeviceObject represents a PCI bus.

Arguments:

    AcpiObject  - the object to be checked
    Result      - pointer to a boolean for the result

Return Value:

    Status

Notes:

--*/
{
    AMLISUPP_CONTEXT_PASSIVE    getDataContext;
    PDEVICE_EXTENSION   devExt = ACPIInternalGetDeviceExtension(DeviceObject);
    NTSTATUS            status;
    BOOLEAN             result = FALSE;

    PAGED_CODE();

    ASSERT(devExt->Signature == ACPI_SIGNATURE);

    KeInitializeEvent(&getDataContext.Event, SynchronizationEvent, FALSE);
    getDataContext.Status = STATUS_NOT_FOUND;

    if (!(devExt->Flags & DEV_PROP_NO_OBJECT) ) {

        status = IsPciBusAsync( devExt->AcpiObject,
                                AmlisuppCompletePassive,
                                (PVOID)&getDataContext,
                                &result );

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(&getDataContext.Event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }

    }
    return result;
}

BOOLEAN
IsPciBusExtension(
    IN PDEVICE_EXTENSION    DeviceExtension
    )
/*++

Routine Description:

    This checks to see if the DeviceExtension represents a PCI bus.

Arguments:

    AcpiObject  - the object to be checked
    Result      - pointer to a boolean for the result

Return Value:

    Status

Notes:

--*/
{
    AMLISUPP_CONTEXT_PASSIVE    getDataContext;
    NTSTATUS                    status;
    BOOLEAN                     result = FALSE;

    PAGED_CODE();

    ASSERT(DeviceExtension->Signature == ACPI_SIGNATURE);

    KeInitializeEvent(&getDataContext.Event, SynchronizationEvent, FALSE);
    getDataContext.Status = STATUS_NOT_FOUND;

    if ( (DeviceExtension->Flags & DEV_PROP_NO_OBJECT) ) {

        return result;

    }

    status = IsPciBusAsync(
        DeviceExtension->AcpiObject,
        AmlisuppCompletePassive,
        (PVOID)&getDataContext,
        &result
        );
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &getDataContext.Event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

    }
    return result;
}

BOOLEAN
IsNsobjPciBus(
    IN PNSOBJ Device
    )
/*++

Routine Description:

    This checks to see if the DeviceObject represents a PCI bus.

Arguments:

    AcpiObject  - the object to be checked
    Result      - pointer to a boolean for the result

Return Value:

    Status

Notes:

--*/
{
    AMLISUPP_CONTEXT_PASSIVE    getDataContext;
    NTSTATUS                    status;
    BOOLEAN                     result = FALSE;

    PAGED_CODE();

    KeInitializeEvent(&getDataContext.Event, SynchronizationEvent, FALSE);
    getDataContext.Status = STATUS_NOT_FOUND;

    status = IsPciBusAsync( Device,
                            AmlisuppCompletePassive,
                            (PVOID)&getDataContext,
                            &result );

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&getDataContext.Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = getDataContext.Status;
    }

    return result;
}

typedef struct {
    PNSOBJ  OpRegion;
    PNSOBJ  Parent;
    ULONG   Flags;
    BOOLEAN IsPciDeviceResult;
    LONG    RunCompletion;
    PFNACB  CompletionHandler;
    PVOID   CompletionContext;
    PNSOBJ  *PciObj;
} OP_REGION_SCOPE_STATE, *POP_REGION_SCOPE_STATE;

NTSTATUS
GetOpRegionScope(
    IN  PNSOBJ  OpRegion,
    IN  PFNACB  CompletionHandler,
    IN  PVOID   CompletionContext,
    OUT PNSOBJ  *PciObj
    )
/*++

Routine Description:

    This routine takes a pointer to an OpRegion and
    returns a pointer to the PCI device that it operates
    on.

Arguments:

    OpRegion    - the operational region
    PciObj      - the object the region operates on

Return Value:

    Status

Notes:

--*/
{
    POP_REGION_SCOPE_STATE  state;

    state = ExAllocatePoolWithTag(NonPagedPool, sizeof(OP_REGION_SCOPE_STATE), ACPI_INTERFACE_POOLTAG);

    if (!state) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(state, sizeof(OP_REGION_SCOPE_STATE));

    state->OpRegion          = OpRegion;
    state->Parent            = OpRegion->pnsParent;
    state->CompletionHandler = CompletionHandler;
    state->CompletionContext = CompletionContext;
    state->PciObj            = PciObj;
    state->RunCompletion     = INITIAL_RUN_COMPLETION;

    return GetOpRegionScopeWorker(OpRegion,
                                  STATUS_SUCCESS,
                                  NULL,
                                  (PVOID)state);
}

NTSTATUS
EXPORT
GetOpRegionScopeWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
{
    POP_REGION_SCOPE_STATE  state;
    NTSTATUS                status;
    BOOLEAN                 found = FALSE;

    ASSERT(Context);

    state = (POP_REGION_SCOPE_STATE)Context;
    status = Status;

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //

    InterlockedIncrement(&state->RunCompletion);

    if (!NT_SUCCESS(Status)) {
        goto GetOpRegionScopeWorkerExit;
    }

    //
    // Need to find the PNSOBJ for the PCI device.  Do it by
    // looking up the tree.
    //

    while ((state->Parent != NULL) &&
           (state->Parent->pnsParent != state->Parent)) {

        if ( !(state->Flags & PCISUPP_COMPLETING_IS_PCI) ) {

            state->Flags |= PCISUPP_COMPLETING_IS_PCI;

            status = IsPciDevice(state->Parent,
                                 GetOpRegionScopeWorker,
                                 (PVOID)state,
                                 &state->IsPciDeviceResult);

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                goto GetOpRegionScopeWorkerExit;
            }
        }

        state->Flags &= ~PCISUPP_COMPLETING_IS_PCI;

        if (state->IsPciDeviceResult) {

            found = TRUE;
            break;
        }

        //
        // Look one step higher.
        //
        state->Parent = state->Parent->pnsParent;
    }

    if (found) {

        *state->PciObj = state->Parent;
        status = STATUS_SUCCESS;

    } else {

        status = STATUS_NOT_FOUND;
    }

GetOpRegionScopeWorkerExit:

    if (state->RunCompletion) {

        state->CompletionHandler(state->OpRegion,
                                 status,
                                 NULL,
                                 state->CompletionContext);
    }

    ExFreePool(state);
    return status;
}

NTSTATUS
EnableDisableRegions(
    IN PNSOBJ NameSpaceObj,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine runs the _REG method for all PCI op-regions
    underneath NameSpaceObj and all its children, except
    additional PCI to PCI bridges.

Arguments:

    NameSpaceObj - A device in the namespace

    Enable - boolean specifying whether this function should
             enable or disable the regions

Return Value:

    Status

Notes:

--*/
#define CONNECT_HANDLER     1
#define DISCONNECT_HANDLER  0
{
    PNSOBJ  sibling;
    PNSOBJ  regMethod = NULL;
    OBJDATA objdata[2];
    NTSTATUS status, returnStatus;

    PAGED_CODE();

    ASSERT(NameSpaceObj->dwNameSeg);

    //
    // Find a _REG that is a child of this device.
    //
    regMethod = ACPIAmliGetNamedChild( NameSpaceObj, PACKED_REG );
    if (regMethod != NULL) {

        //
        // Construct arguments for _REG method.
        //
        RtlZeroMemory(objdata, sizeof(objdata));

        objdata[0].dwDataType = OBJTYPE_INTDATA;
        objdata[0].uipDataValue = REGSPACE_PCICFG;
        objdata[1].dwDataType = OBJTYPE_INTDATA;
        objdata[1].uipDataValue = (Enable ? CONNECT_HANDLER : DISCONNECT_HANDLER );

        status = AMLIEvalNameSpaceObject(
            regMethod,
            NULL,
            2,
            objdata
            );

    }

    //
    // Recurse to all of the children.  Propagate any errors,
    // but don't stop for them.
    //

    returnStatus = STATUS_SUCCESS;

    sibling = NSGETFIRSTCHILD(NameSpaceObj);

    if (!sibling) {
        return returnStatus;
    }

    do {

        switch (NSGETOBJTYPE(sibling)) {
        case OBJTYPE_DEVICE:

            if (IsNsobjPciBus(sibling)) {

                //
                // Don't recurse past a child PCI to PCI bridge.
                //
                break;
            }

            status = EnableDisableRegions(sibling, Enable);

            if (!NT_SUCCESS(status)) {
                returnStatus = status;
            }

            break;

        default:
            break;
        }

    } while (sibling = NSGETNEXTSIBLING(sibling));

    return returnStatus;
}

UCHAR
GetBusNumberFromCRS(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PUCHAR              CRS
    )
/*++

Routine Description:

    Grovels through the _CRS buffer looking for an address
    descriptor for the bus number

Arguments:

    DeviceExtension - Pointer to the PCI root bus
    CRS             - Supplies the CRS.

Return Value:

    NTSTATUS

--*/

{
    PPNP_DWORD_ADDRESS_DESCRIPTOR   DwordAddress;
    PPNP_QWORD_ADDRESS_DESCRIPTOR   QwordAddress;
    PPNP_WORD_ADDRESS_DESCRIPTOR    WordAddress;
    PUCHAR                          Current;
    UCHAR                           TagName;
    USHORT                          Increment;

    Current = CRS;
    while ( *Current ) {

        TagName = *Current;
        if ( !(TagName & LARGE_RESOURCE_TAG)) {
            Increment = (USHORT) (TagName & SMALL_TAG_SIZE_MASK) + 1;
            TagName &= SMALL_TAG_MASK;
        } else {
            Increment = ( *(USHORT UNALIGNED *)(Current + 1) ) + 3;
        }

        if (TagName == TAG_END) {
            break;
        }

        switch(TagName) {
        case TAG_DOUBLE_ADDRESS:

            DwordAddress = (PPNP_DWORD_ADDRESS_DESCRIPTOR) Current;
            if (DwordAddress->RFlag == PNP_ADDRESS_BUS_NUMBER_TYPE) {
                ASSERT(DwordAddress->MinimumAddress <= 0xFF);
                return (UCHAR) DwordAddress->MinimumAddress;
            }
            break;

        case TAG_QUAD_ADDRESS:

            QwordAddress = (PPNP_QWORD_ADDRESS_DESCRIPTOR) Current;
            if (QwordAddress->RFlag == PNP_ADDRESS_BUS_NUMBER_TYPE) {
                ASSERT(QwordAddress->MinimumAddress <= 0xFF);
                return (UCHAR) QwordAddress->MinimumAddress;
            }
            break;

        case TAG_WORD_ADDRESS:

            WordAddress = (PPNP_WORD_ADDRESS_DESCRIPTOR) Current;
            if (WordAddress->RFlag == PNP_ADDRESS_BUS_NUMBER_TYPE) {
                ASSERT(WordAddress->MinimumAddress <= 0xFF);
                return (UCHAR) WordAddress->MinimumAddress;
            }
            break;

        }

        Current += Increment;
    }

    //
    // No Bus address was found. This is an error in the BIOS.
    //
    KeBugCheckEx(
        ACPI_BIOS_ERROR,
        ACPI_ROOT_PCI_RESOURCE_FAILURE,
        (ULONG_PTR) DeviceExtension,
        3,
        (ULONG_PTR) CRS
        );
    return((UCHAR)-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\rangesup.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rangesup.h

Abstract:

    This handles the subtraction of a set of CmResList from an IoResList
    IoResList

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    Aug-05-97   - Initial Revision

--*/

#ifndef _RANGESUP_H_
#define _RANGESUP_H_

    NTSTATUS
    ACPIRangeAdd(
        IN  OUT PIO_RESOURCE_REQUIREMENTS_LIST  *GlobalList,
        IN      PIO_RESOURCE_REQUIREMENTS_LIST  AddList
        );

    NTSTATUS
    ACPIRangeAddCmList(
        IN  OUT PCM_RESOURCE_LIST   *GlobalList,
        IN      PCM_RESOURCE_LIST   AddList
        );

    NTSTATUS
    ACPIRangeFilterPICInterrupt(
        IN  PIO_RESOURCE_REQUIREMENTS_LIST  IoResList
        );

    NTSTATUS
    ACPIRangeSortCmList(
        IN  PCM_RESOURCE_LIST   CmResList
        );

    NTSTATUS
    ACPIRangeSortIoList(
        IN  PIO_RESOURCE_LIST   IoResList
        );

    NTSTATUS
    ACPIRangeSubtract(
        IN  PIO_RESOURCE_REQUIREMENTS_LIST  *IoResReqList,
        IN  PCM_RESOURCE_LIST               CmResList
        );

    NTSTATUS
    ACPIRangeSubtractIoList(
        IN  PIO_RESOURCE_LIST   IoResList,
        IN  PCM_RESOURCE_LIST   CmResList,
        OUT PIO_RESOURCE_LIST   *Result
        );

    VOID
    ACPIRangeValidatePciMemoryResource(
        IN  PIO_RESOURCE_LIST       IoList,
        IN  ULONG                   Index,
        IN  PACPI_BIOS_MULTI_NODE   E820Info,
        OUT ULONG                   *BugCheck
        );

    VOID
    ACPIRangeValidatePciResources(
        IN  PDEVICE_EXTENSION               DeviceExtension,
        IN  PIO_RESOURCE_REQUIREMENTS_LIST  IoResList
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\res_bios.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    res_bios

Abstract:

    PnP BIOS/ISA configuration data definitions

Author:

    Shie-Lin Tzong (shielint) April 12, 1995
    Stephane Plante (splante) Feb 13, 1997

Revision History:

    Feb 13 1997
        Changed and fully adapted to ACPI driver

--*/

#ifndef _RES_BIOS_H_
#define _RES_BIOS_H_

    //
    // Constants
    //
    #define SMALL_RESOURCE_TAG          (UCHAR)(0x00)
    #define LARGE_RESOURCE_TAG          (UCHAR)(0x80)
    #define SMALL_TAG_MASK              0xf8
    #define SMALL_TAG_SIZE_MASK         7

    //
    // Small Resource Tags with length bits stripped off
    //
    #define TAG_IRQ                     0x20
    #define TAG_DMA                     0x28
    #define TAG_START_DEPEND            0x30
    #define TAG_END_DEPEND              0x38
    #define TAG_IO                      0x40
    #define TAG_IO_FIXED                0x48
    #define TAG_VENDOR                  0x70
    #define TAG_END                     0x78

    //
    // Large Resource Tags
    //
    #define TAG_MEMORY                  0x81
    #define TAG_MEMORY32                0x85
    #define TAG_MEMORY32_FIXED          0x86
    #define TAG_DOUBLE_ADDRESS          0x87
    #define TAG_WORD_ADDRESS            0x88
    #define TAG_EXTENDED_IRQ            0x89
    #define TAG_QUAD_ADDRESS            0x8a

    #include "pshpack1.h"

    //
    // PNP ISA Port descriptor definition
    //
    typedef struct _PNP_PORT_DESCRIPTOR_ {
        UCHAR   Tag;                    // 01000111B, small item name = 08, length = 7
        UCHAR   Information;            // bit [0] = 1 device decodes full 16 bit addr
                                        //         = 0 device decodes ISA addr bits[9-0]
        USHORT  MinimumAddress;
        USHORT  MaximumAddress;
        UCHAR   Alignment;              // Increment in 1 byte blocks
        UCHAR   Length;                 // # contiguous Port requested
    } PNP_PORT_DESCRIPTOR, *PPNP_PORT_DESCRIPTOR;

    #define PNP_PORT_DECODE_MASK        0x1
    #define PNP_PORT_10_BIT_DECODE      0x0
    #define PNP_PORT_16_BIT_DECODE      0x1

    //
    // PNP ISA fixed Port descriptor definition
    //
    typedef struct _PNP_FIXED_PORT_DESCRIPTOR_ {
        UCHAR   Tag;                    // 01001011B, small item name = 09, length = 3
        USHORT  MinimumAddress;
        UCHAR   Length;                 // # contiguous Port requested
    } PNP_FIXED_PORT_DESCRIPTOR, *PPNP_FIXED_PORT_DESCRIPTOR;

    //
    // PNP ISA IRQ descriptor definition
    //
    typedef struct _PNP_IRQ_DESCRIPTOR_ {
        UCHAR   Tag;                    // 0010001XB small item name = 4 length = 2/3
        USHORT  IrqMask;                // bit 0 is irq 0
        UCHAR   Information;            // Optional
    } PNP_IRQ_DESCRIPTOR, *PPNP_IRQ_DESCRIPTOR;

    #define PNP_IRQ_LEVEL               0x08
    #define PNP_IRQ_LATCHED             0x01
    #define PNP_IRQ_SHARED              0x10

    //
    // PNP ISA DMA descriptor definition
    //
    typedef struct _PNP_DMA_DESCRIPTOR_ {
        UCHAR   Tag;                    // 00101010B, small item name = 05, length = 2
        UCHAR   ChannelMask;            // bit 0 is channel 0
        UCHAR   Flags;                  // see spec
    } PNP_DMA_DESCRIPTOR, *PPNP_DMA_DESCRIPTOR;

    //
    // Defination and mask for the various flags
    //
    #define PNP_DMA_SIZE_MASK           0x03
    #define PNP_DMA_SIZE_8              0x00
    #define PNP_DMA_SIZE_8_AND_16       0x01
    #define PNP_DMA_SIZE_16             0x02
    #define PNP_DMA_SIZE_RESERVED       0x03

    #define PNP_DMA_BUS_MASTER          0x04

    #define PNP_DMA_TYPE_MASK           0x60
    #define PNP_DMA_TYPE_COMPATIBLE     0x00
    #define PNP_DMA_TYPE_A              0x20
    #define PNP_DMA_TYPE_B              0x40
    #define PNP_DMA_TYPE_F              0x60

    //
    // PNP ISA MEMORY descriptor
    //
    typedef struct _PNP_MEMORY_DESCRIPTOR_ {
        UCHAR   Tag;                    // 10000001B, Large item name = 1
        USHORT  Length;                 // Length of the descriptor = 9
        UCHAR   Information;            // See def below
        USHORT  MinimumAddress;         // address bit [8-23]
        USHORT  MaximumAddress;         // address bit [8-23]
        USHORT  Alignment;              // 0x0000 = 64KB
        USHORT  MemorySize;             // In 256 byte blocks
    } PNP_MEMORY_DESCRIPTOR, *PPNP_MEMORY_DESCRIPTOR;

    //
    // PNP ISA MEMORY32 descriptor
    //
    typedef struct _PNP_MEMORY32_DESCRIPTOR_ {
        UCHAR   Tag;                    // 10000101B, Large item name = 5
        USHORT  Length;                 // Length of the descriptor = 17
        UCHAR   Information;            // See def below
        ULONG   MinimumAddress;         // 32 bit addr
        ULONG   MaximumAddress;         // 32 bit addr
        ULONG   Alignment;              // 32 bit alignment
        ULONG   MemorySize;             // 32 bit length
    } PNP_MEMORY32_DESCRIPTOR, *PPNP_MEMORY32_DESCRIPTOR;

    //
    // PNP ISA FIXED MEMORY32 descriptor
    //
    typedef struct _PNP_FIXED_MEMORY32_DESCRIPTOR_ {
        UCHAR   Tag;                    // 10000110B, Large item name = 6
        USHORT  Length;                 // Length of the descriptor = 9
        UCHAR   Information;            // See def below
        ULONG   BaseAddress;            // 32 bit addr
        ULONG   MemorySize;             // 32 bit length
    } PNP_FIXED_MEMORY32_DESCRIPTOR, *PPNP_FIXED_MEMORY32_DESCRIPTOR;

    #define PNP_MEMORY_READ_ONLY                    0x00
    #define PNP_MEMORY_READ_WRITE                   0x01

    //
    // PNP ISA Resource Source descriptor definition
    //
    typedef struct _PNP_RESOURCE_SOURCE_DESCRIPTOR_ {
        UCHAR   Index;                  // Varies with type of Source
        UCHAR   String[1];              // Start of a variable string
    } PNP_RESOURCE_SOURCE_DESCRIPTOR, *PPNP_RESOURCE_SOURCE_DESCRIPTOR;

    //
    // PNP DWORD Address descriptor definition
    //
    typedef struct _PNP_DWORD_ADDRESS_DESCRIPTOR_ {
        UCHAR   Tag;                    // 10000111B, Large item name= 7
        USHORT  Length;                 // Length of the descriptor = 23 (min)
        UCHAR   RFlag;                  // Resource Flags
        UCHAR   GFlag;                  // General Flags
        UCHAR   TFlag;                  // Type specific flags
        ULONG   Granularity;            // Memory Decode Bits
        ULONG   MinimumAddress;         // Minium Address in range
        ULONG   MaximumAddress;         // Maximum Address in range
        ULONG   TranslationAddress;     // How to translate the address
        ULONG   AddressLength;          // Number of bytes requested
    } PNP_DWORD_ADDRESS_DESCRIPTOR, *PPNP_DWORD_ADDRESS_DESCRIPTOR;

    typedef struct _PNP_QWORD_ADDRESS_DESCRIPTOR_ {
        UCHAR       Tag;                    // 10001010B, Large item name= 10
        USHORT      Length;                 // Length of the descriptor = 23 (min)
        UCHAR       RFlag;                  // Resource Flags
        UCHAR       GFlag;                  // General Flags
        UCHAR       TFlag;                  // Type specific flags
        ULONGLONG   Granularity;            // Memory Decode Bits
        ULONGLONG   MinimumAddress;         // Minium Address in range
        ULONGLONG   MaximumAddress;         // Maximum Address in range
        ULONGLONG   TranslationAddress;     // How to translate the address
        ULONGLONG   AddressLength;          // Number of bytes requested
    } PNP_QWORD_ADDRESS_DESCRIPTOR, *PPNP_QWORD_ADDRESS_DESCRIPTOR;

    typedef struct _PNP_WORD_ADDRESS_DESCRIPTOR_ {
        UCHAR   Tag;                    // 10001000B, Large item name= 8
        USHORT  Length;                 // Length of the descriptor = 13 (min)
        UCHAR   RFlag;                  // Resource Flags
        UCHAR   GFlag;                  // General Flags
        UCHAR   TFlag;                  // Type specific flags
        USHORT  Granularity;            // Memory Decode Bits
        USHORT  MinimumAddress;         // Minium Address in range
        USHORT  MaximumAddress;         // Maximum Address in range
        USHORT  TranslationAddress;     // How to translate the address
        USHORT  AddressLength;          // Number of Bytes requested
    } PNP_WORD_ADDRESS_DESCRIPTOR, *PPNP_WORD_ADDRESS_DESCRIPTOR;

    //
    // These are the valid minimum lengths. We bugcheck if the descriptors
    // are less then these
    //
    #define PNP_ADDRESS_WORD_MINIMUM_LENGTH         0x0D
    #define PNP_ADDRESS_DWORD_MINIMUM_LENGTH        0x17
    #define PNP_ADDRESS_QWORD_MINIMUM_LENGTH        0x2B

    //
    // These are the possible values for RFlag Means
    //
    #define PNP_ADDRESS_MEMORY_TYPE                 0x0
    #define PNP_ADDRESS_IO_TYPE                     0x1
    #define PNP_ADDRESS_BUS_NUMBER_TYPE             0x2

    //
    // The Global flags
    //
    #define PNP_ADDRESS_FLAG_CONSUMED_ONLY          0x1
    #define PNP_ADDRESS_FLAG_SUBTRACTIVE_DECODE     0x2
    #define PNP_ADDRESS_FLAG_MINIMUM_FIXED          0x4
    #define PNP_ADDRESS_FLAG_MAXIMUM_FIXED          0x8

    //
    // This mask is used when the RFLags indicates that this is
    // memory address descriptor. The mask is used with the TFlags
    // and the result is compared to the next 4 defines to determine
    // the memory type
    //
    #define PNP_ADDRESS_TYPE_MEMORY_MASK            0x1E
    #define PNP_ADDRESS_TYPE_MEMORY_NONCACHEABLE    0x00
    #define PNP_ADDRESS_TYPE_MEMORY_CACHEABLE       0x02
    #define PNP_ADDRESS_TYPE_MEMORY_WRITE_COMBINE   0x04
    #define PNP_ADDRESS_TYPE_MEMORY_PREFETCHABLE    0x06

    //
    // If this bit is set, then this memory is read-write
    //
    #define PNP_ADDRESS_TYPE_MEMORY_READ_WRITE      0x01
    #define PNP_ADDRESS_TYPE_MEMORY_READ_ONLY       0x00

    //
    // These are used when the RFlags indicates that this is an IO descriptor
    //
    #define PNP_ADDRESS_TYPE_IO_NON_ISA_RANGE       0x01
    #define PNP_ADDRESS_TYPE_IO_ISA_RANGE           0x02
    #define PNP_ADDRESS_TYPE_IO_SPARSE_TRANSLATION  0x20
    #define PNP_ADDRESS_TYPE_IO_TRANSLATE_IO_TO_MEM 0x10

    //
    // PNP ISA Extended IRQ descriptor definition [fixed block]
    //
    typedef struct _PNP_EXTENDED_IRQ_DESCRIPTOR_ {
        UCHAR   Tag;                    // 10001001B, Large item name = 9
        USHORT  Length;                 // Length of the descriptor = 12 (min)
        UCHAR   Flags;                  // Vector Flags
        UCHAR   TableSize;              // How many items in the table
        ULONG   Table[1];               // Table of interrupts
    } PNP_EXTENDED_IRQ_DESCRIPTOR, *PPNP_EXTENDED_IRQ_DESCRIPTOR;

    #define PNP_EXTENDED_IRQ_RESOURCE_CONSUMER_ONLY 0x01
    #define PNP_EXTENDED_IRQ_MODE                   0x02
    #define PNP_EXTENDED_IRQ_POLARITY               0x04
    #define PNP_EXTENDED_IRQ_SHARED                 0x08

    #define PNP_VENDOR_SPECIFIC_MASK                0x07

    //
    // These are the flags that can be passed into the Bios to Io engine
    //
    #define PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES    0x01

    #include "poppack.h"

    VOID
    PnpiBiosAddressHandleBusFlags(
        IN  PVOID                   Buffer,
        IN  PIO_RESOURCE_DESCRIPTOR Descriptor
        );

    VOID
    PnpiBiosAddressHandleGlobalFlags(
        IN  PVOID                   Buffer,
        IN  PIO_RESOURCE_DESCRIPTOR Descriptor
        );

    VOID
    PnpiBiosAddressHandleMemoryFlags(
        IN  PVOID                   Buffer,
        IN  PIO_RESOURCE_DESCRIPTOR Descriptor
        );

    VOID
    PnpiBiosAddressHandlePortFlags(
        IN  PVOID                   Buffer,
        IN  PIO_RESOURCE_DESCRIPTOR Descriptor
        );

    NTSTATUS
    PnpiBiosAddressToIoDescriptor(
        IN  PUCHAR              Data,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  ULONG               Flags
        );

    NTSTATUS
    PnpiBiosAddressDoubleToIoDescriptor(
        IN  PUCHAR              Data,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  ULONG               Flags
        );

    NTSTATUS
    PnpiBiosAddressQuadToIoDescriptor(
        IN  PUCHAR              Data,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  ULONG               Flags
        );

    NTSTATUS
    PnpiBiosDmaToIoDescriptor(
        IN  PUCHAR              Data,
        IN  UCHAR               Channel,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  USHORT              Count,
        IN  ULONG               Flags
        );

    NTSTATUS
    PnpiBiosExtendedIrqToIoDescriptor(
        IN  PUCHAR              Data,
        IN  UCHAR               DataIndex,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  ULONG               Flags
        );

    NTSTATUS
    PnpiBiosIrqToIoDescriptor(
        IN  PUCHAR              Data,
        IN  USHORT              Interrupt,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  USHORT              Count,
        IN  ULONG               Flags
        );

    NTSTATUS
    PnpiBiosMemoryToIoDescriptor(
        IN  PUCHAR              Data,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  ULONG               Flags
        );

    NTSTATUS
    PnpiBiosPortToIoDescriptor (
        IN  PUCHAR                  Data,
        IN  PIO_RESOURCE_LIST       Array[],
        IN  ULONG                   ArrayIndex,
        IN  ULONG                   Flags
        );


    NTSTATUS
    PnpiBiosPortFixedToIoDescriptor(
        IN  PUCHAR              Data,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  ULONG               Flags
        );

    VOID
    PnpiClearAllocatedMemory(
        IN      PIO_RESOURCE_LIST       ResourceArray[],
        IN      ULONG                   ResourceArraySize
        );

    NTSTATUS
    PnpiGrowResourceDescriptor(
        IN  OUT PIO_RESOURCE_LIST       *ResourceList
        );

    NTSTATUS
    PnpiGrowResourceList(
        IN  OUT PIO_RESOURCE_LIST       *ResourceListArray[],
        IN  OUT ULONG                   *ResourceListArraySize
        );

    NTSTATUS
    PnpiUpdateResourceList(
        IN  OUT PIO_RESOURCE_LIST       *ResourceList,
            OUT PIO_RESOURCE_DESCRIPTOR *ResourceDesc
        );

    NTSTATUS
    PnpBiosResourcesToNtResources (
        IN      PUCHAR                          BiosData,
        IN      ULONG                           Flags,
           OUT PIO_RESOURCE_REQUIREMENTS_LIST  *List
         );

    NTSTATUS
    PnpCmResourceListToIoResourceList(
        IN      PCM_RESOURCE_LIST               CmList,
        IN  OUT PIO_RESOURCE_REQUIREMENTS_LIST  *IoList
        );

    NTSTATUS
    PnpIoResourceListToCmResourceList(
        IN      PIO_RESOURCE_REQUIREMENTS_LIST  IoList,
        IN  OUT PCM_RESOURCE_LIST               *CmList
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\res_cm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cmres.c

Abstract:

    This file contains routines to translate resources between PnP ISA/BIOS
    format and Windows NT formats.

Author:

    Stephane Plante (splante) 20-Nov-1996

Environment:

    Kernel mode only.

Revision History:

    13-Feb-1997:
        Initial Revision

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,PnpiCmResourceToBiosAddress)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosAddressDouble)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosDma)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosExtendedIrq)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosIoFixedPort)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosIoPort)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosIrq)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosMemory)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosMemory32)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosMemory32Fixed)
#pragma alloc_text(PAGE,PnpiCmResourceValidEmptyList)
#pragma alloc_text(PAGE,PnpCmResourcesToBiosResources)
#endif


NTSTATUS
PnpiCmResourceToBiosAddress(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine converts the proper Cm resource descriptor back into a
    word address descriptor

Arguments:

    Buffer  - Pointer to the Bios Resource list
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_WORD_ADDRESS_DESCRIPTOR    buffer;
    UCHAR                           type;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_WORD_ADDRESS_DESCRIPTOR) Buffer;

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1 );
    ASSERT( aList->PartialResourceList.Count );

    //
    // Determine which type of descriptor we are looking for
    //
    switch (buffer->RFlag) {
    case PNP_ADDRESS_MEMORY_TYPE:
        type = CmResourceTypeMemory;
        break;
    case PNP_ADDRESS_IO_TYPE:
        type = CmResourceTypePort;
        break;
    case PNP_ADDRESS_BUS_NUMBER_TYPE:
        type = CmResourceTypeBusNumber;
        break;
    default:
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != type) {

            //
            // No
            //
            continue;

        }

        switch (desc->Type) {
        case PNP_ADDRESS_MEMORY_TYPE:

            //
            // Set the flags
            //
            buffer->TFlag = 0;
            if (desc->Flags & CM_RESOURCE_MEMORY_READ_WRITE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_READ_WRITE;

            } else {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_READ_ONLY;

            }
            if (desc->Flags & CM_RESOURCE_MEMORY_CACHEABLE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_CACHEABLE;

            } else if (desc->Flags & CM_RESOURCE_MEMORY_COMBINEDWRITE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_WRITE_COMBINE;

            } else if (desc->Flags & CM_RESOURCE_MEMORY_PREFETCHABLE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_PREFETCHABLE;

            } else {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_NONCACHEABLE;

            }

            //
            // Set the rest of the information
            //
            buffer->MinimumAddress = (USHORT)
                (desc->u.Memory.Start.LowPart & 0xFFFF);
            buffer->MaximumAddress = buffer->MinimumAddress +
                (USHORT) (desc->u.Memory.Length - 1);
            buffer->AddressLength = (USHORT) desc->u.Memory.Length;
            break;

        case PNP_ADDRESS_IO_TYPE:

            //
            // We must extract the flags here from the
            // devicePrivate resource
            //

            //
            // Set the rest of the information
            //
            buffer->MinimumAddress = (USHORT)
                (desc->u.Port.Start.LowPart & 0xFFFF);
            buffer->MaximumAddress = buffer->MinimumAddress +
                (USHORT) (desc->u.Port.Length - 1);
            buffer->AddressLength = (USHORT) desc->u.Port.Length;
            break;

        case PNP_ADDRESS_BUS_NUMBER_TYPE:

            buffer->MinimumAddress = (USHORT)
                (desc->u.BusNumber.Start & 0xFFFF);
            buffer->MaximumAddress = buffer->MinimumAddress +
                (USHORT) (desc->u.BusNumber.Length - 1);
            buffer->AddressLength = (USHORT) desc->u.BusNumber.Length;
            break;

        } // switch

        //
        // Handling for the GFlags goes here, if we ever decide to
        // support it
        //

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    } // for

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosAddressDouble(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine converts the proper Cm resource descriptor back into a
    word address descriptor

Arguments:

    Buffer  - Pointer to the Bios Resource list
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_DWORD_ADDRESS_DESCRIPTOR   buffer;
    UCHAR                           type;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_DWORD_ADDRESS_DESCRIPTOR) Buffer;

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1 );
    ASSERT( aList->PartialResourceList.Count );

    //
    // Determine which type of descriptor we are looking for
    //
    switch (buffer->RFlag) {
    case PNP_ADDRESS_MEMORY_TYPE:
        type = CmResourceTypeMemory;
        break;
    case PNP_ADDRESS_IO_TYPE:
        type = CmResourceTypePort;
        break;
    case PNP_ADDRESS_BUS_NUMBER_TYPE:
        type = CmResourceTypeBusNumber;
        break;
    default:
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != type) {

            //
            // No
            //
            continue;

        }

        switch (desc->Type) {
        case PNP_ADDRESS_MEMORY_TYPE:

            //
            // Set the flags
            //
            buffer->TFlag = 0;
            if (desc->Flags & CM_RESOURCE_MEMORY_READ_WRITE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_READ_WRITE;

            } else {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_READ_ONLY;

            }
            if (desc->Flags & CM_RESOURCE_MEMORY_CACHEABLE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_CACHEABLE;

            } else if (desc->Flags & CM_RESOURCE_MEMORY_COMBINEDWRITE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_WRITE_COMBINE;

            } else if (desc->Flags & CM_RESOURCE_MEMORY_PREFETCHABLE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_PREFETCHABLE;

            } else {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_NONCACHEABLE;

            }

            //
            // Set the rest of the information
            //
            buffer->MinimumAddress = (ULONG) desc->u.Memory.Start.LowPart;
            buffer->MaximumAddress = buffer->MinimumAddress +
                (ULONG) (desc->u.Memory.Length - 1);
            buffer->AddressLength = desc->u.Memory.Length;
            break;

        case PNP_ADDRESS_IO_TYPE:

            //
            // We must extract the flags here from the
            // devicePrivate resource
            //

            //
            // Set the rest of the information
            //
            buffer->MinimumAddress = (ULONG) desc->u.Port.Start.LowPart;
            buffer->MaximumAddress = buffer->MinimumAddress +
                (ULONG) (desc->u.Port.Length - 1);
            buffer->AddressLength = desc->u.Port.Length;
            break;

        case PNP_ADDRESS_BUS_NUMBER_TYPE:

            buffer->MinimumAddress = (ULONG) desc->u.BusNumber.Start;
            buffer->MaximumAddress = buffer->MinimumAddress +
                (ULONG) (desc->u.BusNumber.Length - 1);
            buffer->AddressLength = desc->u.BusNumber.Length;
            break;

        } // switch

        //
        // Handling for the GFlags goes here if we ever decide to support it
        //

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    } // for

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosDma(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the DMAs in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_DMA_DESCRIPTOR             buffer;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_DMA_DESCRIPTOR) Buffer;
    ASSERT( (buffer->Tag & SMALL_TAG_SIZE_MASK) == 2);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // We can have a descriptor with no DMA channels
    //
    buffer->ChannelMask = 0;

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypeDma) {

            //
            // No
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->ChannelMask = (1 << desc->u.Dma.Channel);

        //
        // Set the correct flags
        //
        buffer->Flags = 0;
        if (desc->Flags & CM_RESOURCE_DMA_8) {

            buffer->Flags |= PNP_DMA_SIZE_8;

        } else if (desc->Flags & CM_RESOURCE_DMA_8_AND_16) {

            buffer->Flags |= PNP_DMA_SIZE_8_AND_16;

        } else if (desc->Flags & CM_RESOURCE_DMA_16) {

            buffer->Flags |= PNP_DMA_SIZE_16;

        } else if (desc->Flags & CM_RESOURCE_DMA_32) {

            buffer->Flags |= PNP_DMA_SIZE_RESERVED;

        }
        if (desc->Flags & CM_RESOURCE_DMA_BUS_MASTER) {

            buffer->Flags |= PNP_DMA_BUS_MASTER;

        }
        if (desc->Flags & CM_RESOURCE_DMA_TYPE_A) {

            buffer->Flags |= PNP_DMA_TYPE_A;

        } else if (desc->Flags & CM_RESOURCE_DMA_TYPE_B) {

            buffer->Flags |= PNP_DMA_TYPE_B;

        } else if (desc->Flags & CM_RESOURCE_DMA_TYPE_F) {

            buffer->Flags |= PNP_DMA_TYPE_F;

        }

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosExtendedIrq(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the Irqs in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return Value:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_EXTENDED_IRQ_DESCRIPTOR    buffer;
    ULONG                           i;
    ULONG                           matches = 0;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_EXTENDED_IRQ_DESCRIPTOR) Buffer;
    ASSERT( buffer->TableSize == 1);
    ASSERT( buffer->Length >= 6);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypeInterrupt) {

            //
            // No
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->Table[0] = (ULONG) desc->u.Interrupt.Level;

        //
        // Set the Flags
        //
        buffer->Flags = 0;
        if ( (desc->Flags & CM_RESOURCE_INTERRUPT_LATCHED) ) {

            buffer->Flags |= $EDG | $HGH;

        } else {

            buffer->Flags |= $LVL | $LOW;

        }
        if (desc->ShareDisposition == CmResourceShareShared) {

            buffer->Flags |= PNP_EXTENDED_IRQ_SHARED;

        }

        //
        // We need to use DevicePrivate information to store this
        // bit. For now, assume that it is set to true
        //
        buffer->Flags |= PNP_EXTENDED_IRQ_RESOURCE_CONSUMER_ONLY;

        //
        // Done with the record
        //
        desc->Type = CmResourceTypeNull;
        matches++;
        break;

    }

    //
    // Done with matches
    //
    return (matches == 0 ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS );
}

NTSTATUS
PnpiCmResourceToBiosIoFixedPort(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the IoPort in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_FIXED_PORT_DESCRIPTOR      buffer;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_FIXED_PORT_DESCRIPTOR) Buffer;
    ASSERT( (buffer->Tag & SMALL_TAG_SIZE_MASK) == 3);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // Our fixed port can be nothing
    //
    buffer->MinimumAddress = buffer->Length = 0;

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypePort) {

            //
            // No
            //
            continue;

        }

        //
        // This port type is always set to a 10 bit decode
        //
        if ( !(desc->Flags & CM_RESOURCE_PORT_10_BIT_DECODE) ) {

            //
            // No
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->MinimumAddress = (USHORT) desc->u.Port.Start.LowPart;
        buffer->Length = (UCHAR) desc->u.Port.Length;

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosIoPort(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the IoPort in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_PORT_DESCRIPTOR            buffer;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_PORT_DESCRIPTOR) Buffer;
    ASSERT( (buffer->Tag & SMALL_TAG_SIZE_MASK) == 7);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // We can use no ports
    //
    buffer->Information = 0;
    buffer->MinimumAddress = 0;
    buffer->MaximumAddress = 0;
    buffer->Alignment = 0;
    buffer->Length = 0;

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypePort) {

            //
            // No
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->MinimumAddress = (USHORT) desc->u.Port.Start.LowPart;
        buffer->MaximumAddress = buffer->MinimumAddress;
        buffer->Alignment = 1;
        buffer->Length = (UCHAR) desc->u.Port.Length;

        //
        // Set the flags
        //
        buffer->Information = 0;
        if (desc->Flags & CM_RESOURCE_PORT_10_BIT_DECODE) {

            buffer->Information |= PNP_PORT_10_BIT_DECODE;

        }
        if (desc->Flags & CM_RESOURCE_PORT_16_BIT_DECODE) {

            buffer->Information |= PNP_PORT_16_BIT_DECODE;

        }

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    }

    //
    // Done with matches
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosIrq(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the Irqs in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return Value:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_IRQ_DESCRIPTOR             buffer;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_IRQ_DESCRIPTOR) Buffer;
    ASSERT( (buffer->Tag & SMALL_TAG_SIZE_MASK) >= 2);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // We can use no interrupts
    //
    buffer->IrqMask = 0;

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypeInterrupt) {

            //
            // No
            //
            continue;

        }

        //
        // Okay, we have a possible match...
        //
        if (desc->u.Interrupt.Level >= sizeof(USHORT) * 8) {

            //
            // Interrupts > 15 are Extended Irqs
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->IrqMask = ( 1 << desc->u.Interrupt.Level );
        if ( (buffer->Tag & SMALL_TAG_SIZE_MASK) == 3) {

            //
            // Wipe out the previous flags
            //
            buffer->Information = 0;
            if ( (desc->Flags & CM_RESOURCE_INTERRUPT_LATCHED) ) {

                buffer->Information |= PNP_IRQ_LATCHED;

            } else {

                buffer->Information |= PNP_IRQ_LEVEL;

            }
            if (desc->ShareDisposition == CmResourceShareShared) {

                buffer->Information |= PNP_IRQ_SHARED;

            }

        }

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosMemory(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the Memory elements in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_MEMORY_DESCRIPTOR          buffer;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_MEMORY_DESCRIPTOR) Buffer;
    ASSERT( buffer->Length == 9);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // We can use no memory
    //
    buffer->Information = 0;
    buffer->MinimumAddress = 0;
    buffer->MaximumAddress = 0;
    buffer->Alignment = 0;
    buffer->MemorySize = 0;

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypeMemory) {

            //
            // No
            //
            continue;

        }

        //
        // Is this a 24 bit memory descriptor?
        //
        if ( !(desc->Flags & CM_RESOURCE_MEMORY_24)) {

            //
            // No
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->MinimumAddress = buffer->MaximumAddress =
            (USHORT) (desc->u.Memory.Start.LowPart >> 8);
        buffer->MemorySize = (USHORT) (desc->u.Memory.Length >> 8);
        if (desc->Flags & CM_RESOURCE_MEMORY_READ_ONLY) {

            buffer->Information |= PNP_MEMORY_READ_ONLY;

        } else {

            buffer->Information |= PNP_MEMORY_READ_WRITE;

        }

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosMemory32(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the Memory elements in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_MEMORY32_DESCRIPTOR        buffer;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_MEMORY32_DESCRIPTOR) Buffer;
    ASSERT( buffer->Length == 17);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // We can use no memory
    //
    buffer->Information = 0;
    buffer->MinimumAddress = 0;
    buffer->MaximumAddress = 0;
    buffer->Alignment = 0;
    buffer->MemorySize = 0;

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypeMemory) {

            //
            // No
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->MemorySize = desc->u.Memory.Length;
        buffer->MinimumAddress = buffer->MaximumAddress = desc->u.Memory.Start.LowPart;
        if (desc->Flags & CM_RESOURCE_MEMORY_READ_ONLY) {

            buffer->Information |= PNP_MEMORY_READ_ONLY;

        } else {

            buffer->Information |= PNP_MEMORY_READ_WRITE;

        }

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    }

    //
    // Done with matches
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosMemory32Fixed(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the Memory elements in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_FIXED_MEMORY32_DESCRIPTOR  buffer;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_FIXED_MEMORY32_DESCRIPTOR) Buffer;
    ASSERT( buffer->Length == 9);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // We can use no memory
    //
    buffer->Information = 0;
    buffer->BaseAddress = 0;
    buffer->MemorySize = 0;

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypeMemory) {

            //
            // No
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->BaseAddress = desc->u.Memory.Start.LowPart;
        buffer->MemorySize =  desc->u.Memory.Length >> 8;
        if (desc->Flags & CM_RESOURCE_MEMORY_READ_ONLY) {

            buffer->Information |= PNP_MEMORY_READ_ONLY;

        } else {

            buffer->Information |= PNP_MEMORY_READ_WRITE;

        }

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

BOOLEAN
PnpiCmResourceValidEmptyList(
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine takes a CM_RESOURCE_LIST and makes sure that no unallocated elements
    remain...

Arguments:

    List    - List to check

Return Value:

    TRUE    - Empty
    FALSE   - Nonempty

--*/
{

    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    ULONG                           i;

    PAGED_CODE();

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypeNull) {

            //
            // No
            //
            continue;

        }

        //
        // This element wasn't consumed...<sigh>
        //
        break;

    }

    //
    // Done
    //
    return ( i == aList->PartialResourceList.Count ? TRUE : FALSE );
}

NTSTATUS
PnpCmResourcesToBiosResources(
    IN  PCM_RESOURCE_LIST   List,
    IN  PUCHAR              Data
    )
/*++

Routine Description:

    This routine takes a CM_RESOURCE_LIST and a _CRS buffer. The routine sets the
    resources in the _CRS buffer to equal to those reported in the CM_RESOURCE_LIST.
    That is: the buffer is used as a template for the new resources that are in
    the system.

Arguments:

    List    - Pointer to the CM_RESOURCE_LIST that we wish to assign
    Data    - Where we wish to store the data, and the template for it

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                        status = STATUS_SUCCESS;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PUCHAR                          buffer;
    UCHAR                           tagName;
    USHORT                          increment;

    PAGED_CODE();

    ASSERT( Data != NULL );

    //
    // Setup initial variables.
    //
    buffer = Data;
    tagName = *buffer;

    //
    // The algorithm we use is that we examine each tag in the buffer, and try to
    // match it with an entry in the resource list. So we take the convertion routine
    // for the previous problem and turn it upside down.
    //
    while (1) {

        //
        // Determine the size of the PNP resource descriptor
        //
        if ( !(tagName & LARGE_RESOURCE_TAG) ) {

            //
            // Small Tag
            //
            increment = (USHORT) (tagName & SMALL_TAG_SIZE_MASK) + 1;
            tagName &= SMALL_TAG_MASK;

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpCmResourcesToBiosResources: small tag = %#02lx increment = %#02lx\n",
                tagName, increment
                ) );

        } else {

            //
            // Large Tag
            //
            increment = ( *(USHORT UNALIGNED *)(buffer+1) ) + 3;

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpCmResourcesToBiosResources: large tag = %#02lx increment = %#02lx\n",
                tagName, increment
                ) );

        }

        //
        // We are done if the current tag is the end tag
        //
        if (tagName == TAG_END) {

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpCmResourcesToBiosResources: TAG_END\n"
                ) );

            break;

        }


        switch(tagName) {
            case TAG_IRQ:

                status = PnpiCmResourceToBiosIrq( buffer, List );
                break;

            case TAG_EXTENDED_IRQ:

                status = PnpiCmResourceToBiosExtendedIrq( buffer, List );
                break;

            case TAG_DMA:

                status = PnpiCmResourceToBiosDma( buffer, List );
                break;

            case TAG_START_DEPEND:

                ASSERT( tagName != TAG_START_DEPEND );
                break;

            case TAG_END_DEPEND:

                ASSERT( tagName != TAG_END_DEPEND );
                break;

            case TAG_IO:

                status = PnpiCmResourceToBiosIoPort( buffer, List );
                break;

            case TAG_IO_FIXED:

                status = PnpiCmResourceToBiosIoFixedPort( buffer, List );
                break;

            case TAG_MEMORY:

                status = PnpiCmResourceToBiosMemory( buffer, List );
                break;

            case TAG_MEMORY32:

                status = PnpiCmResourceToBiosMemory32( buffer, List );
                break;

            case TAG_MEMORY32_FIXED:

                status = PnpiCmResourceToBiosMemory32Fixed( buffer, List );
                break;

            case TAG_WORD_ADDRESS:

                status = PnpiCmResourceToBiosAddress( buffer, List );
                break;

           case TAG_DOUBLE_ADDRESS:

                status = PnpiCmResourceToBiosAddressDouble( buffer, List );
                break;

            case TAG_VENDOR:

                //
                // Ignore this tag
                //
                break;

            default: {

                //
                // Unknown tag. Skip it
                //
                ACPIPrint( (
                    ACPI_PRINT_WARNING,
                    "PnpBiosResourceToNtResources: TAG_UNKNOWN [tagName = %#02lx]\n",
                    tagName
                    ) );

                break;
            }

        } // switch
        //
        // Did we fail?
        //
        if (!NT_SUCCESS(status)) {

            break;

        }

        //
        // Move to the next descriptor
        //
        buffer += increment;
        tagName = *buffer;

    }

    if (!( NT_SUCCESS(status) )) {

        return status;

    }

    //
    // Check to see if we have consumed all of the appropriate resources...
    //
    if (PnpiCmResourceValidEmptyList( List ) ) {

        //
        // We failed to empty the list... <sigh>
        //
        return STATUS_UNSUCCESSFUL;

    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\root.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    root.h

Abstract:

    This module contains the root FDO handler for the NT Driver

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _ROOT_H_
#define _ROOT_H_

    NTSTATUS
    ACPIRootIrpCancelRemoveOrStopDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpCompleteRoutine(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp,
        IN  PVOID           Context
        );

    NTSTATUS
    ACPIRootIrpQueryCapabilities(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpQueryDeviceRelations(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpQueryBusRelations(
        IN  PDEVICE_OBJECT    DeviceObject,
        IN  PIRP              Irp,
        OUT PDEVICE_RELATIONS *PdeviceRelation
        );

    NTSTATUS
    ACPIRootIrpQueryInterface(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpQueryPower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpQueryRemoveOrStopDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpRemoveDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpSetPower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpStartDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpStopDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpUnhandled(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID
    ACPIRootPowerCallBack(
        IN  PVOID   CallBackContext,
        IN  PVOID   Argument1,
        IN  PVOID   Argument2
        );

    NTSTATUS
    ACPIRootUpdateRootResourcesWithBusResources(
        VOID
        );

    NTSTATUS
    ACPIRootUpdateRootResourcesWithHalResources(
        VOID
        );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\reg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    regcd.c

Abstract:

    This contains all of the registry munging code of the NT-specific
    side of the ACPI driver

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    31-Mar-96 Initial Revision

--*/

#include "pch.h"

NTSTATUS
OSOpenUnicodeHandle(
    PUNICODE_STRING UnicodeKey,
    HANDLE          ParentHandle,
    PHANDLE         ChildHandle
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,OSCloseHandle)
#pragma alloc_text(PAGE,OSCreateHandle)
#pragma alloc_text(PAGE,OSGetRegistryValue)
#pragma alloc_text(PAGE,OSOpenHandle)
#pragma alloc_text(PAGE,OSOpenUnicodeHandle)
#pragma alloc_text(PAGE,OSOpenLargestSubkey)
#pragma alloc_text(PAGE,OSReadAcpiConfigurationData)
#pragma alloc_text(PAGE,OSReadRegValue)
#pragma alloc_text(PAGE,OSWriteRegValue)
#endif

WCHAR   rgzAcpiBiosIdentifier[]                 = L"ACPI BIOS";
WCHAR   rgzAcpiConfigurationDataIdentifier[]    = L"Configuration Data";
WCHAR   rgzAcpiMultiFunctionAdapterIdentifier[] = L"\\Registry\\Machine\\Hardware\\Description\\System\\MultiFunctionAdapter";
WCHAR   rgzAcpiRegistryIdentifier[]             = L"Identifier";


NTSTATUS
OSCloseHandle(
    HANDLE  Key
    )
{

    //
    // Call the function that will close the handle now...
    //
    PAGED_CODE();
    return ZwClose( Key );

}

NTSTATUS
OSCreateHandle(
    PSZ     KeyName,
    HANDLE  ParentHandle,
    PHANDLE ChildHandle
    )
/*++

Routine Description:

    Creates a registry key for writting

Arguments:

    KeyName        - Name of the key to create
    ParentHandle    - Handle of parent key
    ChildHandle     - Pointer to where the handle is returned

Return Value:

    Status of create/open

--*/
{
    ANSI_STRING         ansiKey;
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      unicodeKey;

    PAGED_CODE();
    ACPIDebugEnter("OSCreateHandle");

    //
    // We need to convert the given narrow character string into unicode
    //
    RtlInitAnsiString( &ansiKey, KeyName );
    status = RtlAnsiStringToUnicodeString( &unicodeKey, &ansiKey, TRUE );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSCreateHandle: RtlAnsiStringToUnicodeString = %#08lx\n",
            status
            ) );
        return status;
    }

    //
    // Initialize the OBJECT Attributes to a known value
    //
    RtlZeroMemory( &objectAttributes, sizeof(OBJECT_ATTRIBUTES) );
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeKey,
        OBJ_CASE_INSENSITIVE,
        ParentHandle,
        NULL
        );

    //
    // Create the key here
    //
    *ChildHandle = 0;
    status = ZwCreateKey(
        ChildHandle,
        KEY_WRITE,
        &objectAttributes,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        NULL
        );

    //
    // We no longer care about the Key after this point...
    //
    RtlFreeUnicodeString( &unicodeKey );

    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_REGISTRY,
            "OSCreateHandle: ZwCreateKey = %#08lx\n",
            status
            ) );
    }

    return status;

    ACPIDebugExit("OSCreateHandle");
}

NTSTATUS
OSGetRegistryValue(
    IN  HANDLE                          ParentHandle,
    IN  PWSTR                           ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  *Information
    )
{
    NTSTATUS                        status;
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  infoBuffer;
    ULONG                           keyValueLength;
    UNICODE_STRING                  unicodeString;

    PAGED_CODE();
    ACPIDebugEnter("OSGetRegistryValue");

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that we can allocate the
    // proper sized buffer
    //
    status = ZwQueryValueKey(
        ParentHandle,
        &unicodeString,
        KeyValuePartialInformationAlign64,
        (PVOID) NULL,
        0,
        &keyValueLength
        );
    if (status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL) {

        return status;

    }

    //
    // Allocate a buffer large enough to contain the entire key data value
    //
    infoBuffer = ExAllocatePoolWithTag(
        NonPagedPool,
        keyValueLength,
        ACPI_STRING_POOLTAG
        );
    if (infoBuffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Now query the data again and this time it will work
    //
    status = ZwQueryValueKey(
        ParentHandle,
        &unicodeString,
        KeyValuePartialInformationAlign64,
        (PVOID) infoBuffer,
        keyValueLength,
        &keyValueLength
        );
    if (!NT_SUCCESS(status)) {

        ExFreePool( infoBuffer );
        return status;

    }

    //
    // Everything worked - so simply return the address of the allocated
    // structure buffer to the caller, who is now responsible for freeing it
    //
    *Information = infoBuffer;
    return STATUS_SUCCESS;

    ACPIDebugExit("OSGetRegistryValue");
}

NTSTATUS
OSOpenHandle(
    PSZ     KeyName,
    HANDLE  ParentHandle,
    PHANDLE ChildHandle
    )
{
    ANSI_STRING         ansiKey;
    NTSTATUS            status;
    UNICODE_STRING      unicodeKey;

    PAGED_CODE();
    ACPIDebugEnter("OSOpenHandle");

    //
    // We need to convert the given narrow character string into unicode
    //
    RtlInitAnsiString( &ansiKey, KeyName );
    status = RtlAnsiStringToUnicodeString( &unicodeKey, &ansiKey, TRUE );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSOpenHandle: RtlAnsiStringToUnicodeString = %#08lx\n",
            status
            ) );
        return status;

    }

    status = OSOpenUnicodeHandle( &unicodeKey, ParentHandle, ChildHandle );

    //
    // We no longer care about the Key after this point...
    //
    RtlFreeUnicodeString( &unicodeKey );

    return status;

    ACPIDebugExit("OSOpenHandle");
}

NTSTATUS
OSOpenUnicodeHandle(
    PUNICODE_STRING UnicodeKey,
    HANDLE          ParentHandle,
    PHANDLE         ChildHandle
    )
{
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objectAttributes;

    PAGED_CODE();

    //
    // Initialize the OBJECT Attributes to a known value
    //
    RtlZeroMemory( &objectAttributes, sizeof(OBJECT_ATTRIBUTES) );
    InitializeObjectAttributes(
        &objectAttributes,
        UnicodeKey,
        OBJ_CASE_INSENSITIVE,
        ParentHandle,
        NULL
        );

    //
    // Open the key here
    //
    status = ZwOpenKey(
        ChildHandle,
        KEY_READ,
        &objectAttributes
        );

    if (!NT_SUCCESS(status)) {
        ACPIPrint( (
            ACPI_PRINT_REGISTRY,
            "OSOpenUnicodeHandle: ZwOpenKey = %#08lx\n",
            status
            ) );

    }

    return status;
}

NTSTATUS
OSOpenLargestSubkey(
    HANDLE                  ParentHandle,
    PHANDLE                 ChildHandle,
    ULONG                   RomVersion
    )
/*++

Routine Description:

    Open the largest (numerically) subkey under the given parent key.

Arguments:

    ParentHandle    - Handle to the parent key
    ChildHandle     - Pointer to where the handle is returned
    RomVersion      - Minimum version number that is acceptable

Return Value:

    Status of open

--*/
{
    NTSTATUS                status;
    UNICODE_STRING          unicodeName;
    PKEY_BASIC_INFORMATION  keyInformation;
    ULONG                   resultLength;
    ULONG                   i;
    HANDLE                  workingDir = NULL;
    HANDLE                  largestDir = NULL;
    ULONG                   largestRev = 0;
    ULONG                   thisRev = 0;


    PAGED_CODE();
    ACPIDebugEnter( "OSOpenLargestSubkey" );

    keyInformation = ExAllocatePoolWithTag(
        PagedPool,
        512,
        ACPI_MISC_POOLTAG
        );
    if (keyInformation == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Traverse all subkeys
    //
    for (i = 0; ; i++) {

        //
        // Get a subkey
        //
        status = ZwEnumerateKey(
                ParentHandle,
                i,
                KeyBasicInformation,
                keyInformation,
                512,
                &resultLength
                );
        if (!NT_SUCCESS(status)) {          // Fail when no more subkeys
            break;
        }

        //
        // Create a UNICODE_STRING using the counted string passed back to
        // us in the information structure, and convert to an integer.
        //
        unicodeName.Length          = (USHORT) keyInformation->NameLength;
        unicodeName.MaximumLength   = (USHORT) keyInformation->NameLength;
        unicodeName.Buffer          = keyInformation->Name;
        RtlUnicodeStringToInteger(&unicodeName, 16, &thisRev);

        //
        // Save this one if it is the largest
        //
        if ( (workingDir == NULL) || thisRev > largestRev) {

            //
            // We'll just open the target rather than save
            // away the name to open later
            //
            status = OSOpenUnicodeHandle(
                &unicodeName,
                ParentHandle,
                &workingDir
                );
            if ( NT_SUCCESS(status) ) {

                if (largestDir) {

                    OSCloseHandle (largestDir);       // Close previous

                }
                largestDir = workingDir;        // Save handle
                largestRev = thisRev;           // Save version number

           }

        }

    }

    //
    // Done with KeyInformation
    //
    ExFreePool( keyInformation );

    //
    // No subkey found/opened, this is a problem
    //
    if (largestDir == NULL) {

        return ( NT_SUCCESS(status) ? STATUS_UNSUCCESSFUL : status );

    }

    //
    // Use the subkey only if it the revision is equal or greater than the
    // ROM version
    //
    if (largestRev < RomVersion) {

        OSCloseHandle (largestDir);
        return STATUS_REVISION_MISMATCH;

    }

    *ChildHandle = largestDir;       // Return handle to subkey
    return STATUS_SUCCESS;

    ACPIDebugExit( "OSOpenLargestSubkey" );
}

NTSTATUS
OSReadAcpiConfigurationData(
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  *KeyInfo
    )
/*++

Routine Description:

    This very specialized routine looks in the Registry and tries to find
    the information that was written there by ntdetect. It returns a pointer
    to the keyvalue that will then be processed by the caller to find the
    pointer to the RSDT and the E820 memory table

Arguments:

    KeyInfo - Where to store the pointer to the information from the registry

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN         sameId;
    HANDLE          functionHandle;
    HANDLE          multiHandle;
    NTSTATUS        status;
    ULONG           i;
    ULONG           length;
    UNICODE_STRING  biosId;
    UNICODE_STRING  functionId;
    UNICODE_STRING  registryId;
    WCHAR           wbuffer[4];

    ASSERT( KeyInfo != NULL );
    if (KeyInfo == NULL) {

        return STATUS_INVALID_PARAMETER;

    }
    *KeyInfo = NULL;

    //
    // Open the handle for the MultiFunctionAdapter
    //
    RtlInitUnicodeString( &functionId, rgzAcpiMultiFunctionAdapterIdentifier );
    status = OSOpenUnicodeHandle(
        &functionId,
        NULL,
        &multiHandle
        );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSReadAcpiConfigurationData: Cannot open MFA Handle = %08lx\n",
            status
            ) );
        ACPIBreakPoint();
        return status;

    }

    //
    // Initialize the unicode strings we will need shortly
    //
    RtlInitUnicodeString( &biosId, rgzAcpiBiosIdentifier );
    functionId.Buffer = wbuffer;
    functionId.MaximumLength = sizeof(wbuffer);

    //
    // Loop until we run out of children in the MFA node
    //
    for (i = 0; i < 999; i++) {

        //
        // Open the subkey
        //
        RtlIntegerToUnicodeString(i, 10, &functionId );
        status = OSOpenUnicodeHandle(
            &functionId,
            multiHandle,
            &functionHandle
            );
        if (!NT_SUCCESS(status)) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "OSReadAcpiConfigurationData: Cannot open MFA %ws = %08lx\n",
                functionId.Buffer,
                status
                ) );
            ACPIBreakPoint();
            OSCloseHandle( multiHandle );
            return status;

        }

        //
        // Check the identifier to see if this is an ACPI BIOS entry
        //
        status = OSGetRegistryValue(
            functionHandle,
            rgzAcpiRegistryIdentifier,
            KeyInfo
            );
        if (!NT_SUCCESS(status)) {

            OSCloseHandle( functionHandle );
            continue;

        }

        //
        // Convert the key information into a unicode string
        //
        registryId.Buffer = (PWSTR) ( (PUCHAR) (*KeyInfo)->Data);
        registryId.MaximumLength = (USHORT) ( (*KeyInfo)->DataLength );
        length = ( (*KeyInfo)->DataLength ) / sizeof(WCHAR);

        //
        // Determine the real length of the ID string
        //
        while (length) {

            if (registryId.Buffer[length-1] == UNICODE_NULL) {

                length--;
                continue;

            }
            break;

        }
        registryId.Length = (USHORT) ( length * sizeof(WCHAR) );

        //
        // Compare the bios string and the registry string
        //
        sameId = RtlEqualUnicodeString( &biosId, &registryId, TRUE );

        //
        // We are done with this information at this point
        //
        ExFreePool( *KeyInfo );

        //
        // Did the two strings match
        //
        if (sameId == FALSE) {

            OSCloseHandle( functionHandle );
            continue;

        }

        //
        // Read the configuration data from the entry
        //
        status = OSGetRegistryValue(
            functionHandle,
            rgzAcpiConfigurationDataIdentifier,
            KeyInfo
            );

        //
        // We are done with the function handle, no matter what
        //
        OSCloseHandle( functionHandle );

        //
        // Did we read what we wanted to?
        //
        if (!NT_SUCCESS(status)) {

            continue;

        }

        //
        // At this point, we don't need the bus handle
        //
        OSCloseHandle( multiHandle );
        return STATUS_SUCCESS;

    }

    //
    // If we got here, then there is nothing to return
    //
    ACPIPrint( (
        ACPI_PRINT_CRITICAL,
        "OSReadAcpiConfigurationData - Could not find entry\n"
        ) );
    ACPIBreakPoint();
    return STATUS_OBJECT_NAME_NOT_FOUND;
}

NTSTATUS
OSReadRegValue(
    PSZ     ValueName,
    HANDLE  ParentHandle,
    PUCHAR  Buffer,
    PULONG  BufferSize
    )
/*++

Routine Description:

    This function is responsible for returning the data in the specified value
    over to the calling function.

Arguments:

    ValueName       - What we are looking for
    ParentHandle    - Our Parent Handle
    Buffer          - Where to store the data
    BufferSize      - Length of the buffer and where to store the # read

Return Value:

    NTSTATUS

--*/
{
    ANSI_STRING                     ansiValue;
    HANDLE                          localHandle = NULL;
    NTSTATUS                        status;
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  data = NULL;
    ULONG                           currentLength = 0;
    ULONG                           desiredLength = 0;
    UNICODE_STRING                  unicodeValue;

    PAGED_CODE();
    ACPIDebugEnter( "OSReadRegValue" );

    //
    // First, try to open a handle to the key
    //
    if (ParentHandle == NULL) {

        status= OSOpenHandle(
            ACPI_PARAMETERS_REGISTRY_KEY,
            0,
            &localHandle
            );
        if (!NT_SUCCESS(status) || localHandle == NULL) {

            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "OSReadRegValue: OSOpenHandle = %#08lx\n",
                status
                ) );
            return (ULONG) status;

        }

    } else {

        localHandle = ParentHandle;

    }

    //
    // Now that we have an open handle, we can convert the value to a
    // unicode string and query it
    //
    RtlInitAnsiString( &ansiValue, ValueName );
    status = RtlAnsiStringToUnicodeString( &unicodeValue, &ansiValue, TRUE );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSReadRegValue: RtlAnsiStringToUnicodeString = %#08lx\n",
            status
            ) );
        if (ParentHandle == NULL) {

            OSCloseHandle( localHandle );

        }
        return status;

    }

    //
    // Next, we need to figure out how much memore we need to hold the
    // entire key
    //
    status = ZwQueryValueKey(
        localHandle,
        &unicodeValue,
        KeyValuePartialInformationAlign64,
        data,
        currentLength,
        &desiredLength
        );

    //
    // We expect this to fail with STATUS_BUFFER_OVERFLOW, so lets make
    // sure that this is what happened
    //
    if (status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL) {

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "OSReadRegValue: ZwQueryValueKey = %#08lx\n",
            status
            ) );

        //
        // Free resources
        //
        RtlFreeUnicodeString( &unicodeValue );
        if (ParentHandle == NULL) {

            OSCloseHandle( localHandle );

        }
        return (NT_SUCCESS(status) ? STATUS_UNSUCCESSFUL : status);

    }

    while (status == STATUS_BUFFER_OVERFLOW ||
           status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Set the new currentLength
        //
        currentLength = desiredLength;

        //
        // Allocate a correctly sized buffer
        //
        data = ExAllocatePoolWithTag(
            PagedPool,
            currentLength,
            ACPI_MISC_POOLTAG
            );
        if (data == NULL) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "OSReadRegValue: ExAllocatePool(NonPagedPool,%#08lx) failed\n",
                desiredLength
                ) );

            RtlFreeUnicodeString( &unicodeValue );
            if (ParentHandle == NULL) {

                OSCloseHandle( localHandle );

            }
            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Actually try to read the entire key now
        //
        status = ZwQueryValueKey(
            localHandle,
            &unicodeValue,
            KeyValuePartialInformationAlign64,
            data,
            currentLength,
            &desiredLength
            );

        //
        // If we don't have enough resources, lets just loop again
        //
        if (status == STATUS_BUFFER_OVERFLOW ||
            status == STATUS_BUFFER_TOO_SMALL) {

            //
            // Make sure to free the old buffer -- otherwise, we could
            // have a major memory leak
            //
            ExFreePool( data );
            continue;

        }

        if (!NT_SUCCESS(status)) {

            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                "OSReadRegValue: ZwQueryValueKey = %#08lx\n",
                status
                ) );
            RtlFreeUnicodeString( &unicodeValue );
            if (ParentHandle == NULL) {

                OSCloseHandle( localHandle );

            }
            ExFreePool( data );
            return status;

        }

        //
        // Done
        //
        break;

    } // while (status == ...

    //
    // Free Resources
    //
    RtlFreeUnicodeString( &unicodeValue );
    if (ParentHandle == NULL) {

        OSCloseHandle( localHandle );

    }

    //
    // The value read from the registry is a UNICODE Value, however
    // we are asked for an ANSI string. So we just work the conversion
    // backwards
    //
    if ( data->Type == REG_SZ ||
         data->Type == REG_MULTI_SZ) {

        RtlInitUnicodeString( &unicodeValue, (PWSTR) data->Data );
        status = RtlUnicodeStringToAnsiString( &ansiValue, &unicodeValue, TRUE);
        ExFreePool( data );
        if (!NT_SUCCESS(status)) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "OSReadRegValue: RtlAnsiStringToUnicodeString = %#08lx\n",
                status
                ) );
            return (ULONG) status;

        }

        //
        // Is our buffer big enough?
        //
        if ( *BufferSize < ansiValue.MaximumLength) {

            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "OSReadRegValue: %#08lx < %#08lx\n",
                *BufferSize,
                ansiValue.MaximumLength
                ) );

            RtlFreeAnsiString( &ansiValue );
            return (ULONG) STATUS_BUFFER_OVERFLOW;

        } else {

            //
            // Set the returned size
            //
            *BufferSize = ansiValue.MaximumLength;

        }

        //
        // Copy the required information
        //
        RtlCopyMemory( Buffer, ansiValue.Buffer, *BufferSize);
        RtlFreeAnsiString( &ansiValue );

    } else if ( *BufferSize >= data->DataLength) {

        //
        // Copy the memory
        //
        RtlCopyMemory( Buffer, data->Data, data->DataLength );
        *BufferSize = data->DataLength;
        ExFreePool( data );

    } else {

        ExFreePool( data );
        return STATUS_BUFFER_OVERFLOW;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;

    ACPIDebugExit( "OSReadRegValue" );

}

NTSTATUS
OSWriteRegValue(
    PSZ     ValueName,
    HANDLE  Handle,
    PVOID   Data,
    ULONG   DataSize
    )
/*++

Routine Description:

    Creates a value item in a registry key, and writes data to it

Arguments:

    ValueName       - Name of the value item to create
    Handle          - Handle of the parent key
    Data            - Raw data to be written to the value
    DataSize        - Size of the data to write

Return Value:

    Status of create/write

--*/
{
    ANSI_STRING         ansiKey;
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      unicodeKey;

    PAGED_CODE();
    ACPIDebugEnter("OSWriteRegValue");

    //
    // We need to convert the given narrow character string into unicode
    //
    RtlInitAnsiString( &ansiKey, ValueName );
    status = RtlAnsiStringToUnicodeString( &unicodeKey, &ansiKey, TRUE );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSWriteRegValue: RtlAnsiStringToUnicodeString = %#08lx\n",
            status
            ) );
        return status;

    }

    //
    // Create the value
    //
    status = ZwSetValueKey(
        Handle,
        &unicodeKey,
        0,
        REG_BINARY,
        Data,
        DataSize
        );

    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_REGISTRY,
            "OSRegWriteValue: ZwSetValueKey = %#08lx\n",
            status
            ) );

    }

    //
    // We no longer care about the Key after this point...
    //
    RtlFreeUnicodeString( &unicodeKey );
    return status;

    ACPIDebugExit("OSRegWriteValue");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\res_cm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    res_cm.h

Abstract:

    Converts from NT to Pnp resources

Author:

    Stephane Plante (splante) Feb 13, 1997

Revision History:

--*/

#ifndef _RES_CM_H_
#define _RES_CM_H_

    NTSTATUS
    PnpiCmResourceToBiosAddress(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosAddressDouble(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosDma(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosExtendedIrq(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosIoFixedPort(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosIoPort(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosIrq(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosMemory(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosMemory32(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosMemory32Fixed(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    BOOLEAN
    PnpiCmResourceValidEmptyList(
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpCmResourcesToBiosResources(
        IN  PCM_RESOURCE_LIST   List,
        IN  PUCHAR              Data
        );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\root.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    root.c

Abstract:

    This module contains the root FDO handler for the NT Driver

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July-09-97  Added support to Unify QueryDeviceRelations from filter.c

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIRootIrpCancelRemoveOrStopDevice)
#pragma alloc_text(PAGE, ACPIRootIrpQueryBusRelations)
#pragma alloc_text(PAGE, ACPIRootIrpQueryCapabilities)
#pragma alloc_text(PAGE, ACPIRootIrpQueryDeviceRelations)
#pragma alloc_text(PAGE, ACPIRootIrpQueryRemoveOrStopDevice)
#pragma alloc_text(PAGE, ACPIRootIrpStartDevice)
#pragma alloc_text(PAGE, ACPIRootIrpStopDevice)
#pragma alloc_text(PAGE, ACPIRootIrpQueryInterface)
#endif


NTSTATUS
ACPIRootIrpCancelRemoveOrStopDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine transitions the device from the inactive to the
    started state

Arguments:

    DeviceObject    - The target
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Where we allowed to stop the device? If so, then undo whatever it
    // was we did, otherwise let the world know about the cancel
    //

    if (!(deviceExtension->Flags & DEV_CAP_NO_STOP) ) {

        //
        // Check to see if we have placed this device in the inactive state
        //
        if (deviceExtension->DeviceState == Inactive) {

            //
            // Mark the device state to its previous state
            //
            deviceExtension->DeviceState = deviceExtension->PreviousState;

        }


    }

    //
    // We are successfull
    //
    Irp->IoStatus.Status = status;

    //
    // Pass the Irp Along
    //
    Irp->IoStatus.Status = STATUS_SUCCESS ;
    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIRootIrpCompleteRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This is the routine that is called when one of the IRPS that was
    noticed by ACPIRootIrp* and was judged to be an IRP that we need
    to examine later on...

Arguments:

    DeviceObject    - A pointer to the Filter Object
    Irp             - A pointer to the completed request
    Context         - Whatever Irp-dependent information we need to know

Return Value:

    NTSTATUS
--*/
{
    PKEVENT             event           = (PKEVENT) Context;
#if DBG
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    if (deviceExtension != NULL) {

        //
        // Let the world know what we just got...
        //
        ACPIDevPrint( (
            ACPI_PRINT_IRP,
            deviceExtension,
            "(%#08lx): %s = %#08lx (Complete)\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, irpStack->MinorFunction),
            Irp->IoStatus.Status
            ) );

    }
#endif

    //
    // Signal the event
    //
    KeSetEvent( event, IO_NO_INCREMENT, FALSE );

    //
    // Always return MORE_PROCESSING_REQUIRED
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
ACPIRootIrpQueryBusRelations(
    IN  PDEVICE_OBJECT    DeviceObject,
    IN  PIRP              Irp,
    OUT PDEVICE_RELATIONS *PdeviceRelations
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_DEVICE_RELATIONS
    requests sent to the Root or Filter Device Objects

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            detectStatus;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              acpiObject      = NULL;
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // lets look at the ACPIObject that we have and we can see
    // if it is valid
    //
    acpiObject = deviceExtension->AcpiObject;
    ASSERT( acpiObject != NULL );
    if (acpiObject == NULL) {

       ACPIDevPrint( (
           ACPI_PRINT_WARNING,
           deviceExtension,
           "(%#08lx): %s - Invalid ACPI Object %#08lx\n",
           Irp,
           ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
           acpiObject
           ) );

       //
       // Fail the IRP.
       //
       return STATUS_INVALID_PARAMETER;
    }

    //
    // Detect which PDOs are missing
    //
    detectStatus = ACPIDetectPdoDevices(
        DeviceObject,
        PdeviceRelations
        );

    //
    // If something went well along the way, yell a bit
    //
    if ( !NT_SUCCESS(detectStatus) ) {

        ACPIDevPrint( (
            ACPI_PRINT_WARNING,
            deviceExtension,
            "(%#08lx): %s - Enum Failed %#08lx\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            detectStatus
            ) );

    }

    //
    // Detect which profile providers are missing
    //
    if ( NT_SUCCESS(detectStatus)) {

        detectStatus = ACPIDetectDockDevices(
            deviceExtension,
            PdeviceRelations
            );

        //
        // If something went well along the way, yell a bit
        //
        if ( !NT_SUCCESS(detectStatus) ) {

            ACPIDevPrint( (
                ACPI_PRINT_WARNING,
                deviceExtension,
                "(%#08lx): %s - Dock Enum Failed "
                "%#08lx\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
                detectStatus
                ) );

        }

    }

    //
    // Done
    //
    return detectStatus;
}

NTSTATUS
ACPIRootIrpQueryCapabilities(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine fills in the capabilities for the root device

Arguments:

    DeviceObject    - The object whose capabilities to get
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    KEVENT                  event;
    NTSTATUS                status          = STATUS_SUCCESS;
    PDEVICE_CAPABILITIES    capabilities;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION      irpStack;
    UCHAR                   minorFunction;

    PAGED_CODE();

    //
    // Setup the Event so that we are notified of when this done
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Copy the stack location
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // We want our completion routine to fire...
    //
    IoSetCompletionRoutine(
        Irp,
        ACPIRootIrpCompleteRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Let the IRP execute
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );
    if (status == STATUS_PENDING) {

        //
        // Wait for it
        //
        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab the 'real' status
        //
        status = Irp->IoStatus.Status;

    }

    //
    // Look at the current stack location
    //
    irpStack = IoGetCurrentIrpStackLocation( Irp );
    minorFunction = irpStack->MinorFunction;

    //
    // What happened?
    //
    if (!NT_SUCCESS(status)) {

        //
        // Failure
        //
        goto ACPIRootIrpQueryCapabilitiesExit;

    }

    //
    // Grab a pointer to the capabilitites
    //
    capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;
#ifndef HANDLE_BOGUS_CAPS
    if (capabilities->Version < 1) {

        //
        // do not touch irp!
        //
        goto ACPIRootIrpQueryCapabilitiesExit;

    }
#endif

    //
    // Set the capabilities that we know about
    //
    capabilities->LockSupported = FALSE;
    capabilities->EjectSupported = FALSE;
    capabilities->Removable = FALSE;
    capabilities->UINumber = (ULONG) -1;
    capabilities->UniqueID = TRUE;
    capabilities->RawDeviceOK = FALSE;
    capabilities->SurpriseRemovalOK = FALSE;
    capabilities->Address = (ULONG) -1;
    capabilities->DeviceWake = PowerDeviceUnspecified;
    capabilities->SystemWake = PowerDeviceUnspecified;

    //
    // build the power table properly yet?
    //
    status = ACPISystemPowerInitializeRootMapping(
        deviceExtension,
        capabilities
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): %s - InitializeRootMapping = %08lx\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            status
            ) );
        goto ACPIRootIrpQueryCapabilitiesExit;

    }

ACPIRootIrpQueryCapabilitiesExit:

    //
    // Have happily finished with this irp
    //
    Irp->IoStatus.Status = status;

    //
    // Complete the Irp
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}


NTSTATUS
ACPIRootIrpQueryDeviceRelations(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_DEVICE_RELATIONS
    requests sent to the Root or Filter Device Objects

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             checkForFilters = FALSE;
    KEVENT              queryEvent;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_RELATIONS   deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;
    NTSTATUS            detectStatus;

    PAGED_CODE();

    switch(irpStack->Parameters.QueryDeviceRelations.Type) {

        case BusRelations:

            //
            // Remember to check for filters later on...
            //
            checkForFilters = TRUE;

            //
            // Get the real bus relations
            //
            status = ACPIRootIrpQueryBusRelations(
                DeviceObject,
                Irp,
                &deviceRelations
                );
            break ;

        default:
            status = STATUS_NOT_SUPPORTED ;
            ACPIDevPrint( (
                ACPI_PRINT_WARNING,
                deviceExtension,
                "(%#08lx): %s - Unhandled Type %d\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
                irpStack->Parameters.QueryDeviceRelations.Type
                ) );
            break ;
    }

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s (d) = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    if (NT_SUCCESS(status)) {

        //
        // Pass the IRP status along
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

    } else if ((status != STATUS_NOT_SUPPORTED) && (deviceRelations == NULL)) {

        //
        // If we haven't succeed the irp, then we can also fail it
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) NULL;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;

    } else {

        //
        // Either someone above us added an entry or we did not have anything
        // to add. Therefore, we do not touch this IRP, but simply pass it down.
        //
    }

    //
    // Initialize an event so that we can block
    //
    KeInitializeEvent( &queryEvent, SynchronizationEvent, FALSE );

    //
    // If we succeeded, then we must set a completion routine so that we
    // can do some post-processing
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );
    IoSetCompletionRoutine(
        Irp,
        ACPIRootIrpCompleteRoutine,
        &queryEvent,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Pass the irp along
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Wait for it to come back...
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &queryEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab the 'real' status
        //
        status = Irp->IoStatus.Status;

    }

    //
    // Read back the device relations (they may have changed)
    //
    deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;

    //
    // If we succeeded, then we should try to load the filters
    //
    if ( (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED) ) &&
         checkForFilters == TRUE) {

        //
        // Grab the device relations
        //
        detectStatus = ACPIDetectFilterDevices(
            DeviceObject,
            deviceRelations
            );
        ACPIDevPrint( (
            ACPI_PRINT_IRP,
            deviceExtension,
            "(0x%08lx): %s (u) = %#08lx\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            detectStatus
            ) );

    }

    //
    // Done with the IRP
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIRootIrpQueryInterface(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine handles IRP_MN_QUERY_INTERFACE requests for the ACPI FDO.
    It will eject an arbiter interface for interrupts.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    ARBITER_INTERFACE   ArbiterTable;
    CM_RESOURCE_TYPE    resource;
    NTSTATUS            status;
    GUID                *interfaceType;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    ULONG               count;
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Obtain the info we will need from the irp
    //
    resource = (CM_RESOURCE_TYPE)
        PtrToUlong(irpStack->Parameters.QueryInterface.InterfaceSpecificData);
    interfaceType = (LPGUID) irpStack->Parameters.QueryInterface.InterfaceType;

#if DBG
    {
        NTSTATUS        status2;
        UNICODE_STRING  guidString;

        status2 = RtlStringFromGUID( interfaceType, &guidString );
        if (NT_SUCCESS(status2)) {

            ACPIDevPrint( (
                ACPI_PRINT_IRP,
                deviceExtension,
                "(0x%08lx): %s - Res %x Type = %wZ\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, irpStack->MinorFunction),
                resource,
                &guidString
                ) );

            RtlFreeUnicodeString( &guidString );

        }
    }
#endif

    //
    // *Only* Handle the Guids that we know about. Do Not Ever touch
    // any other GUID
    //
    if ((CompareGuid(interfaceType, (PVOID) &GUID_ARBITER_INTERFACE_STANDARD)) &&
               (resource == CmResourceTypeInterrupt)){

        //
        // Only copy up to current size of the ARBITER_INTERFACE structure
        //
        if (irpStack->Parameters.QueryInterface.Size >
            sizeof (ARBITER_INTERFACE) ) {

            count = sizeof (ARBITER_INTERFACE);

        } else {

            count = irpStack->Parameters.QueryInterface.Size;
        }

        ArbiterTable.Size = sizeof(ARBITER_INTERFACE);
        ArbiterTable.Version = 1;
        ArbiterTable.InterfaceReference = AcpiNullReference;
        ArbiterTable.InterfaceDereference = AcpiNullReference;
        ArbiterTable.ArbiterHandler = &ArbArbiterHandler;
        ArbiterTable.Context = &AcpiArbiter.ArbiterState;
        ArbiterTable.Flags = 0; // Do not set ARBITER_PARTIAL here

        //
        // Copy the arbiter table.
        //
        RtlCopyMemory(irpStack->Parameters.QueryInterface.Interface,
                      &ArbiterTable,
                      count);

        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        Irp->IoStatus.Status
        ) );

    return ACPIDispatchForwardIrp( DeviceObject, Irp );
}

NTSTATUS
ACPIRootIrpQueryPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine handles the QUERY_POWER sent to the root FDO. It succeeds
    the query if ACPI supports the listed system state

Arguments:

    DeviceObject    - The Target
    Irp             - The Request

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             passDown = TRUE;
    NTSTATUS            status = Irp->IoStatus.Status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpSp;
    PNSOBJ              object;
    SYSTEM_POWER_STATE  systemState;
    ULONG               objectName;

    //
    // Get the Current stack location to determine if we are a system
    // irp or a device irp. We ignore device irps here.
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);
    if (irpSp->Parameters.Power.Type != SystemPowerState) {

        //
        // We don't handle this irp
        //
        goto ACPIRootIrpQueryPowerExit;

    }
    if (irpSp->Parameters.Power.ShutdownType == PowerActionWarmEject) {

        //
        // We definately don't allow the ejection of this node
        //
        passDown = FALSE;
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto ACPIRootIrpQueryPowerExit;

    }

    //
    // What system state are we looking at?
    //
    systemState = irpSp->Parameters.Power.State.SystemState;
    switch (systemState) {
        case PowerSystemWorking:   objectName = PACKED_S0; break;
        case PowerSystemSleeping1: objectName = PACKED_S1; break;
        case PowerSystemSleeping2: objectName = PACKED_S2; break;
        case PowerSystemSleeping3: objectName = PACKED_S3; break;
        case PowerSystemHibernate:
        case PowerSystemShutdown:

            status = STATUS_SUCCESS;
            goto ACPIRootIrpQueryPowerExit;

        default:

            //
            // We don't handle this IRP
            //
            passDown = FALSE;
            status = STATUS_INVALID_DEVICE_REQUEST;
            goto ACPIRootIrpQueryPowerExit;
    }

    //
    // Does the object exist?
    //
    object = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject->pnsParent,
        objectName
        );
    if (object != NULL) {

        status = STATUS_SUCCESS;

    } else {

        passDown = FALSE;
        status = STATUS_INVALID_DEVICE_REQUEST;

    }

ACPIRootIrpQueryPowerExit:

    //
    // Let the system know what we support and what we don't
    //
    Irp->IoStatus.Status = status;
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): ACPIRootIrpQueryPower = %08lx\n",
        Irp,
        status
        ) );

    //
    // Should we pass the irp down or fail it?
    //
    if (passDown) {

        //
        // If we support the request then pass it down and give someone else a
        // chance to veto it
        //
        return ACPIDispatchForwardPowerIrp( DeviceObject, Irp );

    } else {

        //
        // If we failed the irp for whatever reason, the we should just complete
        // the request now and continue along
        //
        PoStartNextPowerIrp( Irp );
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;

    }
}

NTSTATUS
ACPIRootIrpQueryRemoveOrStopDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine transitions the device to the inactive state

Arguments:

    DeviceObject    - The target
    Irp             - The Request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Are we allowed to stop the device?
    //
    if (deviceExtension->Flags & DEV_CAP_NO_STOP) {

        //
        // No, then fail the irp
        //
        Irp->IoStatus.Status = status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    } else {

        //
        // Mark the device state as inactive...
        //
        deviceExtension->PreviousState = deviceExtension->DeviceState;
        deviceExtension->DeviceState = Inactive;

        //
        // Pass the Irp Along
        //
        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );


    }

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIRootIrpRemoveDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called when a filter object must remove itself...

Arguments:

    DeviceObject    - The DeviceObject that must be removed
    Irp             - The request to remove ourselves

Return Value:

--*/
{
    LONG                oldReferenceCount;
    KIRQL               oldIrql;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    //
    // Set the device state as 'removed' ...
    //
    deviceExtension->DeviceState = Removed;

    //
    // Send on the remove IRP
    //
    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    //
    // Attempt to stop the device (if possible)
    //
    ACPIInitStopACPI( DeviceObject );


    //
    // Unregister WMI
    //
#ifdef WMI_TRACING
    ACPIWmiUnRegisterLog(DeviceObject);
#endif // WMI_TRACING    

    //
    // Delete the useless set of resources
    //
    if (deviceExtension->ResourceList != NULL) {

        ExFreePool( deviceExtension->ResourceList );

    }

    //
    // Update the device extension ---
    // we need to hold the lock for this
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Step one is to zero out the things that we no longer care
    // about
    //
    DeviceObject->DeviceExtension = NULL;
    targetObject = deviceExtension->TargetDeviceObject;
    deviceExtension->TargetDeviceObject = NULL;
    deviceExtension->PhysicalDeviceObject = NULL;
    deviceExtension->DeviceObject = NULL;

    //
    // Mark the node as being fresh and untouched
    //
    ACPIInternalUpdateFlags( &(deviceExtension->Flags), DEV_MASK_TYPE, TRUE );
    ACPIInternalUpdateFlags( &(deviceExtension->Flags), DEV_TYPE_NOT_FOUND, FALSE );
    ACPIInternalUpdateFlags( &(deviceExtension->Flags), DEV_TYPE_REMOVED, FALSE );

    //
    // The reference count should have value >= 1
    //
    oldReferenceCount = InterlockedDecrement(
        &(deviceExtension->ReferenceCount)
        );

    ASSERT( oldReferenceCount >= 0 );

    //
    // Do we have to delete the node?
    //
    if (oldReferenceCount == 0) {

        //
        // Delete the extension
        //
        ACPIInitDeleteDeviceExtension( deviceExtension );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Detach the device and delete the object
    //
    ASSERT( targetObject );
    IoDetachDevice( targetObject );
    IoDeleteDevice( DeviceObject );

    //
    // done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIRootIrpSetPower (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called to tell the Root device that the system is
    going to sleep

Arguments:

    DeviceObject    - Device which represents the root of the ACPI tree
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   oldIrql;
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION      irpSp;

    //
    // See if we need to bugcheck
    //
    if (AcpiSystemInitialized == FALSE) {

        ACPIInternalError( ACPI_ROOT );

    }

    //
    // Get the Current stack location to determine if we are a system
    // irp or a device irp. We ignore device irps here.
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);
    if (irpSp->Parameters.Power.Type != SystemPowerState) {

        //
        // We don't handle this irp
        //
        return ACPIDispatchForwardPowerIrp( DeviceObject, Irp );

    }

    //
    // We are going to work on the Irp, so mark it as being SUCCESS
    // for now
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): ACPIRootIrpSetPower - S%d\n",
        Irp,
        irpSp->Parameters.Power.State.SystemState - PowerSystemWorking
        ) );

    //
    // Mark the irp as pending, and increment the irp count because a
    // completion is going to be set
    //
    IoMarkIrpPending( Irp );
    InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

    //
    // Queue the request
    //
    status = ACPIDeviceIrpSystemRequest(
        DeviceObject,
        Irp,
        ACPIDeviceIrpForwardRequest
        );

    //
    // Did we return STATUS_MORE_PROCESSING_REQUIRED (which we used if
    // we overloaded STATUS_PENDING)
    //
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = STATUS_PENDING;

    }

    //
    // Done. Note: the callback function always gets called, so we don't
    // have to worry about doing clean-up work here.
    //
    return status;
}

NTSTATUS
ACPIRootIrpStartDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_START_DEVICE requests sent
    to the Root (or FDO, take your pick, they are the same thing) device object

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    KEVENT              event;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack;
    UCHAR               minorFunction;

    PAGED_CODE();

    //
    // Request to start the device. The rule is that we must pass
    // this down to the PDO before we can start the device ourselves
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): ACPIRootIrpStartDevice\n",
        Irp
        ) );

    //
    // Setup the Event so that we are notified of when this done
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Copy the stack location
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // We want our completion routine to fire...
    //
    IoSetCompletionRoutine(
        Irp,
        ACPIRootIrpCompleteRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Let the IRP execute
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    if (status == STATUS_PENDING) {

        //
        // Wait for it
        //
        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab the 'real' status
        //
        status = Irp->IoStatus.Status;

    }

    //
    // Get the current irp stack location
    //
    irpStack = IoGetCurrentIrpStackLocation( Irp );
    minorFunction = irpStack->MinorFunction;

    //
    // What happened?
    //
    if (!NT_SUCCESS(status)) {

        //
        // Failure
        //
        goto ACPIRootIrpStartDeviceExit;

    }

    //
    // Grab the translatted resource allocated for this device
    //
    deviceExtension->ResourceList =
        (irpStack->Parameters.StartDevice.AllocatedResourcesTranslated ==
         NULL) ? NULL:
        RtlDuplicateCmResourceList(
            NonPagedPool,
            irpStack->Parameters.StartDevice.AllocatedResourcesTranslated,
            ACPI_RESOURCE_POOLTAG
            );
    if (deviceExtension->ResourceList == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            " - Did not find a resource list!\n"
            ) );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_ROOT_RESOURCES_FAILURE,
            (ULONG_PTR) deviceExtension,
            0,
            0
            );

    }

    //
    // Start ACPI
    //
    status = ACPIInitStartACPI( DeviceObject );

    //
    // Update the status of the device
    //
    if (NT_SUCCESS(status)) {

        deviceExtension->DeviceState = Started;

    }

#if 0
    status = ACPIRootUpdateRootResourcesWithHalResources();
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIRootUpdateRootResourcesWithHalResources = %08lx\n",
            Irp,
            status
            ) );

    }
#endif

ACPIRootIrpStartDeviceExit:

    //
    // Store and return the result
    //
    Irp->IoStatus.Status = status;

    //
    // Complete the Irp
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIRootIrpStopDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to stop the device

Arguments:

    DeviceObject    - The device to stop
    Irp             - The request to tell us how to do it...

Return Value:

    NTSTATUS

--*/
{

    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Note: we can only stop a device from within the Inactive state...
    //
    if (deviceExtension->DeviceState != Inactive) {

        ASSERT( deviceExtension->DeviceState == Inactive );
        Irp->IoStatus.Status = status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        goto ACPIRootIrpStopDeviceExit;

    }

    //
    // Set the device as 'Stopped'
    deviceExtension->DeviceState = Stopped;

    //
    // Send on the Stop IRP
    //
    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Attempt to stop the device (if possible)
    //
#if 1
    ACPIInitStopACPI( DeviceObject );
#endif

ACPIRootIrpStopDeviceExit:

    //
    // done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIRootIrpUnhandled(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the unhandled requests sent to a filter

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    //
    // Let the debugger know
    //
    ACPIDevPrint( (
        ACPI_PRINT_WARNING,
        deviceExtension,
        "(%#08lx): %s - Unhandled\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, irpStack->MinorFunction)
        ) );

    //
    // Skip current stack location
    //
    IoSkipCurrentIrpStackLocation( Irp );

    //
    // Call the driver below us
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Done
    //
    return status;
}

//
// Some data structures used by the AML interpreter. We need to be able
// to read/write these globals to keep track of the number of contexts
// allocated by the interpreter...
//
extern  ULONG       gdwcCTObjsMax;
extern  ULONG       AMLIMaxCTObjs;
extern  KSPIN_LOCK  gdwGContextSpinLock;

VOID
ACPIRootPowerCallBack(
    IN  PVOID   CallBackContext,
    IN  PVOID   Argument1,
    IN  PVOID   Argument2
    )
/*++

Routine Description:

    This routine is called when the system changes power states

Arguments:

    CallBackContext - The device extension for the root device
    Argument1

--*/
{
    HANDLE      pKey;
    HANDLE      wKey;
    KIRQL       oldIrql;
    NTSTATUS    status;
    ULONG       action = PtrToUlong( Argument1 );
    ULONG       value  = PtrToUlong( Argument2 );
    ULONG       num;

    //
    // We are looking for a PO_CB_SYSTEM_STATE_LOCK
    //
    if (action != PO_CB_SYSTEM_STATE_LOCK) {

        return;

    }

    //
    // We need to remember if we are going to S0 or we are leaving S0
    //
    KeAcquireSpinLock( &GpeTableLock, &oldIrql );
    AcpiPowerLeavingS0 = (value != 1);
    KeReleaseSpinLock( &GpeTableLock, oldIrql );

    //
    // We have to update the GPE masks now. Before we can do that, we need
    // to hold the cancel spinlock and the power lock to make sure that
    // everything is synchronized okay
    //
    IoAcquireCancelSpinLock( &oldIrql );
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Update the GPE masks
    //
    ACPIWakeRemoveDevicesAndUpdate( NULL, NULL );

    //
    // Done with the locks
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
    IoReleaseCancelSpinLock( oldIrql );

    if (value == 0) {

        //
        // We need to reset the max number of context objects allocated
        //
        KeAcquireSpinLock( &gdwGContextSpinLock, &oldIrql );
        gdwcCTObjsMax = 0;
        KeReleaseSpinLock( &gdwGContextSpinLock, oldIrql );

        //
        // Return now otherwise we will execute that we normally
        // would execute on wake-up
        //
        return;

    }

    //
    // Open the correct handle to the registry
    //
    status = OSCreateHandle(ACPI_PARAMETERS_REGISTRY_KEY, NULL, &pKey);
    if (!NT_SUCCESS(status)) {

        return;

    }

    //
    // Grab the max number of contexts allocated and write it to
    // the registry, but only if it exceeds the last value store
    // in the registry
    //
    KeAcquireSpinLock( &gdwGContextSpinLock, &oldIrql );
    if (gdwcCTObjsMax > AMLIMaxCTObjs) {

        AMLIMaxCTObjs = gdwcCTObjsMax;

    }
    num = AMLIMaxCTObjs;
    KeReleaseSpinLock( &gdwGContextSpinLock, oldIrql );
    OSWriteRegValue(
        "AMLIMaxCTObjs",
        pKey,
        &num,
        sizeof(num)
        );

    //
    // If we are leaving the sleep state, and re-entering the running
    // state, then we had better write to the registery that we think
    // woke up the computer
    //
    status = OSCreateHandle("WakeUp",pKey,&wKey);
    OSCloseHandle(pKey);
    if (!NT_SUCCESS(status)) {

        OSCloseHandle(pKey);
        return;

    }


    //
    // Store the PM1 Fixed Register Mask
    //
    OSWriteRegValue(
        "FixedEventMask",
        wKey,
        &(AcpiInformation->pm1_wake_mask),
        sizeof(AcpiInformation->pm1_wake_mask)
        );

    //
    // Store the PM1 Fixed Register Status
    //
    OSWriteRegValue(
        "FixedEventStatus",
        wKey,
        &(AcpiInformation->pm1_wake_status),
        sizeof(AcpiInformation->pm1_wake_status)
        );

    //
    // Store the GPE Mask
    //
    OSWriteRegValue(
        "GenericEventMask",
        wKey,
        GpeSavedWakeMask,
        AcpiInformation->GpeSize
        );

    //
    // Store the GPE Status
    //
    OSWriteRegValue(
        "GenericEventStatus",
        wKey,
        GpeSavedWakeStatus,
        AcpiInformation->GpeSize
        );

    //
    // Done with the key
    //
    OSCloseHandle( wKey );
}

NTSTATUS
ACPIRootUpdateRootResourcesWithBusResources(
    VOID
    )
/*++

Routine Description:

    This routine is called when ACPI is started. Its purpose is to change
    the resources reported to ACPI for its own use to include those resources
    used by direct childs which are not buses. In other words, it updates
    its resource list so that buses do not prevent direct children from
    starting.

    This is black magic

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    KIRQL                           oldIrql;
    LONG                            oldReferenceCount;
    NTSTATUS                        status;
    PCM_RESOURCE_LIST               cmList;
    PDEVICE_EXTENSION               deviceExtension;
    PDEVICE_EXTENSION               oldExtension;
    PIO_RESOURCE_REQUIREMENTS_LIST  currentList         = NULL;
    PIO_RESOURCE_REQUIREMENTS_LIST  globalList          = NULL;
    PUCHAR                          crsBuf;

    //
    // First take the ACPI CM Res List and turn *that* into an Io ResList. This
    // is the list that we will add things to
    //
    status = PnpCmResourceListToIoResourceList(
        RootDeviceExtension->ResourceList,
        &globalList
        );
    if (!NT_SUCCESS(status)) {

        //
        // Oops
        //
        return status;

    }

    //
    // We must walk the tree at Dispatch level <sigh>
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Is the list empty?
    //
    if (IsListEmpty( &(RootDeviceExtension->ChildDeviceList) ) ) {

        //
        // We have nothing to do here
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
        ExFreePool( globalList );
        return STATUS_SUCCESS;

    }

    //
    // Get the first child
    //
    deviceExtension = CONTAINING_RECORD(
        RootDeviceExtension->ChildDeviceList.Flink,
        DEVICE_EXTENSION,
        SiblingDeviceList
        );

    //
    // Always update the reference count to make sure that one will ever
    // delete the node without our knowing about it
    //
    InterlockedIncrement( &(deviceExtension->ReferenceCount) );

    //
    // Release the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // loop until we get to the parent
    //
    while (deviceExtension != NULL ) {

        //
        // Check to see if we are a bus, and if we are, we will skip this
        // node
        //
        if (!(deviceExtension->Flags & DEV_MASK_BUS) &&
            !(deviceExtension->Flags & DEV_PROP_NO_OBJECT) ) {

            //
            // At this point, see if there is a _CRS
            //
            ACPIGetBufferSync(
                deviceExtension,
                PACKED_CRS,
                &crsBuf,
                NULL
                );
            if (crsBuf != NULL) {

                //
                // Try to turn the crs into an IO_RESOURCE_REQUIREMENTS_LIST
                //
                status = PnpBiosResourcesToNtResources(
                    crsBuf,
                    0,
                    &currentList
                    );

                //
                // If we didn't succeed, then we skip the list
                //
                if (NT_SUCCESS(status)) {

                    //
                    // Add this list to the global list
                    //
                    status = ACPIRangeAdd(
                        &globalList,
                        currentList
                        );

                    //
                    // We are done with the local IO res list
                    //
                    ExFreePool( currentList );

                }

                ACPIDevPrint( (
                    ACPI_PRINT_RESOURCES_1,
                    deviceExtension,
                    "ACPIRootUpdateResources = %08lx\n",
                    status
                    ) );

                //
                // Done with local crs
                //
                ExFreePool( crsBuf );

            }

        }

        //
        // We need the lock to walk the next resource in the tree
        //
        KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

        //
        // Remember the old extension
        //
        oldExtension = deviceExtension;

        //
        // Get the next device extension
        //
        if (deviceExtension->SiblingDeviceList.Flink !=
            &(RootDeviceExtension->ChildDeviceList) ) {

            //
            // Next Element
            //
            deviceExtension = CONTAINING_RECORD(
                deviceExtension->SiblingDeviceList.Flink,
                DEVICE_EXTENSION,
                SiblingDeviceList
                );

            //
            // Reference count the device
            //
            InterlockedIncrement( &(deviceExtension->ReferenceCount) );

        } else {

            deviceExtension = NULL;

        }

        //
        // Decrement the reference count on this node
        //
        oldReferenceCount = InterlockedDecrement(
            &(oldExtension->ReferenceCount)
            );

        //
        // Is this the last reference?
        //
        if (oldReferenceCount == 0) {

            //
            // Free the memory allocated by the extension
            //
            ACPIInitDeleteDeviceExtension( oldExtension );
        }

        //
        // Done with the lock
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    }

    //
    // Do we have any resources that we care to update?
    //
    if (globalList == NULL) {

        //
        // No, then we are done
        //
        return STATUS_SUCCESS;

    }

    //
    // Turn the global list into a CM_RES_LIST
    //
    status = PnpIoResourceListToCmResourceList( globalList, &cmList );

    //
    // No matter what, we are done with the global list
    //
    ExFreePool( globalList );

    //
    // Check to see if we succeeded
    //
    if (!NT_SUCCESS(status)) {

        //
        // Oops
        //
        return status;

    }

    //
    // Now, set this as the resources consumed by ACPI. The previous list
    // was created by the system manager, so freeing it is bad.
    //
    RootDeviceExtension->ResourceList = cmList;

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIRootUpdateRootResourcesWithHalResources(
    VOID
    )
/*++

Routine Description:

    This routine will read from the registry the resources that cannot
    be allocated by ACPI and store them in the resourceList for PnP0C08

    This is black magic

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    HANDLE                          classKeyHandle;
    HANDLE                          driverKeyHandle;
    HANDLE                          resourceMap;
    NTSTATUS                        status;
    OBJECT_ATTRIBUTES               resourceObject;
    PCM_FULL_RESOURCE_DESCRIPTOR    cmFullResList;
    PCM_RESOURCE_LIST               globalResList;
    PCM_RESOURCE_LIST               cmResList;
    PUCHAR                          lastAddr;
    ULONG                           bufferSize;
    ULONG                           busTranslatedLength;
    ULONG                           classKeyIndex;
    ULONG                           driverKeyIndex;
    ULONG                           driverValueIndex;
    ULONG                           i;
    ULONG                           j;
    ULONG                           length;
    ULONG                           temp;
    ULONG                           translatedLength;
    union {
        PVOID                       buffer;
        PKEY_BASIC_INFORMATION      keyBasicInf;
        PKEY_FULL_INFORMATION       keyFullInf;
        PKEY_VALUE_FULL_INFORMATION valueKeyFullInf;
    } u;
    UNICODE_STRING                  keyName;
    WCHAR                           rgzTranslated[] = L".Translated";
    WCHAR                           rgzBusTranslated[] = L".Bus.Translated";
    WCHAR                           rgzResourceMap[] =
        L"\\REGISTRY\\MACHINE\\HARDWARE\\RESOURCEMAP";

#define INVALID_HANDLE  (HANDLE) -1

    //
    // Start out with one page of buffer
    //
    bufferSize = PAGE_SIZE;

    //
    // Allocate this buffer
    //
    u.buffer = ExAllocatePoolWithTag(
         PagedPool,
         bufferSize,
         ACPI_MISC_POOLTAG
         );
    if (u.buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Add the current global res list to the working list
    //
    globalResList = NULL;
    status = ACPIRangeAddCmList(
        &globalResList,
        RootDeviceExtension->ResourceList
        );
    if (!NT_SUCCESS(status)) {

        ExFreePool( u.buffer );
        return status;

    }
    ExFreePool( RootDeviceExtension->ResourceList );
    RootDeviceExtension->ResourceList = NULL;

    //
    // count the constant string lengths
    //
    for (translatedLength = 0;
         rgzTranslated[translatedLength];
         translatedLength++);
    for (busTranslatedLength = 0;
         rgzBusTranslated[busTranslatedLength];
         busTranslatedLength++);
    translatedLength *= sizeof(WCHAR);
    busTranslatedLength *= sizeof(WCHAR);

    //
    // Initialize the registry path information
    //
    RtlInitUnicodeString( &keyName, rgzResourceMap );

    //
    // Open the registry key for this information
    //
    InitializeObjectAttributes(
        &resourceObject,
        &keyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    status = ZwOpenKey(
        &resourceMap,
        KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
        &resourceObject
        );
    if (!NT_SUCCESS(status)) {

        //
        // Failed:
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIRootUpdateRootResourcesWithHalResources: ZwOpenKey = 0x%08lx\n",
            status
            ) );
        ExFreePool( u.buffer );
        return status;

    }

    //
    // Walk resource map and collect any in-use resources
    //
    classKeyIndex = 0;
    classKeyHandle = INVALID_HANDLE;
    driverKeyHandle = INVALID_HANDLE;
    status = STATUS_SUCCESS;

    //
    // loop until failure
    //
    while (NT_SUCCESS(status)) {

        //
        // Get the class information
        //
        status = ZwEnumerateKey(
            resourceMap,
            classKeyIndex++,
            KeyBasicInformation,
            u.keyBasicInf,
            bufferSize,
            &temp
            );
        if (!NT_SUCCESS(status)) {

            break;

        }

        //
        // Create a unicode string using the counted string passed back to
        // us in the information structure, and open the class key
        //
        keyName.Buffer = (PWSTR) u.keyBasicInf->Name;
        keyName.Length = (USHORT) u.keyBasicInf->NameLength;
        keyName.MaximumLength = (USHORT) u.keyBasicInf->NameLength;
        InitializeObjectAttributes(
            &resourceObject,
            &keyName,
            OBJ_CASE_INSENSITIVE,
            resourceMap,
            NULL
            );
        status = ZwOpenKey(
            &classKeyHandle,
            KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
            &resourceObject
            );
        if (!NT_SUCCESS(status)) {

            break;

        }

        //
        // Loop until failure
        //
        driverKeyIndex = 0;
        while (NT_SUCCESS(status)) {

            //
            // Get the class information
            //
            status = ZwEnumerateKey(
                classKeyHandle,
                driverKeyIndex++,
                KeyBasicInformation,
                u.keyBasicInf,
                bufferSize,
                &temp
                );
            if (!NT_SUCCESS(status)) {

                break;

            }

            //
            // Create a unicode string using the counted string passed back
            // to us in the information structure, and open the class key
            //
            keyName.Buffer = (PWSTR) u.keyBasicInf->Name;
            keyName.Length = (USHORT) u.keyBasicInf->NameLength;
            keyName.MaximumLength = (USHORT) u.keyBasicInf->NameLength;
            InitializeObjectAttributes(
                &resourceObject,
                &keyName,
                OBJ_CASE_INSENSITIVE,
                classKeyHandle,
                NULL
                );
            status = ZwOpenKey(
                &driverKeyHandle,
                KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                &resourceObject
                );
            if (!NT_SUCCESS(status)) {

                break;

            }

            //
            // Get full information for that key so we can get the information
            // about the data stored in the key
            //
            status = ZwQueryKey(
                driverKeyHandle,
                KeyFullInformation,
                u.keyFullInf,
                bufferSize,
                &temp
                );
            if (!NT_SUCCESS(status)) {

                break;

            }

            //
            // How long is the key?
            //
            length = sizeof( KEY_VALUE_FULL_INFORMATION) +
                u.keyFullInf->MaxValueNameLen +
                u.keyFullInf->MaxValueDataLen +
                sizeof(UNICODE_NULL);
            if (length > bufferSize) {

                PVOID   tempBuffer;

                //
                // Grow the buffer
                //
                tempBuffer = ExAllocatePoolWithTag(
                    PagedPool,
                    length,
                    ACPI_MISC_POOLTAG
                    );
                if (tempBuffer == NULL) {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;

                }
                ExFreePool( u.buffer );
                u.buffer = tempBuffer;
                bufferSize = length;

            }

            //
            // Look at all the values
            //
            driverValueIndex = 0;
            for(;;) {

                PCM_RESOURCE_LIST   tempCmList;

                status = ZwEnumerateValueKey(
                    driverKeyHandle,
                    driverValueIndex++,
                    KeyValueFullInformation,
                    u.valueKeyFullInf,
                    bufferSize,
                    &temp
                    );
                if (!NT_SUCCESS(status)) {

                    break;

                }

                //
                // If this is not a translated resource list, skip it
                //
                i = u.valueKeyFullInf->NameLength;
                if (i < translatedLength ||
                    RtlCompareMemory(
                        ((PUCHAR) u.valueKeyFullInf->Name) + i - translatedLength,
                        rgzTranslated,
                        translatedLength) != translatedLength
                    ) {

                    //
                    // Does not end in rgzTranslated
                    //
                    continue;

                }

                //
                // Is this a bus translated resource list???
                //
                if (i >= busTranslatedLength &&
                    RtlCompareMemory(
                        ((PUCHAR) u.valueKeyFullInf->Name) + i - busTranslatedLength,
                        rgzBusTranslated,
                        busTranslatedLength) != busTranslatedLength
                    ) {

                    //
                    // Ends in rgzBusTranslated
                    //
                    continue;

                }

                //
                // we now have a pointer to the cm resource list
                //
                cmResList = (PCM_RESOURCE_LIST) ( (PUCHAR) u.valueKeyFullInf +
                    u.valueKeyFullInf->DataOffset);
                lastAddr = (PUCHAR) cmResList + u.valueKeyFullInf->DataLength;

                //
                // We must flatten this list down to one level, so lets
                // figure out how many descriptors we need
                //
                cmFullResList = cmResList->List;
                for (temp = i = 0; i < cmResList->Count; i++) {

                    if ( (PUCHAR) cmFullResList > lastAddr) {

                        break;

                    }

                    temp += cmFullResList->PartialResourceList.Count;

                    //
                    // next CM_FULL_RESOURCE_DESCRIPTOR
                    //
                    cmFullResList =
                        (PCM_FULL_RESOURCE_DESCRIPTOR) ( (PUCHAR) cmFullResList
                        + sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
                        (cmFullResList->PartialResourceList.Count - 1) *
                        sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) );

                }

                //
                // Now that we have the number of descriptors, allocate this
                // much space
                //
                tempCmList = ExAllocatePool(
                    PagedPool,
                    sizeof(CM_RESOURCE_LIST) + (temp - 1) *
                    sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                    );
                if (tempCmList == NULL) {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;

                }

                //
                // Now, fill up the flatened list
                //
                RtlCopyMemory(
                    tempCmList,
                    cmResList,
                    sizeof(CM_RESOURCE_LIST) -
                    sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                    );
                tempCmList->Count = 1;
                tempCmList->List->PartialResourceList.Count = temp;

                //
                // This is a brute force approach
                //
                cmFullResList = cmResList->List;
                for (temp = i = 0; i < cmResList->Count; i++) {

                    if ( (PUCHAR) cmFullResList > lastAddr) {

                        break;

                    }

                    //
                    // Copy the current descriptors over
                    //
                    RtlCopyMemory(
                        &(tempCmList->List->PartialResourceList.PartialDescriptors[temp]),
                        cmFullResList->PartialResourceList.PartialDescriptors,
                        cmFullResList->PartialResourceList.Count *
                            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                        );


                    temp += cmFullResList->PartialResourceList.Count;

                    //
                    // next CM_FULL_RESOURCE_DESCRIPTOR
                    //
                    cmFullResList =
                        (PCM_FULL_RESOURCE_DESCRIPTOR) ( (PUCHAR) cmFullResList
                        + sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
                        (cmFullResList->PartialResourceList.Count - 1) *
                        sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) );

                }

                //
                // Add it to the global list
                //
                status = ACPIRangeAddCmList(
                    &globalResList,
                    tempCmList
                    );
                if (!NT_SUCCESS(status)) {

                    ACPIPrint( (
                        ACPI_PRINT_CRITICAL,
                        "ACPIRootUpdateRootResourcesWithHalResources: "
                        "ACPIRangeAddCmList = 0x%08lx\n",
                        status
                        ) );
                    ExFreePool( tempCmList );
                    break;

                }
                ExFreePool( tempCmList );

            } // for -- Next driverValueIndex

            if (driverKeyHandle != INVALID_HANDLE) {

                ZwClose( driverKeyHandle);
                driverKeyHandle = INVALID_HANDLE;

            }

            if (status == STATUS_NO_MORE_ENTRIES) {

                status = STATUS_SUCCESS;

            }

        } // while -- Next driverKeyIndex

        if (classKeyHandle != INVALID_HANDLE) {

            ZwClose( classKeyHandle );
            classKeyHandle = INVALID_HANDLE;

        }

        if (status == STATUS_NO_MORE_ENTRIES) {

            status = STATUS_SUCCESS;

        }

    } // while -- next classKeyIndex

    if (status == STATUS_NO_MORE_ENTRIES) {

        status = STATUS_SUCCESS;

    }

    ZwClose( resourceMap );
    ExFreePool( u.buffer );

    //
    // Remember the new global list
    //
    RootDeviceExtension->ResourceList = globalResList;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\res_bios.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    res_bios.c

Abstract:

    This file contains routines to translate resources between PnP ISA/BIOS
    format and Windows NT formats.

Author:

    Shie-Lin Tzong (shielint) 12-Apr-1995
    Stephane Plante (splante) 20-Nov-1996

Environment:

    Kernel mode only.

Revision History:

    20-Nov-1996:
        Changed to conform with ACPI environment
    22-Jan-1997:
        Changed to remove all traces of original Shie Lin code

--*/

#include "pch.h"

#define RESOURCE_LIST_GROWTH_SIZE   8

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,PnpiBiosAddressHandleBusFlags)
#pragma alloc_text(PAGE,PnpiBiosAddressHandleGlobalFlags)
#pragma alloc_text(PAGE,PnpiBiosAddressHandleMemoryFlags)
#pragma alloc_text(PAGE,PnpiBiosAddressHandlePortFlags)
#pragma alloc_text(PAGE,PnpiBiosAddressToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosAddressDoubleToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosAddressQuadToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosDmaToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosExtendedIrqToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosIrqToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosMemoryToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosPortFixedToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosPortToIoDescriptor)
#pragma alloc_text(PAGE,PnpiClearAllocatedMemory)
#pragma alloc_text(PAGE,PnpiGrowResourceDescriptor)
#pragma alloc_text(PAGE,PnpiGrowResourceList)
#pragma alloc_text(PAGE,PnpiUpdateResourceList)
#pragma alloc_text(PAGE,PnpBiosResourcesToNtResources)
#pragma alloc_text(PAGE,PnpIoResourceListToCmResourceList)
#endif


VOID
PnpiBiosAddressHandleBusFlags(
    IN  PVOID                   Buffer,
    IN  PIO_RESOURCE_DESCRIPTOR Descriptor
    )
/*++

Routine Description:

    This routine handles the Type specific flags in an Address Descriptor of
    type Bus

Arguments:

    Buffer      - The pnp descriptor. Can be a WORD, DWORD, or QWORD descriptor,
                  because the initial memory placement is identical
    Descriptor  - Where to set the flags

Return Value:

    None

--*/
{
    PAGED_CODE();

    ASSERT(Descriptor->u.BusNumber.Length > 0);
}

VOID
PnpiBiosAddressHandleGlobalFlags(
    IN  PVOID                   Buffer,
    IN  PIO_RESOURCE_DESCRIPTOR Descriptor
    )
/*++

Routine Descriptoin:

    This routine handles all the Global 'generic' flags in an Address Descriptor

Arguments:

    Buffer      - The pnp descriptor. Can be a WORD, DWORD, or QWORD descriptor,
                  because the initial memory placement is identical
    Descriptor  - Where to set the flags

Return Value:

    None

--*/
{
    PPNP_WORD_ADDRESS_DESCRIPTOR    buffer = (PPNP_WORD_ADDRESS_DESCRIPTOR) Buffer;
    ULONG                           newValue;
    ULONG                           oldValue;
    ULONG                           bound;
    PAGED_CODE();

    //
    // If the resource is marked as being consumed only, then it is
    // exclusive, otherwise, it is shared
    //
    if (buffer->GFlag & PNP_ADDRESS_FLAG_CONSUMED_ONLY) {

        Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;

    } else {

        Descriptor->ShareDisposition = CmResourceShareShared;

    }

    //
    // Handle the hints that are given to us
    //
    if (buffer->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED &&
        buffer->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) {

        if (Descriptor->Type == CmResourceTypeBusNumber) {

            oldValue = Descriptor->u.BusNumber.Length;
            newValue = Descriptor->u.BusNumber.Length =
                Descriptor->u.BusNumber.MaxBusNumber -
                Descriptor->u.BusNumber.MinBusNumber + 1;

        } else {

            oldValue = Descriptor->u.Memory.Length;
            newValue = Descriptor->u.Memory.Length =
                Descriptor->u.Memory.MaximumAddress.LowPart -
                Descriptor->u.Memory.MinimumAddress.LowPart + 1;

        }

    } else if (buffer->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) {

        if (Descriptor->Type == CmResourceTypeBusNumber) {

            bound = Descriptor->u.BusNumber.MaxBusNumber;
            oldValue = Descriptor->u.BusNumber.MinBusNumber;
            newValue = Descriptor->u.BusNumber.MinBusNumber = 1 +
                Descriptor->u.BusNumber.MaxBusNumber -
                Descriptor->u.BusNumber.Length;

        } else {

            bound = Descriptor->u.Memory.MaximumAddress.LowPart;
            oldValue = Descriptor->u.Memory.MinimumAddress.LowPart;
            newValue = Descriptor->u.Memory.MinimumAddress.LowPart = 1 +
                Descriptor->u.Memory.MaximumAddress.LowPart -
                Descriptor->u.Memory.Length;

        }

    } else if (buffer->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED) {

        if (Descriptor->Type == CmResourceTypeBusNumber) {

            bound = Descriptor->u.BusNumber.MinBusNumber;
            oldValue = Descriptor->u.BusNumber.MaxBusNumber;
            newValue = Descriptor->u.BusNumber.MaxBusNumber =
                Descriptor->u.BusNumber.MinBusNumber +
                Descriptor->u.BusNumber.Length - 1;

        } else {

            bound = Descriptor->u.Memory.MinimumAddress.LowPart;
            oldValue = Descriptor->u.Memory.MaximumAddress.LowPart;
            newValue = Descriptor->u.Memory.MaximumAddress.LowPart =
                Descriptor->u.Memory.MinimumAddress.LowPart -
                Descriptor->u.Memory.Length - 1;

        }

    }

}

VOID
PnpiBiosAddressHandleMemoryFlags(
    IN  PVOID                   Buffer,
    IN  PIO_RESOURCE_DESCRIPTOR Descriptor
    )
/*++

Routine Description:

    This routine handles the Type specific flags in an Address Descriptor of
    type Memory

Arguments:

    Buffer      - The pnp descriptor. Can be a WORD, DWORD, or QWORD descriptor,
                  because the initial memory placement is identical
    Descriptor  - Where to set the flags

Return Value:

    None

--*/
{
    PPNP_WORD_ADDRESS_DESCRIPTOR    buffer = (PPNP_WORD_ADDRESS_DESCRIPTOR) Buffer;

    PAGED_CODE();

    //
    // Set the proper memory type flags
    //
    switch( buffer->TFlag & PNP_ADDRESS_TYPE_MEMORY_MASK) {
        case PNP_ADDRESS_TYPE_MEMORY_CACHEABLE:
            Descriptor->Flags |= CM_RESOURCE_MEMORY_CACHEABLE;
            break;
        case PNP_ADDRESS_TYPE_MEMORY_WRITE_COMBINE:
            Descriptor->Flags |= CM_RESOURCE_MEMORY_COMBINEDWRITE;
            break;
        case PNP_ADDRESS_TYPE_MEMORY_PREFETCHABLE:
            Descriptor->Flags |= CM_RESOURCE_MEMORY_PREFETCHABLE;
            break;
        case PNP_ADDRESS_TYPE_MEMORY_NONCACHEABLE:
            break;
        default:
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "PnpiBiosAddressHandleMemoryFlags: Unknown Memory TFlag "
                "0x%02x\n",
                buffer->TFlag
                ) );
            break;
    }

    //
    // This bit is used to turn on/off write access to memory
    //
    if (buffer->TFlag & PNP_ADDRESS_TYPE_MEMORY_READ_WRITE) {

        Descriptor->Flags |= CM_RESOURCE_MEMORY_READ_WRITE;

    } else {

        Descriptor->Flags |= CM_RESOURCE_MEMORY_READ_ONLY;
    }

}

VOID
PnpiBiosAddressHandlePortFlags(
    IN  PVOID                   Buffer,
    IN  PIO_RESOURCE_DESCRIPTOR Descriptor
    )
/*++

Routine Description:

    This routine handles the Type specific flags in an Address Descriptor of
    type Port

Arguments:

    Buffer      - The pnp descriptor. Can be a WORD, DWORD, or QWORD descriptor,
                  because the initial memory placement is identical
    Descriptor  - Where to set the flags

Return Value:

    None

--*/
{
    PPNP_WORD_ADDRESS_DESCRIPTOR    buffer = (PPNP_WORD_ADDRESS_DESCRIPTOR) Buffer;
    ULONG                           granularity = Descriptor->u.Port.Alignment;

    PAGED_CODE();

    //
    // We can determine if the device uses a positive decode or not
    //
    if ( !(buffer->GFlag & PNP_ADDRESS_FLAG_SUBTRACTIVE_DECODE)) {

        Descriptor->Flags |= CM_RESOURCE_PORT_POSITIVE_DECODE;

    }
}

NTSTATUS
PnpiBiosAddressToIoDescriptor(
    IN  PUCHAR              Data,
    IN  PIO_RESOURCE_LIST   Array[],
    IN  ULONG               ArrayIndex,
    IN  ULONG               Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                        status;
    PIO_RESOURCE_DESCRIPTOR         rangeDescriptor, privateDescriptor;
    PPNP_WORD_ADDRESS_DESCRIPTOR    buffer;
    ULONG                           alignment;
    ULONG                           length;
    UCHAR                           decodeLength;
    USHORT                          parentMin, childMin, childMax;

    PAGED_CODE();
    ASSERT( Array != NULL );

    buffer = (PPNP_WORD_ADDRESS_DESCRIPTOR) Data;

    //
    // Check to see if we are are allowed to use this resource
    //
    if (buffer->GFlag & PNP_ADDRESS_FLAG_CONSUMED_ONLY &&
        buffer->RFlag == PNP_ADDRESS_IO_TYPE &&
        Flags & PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES) {

        return STATUS_SUCCESS;

    }

    //
    // If the length of the address range is zero, ignore this descriptor.
    // This makes it easier for BIOS writers to set up a template and then
    // whack its length to zero if it doesn't apply.
    //
    if (buffer->AddressLength == 0) {

        return STATUS_SUCCESS;

    }

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &rangeDescriptor );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // If this is I/O or Memory, then we will need to make enough space for
    // a device private resource too.
    //

    if ((buffer->RFlag == PNP_ADDRESS_MEMORY_TYPE) ||
        (buffer->RFlag == PNP_ADDRESS_IO_TYPE)) {

        status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &privateDescriptor );

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Calling PnpiUpdateResourceList may have invalidated
        // rangeDescriptor.  So make sure it's OK now.
        //

        ASSERT(Array[ArrayIndex]->Count >= 2);
        rangeDescriptor = privateDescriptor - 1;

        privateDescriptor->Type = CmResourceTypeDevicePrivate;

        //
        // Mark this descriptor as containing the start
        // address of the translated resource.
        //
        privateDescriptor->Flags = TRANSLATION_DATA_PARENT_ADDRESS;

        //
        // Fill in the top 32 bits of the start address.
        //
        privateDescriptor->u.DevicePrivate.Data[2] = 0;
    }

    //
    // Do we met the minimum length requirements ?
    //
    if ( buffer->Length < PNP_ADDRESS_WORD_MINIMUM_LENGTH) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "PnpiBiosAddressToIoDescriptor: Descriptor too small 0x%08lx\n",
            buffer->Length
            ) );

        //
        // We can go no further
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_PNP_RESOURCE_LIST_BUFFER_TOO_SMALL,
            (ULONG_PTR) buffer,
            buffer->Tag,
            buffer->Length
            );

    }

    //
    // Length is the stored within the descriptor record
    //
    length = (ULONG) (buffer->AddressLength);
    alignment = (ULONG) (buffer->Granularity) + 1;

    //
    // Calculate the bounds of both the parent and child sides of
    // the bridge.
    //
    // The translation field applies to the parent address i.e.
    // the child address is the address in the buffer and the
    // parent address is the addition of the child address and
    // the translation field.
    //

    parentMin = buffer->MinimumAddress + buffer->TranslationAddress;
    childMin = buffer->MinimumAddress;
    childMax = buffer->MaximumAddress;

    //
    // Patch the length based on wether or not the min/max flags are set
    //
    if ( (buffer->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED) &&
         (buffer->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) ) {

        ULONG   length2;
        ULONG   alignment2;

        //
        // Calculate the length based on the fact that the min and
        // max addresses are locked down.
        //
        length2 = childMax - childMin + 1;

        //
        // Test #1 --- The length had better be correct
        //
        if (length2 != length) {

            //
            // Bummer. Let the world know
            //
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPI: Length does not match fixed attributes\n"
                ) );
            length = length2;

        }

        //
        // Test #2 --- The granularity had also better be correct
        //
        if ( (childMin & (ULONG) buffer->Granularity ) ) {

            //
            // Bummer. Let the world know
            //
            ACPIPrint( (
               ACPI_PRINT_WARNING,
               "ACPI: Granularity does not match fixed attributes\n"
               ) );
            alignment = 1;

        }

    }

    //
    // Handle the Resource type seperately
    //
    switch (buffer->RFlag) {
    case PNP_ADDRESS_MEMORY_TYPE:

        //
        // Set the proper ranges
        //
        rangeDescriptor->u.Memory.Alignment = alignment;
        rangeDescriptor->u.Memory.Length = length;
        rangeDescriptor->u.Memory.MinimumAddress.LowPart = childMin;
        rangeDescriptor->u.Memory.MaximumAddress.LowPart = childMax;
        rangeDescriptor->u.Memory.MinimumAddress.HighPart =
            rangeDescriptor->u.Memory.MaximumAddress.HighPart = 0;
        rangeDescriptor->Type = CmResourceTypeMemory;

        //
        // The child address is the address in the PnP address
        // space descriptor and the child descriptor will inherit
        // the descriptor type from the PnP address space
        // descriptor.
        //


        if (buffer->TFlag & TRANSLATION_MEM_TO_IO) {

            //
            // The device private describes the parent. With this
            // flag set, the descriptor type of the parent will
            // change from Memory to IO.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypePort;

        } else {

            //
            // The parent descriptor type will not change.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypeMemory;

        }

        //
        // Fill in the bottom 32 bits of the parent's start address.
        //
        privateDescriptor->u.DevicePrivate.Data[1] = parentMin;

        //
        // Handle memory flags
        //
        PnpiBiosAddressHandleMemoryFlags( buffer, rangeDescriptor );

        //
        // Reset the alignment
        //
        rangeDescriptor->u.Memory.Alignment = 1;
        break;

    case PNP_ADDRESS_IO_TYPE:

        //
        // Any flags that are set here must be handled
        // through the use of device privates
        //
        rangeDescriptor->u.Port.Alignment = alignment;
        rangeDescriptor->u.Port.Length = length;
        rangeDescriptor->u.Port.MinimumAddress.LowPart = childMin;
        rangeDescriptor->u.Port.MaximumAddress.LowPart = childMax;
        rangeDescriptor->u.Port.MinimumAddress.HighPart =
            rangeDescriptor->u.Port.MaximumAddress.HighPart = 0;
        rangeDescriptor->Type = CmResourceTypePort;

        
        if (buffer->TFlag & PNP_ADDRESS_TYPE_IO_SPARSE_TRANSLATION) {
            privateDescriptor->Flags |= TRANSLATION_RANGE_SPARSE;
        }
        

        if (buffer->TFlag & PNP_ADDRESS_TYPE_IO_TRANSLATE_IO_TO_MEM) {

            //
            // The device private describes the parent. With this
            // flag set, the descriptor type of the parent will
            // change from IO to Memory.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypeMemory;

        } else {

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypePort;

        }

        //
        // Fill in the bottom 32 bits of the parent's start address.
        //
        privateDescriptor->u.DevicePrivate.Data[1] = parentMin;

        //
        // Handle port flags
        //
        PnpiBiosAddressHandlePortFlags( buffer, rangeDescriptor );

        //
        // Reset the alignment
        //
        rangeDescriptor->u.Port.Alignment = 1;
        break;

    case PNP_ADDRESS_BUS_NUMBER_TYPE:

        rangeDescriptor->Type = CmResourceTypeBusNumber;
        rangeDescriptor->u.BusNumber.MinBusNumber = (buffer->MinimumAddress);
        rangeDescriptor->u.BusNumber.MaxBusNumber = (buffer->MaximumAddress);
        rangeDescriptor->u.BusNumber.Length = length;

        //
        // Handle busnumber flags
        //
        PnpiBiosAddressHandleBusFlags( buffer, rangeDescriptor );
        break;

    default:

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "PnpiBiosAddressToIoDescriptor: Unknown Type 0x%2x\n",
            buffer->RFlag ) );
        break;
    }

    //
    // Handle global flags
    //
    PnpiBiosAddressHandleGlobalFlags( buffer, rangeDescriptor );
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiBiosAddressDoubleToIoDescriptor(
    IN  PUCHAR              Data,
    IN  PIO_RESOURCE_LIST   Array[],
    IN  ULONG               ArrayIndex,
    IN  ULONG               Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                        status;
    PIO_RESOURCE_DESCRIPTOR         rangeDescriptor, privateDescriptor;
    PPNP_DWORD_ADDRESS_DESCRIPTOR   buffer;
    UCHAR                           decodeLength;
    ULONG                           alignment;
    ULONG                           length;
    ULONG                           parentMin, childMin, childMax;

    PAGED_CODE();
    ASSERT( Array != NULL );

    buffer = (PPNP_DWORD_ADDRESS_DESCRIPTOR) Data;

    //
    // Check to see if we are are allowed to use this resource
    //
    if (buffer->GFlag & PNP_ADDRESS_FLAG_CONSUMED_ONLY &&
        buffer->RFlag == PNP_ADDRESS_IO_TYPE &&
        Flags & PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES) {

        return STATUS_SUCCESS;

    }

    //
    // If the length of the address range is zero, ignore this descriptor.
    // This makes it easier for BIOS writers to set up a template and then
    // whack its length to zero if it doesn't apply.
    //
    if (buffer->AddressLength == 0) {

        return STATUS_SUCCESS;

    }
    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &rangeDescriptor );
    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // If this is I/O or Memory, then we will need to make enough space for
    // a device private resource too.
    //
    if ((buffer->RFlag == PNP_ADDRESS_MEMORY_TYPE) ||
        (buffer->RFlag == PNP_ADDRESS_IO_TYPE)) {

        status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &privateDescriptor );

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Calling PnpiUpdateResourceList may have invalidated
        // rangeDescriptor.  So make sure it's OK now.
        //

        ASSERT(Array[ArrayIndex]->Count >= 2);
        rangeDescriptor = privateDescriptor - 1;

        privateDescriptor->Type = CmResourceTypeDevicePrivate;

        //
        // Mark this descriptor as containing the start
        // address of the translated resource.
        //
        privateDescriptor->Flags = TRANSLATION_DATA_PARENT_ADDRESS;

        //
        // Fill in the top 32 bits of the start address.
        //
        privateDescriptor->u.DevicePrivate.Data[2] = 0;
    }

    //
    //
    // Do we met the minimum length requirements ?
    //
    if ( buffer->Length < PNP_ADDRESS_DWORD_MINIMUM_LENGTH) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "PnpiBiosAddressDoubleToIoDescriptor: Descriptor too small 0x%08lx\n",
            buffer->Length ) );

        //
        // We can go no further
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_PNP_RESOURCE_LIST_BUFFER_TOO_SMALL,
            (ULONG_PTR) buffer,
            buffer->Tag,
            buffer->Length
            );
    }

    //
    // Length is the stored within the descriptor record
    //
    length = (ULONG) (buffer->AddressLength);
    alignment = (ULONG) (buffer->Granularity) + 1;

    //
    // Calculate the bounds of both the parent and child sides of
    // the bridge.
    //
    // The translation field applies to the parent address i.e.
    // the child address is the address in the buffer and the
    // parent address is the addition of the child address and
    // the translation field.
    //

    parentMin = buffer->MinimumAddress + buffer->TranslationAddress;
    childMin = buffer->MinimumAddress;
    childMax = buffer->MaximumAddress;

    //
    // Patch the length based on wether or not the min/max flags are set
    //
    if ( (buffer->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED) &&
         (buffer->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) ) {

        ULONG   length2;
        ULONG   alignment2;

        //
        // Calculate the length based on the fact that the min and
        // max addresses are locked down.
        //
        length2 = childMax - childMin + 1;

        //
        // Test #1 --- The length had better be correct
        //
        if (length2 != length) {

            //
            // Bummer. Let the world know
            //
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPI: Length does not match fixed attributes\n"
                ) );
            length = length2;

        }

        //
        // Test #2 --- The granularity had also better be correct
        //
        if ( (childMin & (ULONG) buffer->Granularity) ) {

            //
            // Bummer. Let the world know
            //
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPI: Granularity does not match fixed attributes\n"
                ) );
            alignment = 1;

        }

    }

    //
    // Handle the Resource type seperately
    //
    switch (buffer->RFlag) {
    case PNP_ADDRESS_MEMORY_TYPE:

        //
        // Set the proper ranges
        //

        rangeDescriptor->u.Memory.Alignment = alignment;
        rangeDescriptor->u.Memory.Length = length;
        rangeDescriptor->u.Memory.MinimumAddress.LowPart = childMin;
        rangeDescriptor->u.Memory.MaximumAddress.LowPart = childMax;
        rangeDescriptor->u.Memory.MinimumAddress.HighPart =
            rangeDescriptor->u.Memory.MaximumAddress.HighPart = 0;
        rangeDescriptor->Type = CmResourceTypeMemory;

        //
        // The child address is the address in the PnP address
        // space descriptor and the child descriptor will inherit
        // the descriptor type from the PnP address space
        // descriptor.
        //

        if (buffer->TFlag & TRANSLATION_MEM_TO_IO) {

            //
            // The device private describes the parent. With this
            // flag set, the descriptor type of the parent will
            // changed from Memory to IO.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypePort;

        } else {

            //
            // The parent descriptor type will not change.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypeMemory;

        }

        //
        // Fill in the bottom 32 bits of the parent's start address.
        //
        privateDescriptor->u.DevicePrivate.Data[1] = parentMin;

        //
        // Handle memory flags
        //
        PnpiBiosAddressHandleMemoryFlags( buffer, rangeDescriptor );

        //
        // Reset the alignment
        //
        rangeDescriptor->u.Memory.Alignment = 1;
        break;

    case PNP_ADDRESS_IO_TYPE:

        //
        // Any flags that are set here must be handled
        // through the use of device privates
        //
        rangeDescriptor->u.Port.Alignment = alignment;
        rangeDescriptor->u.Port.Length = length;
        rangeDescriptor->u.Port.MinimumAddress.LowPart = childMin;
        rangeDescriptor->u.Port.MaximumAddress.LowPart = childMax;
        rangeDescriptor->u.Port.MinimumAddress.HighPart =
            rangeDescriptor->u.Port.MaximumAddress.HighPart = 0;
        rangeDescriptor->Type = CmResourceTypePort;


        if (buffer->TFlag & PNP_ADDRESS_TYPE_IO_SPARSE_TRANSLATION) {
            privateDescriptor->Flags |= TRANSLATION_RANGE_SPARSE;
        }


        if (buffer->TFlag & PNP_ADDRESS_TYPE_IO_TRANSLATE_IO_TO_MEM) {

            //
            // The device private describes the parent. With this
            // flag set, the descriptor type of the parent will
            // changed from IO to Memory.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypeMemory;

        } else {

            //
            // The parent descriptor type will not change.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypePort;

        }

        //
        // Fill in the bottom 32 bits of the parent's start address.
        //
        privateDescriptor->u.DevicePrivate.Data[1] = parentMin;

        //
        // Handle port flags
        //
        PnpiBiosAddressHandlePortFlags( buffer, rangeDescriptor );

        //
        // Reset the alignment
        //
        rangeDescriptor->u.Port.Alignment = 1;
        break;

    case PNP_ADDRESS_BUS_NUMBER_TYPE:

        rangeDescriptor->Type = CmResourceTypeBusNumber;
        rangeDescriptor->u.BusNumber.Length = length;
        rangeDescriptor->u.BusNumber.MinBusNumber = (buffer->MinimumAddress);
        rangeDescriptor->u.BusNumber.MaxBusNumber = (buffer->MaximumAddress);

        //
        // Handle busnumber flags
        //
        PnpiBiosAddressHandleBusFlags( buffer, rangeDescriptor );
        break;

    default:

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "PnpiBiosAddressDoubleToIoDescriptor: Unknown Type 0x%2x\n",
            buffer->RFlag ) );
        break;

    }

    //
    // Handle global flags
    //
    PnpiBiosAddressHandleGlobalFlags( buffer, rangeDescriptor );
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiBiosAddressQuadToIoDescriptor(
    IN  PUCHAR              Data,
    IN  PIO_RESOURCE_LIST   Array[],
    IN  ULONG               ArrayIndex,
    IN  ULONG               Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                        status;
    PIO_RESOURCE_DESCRIPTOR         rangeDescriptor, privateDescriptor;
    PPNP_QWORD_ADDRESS_DESCRIPTOR   buffer;
    UCHAR                           decodeLength;
    ULONGLONG                       alignment;
    ULONGLONG                       length;
    ULONGLONG                       parentMin, childMin, childMax;

    PAGED_CODE();
    ASSERT( Array != NULL );

    buffer = (PPNP_QWORD_ADDRESS_DESCRIPTOR) Data;

    //
    // Check to see if we are are allowed to use this resource
    //
    if (buffer->GFlag & PNP_ADDRESS_FLAG_CONSUMED_ONLY &&
        buffer->RFlag == PNP_ADDRESS_IO_TYPE &&
        Flags & PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES) {

        return STATUS_SUCCESS;

    }

    //
    // If the length of the address range is zero, ignore this descriptor.
    // This makes it easier for BIOS writers to set up a template and then
    // whack its length to zero if it doesn't apply.
    //
    if (buffer->AddressLength == 0) {

        return STATUS_SUCCESS;

    }

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &rangeDescriptor );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // If this is I/O or Memory, then we will need to make enough space for
    // a device private resource too.
    //
    if ((buffer->RFlag == PNP_ADDRESS_MEMORY_TYPE) ||
        (buffer->RFlag == PNP_ADDRESS_IO_TYPE)) {

        status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &privateDescriptor );

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Calling PnpiUpdateResourceList may have invalidated
        // rangeDescriptor.  So make sure it's OK now.
        //

        ASSERT(Array[ArrayIndex]->Count >= 2);
        rangeDescriptor = privateDescriptor - 1;

        privateDescriptor->Type = CmResourceTypeDevicePrivate;

        //
        // Mark this descriptor as containing the start
        // address of the translated resource.
        //
        privateDescriptor->Flags = TRANSLATION_DATA_PARENT_ADDRESS;
    }

    //
    //
    // Do we met the minimum length requirements ?
    //
    if ( buffer->Length < PNP_ADDRESS_QWORD_MINIMUM_LENGTH) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "PnpiBiosAddressQuadToIoDescriptor: Descriptor too small 0x%08lx\n",
            buffer->Length ) );

        //
        // We can go no further
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_PNP_RESOURCE_LIST_BUFFER_TOO_SMALL,
            (ULONG_PTR) buffer,
            buffer->Tag,
            buffer->Length
            );
    }

    //
    // Length is the stored within the descriptor record
    //
    length = (ULONGLONG) (buffer->AddressLength);
    alignment = (ULONGLONG) (buffer->Granularity) + 1;

    //
    // Calculate the bounds of both the parent and child sides of
    // the bridge.
    //
    // The translation field applies to the parent address i.e.
    // the child address is the address in the buffer and the
    // parent address is the addition of the child address and
    // the translation field.
    //

    parentMin = buffer->MinimumAddress + buffer->TranslationAddress;
    childMin = buffer->MinimumAddress;
    childMax = buffer->MaximumAddress;

    //
    // Patch the length based on wether or not the min/max flags are set
    //
    if ( (buffer->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED) &&
         (buffer->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) ) {

        ULONGLONG   length2;
        ULONGLONG   alignment2;

        //
        // Calculate the length based on the fact that the min and
        // max addresses are locked down.
        //
        length2 = childMax - childMin + 1;

        //
        // Test #1 --- The length had better be correct
        //
        if (length2 != length) {

            //
            // Bummer. Let the world know
            //
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPI: Length does not match fixed attributes\n"
                ) );
            length = length2;

        }

        //
        // Test #2 --- The granularity had also better be correct
        //
        if ( (childMin & (ULONGLONG) buffer->Granularity) ) {

            //
            // Bummer. Let the world know
            //
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPI: Granularity does not match fixed attributes\n"
                ) );
            alignment = 1;

        }
    }

    //
    // Handle the Resource type seperately
    //
    switch (buffer->RFlag) {
    case PNP_ADDRESS_MEMORY_TYPE:

        //
        // Set the proper ranges
        //
        rangeDescriptor->u.Memory.Alignment = (ULONG) alignment ;
        rangeDescriptor->u.Memory.Length = (ULONG) length;
        rangeDescriptor->u.Memory.MinimumAddress.QuadPart = childMin;
        rangeDescriptor->u.Memory.MaximumAddress.QuadPart = childMax;
        rangeDescriptor->Type = CmResourceTypeMemory;

        //
        // The child address is the address in the PnP address
        // space descriptor and the child descriptor will inherit
        // the descriptor type from the PnP address space
        // descriptor.
        //


        if (buffer->TFlag & TRANSLATION_MEM_TO_IO) {

            //
            // The device private describes the parent. With this
            // flag set, the descriptor type of the parent will
            // changed from Memory to IO.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
               CmResourceTypePort;

        } else {

            //
            // The parent descriptor type will not change.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
               CmResourceTypeMemory;

        }

        //
        // Fill in all 64 bits of the start address.
        //
        privateDescriptor->u.DevicePrivate.Data[1] = (ULONG)(parentMin & 0xffffffff);
        privateDescriptor->u.DevicePrivate.Data[2] = (ULONG)(parentMin >> 32);

        //
        // Handle memory flags
        //
        PnpiBiosAddressHandleMemoryFlags( buffer, rangeDescriptor );
        break;

    case PNP_ADDRESS_IO_TYPE:

        //
        // Any flags that are set here must be handled
        // through the use of device privates
        //
        rangeDescriptor->u.Port.Alignment = (ULONG) alignment;
        rangeDescriptor->u.Port.Length = (ULONG) length;
        rangeDescriptor->u.Port.MinimumAddress.QuadPart = childMin;
        rangeDescriptor->u.Port.MaximumAddress.QuadPart = childMax;
        rangeDescriptor->Type = CmResourceTypePort;


        if (buffer->TFlag & PNP_ADDRESS_TYPE_IO_SPARSE_TRANSLATION) {
            privateDescriptor->Flags |= TRANSLATION_RANGE_SPARSE;
        }
        

        if (buffer->TFlag & PNP_ADDRESS_TYPE_IO_TRANSLATE_IO_TO_MEM) {

            //
            // The device private describes the parent. With this
            // flag set, the descriptor type of the parent will
            // change from IO to Memory.
            //

            privateDescriptor->u.DevicePrivate.Data[0] = CmResourceTypeMemory;

        } else {

            //
            // Bridges that implement I/O on the parent side never
            // implement memory on the child side.
            //
            privateDescriptor->u.DevicePrivate.Data[0] = CmResourceTypePort;
        }

        //
        // Fill in all 64 bits of the start address.
        //
        privateDescriptor->u.DevicePrivate.Data[1] = (ULONG)(parentMin & 0xffffffff);
        privateDescriptor->u.DevicePrivate.Data[2] = (ULONG)(parentMin >> 32);

        //
        // Handle port flags
        //
        PnpiBiosAddressHandlePortFlags( buffer, rangeDescriptor );

        //
        // Reset the alignment
        //
        rangeDescriptor->u.Port.Alignment = 1;
        break;

    case PNP_ADDRESS_BUS_NUMBER_TYPE:

        rangeDescriptor->Type = CmResourceTypeBusNumber;
        rangeDescriptor->u.BusNumber.Length = (ULONG) length;
        rangeDescriptor->u.BusNumber.MinBusNumber = (ULONG) (buffer->MinimumAddress);
        rangeDescriptor->u.BusNumber.MaxBusNumber = (ULONG) (buffer->MaximumAddress);

        //
        // Handle busnumber flags
        //
        PnpiBiosAddressHandleBusFlags( buffer, rangeDescriptor );
        break;

    default:

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "PnpiBiosAddressQuadToIoDescriptor: Unknown Type 0x%2x\n",
            buffer->RFlag ) );
        break;

    }

    //
    // Handle global flags
    //
    PnpiBiosAddressHandleGlobalFlags( buffer, rangeDescriptor );
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiBiosDmaToIoDescriptor (
    IN  PUCHAR                  Data,
    IN  UCHAR                   Channel,
    IN  PIO_RESOURCE_LIST       Array[],
    IN  ULONG                   ArrayIndex,
    IN  USHORT                  Count,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PPNP_DMA_DESCRIPTOR     buffer;

    PAGED_CODE();
    ASSERT (Array != NULL);

    buffer = (PPNP_DMA_DESCRIPTOR)Data;

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &descriptor );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Fill in Io resource descriptor
    //
    descriptor->Option = (Count ? IO_RESOURCE_ALTERNATIVE : 0);
    descriptor->Type = CmResourceTypeDma;
    descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    descriptor->u.Dma.MinimumChannel = Channel;
    descriptor->u.Dma.MaximumChannel = Channel;

    //
    // Set some information about the type of DMA channel
    //
    switch ( (buffer->Flags & PNP_DMA_SIZE_MASK) ) {
    case PNP_DMA_SIZE_8:
        descriptor->Flags |= CM_RESOURCE_DMA_8;
        break;
    case PNP_DMA_SIZE_8_AND_16:
        descriptor->Flags |= CM_RESOURCE_DMA_8_AND_16;
        break;
    case PNP_DMA_SIZE_16:
        descriptor->Flags |= CM_RESOURCE_DMA_16;
        break;
    case PNP_DMA_SIZE_RESERVED:
    default:
        ASSERT( (buffer->Flags & 0x3) == 0x3);
        descriptor->Flags |= CM_RESOURCE_DMA_32;
        break;

    }
    if ( (buffer->Flags & PNP_DMA_BUS_MASTER) ) {

        descriptor->Flags |= CM_RESOURCE_DMA_BUS_MASTER;

    }
    switch ( (buffer->Flags & PNP_DMA_TYPE_MASK) ) {
    default:
    case PNP_DMA_TYPE_COMPATIBLE:
        break;
    case PNP_DMA_TYPE_A:
        descriptor->Flags |= CM_RESOURCE_DMA_TYPE_A;
        break;
    case PNP_DMA_TYPE_B:
        descriptor->Flags |= CM_RESOURCE_DMA_TYPE_B;
        break;
    case PNP_DMA_TYPE_F:
        descriptor->Flags |= CM_RESOURCE_DMA_TYPE_F;
        break;
    }

    return status;
}

NTSTATUS
PnpiBiosExtendedIrqToIoDescriptor (
    IN  PUCHAR                  Data,
    IN  UCHAR                   DataIndex,
    IN  PIO_RESOURCE_LIST       Array[],
    IN  ULONG                   ArrayIndex,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                        status = STATUS_SUCCESS;
    PIO_RESOURCE_DESCRIPTOR         descriptor;
    PPNP_EXTENDED_IRQ_DESCRIPTOR    buffer;
    PULONG                          polarity;

    PAGED_CODE();
    ASSERT (Array != NULL);

    buffer = (PPNP_EXTENDED_IRQ_DESCRIPTOR)Data;

    //
    // Are we within bounds?
    //
    if (DataIndex >= buffer->TableSize) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Is the vector null? If so, then this is a 'skip' condition
    //
    if (buffer->Table[DataIndex] == 0) {

        return STATUS_SUCCESS;

    }

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &descriptor );

    if (!NT_SUCCESS(status)) {
        return status;

    }

    //
    // Fill in Io resource descriptor
    //
    descriptor->Option = (DataIndex ? IO_RESOURCE_ALTERNATIVE : 0);
    descriptor->Type = CmResourceTypeInterrupt;
    descriptor->u.Interrupt.MinimumVector =
        descriptor->u.Interrupt.MaximumVector = buffer->Table[DataIndex];

    //
    // Crack the rest of the flags
    //
    descriptor->Flags = 0;
    if ((buffer->Flags & PNP_EXTENDED_IRQ_MODE) == $LVL) {

        descriptor->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;

        //
        // Crack the share flags
        //
        if (buffer->Flags & PNP_EXTENDED_IRQ_SHARED) {

            descriptor->ShareDisposition = CmResourceShareShared;

        } else {

            descriptor->ShareDisposition = CmResourceShareDeviceExclusive;

        }
    }
    if ((buffer->Flags & PNP_EXTENDED_IRQ_MODE) == $EDG) {

        descriptor->Flags = CM_RESOURCE_INTERRUPT_LATCHED;

        //
        // Crack the share flags
        //
        if (buffer->Flags & PNP_EXTENDED_IRQ_SHARED) {

            descriptor->ShareDisposition = CmResourceShareDriverExclusive;

        } else {

            descriptor->ShareDisposition = CmResourceShareDeviceExclusive;

        }
    }

    //
    // Warning!  Awful HACK coming.
    //
    //  The original designer of the flags for CmResourceTypeInterrupt
    //  was bad.  Instead of a bit field, it's an enum.  Which means
    //  that we can't add any flags now.  So I'm stuffing the interrupt
    //  polarity information into an unused DWORD of the IO_RES_LIST.
    //
    polarity = (PULONG)(&descriptor->u.Interrupt.MaximumVector) + 1;

    if ((buffer->Flags & PNP_EXTENDED_IRQ_POLARITY) == $LOW) {

        *polarity = VECTOR_ACTIVE_LOW;

    } else {

        *polarity = VECTOR_ACTIVE_HIGH;

    }

    //
    // To show anything else, we will need to use device private
    // resources
    //
    return status;
}

NTSTATUS
PnpiBiosIrqToIoDescriptor (
    IN  PUCHAR                  Data,
    IN  USHORT                  Interrupt,
    IN  PIO_RESOURCE_LIST       Array[],
    IN  ULONG                   ArrayIndex,
    IN  USHORT                  Count,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PPNP_IRQ_DESCRIPTOR     buffer;
    PULONG                  polarity;

    PAGED_CODE();
    ASSERT (Array != NULL);

    buffer = (PPNP_IRQ_DESCRIPTOR)Data;

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &descriptor );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Fill in the resource descriptor
    //
    descriptor->Option = (Count ? IO_RESOURCE_ALTERNATIVE : 0);
    descriptor->Type = CmResourceTypeInterrupt;
    descriptor->u.Interrupt.MinimumVector = Interrupt;
    descriptor->u.Interrupt.MaximumVector = Interrupt;

    //
    // Warning!  Awful HACK coming.
    //
    //  The original designer of the flags for CmResourceTypeInterrupt
    //  was bad.  Instead of a bit field, it's an enum.  Which means
    //  that we can't add any flags now.  So I'm stuffing the interrupt
    //  polarity information into an unused DWORD of the IO_RES_LIST.
    //

    polarity = (PULONG)(&descriptor->u.Interrupt.MaximumVector) + 1;

    if ( (buffer->Tag & SMALL_TAG_SIZE_MASK) == 3) {

        //
        // Set the type flags
        //
        descriptor->Flags = 0;
        if (buffer->Information & PNP_IRQ_LATCHED) {

            descriptor->Flags |= CM_RESOURCE_INTERRUPT_LATCHED;
            *polarity = VECTOR_ACTIVE_HIGH;

            //
            // Set the share flags
            //
            if (buffer->Information & PNP_IRQ_SHARED) {

                descriptor->ShareDisposition = CmResourceShareDriverExclusive;

            } else {

                descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
            }
        }

        if (buffer->Information & PNP_IRQ_LEVEL) {

            descriptor->Flags |= CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
            *polarity = VECTOR_ACTIVE_LOW;

            //
            // Set the share flags
            //
            if (buffer->Information & PNP_IRQ_SHARED) {

                descriptor->ShareDisposition = CmResourceShareShared;

            } else {

                descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
            }
        }

    } else {

        descriptor->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
        descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    }

    return status;
}

NTSTATUS
PnpiBiosMemoryToIoDescriptor (
    IN  PUCHAR                  Data,
    IN  PIO_RESOURCE_LIST       Array[],
    IN  ULONG                   ArrayIndex,
    IN  ULONG                   Flags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PHYSICAL_ADDRESS        minAddr;
    PHYSICAL_ADDRESS        maxAddr;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    UCHAR                   tag;
    ULONG                   alignment;
    ULONG                   length = 0;
    USHORT                  flags;

    PAGED_CODE();
    ASSERT (Array != NULL);

    //
    // Grab the memory range limits
    //
    tag = ((PPNP_MEMORY_DESCRIPTOR)Data)->Tag;
    minAddr.HighPart = 0;
    maxAddr.HighPart = 0;
    flags = 0;

    //
    // Setup the flags
    //
    if ( ((PPNP_MEMORY_DESCRIPTOR)Data)->Information & PNP_MEMORY_READ_WRITE) {

        flags |= CM_RESOURCE_MEMORY_READ_WRITE;

    } else {

        flags |= CM_RESOURCE_MEMORY_READ_ONLY;

    }

    //
    // Grab the other values from the descriptor
    //
    switch (tag) {
    case TAG_MEMORY: {

        PPNP_MEMORY_DESCRIPTOR  buffer;

        //
        // 24 Bit Memory
        //
        flags |= CM_RESOURCE_MEMORY_24;

        buffer = (PPNP_MEMORY_DESCRIPTOR) Data;
        length = ( (ULONG)(buffer->MemorySize) ) << 8;
        minAddr.LowPart =( (ULONG)(buffer->MinimumAddress) ) << 8;
        maxAddr.LowPart =( ( (ULONG)(buffer->MaximumAddress) ) << 8) + length - 1;
        if ( (alignment = buffer->Alignment) == 0) {

             alignment = 0x10000;

        }
        break;

    }
    case TAG_MEMORY32: {

        PPNP_MEMORY32_DESCRIPTOR    buffer;

        buffer = (PPNP_MEMORY32_DESCRIPTOR) Data;
        length = buffer->MemorySize;
        minAddr.LowPart = buffer->MinimumAddress;
        maxAddr.LowPart = buffer->MaximumAddress +length - 1;
        alignment = buffer->Alignment;
        break;

    }
    case TAG_MEMORY32_FIXED: {

        PPNP_FIXED_MEMORY32_DESCRIPTOR  buffer;

        buffer = (PPNP_FIXED_MEMORY32_DESCRIPTOR) Data;
        length = buffer->MemorySize;
        minAddr.LowPart = buffer->BaseAddress;
        maxAddr.LowPart = minAddr.LowPart + length - 1;
        alignment = 1;
        break;

    }
    default:

         ASSERT( (tag != TAG_MEMORY) || (tag != TAG_MEMORY32) ||
             (tag != TAG_MEMORY32_FIXED) );

    }

    //
    // If the length that we calculated is 0, then we don't have a real
    // descriptor that we should report
    //
    if (length == 0) {

        return STATUS_SUCCESS;

    }

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &descriptor );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Fill in common memory buffers
    //
    descriptor->Type = CmResourceTypeMemory;
    descriptor->Flags = (CM_RESOURCE_PORT_MEMORY | flags);
    descriptor->ShareDisposition = CmResourceShareDeviceExclusive;

    //
    // Fill in Memory Descriptor
    //
    descriptor->u.Memory.MinimumAddress = minAddr;
    descriptor->u.Memory.MaximumAddress = maxAddr;
    descriptor->u.Memory.Alignment = alignment;
    descriptor->u.Memory.Length = length;

    return STATUS_SUCCESS;
}

NTSTATUS
PnpiBiosPortFixedToIoDescriptor (
    IN  PUCHAR                  Data,
    IN  PIO_RESOURCE_LIST       Array[],
    IN  ULONG                   ArrayIndex,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PIO_RESOURCE_DESCRIPTOR     descriptor;
    PPNP_FIXED_PORT_DESCRIPTOR  buffer;

    PAGED_CODE();
    ASSERT (Array != NULL);

    buffer = (PPNP_FIXED_PORT_DESCRIPTOR)Data;

    //
    // Check to see if we are are allowed to use this resource
    //
    if (Flags & PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES) {

        return STATUS_SUCCESS;

    }

    //
    // If the length of the descriptor is 0, then we don't have a descriptor
    // that we can report to the OS
    //
    if (buffer->Length == 0 ) {

        return STATUS_SUCCESS;

    }

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &descriptor );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Fill in Io resource descriptor
    //
    descriptor->Type = CmResourceTypePort;
    descriptor->Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_10_BIT_DECODE;
    descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    descriptor->u.Port.Length = (ULONG)buffer->Length;
    descriptor->u.Port.MinimumAddress.LowPart = (ULONG)(buffer->MinimumAddress & 0x3ff);
    descriptor->u.Port.MaximumAddress.LowPart = (ULONG)(buffer->MinimumAddress & 0x3ff) +
        (ULONG)buffer->Length - 1;
    descriptor->u.Port.Alignment = 1;

    return STATUS_SUCCESS;
}

NTSTATUS
PnpiBiosPortToIoDescriptor (
    IN  PUCHAR                  Data,
    IN  PIO_RESOURCE_LIST       Array[],
    IN  ULONG                   ArrayIndex,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PIO_RESOURCE_DESCRIPTOR     descriptor;
    PPNP_PORT_DESCRIPTOR        buffer;

    PAGED_CODE();
    ASSERT (Array != NULL);

    buffer = (PPNP_PORT_DESCRIPTOR)Data;

    //
    // Check to see if we are are allowed to use this resource
    //
    if (Flags & PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES) {

        return STATUS_SUCCESS;

    }

    //
    // If the length of the descriptor is 0, then we don't have a descriptor
    // that we can report to the OS
    //
    if (buffer->Length == 0 ) {

        return STATUS_SUCCESS;

    }

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &descriptor );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Fill in Io resource descriptor
    //
    descriptor->Type = CmResourceTypePort;
    descriptor->Flags = CM_RESOURCE_PORT_IO;
    descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    descriptor->u.Port.Length = (ULONG)buffer->Length;
    descriptor->u.Port.MinimumAddress.LowPart = (ULONG)buffer->MinimumAddress;
    descriptor->u.Port.MaximumAddress.LowPart = (ULONG)buffer->MaximumAddress +
        buffer->Length - 1;
    descriptor->u.Port.Alignment = (ULONG)buffer->Alignment;

    //
    // Set the flags
    //
    switch (buffer->Information & PNP_PORT_DECODE_MASK) {
    case PNP_PORT_10_BIT_DECODE:
        descriptor->Flags |= CM_RESOURCE_PORT_10_BIT_DECODE;
        break;
    default:
    case PNP_PORT_16_BIT_DECODE:
        descriptor->Flags |= CM_RESOURCE_PORT_16_BIT_DECODE;
        break;
    }

    return STATUS_SUCCESS;
}

VOID
PnpiClearAllocatedMemory(
    IN      PIO_RESOURCE_LIST       ResourceArray[],
    IN      ULONG                   ResourceArraySize
    )
/*++

Routine Description:

    This routine frees all the memory that was allocated in building the resource
    lists in the system

Arguments:

    ResourceArray       - Table of PIO_RESOURCE_LIST
    ResourceArraySize   - How large the table is

Return Value:

    VOID

--*/
{
    ULONG   i;

    PAGED_CODE();

    if (ResourceArray == NULL) {

        return;
    }

    for (i = 0; i < ResourceArraySize; i++) {

        if (ResourceArray[i] != NULL) {

            ExFreePool( ResourceArray[i] );
        }
    }

    ExFreePool( ResourceArray );
}

NTSTATUS
PnpiGrowResourceDescriptor(
    IN  OUT PIO_RESOURCE_LIST       *ResourceList
    )
/*++

Routine Description:

    This routine takes a pointer to a Resource list and returns a pointer to resource list
    that contained all the old information, but is now larger


Arguments:

    ResourceList    - ResourceList pointer to change

Return Value:

    NTSTATUS (in case the memory allocation fails)

--*/
{
    NTSTATUS    status;
    ULONG       count = 0;
    ULONG       size = 0;
    ULONG       size2 = 0;

    PAGED_CODE();
    ASSERT( ResourceList != NULL );

    //
    // Are we looking at a null resource list???
    //
    if (*ResourceList == NULL) {

        //
        // Determine how much space is required
        //
        count = 0;
        size = sizeof(IO_RESOURCE_LIST) + ( (count + 7) * sizeof(IO_RESOURCE_DESCRIPTOR) );

        ACPIPrint( (
            ACPI_PRINT_RESOURCES_2,
            "PnpiGrowResourceDescriptor: Count: %d -> %d, Size: %#08lx\n",
            count, count + RESOURCE_LIST_GROWTH_SIZE, size
            ) );

        //
        // Allocate the ResourceList
        //
        *ResourceList = ExAllocatePoolWithTag( PagedPool, size, ACPI_RESOURCE_POOLTAG );

        //
        // Failed?
        //
        if (*ResourceList == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Init resource list
        //
        RtlZeroMemory( *ResourceList, size );
        (*ResourceList)->Version = 0x01;
        (*ResourceList)->Revision = 0x01;
        (*ResourceList)->Count = 0x00;

        return STATUS_SUCCESS;

    }

    //
    // We already have a resource list, so what we should do is add 8 to the number of
    // existing blocks that we have now, and copy over the old memory
    //
    count = (*ResourceList)->Count ;
    size = sizeof(IO_RESOURCE_LIST) + ( (count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) );
    size2 = size + (8 * sizeof(IO_RESOURCE_DESCRIPTOR) );

    ACPIPrint( (
        ACPI_PRINT_RESOURCES_2,
        "PnpiGrowResourceDescriptor: Count: %d -> %d, Size: %#08lx\n",
        count, count + RESOURCE_LIST_GROWTH_SIZE, size2
        ) );

    //
    // Grow the List
    //
    status = ACPIInternalGrowBuffer( ResourceList, size, size2 );

    return status;
}

NTSTATUS
PnpiGrowResourceList(
    IN  OUT PIO_RESOURCE_LIST       *ResourceListArray[],
    IN  OUT ULONG                   *ResourceListArraySize
    )
/*++

Routine Description:

    This function is responsible for growing the array of resource lists

Arguments:

    ResourceListArray - An array of pointers to IO_RESOURCE_LISTs
    ResourceListSize  - The current size of the array

Return Value:

    NTSTATUS (in case memory allocation fails)

--*/
{
    NTSTATUS    status;
    ULONG       count;
    ULONG       size;
    ULONG       size2;

    PAGED_CODE();
    ASSERT( ResourceListArray != NULL);

    //
    // Its always a special case if the table is null
    //
    if ( *ResourceListArray == NULL || *ResourceListArraySize == 0) {

        count = 0;
        size = (count + RESOURCE_LIST_GROWTH_SIZE ) * sizeof(PIO_RESOURCE_LIST);

        ACPIPrint( (
            ACPI_PRINT_RESOURCES_2,
            "PnpiGrowResourceList: Count: %d -> %d, Size: %#08lx\n",
            count, count + RESOURCE_LIST_GROWTH_SIZE, size
            ) );

        //
        // Allocate the ResourceListArray
        //
        *ResourceListArray = ExAllocatePoolWithTag( PagedPool, size, ACPI_RESOURCE_POOLTAG );

        //
        // Failed?
        //
        if (*ResourceListArray == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Increment the size
        //
        *ResourceListArraySize = count + RESOURCE_LIST_GROWTH_SIZE;
        RtlZeroMemory( *ResourceListArray, size );

        return STATUS_SUCCESS;
    }

    count = *ResourceListArraySize;
    size  = count * sizeof(PIO_RESOURCE_LIST);
    size2 = size + (RESOURCE_LIST_GROWTH_SIZE * sizeof(PIO_RESOURCE_LIST));

    ACPIPrint( (
        ACPI_PRINT_RESOURCES_2,
        "PnpiGrowResourceList: Count: %d -> %d, Size: %#08lx\n",
        count, count + RESOURCE_LIST_GROWTH_SIZE, size2
        ) );

    status = ACPIInternalGrowBuffer( (PVOID *) ResourceListArray, size, size2 );
    if (!NT_SUCCESS(status)) {

        *ResourceListArraySize = 0;

    } else {

        *ResourceListArraySize = (count + RESOURCE_LIST_GROWTH_SIZE);
    }

    return status;
}

NTSTATUS
PnpiUpdateResourceList(
    IN  OUT PIO_RESOURCE_LIST       *ResourceList,
        OUT PIO_RESOURCE_DESCRIPTOR *ResourceDesc
    )
/*++

Routine Description:

    This function is called when a new resource is about to be added. This routine
    ensures that enough space is present within the list, and gives a pointer to the
    location of the Resource Descriptor where the list should be added...

Arguments:

    ResourceList    - Pointer to list to check
    ResourceDesc    - Location to store pointer to descriptor

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;

    PAGED_CODE();
    ASSERT( ResourceList != NULL);

    if ( *ResourceList == NULL ||
         (*ResourceList)->Count % RESOURCE_LIST_GROWTH_SIZE == 0) {

        //
        // Oops, not enough space for the next descriptor
        //
        status = PnpiGrowResourceDescriptor( ResourceList );

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    //
    // Find the next descriptor to use
    //
    *ResourceDesc = & ( (*ResourceList)->Descriptors[ (*ResourceList)->Count ] );

    //
    // Update the count of in-use descriptors
    //
    (*ResourceList)->Count += 1;

    return status;
}

NTSTATUS
PnpBiosResourcesToNtResources(
    IN      PUCHAR                          Data,
    IN      ULONG                           Flags,
        OUT PIO_RESOURCE_REQUIREMENTS_LIST  *List
    )
/*++

Routine Description:

    This routine parses the Bios resource list and generates an NT resource list.
    The returned NT resource list must be freed by the caller

Arguments:

    Data    - Pointer to PNP ISA Configuration Information
    Flags   - Options to use when parsing the data
    List    - Pointer to NT Configuration Information

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS            status;
    PIO_RESOURCE_LIST   *Array = NULL;
    PUCHAR              buffer;
    UCHAR               tagName;
    USHORT              increment;
    ULONG               ArraySize = 0;
    ULONG               ArrayIndex = 0;
    ULONG               ArrayAlternateIndex = 0;
    ULONG               size;
    ULONG               size2;

    PAGED_CODE();
    ASSERT( Data != NULL );

    //
    // First we need to build the pointer list
    //
    status = PnpiGrowResourceList( &Array, &ArraySize );

    if (!NT_SUCCESS(status)) {
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "PnpBiosResourcesToNtResources: PnpiGrowResourceList = 0x%8lx\n",
            status ) );

        return status;
    }

    //
    // Setup initial variables
    //
    buffer = Data;
    tagName = *buffer;

    //
    // Look through all the descriptors.
    //
    while (TRUE) {

        //
        // Determine the size of the PNP resource descriptor
        //
        if ( !(tagName & LARGE_RESOURCE_TAG) ) {

            //
            // Small Tag
            //
            increment = (USHORT) (tagName & SMALL_TAG_SIZE_MASK) + 1;
            tagName &= SMALL_TAG_MASK;

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: small = %#02lx incr = 0x%2lx\n",
                tagName, increment ) );

        } else {

            //
            // Large Tag
            //
            increment = ( *(USHORT UNALIGNED *)(buffer+1) ) + 3;

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: large = %#02lx incr = 0x%2lx\n",
                tagName, increment
                ) );
        }

        //
        // We are done if the current tag is the end tag
        //
        if (tagName == TAG_END) {

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_END\n"
                ) );
            break;
        }

        switch(tagName) {
        case TAG_IRQ: {

            USHORT  mask = ( (PPNP_IRQ_DESCRIPTOR)buffer)->IrqMask;
            USHORT  interrupt = 0;
            USHORT  count = 0;

            //
            // Find all of interrupts to set
            //
            for ( ;mask && NT_SUCCESS(status); interrupt++, mask >>= 1) {

                if (mask & 1) {

                    status = PnpiBiosIrqToIoDescriptor(
                        buffer,
                        interrupt,
                        Array,
                        ArrayIndex,
                        count,
                        Flags
                        );

                    count++;
                }
            }

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_IRQ(count: 0x%2lx) "
                "= 0x%8lx\n",
                count, status
                ) );

            break;
            }

        case TAG_EXTENDED_IRQ: {

            UCHAR   tableSize =
                ( (PPNP_EXTENDED_IRQ_DESCRIPTOR)buffer)->TableSize;
            UCHAR   irqCount = 0;

            //
            // For each of the interrupts to set, do
            //
            for ( ;irqCount < tableSize && NT_SUCCESS(status); irqCount++) {

                status = PnpiBiosExtendedIrqToIoDescriptor(
                    buffer,
                    irqCount,
                    Array,
                    ArrayIndex,
                    Flags
                    );
            }

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_EXTENDED_IRQ(count: "
                "0x%2lx) = 0x%8lx\n",
                irqCount, status
                ) );

            break;
            }

        case TAG_DMA: {

            UCHAR   mask = ( (PPNP_DMA_DESCRIPTOR)buffer)->ChannelMask;
            UCHAR   channel = 0;
            USHORT  count = 0;

            //
            // Find all the dma's to set
            //
            for ( ;mask && NT_SUCCESS(status); channel++, mask >>= 1 ) {

                if (mask & 1) {

                    status = PnpiBiosDmaToIoDescriptor(
                        buffer,
                        channel,
                        Array,
                        ArrayIndex,
                        count,
                        Flags
                        );

                    count++;
                }
            }

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_DMA(count: 0x%2lx) "
                "= 0x%8lx\n",
                count, status
                ) );

            break;
            }

        case TAG_START_DEPEND: {

            //
            // Increment the alternate list index
            //
            ArrayAlternateIndex++;

            //
            // This is now our current index
            //
            ArrayIndex = ArrayAlternateIndex;

            //
            // We need to use DevicePrivate data to give the
            // arbiter a helping hand
            //

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_START_DEPEND(Index: "
                "0x%2lx)\n",
                ArrayIndex
                ) );

            //
            // Make sure that there is a pointer allocated for this index
            //
            if (ArrayIndex == ArraySize) {

                //
                // Not enough space
                //
                status = PnpiGrowResourceList( &Array, &ArraySize );
            }

            break;
            }

        case TAG_END_DEPEND: {

            //
            // Debug Info
            //
            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_END_DEPEND(Index: "
                "0x%2lx)\n",
                ArrayIndex
                ) );

            //
            // All we have to do is go back to our original index
            //
            ArrayIndex = 0;
            break;
            }

        case TAG_IO: {

            status = PnpiBiosPortToIoDescriptor(
                buffer,
                Array,
                ArrayIndex,
                Flags
                );

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_IO = 0x%8lx\n",
                status
                ) );

            break;
            }

        case TAG_IO_FIXED: {

            status = PnpiBiosPortFixedToIoDescriptor(
                buffer,
                Array,
                ArrayIndex,
                Flags
                );

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_IO_FIXED = 0x%8lx\n",
                status
                ) );

            break;
            }

        case TAG_MEMORY:
        case TAG_MEMORY32:
        case TAG_MEMORY32_FIXED: {

            status = PnpiBiosMemoryToIoDescriptor(
                buffer,
                Array,
                ArrayIndex,
                Flags
                );

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_MEMORY = 0x%8lx\n",
                status
                ) );
            break;
            }

        case TAG_WORD_ADDRESS: {

            status = PnpiBiosAddressToIoDescriptor(
                buffer,
                Array,
                ArrayIndex,
                Flags
                );

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_WORD_ADDRESS = 0x%8lx\n",
                status
                ) );
            break;
            }

        case TAG_DOUBLE_ADDRESS: {

            status = PnpiBiosAddressDoubleToIoDescriptor(
                buffer,
                Array,
                ArrayIndex,
                Flags
                );

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_DOUBLE_ADDRESS = 0x%8lx\n",
                status
                ) );
            break;
            }

        case TAG_QUAD_ADDRESS: {

            status = PnpiBiosAddressQuadToIoDescriptor(
                buffer,
                Array,
                ArrayIndex,
                Flags
                );

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_QUAD_ADDRESS = 0x%8lx\n",
                status
                ) );
            break;
            }

        case TAG_VENDOR:

            //
            // Ignore this tag.  Skip over it.
            //
            break;

        default: {

            //
            // Unknown tag. Skip it
            //
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "PnpBiosResourceToNtResources: TAG_UNKNOWN(tagName:"
                " 0x%2lx)\n",
                tagName ) );
            break;
            }
        } // switch

        //
        // Did we fail?
        //
        if (!NT_SUCCESS(status)) {

            break;
        }

        //
        // Move to the next descriptor
        //
        buffer += increment;
        tagName = *buffer;

    }

    //
    // At this point, if everything is okay, we should be looking at the end tag
    // If not, we will have a failed status value to account for it...
    //
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "PnpBiosResourcesToNtResources: Failed on Tag - %d Status %#08lx\n",
            tagName, status
            ) );

        //
        // Clean up any allocated memory and return
        //
        PnpiClearAllocatedMemory( Array, ArraySize );

        return status;
    }

    //
    // Now, we must figure out how many bytes to allocate for the lists...
    // We can start out by determining the size of just the REQUIREMENT_LIST
    //
    size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) - sizeof(IO_RESOURCE_LIST);

    //
    // How much many common resources are there?
    //
    if (Array[0] != NULL) {

        size2 = Array[0]->Count;

    } else {

        size2 = 0;
    }

    //
    // This is tricky. The first array is the list of resources that are
    // common to *all* lists, so we don't begin by counting it. Rather, we
    // figure out how much the other lists will take up
    //
    for (ArrayIndex = 1; ArrayIndex <= ArrayAlternateIndex; ArrayIndex++) {

         if (Array[ArrayIndex] == NULL) {

             ACPIPrint( (
                 ACPI_PRINT_CRITICAL,
                 "PnpBiosResourcesToNtResources: Bad List at Array[%d]\n",
                 ArrayIndex
                 ) );
             PnpiClearAllocatedMemory( Array, ArraySize );
             *List = NULL;
             return STATUS_UNSUCCESSFUL;

         }

        //
        // Just to make sure that we don't get tricked into adding an alternate list
        // if we do not need to...
        //
        if ( (Array[ArrayIndex])->Count == 0) {

            continue;
        }

        //
        // How much space does the current Resource List take?
        //
        size += sizeof(IO_RESOURCE_LIST) +
            ( (Array[ArrayIndex])->Count - 1 + size2) * sizeof(IO_RESOURCE_DESCRIPTOR);

        ACPIPrint( (
            ACPI_PRINT_RESOURCES_2,
            "PnpBiosResourcesToNtResources: Index %d Size %#08lx\n",
            ArrayIndex, size
            ) );

    } // for

    //
    // This is to account for the case where there are no dependent resources...
    //
    if (ArrayAlternateIndex == 0) {

         if (Array[0] == NULL || Array[0]->Count == 0) {

             ACPIPrint( (
                 ACPI_PRINT_WARNING,
                 "PnpBiosResourcesToNtResources: No Resources to Report\n"
                 ) );

             PnpiClearAllocatedMemory( Array, ArraySize );
             *List = NULL;

             return STATUS_UNSUCCESSFUL;
         }

        size += ( (Array[0])->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) +
            sizeof(IO_RESOURCE_LIST);
    }

    //
    // This is a redundant check. If we don't have at least enough information
    // to create a single list, then we should not be returning anything. Period.
    //
    if (size < sizeof(IO_RESOURCE_REQUIREMENTS_LIST) ) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "PnpBiosResourcesToNtResources: Resources smaller than a List\n"
            ) );

        PnpiClearAllocatedMemory( Array, ArraySize );
        *List = NULL;
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Allocate the required amount of space
    //
    (*List) = ExAllocatePoolWithTag( PagedPool, size, ACPI_RESOURCE_POOLTAG );
    ACPIPrint( (
        ACPI_PRINT_RESOURCES_2,
        "PnpBiosResourceToNtResources: ResourceRequirementsList = %#08lx (%#08lx)\n",
        (*List), size ) );

    if (*List == NULL) {

        //
        // Oops...
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "PnpBiosResourceToNtResources: Could not allocate memory for "
            "ResourceRequirementList\n" ) );


        //
        // Clean up any allocated memory and return
        //
        PnpiClearAllocatedMemory( Array, ArraySize );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( (*List), size );

    //
    // Find the first place to store the information
    //
    (*List)->InterfaceType = PNPBus;
    (*List)->BusNumber = 0;
    (*List)->ListSize = size;
    buffer = (PUCHAR) &( (*List)->List[0]);
    for (ArrayIndex = 1; ArrayIndex <= ArrayAlternateIndex; ArrayIndex++) {

        //
        // Just to make sure that we don't get tricked into adding an alternate list
        // if we do not need to...
        //
        if ( (Array[ArrayIndex])->Count == 0) {

            continue;
        }

        //
        // How much space does the current Resource List take?
        //
        size = ( ( (Array[ArrayIndex])->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) +
            sizeof(IO_RESOURCE_LIST) );

        //
        // This is tricky. Using the sideeffect of if I upgrade the count field
        // in the dependent resource descriptor, then when I copy it over, it will
        // be correct, I avoid issues with trying to message with pointers at a
        // later point in time.
        //
        (Array[ArrayIndex])->Count += size2;

        ACPIPrint( (
            ACPI_PRINT_RESOURCES_2,
            "PnpBiosResourcesToNtResources:  %d@%#08lx Size %#04lx Items %#04x\n",
            ArrayIndex, buffer, size, (Array[ArrayIndex])->Count
            ) );

        //
        // Copy the resources
        //
        RtlCopyMemory(buffer, Array[ArrayIndex], size );
        buffer += size;

        //
        // Now we account for the common resources
        //
        if (size2) {

            RtlCopyMemory(
                buffer,
                &( (Array[0])->Descriptors[0]),
                size2 * sizeof(IO_RESOURCE_DESCRIPTOR)
                );
            buffer += (size2 * sizeof(IO_RESOURCE_DESCRIPTOR));
        }

        //
        // Update the number of alternate lists in the ResourceRequirement List
        //
        (*List)->AlternativeLists += 1;
    }

    //
    // This check is required because we might just have a common list, with
    // no dependent resources...
    //
    if (ArrayAlternateIndex == 0) {

        ASSERT( size2 != 0 );

        size = (size2 - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) + sizeof(IO_RESOURCE_LIST);
        RtlCopyMemory(buffer,Array[0],size);
        (*List)->AlternativeLists += 1;
    }

    //
    // Clean up the copies
    //
    PnpiClearAllocatedMemory( Array, ArraySize );

    return STATUS_SUCCESS;
}

NTSTATUS
PnpIoResourceListToCmResourceList(
    IN      PIO_RESOURCE_REQUIREMENTS_LIST  IoList,
    IN  OUT PCM_RESOURCE_LIST               *CmList
    )
/*++

Routine Description:

    This routine takes an IO_RESOURCE_REQUIREMENTS_LIST and generates a
    CM_RESOURCE_LIST

Arguments:

    IoList  - The list to convert
    CmList  - Points to pointer of where to store the new list. The caller is
            responsible for freeing this

Return Value:

    NTSTATUS

--*/
{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDesc;
    PCM_PARTIAL_RESOURCE_LIST       cmPartialList;
    PCM_RESOURCE_LIST               cmList;
    PIO_RESOURCE_DESCRIPTOR         ioDesc;
    PIO_RESOURCE_LIST               ioResList;
    ULONG                           size;
    ULONG                           count;

    PAGED_CODE();

    *CmList = NULL;

    //
    // As a trivial check, if there are no lists, than we can simply return
    //
    if (IoList == NULL || IoList->List == NULL || IoList->List[0].Count == 0) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // The first step is to allocate the correct number of bytes for the CmList. The
    // first simplifying assumptions that can be me is that the IoList will not have
    // more than one alternative.
    //
    size = (IoList->List[0].Count - 1) * sizeof( CM_PARTIAL_RESOURCE_DESCRIPTOR ) +
        sizeof( CM_RESOURCE_LIST );

    //
    // Now, allocate this block of memory
    //
    cmList = ExAllocatePoolWithTag( PagedPool, size, ACPI_RESOURCE_POOLTAG );
    if (cmList == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( cmList, size );

    //
    // Setup the initial values for the CmList
    //
    ioResList = &(IoList->List[0]);
    cmList->Count = 1;
    cmList->List[0].InterfaceType = IoList->InterfaceType;
    cmList->List[0].BusNumber = IoList->BusNumber;
    cmPartialList = &(cmList->List[0].PartialResourceList);
    cmPartialList->Version = 1;
    cmPartialList->Revision = 1;
    cmPartialList->Count = ioResList->Count;

    for (count = 0; count < ioResList->Count; count++) {

        //
        // Grab the current CmDescriptor and IoDescriptor
        //
        cmDesc = &(cmPartialList->PartialDescriptors[count]);
        ioDesc = &(ioResList->Descriptors[count]);

        //
        // Now, copy the information from one descriptor to another
        //
        cmDesc->Type = ioDesc->Type;
        cmDesc->ShareDisposition = ioDesc->ShareDisposition;
        cmDesc->Flags = ioDesc->Flags;
        switch (cmDesc->Type) {
        case CmResourceTypeBusNumber:
            cmDesc->u.BusNumber.Start = ioDesc->u.BusNumber.MinBusNumber;
            cmDesc->u.BusNumber.Length = ioDesc->u.BusNumber.Length;
            break;
        case CmResourceTypePort:
            cmDesc->u.Port.Length = ioDesc->u.Port.Length;
            cmDesc->u.Port.Start = ioDesc->u.Port.MinimumAddress;
            break;
        case CmResourceTypeInterrupt:
            cmDesc->u.Interrupt.Level =
            cmDesc->u.Interrupt.Vector = ioDesc->u.Interrupt.MinimumVector;
            cmDesc->u.Interrupt.Affinity = (ULONG)-1;
            break;
        case CmResourceTypeMemory:
            cmDesc->u.Memory.Length = ioDesc->u.Memory.Length;
            cmDesc->u.Memory.Start = ioDesc->u.Memory.MinimumAddress;
            break;
        case CmResourceTypeDma:
            cmDesc->u.Dma.Channel = ioDesc->u.Dma.MinimumChannel;
            cmDesc->u.Dma.Port = 0;
            break;
        default:
        case CmResourceTypeDevicePrivate:
            cmDesc->u.DevicePrivate.Data[0] = ioDesc->u.DevicePrivate.Data[0];
            cmDesc->u.DevicePrivate.Data[1] = ioDesc->u.DevicePrivate.Data[1];
            cmDesc->u.DevicePrivate.Data[2] = ioDesc->u.DevicePrivate.Data[2];
            break;
        }
    }

    //
    // Let the caller know he has a good list
    //
    *CmList = cmList;

    return STATUS_SUCCESS;
}

NTSTATUS
PnpCmResourceListToIoResourceList(
    IN      PCM_RESOURCE_LIST               CmList,
    IN  OUT PIO_RESOURCE_REQUIREMENTS_LIST  *IoList
    )
/*++

Routine Description:

    This routine generates an IO_RESOURCE_REQUIREMENTS_LIST and from a
    CM_RESOURCE_LIST

Arguments:

    CmList  - The list to convert
    IoList  - Points to pointer of where to store the new list. The caller is
            responsible for freeing this

Return Value:

    NTSTATUS

--*/
{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDesc;
    PCM_PARTIAL_RESOURCE_LIST       cmPartialList;
    PIO_RESOURCE_DESCRIPTOR         ioDesc;
    PIO_RESOURCE_LIST               ioResList;
    PIO_RESOURCE_REQUIREMENTS_LIST  ioList;
    ULONG                           size;
    ULONG                           count;

    PAGED_CODE();

    *IoList = NULL;

    //
    // As a trivial check, if there are no lists, than we can simply return
    //
    if (CmList == NULL || CmList->List == NULL ||
        CmList->List[0].PartialResourceList.Count == 0) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Grab the partial list to make walking it easier
    //
    cmPartialList = &(CmList->List[0].PartialResourceList);


    //
    // How much space do we need for the IO list?
    //
    size = (cmPartialList->Count - 1) * sizeof( IO_RESOURCE_DESCRIPTOR ) +
        sizeof( IO_RESOURCE_REQUIREMENTS_LIST );

    //
    // Now, allocate this block of memory
    //
    ioList = ExAllocatePoolWithTag( NonPagedPool, size, ACPI_RESOURCE_POOLTAG );

    if (ioList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( ioList, size );

    //
    // Setup the initial values for the IoList
    //
    ioList->ListSize = size;
    ioList->AlternativeLists = 1;
    ioList->InterfaceType = CmList->List[0].InterfaceType;
    ioList->BusNumber = CmList->List[0].BusNumber;

    //
    // Setup the initialize value for the ioResList
    //
    ioResList = &(ioList->List[0]);
    ioResList->Count = cmPartialList->Count;
    ioResList->Version = cmPartialList->Version;
    ioResList->Revision = cmPartialList->Revision;

    //
    // Loop for all the elements in the partial list
    //
    for (count = 0; count < ioResList->Count; count++) {

        //
        // Grab the current CmDescriptor and IoDescriptor
        //
        cmDesc = &(cmPartialList->PartialDescriptors[count]);
        ioDesc = &(ioResList->Descriptors[count]);

        //
        // Now, copy the information from one descriptor to another
        //
        ioDesc->Type                = cmDesc->Type;
        ioDesc->ShareDisposition    = cmDesc->ShareDisposition;
        ioDesc->Flags               = cmDesc->Flags;
        switch (cmDesc->Type) {
        case CmResourceTypeMemory:
        case CmResourceTypePort:
            ioDesc->u.Port.Length           = cmDesc->u.Port.Length;
            ioDesc->u.Port.MinimumAddress   = cmDesc->u.Port.Start;
            ioDesc->u.Port.MaximumAddress   = cmDesc->u.Port.Start;
            ioDesc->u.Port.MaximumAddress.LowPart += cmDesc->u.Port.Length - 1;
            ioDesc->u.Port.Alignment        = 1;
            break;
        case CmResourceTypeInterrupt:
            ioDesc->u.Interrupt.MinimumVector = cmDesc->u.Interrupt.Vector;
            ioDesc->u.Interrupt.MaximumVector = cmDesc->u.Interrupt.Vector;
            break;
        case CmResourceTypeDma:
            ioDesc->u.Dma.MinimumChannel = cmDesc->u.Dma.Channel;
            ioDesc->u.Dma.MaximumChannel = cmDesc->u.Dma.Channel;
            break;
        case CmResourceTypeBusNumber:
            ioDesc->u.BusNumber.MinBusNumber = cmDesc->u.BusNumber.Start;
            ioDesc->u.BusNumber.MaxBusNumber = cmDesc->u.BusNumber.Length +
                cmDesc->u.BusNumber.Start;
            ioDesc->u.BusNumber.Length = cmDesc->u.BusNumber.Length;
            break;
        default:
        case CmResourceTypeDevicePrivate:
            ioDesc->u.DevicePrivate.Data[0] = cmDesc->u.DevicePrivate.Data[0];
            ioDesc->u.DevicePrivate.Data[1] = cmDesc->u.DevicePrivate.Data[1];
            ioDesc->u.DevicePrivate.Data[2] = cmDesc->u.DevicePrivate.Data[2];
            break;
        }
    }

    *IoList = ioList;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\rtl.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    rtl.h

Abstract:

    Some handy-dany RTL functions. These really should be part of the kernel

Author:

Environment:

    NT Kernel Model Driver only

Revision History:

--*/

#ifndef _RTL_H_
#define _RTL_H_

    PCM_RESOURCE_LIST
    RtlDuplicateCmResourceList(
        IN  POOL_TYPE           PoolType,
        IN  PCM_RESOURCE_LIST   ResourceList,
        IN  ULONG               Tag
        );

    ULONG
    RtlSizeOfCmResourceList(
        IN  PCM_RESOURCE_LIST   ResourceList
        );

    PCM_PARTIAL_RESOURCE_DESCRIPTOR
    RtlUnpackPartialDesc(
        IN  UCHAR               Type,
        IN  PCM_RESOURCE_LIST   ResList,
        IN  OUT PULONG          Count
        );

#endif // _RTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\sleep.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sleep.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _SLEEP_H_
#define _SLEEP_H_

    NTSTATUS
    ACPIHandleSetPower (
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\rtl.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    rtl.c

Abstract:

    Some handy-dany RTL functions. These really should be part of the kernel


Author:

Environment:

    NT Kernel Model Driver only

Revision History:

--*/

#include "pch.h"


PCM_RESOURCE_LIST
RtlDuplicateCmResourceList(
    IN  POOL_TYPE           PoolType,
    IN  PCM_RESOURCE_LIST   ResourceList,
    IN  ULONG               Tag
    )
/*++

Routine Description:

    This routine will attempt to allocate memory to copy the supplied
    resource list.  If sufficient memory cannot be allocated then the routine
    will return NULL.

Arguments:

    PoolType - the type of pool to allocate the duplicate from

    ResourceList - the resource list to be copied

    Tag - a value to tag the memory allocation with.  If 0 then untagged
          memory will be allocated.

Return Value:

    an allocated copy of the resource list (caller must free) or
    NULL if memory could not be allocated.

--*/
{
    ULONG size = sizeof(CM_RESOURCE_LIST);
    PVOID buffer;

    PAGED_CODE();

    //
    // How much memory do we need for this resource list?
    //
    size = RtlSizeOfCmResourceList(ResourceList);

    //
    // Allocate the memory and copy the list
    //
    buffer = ExAllocatePoolWithTag(PoolType, size, Tag);
    if(buffer != NULL) {

        RtlCopyMemory(
            buffer,
            ResourceList,
            size
            );

    }

    return buffer;
}

ULONG
RtlSizeOfCmResourceList(
    IN  PCM_RESOURCE_LIST   ResourceList
    )
/*++

Routine Description:

    This routine returns the size of a CM_RESOURCE_LIST.

Arguments:

    ResourceList - the resource list to be copied

Return Value:

    an allocated copy of the resource list (caller must free) or
    NULL if memory could not be allocated.

--*/

{
    ULONG size = sizeof(CM_RESOURCE_LIST);
    ULONG i;

    PAGED_CODE();

    for(i = 0; i < ResourceList->Count; i++) {

        PCM_FULL_RESOURCE_DESCRIPTOR fullDescriptor = &(ResourceList->List[i]);
        ULONG j;

        //
        // First descriptor is included in the size of the resource list.
        //
        if(i != 0) {

            size += sizeof(CM_FULL_RESOURCE_DESCRIPTOR);

        }

        for(j = 0; j < fullDescriptor->PartialResourceList.Count; j++) {

            //
            // First descriptor is included in the size of the partial list.
            //
            if(j != 0) {

                size += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

            }

        }

    }
    return size;
}

PCM_PARTIAL_RESOURCE_DESCRIPTOR
RtlUnpackPartialDesc(
    IN  UCHAR               Type,
    IN  PCM_RESOURCE_LIST   ResList,
    IN  OUT PULONG          Count
    )
/*++

Routine Description:

    Pulls out a pointer to the partial descriptor you're interested in

Arguments:

    Type - CmResourceTypePort, ...
    ResList - The list to search
    Count - Points to the index of the partial descriptor you're looking
            for, gets incremented if found, i.e., start with *Count = 0,
            then subsequent calls will find next partial, make sense?

Return Value:

    Pointer to the partial descriptor if found, otherwise NULL

--*/
{
    ULONG hit = 0;
    ULONG i;
    ULONG j;

    for (i = 0; i < ResList->Count; i++) {

        for (j = 0; j < ResList->List[i].PartialResourceList.Count; j++) {

            if (ResList->List[i].PartialResourceList.PartialDescriptors[j].Type == Type) {

                if (hit == *Count) {

                    (*Count)++;
                    return &ResList->List[i].PartialResourceList.PartialDescriptors[j];

                } else {

                    hit++;

                }

            }

        }

    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\syspower.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    syspower.c

Abstract:

    Contains all the code that deals with the system having to determine
    System Power State to Device Power State mappings

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    October 29th, 1998

--*/

#include "pch.h"

//
// Quick Lookup table to map S-States to SxD methods
//
ULONG   AcpiSxDMethodTable[] = {
    PACKED_SWD,
    PACKED_S0D,
    PACKED_S1D,
    PACKED_S2D,
    PACKED_S3D,
    PACKED_S4D,
    PACKED_S5D
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPISystemPowerGetSxD)
#pragma alloc_text(PAGE,ACPISystemPowerProcessRootMapping)
#pragma alloc_text(PAGE,ACPISystemPowerProcessSxD)
#pragma alloc_text(PAGE,ACPISystemPowerQueryDeviceCapabilities)
#pragma alloc_text(PAGE,ACPISystemPowerUpdateWakeCapabilities)
#endif

NTSTATUS
ACPISystemPowerDetermineSupportedDeviceStates(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  SYSTEM_POWER_STATE  SystemState,
    OUT ULONG               *SupportedDeviceStates
    )
/*++

Routine Description:

    This recursive routine looks at all the children of the current
    device extension and determines what device states might be supported
    at the specified system state. This is accomplished by looking at the
    _SxD methods and looking at the power plane information

Arguments:

    DeviceExtension         - The device whose children we want to know
                              information about
    SystemState             - The system state we want to know about
    SupportedDeviceStates   - Set bits represent supported D-states

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE      deviceState;
    EXTENSIONLIST_ENUMDATA  eled;
    KIRQL                   oldIrql;
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       childExtension;
    SYSTEM_POWER_STATE      prSystemState;

    ASSERT(
        SystemState >= PowerSystemWorking &&
        SystemState <= PowerSystemShutdown
        );
    ASSERT( SupportedDeviceStates != NULL );

    //
    // Setup the data structure that we will use to walk the device extension
    // tree
    //
    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_REFERENCE_ENTRIES
        );

    //
    // Look at all children of the current device extension
    //
    for (childExtension = ACPIExtListStartEnum( &eled );
         ACPIExtListTestElement( &eled, (BOOLEAN) NT_SUCCESS(status) );
         childExtension = ACPIExtListEnumNext( &eled) ) {

        //
        // Recurse first
        //
        status = ACPISystemPowerDetermineSupportedDeviceStates(
            childExtension,
            SystemState,
            SupportedDeviceStates
            );
        if (!NT_SUCCESS(status)) {

            continue;

        }

        //
        // Get the _SxD mapping for the device
        //
        status = ACPISystemPowerGetSxD(
            childExtension,
            SystemState,
            &deviceState
            );
        if (NT_SUCCESS( status ) ) {

            //
            // We support this D-state
            //
            *SupportedDeviceStates |= (1 << deviceState );

            ACPIDevPrint( (
                ACPI_PRINT_SXD,
                childExtension,
                " S%x->D%x\n",
                (SystemState - 1),
                (deviceState - 1)
                ) );

            //
            // Don't bother looking at the _PRx methods
            //
            continue;

        } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // If we hit another error, then we should continue now
            // Note that continuing will cause us to terminate the loop
            //
            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                childExtension,
                " - ACPISystemPowerdetermineSupportedDeviceStates = %08lx\n",
                status
                ) );
            continue;

        } else {

            //
            // If we got here, then that means that the childExtension doesn't
            // have a _SxD method, which is okay. We reset the status so that
            // the loop test will succeed, or at least won't fail because there
            // wasn't an _SxD method.
            //
            status = STATUS_SUCCESS;

        }

        //
        // We are going to play with the power nodes, so we must be holding
        // the power lock
        //
        KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

        //
        // Look at all the device states that might be supported via
        // the _PR methods
        //
        for (deviceState = PowerDeviceD0;
             deviceState <= PowerDeviceD2;
             deviceState++) {

            prSystemState = ACPISystemPowerDetermineSupportedSystemState(
                 childExtension,
                 deviceState
                 );
            if (prSystemState >= SystemState) {

                //
                // This d-state maps to a deeper S-state than what we
                // are looking for, so we should be implicitly supporting
                // this d-state for the current S-state
                //
                *SupportedDeviceStates |= (1 << deviceState);

                ACPIDevPrint( (
                    ACPI_PRINT_SXD,
                    childExtension,
                    " PR%x maps to S%x, so S%x->D%x\n",
                    (deviceState - 1),
                    (prSystemState - 1),
                    (SystemState - 1),
                    (deviceState - 1)
                    ) );

            }

        }

        //
        // Done with the lock
        //
        KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

DEVICE_POWER_STATE
ACPISystemPowerDetermineSupportedDeviceWakeState(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine looks at the PowerInformation structure and determines
    the D-State that is supported by the wake state

    As a rule of thumb, if the S-State is not supported, then we
    return PowerDeviceUnspecified

    Note: The parent is holding the AcpiPowerLock

Arguments:

    DeviceExtension     - The extension that we wish to check

Return Value:

    DEVICE_POWER_STATE

--*/
{
    DEVICE_POWER_STATE      deviceState = PowerDeviceMaximum;
    PACPI_DEVICE_POWER_NODE deviceNode;

    deviceNode = DeviceExtension->PowerInfo.PowerNode[PowerDeviceUnspecified];
    while (deviceNode != NULL) {

        //
        // Does the current device node support a lower device then the
        // current maximum device state?
        //
        if (deviceNode->AssociatedDeviceState < deviceState) {

            //
            // Yes, so this is the new maximum system state
            //
            deviceState = deviceNode->AssociatedDeviceState;

        }
        deviceNode = deviceNode->Next;

    }

    //
    // PowerSystemMaximum is not a valid entry. So if that is what we would
    // return, then change that to return PowerSystemUnspecified
    //
    if (deviceState == PowerDeviceMaximum) {

        deviceState = PowerDeviceUnspecified;

    }
    return deviceState;
}

SYSTEM_POWER_STATE
ACPISystemPowerDetermineSupportedSystemState(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  DEVICE_POWER_STATE  DeviceState
    )
/*++

Routine Description:

    This routine looks at the PowerInformation structure and determines
    the S-State that is supported by the D-state

    As a rule of thumb, if the D-State is not supported, then we
    return PowerSystemUnspecified

    Note: The parent is holding the AcpiPowerLock

Arguments:

    DeviceExtension     - The extension that we wish to check
    DeviceState         - The state that we wish to sanity check

Return Value:

    SYSTEM_POWER_STATE

--*/
{
    PACPI_DEVICE_POWER_NODE deviceNode;
    SYSTEM_POWER_STATE      systemState = PowerSystemMaximum;

    if (DeviceState == PowerDeviceD3) {

        goto ACPISystemPowerDetermineSupportedSystemStateExit;

    }

    deviceNode = DeviceExtension->PowerInfo.PowerNode[DeviceState];
    while (deviceNode != NULL) {

        //
        // Does the current device node support a lower system then the
        // current maximum system state?
        //
        if (deviceNode->SystemState < systemState) {

            //
            // Yes, so this is the new maximum system state
            //
            systemState = deviceNode->SystemState;

        }
        deviceNode = deviceNode->Next;

    }

ACPISystemPowerDetermineSupportedSystemStateExit:
    //
    // PowerSystemMaximum is not a valid entry. So if that is what we would
    // return, then change that to return PowerSystemUnspecified
    //
    if (systemState == PowerSystemMaximum) {

        systemState = PowerSystemUnspecified;

    }
    return systemState;
}

NTSTATUS
ACPISystemPowerGetSxD(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  SYSTEM_POWER_STATE  SystemState,
    OUT DEVICE_POWER_STATE  *DeviceState
    )
/*++

Routine Description:

    This is the worker function that is called when we want to run an
    SxD method. We give the function an S-State, and we get back a
    D-State.

Arguments:

    DeviceExtension - The device to run the SxD on
    SystemState     - The S-state to determine the D-State for
    DeviceState     - Where we store the answer

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    ULONG       value;

    PAGED_CODE();

    //
    // Assume that we don't find an answer
    //
    *DeviceState = PowerDeviceUnspecified;

    //
    // We want this code to run even though there is no namespace object
    // for the device. Since we don't want to add a check to GetNamedChild
    // that checks for null, we need to handle this special case here
    //
    if ( (DeviceExtension->Flags & DEV_PROP_NO_OBJECT) ||
         (DeviceExtension->Flags & DEV_PROP_FAILED_INIT) ) {

        return STATUS_OBJECT_NAME_NOT_FOUND;

    }

    //
    // Evaluate the control method
    //
    status = ACPIGetIntegerSync(
        DeviceExtension,
        AcpiSxDMethodTable[SystemState],
        &value,
        NULL
        );
    if (NT_SUCCESS(status)) {

        //
        // Convert this number to a D-State
        //
        *DeviceState = ACPIDeviceMapPowerState( value );

    } else if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // HACKHACK --- Program Management wants us to force the PCI Root Bus
        // mappings for S1 to be D1. So look for a device node that has
        // both the PCI flag and the HID flag set, and if so, return that
        // we support D1
        //
        if (SystemState == PowerSystemSleeping1 &&
            (DeviceExtension->Flags & DEV_MASK_HID) &&
            (DeviceExtension->Flags & DEV_CAP_PCI) ) {

            *DeviceState = PowerDeviceD1;
            status = STATUS_SUCCESS;

        }

#if DBG
    } else {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "ACPISystemPowerGetSxD: Cannot run _S%cD - 0x%08lx\n",
            (SystemState == 0 ? 'w' : '0' + (UCHAR) (SystemState - 1) ),
            status
            ) );
#endif

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPISystemPowerInitializeRootMapping(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    )
/*++

Routine Description:

    This routine is responsible for initializing the S->D mapping for the
    root device extension

Arguments:

    DeviceExtension     - Pointer to the root device extension
    DeviceCapabilitites - DeviceCapabilitites

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             sxdFound;
    DEVICE_POWER_STATE  deviceMap[PowerSystemMaximum];
    KIRQL               oldIrql;
    NTSTATUS            status;
    SYSTEM_POWER_STATE  sysIndex;

    //
    // Can we actually do any real work here?
    //
    if ( (DeviceExtension->Flags & DEV_PROP_BUILT_POWER_TABLE) ||
         (DeviceExtension->DeviceState != Started) ) {

        goto ACPISystemPowerInitializeRootMappingExit;

    }

    //
    // Initialize the root mapping
    //
    RtlZeroMemory( deviceMap, sizeof(DEVICE_POWER_STATE) * PowerSystemMaximum );

    //
    // Copy the mapping from the device extension. See the comment at the
    // end as to why we don't grab a spinlock
    //
    IoCopyDeviceCapabilitiesMapping(
       DeviceExtension->PowerInfo.DevicePowerMatrix,
       deviceMap
       );

    //
    // Make sure that S0->D0
    //
    deviceMap[PowerSystemWorking]  = PowerDeviceD0;

    //
    // Special case the fact that someone one might want to have the
    // HAL return a different template. If the capabilities that we got
    // handed have some values in them, have them override our defaults
    //
    for (sysIndex = PowerSystemSleeping1;
         sysIndex <= PowerSystemShutdown;
         sysIndex++) {

        if (DeviceCapabilities->DeviceState[sysIndex] != PowerDeviceUnspecified) {

            deviceMap[sysIndex] = DeviceCapabilities->DeviceState[sysIndex];

        }

    }

    //
    // Porcess the SxD methods if there are any
    //
    status = ACPISystemPowerProcessSxD(
        DeviceExtension,
        deviceMap,
        &sxdFound
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "- ACPISystemPowerProcessSxD = %08lx\n",
            status
            ) );
        return status;

    }

    //
    // Make sure that the Shutdown case doesn't map to PowerDeviceUnspecified
    // If it does, then it should really map to PowerDeviceD3
    //
    if (deviceMap[PowerSystemShutdown] == PowerDeviceUnspecified) {

        deviceMap[PowerSystemShutdown] = PowerDeviceD3;

    }

    //
    // Look at all the children capabilities to help us decide the root
    // mapping
    //
    status = ACPISystemPowerProcessRootMapping(
        DeviceExtension,
        deviceMap
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            " - ACPISystemPowerProcessRootMapping = %08lx\n",
            status
            ) );
        goto ACPISystemPowerInitializeRootMappingExit;

    }

    //
    // If we have reached this point, then we have build the SxD table
    // and never need to do so again
    //
    ACPIInternalUpdateFlags(
        &(DeviceExtension->Flags),
        DEV_PROP_BUILT_POWER_TABLE,
        FALSE
        );

#if DBG
    //
    // We haven't updated the device extension yet, so we can still do this
    // at this point in the game
    //
    ACPIDebugDeviceCapabilities(
        DeviceExtension,
        DeviceCapabilities,
        "Initial"
        );
    ACPIDebugPowerCapabilities( DeviceExtension, "Before Update" );
#endif

    //
    // Copy the mapping to the device extension
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );
    IoCopyDeviceCapabilitiesMapping(
       deviceMap,
       DeviceExtension->PowerInfo.DevicePowerMatrix
       );
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

#if DBG
    ACPIDebugPowerCapabilities( DeviceExtension, "After Update" );
#endif

ACPISystemPowerInitializeRootMappingExit:
    //
    // Hmm.. I'm tempted to grab a spinlock here, but since we cannot
    // updating the capabilities for this device, I think it is safe
    // to not do so. We need to grab the spinlock when setting these
    // values so that we can sync with the power code
    //

    //
    // Copy the power capabilities to their final location
    //
    IoCopyDeviceCapabilitiesMapping(
        DeviceExtension->PowerInfo.DevicePowerMatrix,
        DeviceCapabilities->DeviceState
        );
#if DBG
    ACPIDebugDeviceCapabilities(DeviceExtension, DeviceCapabilities, "Done" );
#endif

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPISystemPowerProcessRootMapping(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  DEVICE_POWER_STATE  DeviceMap[PowerSystemMaximum]
    )
/*++

Routine Description:

    This routine is called by the FDO to figure out what the minimal set
    of capabilities for each s state are. These then become the root
    capabilitites

Arguments:

    DeviceExtension - The root device extension
    DeviceMap       - The current mapping

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  deviceState;
    KIRQL               oldIrql;
    NTSTATUS            status;
    SYSTEM_POWER_STATE  systemState;
    ULONG               supportedDeviceStates;

    PAGED_CODE();

    //
    // Loop on all the system supported states
    //
    for (systemState = PowerSystemSleeping1;
         systemState <= PowerSystemShutdown;
         systemState++) {

        //
        // Do we support this state?
        //
        if (!(AcpiSupportedSystemStates & (1 << systemState) ) ) {

            continue;

        }

        //
        // We always support the D3 state
        //
        supportedDeviceStates = (1 << PowerDeviceD3);

        //
        // Determine the supported Device states for this System state
        //
        status = ACPISystemPowerDetermineSupportedDeviceStates(
            DeviceExtension,
            systemState,
            &supportedDeviceStates
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_WARNING,
                DeviceExtension,
                "Cannot determine D state for S%x - %08lx\n",
                (systemState - 1),
                status
                ) );
            DeviceMap[systemState] = PowerDeviceD3;
            continue;

        }

        //
        // Starting from the device states that we currently are set to
        // (which we would have gotten by running the _SxD method on the
        // \_SB), look to see if we can use a lower D-state instead.
        //
        // Note: It is *VERY* important to remember that *ALL* devices can
        // support D3, so the following loop will *always* terminate in the
        // D3 case.
        //
        for (deviceState = DeviceMap[systemState];
             deviceState <= PowerDeviceD3;
             deviceState++) {

            //
            // Is this a supported device state?
            //
            if (!(supportedDeviceStates & (1 << deviceState) ) ) {

                //
                // no? then look at the next one
                //
                continue;

            }

            //
            // This is the D-state that we need to use
            //
            DeviceMap[systemState] = deviceState;
            break;

        }

    }

    //
    // Always return success
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPISystemPowerProcessSxD(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  DEVICE_POWER_STATE  CurrentMapping[PowerSystemMaximum],
    IN  PBOOLEAN            MatchFound
    )
/*++

Routine Description:

    This routine updates the current S-to-D mapping with the information
    in the ACPI namespace. If it finds any _SxD routines, then it tells the
    caller

Arguments:

    DeviceExtension - Device to check
    CurrentMapping  - The current mapping to modify
    MatchFound      - Where to indicate if we have found a match or not

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  dState;
    NTSTATUS            status;
    SYSTEM_POWER_STATE  sState;

    PAGED_CODE();
    ASSERT( MatchFound != NULL );

    //
    // Assume no match
    //
    *MatchFound = FALSE;

    //
    // Loop for all the S-States that we care about
    //
    for (sState = PowerSystemWorking; sState < PowerSystemMaximum; sState++) {

        //
        // Does the system support this S-State?
        //
        if (!(AcpiSupportedSystemStates & (1 << sState)) ) {

            //
            // This S-state is not supported by the system. Mark it as such
            //
            CurrentMapping[sState] = PowerDeviceUnspecified;
            continue;

        }

        //
        // Evaluate the control method
        //
        status = ACPISystemPowerGetSxD( DeviceExtension, sState, &dState );
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // Not a critical error
            //
            continue;

        }
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                DeviceExtension,
                "ACPISystemPowerProcessSxD: Cannot Evaluate _SxD - 0x%08lx\n",
                status
                ) );
            continue;

        }

        //
        // Match found
        //
        *MatchFound = TRUE;

        //
        // Is this value greater then the number within the table?
        //
        if (dState > CurrentMapping[sState]) {

            //
            // Yes, so we have a new mapping
            //
            CurrentMapping[sState] = dState;

        }

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPISystemPowerQueryDeviceCapabilities(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    )
/*++

Routine Description:

    Any routine that needs to know the device capabilities will call this
    function for the power capabilities

Arguments:

    DeviceExtension     - The extension whose capabilities we want
    DeviceCapabilities  - Where to store the capabilities

Return Value:

    NTSTATUS

--*/
{
#if DBG
    BOOLEAN                 dumpAtEnd = FALSE;
#endif
    DEVICE_CAPABILITIES     parentCapabilities;
    NTSTATUS                status;
    PDEVICE_CAPABILITIES    baseCapabilities;

    PAGED_CODE();

    //
    // We only need to do this once
    //
    if (!(DeviceExtension->Flags & DEV_PROP_BUILT_POWER_TABLE) ) {

#if DBG
        ACPIDebugDeviceCapabilities(
            DeviceExtension,
            DeviceCapabilities,
            "From PDO"
            );
#endif

        //
        // Our next action depends on wether or not we are a filter (only)
        // or a PDO
        //
        if ( (DeviceExtension->Flags & DEV_TYPE_FILTER) &&
            !(DeviceExtension->Flags & DEV_TYPE_PDO) ) {

            //
            // In this case, our base capabilities are the ones that have
            // already been passed to us
            //
            baseCapabilities = DeviceCapabilities;

        } else {

            //
            // We must get the capabilities of the parent device
            //
            status = ACPIInternalGetDeviceCapabilities(
                DeviceExtension->ParentExtension->DeviceObject,
                &parentCapabilities
                );
            if (!NT_SUCCESS(status)) {

                ACPIDevPrint( (
                    ACPI_PRINT_CRITICAL,
                    DeviceExtension,
                    " - Could not get parent caps - %08lx\n",
                    status
                    ) );
                return status;

            }

            //
            // our base capabilities are the one that we just fetched
            //
            baseCapabilities = &parentCapabilities;

#if DBG
            ACPIDebugDeviceCapabilities(
                DeviceExtension,
                baseCapabilities,
                "From Parent"
                );
#endif

        }

#if DBG
        ACPIDebugPowerCapabilities( DeviceExtension, "Before Update" );
#endif

        //
        // Update our capabilities with those of our parent
        //
        status = ACPISystemPowerUpdateDeviceCapabilities(
            DeviceExtension,
            baseCapabilities,
            DeviceCapabilities
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                DeviceExtension,
                " - Could not update caps - %08lx\n",
                status
                ) );

            //
            // If this is a pdo, then this is a fatal error
            //
            if ( (DeviceExtension->Flags & DEV_TYPE_PDO) ) {

                ACPIInternalError( ACPI_SYSPOWER );

            }
            return status;

        }
#if DBG
        ACPIDebugPowerCapabilities( DeviceExtension, "After Update" );
        dumpAtEnd = TRUE;
#endif

        //
        // Never do this again
        //
        ACPIInternalUpdateFlags(
            &(DeviceExtension->Flags),
            DEV_PROP_BUILT_POWER_TABLE,
            FALSE
            );

    }

    //
    // Hmm.. I'm tempted to grab a spinlock here, but since we cannot
    // updating the capabilities for this device, I think it is safe
    // to not do so. We need to grab the spinlock when setting these
    // values so that we can sync with the power code
    //

    //
    // Okay, at this point, we think the device extension's capabilities
    // are appropriate for the stack at hand. Let's copy them over
    //
    IoCopyDeviceCapabilitiesMapping(
        DeviceExtension->PowerInfo.DevicePowerMatrix,
        DeviceCapabilities->DeviceState
        );

    //
    // then set those capabilities as well.
    //
    DeviceCapabilities->SystemWake = DeviceExtension->PowerInfo.SystemWakeLevel;
    DeviceCapabilities->DeviceWake = DeviceExtension->PowerInfo.DeviceWakeLevel;

    //
    // Set the other capabilities
    //
    DeviceCapabilities->DeviceD1 = DeviceExtension->PowerInfo.SupportDeviceD1;
    DeviceCapabilities->DeviceD2 = DeviceExtension->PowerInfo.SupportDeviceD2;
    DeviceCapabilities->WakeFromD0 = DeviceExtension->PowerInfo.SupportWakeFromD0;
    DeviceCapabilities->WakeFromD1 = DeviceExtension->PowerInfo.SupportWakeFromD1;
    DeviceCapabilities->WakeFromD2 = DeviceExtension->PowerInfo.SupportWakeFromD2;
    DeviceCapabilities->WakeFromD3 = DeviceExtension->PowerInfo.SupportWakeFromD3;

#if DBG
    if (dumpAtEnd) {

        ACPIDebugDeviceCapabilities(
            DeviceExtension,
            DeviceCapabilities,
            "Done"
            );

    }
#endif

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPISystemPowerUpdateDeviceCapabilities(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PDEVICE_CAPABILITIES    BaseCapabilities,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    )
/*++

Routine Description:

    This routine updates the DevicePowerMatrix of the device extension with
    the current S to D mapping for the device.

    The BaseCapabilities are used as the template. That is, they provide
    values that we then modify.

    The DeviceCapabilities are the actual capabilities that are returned
    to the OS. Note that it is possible for the BaseCapabilities to the be
    same pointer as the DeviceCapabilities (if its a Filter).

Arguments:

    DeviceExtension     - The device whose capabilities we want
    BaseCapabilities    - The base values
    DeviceCapabilities  - The device capabilities

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             matchFound;
    DEVICE_POWER_STATE  currentDState;
    DEVICE_POWER_STATE  currentMapping[PowerSystemMaximum];
    DEVICE_POWER_STATE  devIndex;
    DEVICE_POWER_STATE  deviceWakeLevel = PowerDeviceUnspecified;
    DEVICE_POWER_STATE  filterWakeLevel = PowerDeviceUnspecified;
    KIRQL               oldIrql;
    NTSTATUS            status          = STATUS_SUCCESS;
    SYSTEM_POWER_STATE  sysIndex;
    SYSTEM_POWER_STATE  supportedState;
    SYSTEM_POWER_STATE  systemWakeLevel = PowerSystemUnspecified;
    ULONG               interestingBits;
    ULONG               mask;
    ULONG               supported       = 0;
    ULONG               supportedPr     = 0;
    ULONG               supportedPs     = 0;
    ULONG               supportedWake   = 0;

    //
    // We should remember what the capabilities of the device. We need
    // to remember because we will be modifying these capabilities in
    // the next call (if required)
    //
    IoCopyDeviceCapabilitiesMapping(
        BaseCapabilities->DeviceState,
        currentMapping
        );

    //
    // Sanity checks
    //
    if (currentMapping[PowerSystemWorking] != PowerDeviceD0) {

#if DBG
        ACPIDebugDeviceCapabilities(
            DeviceExtension,
            BaseCapabilities,
            "PowerSystemWorking != PowerDeviceD0"
            );
#endif
//        ASSERT( currentMapping[PowerSystemWorking] == PowerDeviceD0 );
        currentMapping[PowerSystemWorking] = PowerDeviceD0;

    }

    //
    // Get the D-States that are supported by this extension
    //
    status = ACPIDevicePowerDetermineSupportedDeviceStates(
        DeviceExtension,
        &supportedPr,
        &supportedPs
        );
    if (!NT_SUCCESS(status)) {

        //
        // Hmm...
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "ACPIDevicePowerDetermineSupportedDeviceStates = 0x%08lx\n",
            status
            ) );
        return status;

    }

    //
    // The supported index is the union of which _PR and which _PS are
    // present
    supported = (supportedPr | supportedPs);

    //
    // At this point, if there are no supported bits, then we should check
    // the device capabilities and what our parent supports
    //
    if (!supported) {

        //
        // Do some special checkin if we are a filter. We can only do the
        // following if the caps indicate that there is a D0 or D3 support
        //
        if ( (DeviceExtension->Flags & DEV_TYPE_FILTER) &&
            !(DeviceExtension->Flags & DEV_TYPE_PDO)    &&
            !(DeviceCapabilities->DeviceD1)             &&
            !(DeviceCapabilities->DeviceD2) ) {

            //
            // This is a filter, and we don't know any of its power caps, so
            // the thing to do (because of Video) is to decide to not touch
            // the mapping
            //
            goto ACPISystemPowerUpdateDeviceCapabilitiesExit;

        }

        //
        // Assume that we support D0 and D3
        //
        supported = (1 << PowerDeviceD0) | (1 << PowerDeviceD3);

        //
        // Do we support D1?
        //
        if (DeviceCapabilities->DeviceD1) {

            supported |= (1 << PowerDeviceD1);

        }

        //
        // Do we support D2?
        //
        if (DeviceCapabilities->DeviceD2) {

            supported |= (1 << PowerDeviceD2);

        }

    }

    //
    // We also need to update the Wake Capabilities. We do this so
    // that we get the correct SystemWakeLevel based on the information
    // present
    //
    status = ACPISystemPowerUpdateWakeCapabilities(
        DeviceExtension,
        BaseCapabilities,
        DeviceCapabilities,
        currentMapping,
        &supportedWake,
        &systemWakeLevel,
        &deviceWakeLevel,
        &filterWakeLevel
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "ACPISystemPowerUpdateWakeCapabilities = 0x%08lx\n",
            status
            ) );
        return status;

    }

    //
    // Now, we must look at the base capabilities and determine
    // if we need to modify them
    //
    for (sysIndex = PowerSystemSleeping1; sysIndex <= PowerSystemShutdown; sysIndex++) {

        //
        // Does the system support this S-State?
        //
        if (!(AcpiSupportedSystemStates & (1 << sysIndex) ) ) {

            continue;

        }

        //
        // See if there is an _SxD for this state
        //
        status = ACPISystemPowerGetSxD( DeviceExtension, sysIndex, &devIndex );
        if (NT_SUCCESS(status)) {

            //
            // We have found a match. Is it better then the current mapping?
            //
            if (devIndex > currentMapping[sysIndex]) {

                //
                // Yes, so we have a new mapping
                //
                currentMapping[sysIndex] = devIndex;

            }
            continue;

        } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                DeviceExtension,
                "ACPISystemPowerUpdateDeviceCapabilities: Cannot Evalutate "
                "_SxD - 0x%08lx\n",
                status
                ) );

        }

        //
        // What is the base d-state for the current mapping
        //
        currentDState = currentMapping[sysIndex];

        //
        // Remember that we didn't find a match
        //
        matchFound = FALSE;

        //
        // Calculate the interesting pr bits. Do this by ignoring any bit
        // less then the one indicated by the current mapping
        //
        mask = (1 << currentDState) - 1;
        interestingBits = supported & ~mask;

        //
        // While there are interesting bits, look to see if they are
        // available for the current state
        //
       while (interestingBits) {

            //
            // Determine what the highest possible D state that we can
            // have on this device. Clear what we are looking at from
            // the interesting bits
            //
            devIndex = (DEVICE_POWER_STATE) RtlFindLeastSignificantBit(
                (ULONGLONG) interestingBits
                );
            mask = (1 << devIndex);
            interestingBits &= ~mask;

            //
            // If this S-state is less than the wake level of the device
            // then we should try to find a D-state that we can wake from
            //
            if (sysIndex <= systemWakeLevel) {

                //
                // If we can wake from a deeper state, then lets consider
                // those bits
                //
                if ( (supportedWake & interestingBits) ) {

                    continue;

                }

                //
                // Don't consider anything deeper than the deviceWake,
                // although this should be taken care in the supportedWake
                // test
                //
                if (devIndex == filterWakeLevel) {

                    matchFound = TRUE;
                    currentMapping[sysIndex] = devIndex;

                }

            }

            //
            // If our only choice is D3, than we automatically match that
            // since all S states can map to D3.
            //
            if (devIndex == PowerDeviceD3) {

                matchFound = TRUE;
                currentMapping[sysIndex] = devIndex;
                break;

            }

            //
            // If we are looking at a _PR entry, then we need to determine
            // if the power plane actually supports this S state
            //
            if (supportedPr == 0) {

                //
                // We are looking at a _PS entry, and automatically match
                // those
                //
                matchFound = TRUE;
                currentMapping[sysIndex] = devIndex;
                break;

            }

            //
            // We must holding a spinlock for the following
            //
            KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

            //
            // What system state does this pr state support. If the
            // If the function does not support the D state, then Power
            // SystemUnspecified is returned. The only time that we
            // expect this value is when devIndex == PowerDeviceD3
            //
            supportedState = ACPISystemPowerDetermineSupportedSystemState(
                DeviceExtension,
                devIndex
                );
            if (supportedState == PowerSystemUnspecified) {

                //
                // Paranoia
                //
                ACPIDevPrint( (
                    ACPI_PRINT_CRITICAL,
                    DeviceExtension,
                    "D%x returned PowerSystemUnspecified!\n",
                    (devIndex - 1)
                    ) );
                KeBugCheckEx(
                    ACPI_BIOS_ERROR,
                    ACPI_CANNOT_MAP_SYSTEM_TO_DEVICE_STATES,
                    (ULONG_PTR) DeviceExtension,
                    0,
                    devIndex
                    );

            }

            //
            // Done with the power lock
            //
            KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

            //
            // The only way to match is if the return value from
            // ACPISystemPowerDetermineSupportedSystemState returns an S
            // state greater than or equal to the one that we are currently
            // processing.
            //
            if (supportedState >= sysIndex) {

                matchFound = TRUE;
                currentMapping[sysIndex] = devIndex;
                break;

            }

        } // while

        //
        // If we didn't find a match at this point, that should be fatal
        //
        if (!matchFound) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                DeviceExtension,
                "No match found for S%x\n",
                (sysIndex - 1)
                ) );
            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_CANNOT_MAP_SYSTEM_TO_DEVICE_STATES,
                (ULONG_PTR) DeviceExtension,
                1,
                sysIndex
                );

        }

    } // for

ACPISystemPowerUpdateDeviceCapabilitiesExit:

    //
    // Now, we re-run the wake capabilities to make sure that we get the correct
    // device wake level
    //
    status = ACPISystemPowerUpdateWakeCapabilities(
        DeviceExtension,
        BaseCapabilities,
        DeviceCapabilities,
        currentMapping,
        &supportedWake,
        &systemWakeLevel,
        &deviceWakeLevel,
        &filterWakeLevel
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "ACPISystemPowerUpdateWakeCapabilities = 0x%08lx\n",
            status
            ) );
        return status;

    }

    //
    // We must holding a spinlock for the following
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // Copy the mapping back onto the device
    //
    IoCopyDeviceCapabilitiesMapping(
        currentMapping,
        DeviceExtension->PowerInfo.DevicePowerMatrix
        );

    //
    // Remember the system wake level, device wake level, and what
    // the various support Wake and Power states are
    //
    DeviceExtension->PowerInfo.DeviceWakeLevel = deviceWakeLevel;
    DeviceExtension->PowerInfo.SystemWakeLevel = systemWakeLevel;
    DeviceExtension->PowerInfo.SupportDeviceD1 = ( ( supported & ( 1 << PowerDeviceD1 ) ) != 0);
    DeviceExtension->PowerInfo.SupportDeviceD2 = ( ( supported & ( 1 << PowerDeviceD2 ) ) != 0);
    DeviceExtension->PowerInfo.SupportWakeFromD0 = ( ( supportedWake & ( 1 << PowerDeviceD0 ) ) != 0);
    DeviceExtension->PowerInfo.SupportWakeFromD1 = ( ( supportedWake & ( 1 << PowerDeviceD1 ) ) != 0);
    DeviceExtension->PowerInfo.SupportWakeFromD2 = ( ( supportedWake & ( 1 << PowerDeviceD2 ) ) != 0);
    DeviceExtension->PowerInfo.SupportWakeFromD3 = ( ( supportedWake & ( 1 << PowerDeviceD3 ) ) != 0);

    //
    // Done with the power lock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Again, because we allowed device extension with no name space objects
    // to use this function, we must make sure not to set the ACPI_POWER
    // property unless they have a name space object
    //
    if (!(DeviceExtension->Flags & DEV_PROP_NO_OBJECT)) {

        //
        // Set the ACPI Power Management bits
        //
        ACPIInternalUpdateFlags(
            &(DeviceExtension->Flags),
            DEV_PROP_ACPI_POWER,
            FALSE
            );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPISystemPowerUpdateWakeCapabilities(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PDEVICE_CAPABILITIES    BaseCapabilities,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
    IN  DEVICE_POWER_STATE      CurrentMapping[PowerSystemMaximum],
    IN  ULONG                   *SupportedWake,
    IN  SYSTEM_POWER_STATE      *SystemWakeLevel,
    IN  DEVICE_POWER_STATE      *DeviceWakeLevel,
    IN  DEVICE_POWER_STATE      *FilterWakeLevel
    )
/*++

Routine Description:

    This routine calculates the Wake Capabilities of the device based on
    the present capabilities

Arguments:

    DeviceExtension     - The device whose capabilities we want
    BaseCapabilities    - The base values
    ParentCapabilities  - The capabilities for the device
    CurrentMapping      - The current S->D mapping
    SupportedWake       - BitMap of the supported Wake states
    SystemWakeLevel     - The S-State that we can wake up from
    DeviceWakeLevel     - The D-State that we can wake up from

Return Value:

    NTSTATUS

--*/
{

    PAGED_CODE();

    if ( (DeviceExtension->Flags & DEV_TYPE_FILTER) &&
        !(DeviceExtension->Flags & DEV_TYPE_PDO) ) {

        return ACPISystemPowerUpdateWakeCapabilitiesForFilters(
            DeviceExtension,
            BaseCapabilities,
            DeviceCapabilities,
            CurrentMapping,
            SupportedWake,
            SystemWakeLevel,
            DeviceWakeLevel,
            FilterWakeLevel
            );

    } else {

        if (FilterWakeLevel != NULL) {

            *FilterWakeLevel = PowerDeviceUnspecified;

        }

        return ACPISystemPowerUpdateWakeCapabilitiesForPDOs(
            DeviceExtension,
            BaseCapabilities,
            DeviceCapabilities,
            CurrentMapping,
            SupportedWake,
            SystemWakeLevel,
            DeviceWakeLevel,
            FilterWakeLevel
            );
    }

}

NTSTATUS
ACPISystemPowerUpdateWakeCapabilitiesForFilters(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PDEVICE_CAPABILITIES    BaseCapabilities,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
    IN  DEVICE_POWER_STATE      CurrentMapping[PowerSystemMaximum],
    IN  ULONG                   *SupportedWake,
    IN  SYSTEM_POWER_STATE      *SystemWakeLevel,
    IN  DEVICE_POWER_STATE      *DeviceWakeLevel,
    IN  DEVICE_POWER_STATE      *FilterWakeLevel
    )
/*++

Routine Description:

    This routine calculates the Wake Capabilities of the device based on
    the present capabilities. This version of the function uses the
    devices states that the device can wake from to determine what the
    appropriate system level is.

Arguments:

    DeviceExtension     - The device whose capabilities we want
    BaseCapabilities    - The base values
    DeviceCapabilities  - The capabilities for the device
    CurrentMapping      - The current S->D mapping

    SupportedWake       - BitMap of the supported Wake states
    SystemWakeLevel     - The S-State that we can wake up from
    DeviceWakeLevel     - The D-State that we can wake up from

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             noPdoWakeSupport = FALSE;
    BOOLEAN             foundDState = FALSE;
    DEVICE_POWER_STATE  deviceWake;
    DEVICE_POWER_STATE  deviceTempWake;
    KIRQL               oldIrql;
    NTSTATUS            status;
    PACPI_POWER_INFO    powerInfo;
    SYSTEM_POWER_STATE  systemWake;
    SYSTEM_POWER_STATE  tempWake;

    UNREFERENCED_PARAMETER( BaseCapabilities );

    //
    // Use the capabilities from the Device
    //
    deviceWake = DeviceCapabilities->DeviceWake;
    systemWake = DeviceCapabilities->SystemWake;

    //
    // Does the device support wake from D0? D1? D2? D3?
    //
    if (DeviceCapabilities->WakeFromD0) {

        *SupportedWake |= (1 << PowerDeviceD0 );

    }
    if (DeviceCapabilities->WakeFromD1) {

        *SupportedWake |= (1 << PowerDeviceD1 );

    }
    if (DeviceCapabilities->WakeFromD2) {

        *SupportedWake |= (1 << PowerDeviceD2 );

    }
    if (DeviceCapabilities->WakeFromD3) {

        *SupportedWake |= (1 << PowerDeviceD3 );

    }

    //
    // If we don't support any wake states in the PDO (ie: DeviceWake or
    // SystemWake is 0) then we should remember that for future considerations
    //
    if (deviceWake == PowerDeviceUnspecified ||
        systemWake == PowerSystemUnspecified) {

        noPdoWakeSupport = TRUE;
        deviceWake = PowerDeviceUnspecified;
        systemWake = PowerSystemUnspecified;

    }

    //
    // If we support the device wake (ie: there is a _PRW), then we
    // should take the minimum of the systemWake we got from the parent
    // and the value that is stored in the _PRW
    //
    if ( (DeviceExtension->Flags & DEV_CAP_WAKE) ) {

        //
        // Need power lock for the following.
        //
        KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

        //
        // Remember the current system wake level
        //
        tempWake = DeviceExtension->PowerInfo.SystemWakeLevel;

        //
        // See what D-state (if any) that the power plane information
        // maps to
        //
        deviceTempWake = ACPISystemPowerDetermineSupportedDeviceWakeState(
            DeviceExtension
            );

        KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

        //
        // Take the minimum
        //
        if (tempWake < systemWake || noPdoWakeSupport) {

            systemWake = tempWake;

        }

        //
        // Did the PRW have useful information for us?
        //
        if (deviceTempWake != PowerDeviceUnspecified) {

            //
            // Note that in this case, they are basically overriding all
            // other supported wake up states, so the thing to do is only
            // remember this wake level
            //
            foundDState = TRUE;
            deviceWake = deviceTempWake;

        }

        //
        // See if there is a device wake specified for this S-state?
        //
        status = ACPISystemPowerGetSxD(
            DeviceExtension,
            tempWake,
            &deviceTempWake
            );
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            status = ACPISystemPowerGetSxD(
                DeviceExtension,
                systemWake,
                &deviceTempWake
                );

        }
        if (NT_SUCCESS(status)) {

            //
            // Note that in this case, they are basically overriding all other
            // supported Wake up states, so the thing to do is only remember
            // this wake level
            //
            foundDState = TRUE;
            deviceWake = deviceTempWake;

        }

        if (!foundDState) {

            //
            // Crossreference the system wake level with the matrix
            // Need spinlock to do this
            //
            deviceWake = CurrentMapping[systemWake];

            //
            // If this value isn't known, then we guess that it can
            // from D3. In other words, unless they have made some
            // explicity mechanism to tell which D-state to wake from,
            // assume that we can do it from D3
            //
            if (deviceWake == PowerDeviceUnspecified) {

                deviceWake = PowerDeviceD3;

            }

        }

        //
        // We should only check to see if the D-state is a wakeable state
        // in the parent only if the parent claims to support wake
        //
        if (!noPdoWakeSupport) {

            //
            // The logic behind the following is that if we are a filter, even
            // if we support device wake (that is the _PRW is in the PCI device
            // itself, not for the root PCI bus), than we still need to make sure
            // that the D-State that we mapped to is one that is supported by
            // the hardware.
            //
            for (;deviceWake < PowerDeviceMaximum; deviceWake++) {

                //
                // If we we support this wake state, then we can stop
                //
                if (*SupportedWake & (1 << deviceWake) ) {

                    break;

                }

            }

        }

        //
        // If we got here, and the D-state is PowerDeviceMaximum, then we
        // don't really support wake on the device
        //
        if (deviceWake == PowerDeviceMaximum ||
            deviceWake == PowerDeviceUnspecified) {

            deviceWake = PowerDeviceUnspecified;
            systemWake = PowerSystemUnspecified;
            *SupportedWake = 0;

        } else {

            //
            // In this situation, we will end up only supporting this wake state
            //
            *SupportedWake = (1 << deviceWake );

        }

    } else {

        //
        // See if there is a device wake specified for this S-state
        //
        status = ACPISystemPowerGetSxD(
            DeviceExtension,
            systemWake,
            &deviceTempWake
            );
        if (NT_SUCCESS(status)) {

            //
            // Find the best supported wake level
            //
            for (;deviceTempWake > PowerDeviceUnspecified; deviceTempWake--) {

                if ( (*SupportedWake & (1 << deviceTempWake) ) ) {

                    deviceWake = deviceTempWake;
                    break;

                }

            }

        }

        //
        // Make sure that the system wake level is a valid one
        //
        for (; systemWake > PowerSystemUnspecified; systemWake--) {

            //
            // Since S-States that we don't support map to
            // PowerDeviceUnspecified, we cannot consider any of those S
            // states in this test. We also cannot consider them for other
            // obvious reasons as well
            //*
            if (!(AcpiSupportedSystemStates & (1 << systemWake) ) ||
                 (CurrentMapping[systemWake] == PowerDeviceUnspecified) ) {

                continue;

            }

            //
            // Does this S-state support the given S-State?
            //
            if (CurrentMapping[systemWake] <= deviceWake) {

                break;

            }

            //
            // Does the device state for the current system wake mapping
            // allow wake-from sleep?
            //
            if (*SupportedWake & (1 << CurrentMapping[systemWake]) ) {

                //
                // Yes? then we had better update our idea of what the
                // device wake state should be...
                //
                deviceWake = CurrentMapping[systemWake];
                break;

            }

        }

        //
        // If we got into a situation were we cannot find a single S-state
        // that we can wake from, then we must make sure that the device
        // wake is null
        //
        if (systemWake == PowerSystemUnspecified) {

            //
            // Remember that the device wake and supported wake states
            // are null
            //
            deviceWake = PowerDeviceUnspecified;
            *SupportedWake = 0;

        }

    }

    //
    // Return the proper device wake and system wake values
    //
    if (SystemWakeLevel != NULL) {

        *SystemWakeLevel = systemWake;

    }
    if (DeviceWakeLevel != NULL) {

        *DeviceWakeLevel = deviceWake;

    }
    if (FilterWakeLevel != NULL) {

        *FilterWakeLevel = deviceWake;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPISystemPowerUpdateWakeCapabilitiesForPDOs(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PDEVICE_CAPABILITIES    BaseCapabilities,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
    IN  DEVICE_POWER_STATE      CurrentMapping[PowerSystemMaximum],
    IN  ULONG                   *SupportedWake,
    IN  SYSTEM_POWER_STATE      *SystemWakeLevel,
    IN  DEVICE_POWER_STATE      *DeviceWakeLevel,
    IN  DEVICE_POWER_STATE      *FilterWakeLevel
    )
/*++

Routine Description:

    This routine calculates the Wake Capabilities of the device based on
    the present capabilities. This version of the function uses the
    system state that the device can wake from to determine what the
    appropriate device level is.

Arguments:

    DeviceExtension     - The device whose capabilities we want
    BaseCapabilities    - The base values
    DeviceCapabilities  - The capabilities for the device
    CurrentMapping      - The current S->D mapping
    SupportedWake       - BitMap of the supported Wake states
    SystemWakeLevel     - The S-State that we can wake up from
    DeviceWakeLevel     - The D-State that we can wake up from

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             foundDState = FALSE;
    DEVICE_POWER_STATE  deviceWake;
    DEVICE_POWER_STATE  deviceTempWake;
    DEVICE_POWER_STATE  filterWake = PowerDeviceUnspecified;
    KIRQL               oldIrql;
    NTSTATUS            status;
    SYSTEM_POWER_STATE  systemWake;

    UNREFERENCED_PARAMETER( DeviceCapabilities );
    UNREFERENCED_PARAMETER( BaseCapabilities );

    //
    // Use the capabilities of the device
    //
    if (!(DeviceExtension->Flags & DEV_CAP_WAKE) ) {

        deviceWake = PowerDeviceUnspecified;
        systemWake = PowerSystemUnspecified;
        goto ACPISystemPowerUpdateWakeCapabilitiesForPDOsExit;

    }

    //
    // Hold the lock for the following
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // Use the wake level that we know about. If this wakelevel
    // isn't supported, than there is a bios error
    //
    systemWake = DeviceExtension->PowerInfo.SystemWakeLevel;
    deviceTempWake = ACPISystemPowerDetermineSupportedDeviceWakeState(
        DeviceExtension
        );

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Sanity check
    //
    if (!(AcpiSupportedSystemStates & (1 << systemWake) ) ) {

#if 0
        if (!(AcpiOverrideAttributes & ACPI_OVERRIDE_MP_SLEEP) ) {

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_CANNOT_MAP_SYSTEM_TO_DEVICE_STATES,
                (ULONG_PTR) DeviceExtension,
                2,
                systemWake
                );

        }
#endif

        deviceWake = PowerDeviceUnspecified;
        systemWake = PowerSystemUnspecified;
        goto ACPISystemPowerUpdateWakeCapabilitiesForPDOsExit;

    }

    if (deviceTempWake != PowerDeviceUnspecified) {

        //
        // Note that in this case, they are basically overriding all
        // other supported wake up states, so the thing to do is only
        // remember this wake level
        //
        foundDState = TRUE;
        deviceWake = deviceTempWake;
        filterWake = deviceTempWake;
        *SupportedWake = (1 << deviceWake );

    }

    //
    // See if there is an SxD method that will give us a hint
    //
    status = ACPISystemPowerGetSxD(
        DeviceExtension,
        systemWake,
        &deviceTempWake
        );
    if (NT_SUCCESS(status)) {

        //
        // Note that in this case, they are basically overriding all other
        // supported Wake up states, so the thing to do is only remember
        // this wake level
        deviceWake = deviceTempWake;
        filterWake = deviceTempWake;
        foundDState = TRUE;

    }

    if (!foundDState) {

        //
        // Crossreference the system wake level with the matrix
        // Need spinlock to do this
        //
        deviceWake = CurrentMapping[systemWake];

        //
        // If this value isn't known, then we guess that it can
        // from D3. In other words, unless they have made some
        // explicity mechanism to tell which D-state to wake from,
        // assume that we can do it from D3
        //
        if (deviceWake == PowerDeviceUnspecified) {

            deviceWake = PowerDeviceD3;

        }

    }

ACPISystemPowerUpdateWakeCapabilitiesForPDOsExit:

    //
    // Set the return values
    //
    if (deviceWake != PowerDeviceUnspecified) {

        *SupportedWake = (1 << deviceWake );

    } else {

        *SupportedWake = 0;
    }

    if (SystemWakeLevel != NULL) {

        *SystemWakeLevel = systemWake;

    }
    if (DeviceWakeLevel != NULL) {

        *DeviceWakeLevel = deviceWake;

    }
    if (FilterWakeLevel != NULL) {

        *FilterWakeLevel = filterWake;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\table.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    table.c

Abstract:

    All the function related to actually loading an ACPI table
    are included herein.

    This, however, is mostly bookkeeping since the actual mechanics
    of creating device extensions, and the name space tree are
    handled elsewhere

Author:

    Stephane Plante (splante)

Environment:

    Kernel Mode Only

Revision History:

    03/22/00 - Created (from code in callback.c)

--*/

#include "pch.h"

NTSTATUS
ACPITableLoad(
    VOID
    )
/*++

Routine Description:

    This routine is called when the AML interpreter has finished loading
    a Differentiated Data Block

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             runRootIni = FALSE;
    KIRQL               oldIrql;
    NTSTATUS            status;
    PDEVICE_EXTENSION   fixedButtonExtension = NULL;
    PNSOBJ              iniObject;
    PNSOBJ              nsObject;

    //
    // At this point, we should do everything that we need to do once the
    // name space has been loaded. Note that we need to make sure that we
    // only do those things once...
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // We need the ACPI object for the _SB tree
    //
    status = AMLIGetNameSpaceObject( "\\_SB", NULL, &nsObject, 0 );
    if (!NT_SUCCESS(status)) {

        //
        // Ooops. Failure
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPICallBackLoadUnloadDDB: No SB Object!\n"
            ) );
        ACPIInternalError( ACPI_CALLBACK );
        return STATUS_SUCCESS;

    }

    //
    // Make sure that the root device extension's object points to the correct
    // thing. We only want to run through this code path once...
    //
    if (RootDeviceExtension->AcpiObject == NULL) {

        runRootIni = TRUE;
        InterlockedIncrement( &(RootDeviceExtension->ReferenceCount) );
        RootDeviceExtension->AcpiObject = nsObject;
        nsObject->Context = RootDeviceExtension;

        //
        // Now, enumerate the fixed button
        //
        status = ACPIBuildFixedButtonExtension(
            RootDeviceExtension,
            &fixedButtonExtension
            );
        if (NT_SUCCESS(status) &&
            fixedButtonExtension != NULL) {

            //
            // Incremement the reference count on the node. We do this because
            // we are going to be doing work (which will take a long time
            // to complete, anyways), and we don't want to hold the lock for that
            // entire time. If we incr the reference count, then we guarantee that
            // no one can come along and kick the feet out from underneath us
            //
            InterlockedIncrement( &(fixedButtonExtension->ReferenceCount) );

        }

    }

    //
    // We now want to run the _INI through the entire tree, starting at
    // the _SB
    //
    status = ACPIBuildRunMethodRequest(
        RootDeviceExtension,
        NULL,
        NULL,
        PACKED_INI,
        (RUN_REQUEST_CHECK_STATUS | RUN_REQUEST_RECURSIVE | RUN_REQUEST_MARK_INI),
        FALSE
        );
    if (!NT_SUCCESS(status)) {

        ACPIInternalError( ACPI_CALLBACK );

    }

    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // We also need to run the _INI method off of the root name space entry
    //
    if (runRootIni) {

        iniObject = ACPIAmliGetNamedChild( nsObject->pnsParent, PACKED_INI );
        if (iniObject) {

            AMLINestAsyncEvalObject(
                iniObject,
                NULL,
                0,
                NULL,
                NULL,
                NULL
                );

        }

    }

    //
    // We need a synchronization point after we finish running the
    // DPC engine. We want to be able to move anything in the Delayed
    // Power Queue over to the Power DPC engine
    //
    status = ACPIBuildSynchronizationRequest(
        RootDeviceExtension,
        ACPITableLoadCallBack,
        NULL,
        &AcpiBuildDeviceList,
        FALSE
        );
    if (!NT_SUCCESS(status)) {

        ACPIInternalError( ACPI_CALLBACK );

    }

    //
    // We need to hold this spinlock
    //
    KeAcquireSpinLock( &AcpiBuildQueueLock, &oldIrql );

    //
    // Do we need to run the DPC?
    //
    if (!AcpiBuildDpcRunning) {

        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0);

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiBuildQueueLock, oldIrql );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

VOID
ACPITableLoadCallBack(
    IN  PVOID       BuildContext,
    IN  PVOID       Context,
    IN  NTSTATUS    Status
    )
/*++

Routine Description:

    This routine is called when we have emptied all of the elements
    within the AcpiBuildDeviceList. This is a good time to move items
    from the AcpiPowerDelayedQueueList to the AcpiPowerQueueList.

Arguments:

    BuildContext    - Not used (it is the RootDeviceExtension)
    Context         - NULL
    Status          - Status of the operation

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER( BuildContext );
    UNREFERENCED_PARAMETER( Context );
    UNREFERENCED_PARAMETER( Status );

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // We want to rebuilt the device based GPE mask here, so
    // we need the following locks
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiDeviceTreeLock );
    KeAcquireSpinLockAtDpcLevel( &GpeTableLock );

    //
    // Now, we need to walk the device namespace and find which events
    // are special, which are wake events, and which are run-time events
    // As a matter of practical theory, its not possible for there to
    // be a _PRW on the root device extension, so we should be safely
    // able to walk only the Root's children and thereon
    //
    ACPIGpeBuildWakeMasks(RootDeviceExtension);

    //
    // We don't need these particular spin locks anymore
    //
    KeReleaseSpinLockFromDpcLevel( &GpeTableLock );
    KeReleaseSpinLockFromDpcLevel( &AcpiDeviceTreeLock );

    //
    // We need the power lock to touch these Power Queues
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerQueueLock );

    //
    // If we there are items on the delayed list, we need to put them
    // on the main list
    //
    if (!IsListEmpty( &AcpiPowerDelayedQueueList ) ) {

        //
        // Move the list
        //
        ACPIInternalMoveList(
            &AcpiPowerDelayedQueueList,
            &AcpiPowerQueueList
            );

        //
        // Schedule the DPC, if necessary
        ///
        if (!AcpiPowerDpcRunning) {

            KeInsertQueueDpc( &AcpiPowerDpc, 0, 0 );

        }
    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerQueueLock );

}

NTSTATUS
EXPORT
ACPITableNotifyFreeObject(
    ULONG   Event,
    PVOID   Context,
    ULONG   ObjectType
    )
/*++

Routine Description:

    This routine is called when interpreter tells us that an
    object has been freed

Arguments:

    Event       - the step in unload
    Object      - the object being unloaded
    ObjectType  - the type of the object

--*/
{
    LONG                oldReferenceCount;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_EXTENSION   parentExtension;
    PKIRQL              oldIrql;
    PNSOBJ              object;

    //
    // Start case
    //
    if (Event == DESTROYOBJ_START) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "Unloading: Start\n"
            ) );

        oldIrql = (PKIRQL) Context;
        KeAcquireSpinLock( &AcpiDeviceTreeLock, oldIrql );
        return STATUS_SUCCESS;

    }
    if (Event == DESTROYOBJ_END) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "Unloading: End\n"
            ) );

        oldIrql = (PKIRQL) Context;
        KeReleaseSpinLock( &AcpiDeviceTreeLock, *oldIrql );
        return STATUS_SUCCESS;
    }

    //
    // At this point, we have a either a valid unload request or
    // a bugcheck request
    //
    object = (PNSOBJ) Context;

    //
    // Let the world Know...
    //
    ACPIPrint( (
        ACPI_PRINT_CRITICAL,
        "%x: Unloading: %x %x %x\n",
        (object ? object->Context : 0),
        object,
        ObjectType,
        Event
        ) );

    //
    // Handle the bugcheck cases
    //
    if (Event == DESTROYOBJ_CHILD_NOT_FREED) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_TABLE_UNLOAD,
            (ULONG_PTR) object,
            0,
            0
            );

    }
    if (Event == DESTROYOBJ_BOGUS_PARENT) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_TABLE_UNLOAD,
            (ULONG_PTR) object,
            1,
            0
            );

    }

    //
    // We only understand processors, thermal zones, and devices for right
    // now, we will have to add power resources at a later point
    //
    if (ObjectType == OBJTYPE_POWERRES) {

        return STATUS_SUCCESS;

    }

    //
    // Grab the device extension, and make sure that one exists
    //
    deviceExtension = object->Context;
    if (deviceExtension == NULL) {

        //
        // No device extension, so we can free this thing *now*
        //
        AMLIDestroyFreedObjs( object );
        return STATUS_SUCCESS;

    }

    //
    // Mark the extension as no longer existing
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_PROP_UNLOADING,
        FALSE
        );

    //
    // Does this device have a parent extension? It might not
    // have an extension if the parent has been marked for removal
    //
    parentExtension = deviceExtension->ParentExtension;
    if (parentExtension != NULL) {

        //
        // Mark the parent's relations as invalid
        //
        ACPIInternalUpdateFlags(
            &(parentExtension->Flags),
            DEV_PROP_INVALID_RELATIONS,
            FALSE
            );

    }

    //
    // Finally, decrement the reference count on the device...
    //
    oldReferenceCount = InterlockedDecrement(
        &(deviceExtension->ReferenceCount)
        );
    if (oldReferenceCount == 0) {

        //
        // Free this extension
        //
        ACPIInitDeleteDeviceExtension( deviceExtension );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPITableUnload(
    VOID
    )
/*++

Routine Description:

    This routine is called after a table has been unloaded.

    The purpose of this routine is to go out and issue the invalidate
    device relations on all elements of the table whose children are
    going away...

Arguments:

    None

Return value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // We will need to hold the device tree lock for the following
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Check to see if we have to invalid the root's device extension?
    //
    deviceExtension = RootDeviceExtension;
    if (deviceExtension && !(deviceExtension->Flags & DEV_TYPE_NOT_FOUND) ) {

        if (deviceExtension->Flags & DEV_PROP_INVALID_RELATIONS) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                DEV_PROP_INVALID_RELATIONS,
                TRUE
                );
            IoInvalidateDeviceRelations(
                deviceExtension->PhysicalDeviceObject,
                BusRelations
                );

        } else {

            //
            // Walk the namespace looking for bogus relations
            //
            ACPITableUnloadInvalidateRelations( deviceExtension );

        }

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // And with the function
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPITableUnloadInvalidateRelations(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This recursive routine is called to walke the namespace and issue
    the appropriate invalidates.

    The device tree lock is owned during this call...

Arguments:

    DeviceExtension - The device whose child extension we have to check

Return Value:

    NTSTATUS

--*/
{
    EXTENSIONLIST_ENUMDATA  eled;
    PDEVICE_EXTENSION       childExtension;

    //
    // Setup the data structures that we will use to walk the
    // device extension tree
    //
    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->ChildDeviceList),
        NULL,
        SiblingDeviceList,
        WALKSCHEME_NO_PROTECTION
        );

    //
    // Look at all the children of the current device extension
    //
    for (childExtension = ACPIExtListStartEnum( &eled) ;
         ACPIExtListTestElement( &eled, TRUE);
         childExtension = ACPIExtListEnumNext( &eled) ) {

        //
        // Does this object have any device objects?
        //
        if (!(childExtension->Flags & DEV_TYPE_NOT_FOUND) ) {

            continue;

        }

        //
        // Do we have to invalidate this object's relations?
        //
        if (childExtension->Flags & DEV_PROP_INVALID_RELATIONS) {

            ACPIInternalUpdateFlags(
                &(childExtension->Flags),
                DEV_PROP_INVALID_RELATIONS,
                TRUE
                );
            IoInvalidateDeviceRelations(
                childExtension->PhysicalDeviceObject,
                BusRelations
                );
            continue;
        }

        //
        // Recurse
        //
        ACPITableUnloadInvalidateRelations( childExtension );

    } // for ( ... )

    //
    // Done
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\table.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    table.h

Abstract:

    All the function related to actually loading an ACPI table
    are included herein.

    This, however, is mostly bookkeeping since the actual mechanics
    of creating device extensions, and the name space tree are
    handled elsewhere

Author:

    Stephane Plante (splante)

Environment:

    Kernel Mode Only

Revision History:

    03/22/00 - Created (from code in callback.c)

--*/

#ifndef _TABLE_H_
#define _TABLE_H_

    NTSTATUS
    ACPITableLoad(
        VOID
        );

    VOID
    ACPITableLoadCallBack(
        IN  PVOID       BuildContext,
        IN  PVOID       Context,
        IN  NTSTATUS    Status
        );

    NTSTATUS
    EXPORT
    ACPITableNotifyFreeObject(
        IN  ULONG       Event,
        IN  PVOID       Object,
        IN  ULONG       ObjectType
        );

    NTSTATUS
    ACPITableUnload(
        VOID
        );

    NTSTATUS
    ACPITableUnloadInvalidateRelations(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\syspower.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    syspower.h

Abstract:

    Contains all the code that deals with the system having to determine
    System Power State to Device Power State mappings

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    October 29th, 1998

--*/

#ifndef _SYSPOWER_H_
#define _SYSPOWER_H_

    #define IoCopyDeviceCapabilitiesMapping( Source, Dest )           \
        RtlCopyMemory( (PUCHAR) Dest, (PUCHAR) Source,                \
            (PowerSystemShutdown + 1) * sizeof(DEVICE_POWER_STATE) )

    NTSTATUS
    ACPISystemPowerDetermineSupportedDeviceStates(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  SYSTEM_POWER_STATE  SystemState,
        OUT ULONG               *SupportedDeviceStates
        );

    DEVICE_POWER_STATE
    ACPISystemPowerDetermineSupportedDeviceWakeState(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    SYSTEM_POWER_STATE
    ACPISystemPowerDetermineSupportedSystemState(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  DEVICE_POWER_STATE  DeviceState
        );

    NTSTATUS
    ACPISystemPowerGetSxD(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  SYSTEM_POWER_STATE  SystemState,
        OUT DEVICE_POWER_STATE  *DeviceState
        );

    NTSTATUS
    ACPISystemPowerInitializeRootMapping(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PDEVICE_CAPABILITIES    DeviceCapabilities
        );

    NTSTATUS
    ACPISystemPowerProcessRootMapping(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  DEVICE_POWER_STATE  DeviceMapping[PowerSystemMaximum]
        );

    NTSTATUS
    ACPISystemPowerProcessSxD(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  DEVICE_POWER_STATE  CurrentMapping[PowerSystemMaximum],
        IN  PBOOLEAN            MatchFound
        );

    NTSTATUS
    ACPISystemPowerQueryDeviceCapabilities(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PDEVICE_CAPABILITIES    DeviceCapabilities
        );

    NTSTATUS
    ACPISystemPowerUpdateDeviceCapabilities(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PDEVICE_CAPABILITIES    BaseCapabilities,
        IN  PDEVICE_CAPABILITIES    DeviceCapabilities
        );

    NTSTATUS
    ACPISystemPowerUpdateWakeCapabilities(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PDEVICE_CAPABILITIES    BaseCapabilities,
        IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
        IN  DEVICE_POWER_STATE      CurrentMapping[PowerSystemMaximum],
        IN  ULONG                   *SupportedWake,
        IN  SYSTEM_POWER_STATE      *SystemWakeLevel,
        IN  DEVICE_POWER_STATE      *DeviceWakeLevel,
        IN  DEVICE_POWER_STATE      *FilterWakeLevel
        );

    NTSTATUS
    ACPISystemPowerUpdateWakeCapabilitiesForFilters(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PDEVICE_CAPABILITIES    BaseCapabilities,
        IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
        IN  DEVICE_POWER_STATE      CurrentMapping[PowerSystemMaximum],
        IN  ULONG                   *SupportedWake,
        IN  SYSTEM_POWER_STATE      *SystemWakeLevel,
        IN  DEVICE_POWER_STATE      *DeviceWakeLevel,
        IN  DEVICE_POWER_STATE      *FilterWakeLevel
        );

    NTSTATUS
    ACPISystemPowerUpdateWakeCapabilitiesForPDOs(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PDEVICE_CAPABILITIES    BaseCapabilities,
        IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
        IN  DEVICE_POWER_STATE      CurrentMapping[PowerSystemMaximum],
        IN  ULONG                   *SupportedWake,
        IN  SYSTEM_POWER_STATE      *SystemWakeLevel,
        IN  DEVICE_POWER_STATE      *DeviceWakeLevel,
        IN  DEVICE_POWER_STATE      *FilterWakeLevel
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\thermal.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    thermal.c

Abstract:

    Thermal Zone support

    A small discourse on the use and function of the THRM_WAIT_FOR_NOTIFY
    flag. This flag was added to ensure that at least one Notify() operation
    occured between each query of the temperature. In other words, we didn't
    want to loop forever asking and receiving the same temperature information.

    One of the side effects of this flag is that if we get a QUERY, then
    a SET (instead of another QUERY), then the set must clear the flag.
    Failure to do so will prevent the ThermalLoop() code from ever completing
    the IRP. And that means that the temperature mechanisms will stop working.

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July 7, 1997    - Complete Rewrite
--*/

#include "pch.h"

WMIGUIDREGINFO ACPIThermalGuidList =
{
    &THERMAL_ZONE_GUID,
    1,
    0
};

//
// Spinlock to protect the thermal list
//
KSPIN_LOCK  AcpiThermalLock;

//
// List entry to store the thermal requests on
//
LIST_ENTRY  AcpiThermalList;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIThermalStartDevice)
#pragma alloc_text(PAGE, ACPIThermalWorker)
#pragma alloc_text(PAGE, ACPIThermalQueryWmiRegInfo)
#pragma alloc_text(PAGE, ACPIThermalQueryWmiDataBlock)
#pragma alloc_text(PAGE, ACPIThermalWmi)
#endif

VOID
ACPIThermalCalculateProcessorMask(
    IN PNSOBJ           ProcessorObject,
    IN PTHRM_INFO       Thrm
    )
/*++

Routine Description:

    This routine, which is only called from ACPIThermalWorker, has been
    created so that we don't have to worry about locking down the
    ACPIThermalWorker, takes a processor object from the namespace and
    sets the proper affinity bit in the thermal info

Arguments:

    ProcessorObject - Pointer to Namespace Processor Object
    Thrm            - Thermal Information Structure

Return Value:

    None

--*/
{
    KIRQL               OldIrql;
    PDEVICE_EXTENSION   ProcessorExtension;

    //
    // Sanity check
    //
    if (ProcessorObject == NULL) {

        return;

    }

    //
    // We need the spinlock to deref the processor extension
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &OldIrql );

    //
    // The context pointer is the device extension
    //
    ProcessorExtension = (PDEVICE_EXTENSION) ProcessorObject->Context;
    if (ProcessorExtension) {

        //
        // We know what index it is within the processor list.
        // This should be a good enough guess for now
        //
        Thrm->Info.Processors |= (1 << ProcessorExtension->Processor.ProcessorIndex);

    }

    //
    // Done with the spinlock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, OldIrql );

}

VOID
ACPIThermalCancelRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine cancels an outstanding thermal request

Arguments

    DeviceObject    - The device which has a request being cancelled
    Irp             - The cancelling irp

Return Value:

    None

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

#if DBG
    ULONGLONG           currentTime = KeQueryInterruptTime();

    ACPIThermalPrint( (
        ACPI_PRINT_THERMAL,
        deviceExtension,
        currentTime,
        "ACPIThermalCancelRequest: Irp %08lx\n",
        Irp
        ) );
#endif

    //
    // We no longer need the cancel lock
    //
    IoReleaseCancelSpinLock (Irp->CancelIrql);

    //
    // We do however need the thermal queue lock
    //
    KeAcquireSpinLock( &AcpiThermalLock, &oldIrql );

    //
    // Remove the irp from the list that it is on
    //
    RemoveEntryList( &(Irp->Tail.Overlay.ListEntry) );

    //
    // Done with the thermal lock now
    //
    KeReleaseSpinLock( &AcpiThermalLock, oldIrql );

    //
    // Complete the irp now
    //
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
}

VOID
EXPORT
ACPIThermalComplete (
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result  OPTIONAL,
    IN PVOID                DeviceExtension
    )
/*++

Routine Description:

    This routine is called when the interpreter has completed a request

Arguments:

    AcpiObject  - The request that was completed
    Status      - The status of the request
    Result      - What the result of the request was
    DevExt      - The context of the request

Return Value:

    NONE

--*/
{
    ACPIThermalLoop (DeviceExtension, THRM_BUSY);
}

BOOLEAN
ACPIThermalCompletePendingIrps(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PTHRM_INFO          Thermal
    )
/*++

Routine Description:

    This routine is called, with no spinlock being held. This routine
    completes any IOCTLs associated with the device object

    This routine will return TRUE if it completed any requests, false
    otherwise

Arguments:

    DeviceExtension - The device extension whose requests we want to complete
    Thermal         - Pointer to the thermal information for the extension

Return Value:

    BOOLEAN
--*/
{
    BOOLEAN                 handledRequest  = FALSE;
    KIRQL                   oldIrql;
    LIST_ENTRY              doneList;
    PDEVICE_EXTENSION       irpExtension;
    PDEVICE_OBJECT          deviceObject;
    PIO_STACK_LOCATION      irpSp;
    PIRP                    irp;
    PLIST_ENTRY             listEntry;
    PTHERMAL_INFORMATION    thermalInfo;

    //
    // Initialize the list that will hold the requets that we need to complete
    //
    InitializeListHead( &doneList );
    //
    // Acquire the thermal lock so that we can pend these requests
    //
    KeAcquireSpinLock( &AcpiThermalLock, &oldIrql );

    //
    // Walk the list of pending irps to see which ones match this extensions
    //
    listEntry = AcpiThermalList.Flink;
    while (listEntry != &AcpiThermalList) {

        //
        // Grab the irp from the list entry and update the next list entry
        // that we will look at
        //
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        listEntry = listEntry->Flink;

        //
        // We need the current irp stack location
        //
        irpSp = IoGetCurrentIrpStackLocation( irp );

        //
        // Grab the device object from the irp stack and turn that into a
        // device extension
        //
        irpExtension = ACPIInternalGetDeviceExtension( irpSp->DeviceObject );

        //
        // Is this an irp that we care about? IE: does the target match the
        // one specified in this function
        //
        if (irpExtension != DeviceExtension) {

            continue;

        }

        //
        // If this is a query information irp then, we must be able to set the
        // cancel routine to NULL to make sure that it cannot be cancelled on
        // us
        //
        if (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_THERMAL_QUERY_INFORMATION) {

            if (IoSetCancelRoutine(irp, NULL) == NULL) {

                //
                // Cancel routine is active, stop processing this irp and move on
                //
                continue;

            }

            //
            // Copy the data that we got back to the irp
            //
            DeviceExtension->Thermal.Flags |= THRM_WAIT_FOR_NOTIFY;
            thermalInfo = (PTHERMAL_INFORMATION) irp->AssociatedIrp.SystemBuffer;
            memcpy (thermalInfo, Thermal, sizeof (THERMAL_INFORMATION));

            //
            // Set the parameters that we will return
            //
            irp->IoStatus.Information   = sizeof(THERMAL_INFORMATION);

        } else {

            //
            // Set the parameters that we will return
            //
            irp->IoStatus.Information = 0;

        }

        //
        // Always succeed these irps
        //
        irp->IoStatus.Status        = STATUS_SUCCESS;

        //
        // Remove the entry from the list
        //
        RemoveEntryList( &(irp->Tail.Overlay.ListEntry) );

        //
        // Insert the list into the next queue so that we know to complete it
        // later on
        //
        InsertTailList( &doneList, &(irp->Tail.Overlay.ListEntry) );

    }

    //
    // At this point, drop our thermal lock
    //
    KeReleaseSpinLock( &AcpiThermalLock, oldIrql );

    //
    // Walk the list of irpts to be completed
    //
    listEntry = doneList.Flink;
    while (listEntry != &doneList) {

        //
        // Grab the irp from the list entry and update the next list entry
        // that we will look at
        //
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        listEntry = listEntry->Flink;
        RemoveEntryList( &(irp->Tail.Overlay.ListEntry) );

        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            DeviceExtension,
            KeQueryInterruptTime(),
            "Completing Irp 0x%x\n",
            irp
            ) );

        //
        // Now complete the irp
        //
        IoCompleteRequest( irp, IO_NO_INCREMENT );

        //
        // Remember that we handled a request
        //
        handledRequest = TRUE;

    }

    //
    // Return wether or not we handled a request
    return handledRequest;
}

NTSTATUS
ACPIThermalDeviceControl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    Fixed button device IOCTL handler

Arguments:

    DeviceObject    - fixed feature button device object
    Irp             - the ioctl request

Return Value:

    NTSTATUS

--*/
{
    KIRQL                       oldIrql;
    PIO_STACK_LOCATION          IrpSp           = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION           deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PTHERMAL_INFORMATION        thermalInfo;
    PULONG                      Mode;
    PTHRM_INFO                  Thrm            = deviceExtension->Thermal.Info;
    NTSTATUS                    Status          = STATUS_PENDING;
    ULONG                       ThermalWork     = 0;
    ULONGLONG                   currentTime;

    //
    // Do not allow user mode IRPs in this routine
    //
    if (Irp->RequestorMode != KernelMode) {

        return ACPIDispatchIrpInvalid( DeviceObject, Irp );

    }

#if DBG
    currentTime = KeQueryInterruptTime();
#endif

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_THERMAL_QUERY_INFORMATION:

        //
        // If this irp's stamp does not match the known last stamp, then we
        // need a new temp now
        //
        thermalInfo = (PTHERMAL_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
        if (thermalInfo->ThermalStamp != Thrm->Info.ThermalStamp) {

            ThermalWork = THRM_TEMP | THRM_WAIT_FOR_NOTIFY;

        }
#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            deviceExtension,
            currentTime,
            "%08x - THERMAL_QUERY_INFORMATION: %x - %x\n",
            Irp,
            thermalInfo->ThermalStamp,
            Thrm->Info.ThermalStamp
            ) );
#endif

        break;

    case IOCTL_THERMAL_SET_COOLING_POLICY:

        //
        // Set the thermal zone's policy mode
        //
        Thrm->Mode = *((PUCHAR) Irp->AssociatedIrp.SystemBuffer);
        ThermalWork = THRM_MODE | THRM_TRIP_POINTS | THRM_WAIT_FOR_NOTIFY;

#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            deviceExtension,
            currentTime,
            "%08x - SET_COOLING_POLICY: %x\n",
            Irp,
            Thrm->Mode
            ) );
#endif

        break;

    case IOCTL_RUN_ACTIVE_COOLING_METHOD:

        Thrm->CoolingLevel = *((PUCHAR) Irp->AssociatedIrp.SystemBuffer);
        ThermalWork = THRM_COOLING_LEVEL | THRM_WAIT_FOR_NOTIFY;

#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            deviceExtension,
            currentTime,
            "%08x - ACTIVE_COOLING_LEVEL: %x\n",
            Irp,
            Thrm->CoolingLevel
            ) );
#endif

        break;

    default:

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_NOT_SUPPORTED;

    }

    //
    // Grab the thermal lock, queue the request to the proper place, and make
    // sure to set a cancel routine --- no that we will only allow a cancel
    // routine if this is a query irp
    //
    KeAcquireSpinLock( &AcpiThermalLock, &oldIrql );

    //
    // There is one fly in the ointment: What to do if the device is no longer
    // there. The only way to really handle that is to just fail the request.
    // Its important to note that this check is done while the ThermalLock
    // is being held because the code that builds a SurpriseRemoved extension
    // will attempt to call AcpiThermalCompletePendingIrps which also
    // acquires this lock.
    //
    if (deviceExtension->Flags & DEV_TYPE_SURPRISE_REMOVED) {

        KeReleaseSpinLock( &AcpiThermalLock, oldIrql );
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;

    }

    if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_THERMAL_QUERY_INFORMATION) {

        IoSetCancelRoutine (Irp, ACPIThermalCancelRequest);
        if (Irp->Cancel && IoSetCancelRoutine( Irp, NULL ) ) {

            //
            // If we got here, that means that the irp has been cancelled and we
            // beat the IO manager to the ThermalLock. So release the irp, and
            // mark the irp as being cancelled
            //
            KeReleaseSpinLock( &AcpiThermalLock, oldIrql );
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return STATUS_CANCELLED;

        }

        //
        // If we got to this point, we are going to queue the request and do some
        // work on it later
        //
        IoMarkIrpPending( Irp );

    }

    //
    // If we got here, we know we can queue the irp in the outstanding
    // work list entry
    //
    InsertTailList( &AcpiThermalList, &(Irp->Tail.Overlay.ListEntry) );

    //
    // Done with the lock at this point
    //
    KeReleaseSpinLock( &AcpiThermalLock, oldIrql );

    //
    // Fire off the workter thread
    //
    ACPIThermalLoop (deviceExtension, ThermalWork);
    return Status;
}

VOID
ACPIThermalEvent (
    IN PDEVICE_OBJECT   DeviceObject,
    IN ULONG            EventData
    )
/*++

Routine Description:

    This routine handles thermal events

Arguments:

    DeviceObject    - The device that received the event
    EventData       - The event that just happened

Return Value:

    NONE

--*/
{
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    ULONG               clear;

    ACPIThermalPrint( (
        ACPI_PRINT_THERMAL,
        deviceExtension,
        KeQueryInterruptTime(),
        "ACPIThermalEvent - Notify(%x)\n",
        EventData
        ) );

    //
    // Handle event type
    //
    clear = 0;
    switch (EventData) {
    case 0x80:

        //
        // Tempature changed notification
        //
        clear = THRM_WAIT_FOR_NOTIFY | THRM_TEMP;
        break;

    case 0x81:

        //
        // Trips points changed notification
        //
        clear = THRM_WAIT_FOR_NOTIFY | THRM_TEMP | THRM_TRIP_POINTS;
        break;

    default:
        break;
    }

    ACPIThermalLoop (deviceExtension, clear);
}

NTSTATUS
ACPIThermalFanStartDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the routine that processes the start device for the fans

Arguments:

    DeviceObject    - The fan device
    Irp             - The start request

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    //
    // There is nothing to do when starting a fan --- it is really being
    // controlled by the thermal zones
    //
    deviceExtension->DeviceState = Started;

    //
    // Complete the request
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = (ULONG_PTR) NULL;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Let the world know
    //
    ACPIDevPrint( (
        ACPI_PRINT_THERMAL,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        STATUS_SUCCESS
        ) );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

VOID
ACPIThermalLoop (
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN ULONG                Clear
    )
/*++

Routine Description:

    This is the routine that processes all thermal events

Arguments:

    DevExt  - The device extension of the thermal zone
    Clear   - Bits to clear

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN     doneRequests;
    BOOLEAN     lockHeld;
    KIRQL       oldIrql;
    PTHRM_INFO  thermal;
    NTSTATUS    status;

    thermal = DeviceExtension->Thermal.Info;

    KeAcquireSpinLock (&DeviceExtension->Thermal.SpinLock, &oldIrql);
    lockHeld = TRUE;

    DeviceExtension->Thermal.Flags &= ~Clear;

    //
    // If we're not in the service loop, enter it now
    //
    if (!(DeviceExtension->Thermal.Flags & THRM_IN_SERVICE_LOOP)) {
        DeviceExtension->Thermal.Flags |= THRM_IN_SERVICE_LOOP;

        //
        // Loop while there's work to be done
        //
        for (; ;) {

            //
            // Synchronize the thermal zone
            //
            if (!lockHeld) {

                KeAcquireSpinLock(&DeviceExtension->Thermal.SpinLock, &oldIrql);
                lockHeld = TRUE;

            }

            //
            // If some work is pending, wait for it to complete
            //
            if (DeviceExtension->Thermal.Flags & THRM_BUSY) {

                break;

            }

            //
            // Make sure that the thermal zone is initialized. This must
            // be the first thing that we do in the loop!!!
            //
            if (!(DeviceExtension->Thermal.Flags & THRM_INITIALIZE) ) {

                DeviceExtension->Thermal.Flags |= THRM_BUSY | THRM_INITIALIZE;
                ACPISetDeviceWorker(
                    DeviceExtension,
                    THRM_COOLING_LEVEL | THRM_INITIALIZE
                    );
                continue;

            }

            //
            // If the thermal zone mode needs updated, do it now
            //
            if (!(DeviceExtension->Thermal.Flags & THRM_MODE)) {

                DeviceExtension->Thermal.Flags |= THRM_BUSY | THRM_MODE;
                KeReleaseSpinLock (&DeviceExtension->Thermal.SpinLock, oldIrql);
                lockHeld = FALSE;

                status = ACPIGetNothingEvalIntegerAsync(
                    DeviceExtension,
                    PACKED_SCP,
                    thermal->Mode,
                    ACPIThermalComplete,
                    DeviceExtension
                    );
                if (status != STATUS_PENDING) {

                    ACPIThermalComplete(
                        NULL,
                        status,
                        NULL,
                        DeviceExtension
                        );

                }
                continue;

            }

            //
            // If the trip point infomation needs updated, get it. Note that
            // updating the trip points means that we also need to redo the
            // cooling level
            //
            if (!(DeviceExtension->Thermal.Flags & THRM_TRIP_POINTS)) {

                DeviceExtension->Thermal.Flags |= THRM_BUSY | THRM_TRIP_POINTS;
                ACPISetDeviceWorker( DeviceExtension, THRM_TRIP_POINTS );
                continue;

            }

            //
            // If the cooling level has changed,
            //
            if (!(DeviceExtension->Thermal.Flags & THRM_COOLING_LEVEL)) {

                DeviceExtension->Thermal.Flags |= THRM_BUSY | THRM_COOLING_LEVEL;
                ACPISetDeviceWorker (DeviceExtension, THRM_COOLING_LEVEL);
                continue;

            }

            //
            // Prevent the recursion that occurs when we complete an irp and
            // the completion routine is able to queue the IRP before we resume
            // the loop
            //
            if ( (DeviceExtension->Thermal.Flags & THRM_WAIT_FOR_NOTIFY) &&
                 (DeviceExtension->Thermal.Flags & THRM_TEMP) ) {

                break;

            }

            //
            // If we don't have a temp, get it
            //
            if (!(DeviceExtension->Thermal.Flags & THRM_TEMP)) {

                //
                // Is the temp object not present?
                //
#if DBG
                if (thermal->TempMethod == NULL) {

                    ACPIInternalError( ACPI_THERMAL );

                }
#endif

                thermal->Info.ThermalStamp += 1;
                DeviceExtension->Thermal.Flags |= THRM_BUSY | THRM_TEMP;
                KeReleaseSpinLock (&DeviceExtension->Thermal.SpinLock, oldIrql);
                lockHeld = FALSE;

                RtlZeroMemory (&thermal->Temp, sizeof(OBJDATA));

                thermal->Temp.dwDataType = OBJTYPE_UNKNOWN;
                status = AMLIAsyncEvalObject(
                    thermal->TempMethod,
                    &thermal->Temp,
                    0,
                    NULL,
                    ACPIThermalTempatureRead,
                    DeviceExtension
                    );

                if (status != STATUS_PENDING) {

                    ACPIThermalTempatureRead(
                        thermal->TempMethod,
                        status,
                        &thermal->Temp,
                        DeviceExtension
                        );

                }
                continue;

            }

            //
            // Everything is up to date.  Check for a pending irp to see if
            // we can complete it.
            //

            //
            // Call into a child function to determine if we have completed
            // any requests
            //
            doneRequests = ACPIThermalCompletePendingIrps(
                DeviceExtension,
                thermal
                );
            if (doneRequests) {

                continue;

            }
            break;

        }

        //
        // No longer in the serivce loop
        //
        DeviceExtension->Thermal.Flags &= ~THRM_IN_SERVICE_LOOP;

    }

    KeReleaseSpinLock (&DeviceExtension->Thermal.SpinLock, oldIrql);
    return ;
}

VOID
ACPIThermalPowerCallback (
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN PVOID                Context,
    IN NTSTATUS             Status
    )
/*++

Routine Description:

    This is the routine that is called after we have sent an internal
    power request to the device

Arguments:

    DeviceExtension - the device that was set
    Context         - Not used
    Status          - Result

Return Value:

    None

--*/
{
    if (!NT_SUCCESS(Status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "ACPIThermalPowerCallBack: failed power setting %x\n",
            Status
            ) );

    }
}

NTSTATUS
ACPIThermalQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. When the driver has finished filling the
    data block it must call WmiCompleteRequest to complete the irp. The
    driver can return STATUS_PENDING if the irp cannot be completed
    immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension;
    ULONG                   sizeNeeded;
    PTHRM_INFO              info;
    PTHERMAL_INFORMATION    thermalInfo;
    PTHERMAL_INFORMATION    wmiThermalInfo;

    PAGED_CODE();

    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    if (GuidIndex == 0) {

        //
        // ThermalZone temperature query
        //
        info = (PTHRM_INFO) deviceExtension->Thermal.Info;
        thermalInfo = &info->Info;

        wmiThermalInfo = (PTHERMAL_INFORMATION)Buffer;
        sizeNeeded = sizeof(THERMAL_INFORMATION);

        if (BufferAvail >= sizeNeeded) {

            // NOTE - Synchronize with thread getting this data
            *InstanceLengthArray = sizeNeeded;
            RtlCopyMemory(wmiThermalInfo, thermalInfo, sizeNeeded);
            status = STATUS_SUCCESS;

        } else {

            status = STATUS_BUFFER_TOO_SMALL;

        }

    } else {

        status = STATUS_WMI_GUID_NOT_FOUND;
        sizeNeeded = 0;

    }

    status = WmiCompleteRequest(
        DeviceObject,
        Irp,
        status,
        sizeNeeded,
        IO_NO_INCREMENT
        );
    return status;
}

NTSTATUS
ACPIThermalQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned unmodified. If a value is returned then
        it is NOT freed.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    PAGED_CODE();

    if (AcpiRegistryPath.Buffer != NULL) {

        *RegistryPath = &AcpiRegistryPath;

    } else {

        *RegistryPath = NULL;

    }

    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *Pdo = DeviceObject;
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIThermalStartDevice (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called to start the thermal zone

Arguments:

    DeviceObject    - The device that is starting up
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PWMILIB_CONTEXT     wmilibContext;

    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): IRP_MN_START_DEVICE\n",
        Irp
        ) );

    status = ACPIInternalSetDeviceInterface (
        DeviceObject,
        (LPGUID) &GUID_DEVICE_THERMAL_ZONE
        );

    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPIThermalStartDevice -> SetDeviceInterface = 0x%08lx\n",
            status
            ) );
        goto ACPIThermalStartDeviceExit;

    }

    ACPIRegisterForDeviceNotifications(
        DeviceObject,
        (PDEVICE_NOTIFY_CALLBACK) ACPIThermalEvent,
        (PVOID) DeviceObject
        );

    //
    // Initialize device object for WMILIB
    //
    wmilibContext = ExAllocatePoolWithTag(
        PagedPool,
        sizeof(WMILIB_CONTEXT),
        ACPI_THERMAL_POOLTAG
        );
    if (wmilibContext == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIThermalStartDeviceExit;

    }

    RtlZeroMemory(wmilibContext, sizeof(WMILIB_CONTEXT));
    wmilibContext->GuidCount = ACPIThermalGuidCount;
    wmilibContext->GuidList = &ACPIThermalGuidList;
    wmilibContext->QueryWmiRegInfo = ACPIThermalQueryWmiRegInfo;
    wmilibContext->QueryWmiDataBlock = ACPIThermalQueryWmiDataBlock;
    deviceExtension->Thermal.WmilibContext = wmilibContext;

    //
    // Register for WMI events
    //
    status = IoWMIRegistrationControl(
        DeviceObject,
        WMIREG_ACTION_REGISTER
        );
    if (!NT_SUCCESS(status)) {

        deviceExtension->Thermal.WmilibContext = NULL;
        ExFreePool(wmilibContext);
        goto ACPIThermalStartDeviceExit;

    }

    //
    // Mark the device as started
    //
    deviceExtension->DeviceState = Started;

    //
    // Request that the device go to the D0 state
    //  Note: that we don't block on this call, since we assume that
    //        we can process thermal events asynchronously from being in
    //        the D0 state. However, there may be a future occasion where
    //        this is not true, so this makes the code more ready to handle
    //        that case
    //
    status = ACPIDeviceInternalDeviceRequest(
        deviceExtension,
        PowerDeviceD0,
        NULL,
        NULL,
        0
        );
    if (status == STATUS_PENDING) {

        status = STATUS_SUCCESS;

    }

    //
    // Start the thermal engine
    //
    ACPIThermalLoop( deviceExtension, THRM_TRIP_POINTS | THRM_MODE);

ACPIThermalStartDeviceExit:

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}

VOID
EXPORT
ACPIThermalTempatureRead (
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result  OPTIONAL,
    IN PVOID                Context
    )
/*++

Routine Description:

    This routine is called to read the temperature. It is used a callback to
    an interpreter call

Arguments:

    AcpiObject  - The object that was executed
    Status      - The status of the execution
    Result      - The result of the execution
    Context     - The device extension

Return Value:

    NTSTATUS

--*/
{
    PTHRM_INFO          Thrm;
    PDEVICE_EXTENSION   deviceExtension;

    deviceExtension = Context;

    if (NT_SUCCESS(Status)) {

        ASSERT (Result->dwDataType == OBJTYPE_INTDATA);
        Thrm = deviceExtension->Thermal.Info;
        Thrm->Info.CurrentTemperature = (ULONG)Result->uipDataValue;
        AMLIFreeDataBuffs (Result, 1);

        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            deviceExtension,
            KeQueryInterruptTime(),
            "Current Temperature is %d.%dK\n",
            (Thrm->Info.CurrentTemperature / 10 ),
            (Thrm->Info.CurrentTemperature % 10 )
            ) );

    }
    ACPIThermalLoop (deviceExtension, THRM_BUSY);
}

VOID
ACPIThermalWorker (
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN ULONG                Events
    )
/*++

Routine Description:

    Worker thread for thermal regions

Arguments:

    DeviceExtension - The device extension that we are manipulating
    Events          - What just happened

Return Value:

    None

--*/
{
    BOOLEAN             TurnOn;
    PTHRM_INFO          Thrm;
    NTSTATUS            Status;
    PNSOBJ              ThrmObj;
    PNSOBJ              ALobj;
    OBJDATA             ALPackage;
    OBJDATA             ALElement;
    PNSOBJ              ACDevObj;
    ULONG               Index;
    ULONG               Level;
    ULONG               PackageSize;
    ULONGLONG           currentTime;

    PAGED_CODE();

#if DBG
    currentTime = KeQueryInterruptTime();
#endif

    Thrm = DeviceExtension->Thermal.Info;
    ThrmObj = DeviceExtension->AcpiObject;

    //
    // Initialization code
    //
    if (Events & THRM_INITIALIZE) {

        ULONG   names[10] = {
                    PACKED_AL0,
                    PACKED_AL1,
                    PACKED_AL2,
                    PACKED_AL3,
                    PACKED_AL4,
                    PACKED_AL5,
                    PACKED_AL6,
                    PACKED_AL7,
                    PACKED_AL8,
                    PACKED_AL9,
                    };

        //
        // Start the system in PASSIVE mode
        //
        Thrm->Mode = 1;

        //
        // Fetch all of the objects associated with each cooling level
        //
        for (Level = 0; Level < 10; Level++) {

            //
            // Find this level's active list
            //
            ALobj = ACPIAmliGetNamedChild(
                ThrmObj,
                names[Level]
                );
            if (ALobj == NULL) {

                break;

            }

            //
            // Remember that we have this object
            //
            Thrm->ActiveList[Level] = ALobj;

        }

    }

    //
    // Do this before we update the trips points
    //
    if ( (Events & THRM_COOLING_LEVEL) ) {

        RtlZeroMemory (&ALPackage, sizeof(OBJDATA));
        RtlZeroMemory (&ALElement, sizeof(OBJDATA));

        for (Level=0; Level < 10; Level++) {

            //
            // Is there a cooling object?
            //
            ALobj = Thrm->ActiveList[Level];
            if (ALobj == NULL) {

                break;
            }

            //
            // Evalute the list to its package
            //
            Status = AMLIEvalNameSpaceObject(
                ALobj,
                &ALPackage,
                0,
                NULL
                );
            if (!NT_SUCCESS(Status)) {

                break;

            }

            //
            // Remember how large the package is
            //
            PackageSize = ((PPACKAGEOBJ) ALPackage.pbDataBuff)->dwcElements;

            //
            // Walk the names in the package
            //
            for (Index = 0; Index < PackageSize; Index += 1) {

                //
                // Grab the object name
                Status = AMLIEvalPkgDataElement(
                    &ALPackage,
                    Index,
                    &ALElement
                    );
                if (!NT_SUCCESS(Status)) {

                    break;

                }

                //
                // Determine if we are going to the device on or off
                //
                TurnOn = (Level >= Thrm->CoolingLevel);

                //
                // Tell the world
                //
#if DBG
                ACPIThermalPrint( (
                    ACPI_PRINT_THERMAL,
                    DeviceExtension,
                    currentTime,
                    "ACPIThermalWorker: Turn %s %s\n",
                    TurnOn ? "on " : "off",
                    ALElement.pbDataBuff
                    ) );
#endif

                //
                // Find this device of this name
                //
                Status = AMLIGetNameSpaceObject(
                    ALElement.pbDataBuff,
                    ThrmObj,
                    &ACDevObj,
                    0
                    );
                AMLIFreeDataBuffs (&ALElement, 1);
                if (!NT_SUCCESS(Status) ||  !ACDevObj->Context) {

                    break;

                }

                //
                // Turn it on/off
                //
                ACPIDeviceInternalDeviceRequest (
                    (PDEVICE_EXTENSION) ACDevObj->Context,
                    TurnOn ? PowerDeviceD0 : PowerDeviceD3,
                    ACPIThermalPowerCallback,
                    NULL,
                    0
                    );

            }
            AMLIFreeDataBuffs (&ALPackage, 1);

        }

    }

    //
    // If the trip points need to be re-freshed, go read them
    //
    if (Events & THRM_TRIP_POINTS) {

        ULONG   names[10] = {
                    PACKED_AC0,
                    PACKED_AC1,
                    PACKED_AC2,
                    PACKED_AC3,
                    PACKED_AC4,
                    PACKED_AC5,
                    PACKED_AC6,
                    PACKED_AC7,
                    PACKED_AC8,
                    PACKED_AC9,
                    };

        //
        // Get the thermal constants, passive & critical values
        //
        ACPIGetIntegerSync(
            DeviceExtension,
            PACKED_TC1,
            &Thrm->Info.ThermalConstant1,
            NULL
            );
#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            DeviceExtension,
            currentTime,
            "ACPIThermalWorker - ThermalConstant1 = %x\n",
            Thrm->Info.ThermalConstant1
            ) );
#endif
        ACPIGetIntegerSync(
            DeviceExtension,
            PACKED_TC2,
            &Thrm->Info.ThermalConstant2,
            NULL
            );
#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            DeviceExtension,
            currentTime,
            "ACPIThermalWorker - ThermalConstant2 = %x\n",
            Thrm->Info.ThermalConstant2
            ) );
#endif
        ACPIGetIntegerSync(
            DeviceExtension,
            PACKED_PSV,
            &Thrm->Info.PassiveTripPoint,
            NULL
            );
#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            DeviceExtension,
            currentTime,
            "ACPIThermalWorker - PassiveTripPoint = %d.%dK\n",
            (Thrm->Info.PassiveTripPoint / 10),
            (Thrm->Info.PassiveTripPoint % 10)
            ) );
#endif
        ACPIGetIntegerSync(
            DeviceExtension,
            PACKED_CRT,
            &Thrm->Info.CriticalTripPoint,
            NULL
            );
#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            DeviceExtension,
            currentTime,
            "ACPIThermalWorker - CriticalTripPoint = %d.%dK\n",
            (Thrm->Info.CriticalTripPoint / 10),
            (Thrm->Info.CriticalTripPoint % 10)
            ) );
#endif
        ACPIGetIntegerSync(
            DeviceExtension,
            PACKED_TSP,
            &Thrm->Info.SamplingPeriod,
            NULL
            );
#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            DeviceExtension,
            currentTime,
            "ACPIThermalWorker - SamplingPeriod = %x\n",
            Thrm->Info.SamplingPeriod
            ) );
#endif

        //
        // Get the active cooling limits
        //
        for (Level=0; Level < 10; Level++) {

            Status = ACPIGetIntegerSync(
                DeviceExtension,
                names[Level],
                &Thrm->Info.ActiveTripPoint[Level],
                NULL
                );
            if (!NT_SUCCESS(Status)) {

                break;

            }
#if DBG
            ACPIThermalPrint( (
                ACPI_PRINT_THERMAL,
                DeviceExtension,
                currentTime,
                "ACPIThermalWorker - Active Cooling Level %x = %d.%dK\n",
                Level,
                (Thrm->Info.ActiveTripPoint[Level] / 10),
                (Thrm->Info.ActiveTripPoint[Level] % 10)
                ) );
#endif

        }
        Thrm->Info.ActiveTripPointCount = (UCHAR) Level;

        //
        // Clean these variables for reuse
        //
        RtlZeroMemory (&ALPackage, sizeof(OBJDATA));
        RtlZeroMemory (&ALElement, sizeof(OBJDATA));

        //
        // Assume an affinity of 0
        //
        Thrm->Info.Processors = 0;

        //
        // Get the passive cooling affinity object
        //
        ALobj = ACPIAmliGetNamedChild(
            ThrmObj,
            PACKED_PSL
            );
        if (ALobj != NULL) {

            //
            // Evaluate the processor affinity object
            //
            Status = AMLIEvalNameSpaceObject(
                ALobj,
                &ALPackage,
                0,
                NULL
                );
            if (!NT_SUCCESS(Status)) {

                goto ACPIThermalWorkerExit;

            }

            //
            // Remember how large the package is
            //
            PackageSize = ((PPACKAGEOBJ) ALPackage.pbDataBuff)->dwcElements;

            //
            // Walk the elements in the package
            //
            for (Index = 0; Index < PackageSize ;Index++) {

                Status = AMLIEvalPkgDataElement(
                    &ALPackage,
                    Index,
                    &ALElement
                    );
                if (!NT_SUCCESS(Status)) {

                    break;

                }

                //
                // Find this device of this name
                //
                Status = AMLIGetNameSpaceObject(
                    ALElement.pbDataBuff,
                    NULL,
                    &ACDevObj,
                    0
                    );

                //
                // No longer need this information
                //
                AMLIFreeDataBuffs (&ALElement, 1);

                //
                // Did we find what we wanted?
                //
                if (!NT_SUCCESS(Status) ) {

                    break;

                }

                //
                // Get the correct affinity mask. We call another
                // function since that one requires a spinlock which
                // don't want to take in this worker function
                //
                ACPIThermalCalculateProcessorMask( ACDevObj, Thrm );

            }

            //
            // We are done with the package
            //
            AMLIFreeDataBuffs (&ALPackage, 1);

        }

    }

ACPIThermalWorkerExit:

    //
    // done, check for next work
    //
    ACPIThermalLoop (DeviceExtension, THRM_TEMP | THRM_BUSY);
}


NTSTATUS
ACPIThermalWmi(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION      irpSp;
    PWMILIB_CONTEXT         wmilibContext;
    SYSCTL_IRP_DISPOSITION  disposition;

    wmilibContext = deviceExtension->Thermal.WmilibContext;
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    status = WmiSystemControl(
        wmilibContext,
        DeviceObject,
        Irp,
        &disposition
        );

    switch (disposition) {

        case IrpProcessed:
            break;
        case IrpNotCompleted:
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        case IrpNotWmi:
        case IrpForward:
        default:
            status = ACPIDispatchForwardIrp(DeviceObject, Irp);
            break;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\thermal.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    thermal.h

Abstract:

    This module implements all the callbacks that are NT specific from
    the AML Interperter

Environment

    Kernel mode only

Revision History:

    04-Jun-97 Initial Revision

--*/

#ifndef _THERMAL_H_
#define _THERMAL_H_

    //
    // Structures
    //
    typedef struct {
        THERMAL_INFORMATION     Info;
        ULONG                   CoolingLevel;
        ULONG                   Mode;
        PVOID                   ActiveList[10];
        PNSOBJ                  TempMethod;
        OBJDATA                 Temp;
    } THRM_INFO, *PTHRM_INFO;

    extern  WMIGUIDREGINFO  ACPIThermalGuidList;
    extern  KSPIN_LOCK      AcpiThermalLock;
    extern  LIST_ENTRY      AcpiThermalList;

    #define ACPIThermalGuidCount (sizeof(ACPIThermalGuidList) / sizeof(WMIGUIDREGINFO))

    //
    // Defines
    //
    #define THRM_COOLING_LEVEL          0x00000001
    #define THRM_TEMP                   0x00000002
    #define THRM_TRIP_POINTS            0x00000004
    #define THRM_MODE                   0x00000008
    #define THRM_INITIALIZE             0x00000010

    #define THRM_WAIT_FOR_NOTIFY        0x20000000
    #define THRM_BUSY                   0x40000000
    #define THRM_IN_SERVICE_LOOP        0x80000000

    //
    // Prototypes
    //
    VOID
    ACPIThermalCalculateProcessorMask(
        IN PNSOBJ           ProcessorObject,
        IN PTHRM_INFO       Thrm
        );

    VOID
    ACPIThermalCancelRequest (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );

    VOID
    EXPORT
    ACPIThermalComplete(
        IN PNSOBJ               AcpiObject,
        IN NTSTATUS             Status,
        IN POBJDATA             Result  OPTIONAL,
        IN PVOID                DevExt
        );

    BOOLEAN
    ACPIThermalCompletePendingIrps(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PTHRM_INFO          Thermal
        );

    NTSTATUS
    ACPIThermalDeviceControl(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID
    ACPIThermalEvent(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  ULONG           EventData
        );

    NTSTATUS
    ACPIThermalFanStartDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID
    ACPIThermalLoop(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  ULONG               Clear
        );

    VOID
    ACPIThermalPowerCallback(
        IN PDEVICE_EXTENSION    DeviceExtenion,
        IN PVOID                Context,
        IN NTSTATUS             Status
        );

    NTSTATUS
    ACPIThermalQueryWmiDataBlock(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp,
        IN  ULONG           GuidIndex,
        IN  ULONG           InstanceIndex,
        IN  ULONG           InstanceCount,
        IN  OUT PULONG      InstanceLengthArray,
        IN  ULONG           BufferAvail,
        OUT PUCHAR          Buffer
        );

    NTSTATUS
    ACPIThermalQueryWmiRegInfo(
        IN  PDEVICE_OBJECT  DeviceObject,
        OUT ULONG           *RegFlags,
        OUT PUNICODE_STRING InstanceName,
        OUT PUNICODE_STRING *RegistryPath,
        OUT PUNICODE_STRING MofResourceName,
        OUT PDEVICE_OBJECT  *Pdo
        );

    NTSTATUS
    ACPIThermalStartDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID
    EXPORT
    ACPIThermalTempatureRead (
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    Result  OPTIONAL,
        IN  PVOID       DevExt
        );

    VOID
    ACPIThermalWorker (
        IN  PDEVICE_EXTENSION   DevExt,
        IN  ULONG               Events
        );

    NTSTATUS
    ACPIThermalWmi(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\wake.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    wake.h

Abstract:

    Handles wake code for the entire ACPI subsystem

Author:

    splante (splante)

Environment:

    Kernel mode only.

Revision History:

    06-18-97:   Initial Revision
    11-24-97:   Rewrite

--*/

#ifndef _WAKE_H_
#define _WAKE_H_

    //
    // This structure is used only within this module to ensure that we run
    // the _PSW methods in a synchronized and well behabed manner
    //
    typedef struct _ACPI_WAKE_PSW_CONTEXT {
        LIST_ENTRY          ListEntry;
        PDEVICE_EXTENSION   DeviceExtension;
        BOOLEAN             Enable;
        ULONG               Count;
        PFNACB              CallBack;
        PVOID               Context;
    } ACPI_WAKE_PSW_CONTEXT, *PACPI_WAKE_PSW_CONTEXT;

    //
    // This structure is used when we wake up from hibernate and we need to
    // re-enable all of the outstanding _PSWs
    //
    typedef struct _ACPI_WAKE_RESTORE_PSW_CONTEXT {

        PACPI_POWER_CALLBACK    CallBack;
        PVOID                   CallBackContext;

    } ACPI_WAKE_RESTORE_PSW_CONTEXT, *PACPI_WAKE_RESTORE_PSW_CONTEXT;

    extern  NPAGED_LOOKASIDE_LIST   PswContextLookAsideList;
    extern  BOOLEAN                 PciPmeInterfaceInstantiated;

    VOID
    ACPIWakeCompleteRequestQueue(
        IN  PLIST_ENTRY         RequestList,
        IN  NTSTATUS            Status
        );

    NTSTATUS
    ACPIWakeDisableAsync(
        IN  PDEVICE_EXTENSION   DeviceExtenion,
        IN  PLIST_ENTRY         RequestList,
        IN  PFNACB              CallBack,
        IN  PVOID               Context
        );

    NTSTATUS
    ACPIWakeEmptyRequestQueue(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIWakeEnableDisableAsync(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  BOOLEAN             Enable,
        IN  PFNACB              CallBack,
        IN  PVOID               Context
        );

    VOID
    EXPORT
    ACPIWakeEnableDisableAsyncCallBack(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            ObjData,
        IN  PVOID               Context
        );

    VOID
    ACPIWakeEnableDisablePciDevice(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  BOOLEAN             Enable
        );

    NTSTATUS
    ACPIWakeEnableDisableSync(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  BOOLEAN             Enable
        );

    VOID
    EXPORT
    ACPIWakeEnableDisableSyncCallBack(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            ObjData,
        IN  PVOID               Context
        );

    VOID
    ACPIWakeEnableWakeEvents(
        VOID
        );

    NTSTATUS
    ACPIWakeInitializePciDevice(
        IN  PDEVICE_OBJECT      DeviceObject
        );

    NTSTATUS
    ACPIWakeInitializePmeRouting(
        IN  PDEVICE_OBJECT      DeviceObject
        );

    VOID
    ACPIWakeRemoveDevicesAndUpdate(
        IN  PDEVICE_EXTENSION   TargetExtension,
        IN  PLIST_ENTRY         ListHead
        );

    NTSTATUS
    ACPIWakeRestoreEnables(
        IN  PACPI_BUILD_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext
        );

    VOID
    ACPIWakeRestoreEnablesCompletion(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PVOID                   Context,
        IN  NTSTATUS                Status
        );

    NTSTATUS
    ACPIWakeWaitIrp(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PIRP                Irp
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\wake.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    wake.c

Abstract:

    Handles wake code for the entire ACPI subsystem

Author:

    splante (splante)

Environment:

    Kernel mode only.

Revision History:

    06-18-97:   Initial Revision
    11-24-97:   Rewrite

--*/

#include "pch.h"
#pragma hdrstop
#define INITGUID
#include <initguid.h>
#include <pciintrf.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIWakeEnableDisableSync)
#endif

//
// This request is used by the synchronous mechanism when it calls the
// asynchronous one
//
typedef struct _ACPI_WAKE_PSW_SYNC_CONTEXT {
    KEVENT      Event;
    NTSTATUS    Status;
} ACPI_WAKE_PSW_SYNC_CONTEXT, *PACPI_WAKE_PSW_SYNC_CONTEXT;

//
// This is a lookaside list of contexts
//
NPAGED_LOOKASIDE_LIST   PswContextLookAsideList;

//
// Pointer to the PCI PME interface, which we will need (maybe)
//
PPCI_PME_INTERFACE      PciPmeInterface;

//
// Have we loaded the PCI PME Interface?
//
BOOLEAN                 PciPmeInterfaceInstantiated;

//
// We need to access this piece of data here
//
extern PACPIInformation AcpiInformation;

VOID
ACPIWakeCompleteRequestQueue(
    IN  PLIST_ENTRY         RequestList,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This routine takes a LIST_ENTRY of requests to be completed and completes
    all of them. This is to minimize code duplication.

Arguments:

    RequestList - List Entry to process
    Status      - Status to complete the requests with

Return Value:

    None

--*/
{
    PLIST_ENTRY         listEntry;
    PACPI_POWER_REQUEST powerRequest;

    //
    // walk the list
    //
    listEntry = RequestList->Flink;
    while (listEntry != RequestList) {

        //
        // Crack the request
        //
        powerRequest = CONTAINING_RECORD(
            listEntry,
            ACPI_POWER_REQUEST,
            ListEntry
            );
        listEntry = listEntry->Flink;

        //
        // Complete this power request
        //
        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            powerRequest->DeviceExtension,
            "ACPIWakeCompleteRequestQueue - Completing 0x%08lx - %08lx\n",
            powerRequest,
            Status
            ) );
        powerRequest->Status = Status;
        ACPIDeviceIrpWaitWakeRequestComplete( powerRequest );

    }

}

NTSTATUS
ACPIWakeDisableAsync(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PLIST_ENTRY         RequestList,
    IN  PFNACB              CallBack,
    IN  PVOID               Context
    )
/*++

Routine Description:

    This routine decrements the number of outstanding wake events on the
    supplied DeviceExtension by the number of items in the request list.
    If the reference goes to 0, then we run _PSW(Off) to disable wake support
    on the device

Arguments:

    DeviceExtension - Device for which we to deference the wake count
    RequestList     - The list of requests, for which the ref count will
                      be decreased
    CallBack        - Function to call when we are done
    Context         - Argument to the function

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN                 runPsw          = FALSE;
    KIRQL                   oldIrql;
    NTSTATUS                status          = STATUS_SUCCESS;
    OBJDATA                 pswData;
    PACPI_WAKE_PSW_CONTEXT  pswContext;
    PLIST_ENTRY             listEntry       = RequestList->Flink;
    PNSOBJ                  pswObject       = NULL;
    ULONG                   count           = 0;

    //
    // Walk the list, counting the number of items within it
    //
    while (listEntry != RequestList) {

        count++;
        listEntry = listEntry->Flink;

    }

    //
    // Grab the spinlock
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // Let the world know what happened
    //
    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        DeviceExtension,
        "ACPIWakeDisableAsync - ReferenceCount: %lx - %lx = %lx\n",
        DeviceExtension->PowerInfo.WakeSupportCount,
        count,
        (DeviceExtension->PowerInfo.WakeSupportCount - count)
        ) );

    //
    // Update the number of references on the device
    //
    ASSERT( DeviceExtension->PowerInfo.WakeSupportCount <= count );
    DeviceExtension->PowerInfo.WakeSupportCount -= count;

    //
    // Grab the pswObject
    //
    pswObject = DeviceExtension->PowerInfo.PowerObject[PowerDeviceUnspecified];
    if (pswObject == NULL) {

        goto ACPIWakeDisableAsyncExit;

    }

    //
    // Are there no references left on the device?
    //
    if (DeviceExtension->PowerInfo.WakeSupportCount != 0) {

        //
        // If we own the PME pin for this device, then make sure that
        // we clear the status pin and keep the PME signal enabled
        //
        if (DeviceExtension->Flags & DEV_PROP_HAS_PME ) {

            ACPIWakeEnableDisablePciDevice(
                DeviceExtension,
                TRUE
                );

        }
        goto ACPIWakeDisableAsyncExit;

    }

    //
    // Allocate the _PSW context that we need to signify that there is
    // a pending _PSW on this device
    //
    pswContext = ExAllocateFromNPagedLookasideList(
        &PswContextLookAsideList
        );
    if (pswContext == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIWakeDisableAsyncExit;

    }

    //
    // Initialize the context
    //
    pswContext->Enable = FALSE;
    pswContext->CallBack = CallBack;
    pswContext->Context = Context;
    pswContext->DeviceExtension = DeviceExtension;
    pswContext->Count = count;

    //
    // Check to see if we are simply going to queue the context up, or
    // call the interpreter
    //
    if (IsListEmpty( &(DeviceExtension->PowerInfo.WakeSupportList) ) ) {

        runPsw = TRUE;

    }

    //
    // List is non-empty, so we just queue up the context
    //
    InsertTailList(
        &(DeviceExtension->PowerInfo.WakeSupportList),
        &(pswContext->ListEntry)
        );

    //
    // Release the lock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Should we run the method?
    //
    if (runPsw) {

        //
        // If we own the PCI PME pin for this device, the make sure to clear the
        // status and disable it --- we enable the PME pin after we have
        // turned on the _PSW, and we disable the PME pin before we turn off
        // the _PSW
        //
        if ( (DeviceExtension->Flags & DEV_PROP_HAS_PME)) {

            ACPIWakeEnableDisablePciDevice(
                DeviceExtension,
                FALSE
                );

        }

        //
        // Initialize the arguments
        //
        RtlZeroMemory( &pswData, sizeof(OBJDATA) );
        pswData.dwDataType = OBJTYPE_INTDATA;
        pswData.uipDataValue = 0;

        //
        // Run the control method
        //
        status = AMLIAsyncEvalObject(
            pswObject,
            NULL,
            1,
            &pswData,
            ACPIWakeEnableDisableAsyncCallBack,
            pswContext
            );

        //
        // What Happened
        //
        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            DeviceExtension,
            "ACPIWakeDisableAsync = 0x%08lx (P)\n",
            status
            ) );


        if (status != STATUS_PENDING) {

            ACPIWakeEnableDisableAsyncCallBack(
                pswObject,
                status,
                NULL,
                pswContext
                );

        }
        return STATUS_PENDING;

    } else {

        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            DeviceExtension,
            "ACPIWakeEnableDisableAsync = 0x%08lx (Q)\n",
            STATUS_PENDING
            ) );

        //
        // we queued the request up, so we must return pending
        //
        return STATUS_PENDING;

    }

ACPIWakeDisableAsyncExit:

    //
    // Release the lock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // What happened
    //
    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        DeviceExtension,
        "ACPIWakeDisableAsync = 0x%08lx\n",
        status
        ) );

    //
    // Call the specified callback ourselves
    //
    (*CallBack)(
        pswObject,
        status,
        NULL,
        Context
        );
    return STATUS_PENDING;


}

NTSTATUS
ACPIWakeEmptyRequestQueue(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine looks at the current list of Wake Request irps and
    completes the ones that are waiting on the specified device

    Note: this code assumes that if we clear the irps out but we don't
    run _PSW(O), that nothing bad will happen if that GPE fires

Arguments:

    DeviceExtension - Device for which we want no wake requests

Return Value:

    None

--*/
{
    KIRQL               oldIrql;
    LIST_ENTRY          powerList;

    //
    // We will store the list of matching requests onto this list, so we
    // must initialize it
    //
    InitializeListHead( &powerList );

    //
    // We need to hold both the Cancel and the Power lock while we remove
    // things from the PowerQueue list
    //
    IoAcquireCancelSpinLock( &oldIrql );
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );
    ACPIWakeRemoveDevicesAndUpdate( DeviceExtension, &powerList );
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
    IoReleaseCancelSpinLock( oldIrql );

    //
    // Complete the requests
    //
    ACPIWakeCompleteRequestQueue( &powerList, STATUS_NO_SUCH_DEVICE );

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIWakeEnableDisableAsync(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  BOOLEAN             Enable,
    IN  PFNACB              CallBack,
    IN  PVOID               Context
    )
/*++

Routine Description:

    Given a Device Extension, updates the count of outstanding PSW on the
    device. If there is a 0-1 transition, then we must run _PSW(1). If there
    is a 1-0 transition, then we must run _PSW(0)

    NB: The CallBack will always be invoked

Arguments:


    DeviceExtension - Object to look at
    Enable          - Increment or Decrement
    CallBack        - Function to run after running _PSW()
    Context         - Argument to pass to _PSW

Return Value:

    Status

--*/
{
    BOOLEAN                 runPsw      = FALSE;
    KIRQL                   oldIrql;
    OBJDATA                 pswData;
    NTSTATUS                status      = STATUS_SUCCESS;
    PACPI_WAKE_PSW_CONTEXT  pswContext;
    PNSOBJ                  pswObject   = NULL;

    //
    // Acquire the Spinlock
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // Update the number of references on the device
    //
    if (Enable) {

        DeviceExtension->PowerInfo.WakeSupportCount++;

        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            DeviceExtension,
            "ACPIWakeEnableDisableAsync - Count: %d (+)\n",
            DeviceExtension->PowerInfo.WakeSupportCount
            ) );

        //
        // Did we transition to one wake?
        //
        if (DeviceExtension->PowerInfo.WakeSupportCount != 1) {

            //
            // If we own the PME pin for this device, then make sure that
            // we clear the status pin and keep the PME signal enabled
            //
            if (DeviceExtension->Flags & DEV_PROP_HAS_PME ) {

                ACPIWakeEnableDisablePciDevice(
                    DeviceExtension,
                    TRUE
                    );

            }
            goto ACPIWakeEnableDisableAsyncExit;

        }

    } else {

        ASSERT( DeviceExtension->PowerInfo.WakeSupportCount );
        DeviceExtension->PowerInfo.WakeSupportCount--;

        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            DeviceExtension,
            "ACPIWakeEnableDisableAsync - Count: %d (-)\n",
            DeviceExtension->PowerInfo.WakeSupportCount
            ) );

        //
        // Did we transition to zero wake?
        //
        if (DeviceExtension->PowerInfo.WakeSupportCount != 0) {

            //
            // If we own the PME pin for this device, then make sure that
            // we clear the status pin and keep the PME signal enabled
            //
            if (DeviceExtension->Flags & DEV_PROP_HAS_PME ) {

                ACPIWakeEnableDisablePciDevice(
                    DeviceExtension,
                    TRUE
                    );

            }
            goto ACPIWakeEnableDisableAsyncExit;

        }

    }

    //
    // Grab the pswObject
    //
    pswObject = DeviceExtension->PowerInfo.PowerObject[PowerDeviceUnspecified];
    if (pswObject == NULL) {

        //
        // If we got here, that means that there isn't a _PSW to be run and
        // that we should make sure that if we own the PME pin, that we should
        // set it.
        //
        if (DeviceExtension->Flags & DEV_PROP_HAS_PME) {

            ACPIWakeEnableDisablePciDevice(
                DeviceExtension,
                TRUE
                );

        }
        goto ACPIWakeEnableDisableAsyncExit;

    }

    //
    // Allocate the _PSW context that we need to signify that there is
    // a pending _PSW on this device
    //
    pswContext = ExAllocateFromNPagedLookasideList(
        &PswContextLookAsideList
        );
    if (pswContext == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIWakeEnableDisableAsyncExit;

    }

    //
    // Initialize the context
    //
    pswContext->Enable = Enable;
    pswContext->CallBack = CallBack;
    pswContext->Context = Context;
    pswContext->DeviceExtension = DeviceExtension;
    pswContext->Count = 1;

    //
    // Check to see if we are simply going to queue the context up, or
    // call the interpreter
    //
    if (IsListEmpty( &(DeviceExtension->PowerInfo.WakeSupportList) ) ) {

        runPsw = TRUE;

    }

    //
    // List is non-empty, so we just queue up the context
    //
    InsertTailList(
        &(DeviceExtension->PowerInfo.WakeSupportList),
        &(pswContext->ListEntry)
        );

    //
    // Release the lock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Should we run the method?
    //
    if (runPsw) {

        //
        // If we own the PCI PME pin for this device, the make sure to clear the
        // status and disable it --- we enable the PME pin after we have
        // turned on the _PSW, and we disable the PME pin before we turn off
        // the _PSW
        //
        if ( (DeviceExtension->Flags & DEV_PROP_HAS_PME) &&
             pswContext->Enable == FALSE) {

            ACPIWakeEnableDisablePciDevice(
                DeviceExtension,
                FALSE
                );

        }

        //
        // Initialize the arguments
        //
        RtlZeroMemory( &pswData, sizeof(OBJDATA) );
        pswData.dwDataType = OBJTYPE_INTDATA;
        pswData.uipDataValue = (Enable ? 1 : 0);

        //
        // Run the control method
        //
        status = AMLIAsyncEvalObject(
            pswObject,
            NULL,
            1,
            &pswData,
            ACPIWakeEnableDisableAsyncCallBack,
            pswContext
            );

        //
        // What Happened
        //
        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            DeviceExtension,
            "ACPIWakeEnableDisableAsync = 0x%08lx (P)\n",
            status
            ) );

        if (status != STATUS_PENDING) {

            ACPIWakeEnableDisableAsyncCallBack(
                pswObject,
                status,
                NULL,
                pswContext
                );

        }
        return STATUS_PENDING;

    } else {

        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            DeviceExtension,
            "ACPIWakeEnableDisableAsync = 0x%08lx (Q)\n",
            STATUS_PENDING
            ) );

        //
        // we queued the request up, so we must return pending
        //
        return STATUS_PENDING;

    }

ACPIWakeEnableDisableAsyncExit:

    //
    // Release the lock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // What happened
    //
    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        DeviceExtension,
        "ACPIWakeEnableDisableAsync = 0x%08lx\n",
        status
        ) );

    //
    // Call the specified callback ourselves
    //
    (*CallBack)(
        pswObject,
        status,
        NULL,
        Context
        );
    return STATUS_PENDING;

}

VOID
EXPORT
ACPIWakeEnableDisableAsyncCallBack(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called after a _PSW method has been run on a device.

    This routine is responsible for seeing if there are any more delayed
    _PSW requests on the same device, and if so, run them.

Arguments:

    AcpiObject  - The method object that was run
    Status      - The result of the eval
    ObjData     - Not used
    Context     - PACPI_WAKE_PSW_CONTEXT

Return value:

    VOID

--*/
{
    BOOLEAN                 runPsw          = FALSE;
    KIRQL                   oldIrql;
    PACPI_WAKE_PSW_CONTEXT  pswContext      = (PACPI_WAKE_PSW_CONTEXT) Context;
    PACPI_WAKE_PSW_CONTEXT  nextContext;
    PDEVICE_EXTENSION       deviceExtension = pswContext->DeviceExtension;

    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        deviceExtension,
        "ACPIWakeEnableDisableAsyncCallBack = %08lx (C)\n",
        Status
        ) );

    //
    // Acquire the spinlock
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // Remove the specified entry from the list
    //
    RemoveEntryList( &(pswContext->ListEntry) );

    //
    // If we failed the request, then we don't really know the status of the
    // _PSW on the device. Lets assume that it doesn't change and undo
    // whatever change we did to get here
    //
    if (!NT_SUCCESS(Status)) {

        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            deviceExtension,
            "ACPIWakeEnableDisableAsyncCallBack - RefCount: %lx %s %lx = %lx\n",
            deviceExtension->PowerInfo.WakeSupportCount,
            (pswContext->Enable ? "-" : "+"),
            pswContext->Count,
            (pswContext->Enable ? deviceExtension->PowerInfo.WakeSupportCount -
             pswContext->Count : deviceExtension->PowerInfo.WakeSupportCount +
             pswContext->Count)
            ) );


        if (pswContext->Enable) {

            deviceExtension->PowerInfo.WakeSupportCount -= pswContext->Count;

        } else {

            deviceExtension->PowerInfo.WakeSupportCount += pswContext->Count;

        }

    }

    //
    // If we own the PCI PME pin for this device, the make sure to clear the
    // status and either enable it --- we enable the PME pin after we have
    // turned on the _PSW, and we disable the PME pin before we turn off
    // the _PSW
    //
    if ( (deviceExtension->Flags & DEV_PROP_HAS_PME) &&
         pswContext->Enable == TRUE) {

        ACPIWakeEnableDisablePciDevice(
            deviceExtension,
            pswContext->Enable
            );

    }

    //
    // Are the any items on the list?
    //
    if (!IsListEmpty( &(deviceExtension->PowerInfo.WakeSupportList) ) ) {

        runPsw = TRUE;
        nextContext = CONTAINING_RECORD(
            deviceExtension->PowerInfo.WakeSupportList.Flink,
            ACPI_WAKE_PSW_CONTEXT,
            ListEntry
            );

    }

    //
    // We can release the lock now
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Call the callback on the completed item
    //
    (*pswContext->CallBack)(
        AcpiObject,
        Status,
        ObjData,
        (pswContext->Context)
        );

    //
    // Free the completed context
    //
    ExFreeToNPagedLookasideList(
        &PswContextLookAsideList,
        pswContext
        );

    //
    // Do we have to run a method?
    //
    if (runPsw) {

        NTSTATUS    status;
        OBJDATA     pswData;

        RtlZeroMemory( &pswData, sizeof(OBJDATA) );
        pswData.dwDataType = OBJTYPE_INTDATA;
        pswData.uipDataValue = (nextContext->Enable ? 1 : 0);

        //
        // If we own the PCI PME pin for this device, the make sure to clear the
        // status and disable it --- we enable the PME pin after we have
        // turned on the _PSW, and we disable the PME pin before we turn off
        // the _PSW
        //
        if ( (deviceExtension->Flags & DEV_PROP_HAS_PME) &&
             nextContext->Enable == FALSE) {

            ACPIWakeEnableDisablePciDevice(
                deviceExtension,
                FALSE
                );

        }

        //
        // Call the interpreter
        //
        status = AMLIAsyncEvalObject(
            AcpiObject,
            NULL,
            1,
            &pswData,
            ACPIWakeEnableDisableAsyncCallBack,
            nextContext
            );

        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            nextContext->DeviceExtension,
            "ACPIWakeEnableDisableAsyncCallBack = 0x%08lx (M)\n",
            status
            ) );

        if (status != STATUS_PENDING) {

            //
            // Ugh - Recursive
            //
            ACPIWakeEnableDisableAsyncCallBack(
                AcpiObject,
                status,
                NULL,
                nextContext
                );

        }

    }

}

VOID
ACPIWakeEnableDisablePciDevice(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  BOOLEAN             Enable
    )
/*++

Routine Description:

    This routine is what is actually called to enable or disable the
    PCI PME pin for a device

    N.B. The AcpiPowerLock must be owned

Arguments:

    DeviceExtension - The device extension that is a filter on top of the
                      pdo from the PCI device
    Enable          - True to enable PME, false otherwise

Return Value:

    None

--*/
{
    KIRQL   oldIrql;


    //
    // Is there an interface present?
    //
    if (!PciPmeInterfaceInstantiated) {

        return;

    }

    //
    // Prevent the device from going away while we make this call
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Check to see if there is a device object...
    //
    if (!DeviceExtension->PhysicalDeviceObject) {

        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
        return;

    }

    PciPmeInterface->UpdateEnable(
        DeviceExtension->PhysicalDeviceObject,
        Enable
        );

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
}

NTSTATUS
ACPIWakeEnableDisableSync(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  BOOLEAN             Enable
    )
/*++

Routine Description:

    Given a DeviceExtension, enables or disables the device wake support
    from the device

    NB: This routine can only be called at passive level

Arguments:

    DeviceExtension - The device we care about
    Enable          - True if we are to enable, false otherwise

Return Value:

    NTSTATUS

--*/
{
    ACPI_WAKE_PSW_SYNC_CONTEXT  syncContext;
    NTSTATUS                    status;

    PAGED_CODE();

    ASSERT( DeviceExtension != NULL &&
            DeviceExtension->Signature == ACPI_SIGNATURE );

    //
    // Initialize the event
    //
    KeInitializeEvent( &syncContext.Event, NotificationEvent, FALSE );

    //
    // Call the async procedure
    //
    status = ACPIWakeEnableDisableAsync(
        DeviceExtension,
        Enable,
        ACPIWakeEnableDisableSyncCallBack,
        &syncContext
        );
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &syncContext.Event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = syncContext.Status;

    }

    //
    // Done
    //
    return status;
}

VOID
EXPORT
ACPIWakeEnableDisableSyncCallBack(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    The Async part of the EnableDisable request has been completed

Arguments:

    AcpiObject  - The object that was executed
    Status      - The result of the operation
    ObjData     - Not used
    Context     - ACPI_WAKE_PSW_SYNC_CONTEXT

Return Value:

    VOID

--*/
{
    PACPI_WAKE_PSW_SYNC_CONTEXT pswContext = (PACPI_WAKE_PSW_SYNC_CONTEXT) Context;

    //
    // Set the real status
    //
    pswContext->Status = Status;

    //
    // Set the event
    //
    KeSetEvent( &(pswContext->Event), IO_NO_INCREMENT, FALSE );
}

VOID
ACPIWakeEnableWakeEvents(
    VOID
    )
/*++

Routine Description:

    This routine is called just before the system is put to sleep.

    The purpose of this routine is re-allow all wake and run-time events
    in the GpeCurEnable to be correctly set. After the machine wakes up,
    the machine will check that register to see if any events triggered the
    wakeup

    NB: This routine is called with interrupts off.

Arguments:

    None

Return Value:

    None

--*/
{
    KIRQL   oldIrql;
    ULONG   gpeRegister = 0;

    //
    // This function is called when interrupts are disabled, so in theory,
    // all the following should be safe. However, better safe than sorry.
    //
    KeAcquireSpinLock( &GpeTableLock, &oldIrql );

    //
    // Remember that on the way back up, we will entering the S0 state
    //
    AcpiPowerLeavingS0 = FALSE;

    //
    // Update all the registers
    //
    for (gpeRegister = 0; gpeRegister < AcpiInformation->GpeSize; gpeRegister++) {

        //
        // In any case, make sure that our current enable mask includes all
        // the wake registers, but doesn't include any of the pending
        // events
        //
        GpeCurEnable[gpeRegister] |= (GpeWakeEnable[gpeRegister] &
            ~GpePending[gpeRegister]);

    }

    //
    // Set the wake events only
    //
    ACPIGpeEnableWakeEvents();

    //
    // Done with the table lock
    //
    KeReleaseSpinLock( &GpeTableLock, oldIrql );
}

NTSTATUS
ACPIWakeInitializePciDevice(
    IN  PDEVICE_OBJECT      DeviceObject
    )
/*++

Routine Description:

    This routine is called when a filter is started to determine if the PCI
    device is capable of generating a PME

Arguments:

    DeviceObject    - The device object to initialize

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             pmeSupported;
    BOOLEAN             pmeStatus;
    BOOLEAN             pmeEnable;
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    //
    // We don't have to worry if the device doesn't support wake methods
    // directly
    //
    if (!(deviceExtension->Flags & DEV_CAP_WAKE) ) {

        return STATUS_SUCCESS;

    }

    //
    // Need to grab the power lock to do the following
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // Do we have an interface to call?
    //
    if (PciPmeInterfaceInstantiated == FALSE) {

        goto ACPIWakeInitializePciDeviceExit;

    }

    //
    // Get the status of PME for this device
    //
    PciPmeInterface->GetPmeInformation(
        deviceExtension->PhysicalDeviceObject,
        &pmeSupported,
        &pmeStatus,
        &pmeEnable
        );

    //
    // if the device supports pme, then we own it...
    //
    if (pmeSupported == TRUE) {

        //
        // We own the PME pin for this device
        //
        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            (DEV_PROP_HAS_PME),
            FALSE
            );

        //
        // Check to see if we should disable PME or disable the PME status
        //
        if (pmeEnable) {

            //
            // Calling this also clears the PME status pin
            //
            PciPmeInterface->UpdateEnable(
                deviceExtension->PhysicalDeviceObject,
                FALSE
                );

        } else if (pmeStatus) {

            //
            // Clear the PME status
            //
            PciPmeInterface->ClearPmeStatus(
                deviceExtension->PhysicalDeviceObject
                );

        }

    }

ACPIWakeInitializePciDeviceExit:
    //
    // Done with lock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIWakeInitializePmeRouting(
    IN  PDEVICE_OBJECT      DeviceObject
    )
/*++

Routine Description:

    This routine will ask the PCI driver for its PME interface

Arguments:

    DeviceObject    - The ACPI PDO for a PCI root bus

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    NTSTATUS            status;
    IO_STACK_LOCATION   irpSp;
    PPCI_PME_INTERFACE  interface;
    PULONG              dummy;

    //
    // Allocate some memory for the interface
    //
    interface = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(PCI_PME_INTERFACE),
        ACPI_ARBITER_POOLTAG
        );
    if (interface == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Initialize the stack location
    //
    RtlZeroMemory( &irpSp, sizeof(IO_STACK_LOCATION) );
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCI_PME_INTERFACE;
    irpSp.Parameters.QueryInterface.Version = PCI_PME_INTRF_STANDARD_VER;
    irpSp.Parameters.QueryInterface.Size = sizeof (PCI_PME_INTERFACE);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) interface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Send the request along
    //
    status = ACPIInternalSendSynchronousIrp(
        DeviceObject,
        &irpSp,
        &dummy
        );
    if (!NT_SUCCESS(status)) {

        PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            " - ACPIWakeInitializePmeRouting = %08lx\n",
            status
            ) );

        //
        // Free the memory and return
        //
        ExFreePool( interface );
        return status;

    }

    //
    // Do this under spinlock protection
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );
    if (PciPmeInterfaceInstantiated == FALSE) {

        //
        // Keep a global pointer to the interface
        //
        PciPmeInterfaceInstantiated = TRUE;
        PciPmeInterface = interface;

    } else {

        //
        // Someone else got here before us, so we need to make sure
        // that we free the extra memory
        //
        ExFreePool (interface );

    }
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Done
    //
    return status;
}

VOID
ACPIWakeRemoveDevicesAndUpdate(
    IN  PDEVICE_EXTENSION   TargetExtension,
    OUT PLIST_ENTRY         ListHead
    )
/*++

Routine Description:

    This routine finds the all of the WaitWake requests associated with
    TargetDevice and return them on ListHead. This is done in a 'safe' way

    NB: Caller must hold the AcpiPowerLock and Cancel Lock!

Arguments:

    TargetExtension - The target extension that we are looking for
    ListHead        - Where to store the list of matched devices

Return Value:

    NONE

--*/
{
    PACPI_POWER_REQUEST powerRequest;
    PDEVICE_EXTENSION   deviceExtension;
    PLIST_ENTRY         listEntry;
    SYSTEM_POWER_STATE  sleepState;
    ULONG               gpeRegister;
    ULONG               gpeMask;
    ULONG               byteIndex;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // We need to synchronize with the ProcessGPE code because we are going
    // to touch one of the GPE Masks
    //
    KeAcquireSpinLockAtDpcLevel( &GpeTableLock );

    //
    // The first step is to disable all the wake vectors
    //
    for (gpeRegister = 0; gpeRegister < AcpiInformation->GpeSize; gpeRegister++) {

        //
        // Remove the wake vectors from the real-time vectors.
        // Note that since we are going to be writting the GPE Enable vector
        // later on in the process, it seems pointless to actually write them
        // now as well
        //
        GpeCurEnable[gpeRegister] &= (GpeSpecialHandler[gpeRegister] |
            ~(GpeWakeEnable[gpeRegister] | GpeWakeHandler[gpeRegister]));

    }

    //
    // Next step is to reset the wake mask
    //
    RtlZeroMemory( GpeWakeEnable, AcpiInformation->GpeSize * sizeof(UCHAR) );


    //
    // Look at the first element in the wake list
    //
    listEntry = AcpiPowerWaitWakeList.Flink;

    //
    // Loop for all elements in the list
    //
    while (listEntry != &AcpiPowerWaitWakeList) {

        //
        // Grab the irp from the listEntry
        //
        powerRequest = CONTAINING_RECORD(
            listEntry,
            ACPI_POWER_REQUEST,
            ListEntry
            );

        //
        // Point to the next request
        //
        listEntry = listEntry->Flink;

        //
        // Obtain the device extension for the request
        //
        deviceExtension = powerRequest->DeviceExtension;

        //
        // If this device is to be removed, then remove it
        //
        if (deviceExtension == TargetExtension) {

            //
            // Remove the request from the list and move it to the next
            // list. Mark the irp as no longer cancelable.
            //
            IoSetCancelRoutine( (PIRP) powerRequest->Context, NULL );
            RemoveEntryList( &powerRequest->ListEntry );
            InsertTailList( ListHead, &powerRequest->ListEntry );

        } else {

            //
            // If the wake level of the bit indicates that it isn't supported
            // in the current sleep state, then don't enable it... Note that
            // this doesn't solve the problem where two devices share the
            // same vector, one can wake the computer from S2, one from S3 and
            // we are going to S3. In this case, we don't have the smarts to
            // un-run the _PSW from the S2 device
            //
            sleepState = powerRequest->u.WaitWakeRequest.SystemPowerState;
            if (sleepState < AcpiMostRecentSleepState) {

                continue;

            }

            //
            // Get the byteIndex for this GPE
            //
            byteIndex = ACPIGpeIndexToByteIndex(
                deviceExtension->PowerInfo.WakeBit
                );

            //
            // Drivers cannot register on wake vectors
            //
            if (GpeMap[byteIndex]) {

                ACPIDevPrint( (
                    ACPI_PRINT_WAKE,
                    deviceExtension,
                    "ACPIWakeRemoveDeviceAndUpdate - %x cannot be used as a"
                    "wake pin.\n",
                    deviceExtension->PowerInfo.WakeBit
                    ) );
                continue;

            }

            //
            // Calculate the entry and offset. Assume that the Parameter is
            // at most a UCHAR
            //
            gpeRegister = ACPIGpeIndexToGpeRegister(
                deviceExtension->PowerInfo.WakeBit
                );
            gpeMask  = 1 << ( (UCHAR) deviceExtension->PowerInfo.WakeBit % 8);

            //
            // This GPE is being used as a wake event
            //
            if (!(GpeWakeEnable[gpeRegister] & gpeMask)) {

                //
                // This is a wake pin
                //
                GpeWakeEnable[gpeRegister] |= gpeMask;

                //
                // Prevent machine stupity and try to clear the Status bit
                //
                ACPIWriteGpeStatusRegister( gpeRegister, (UCHAR) gpeMask );

                //
                // Do we have a control method associated with this GPE?
                //
                if (!(GpeEnable[gpeRegister] & gpeMask)) {

                    //
                    // Is this GPE already enabled?
                    //
                    if (GpeCurEnable[gpeRegister] & gpeMask) {

                        continue;

                    }

                    //
                    // Not enabled -- then there is no control method for this
                    // GPE, consider this to be a level vector.
                    //
                    GpeIsLevel[gpeRegister] |= gpeMask;
                    GpeCurEnable[gpeRegister] |= gpeMask;

                } else if (!(GpeSpecialHandler[gpeRegister] & gpeMask) ) {

                    //
                    // In this case, the GPE *does* have a control method
                    // associated with it. Remember that.
                    //
                    GpeWakeHandler[gpeRegister] |= gpeMask;

                }

            }

        }

    }

    //
    // Update all the registers
    //
    for (gpeRegister = 0; gpeRegister < AcpiInformation->GpeSize; gpeRegister++) {

        if (AcpiPowerLeavingS0) {

            //
            // If we are leaving S0, then make sure to remove *all* the
            // wake events that we know about from the current enable mask.
            // If any wake events are currently pending, that will cause us
            // to continue processing them, but hopefully will not lead us
            // to renable them
            //
            GpeCurEnable[gpeRegister] &= ~GpeWakeEnable[gpeRegister];

        } else {

            //
            // If we are re-entering S0, then we need to renable all the wake
            // events, except the ones that we are already processing
            //
            GpeCurEnable[gpeRegister] |= (GpeWakeEnable[gpeRegister] &
                ~GpePending[gpeRegister]);

        }

        //
        // Now that we have calculate what the proper register should be,
        // write it back to the hardware
        //
        ACPIWriteGpeEnableRegister( gpeRegister, GpeCurEnable[gpeRegister] );

    }

    //
    // Done with the spinlock
    //
    KeReleaseSpinLockFromDpcLevel( &GpeTableLock );

    //
    // Done
    //
    return;
}

NTSTATUS
ACPIWakeRestoreEnables(
    IN  PACPI_BUILD_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext
    )
/*++

Routine Description:

    This routine re-runs through the list of WAIT-WAKE irps and runs the _PSW
    method for each of those irps again. The reason that this is done is to
    restore the state of the hardware to what the OS thinks the state is.

Arguments:

    CallBack        - The function to call when done
    CallBackContext - The context to pass to that function

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                        status;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // We need to hold the device tree lock
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiDeviceTreeLock );

    //
    // Call the build routines that we have already tested and running to
    // cause them to walk the device extension tree and run the appropriate
    // control methods
    //
    status = ACPIBuildRunMethodRequest(
        RootDeviceExtension,
        CallBack,
        CallBackContext,
        PACKED_PSW,
        (RUN_REQUEST_CHECK_STATUS | RUN_REQUEST_RECURSIVE |
         RUN_REQUEST_CHECK_WAKE_COUNT),
        TRUE
        );

    //
    // Done with the device tree lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiDeviceTreeLock );

    //
    // Done
    //
    return status;
}

VOID
ACPIWakeRestoreEnablesCompletion(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This routine is called after we have finished running all the _PSWs in the
    system

Arguments:

    DeviceExtension - The device that just completed the enables
    Context         - PACPI_POWER_REQUEST
    Status          - What the status of the operation was

--*/
{
    UNREFERENCED_PARAMETER( DeviceExtension);

    //
    // Restart the device power management engine
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        Status,
        NULL,
        Context
        );
}

NTSTATUS
ACPIWakeWaitIrp(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the routine that is called when the system wants to be notified
    of this device waking the system.

Arguments:

    DeviceObject    - The device object which is supposed to wake the system
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION      irpStack;

    //
    // The first step is to decide if this object can actually support
    // a wake.
    //
    if ( !(deviceExtension->Flags & DEV_CAP_WAKE) ) {

        //
        // We do not support wake
        //
        return ACPIDispatchForwardOrFailPowerIrp( DeviceObject, Irp );

    }

    //
    // Get the stack parameters
    //
    irpStack = IoGetCurrentIrpStackLocation( Irp );

    //
    // We must make sure that we are at the correct system level
    // to support this functionality
    //
    if (deviceExtension->PowerInfo.SystemWakeLevel <
        irpStack->Parameters.WaitWake.PowerState) {

        //
        // The system level is not the one we are currently at
        //
        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            deviceExtension,
            "(0x%08lx): ACPIWakeWaitIrp ->S%d < Irp->S%d\n",
            Irp,
            deviceExtension->PowerInfo.SystemWakeLevel - 1,
            irpStack->Parameters.WaitWake.PowerState - 1
            ) );

        //
        // Fail the Irp
        //
        Irp->IoStatus.Status = status = STATUS_INVALID_DEVICE_STATE;
        PoStartNextPowerIrp( Irp );
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;

    }

    //
    // We must make sure that the device is in the proper device level
    // to support this functionality
    //
    if (deviceExtension->PowerInfo.DeviceWakeLevel <
        deviceExtension->PowerInfo.PowerState) {

        //
        // We are too much powered off to wake the computer
        //
        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            deviceExtension,
            "(0x%08lx): ACPIWakeWaitIrp  Device->D%d Max->D%d\n",
            Irp,
            deviceExtension->PowerInfo.DeviceWakeLevel - 1,
            deviceExtension->PowerInfo.PowerState - 1
            ) );

        //
        // Fail the irp
        //
        Irp->IoStatus.Status = status = STATUS_INVALID_DEVICE_STATE;
        PoStartNextPowerIrp( Irp );
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;

    }

    //
    // At this point, we are definately going to run the completion routine
    // so, we mark the irp as pending and increment the reference count
    //
    IoMarkIrpPending( Irp );
    InterlockedIncrement( &deviceExtension->OutstandingIrpCount );

    //
    // Feed the request to the device power management subsystem. Note that
    // this function is supposed to invoke the completion request no matter
    // what happens.
    //
    status = ACPIDeviceIrpWaitWakeRequest(
        DeviceObject,
        Irp,
        ACPIDeviceIrpCompleteRequest
        );
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = STATUS_PENDING;

    } else {

        //
        // Remove our reference
        //
        ACPIInternalDecrementIrpReferenceCount( deviceExtension );

    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\translate.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    translate.c

Abstract:

    This file implements translator interfaces for busses
    enumerated by ACPI.

    The actual translation information about this bus is
    gotten from the _CRS associated with the bus.  We put
    the data into an IO_RESOURCE_REQUIREMENTS_LIST as
    device private data of the following form:

        DevicePrivate.Data[0]:  child's CM_RESOURCE_TYPE
        DevicePrivate.Data[1]:  child's start address [31:0]
        DevicePrivate.Data[2]:  child's start address [63:32]

    The descriptor that describes child-side translation
    immediately follows the one that describes the
    parent-side resources.

    The Flags field of the IO_RESOURCE_REQUIREMENTS_LIST may have the
    TRANSLATION_RANGE_SPARSE bit set.

Author:

    Jake Oshins     7-Nov-97

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

NTSTATUS
FindTranslationRange(
    IN  PHYSICAL_ADDRESS    Start,
    IN  LONGLONG            Length,
    IN  PBRIDGE_TRANSLATOR  Translator,
    IN  RESOURCE_TRANSLATION_DIRECTION  Direction,
    IN  UCHAR               ResType,
    OUT PBRIDGE_WINDOW      *Window
    );

NTSTATUS
TranslateBridgeResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
TranslateBridgeRequirements(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
BuildTranslatorRanges(
    IN  PBRIDGE_TRANSLATOR Translator,
    OUT ULONG *BridgeWindowCount,
    OUT PBRIDGE_WINDOW *Window
    );

#define MAX(a, b)       \
    ((a) > (b) ? (a) : (b))

#define MIN(a, b)       \
    ((a) < (b) ? (a) : (b))

HAL_PORT_RANGE_INTERFACE HalPortRangeInterface;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TranslateEjectInterface)
#pragma alloc_text(PAGE, TranslateBridgeResources)
#pragma alloc_text(PAGE, TranslateBridgeRequirements)
#pragma alloc_text(PAGE, FindTranslationRange)
#pragma alloc_text(PAGE, AcpiNullReference)
#pragma alloc_text(PAGE, BuildTranslatorRanges)
#endif

NTSTATUS
TranslateEjectInterface(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
{
    PIO_RESOURCE_REQUIREMENTS_LIST  ioList = NULL;
    PIO_RESOURCE_DESCRIPTOR         transDesc;
    PIO_RESOURCE_DESCRIPTOR         parentDesc;
    PTRANSLATOR_INTERFACE           transInterface;
    PBRIDGE_TRANSLATOR              bridgeTrans;
    PIO_STACK_LOCATION              irpSp;
    PDEVICE_EXTENSION               devExtension;
    BOOLEAN                         foundTranslations = FALSE;
    NTSTATUS                        status;
    PUCHAR                          crsBuf;
    ULONG                           descCount;
    ULONG                           parentResType;
    ULONG                           childResType;
    ULONG                           crsBufSize;
    PHYSICAL_ADDRESS                parentStart;
    PHYSICAL_ADDRESS                childStart;

    PAGED_CODE();

    devExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    ASSERT(devExtension);
    ASSERT(devExtension->AcpiObject);

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp->Parameters.QueryInterface.Size >= sizeof(TRANSLATOR_INTERFACE));

    transInterface = (PTRANSLATOR_INTERFACE)irpSp->Parameters.QueryInterface.Interface;
    ASSERT(transInterface);

    //
    // Get the resources for this bus.
    //
    status = ACPIGetBufferSync(
        devExtension,
        PACKED_CRS,
        &crsBuf,
        &crsBufSize
        );
    if (!NT_SUCCESS(status)) {

        //
        // This bus has no _CRS.  So it doesn't need a translator.
        //
        return Irp->IoStatus.Status;

    }

    //
    // Turn it into something meaningful.
    //
    status = PnpBiosResourcesToNtResources(
        crsBuf,
        PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES,
        &ioList
        );
    if (!NT_SUCCESS(status)) {
        goto TranslateEjectInterfaceExit;
    }

    //
    // Cycle through the descriptors looking for device private data
    // that contains translation information.
    //

    for (descCount = 0; descCount < ioList->List[0].Count; descCount++) {

        transDesc = &ioList->List[0].Descriptors[descCount];

        if (transDesc->Type == CmResourceTypeDevicePrivate) {

            //
            // Translation information is contained in
            // a device private resource that has
            // TRANSLATION_DATA_PARENT_ADDRESS in the
            // flags field.
            //
            if (transDesc->Flags & TRANSLATION_DATA_PARENT_ADDRESS) {

                // The first descriptor cannot be a translation descriptor
                ASSERT(descCount != 0);

                //
                // The translation descriptor should follow the descriptor
                // that it is trying to modify.  The first, normal,
                // descriptor is for the child-relative resources.  The
                // second, device private, descriptor is modifies the
                // child-relative resources to generate the parent-relative
                // resources.
                //

                parentResType        = transDesc->u.DevicePrivate.Data[0];
                parentStart.LowPart  = transDesc->u.DevicePrivate.Data[1];
                parentStart.HighPart = transDesc->u.DevicePrivate.Data[2];

                childResType = ioList->List[0].Descriptors[descCount - 1].Type;
                childStart.QuadPart = (transDesc - 1)->u.Generic.MinimumAddress.QuadPart;
                
                if ((parentResType != childResType) ||
                    (parentStart.QuadPart != childStart.QuadPart)) {

                    foundTranslations = TRUE;
                    break;
                }
            }
        }
    }

    if (!foundTranslations) {

        //
        // Didn't find any translation information for this bus.
        //
        status = Irp->IoStatus.Status;
        ExFreePool(ioList);
        goto TranslateEjectInterfaceExit;
    }

    //
    // Build a translator interface.
    //
    bridgeTrans = ExAllocatePoolWithTag(
        PagedPool,
        sizeof (BRIDGE_TRANSLATOR),
        ACPI_TRANSLATE_POOLTAG
        );
    if (!bridgeTrans) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto TranslateEjectInterfaceExit;

    }

    bridgeTrans->AcpiObject = devExtension->AcpiObject;
    bridgeTrans->IoList = ioList;

    //
    // Build the array of bridge windows.
    //
    status = BuildTranslatorRanges(
        bridgeTrans,
        &bridgeTrans->RangeCount,
        &bridgeTrans->Ranges
        );
    if (!NT_SUCCESS(status)) {

        goto TranslateEjectInterfaceExit;

    }
    transInterface->Size = sizeof(TRANSLATOR_INTERFACE);
    transInterface->Version = 1;
    transInterface->Context = (PVOID)bridgeTrans;
    transInterface->InterfaceReference = AcpiNullReference;
    transInterface->InterfaceDereference = AcpiNullReference;
    transInterface->TranslateResources = TranslateBridgeResources;
    transInterface->TranslateResourceRequirements = TranslateBridgeRequirements;

    status = STATUS_SUCCESS;

TranslateEjectInterfaceExit:
    
    return status;
}




NTSTATUS
FindTranslationRange(
    IN  PHYSICAL_ADDRESS    Start,
    IN  LONGLONG            Length,
    IN  PBRIDGE_TRANSLATOR  Translator,
    IN  RESOURCE_TRANSLATION_DIRECTION  Direction,
    IN  UCHAR               ResType,
    OUT PBRIDGE_WINDOW      *Window
    )
{
    LONGLONG    beginning, end;
    ULONG       i;
    UCHAR       rangeType;

    PAGED_CODE();

    for (i = 0; i < Translator->RangeCount; i++) {

        if (Direction == TranslateParentToChild) {

            beginning = Translator->Ranges[i].ParentAddress.QuadPart;
            rangeType = Translator->Ranges[i].ParentType;

        } else {

            beginning = Translator->Ranges[i].ChildAddress.QuadPart;
            rangeType = Translator->Ranges[i].ChildType;
        }

        end = beginning + Translator->Ranges[i].Length;

        if ((rangeType == ResType) &&
            (!((Start.QuadPart < beginning) ||
               (Start.QuadPart + Length > end)))) {

            //
            // The range lies within this bridge window
            // and the resource types match.
            //

            *Window = &Translator->Ranges[i];

            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}

NTSTATUS
TranslateBridgeResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function takes a set of resources that are
    passed through a bridge and does any translation
    that is necessary when changing from a parent-
    relative viewpoint to a child-relative one or
    back again.

    In this function, we have the notion of a "window,"
    which is an aperature within the bridge.  Bridges
    often have multiple windows, each with distinct
    translations.

    This function should never fail, as any resource
    range that will fail translation should have already
    been stripped out by TranslateBridgeRequirements.

Arguments:

    Context - pointer to the translation data

    Source  - resource list to be translated

    Direction - TranslateChildToParent or
                    TranslateParentToChild

    AlternativesCount - not used

    Alternatives - not used

    PhysicalDeviceObject - not used

    Target  - translated resource list

Return Value:

    Status

--*/
{
    PBRIDGE_TRANSLATOR  translator;
    PBRIDGE_WINDOW      window;
    NTSTATUS            status;

    PAGED_CODE();
    ASSERT(Context);
    ASSERT((Source->Type == CmResourceTypePort) ||
           (Source->Type == CmResourceTypeMemory));

    translator = (PBRIDGE_TRANSLATOR)Context;

    ASSERT(translator->RangeCount > 0);

    //
    // Find the window that this translation occurs
    // within.
    //
    status = FindTranslationRange(Source->u.Generic.Start,
                                  Source->u.Generic.Length,
                                  translator,
                                  Direction,
                                  Source->Type,
                                  &window);

    if (!NT_SUCCESS(status)) {

        //
        // We should never get here.  This fucntion
        // should only be called for ranges that
        // are valid.  TranslateBridgeRequirements should
        // weed out all the invalid ranges.

        return status;
    }

    //
    // Copy everything
    //
    *Target = *Source;

    switch (Direction) {
    case TranslateChildToParent:

        //
        // Target inherits the parent's resource type.
        //
        Target->Type = window->ParentType;

        //
        // Calculate the target's parent-relative start
        // address.
        //
        Target->u.Generic.Start.QuadPart =
            Source->u.Generic.Start.QuadPart +
                window->ParentAddress.QuadPart -
                window->ChildAddress.QuadPart;

        //
        // Make sure the length is still in bounds.
        //
        ASSERT(Target->u.Generic.Length <= (ULONG)(window->Length -
               (Target->u.Generic.Start.QuadPart -
                    window->ParentAddress.QuadPart)));

        status = STATUS_TRANSLATION_COMPLETE;

        break;

    case TranslateParentToChild:

        //
        // Target inherits the child's resource type.
        //
        Target->Type = window->ChildType;

        //
        // Calculate the target's child-relative start
        // address.
        //
        Target->u.Generic.Start.QuadPart =
            Source->u.Generic.Start.QuadPart +
                window->ChildAddress.QuadPart -
                window->ParentAddress.QuadPart;

        //
        // Make sure the length is still in bounds.
        //
        ASSERT(Target->u.Generic.Length <= (ULONG)(window->Length -
               (Target->u.Generic.Start.QuadPart -
                    window->ChildAddress.QuadPart)));

        status = STATUS_SUCCESS;
        break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }

#if 0
    if (Target->Type == CmResourceTypePort) {
        DbgPrint("XXX:  %s[%d]=0x%I64x -> %s[%d]=0x%I64x\n",
                 (Direction == TranslateChildToParent) ? "child" : "parent",
                 Source->Type,
                 Source->u.Generic.Start.QuadPart,
                 (Direction == TranslateChildToParent) ? "parent" : "child",
                 Target->Type,
                 Target->u.Generic.Start.QuadPart);
    }
#endif
    
    return status;
}

NTSTATUS
TranslateBridgeRequirements(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function takes a resource requirements list for
    resources on the child side of the bridge and
    translates them into resource requirements on the
    parent side of the bridge.  This may involve clipping
    and there may be multiple target ranges.

Arguments:

    Context - pointer to the translation data

    Source  - resource list to be translated

    PhysicalDeviceObject - not used

    TargetCount - number of resources in the target list

    Target  - translated resource requirements list

Return Value:

    Status

--*/
{
    PBRIDGE_TRANSLATOR  translator;
    PBRIDGE_WINDOW      window;
    NTSTATUS            status;
    LONGLONG            rangeStart, rangeEnd, windowStart, windowEnd;
    ULONG               i;

    PAGED_CODE();
    ASSERT(Context);
    ASSERT((Source->Type == CmResourceTypePort) ||
           (Source->Type == CmResourceTypeMemory));

    translator = (PBRIDGE_TRANSLATOR)Context;

    //
    // Allocate memory for the target range.
    //

    *Target = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(IO_RESOURCE_DESCRIPTOR),
                                    ACPI_RESOURCE_POOLTAG);

    if (!*Target) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    //
    // Look at all the aperatures in the bridge to see which
    // ones of them could possibly provide translations for
    // this resource.
    //

    rangeStart = Source->u.Generic.MinimumAddress.QuadPart;
    rangeEnd   = Source->u.Generic.MaximumAddress.QuadPart;

    for (i = 0; i < translator->RangeCount; i++) {

        window = &translator->Ranges[i];

        if (window->ChildType != Source->Type) {

            //
            // This window describes the wrong
            // type of resource.
            //
            continue;
        }

        if (Source->u.Generic.Length > window->Length) {

            //
            // This resource won't fit in this aperature.
            //
            continue;
        }

        windowStart = window->ChildAddress.QuadPart;
        windowEnd = window->ChildAddress.QuadPart + (LONGLONG)window->Length;

        if (!(((rangeStart < windowStart) && (rangeEnd < windowStart)) ||
              ((rangeStart > windowEnd) && (rangeEnd > windowEnd)))) {

            //
            // The range and the window do intersect.  So create
            // a resource that clips the range to the window.
            //

            **Target = *Source;
            *TargetCount = 1;

            (*Target)->Type = window->ParentType;

            (*Target)->u.Generic.MinimumAddress.QuadPart =
                rangeStart + (window->ParentAddress.QuadPart - windowStart);

            (*Target)->u.Generic.MaximumAddress.QuadPart =
                rangeEnd + (window->ParentAddress.QuadPart - windowStart);

            break;
        }
    }

    if (i < translator->RangeCount) {

        return STATUS_TRANSLATION_COMPLETE;

    } else {

        *TargetCount = 0;
        status = STATUS_PNP_TRANSLATION_FAILED;
    }

cleanup:

    if (*Target) {
        ExFreePool(*Target);
    }

    return status;
}

NTSTATUS
BuildTranslatorRanges(
    IN  PBRIDGE_TRANSLATOR Translator,
    OUT ULONG *BridgeWindowCount,
    OUT PBRIDGE_WINDOW *Window
    )
{
    PIO_RESOURCE_REQUIREMENTS_LIST ioList;
    PIO_RESOURCE_DESCRIPTOR transDesc, resDesc;
    ULONG   descCount, windowCount, maxWindows;

    PAGED_CODE();

    ioList = Translator->IoList;

    //
    // Make an array of windows for holding the translation information.
    //

    maxWindows = ioList->List[0].Count / 2;

    *Window = ExAllocatePoolWithTag(PagedPool,
                                    maxWindows *  sizeof(BRIDGE_WINDOW),
                                    ACPI_TRANSLATE_POOLTAG);

    if (!*Window) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill in the array with translations.
    //

    windowCount = 0;

    for (descCount = 0; descCount < ioList->List[0].Count; descCount++) {

        transDesc = &ioList->List[0].Descriptors[descCount];

        if (transDesc->Type == CmResourceTypeDevicePrivate) {

            //
            // Translation information is contained in
            // a device private resource that has
            // TRANSLATION_DATA_PARENT_ADDRESS in the
            // flags field.
            //
            if (transDesc->Flags & TRANSLATION_DATA_PARENT_ADDRESS) {

                ASSERT(windowCount <= maxWindows);

                         

                //
                // The translation descriptor is supposed to follow
                // the resource that it is providing information about.
                //

                resDesc = &ioList->List[0].Descriptors[descCount - 1];



                (*Window)[windowCount].ParentType =
                    (UCHAR)transDesc->u.DevicePrivate.Data[0];

                (*Window)[windowCount].ChildType = resDesc->Type;

                (*Window)[windowCount].ParentAddress.LowPart =
                    transDesc->u.DevicePrivate.Data[1];

                (*Window)[windowCount].ParentAddress.HighPart =
                    transDesc->u.DevicePrivate.Data[2];

                (*Window)[windowCount].ChildAddress.QuadPart =
                    resDesc->u.Generic.MinimumAddress.QuadPart;

                (*Window)[windowCount].Length =
                    resDesc->u.Generic.Length;

                //
                // If the HAL has provided underlying sparse port translation
                // services, allow for that.
                //

                if ((HalPortRangeInterface.QueryAllocateRange != NULL) &&
                    (resDesc->Type == CmResourceTypePort)) {
                    
                    USHORT rangeId;
                    UCHAR parentType = (UCHAR)transDesc->u.DevicePrivate.Data[0];
                    
                    BOOLEAN isSparse = transDesc->Flags & TRANSLATION_RANGE_SPARSE;
                    ULONG parentLength = resDesc->u.Generic.Length;
                    PHYSICAL_ADDRESS parentAddress;
                    NTSTATUS status;

                    PHYSICAL_ADDRESS rangeZeroBase;

                    parentAddress.LowPart  = transDesc->u.DevicePrivate.Data[1];
                    parentAddress.HighPart = transDesc->u.DevicePrivate.Data[2];

                    rangeZeroBase.QuadPart = parentAddress.QuadPart - resDesc->u.Generic.MinimumAddress.QuadPart;                    

                    if (isSparse) {
                        parentLength = (parentLength + resDesc->u.Generic.MinimumAddress.LowPart) << 10;
                    }

                    status = HalPortRangeInterface.QueryAllocateRange(
                        isSparse,
                        parentType == CmResourceTypeMemory,
                        NULL,
                        rangeZeroBase,
                        parentLength,
                        &rangeId
                        );

                    if (NT_SUCCESS(status)) {
                        (*Window)[windowCount].ParentType = CmResourceTypePort;
                        
                        (*Window)[windowCount].ParentAddress.QuadPart =
                            (rangeId << 16) |
                            ((*Window)[windowCount].ChildAddress.QuadPart & 0xffff);
                    }
                }

                windowCount++;
            }
        }
    }

    *BridgeWindowCount = windowCount;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\wmilog.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    WmiLog.c

Abstract:

    This module contains Wmi loging support.

Author:

    Hanumant Yadav (hanumany) 18-Dec-2000

Revision History:

--*/



#include "pch.h"
#include <evntrace.h>



#ifdef WMI_TRACING
//
//Globals
//
GUID        GUID_List[] =
{
    {0xF2E0E060L, 0xBF32, 0x4B88, 0xB8, 0xE4, 0x5C, 0xAD, 0x15, 0xAF, 0x6A, 0xE9} /* AMLI log GUID */
    /* Add new logging GUIDS here */
};



ULONG       ACPIWmiTraceEnable = 0;
ULONG       ACPIWmiTraceGlobalEnable = 0;
TRACEHANDLE ACPIWmiLoggerHandle = 0;

// End Globals



VOID
ACPIWmiInitLog(
    IN  PDEVICE_OBJECT ACPIDeviceObject
    )
/*++

Routine Description:

    This is a initialization function in which we call IoWMIRegistrationControl
    to register for WMI loging.

Arguments:
    ACPIDeviceObject.

Return Value:
    None.

--*/
{
    NTSTATUS status;
    //
    // Register with WMI.
    //
    status = IoWMIRegistrationControl(ACPIDeviceObject,
                                      WMIREG_ACTION_REGISTER);
    if (!NT_SUCCESS(status))
    {
        ACPIPrint( (
                    DPFLTR_ERROR_LEVEL,
                    "ACPIWmiInitLog: Failed to register for WMI support\n"
                 ) );
    }
    return;
}

VOID
ACPIWmiUnRegisterLog(
    IN  PDEVICE_OBJECT ACPIDeviceObject
    )
/*++

Routine Description:

    This is a unregistration function in which we call IoWMIRegistrationControl
    to unregister for WMI loging.

Arguments:
    ACPIDeviceObject.

Return Value:
    None.

--*/
{
    NTSTATUS status;
    //
    // Register with WMI.
    //
    status = IoWMIRegistrationControl(ACPIDeviceObject,
                                      WMIREG_ACTION_DEREGISTER);
    if (!NT_SUCCESS(status))
    {
        ACPIPrint( (
                    DPFLTR_ERROR_LEVEL,
                    "ACPIWmiInitLog: Failed to unregister for WMI support\n"
                 ) );
    }
    return;
}

NTSTATUS
ACPIWmiRegisterGuids(
    IN  PWMIREGINFO             WmiRegInfo,
    IN  ULONG                   wmiRegInfoSize,
    IN  PULONG                  pReturnSize
    )
/*++

Routine Description:

    This function handles WMI GUID registration goo.

Arguments:
    WmiRegInfo,
    wmiRegInfoSize,
    pReturnSize

Return Value:
    STATUS_SUCCESS on success.

--*/
{
    //
    // Register a Control Guid as a Trace Guid.
    //

    ULONG           SizeNeeded;
    PWMIREGGUIDW    WmiRegGuidPtr;
    ULONG           Status;
    ULONG           GuidCount;
    LPGUID          ControlGuid;
    ULONG           RegistryPathSize;
    ULONG           MofResourceSize;
    PUCHAR          ptmp;
    GUID            ACPITraceGuid  = {0xDAB01D4DL, 0x2D48, 0x477D, 0xB1, 0xC3, 0xDA, 0xAD, 0x0C, 0xE6, 0xF0, 0x6B};

    
    *pReturnSize = 0;
    GuidCount = 1;
    ControlGuid = &ACPITraceGuid;

    //
    // Allocate WMIREGINFO for controlGuid + GuidCount.
    //
    RegistryPathSize = sizeof(ACPI_REGISTRY_KEY) - sizeof(WCHAR) + sizeof(USHORT);
    MofResourceSize =  sizeof(ACPI_TRACE_MOF_FILE) - sizeof(WCHAR) + sizeof(USHORT);
    SizeNeeded = sizeof(WMIREGINFOW) + GuidCount * sizeof(WMIREGGUIDW) +
                 RegistryPathSize +
                 MofResourceSize;


    if (SizeNeeded  > wmiRegInfoSize) {
        *((PULONG)WmiRegInfo) = SizeNeeded;
        *pReturnSize = sizeof(ULONG);
        return STATUS_SUCCESS;
    }


    RtlZeroMemory(WmiRegInfo, SizeNeeded);
    WmiRegInfo->BufferSize = SizeNeeded;
    WmiRegInfo->GuidCount = GuidCount;
    WmiRegInfo->RegistryPath = sizeof(WMIREGINFOW) + GuidCount * sizeof(WMIREGGUIDW);
    WmiRegInfo->MofResourceName = WmiRegInfo->RegistryPath + RegistryPathSize; //ACPI_TRACE_MOF_FILE;

    WmiRegGuidPtr = &WmiRegInfo->WmiRegGuid[0];
    WmiRegGuidPtr->Guid = *ControlGuid;
    WmiRegGuidPtr->Flags |= WMIREG_FLAG_TRACED_GUID;
    WmiRegGuidPtr->Flags |= WMIREG_FLAG_TRACE_CONTROL_GUID;
    WmiRegGuidPtr->InstanceCount = 0;
    WmiRegGuidPtr->InstanceInfo = 0;

    ptmp = (PUCHAR)&WmiRegInfo->WmiRegGuid[1];
    *((PUSHORT)ptmp) = sizeof(ACPI_REGISTRY_KEY) - sizeof(WCHAR);

    ptmp += sizeof(USHORT);
    RtlCopyMemory(ptmp, ACPI_REGISTRY_KEY, sizeof(ACPI_REGISTRY_KEY) - sizeof(WCHAR));

    ptmp = (PUCHAR)WmiRegInfo + WmiRegInfo->MofResourceName;
    *((PUSHORT)ptmp) = sizeof(ACPI_TRACE_MOF_FILE) - sizeof(WCHAR);

    ptmp += sizeof(USHORT);
    RtlCopyMemory(ptmp, ACPI_TRACE_MOF_FILE, sizeof(ACPI_TRACE_MOF_FILE) - sizeof(WCHAR));

    *pReturnSize =  SizeNeeded;
    return(STATUS_SUCCESS);

}


VOID
ACPIGetWmiLogGlobalHandle(
    VOID
    )
/*++

Routine Description:

    This function gets the global wmi logging handle. We need this to log
    at boot time, before we start getting wmi messages.

Arguments:
    None.

Return Value:
    None.

--*/
{
    WmiSetLoggerId(WMI_GLOBAL_LOGGER_ID, &ACPIWmiLoggerHandle);
    if(ACPIWmiLoggerHandle)
    {
       ACPIPrint( (
                    DPFLTR_INFO_LEVEL,
                    "ACPIGetWmiLogGlobalHandle: Global handle aquired. Handle = %I64u\n",
                    ACPIWmiLoggerHandle
                ) );

        ACPIWmiTraceGlobalEnable = 1;
    }
    return;
}


NTSTATUS
ACPIWmiEnableLog(
    IN  PVOID Buffer,
    IN  ULONG BufferSize
    )
/*++

Routine Description:

    This function is the handler for IRP_MN_ENABLE_EVENTS.

Arguments:
    Buffer,
    BufferSize

Return Value:
    NTSTATUS

--*/
{
    PWNODE_HEADER Wnode=NULL;

    InterlockedExchange(&ACPIWmiTraceEnable, 1);

    Wnode = (PWNODE_HEADER)Buffer;
    if (BufferSize >= sizeof(WNODE_HEADER)) {
        ACPIWmiLoggerHandle = Wnode->HistoricalContext;
        //
        // reset the global logger if it is active.
        //
        if(ACPIWmiTraceGlobalEnable)
            ACPIWmiTraceGlobalEnable = 0;

       ACPIPrint( (
                    DPFLTR_INFO_LEVEL,
                    "ACPIWmiEnableLog: LoggerHandle = %I64u. BufferSize = %d. Flags = %x. Version = %x\n",
                    ACPIWmiLoggerHandle,
                    Wnode->BufferSize,
                    Wnode->Flags,
                    Wnode->Version
                ) );

    }

    return(STATUS_SUCCESS);

}

NTSTATUS
ACPIWmiDisableLog(
    VOID
    )
/*++

Routine Description:

    This function is the handler for IRP_MN_DISABLE_EVENTS.

Arguments:
    None.

Return Value:
    NTSTATUS

--*/
{
    InterlockedExchange(&ACPIWmiTraceEnable, 0);
    ACPIWmiLoggerHandle = 0;

    return(STATUS_SUCCESS);
}

NTSTATUS
ACPIWmiLogEvent(
    IN UCHAR    LogLevel,
    IN UCHAR    LogType,
    IN GUID     LogGUID,
    IN PUCHAR   Format,
    IN ...
    )
/*++

Routine Description:

    This is the main wmi logging funcion. This function should be used
    throughtout the ACPI driver where WMI logging is required.

Arguments:
    LogLevel,
    LogType,
    LogGUID,
    Format,
    ...

Return Value:
    NTSTATUS

--*/
{
    static char         Buffer[1024];
    va_list             marker;
    WMI_LOG_DATA        Wmi_log_data ={0,0};
    EVENT_TRACE_HEADER  *Wnode;
    NTSTATUS            status = STATUS_UNSUCCESSFUL;

    va_start(marker, Format);
    vsprintf(Buffer, Format, marker);
    va_end(marker);

    if(ACPIWmiTraceEnable || ACPIWmiTraceGlobalEnable)
    {
        if(ACPIWmiLoggerHandle)
        {
            Wmi_log_data.Data.DataPtr = (ULONG64)&Buffer;
            Wmi_log_data.Data.Length = strlen(Buffer) + 1;
            Wmi_log_data.Header.Size = sizeof(WMI_LOG_DATA);
            Wmi_log_data.Header.Flags = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;
            Wmi_log_data.Header.Class.Type = LogType;
            Wmi_log_data.Header.Class.Level = LogLevel;
            Wmi_log_data.Header.Guid = LogGUID;
            Wnode = &Wmi_log_data.Header;
            ((PWNODE_HEADER)Wnode)->HistoricalContext = ACPIWmiLoggerHandle;

            //
            // Call TraceLogger to  write this event
            //

            status = IoWMIWriteEvent((PVOID)&(Wmi_log_data.Header));

            //
            // if IoWMIWriteEvent fails and we are using the global logger handle,
            // we need to stop loging.
            //
            if(status != STATUS_SUCCESS)
            {
                if(ACPIWmiTraceGlobalEnable)
                {
                    ACPIWmiLoggerHandle = 0;
                    ACPIWmiTraceGlobalEnable = 0;
                    ACPIPrint( (
                            ACPI_PRINT_INFO,
                            "ACPIWmiLogEvent: Disabling WMI loging using global handle. status = %x\n",
                            status
                         ) );
                }
                else
                {
                    ACPIPrint( (
                                DPFLTR_ERROR_LEVEL,
                                "ACPIWmiLogEvent: Failed to log. status = %x\n",
                                status
                             ) );
                }

            }
        }
    }

    return status;
}


NTSTATUS
ACPIDispatchWmiLog(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS                status;
    PIO_STACK_LOCATION      irpSp;
    UCHAR                   minorFunction;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the dispatch table that we will be using and the minor code as well,
    // so that we can look it when required
    //
    ASSERT(RootDeviceExtension->DeviceObject == DeviceObject);

    if (DeviceObject != (PDEVICE_OBJECT) irpSp->Parameters.WMI.ProviderId) {

        return ACPIDispatchForwardIrp(DeviceObject, Irp);
    }

    minorFunction = irpSp->MinorFunction;

    switch(minorFunction){

        case IRP_MN_REGINFO:{
            
            ULONG ReturnSize = 0;
            ULONG BufferSize = irpSp->Parameters.WMI.BufferSize;
            PVOID Buffer = irpSp->Parameters.WMI.Buffer;

            status=ACPIWmiRegisterGuids(
                                         Buffer,
                                         BufferSize,
                                         &ReturnSize
                                        );

            Irp->IoStatus.Information = ReturnSize;
            Irp->IoStatus.Status = status;

            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return status;
        }
        case IRP_MN_ENABLE_EVENTS:{
            
            status=ACPIWmiEnableLog(
                                    irpSp->Parameters.WMI.Buffer,
                                    irpSp->Parameters.WMI.BufferSize
                                   );
            Irp->IoStatus.Status = status;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return status;
        }
        case IRP_MN_DISABLE_EVENTS:{
            
            status=ACPIWmiDisableLog();
            Irp->IoStatus.Status = status;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return status;
        }
        default:{
            
            status = ACPIDispatchForwardIrp(DeviceObject, Irp);
            return status;
        }
    }
    return status;
}

#endif //WMI_TRACING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\vector.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vector.c

Abstract:

    This module is how external drivers add / remove hooks to deal with
    ACPI Gpe Events

Author:

    Stephane Plante

Environment:

    NT Kernel Mode Driver Only

--*/

#include "pch.h"

//
// Table for installed GPE handlers
//
PGPE_VECTOR_ENTRY   GpeVectorTable      = NULL;
UCHAR               GpeVectorFree       = 0;
ULONG               GpeVectorTableSize  = 0;


VOID
ACPIVectorBuildVectorMasks(
    VOID
    )
/*++

Routine Description:

    This routine is called to walk the GPE Vector Table and properly
    enable all the events that we think should be enabled.

    This routine is typically called after we have loaded a new set
    of tables or we have unloaded an existing set of tables.

    We have to call this routine because at the start of the operation,
    we clear out all the knowledge of these additional vectors.

    This routine is called with GPEs disabled and the GPE Table locked
    acquired.

Arguments:

    None

Return Value:

    None

--*/
{
    BOOLEAN installed;
    ULONG   i;
    ULONG   mode;

    //
    // Walk all the elements in the table
    //
    for (i = 0; i < GpeVectorTableSize; i++) {

        //
        // Does this entry point to a vector object?
        //
        if (GpeVectorTable[i].GpeVectorObject == NULL) {

            continue;

        }

        if (GpeVectorTable[i].GpeVectorObject->Mode == LevelSensitive) {

            mode = ACPI_GPE_LEVEL_INSTALL;

        } else {

            mode = ACPI_GPE_EDGE_INSTALL;

        }

        //
        // Install the GPE into bit-maps.  This validates the GPE number.
        //
        installed = ACPIGpeInstallRemoveIndex(
            GpeVectorTable[i].GpeVectorObject->Vector,
            mode,
            ACPI_GPE_HANDLER,
            &(GpeVectorTable[i].GpeVectorObject->HasControlMethod)
            );
        if (!installed) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ACPIVectorBuildVectorMasks: Could not reenable Vector Object %d\n",
                i
                ) );

        }

    }

}

NTSTATUS
ACPIVectorClear(
    PDEVICE_OBJECT      AcpiDeviceObject,
    PVOID               GpeVectorObject
    )
/*++

Routine Description:

    Clear the GPE_STS (status) bit associated with a vector object

Arguments:

    AcpiDeviceObject    - The ACPI device object
    GpeVectorObject     - Pointer to the vector object returned by
                          ACPIGpeConnectVector

Return Value

    Returns status

--*/
{
    PGPE_VECTOR_OBJECT  localVectorObject = GpeVectorObject;
    ULONG               gpeIndex;
    ULONG               bitOffset;
    ULONG               i;

    ASSERT( localVectorObject );

    //
    // What is the GPE index for this vector?
    //
    gpeIndex = localVectorObject->Vector;

    //
    // Calculate the proper mask to use
    //
    bitOffset = gpeIndex % 8;

    //
    // Calculate the offset for the register
    //
    i = ACPIGpeIndexToGpeRegister (gpeIndex);

    //
    // Clear the register
    //
    ACPIWriteGpeStatusRegister (i, (UCHAR) (1 << bitOffset));
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIVectorConnect(
    PDEVICE_OBJECT          AcpiDeviceObject,
    ULONG                   GpeVector,
    KINTERRUPT_MODE         GpeMode,
    BOOLEAN                 Sharable,
    PGPE_SERVICE_ROUTINE    ServiceRoutine,
    PVOID                   ServiceContext,
    PVOID                   *GpeVectorObject
    )
/*++

Routine Description:

    Connects a handler to a general-purpose event.

Arguments:

    AcpiDeviceObject    - The ACPI object
    GpeVector           - The event number to connect to
    GpeMode             - Level or edge interrupt
    Sharable            - Can this level be shared?
    ServiceRoutine      - Address of the handler
    ServiceContext      - Context object to be passed to the handler
    *GpeVectorObject    - Pointer to where the vector object is returned

Return Value

    Returns status

--*/
{
    BOOLEAN                 installed;
    KIRQL                   oldIrql;
    NTSTATUS                status;
    PGPE_VECTOR_OBJECT      localVectorObject;
    ULONG                   mode;

    ASSERT( GpeVectorObject );

    ACPIPrint( (
        ACPI_PRINT_INFO,
        "ACPIVectorConnect: Attach GPE handler\n"
        ) );

    status = STATUS_SUCCESS;
    *GpeVectorObject = NULL;

    //
    // Do GPEs exist on this machine?
    //
    if (AcpiInformation->GpeSize == 0) {

        return STATUS_UNSUCCESSFUL;

    }

    //
    // Validate the vector number (GPE number)
    //
    if ( !ACPIGpeValidIndex(GpeVector) ) {

        return STATUS_INVALID_PARAMETER_2;

    }

    //
    // Create and initialize a vector object
    //
    localVectorObject = ExAllocatePoolWithTag (
        NonPagedPool,
        sizeof(GPE_VECTOR_OBJECT),
        ACPI_SHARED_GPE_POOLTAG
        );
    if (localVectorObject == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( localVectorObject, sizeof(GPE_VECTOR_OBJECT) );
    localVectorObject->Vector   = GpeVector;
    localVectorObject->Handler  = ServiceRoutine;
    localVectorObject->Context  = ServiceContext;
    localVectorObject->Mode     = GpeMode;

    //
    // We don't implement anything other than sharable...
    //
    localVectorObject->Sharable = Sharable;

    //
    // Level/Edge mode for ACPIGpeInstallRemoveIndex()
    //
    if (GpeMode == LevelSensitive) {

        mode = ACPI_GPE_LEVEL_INSTALL;

    } else {

        mode = ACPI_GPE_EDGE_INSTALL;

    }

    //
    // Lock the global tables
    //
    KeAcquireSpinLock (&GpeTableLock, &oldIrql);

    //
    // Disable GPEs while we are installing the handler
    //
    ACPIGpeEnableDisableEvents(FALSE);

    //
    // Install the GPE into bit-maps.  This validates the GPE number.
    //
    installed = ACPIGpeInstallRemoveIndex(
        GpeVector,
        mode,
        ACPI_GPE_HANDLER,
        &(localVectorObject->HasControlMethod)
        );
    if (!installed) {

        status = STATUS_UNSUCCESSFUL;

    } else {

        //
        // Install GPE handler into vector table.
        //
        installed = ACPIVectorInstall(
            GpeVector,
            localVectorObject
            );
        if (!installed) {

            ACPIGpeInstallRemoveIndex(
                GpeVector,
                ACPI_GPE_REMOVE,
                0,
                &localVectorObject->HasControlMethod
                );
            status = STATUS_UNSUCCESSFUL;

        }

    }

    if (!NT_SUCCESS(status)) {

        ExFreePool (localVectorObject);

    } else {

        *GpeVectorObject = localVectorObject;

    }

    //
    // Update hardware to match us
    //
    ACPIGpeEnableDisableEvents (TRUE);

    //
    // Unlock tables and return status
    //
    KeReleaseSpinLock (&GpeTableLock, oldIrql);
    return status;
}

NTSTATUS
ACPIVectorDisable(
    PDEVICE_OBJECT      AcpiDeviceObject,
    PVOID               GpeVectorObject
    )
/*++

Routine Description:

    Temporarily disable a GPE that is already attached to a handler.

Arguments:

    AcpiDeviceObject    - The ACPI device object
    GpeVectorObject     - Pointer to the vector object returned by ACPIGpeConnectVector

Return Value

    Returns status

--*/
{
    PGPE_VECTOR_OBJECT  localVectorObject = GpeVectorObject;
    KIRQL               oldIrql;
    ULONG               gpeIndex;
    ULONG               bit;
    ULONG               i;

    //
    // The GPE index was validated when the handler was attached
    //
    gpeIndex = localVectorObject->Vector;

    //
    // Calculate the mask and index
    //
    bit = (1 << (gpeIndex % 8));
    i = ACPIGpeIndexToGpeRegister (gpeIndex);

    //
    // Lock the global tables
    //
    KeAcquireSpinLock (&GpeTableLock, &oldIrql);

    //
    // Disable GPEs while we are fussing with the enable bits
    //
    ACPIGpeEnableDisableEvents(FALSE);

    //
    // Remove the GPE from the enable bit-maps.  This event will be completely disabled,
    // but the handler has not been removed.
    //
    GpeEnable [i]      &= ~bit;
    GpeCurEnable [i]   &= ~bit;
    ASSERT(!(GpeWakeEnable[i] & bit));

    //
    // Update hardware to match us
    //
    ACPIGpeEnableDisableEvents (TRUE);

    //
    // Unlock tables and return status
    //
    KeReleaseSpinLock (&GpeTableLock, oldIrql);
    ACPIPrint( (
        ACPI_PRINT_RESOURCES_2,
        "ACPIVectorDisable: GPE %x disabled\n",
        gpeIndex
        ) );
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIVectorDisconnect(
    PVOID                   GpeVectorObject
    )
/*++

Routine Description:

    Disconnects a handler from a general-purpose event.

Arguments:

    GpeVectorObject - Pointer to the vector object returned by
                      ACPIGpeConnectVector

Return Value

    Returns status

--*/
{
    BOOLEAN                 removed;
    KIRQL                   oldIrql;
    NTSTATUS                status          = STATUS_SUCCESS;
    PGPE_VECTOR_OBJECT      gpeVectorObj    = GpeVectorObject;

    ACPIPrint( (
        ACPI_PRINT_INFO,
        "ACPIVectorDisconnect: Detach GPE handler\n"
        ) );

    //
    // Lock the global tables
    //
    KeAcquireSpinLock (&GpeTableLock, &oldIrql);

    //
    // Disable GPEs while we are removing the handler
    //
    ACPIGpeEnableDisableEvents (FALSE);

    //
    // Remove GPE handler From vector table.
    //
    ACPIVectorRemove(gpeVectorObj->Vector);

    //
    // Remove the GPE from the bit-maps.  Fall back to using control method
    // if available.
    //
    removed = ACPIGpeInstallRemoveIndex(
        gpeVectorObj->Vector,
        ACPI_GPE_REMOVE,
        0,
        &(gpeVectorObj->HasControlMethod)
        );
    if (!removed) {

        status = STATUS_UNSUCCESSFUL;

    }

    //
    // Update hardware to match us
    //
    ACPIGpeEnableDisableEvents(TRUE);

    //
    // Unlock tables and return status
    //
    KeReleaseSpinLock (&GpeTableLock, oldIrql);

    //
    // Free the vector object, it's purpose is done.
    //
    if (status == STATUS_SUCCESS) {

        ExFreePool (GpeVectorObject);

    }
    return status;
}

NTSTATUS
ACPIVectorEnable(
    PDEVICE_OBJECT      AcpiDeviceObject,
    PVOID               GpeVectorObject
    )
/*++

Routine Description:

    Enable (a previously disabled) GPE that is already attached to a handler.

Arguments:

    AcpiDeviceObject    - The ACPI device object
    GpeVectorObject     - Pointer to the vector object returned by ACPIGpeConnectVector

Return Value

    Returns status

--*/
{
    KIRQL               oldIrql;
    PGPE_VECTOR_OBJECT  localVectorObject = GpeVectorObject;
    ULONG               bit;
    ULONG               gpeIndex;
    ULONG               gpeRegister;

    //
    // The GPE index was validated when the handler was attached
    //
    gpeIndex = localVectorObject->Vector;
    bit = (1 << (gpeIndex % 8));
    gpeRegister = ACPIGpeIndexToGpeRegister (gpeIndex);

    //
    // Lock the global tables
    //
    KeAcquireSpinLock (&GpeTableLock, &oldIrql);

    //
    // Disable GPEs while we are fussing with the enable bits
    //
    ACPIGpeEnableDisableEvents (FALSE);

    //
    // Enable the GPE in the bit maps.
    //
    GpeEnable [gpeRegister]      |= bit;
    GpeCurEnable [gpeRegister]   |= bit;

    //
    // Update hardware to match us
    //
    ACPIGpeEnableDisableEvents (TRUE);

    //
    // Unlock tables and return status
    //
    KeReleaseSpinLock (&GpeTableLock, oldIrql);
    ACPIPrint( (
        ACPI_PRINT_RESOURCES_2,
        "ACPIVectorEnable: GPE %x enabled\n",
        gpeIndex
        ) );
    return STATUS_SUCCESS;
}

VOID
ACPIVectorFreeEntry (
    ULONG       TableIndex
    )
/*++

Routine Description:

    Free a GPE vector table entry.
    NOTE: Should be called with the global GpeVectorTable locked.

Arguments:

    TableIndex  - Index into GPE vector table of entry to be freed

Return Value:

    NONE

--*/
{
    //
    // Put onto free list
    //
    GpeVectorTable[TableIndex].Next = GpeVectorFree;
    GpeVectorFree = (UCHAR) TableIndex;
}

BOOLEAN
ACPIVectorGetEntry (
    PULONG              TableIndex
    )
/*++

Routine Description:

    Get a new vector entry from the GPE vector table.
    NOTE: Should be called with the global GpeVectorTable locked.

Arguments:

    TableIndex      - Pointer to where the vector table index of the entry is returned

Return Value:

    TRUE - Success
    FALSE - Failure

--*/
{
    PGPE_VECTOR_ENTRY   Vector;
    ULONG               i, j;

#define NEW_TABLE_ENTRIES       4

    if (!GpeVectorFree) {

        //
        // No free entries on vector table, make some
        //
        i = GpeVectorTableSize;
        Vector = ExAllocatePoolWithTag (
            NonPagedPool,
            sizeof (GPE_VECTOR_ENTRY) * (i + NEW_TABLE_ENTRIES),
            ACPI_SHARED_GPE_POOLTAG
            );
        if (Vector == NULL) {

            return FALSE;

        }

        //
        // Make sure that its in a known state
        //
        RtlZeroMemory(
            Vector,
            (sizeof(GPE_VECTOR_ENTRY) * (i + NEW_TABLE_ENTRIES) )
            );

        //
        // Copy old table to new
        //
        if (GpeVectorTable) {

            RtlCopyMemory(
                Vector,
                GpeVectorTable,
                sizeof (GPE_VECTOR_ENTRY) * i
                );
            ExFreePool (GpeVectorTable);

        }

        GpeVectorTableSize += NEW_TABLE_ENTRIES;
        GpeVectorTable = Vector;

        //
        // Link new entries
        //
        for (j=0; j < NEW_TABLE_ENTRIES; j++) {

            GpeVectorTable[i+j].Next = (UCHAR) (i+j+1);

        }

        //
        // The last entry in the list gets pointed to 0, because we then
        // want to grow this list again
        //
        GpeVectorTable[i+j-1].Next = 0;

        //
        // The next free vector the head of the list that we just allocated
        //
        GpeVectorFree = (UCHAR) i;

    }

    *TableIndex = GpeVectorFree;
    Vector = &GpeVectorTable[GpeVectorFree];
    GpeVectorFree = Vector->Next;
    return TRUE;
}

BOOLEAN
ACPIVectorInstall(
    ULONG               GpeIndex,
    PGPE_VECTOR_OBJECT  GpeVectorObject
    )
/*++

Routine Description:

    Install a GPE handler into the Map and Vector tables
    NOTE: Should be called with the global GpeVectorTable locked, and GPEs disabled

Arguments:


Return Value:

    TRUE    - Success
    FALSE   - Failure

--*/
{
    ULONG               byteIndex;
    ULONG               tableIndex;

    //
    // Get an entry in the global vector table
    //
    if (ACPIVectorGetEntry (&tableIndex)) {

        //
        // Install the entry into the map table
        //
        byteIndex = ACPIGpeIndexToByteIndex (GpeIndex);
        GpeMap [byteIndex] = (UCHAR) tableIndex;

        //
        // Install the vector object in the vector table entry
        //
        GpeVectorTable [tableIndex].GpeVectorObject = GpeVectorObject;
        return TRUE;

    }

    return FALSE;
}

BOOLEAN
ACPIVectorRemove(
    ULONG       GpeIndex
    )
/*++

Routine Description:

    Remove a GPE handler from the Map and Vector tables
    NOTE: Should be called with the global GpeVectorTable locked,
    and GPEs disabled

Arguments:


Return Value:

    TRUE    - Success
    FALSE   - Failure

--*/
{
    ULONG               byteIndex;
    ULONG               tableIndex;

    //
    // Get the table index from the map table
    //
    byteIndex = ACPIGpeIndexToByteIndex (GpeIndex);
    tableIndex = GpeMap [byteIndex];

    //
    // Bounds check
    //
    if (tableIndex >= GpeVectorTableSize) {

        return FALSE;

    }

    //
    // Remember that we don't have this GpeVectorObject anymore
    //
    GpeVectorTable[tableIndex].GpeVectorObject = NULL;

    //
    // Free the slot in the master vector table
    //
    ACPIVectorFreeEntry (tableIndex);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\vector.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vector.h

Abstract:

    contains all structures protyptes for connecting external
    vectors to the Gpe Engine

Environment

    Kernel mode only

Revision History:

    03/22/00 - Initial Revision

--*/

#ifndef _VECTOR_H_
#define _VECTOR_H_

    //
    // Object returned by GpeConnectVector
    //
    typedef struct _GPE_VECTOR_OBJECT {
        ULONG                   Vector;
        PGPE_SERVICE_ROUTINE    Handler;
        PVOID                   Context;
        BOOLEAN                 Sharable;
        BOOLEAN                 HasControlMethod;
        KINTERRUPT_MODE         Mode;
    } GPE_VECTOR_OBJECT, *PGPE_VECTOR_OBJECT;

    //
    // Structure of each entry in the global GPE vector table
    //
    typedef struct {
        UCHAR                   Next;
        PGPE_VECTOR_OBJECT      GpeVectorObject;
    } GPE_VECTOR_ENTRY, *PGPE_VECTOR_ENTRY;

    extern PGPE_VECTOR_ENTRY    GpeVectorTable;
    extern UCHAR                GpeVectorFree;
    extern ULONG                GpeVectorTableSize;

    //
    // Action parameter to ACPIGpeInstallRemoveIndex
    //
    #define ACPI_GPE_EDGE_INSTALL       0
    #define ACPI_GPE_LEVEL_INSTALL      1
    #define ACPI_GPE_REMOVE             2

    //
    // Type parameter to ACPIGpeInstallRemoveIndex
    //
    #define ACPI_GPE_HANDLER            0
    #define ACPI_GPE_CONTROL_METHOD     1

    VOID
    ACPIVectorBuildVectorMasks(
        VOID
        );

    NTSTATUS
    ACPIVectorClear(
        PDEVICE_OBJECT      AcpiDeviceObject,
        PVOID               GpeVectorObject
        );

    NTSTATUS
    ACPIVectorConnect(
        PDEVICE_OBJECT          AcpiDeviceObject,
        ULONG                   GpeVector,
        KINTERRUPT_MODE         GpeMode,
        BOOLEAN                 Sharable,
        PGPE_SERVICE_ROUTINE    ServiceRoutine,
        PVOID                   ServiceContext,
        PVOID                   *GpeVectorObject
        );

    NTSTATUS
    ACPIVectorDisable(
        PDEVICE_OBJECT      AcpiDeviceObject,
        PVOID               GpeVectorObject
        );

    NTSTATUS
    ACPIVectorDisconnect(
        PVOID                   GpeVectorObject
        );

    NTSTATUS
    ACPIVectorEnable(
        PDEVICE_OBJECT      AcpiDeviceObject,
        PVOID               GpeVectorObject
        );

    VOID
    ACPIVectorFreeEntry (
        ULONG       TableIndex
        );

    BOOLEAN
    ACPIVectorGetEntry (
        PULONG              TableIndex
        );

    BOOLEAN
    ACPIVectorInstall(
        ULONG               GpeIndex,
        PGPE_VECTOR_OBJECT  GpeVectorObject
        );

    BOOLEAN
    ACPIVectorRemove(
        ULONG       GpeIndex
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\wmilog.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Wmilog.h

Abstract:

    This module contains Wmi loging support

Author:

    Hanumant Yadav (hanumany)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _WMILOG_H_
#define _WMILOG_H_

#ifdef WMI_TRACING
    #define ACPIWMILOGEVENT(a1) {ACPIWmiLogEvent a1;}
#else
    #define ACPIWMILOGEVENT(a1)
#endif

#ifdef WMI_TRACING

//
// Defines
//

#define AMLI_LOG_GUID 0x0

#define ACPI_TRACE_MOF_FILE     L"ACPIMOFResource"

//
// Globals
//
extern GUID        GUID_List[];



extern ULONG       ACPIWmiTraceEnable;
extern ULONG       ACPIWmiTraceGlobalEnable;
extern TRACEHANDLE ACPIWmiLoggerHandle;
// End Globals

//
// Structures
//
typedef struct 
{
    EVENT_TRACE_HEADER  Header;
    MOF_FIELD           Data;
} WMI_LOG_DATA, *PWMI_LOG_DATA;




//
// Function Prototypes
//

VOID 
ACPIWmiInitLog(
    IN  PDEVICE_OBJECT ACPIDeviceObject
    );

VOID 
ACPIWmiUnRegisterLog(
    IN  PDEVICE_OBJECT ACPIDeviceObject
    );

NTSTATUS
ACPIWmiRegisterGuids(
    IN  PWMIREGINFO     WmiRegInfo,
    IN  ULONG           wmiRegInfoSize,
    IN  PULONG          pReturnSize
    );


VOID
ACPIGetWmiLogGlobalHandle(
    VOID
    );

NTSTATUS
ACPIWmiEnableLog(
    IN  PVOID           Buffer,
    IN  ULONG           BufferSize
    );


NTSTATUS
ACPIWmiDisableLog(
    VOID
    );

NTSTATUS
ACPIWmiLogEvent(
    IN UCHAR    LogLevel,
    IN UCHAR    LogType,
    IN GUID     LogGUID,
    IN PUCHAR   Format, 
    IN ...
    );

NTSTATUS
ACPIDispatchWmiLog(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

#endif //WMI_TRACING

#endif // _WMILOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\worker.c ===
/*
 *  Worker thread functions
 *
 *
 */

#include "pch.h"

KSPIN_LOCK      ACPIWorkerSpinLock;
WORK_QUEUE_ITEM ACPIWorkItem;
LIST_ENTRY      ACPIDeviceWorkQueue;
BOOLEAN         ACPIWorkerBusy;

KEVENT          ACPIWorkToDoEvent;
KEVENT          ACPITerminateEvent;
LIST_ENTRY      ACPIWorkQueue;
HANDLE          ACPIThread;

VOID
ACPIWorkerThread (
    IN PVOID    Context
    );

VOID
ACPIWorker(
    IN PVOID StartContext
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ACPIInitializeWorker)
#endif

VOID
ACPIInitializeWorker (
    VOID
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ThreadHandle;
    PETHREAD *Thread;

    KeInitializeSpinLock (&ACPIWorkerSpinLock);
    ExInitializeWorkItem (&ACPIWorkItem, ACPIWorkerThread, NULL);
    InitializeListHead (&ACPIDeviceWorkQueue);

    //
    // Initialize the ACPI worker thread. This thread is for use by the AML
    // interpreter and must not page-fault or have its stack swapped.
    //
    KeInitializeEvent(&ACPIWorkToDoEvent, NotificationEvent, FALSE);
    KeInitializeEvent(&ACPITerminateEvent, NotificationEvent, FALSE);
    InitializeListHead(&ACPIWorkQueue);

    //
    // Create the worker thread
    //
    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, NULL, NULL);
    Status = PsCreateSystemThread(&ThreadHandle,
                                  THREAD_ALL_ACCESS,
                                  &ObjectAttributes,
                                  0,
                                  NULL,
                                  ACPIWorker,
                                  NULL);
    if (Status != STATUS_SUCCESS) {

        ACPIInternalError( ACPI_WORKER );

    }

    Status = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_ALL_ACCESS,
                                        NULL,
                                        KernelMode,
                                        (PVOID *)&Thread,
                                        NULL);

    if (Status != STATUS_SUCCESS) {

        ACPIInternalError( ACPI_WORKER );

    }
}


VOID
ACPISetDeviceWorker (
    IN PDEVICE_EXTENSION    DevExt,
    IN ULONG                Events
    )
{
    BOOLEAN         QueueWorker;
    KIRQL           OldIrql;

    //
    // Synchronize with worker thread
    //

    KeAcquireSpinLock (&ACPIWorkerSpinLock, &OldIrql);
    QueueWorker = FALSE;

    //
    // Set the devices pending events
    //

    DevExt->WorkQueue.PendingEvents |= Events;

    //
    // If this device is not being processed, start now
    //

    if (!DevExt->WorkQueue.Link.Flink) {
        //
        // Queue to worker thread
        //

        InsertTailList (&ACPIDeviceWorkQueue, &DevExt->WorkQueue.Link);
        QueueWorker = !ACPIWorkerBusy;
        ACPIWorkerBusy = TRUE;
    }

    //
    // Drop lock, and if needed get a worker thread
    //

    KeReleaseSpinLock (&ACPIWorkerSpinLock, OldIrql);
    if (QueueWorker) {
        ExQueueWorkItem (&ACPIWorkItem, DelayedWorkQueue);
    }
}

VOID
ACPIWorkerThread (
    IN PVOID    Context
    )
{
    KIRQL               OldIrql;
    PDEVICE_EXTENSION   DevExt;
    ULONG               Events;
    PLIST_ENTRY         Link;

    KeAcquireSpinLock (&ACPIWorkerSpinLock, &OldIrql);
    ACPIWorkerBusy = TRUE;

    //
    // Loop and handle each queue device
    //

    while (!IsListEmpty(&ACPIDeviceWorkQueue)) {
        Link = ACPIDeviceWorkQueue.Flink;
        RemoveEntryList (Link);
        Link->Flink = NULL;

        DevExt = CONTAINING_RECORD (Link, DEVICE_EXTENSION, WorkQueue.Link);

        //
        // Dispatch the pending events
        //

        Events = DevExt->WorkQueue.PendingEvents;
        DevExt->WorkQueue.PendingEvents = 0;

        KeReleaseSpinLock (&ACPIWorkerSpinLock, OldIrql);
        DevExt->DispatchTable->Worker (DevExt, Events);
        KeAcquireSpinLock (&ACPIWorkerSpinLock, &OldIrql);
    }

    ACPIWorkerBusy = FALSE;
    KeReleaseSpinLock (&ACPIWorkerSpinLock, OldIrql);
}

#if DBG

EXCEPTION_DISPOSITION
ACPIWorkerThreadFilter(
    IN PWORKER_THREAD_ROUTINE WorkerRoutine,
    IN PVOID Parameter,
    IN PEXCEPTION_POINTERS ExceptionInfo
    )
{
    KdPrint(("ACPIWORKER: exception in worker routine %lx(%lx)\n", WorkerRoutine, Parameter));
    KdPrint(("  exception record at %lx\n", ExceptionInfo->ExceptionRecord));
    KdPrint(("  context record at %lx\n",ExceptionInfo->ContextRecord));

    try {
        DbgBreakPoint();

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // No kernel debugger attached, so let the system thread
        // exception handler call KeBugCheckEx.
        //
        return(EXCEPTION_CONTINUE_SEARCH);
    }

    return(EXCEPTION_EXECUTE_HANDLER);
}
#endif

typedef enum _ACPI_WORKER_OBJECT {
    ACPIWorkToDo,
    ACPITerminate,
    ACPIMaximumObject
} ACPI_WORKER_OBJECT;

VOID
ACPIWorker(
    IN PVOID StartContext
    )
{
    PLIST_ENTRY Entry;
    WORK_QUEUE_TYPE QueueType;
    PWORK_QUEUE_ITEM WorkItem;
    KIRQL OldIrql;
    NTSTATUS Status;
    static KWAIT_BLOCK WaitBlockArray[ACPIMaximumObject];
    PVOID WaitObjects[ACPIMaximumObject];

    ACPIThread = PsGetCurrentThread ();

    //
    // Wait for the modified page writer event AND the PFN mutex.
    //

    WaitObjects[ACPIWorkToDo] = (PVOID)&ACPIWorkToDoEvent;
    WaitObjects[ACPITerminate] = (PVOID)&ACPITerminateEvent;

    //
    // Loop forever waiting for a work queue item, calling the processing
    // routine, and then waiting for another work queue item.
    //

    do {

        //
        // Wait until something is put in the queue.
        //
        // By specifying a wait mode of KernelMode, the thread's kernel stack is
        // not swappable
        //


        Status = KeWaitForMultipleObjects(ACPIMaximumObject,
                                          &WaitObjects[0],
                                          WaitAny,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL,
                                          &WaitBlockArray[0]);

        //
        // Switch on the wait status.
        //

        switch (Status) {

        case ACPIWorkToDo:
                break;

        case ACPITerminate:
                // Stephane - you need to clear out any pending requests,
                // wake people up, etc.  here.
                //
                // Also make sure you free up any allocated pool, etc.

                PsTerminateSystemThread (STATUS_SUCCESS);
                break;

        default:
                break;
        }

        KeAcquireSpinLock(&ACPIWorkerSpinLock, &OldIrql);
        ASSERT(!IsListEmpty(&ACPIWorkQueue));
        Entry = RemoveHeadList(&ACPIWorkQueue);

        if (IsListEmpty(&ACPIWorkQueue)) {
            KeClearEvent(&ACPIWorkToDoEvent);
        }
        KeReleaseSpinLock(&ACPIWorkerSpinLock, OldIrql);

        WorkItem = CONTAINING_RECORD(Entry, WORK_QUEUE_ITEM, List);

        //
        // Execute the specified routine.
        //

#if DBG

        try {

            PVOID WorkerRoutine;
            PVOID Parameter;

            WorkerRoutine = WorkItem->WorkerRoutine;
            Parameter = WorkItem->Parameter;
            (WorkItem->WorkerRoutine)(WorkItem->Parameter);
            if (KeGetCurrentIrql() != 0) {

                ACPIPrint( (
                    ACPI_PRINT_CRITICAL,
                    "ACPIWORKER: worker exit at IRQL %d, worker routine %x, "
                    "parameter %x, item %x\n",
                    KeGetCurrentIrql(),
                    WorkerRoutine,
                    Parameter,
                    WorkItem
                    ) );
                DbgBreakPoint();

            }

        } except( ACPIWorkerThreadFilter(WorkItem->WorkerRoutine,
                                         WorkItem->Parameter,
                                         GetExceptionInformation() )) {
        }

#else

        (WorkItem->WorkerRoutine)(WorkItem->Parameter);
        if (KeGetCurrentIrql() != 0) {
            KeBugCheckEx(
                IRQL_NOT_LESS_OR_EQUAL,
                (ULONG_PTR)WorkItem->WorkerRoutine,
                (ULONG_PTR)KeGetCurrentIrql(),
                (ULONG_PTR)WorkItem->WorkerRoutine,
                (ULONG_PTR)WorkItem
                );
            }
#endif

    } while(TRUE);
}

VOID
OSQueueWorkItem(
    IN PWORK_QUEUE_ITEM WorkItem
    )

/*++

Routine Description:

    This function inserts a work item into a work queue that is processed
    by the ACPI worker thread

Arguments:

    WorkItem - Supplies a pointer to the work item to add the the queue.
        This structure must be located in NonPagedPool. The work item
        structure contains a doubly linked list entry, the address of a
        routine to call and a parameter to pass to that routine.

Return Value:

    None

--*/

{
    KIRQL OldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Insert the work item
    //
    KeAcquireSpinLock(&ACPIWorkerSpinLock, &OldIrql);
    if (IsListEmpty(&ACPIWorkQueue)) {
        KeSetEvent(&ACPIWorkToDoEvent, 0, FALSE);
    }
    InsertTailList(&ACPIWorkQueue, &WorkItem->List);
    KeReleaseSpinLock(&ACPIWorkerSpinLock, OldIrql);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpienbl.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpienbl.c

Abstract:

    This module contains functions to put an ACPI machine in ACPI mode.

Author:

    Jason Clark (jasoncl)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _ACPIENBL_H_
#define _ACPIENBL_H_

    VOID
    ACPIEnableEnterACPIMode(
        VOID
        );

    VOID
    ACPIEnableInitializeACPI(
        IN  BOOLEAN ReEnable
        );

    VOID
    ACPIEnablePMInterruptOnly(
        VOID
        );

    ULONG
    ACPIEnableQueryFixedEnables(
        VOID
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\nt\worker.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    butt.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/


#ifndef _WORKER_H_
#define _WORKER_H_

VOID
ACPIInitializeWorker (
    VOID
    );

VOID
ACPISetDeviceWorker (
    IN PDEVICE_EXTENSION    DevExt,
    IN ULONG                Events
    );

#endif _WORKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpictl.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpictl.c

Abstract:

    This module handles all of the INTERNAL_DEVICE_CONTROLS requested to
    the ACPI driver

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Mode Driver only

--*/

#ifndef _ACPICTL_H_
#define _ACPICTL_H_

NTSTATUS
ACPIIoctlAcquireGlobalLock(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    );

NTSTATUS
ACPIIoctlAsyncEvalControlMethod(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    );

VOID EXPORT
ACPIIoctlAsyncEvalControlMethodCompletion(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    );

NTSTATUS
ACPIIoctlCalculateOutputBuffer(
    IN  POBJDATA                ObjectData,
    IN  PACPI_METHOD_ARGUMENT   Argument,
    IN  BOOLEAN                 TopLevel
    );

NTSTATUS
ACPIIoctlCalculateOutputBufferSize(
    IN  POBJDATA                ObjectData,
    IN  PULONG                  BufferSize,
    IN  PULONG                  BufferCount,
    IN  BOOLEAN                 TopLevel
    );

NTSTATUS
ACPIIoctlEvalControlMethod(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    );

NTSTATUS
ACPIIoctlEvalPostProcessing(
    IN  PIRP        Irp,
    IN  POBJDATA    ObjectData
    );

NTSTATUS
ACPIIoctlEvalPreProcessing(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack,
    IN  POOL_TYPE           PoolType,
    OUT PNSOBJ              *MethodObject,
    OUT POBJDATA            *ResultData,
    OUT POBJDATA            *ArgumentData,
    OUT ULONG               *ArgumentCount
    );

NTSTATUS
ACPIIoctlRegisterOpRegionHandler(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    );

NTSTATUS
ACPIIoctlReleaseGlobalLock(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    );

NTSTATUS
ACPIIoctlUnRegisterOpRegionHandler(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    );

NTSTATUS
ACPIIrpDispatchDeviceControl(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpienbl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpienbl.c

Abstract:

    This module contains functions to put an ACPI machine in ACPI mode.

Author:

    Jason Clark (jasoncl)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"


VOID
ACPIEnableEnterACPIMode (
    VOID
    )
/*++

Routine Description:

    This routine is called to enter ACPI mode

Arguments:

    None

Return Value:

    None

--*/
{

    ULONG   i;

    ASSERTMSG(
        "ACPIEnableEnterACPIMode: System already in ACPI mode!\n",
        !(READ_PM1_CONTROL() & PM1_SCI_EN)
        );

    //
    // Let the world know about this
    //
    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPIEnableEnterACPIMode: Enabling ACPI\n"
        ) );

    //
    // Write the magic value to the port
    //

    WRITE_ACPI_REGISTER(SMI_CMD, 0,
            AcpiInformation->FixedACPIDescTable->acpi_on_value);

    //
    // Make sure that we see that PM1 is in fact enabled
    //
    for (i = 0; ; i++) {

        if ( (READ_PM1_CONTROL() & PM1_SCI_EN) ) {

            break;

        }
        if (i > 0xFFFFFF) {

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_SYSTEM_CANNOT_START_ACPI,
                6,
                0,
                0
                );

        }

    }
}

VOID
ACPIEnableInitializeACPI(
    IN BOOLEAN ReEnable
    )
/*++

Routine Description:

    A function to put an ACPI machine into ACPI mode.  This function should be
    called with the SCI IRQ masked since we cannot set the interrupt enable
    mask until after enabling ACPI.  The SCI should be unmasked by the caller
    when the call returns.

    General Sequence:
        Enable ACPI through the SMI command port
        Clear the PM1_STS register to put it in a known state
        Set the PM1_EN register mask
        Build the GP mask
        Clear the GP status register bits which belong to the GP mask
        Set the GP enable register bits according to the GP mask built above
        Set the PM1_CTRL register bits.

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    USHORT contents;
    USHORT clearbits;

    //
    // Read PM1_CTRL, if SCI_EN is already set then this is an ACPI only machine
    // and we do not need to Enable ACPI
    //
    if ( !(READ_PM1_CONTROL() & PM1_SCI_EN) )   {

        AcpiInformation->ACPIOnly = FALSE;
        ACPIEnableEnterACPIMode();

    }

    //
    // Put the pm1 status registers into a known state. We will allow the Bus
    // Master bit to be enabled (if we have no choice) across this reset. I do
    // not pretend to understand this code
    //
    CLEAR_PM1_STATUS_REGISTER();
    contents = (USHORT)(READ_PM1_STATUS() & ~(PM1_BM_STS | PM1_RTC_STS));
    if (contents)   {

        CLEAR_PM1_STATUS_REGISTER();
        contents = (USHORT)(READ_PM1_STATUS() & ~(PM1_BM_STS | PM1_RTC_STS));

    }
    ASSERTMSG(
        "ACPIEnableInitializeACPI: Cannot clear PM1 Status Register\n",
        (contents == 0)
        );

    //
    // We determined what the PM1 enable bits are when we processed the FADT.
    // We should now enable those bits
    //
    WRITE_PM1_ENABLE( AcpiInformation->pm1_en_bits );
    ASSERTMSG(
        "ACPIEnableInitializeACPI: Cannot write all PM1 Enable Bits\n",
        (READ_PM1_ENABLE() == AcpiInformation->pm1_en_bits)
        );

    //
    // This is called when we renable ACPI after having woken up from sleep
    // or hibernate
    //
    if (ReEnable) {

        //
        // Re-enable all possible GPE events
        //
        ACPIGpeClearRegisters();
        ACPIGpeEnableDisableEvents( TRUE );

    }

    //
    // Calculate the bits that we should clear. These are the
    // sleep enable bit and the bus master bit.
    //
    // [vincentg] - the original implementation cleared SLP_TYP as well -
    // this breaks C2/C3 on Intel PIIX4 chipsets.  Updated to only clear
    // SLP_EN and BM_RLD.
    //

    clearbits = ((0x8 << SLP_TYP_POS) | PM1_BM_RLD);

    //
    // Read the PM1 control registery, clear the unwanted bits and then
    // write it back
    //
    contents = (READ_PM1_CONTROL() & ~clearbits);
    WRITE_PM1_CONTROL ( contents, TRUE, WRITE_REGISTER_A_AND_B );
}

VOID
ACPIEnablePMInterruptOnly(
    VOID
    )
/*++

Routine Descrition:

    Enable interrupts in the ACPI controller

Arguments:

    None

Return Value:

    None

--*/
{
    WRITE_PM1_ENABLE(AcpiInformation->pm1_en_bits);
}

ULONG
ACPIEnableQueryFixedEnables (
    VOID
    )
/*++

Routine Descrition:

    Returns the enable mask

Arguments:

    None

Return Value:

    None

--*/
{
    return AcpiInformation->pm1_en_bits;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpigpio.c ===
/*
 *  ACPIGPIO.C -- ACPI OS Independent functions for low-level General-Purpose Event register I/O.
 *
 *  Notes:
 *
 *      This file provides OS independent functions that are called to read/write the GPE registers,
 *      perform index <--> register translation, and to validate index values.
 *
 *      This is the only place where the GPE0 and GPE1 blocks are differentiated.
 *
 */

#include "pch.h"


UCHAR
ACPIReadGpeStatusRegister (
    ULONG           Register
    )
/*++

Routine Description:

    Read a GPE status register.  Differentiation between GP0 and GP1 is
    handled here.

Arguments:

    Register    - The GPE status register to read.  Registers are numbered sequentially,
                  GP0 block first, then GP1 block appended.
Return Value:

    The value of the status register

--*/
{
    return (UCHAR) READ_ACPI_REGISTER(GP_STATUS, Register);
}


VOID
ACPIWriteGpeStatusRegister (
    ULONG           Register,
    UCHAR           Value
    )
/*++

Routine Description:

    Write a GPE status register.  Differentiation between GP0 and GP1 is
    handled here.

Arguments:

    Register    - The GPE status register to write.  Registers are numbered sequentially,
                  GP0 block first, then GP1 block appended.
    Value       - The value to be written

Return Value:

    None

--*/
{
    WRITE_ACPI_REGISTER(GP_STATUS, Register, (USHORT) Value);
}


VOID
ACPIWriteGpeEnableRegister (
    ULONG           Register,
    UCHAR           Value
    )
/*++

Routine Description:

    Write a GPE Enable register.  Differentiation between GP0 and GP1 is
    handled here.

Arguments:

    Register    - The GPE enable register to write.  Registers are numbered sequentially,
                  GP0 block first, then GP1 block appended.
    Value       - The value to be written

Return Value:

    None

--*/
{
    ACPIPrint( (
        ACPI_PRINT_DPC,
        "ACPIWriteGpeEnableRegister: Writing GPE Enable register %x = %x\n",
        Register, Value
        ) );

    WRITE_ACPI_REGISTER(GP_ENABLE, Register, (USHORT) Value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpictl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpictl.c

Abstract:

    This module handles all of the INTERNAL_DEVICE_CONTROLS requested to
    the ACPI driver

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Mode Driver only

Revision History:

    01-05-98 - SGP - Complete Rewrite
    01-13-98 - SGP - Cleaned up the Eval Post-Processing

--*/

#include "pch.h"

NTSTATUS
ACPIIoctlAcquireGlobalLock(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This routine acquires the global lock for another device driver

Arguments:

    DeviceObject    - The device object stack that wants the lock
    Irp             - The irp with the request in it
    Irpstack        - The current stack within the irp

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                            status;
    PACPI_GLOBAL_LOCK                   newLock;
    PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER outputBuffer;
    ULONG                               outputLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Remember that we don't be returning any data
    //
    Irp->IoStatus.Information = 0;

    //
    // Is the irp have a minimum size buffer?
    //
    if (outputLength < sizeof(ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER) ) {

        status = STATUS_INFO_LENGTH_MISMATCH;
        goto ACPIIoctlAcquireGlobalLockExit;

    }

    //
    // Grab a pointer at the input buffer
    //
    outputBuffer = (PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER)
        Irp->AssociatedIrp.SystemBuffer;
    if (outputBuffer->Signature != ACPI_ACQUIRE_GLOBAL_LOCK_SIGNATURE) {

        status = STATUS_INVALID_PARAMETER_1;
        goto ACPIIoctlAcquireGlobalLockExit;

    }

    //
    // Allocate storage for the lock
    //
    newLock = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(ACPI_GLOBAL_LOCK),
        'LcpA'
        );
    if (newLock == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIIoctlAcquireGlobalLockExit;

    }
    RtlZeroMemory( newLock, sizeof(ACPI_GLOBAL_LOCK) );

    //
    // Initialize the new lock and the request
    //
    outputBuffer->LockObject = newLock;
    Irp->IoStatus.Information = sizeof(ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER);
    newLock->LockContext = Irp;
    newLock->Type = ACPI_GL_QTYPE_IRP;

    //
    // Mark the irp as pending, since we can block while acquire the lock
    //
    IoMarkIrpPending( Irp );

    //
    // Request the lock now
    //
    status = ACPIAsyncAcquireGlobalLock( newLock );
    if (status == STATUS_PENDING) {

        return status;

    }
ACPIIoctlAcquireGlobalLockExit:

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;

}

NTSTATUS
ACPIIoctlAsyncEvalControlMethod(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This routine is called to handle a control method request asynchronously

Arguments:

    DeviceObject    - The device object to run the method on
    Irp             - The irp with the request in it
    IrpStack        - THe current stack within the Irp

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PNSOBJ      methodObject;
    POBJDATA    argumentData = NULL;
    POBJDATA    resultData = NULL;
    ULONG       argumentCount = 0;

    //
    // Do the pre processing on the irp
    //
    status = ACPIIoctlEvalPreProcessing(
        DeviceObject,
        Irp,
        IrpStack,
        NonPagedPool,
        &methodObject,
        &resultData,
        &argumentData,
        &argumentCount
        );
    if (!NT_SUCCESS(status)) {

        goto ACPIIoctlAsyncEvalControlMethodExit;

    }

    //
    // At this point, we can run the async method
    //
    status = AMLIAsyncEvalObject(
        methodObject,
        resultData,
        argumentCount,
        argumentData,
        ACPIIoctlAsyncEvalControlMethodCompletion,
        Irp
        );

    //
    // We no longer need the arguments now. Note, that we should clean up
    // the argument list because it contains pointer to another block of
    // allocated data. Freeing something in the middle of the block would be
    // very bad.
    //
    if (argumentData != NULL) {

        ExFreePool( argumentData );
        argumentData = NULL;

    }

    //
    // Check the return data now
    //
    if (status == STATUS_PENDING) {

        return status;

    } else if (NT_SUCCESS(status)) {

        //
        // Do the post processing ourselves
        //
        status = ACPIIoctlEvalPostProcessing(
            Irp,
            resultData
            );
        AMLIFreeDataBuffs( resultData, 1 );

    }

ACPIIoctlAsyncEvalControlMethodExit:

    //
    // No longer need this data
    //
    if (resultData != NULL) {

        ExFreePool( resultData );

    }

    //
    // If we got here, then we must complete the irp and return
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

VOID EXPORT
ACPIIoctlAsyncEvalControlMethodCompletion(
    IN  PNSOBJ          AcpiObject,
    IN  NTSTATUS        Status,
    IN  POBJDATA        ObjectData,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This routine is called after the interpreter has had a chance to run
    the method

Arguments:

    AcpiObject  - The object that the method was run on
    Status      - The status of the eval
    ObjectData  - The result of the eval
    Context     - Specific to the caller

Return Value:

    NTSTATUS

--*/
{
    PIRP        irp = (PIRP) Context;

    //
    // Did we succeed the request?
    //
    if (NT_SUCCESS(Status)) {

        //
        // Do the work now
        //
        Status = ACPIIoctlEvalPostProcessing(
            irp,
            ObjectData
            );
        AMLIFreeDataBuffs( ObjectData, 1 );

    }

    //
    // No longer need this data
    //
    ExFreePool( ObjectData );

    //
    // If our completion routine got called, then AMLIAsyncEvalObject returned
    // STATUS_PENDING. Be sure to mark the IRP pending before we complete it.
    //
    IoMarkIrpPending(irp);

    //
    // Complete the request
    //
    irp->IoStatus.Status = Status;
    IoCompleteRequest( irp, IO_NO_INCREMENT );

}

NTSTATUS
ACPIIoctlCalculateOutputBuffer(
    IN  POBJDATA                ObjectData,
    IN  PACPI_METHOD_ARGUMENT   Argument,
    IN  BOOLEAN                 TopLevel
    )
/*++

Routine Description:

    This function is called to fill the contents of Argument with the
    information provided by the ObjectData. This function is recursive.

    It assumes that the correct amount of storage was allocated for Argument.

    Note:  To add the ability to return nested packages without breaking W2K
           behavior, the outermost package is not part of the output buffer.
           I.e. anything that was a package will have its outermost
           ACPI_EVAL_OUTPUT_BUFFER.Count be more than 1.

Arguments:

    ObjectData  - The information that we need to propogate
    Argument    - The location to propogate that information
    TopLevel    - Indicates whether we are at the top level of recursion

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    POBJDATA    objData;
    PPACKAGEOBJ package;
    ULONG       count;
    ULONG       packageCount;
    ULONG       packageSize;
    PACPI_METHOD_ARGUMENT packageArgument;

    ASSERT( Argument );

    //
    // Fill in the output buffer arguments
    //
    if (ObjectData->dwDataType == OBJTYPE_INTDATA) {

        Argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        Argument->DataLength = sizeof(ULONG);
        Argument->Argument = (ULONG) ObjectData->uipDataValue;

    } else if (ObjectData->dwDataType == OBJTYPE_STRDATA ||
        ObjectData->dwDataType == OBJTYPE_BUFFDATA) {

        Argument->Type = (ObjectData->dwDataType == OBJTYPE_STRDATA ?
            ACPI_METHOD_ARGUMENT_STRING : ACPI_METHOD_ARGUMENT_BUFFER);
        Argument->DataLength = (USHORT)ObjectData->dwDataLen;
        RtlCopyMemory(
            Argument->Data,
            ObjectData->pbDataBuff,
            ObjectData->dwDataLen
            );

    } else if (ObjectData->dwDataType == OBJTYPE_PKGDATA) {

        package = (PPACKAGEOBJ) ObjectData->pbDataBuff;

        //
        // Get the size of the space necessary to store a package's
        // data.  We are really only interested in the amount of
        // data the package will consume *without* its header
        // information.  Passing TRUE as the last parameter will
        // give us that.
        //

        packageSize = 0;
        packageCount = 0;
        status = ACPIIoctlCalculateOutputBufferSize(ObjectData,
                                                    &packageSize,
                                                    &packageCount,
                                                    TRUE);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        ASSERT(packageCount == package->dwcElements);

        if (!TopLevel) {
            //
            // Create a package argument.
            //

            Argument->Type = ACPI_METHOD_ARGUMENT_PACKAGE;
            Argument->DataLength = (USHORT)packageSize;

            packageArgument = (PACPI_METHOD_ARGUMENT)
                ((PUCHAR)Argument + FIELD_OFFSET(ACPI_METHOD_ARGUMENT, Data));

        } else {

            packageArgument = Argument;
        }

        for (count = 0; count < package->dwcElements; count++) {

            objData = &(package->adata[count]);
            status = ACPIIoctlCalculateOutputBuffer(
                objData,
                packageArgument,
                FALSE
                );
            if (!NT_SUCCESS(status)) {
                return status;
            }

            //
            // Point to the next argument
            //

            packageArgument = ACPI_METHOD_NEXT_ARGUMENT(packageArgument);
        }

    } else {

        //
        // We don't understand this data type, we won't return anything
        //
        return STATUS_ACPI_INVALID_DATA;

    }

    //
    // Success
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIIoctlCalculateOutputBufferSize(
    IN  POBJDATA            ObjectData,
    IN  PULONG              BufferSize,
    IN  PULONG              BufferCount,
    IN  BOOLEAN             TopLevel
    )
/*++

Routine Description:

    This routine (recursively) calculates the amount of buffer space required
    to hold the flattened contents of ObjectData. This information is returned
    in BufferSize data location...

    If the ObjectData structure contains information that cannot be expressed
    to the user, then this routine will return a failure code.

Arguments:

    ObjectData  - The object whose size we have to calculate
    BufferSize  - Where to put that size
    BufferCount - The number of elements that we are allocating for

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    POBJDATA    objData;
    PPACKAGEOBJ package;
    ULONG       bufferLength;
    ULONG       count;
    ULONG       packageCount;
    ULONG       dummyCount;

    //
    // Determine how much buffer space is required to hold the
    // flattened data structure
    //
    if (ObjectData->dwDataType == OBJTYPE_INTDATA) {

        bufferLength = ACPI_METHOD_ARGUMENT_LENGTH( sizeof(ULONG) );
        *BufferCount = 1;

    } else if (ObjectData->dwDataType == OBJTYPE_STRDATA ||
        ObjectData->dwDataType == OBJTYPE_BUFFDATA) {

        bufferLength = ACPI_METHOD_ARGUMENT_LENGTH( ObjectData->dwDataLen );
        *BufferCount = 1;

    } else if (ObjectData->dwDataType == OBJTYPE_PKGDATA) {

        //
        // Remember that walking the package means that we have accounted for
        // the length of the package and the number of elements within the
        // package
        //
        packageCount = 0;

        //
        // Walk the package
        //
        package = (PPACKAGEOBJ) ObjectData->pbDataBuff;

        if (!TopLevel) {

            //
            // Packages are contained in an ACPI_METHOD_ARGUMENT structure.
            // So add enough for the overhead of one of these before looking
            // at the children.
            //
            bufferLength = FIELD_OFFSET(ACPI_METHOD_ARGUMENT, Data);
            *BufferCount = 1;

        } else {

            bufferLength = 0;
            *BufferCount = package->dwcElements;
        }

        for (count = 0; count < package->dwcElements; count++) {

            objData = &(package->adata[count]);
            status = ACPIIoctlCalculateOutputBufferSize(
                objData,
                BufferSize,
                &dummyCount,
                FALSE
                );

            if (!NT_SUCCESS(status)) {
                return status;
            }
        }

    } else if (ObjectData->dwDataType == OBJTYPE_UNKNOWN) {

        *BufferCount = 1;
        bufferLength = 0;

    } else {

        //
        // We don't understand this data type, so we won't return anything
        //
        ASSERT(FALSE);
        return STATUS_ACPI_INVALID_DATA;
    }

    //
    // Update the package lengths
    //
    ASSERT( BufferSize && BufferCount );
    *BufferSize += bufferLength;

    return STATUS_SUCCESS;
}

NTSTATUS
ACPIIoctlEvalControlMethod(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This routine is called to handle a control method request synchronously

Arguments:

    DeviceObject    - The device object to run the method on
    Irp             - The irp with the request in it
    IrpStack        - THe current stack within the Irp

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PNSOBJ      methodObject;
    POBJDATA    argumentData = NULL;
    POBJDATA    resultData = NULL;
    ULONG       argumentCount = 0;

    //
    // Do the pre processing on the irp
    //
    status = ACPIIoctlEvalPreProcessing(
        DeviceObject,
        Irp,
        IrpStack,
        PagedPool,
        &methodObject,
        &resultData,
        &argumentData,
        &argumentCount
        );
    if (!NT_SUCCESS(status)) {

        goto ACPIIoctlEvalControlMethodExit;

    }

    //
    // At this point, we can run the async method
    //
    status = AMLIEvalNameSpaceObject(
        methodObject,
        resultData,
        argumentCount,
        argumentData
        );

    //
    // We no longer need the arguments now
    //
    if (argumentData != NULL) {

        ExFreePool( argumentData );
        argumentData = NULL;

    }

    //
    // Check the return data now and fake a call to the completion routine
    //
    if (NT_SUCCESS(status)) {

        //
        // Do the post processing now
        //
        status = ACPIIoctlEvalPostProcessing(
            Irp,
            resultData
            );
        AMLIFreeDataBuffs( resultData, 1 );

    }

ACPIIoctlEvalControlMethodExit:

    //
    // No longer need this data
    //
    if (resultData != NULL) {

        ExFreePool( resultData );

    }

    //
    // If we got here, then we must complete the irp and return
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

NTSTATUS
ACPIIoctlEvalPostProcessing(
    IN  PIRP        Irp,
    IN  POBJDATA    ObjectData
    )
/*++

Routine Description:

    This routine handles convering the ObjectData into information
    that can be passed back into the irp.

    N.B. This routine does *not* complete the irp. The caller must
    do that. This routine is also *not* pageable

Arguments:

    Irp         - The irp that will hold the results
    ObjectData  - The result to convert

Return Value:

    NTSTATUS    - Same as in Irp->IoStatus.Status

--*/
{
    NTSTATUS                    status;
    PACPI_EVAL_OUTPUT_BUFFER    outputBuffer;
    PACPI_METHOD_ARGUMENT       arg;
    PIO_STACK_LOCATION          irpStack = IoGetCurrentIrpStackLocation( Irp );
    ULONG                       bufferLength = 0;
    ULONG                       outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ULONG                       packageCount = 0;

    //
    // If we don't have an output buffer, then we can complete the request
    //
    if (outputLength == 0) {

        Irp->IoStatus.Information = 0;
        return STATUS_SUCCESS;

    }

    //
    // Count the amount of space taken up by the flattened data and how many
    // elements of data are contained therein
    //
    bufferLength = 0;
    packageCount = 0;
    status = ACPIIoctlCalculateOutputBufferSize(
        ObjectData,
        &bufferLength,
        &packageCount,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        //
        // We don't understand a data type in the handling of the data, so
        // we won't return anything
        //
        Irp->IoStatus.Information = 0;
        return STATUS_SUCCESS;

    }

    //
    // Add in the fudge factor that we need to account for the Output buffer
    //
    bufferLength += (sizeof(ACPI_EVAL_OUTPUT_BUFFER) -
        sizeof(ACPI_METHOD_ARGUMENT) );

    if (bufferLength < sizeof(ACPI_EVAL_OUTPUT_BUFFER)) {
        bufferLength = sizeof(ACPI_EVAL_OUTPUT_BUFFER);
    }

    //
    // Setup the Output buffer
    //
    if (outputLength >= sizeof(ACPI_EVAL_OUTPUT_BUFFER)) {

        outputBuffer = (PACPI_EVAL_OUTPUT_BUFFER) Irp->AssociatedIrp.SystemBuffer;
        outputBuffer->Signature = ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE;
        outputBuffer->Length = bufferLength;
        outputBuffer->Count = packageCount;
        arg = outputBuffer->Argument;

    }

    //
    // Make sure that we have enough output buffer space
    //
    if (bufferLength > outputLength) {

        Irp->IoStatus.Information = sizeof(ACPI_EVAL_OUTPUT_BUFFER);
        return STATUS_BUFFER_OVERFLOW;


    } else {

        Irp->IoStatus.Information = bufferLength;

    }

    status = ACPIIoctlCalculateOutputBuffer(
        ObjectData,
        arg,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        //
        // We don't understand a data type in the handling of the data, so we
        // won't return anything
        //
        Irp->IoStatus.Information = 0;
        return STATUS_SUCCESS;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIIoctlEvalPreProcessing(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack,
    IN  POOL_TYPE           PoolType,
    OUT PNSOBJ              *MethodObject,
    OUT POBJDATA            *ResultData,
    OUT POBJDATA            *ArgumentData,
    OUT ULONG               *ArgumentCount
    )
/*++

Routine Description:

    This routine converts the request in an Irp into the structures
    required by the AML Interpreter

    N.B. This routine does *not* complete the irp. The caller must
    do that. This routine is also *not* pageable

Arguments:

    Irp             - The request
    IrpStack        - The current stack location in the request
    PoolType        - Which type of memory to allocate
    MethodObject    - Pointer to which object to run
    ResultData      - Pointer to where to store the result
    ArgumentData    - Pointer to the arguments
    ArgumentCount   - Potiner to the number of arguments

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PACPI_EVAL_INPUT_BUFFER inputBuffer;
    PNSOBJ                  acpiObject;
    PNSOBJ                  methodObject;
    POBJDATA                argumentData = NULL;
    POBJDATA                resultData = NULL;
    UCHAR                   methodName[5];
    ULONG                   argumentCount = 0;
    ULONG                   inputLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    ULONG                   outputLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Do this step before we do anything else --- this way we won't
    // overwrite anything is someone tries to return some data
    //
    Irp->IoStatus.Information = 0;

    //
    // Is the irp have a minimum size buffer?
    //
    if (inputLength < sizeof(ACPI_EVAL_INPUT_BUFFER) ) {

        return STATUS_INFO_LENGTH_MISMATCH;

    }

    //
    // Do we have a non-null output length? if so, then it must meet the
    // minimum size
    //
    if (outputLength != 0 && outputLength < sizeof(ACPI_EVAL_OUTPUT_BUFFER)) {

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    // Grab a pointer at the input buffer
    //
    inputBuffer = (PACPI_EVAL_INPUT_BUFFER) Irp->AssociatedIrp.SystemBuffer;

    //
    // Convert the name to a null terminated string
    //
    RtlZeroMemory( methodName, 5 * sizeof(UCHAR) );
    RtlCopyMemory( methodName, inputBuffer->MethodName, sizeof(NAMESEG) );

    //
    // Search for the name space object that corresponds to the one that we
    // being asked about
    //
    acpiObject = OSConvertDeviceHandleToPNSOBJ( DeviceObject );
    if (acpiObject == NULL) {

        return STATUS_NO_SUCH_DEVICE;

    }
    status = AMLIGetNameSpaceObject(
        methodName,
        acpiObject,
        &methodObject,
        NSF_LOCAL_SCOPE
        );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Allocate memory for return data
    //
    resultData = ExAllocatePoolWithTag( PoolType, sizeof(OBJDATA), 'RcpA' );
    if (resultData == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // What we do is really based on what the signature in this buffer is
    //
    switch (inputBuffer->Signature) {
        case ACPI_EVAL_INPUT_BUFFER_SIGNATURE:

            //
            // Nothing to do here
            //
            break;

        case ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_SIGNATURE:
        case ACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING_SIGNATURE:

            //
            // We need to create a single argument to pass to the function
            //
            argumentCount = 1;
            argumentData = ExAllocatePoolWithTag(
                PoolType,
                sizeof(OBJDATA),
                'AcpA'
                );
            if (argumentData == NULL) {

                ExFreePool( resultData );
                return STATUS_INSUFFICIENT_RESOURCES;

            }

            //
            // Initialize the argument to the proper value
            //
            RtlZeroMemory( argumentData, sizeof(OBJDATA) );
            if (inputBuffer->Signature == ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_SIGNATURE) {

                PACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER integerBuffer;

                integerBuffer = (PACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER) inputBuffer;

                argumentData->dwDataType = OBJTYPE_INTDATA;
                argumentData->uipDataValue = integerBuffer->IntegerArgument;

            } else {

                PACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING stringBuffer;

                stringBuffer = (PACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING) inputBuffer;

                argumentData->dwDataType = OBJTYPE_STRDATA;
                argumentData->dwDataLen = stringBuffer->StringLength;
                argumentData->pbDataBuff = stringBuffer->String;

            }
            break;

        case ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE: {

            PACPI_EVAL_INPUT_BUFFER_COMPLEX complexBuffer;
            PACPI_METHOD_ARGUMENT           methodArgument;
            ULONG                           i;

            complexBuffer = (PACPI_EVAL_INPUT_BUFFER_COMPLEX) inputBuffer;

            //
            // Do we need to create any arguments?
            //
            if (complexBuffer->ArgumentCount == 0) {

                break;
            }

            //
            // Create the object data structures to hold these arguments
            //
            argumentCount = complexBuffer->ArgumentCount;
            methodArgument = complexBuffer->Argument;
            argumentData = ExAllocatePoolWithTag(
                PoolType,
                sizeof(OBJDATA) * argumentCount,
                'AcpA'
                );
            if (argumentData == NULL) {

                ExFreePool( resultData );
                return STATUS_INSUFFICIENT_RESOURCES;

            }

            RtlZeroMemory( argumentData, argumentCount * sizeof(OBJDATA) );
            for (i = 0; i < argumentCount; i++) {

                if (methodArgument->Type == ACPI_METHOD_ARGUMENT_INTEGER) {

                    (argumentData[i]).dwDataType = OBJTYPE_INTDATA;
                    (argumentData[i]).uipDataValue = methodArgument->Argument;

                } else {

                    (argumentData[i]).dwDataLen = methodArgument->DataLength;
                    (argumentData[i]).pbDataBuff = methodArgument->Data;
                    if (methodArgument->Type == ACPI_METHOD_ARGUMENT_STRING) {

                        (argumentData[i]).dwDataType = OBJTYPE_STRDATA;

                    } else {

                        (argumentData[i]).dwDataType = OBJTYPE_BUFFDATA;

                    }

                }

                //
                // Look at the next method
                //
                methodArgument = ACPI_METHOD_NEXT_ARGUMENT( methodArgument );

            }

            break;

        }
        default:

            return STATUS_INVALID_PARAMETER_1;

    }

    //
    // Set the proper pointers
    //
    *MethodObject = methodObject;
    *ResultData = resultData;
    *ArgumentData = argumentData;
    *ArgumentCount = argumentCount;

    //
    // Done pre-processing
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIIoctlRegisterOpRegionHandler(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This routine handle the registration of the an Operation Region

Arguments:

    DeviceObject    - The DeviceObject that the region is getting
                      registered on
    Irp             - The request
    IrpStack        - Our part of the request

Return Value

    Status

--*/
{
    NTSTATUS                                    status;
    PACPI_REGISTER_OPREGION_HANDLER_BUFFER      inputBuffer;
    PACPI_UNREGISTER_OPREGION_HANDLER_BUFFER    outputBuffer;
    PNSOBJ                                      regionObject;
    PVOID                                       opregionObject;
    ULONG                                       accessType;
    ULONG                                       inputLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    ULONG                                       outputLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ULONG                                       regionSpace;

    //
    // Grab the acpi object that corresponds to the current one
    //
    regionObject  = OSConvertDeviceHandleToPNSOBJ( DeviceObject );

    //
    // Preload this value. This is so that we don't have to remember how
    // many bytes we will return
    //
    Irp->IoStatus.Information = sizeof(ACPI_REGISTER_OPREGION_HANDLER_BUFFER);

    //
    // Is the irp have a minimum size buffer?
    //
    if (inputLength < sizeof(ACPI_REGISTER_OPREGION_HANDLER_BUFFER) ) {

        status = STATUS_INFO_LENGTH_MISMATCH;
        goto ACPIIoctlRegisterOpRegionHandlerExit;

    }

    //
    // Do we have a non-null output length? if so, then it must meet the
    // minimum size
    //
    if (outputLength < sizeof(ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER) ) {

        status = STATUS_BUFFER_TOO_SMALL;
        goto ACPIIoctlRegisterOpRegionHandlerExit;

    }

    //
    // Grab a pointer at the input buffer
    //
    inputBuffer = (PACPI_REGISTER_OPREGION_HANDLER_BUFFER)
        Irp->AssociatedIrp.SystemBuffer;

    //
    // Is this an input buffer?
    //
    if (inputBuffer->Signature != ACPI_REGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE) {

        status = STATUS_ACPI_INVALID_DATA;
        goto ACPIIoctlRegisterOpRegionHandlerExit;

    }

    //
    // Set the correct access type
    //
    switch (inputBuffer->AccessType) {
        case ACPI_OPREGION_ACCESS_AS_RAW:

            accessType = EVTYPE_RS_RAWACCESS;
            break;

        case ACPI_OPREGION_ACCESS_AS_COOKED:

            accessType = EVTYPE_RS_COOKACCESS;
            break;

        default:

            status = STATUS_ACPI_INVALID_DATA;
            goto ACPIIoctlRegisterOpRegionHandlerExit;
    }

    //
    // Set the correct region space
    //
    switch (inputBuffer->RegionSpace) {
        case ACPI_OPREGION_REGION_SPACE_MEMORY:

            regionSpace = REGSPACE_MEM;
            break;

        case ACPI_OPREGION_REGION_SPACE_IO:

            regionSpace = REGSPACE_IO;
            break;

        case ACPI_OPREGION_REGION_SPACE_PCI_CONFIG:

            regionSpace = REGSPACE_PCICFG;
            break;

        case ACPI_OPREGION_REGION_SPACE_EC:

            regionSpace = REGSPACE_EC;
            break;

        case ACPI_OPREGION_REGION_SPACE_SMB:

            regionSpace = REGSPACE_SMB;
            break;

        case ACPI_OPREGION_REGION_SPACE_CMOS_CONFIG:

            regionSpace = REGSPACE_CMOSCFG;
            break;

        case ACPI_OPREGION_REGION_SPACE_PCIBARTARGET:

            regionSpace = REGSPACE_PCIBARTARGET;
            break;

        default:

            if (inputBuffer->RegionSpace >= 0x80 &&
                inputBuffer->RegionSpace <= 0xff ) {

                //
                // This one is vendor-defined.  Just use
                // the value that the vendor passed in.
                //

                regionSpace = inputBuffer->RegionSpace;
                break;
            }

            status = STATUS_ACPI_INVALID_DATA;
            goto ACPIIoctlRegisterOpRegionHandlerExit;
    }

    //
    // Evaluate the registration
    //
    status = RegisterOperationRegionHandler(
        regionObject,
        accessType,
        regionSpace,
        (PFNHND) inputBuffer->Handler,
        (ULONG_PTR)inputBuffer->Context,
        &opregionObject
        );

    //
    // If we succeeded, then setup the output buffer
    //
    if (NT_SUCCESS(status)) {

        outputBuffer = (PACPI_UNREGISTER_OPREGION_HANDLER_BUFFER)
            Irp->AssociatedIrp.SystemBuffer;
        outputBuffer->Signature = ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE;
        outputBuffer->OperationRegionObject = opregionObject;
        Irp->IoStatus.Information =
            sizeof(ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER);

    }

ACPIIoctlRegisterOpRegionHandlerExit:

    //
    // Done with the request
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // return with the status code
    //
    return status;
}

NTSTATUS
ACPIIoctlReleaseGlobalLock(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This routine is called to release the global lock

Arguments:

    DeviceObject    - The Device object that is releasing the lock
    Irp             - The request
    IrpStack        - Our part of the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                            status;
    PACPI_GLOBAL_LOCK                   acpiLock;
    PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER inputBuffer;
    ULONG                               inputLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

    //
    // Remember that we don't be returning any data
    //
    Irp->IoStatus.Information = 0;

    //
    // Is the irp have a minimum size buffer?
    //
    if (inputLength < sizeof(ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER) ) {

        status = STATUS_INFO_LENGTH_MISMATCH;
        goto ACPIIoctlReleaseGlobalLockExit;

    }

    //
    // Grab a pointer at the input buffer
    //
    inputBuffer = (PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER)
        Irp->AssociatedIrp.SystemBuffer;
    if (inputBuffer->Signature != ACPI_RELEASE_GLOBAL_LOCK_SIGNATURE) {

        status = STATUS_INVALID_PARAMETER_1;
        goto ACPIIoctlReleaseGlobalLockExit;

    }
    acpiLock = inputBuffer->LockObject;

    //
    // Release the lock now
    //
    status = ACPIReleaseGlobalLock( acpiLock );

    //
    // Free the memory for the lock
    //
    ExFreePool( acpiLock );

ACPIIoctlReleaseGlobalLockExit:

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIIoctlUnRegisterOpRegionHandler(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This routine handle the unregistration of the an Operation Region

Arguments:

    DeviceObject    - The DeviceObject that the region is getting
                      registered on
    Irp             - The request
    IrpStack        - Our part of the request

NTSTATUS

    Status

--*/
{
    NTSTATUS                                    status;
    PACPI_UNREGISTER_OPREGION_HANDLER_BUFFER    inputBuffer;
    PNSOBJ                                      regionObject;
    ULONG                                       inputLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

    //
    // Grab the region object that corresponds to the requested on
    //
    regionObject = OSConvertDeviceHandleToPNSOBJ( DeviceObject );

    //
    // Is the irp have a minimum size buffer?
    //
    if (inputLength < sizeof(ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER) ) {

        status = STATUS_INFO_LENGTH_MISMATCH;
        goto ACPIIoctlUnRegisterOpRegionHandlerExit;

    }

    //
    // Grab a pointer at the input buffer
    //
    inputBuffer = (PACPI_UNREGISTER_OPREGION_HANDLER_BUFFER)
        Irp->AssociatedIrp.SystemBuffer;

    //
    // Evaluate the registration
    //
    status = UnRegisterOperationRegionHandler(
        regionObject,
        inputBuffer->OperationRegionObject
        );

ACPIIoctlUnRegisterOpRegionHandlerExit:

    //
    // Done with the request
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // return with the status code
    //
    return status;
}

NTSTATUS
ACPIIrpDispatchDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine handles the INTERNAL_DEVICE_CONTROLs that are sent to
    an ACPI Device Object

Arguments:

    DeviceObject    - The device object that received the request
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    ULONG               ioctlCode;

    //
    // Make sure that this is an internally generated irp
    //
    if (Irp->RequestorMode != KernelMode) {

        status = ACPIDispatchForwardIrp( DeviceObject, Irp );
        return status;

    }

    //
    // Grab what we need out of the current irp stack
    //
    ioctlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

    //
    // What is the IOCTL that we need to handle?
    //
    switch (ioctlCode ) {
        case IOCTL_ACPI_ASYNC_EVAL_METHOD:

            //
            // Handle this elsewhere
            //
            status = ACPIIoctlAsyncEvalControlMethod(
                DeviceObject,
                Irp,
                irpStack
                );
            break;

        case IOCTL_ACPI_EVAL_METHOD:

            //
            // Handle this elsewhere
            //
            status = ACPIIoctlEvalControlMethod(
                DeviceObject,
                Irp,
                irpStack
                );
            break;

        case IOCTL_ACPI_REGISTER_OPREGION_HANDLER:

            //
            // Handle this elsewhere
            //
            status = ACPIIoctlRegisterOpRegionHandler(
                DeviceObject,
                Irp,
                irpStack
                );
            break;

        case IOCTL_ACPI_UNREGISTER_OPREGION_HANDLER:

            //
            // Handle this elsewhere
            //
            status = ACPIIoctlUnRegisterOpRegionHandler(
                DeviceObject,
                Irp,
                irpStack
                );
            break;

        case IOCTL_ACPI_ACQUIRE_GLOBAL_LOCK:

            //
            // Handle this elsewhere
            //
            status = ACPIIoctlAcquireGlobalLock(
                DeviceObject,
                Irp,
                irpStack
                );
            break;

        case IOCTL_ACPI_RELEASE_GLOBAL_LOCK:

            //
            // Handle this elsewhere
            //
            status = ACPIIoctlReleaseGlobalLock(
                DeviceObject,
                Irp,
                irpStack
                );
            break;

        default:

            //
            // Handle this with the default mechanism
            //
            status = ACPIDispatchForwardIrp( DeviceObject, Irp );

    }

    //
    // Done
    //
    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpiinit.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiinit.h

Abstract:

    ACPI OS Independent initialization routines

Author:

    Jason Clark (JasonCl)
    Stephane Plante (SPlante)

Environment:

    NT Kernel Model Driver only

Revision History:

--*/

#ifndef _ACPIINIT_H_
#define _ACPIINIT_H_

    extern PACPIInformation AcpiInformation;
    extern PRSDTINFORMATION RsdtInformation;
    extern PNSOBJ           ProcessorList[];

    BOOLEAN
    ACPIInitialize(
        IN  PVOID   Context
        );

    NTSTATUS
    ACPIInitializeAMLI(
        VOID
        );

    NTSTATUS
    ACPIInitializeDDB(
        IN  ULONG   Index
        );

    NTSTATUS
    ACPIInitializeDDBs(
        VOID
        );

    ULONG
    GetPBlkAddress(
        IN  UCHAR   Processor
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpigpio.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    acpigpio.h

Abstract:

    contains all the structures related to reading/writting to directly
    to the GP IO registers

Environment:

    Kernel mode only

Revision History:

    03/22/00 - Initial Revision

--*/

#ifndef _ACPIGPIO_H_
#define _ACPIGPIO_H_

    UCHAR
    ACPIReadGpeStatusRegister (
        ULONG                   Register
        );

    VOID
    ACPIWriteGpeStatusRegister (
        ULONG                   Register,
        UCHAR                   Value
        );

    VOID
    ACPIWriteGpeEnableRegister (
        ULONG                   Register,
        UCHAR                   Value
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpiio.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiio.h

Abstract:

    ACPI OS Independent I/O routines

    We probably need a spinlock or some other form of protection to
    make the split read and writes atomic

Author:

    Jason Clark (JasonCl)
    Stephane Plante (SPlante)

Environment:

    NT Kernel Model Driver only

Revision History:

    Eric Nelson    October, '98 - Add READ/WRITE_ACPI_REGISTER

--*/

#ifndef _ACPIIO_H_
#define _ACPIIO_H_

    //
    // Flags for WRITE_PM1_CONTROL
    //
    #define WRITE_REGISTER_A_BIT        0
    #define WRITE_REGISTER_A            (1 << WRITE_REGISTER_A_BIT)
    #define WRITE_REGISTER_B_BIT        1
    #define WRITE_REGISTER_B            (1 << WRITE_REGISTER_B_BIT)
    #define WRITE_SCI_BIT               2
    #define WRITE_SCI                   (1 << WRITE_SCI_BIT)
    #define WRITE_REGISTER_A_AND_B      WRITE_REGISTER_A+WRITE_REGISTER_B
    #define WRITE_REGISTER_A_AND_B_SCI  WRITE_REGISTER_A+WRITE_REGISTER_B+WRITE_SCI

    ULONG
    ACPIIoReadPm1Status(
        VOID
        );

    VOID
    CLEAR_PM1_STATUS_BITS(
        USHORT BitMask
        );
    #define ACPIIoClearPm1Status        CLEAR_PM1_STATUS_BITS

    VOID
    CLEAR_PM1_STATUS_REGISTER(
        VOID
        );

    USHORT
    READ_PM1_CONTROL(
        VOID
        );

    USHORT
    READ_PM1_ENABLE(
        VOID
        );

    USHORT
    READ_PM1_STATUS(
        VOID
        );

    VOID
    WRITE_PM1_CONTROL(
        USHORT Value,
        BOOLEAN Destructive,
        ULONG Flags
        );

    VOID
    WRITE_PM1_ENABLE(
        USHORT Value
        );

//
// From acpiio.c, these point to DefRead/WriteAcpiRegister
// by default (x86)
//
extern PREAD_ACPI_REGISTER  AcpiReadRegisterRoutine;
extern PWRITE_ACPI_REGISTER AcpiWriteRegisterRoutine;

//
// All ACPI register accesses is now done via these macros
//
#define READ_ACPI_REGISTER(AcpiReg, Register) ((*AcpiReadRegisterRoutine)((AcpiReg), (Register)))

#define WRITE_ACPI_REGISTER(AcpiReg, Register, Value) ((*AcpiWriteRegisterRoutine)((AcpiReg), (Register), (Value)))

#endif // _ACPIIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\driver\shared\acpiinit.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiinit.c

Abstract:

    ACPI OS Independent initialization routines

Author:

    Jason Clark (JasonCl)
    Stephane Plante (SPlante)

Environment:

    NT Kernel Model Driver only

Revision History:

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIInitialize)
#pragma alloc_text(PAGE,ACPIInitializeAMLI)
#pragma alloc_text(PAGE,ACPIInitializeDDB)
#pragma alloc_text(PAGE,ACPIInitializeDDBs)
#pragma alloc_text(PAGE,GetPBlkAddress)
#endif

#ifdef DBG
#define VERIFY_IO_WRITES
#endif

//
// Pointer to global ACPIInformation structure.
//
PACPIInformation        AcpiInformation = NULL;

//
// Global structure for Pnp/QUERY_INTERFACE
//
ACPI_INTERFACE_STANDARD ACPIInterfaceTable;
PNSOBJ                  ProcessorList[ACPI_SUPPORTED_PROCESSORS];
PRSDTINFORMATION        RsdtInformation;

//
// Remember how many contexts we have reserved for the interpreter
//
ULONG                   AMLIMaxCTObjs;


BOOLEAN
ACPIInitialize(
    PVOID Context
    )
/*++

Routine Description:

    This routine is called by the OS to detect ACPI, store interesting
    information in the global data structure, enables ACPI on the machine,
    and finally load the DSDT

Arguments:

    Context - The context to back to the OS upon a callback. Typically a
              deviceObject

Return Value:

    BOOLEAN
        - TRUE if ACPI was found
        - FALSE, otherwise

--*/
{
    BOOLEAN     bool;
    NTSTATUS    status;
    PRSDT       rootSystemDescTable;

    PAGED_CODE();

    //
    // Initialize the interpreter
    //
    status = ACPIInitializeAMLI();
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIInitialize: AMLI failed initialization 0x%08lx\n",
            status
            ) );
        ASSERTMSG(
            "ACPIInitialize: AMLI failed initialization\n",
            NT_SUCCESS(status)
            );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            0,
            0,
            0
            );

    }

    //
    // Get the linear address of the RSDT of NULL if ACPI is not present on
    // the System
    //
    rootSystemDescTable = ACPILoadFindRSDT();
    if ( rootSystemDescTable == NULL ) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIInitialize: ACPI RSDT Not Found\n"
            ) );
        ASSERTMSG(
            "ACPIInitialize: ACPI RSDT Not Found\n",
            rootSystemDescTable
            );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            1,
            0,
            0
            );

    }

    //
    // ACPI is alive and well on this machine.
    //
    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPIInitalize: ACPI RSDT found at 0x%08lx\n",
        rootSystemDescTable
        ) );

    //
    // Initialize table used for MJ_PNP/MN_QUERY_INTERFACE requests
    //
    ACPIInterfaceTable.Size                             = sizeof (ACPIInterfaceTable);
    ACPIInterfaceTable.GpeConnectVector                 = ACPIVectorConnect;
    ACPIInterfaceTable.GpeDisconnectVector              = ACPIVectorDisconnect;
    ACPIInterfaceTable.GpeEnableEvent                   = ACPIVectorEnable;
    ACPIInterfaceTable.GpeDisableEvent                  = ACPIVectorDisable;
    ACPIInterfaceTable.GpeClearStatus                   = ACPIVectorClear;
    ACPIInterfaceTable.RegisterForDeviceNotifications   = ACPIRegisterForDeviceNotifications;
    ACPIInterfaceTable.UnregisterForDeviceNotifications = ACPIUnregisterForDeviceNotifications;
    ACPIInterfaceTable.InterfaceReference               = AcpiNullReference;
    ACPIInterfaceTable.InterfaceDereference             = AcpiNullReference;
    ACPIInterfaceTable.Context                          = Context;
    ACPIInterfaceTable.Version                          = 1;

    //
    // Initialize global data structures
    //
    KeInitializeSpinLock (&GpeTableLock);
    KeInitializeSpinLock (&NotifyHandlerLock);
    ProcessorList[0] = 0;
    RtlZeroMemory( ProcessorList, ACPI_SUPPORTED_PROCESSORS * sizeof(PNSOBJ) );

    //
    // Allocate some memory to hold the ACPI Information structure.
    //
    AcpiInformation = (PACPIInformation) ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(ACPIInformation),
        ACPI_SHARED_INFORMATION_POOLTAG
        );
    if ( AcpiInformation == NULL ) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIInitialize: Could not allocate AcpiInformation (x%x bytes)\n",
            sizeof(ACPIInformation)
            ) );
        ASSERTMSG(
            "ACPIInitialize: Could not allocate AcpiInformation\n",
            AcpiInformation
            );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            2,
            0,
            0
            );

    }
    RtlZeroMemory( AcpiInformation, sizeof(ACPIInformation) );
    AcpiInformation->ACPIOnly = TRUE;
    AcpiInformation->RootSystemDescTable = rootSystemDescTable;

    //
    // Initialize queue, lock, and owner info for the Global Lock.
    // This must be done before we ever call the interpreter!
    //
    KeInitializeSpinLock( &AcpiInformation->GlobalLockQueueLock );
    InitializeListHead( &AcpiInformation->GlobalLockQueue );
    AcpiInformation->GlobalLockOwnerContext = NULL;
    AcpiInformation->GlobalLockOwnerDepth = 0;

    //
    // Initialize most of the remaining fields in the AcpiInformation structure.
    // This function will return FALSE in case of a problem finding the required
    //  tables
    //
    status = ACPILoadProcessRSDT();
    if ( !NT_SUCCESS(status) ) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIInitialize: ACPILoadProcessRSDT = 0x%08lx\n",
            status
            ) );
        ASSERTMSG(
            "ACPIInitialize: ACPILoadProcessRSDT Failed\n",
            NT_SUCCESS(status)
            );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            3,
            0,
            0
            );

    }

    //
    // Now switch the machine into ACPI mode and initialize
    // the ACPI registers.
    //
    ACPIEnableInitializeACPI( FALSE );

    //
    // At this point, we can load all of the DDBs. We need to load all of
    // these tables *before* we try to enable any GPEs or Interrupt Vectors
    //
    status = ACPIInitializeDDBs();
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIInitialize: ACPIInitializeLoadDDBs = 0x%08lx\n",
            status
            ) );
        ASSERTMSG(
            "ACPIInitialize: ACPIInitializeLoadDDBs Failed\n",
            NT_SUCCESS(status)
            );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            4,
            0,
            0
            );

    }

    //
    // Hook the SCI Vector
    //
    bool = OSInterruptVector(
        Context
        );
    if ( !bool ) {

        //
        // Ooops... We were unable to hook the SCI vector.  Clean Up and
        // fail to load.
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIInitialize: OSInterruptVector Failed!!\n"
            ) );
        ASSERTMSG(
            "ACPIInitialize: OSInterruptVector Failed!!\n",
            bool
            );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            5,
            0,
            0
            );

    }

    return (TRUE);
}

NTSTATUS
ACPIInitializeAMLI(
    VOID
    )
/*++

Routine Description:

    Called by ACPIInitialize to init the interpreter. We go and read
    some values from the registry to decide what to initialize the
    interpreter with

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    ULONG       amliInitFlags;
    ULONG       contextBlockSize;
    ULONG       globalHeapBlockSize;
    ULONG       timeSliceLength;
    ULONG       timeSliceInterval;
    ULONG       argSize;

    PAGED_CODE();

    //
    // Initialize AMLI
    //
    argSize = sizeof(amliInitFlags);
    status = OSReadRegValue(
        "AMLIInitFlags",
        (HANDLE) NULL,
        &amliInitFlags,
        &argSize
        );
    if (!NT_SUCCESS(status) ) {

        amliInitFlags = 0;

    }

    argSize = sizeof(contextBlockSize);
    status = OSReadRegValue(
        "AMLICtxtBlkSize",
        (HANDLE) NULL,
        &contextBlockSize,
        &argSize
        );
    if (!NT_SUCCESS(status) ) {

        contextBlockSize = 0;

    }

    argSize = sizeof(globalHeapBlockSize);
    status = OSReadRegValue(
        "AMLIGlobalHeapBlkSize",
        (HANDLE) NULL,
        &globalHeapBlockSize,
        &argSize
        );
    if (!NT_SUCCESS(status) ) {

        globalHeapBlockSize = 0;

    }

    argSize = sizeof(timeSliceLength);
    status = OSReadRegValue(
        "AMLITimeSliceLength",
        (HANDLE) NULL,
        &timeSliceLength,
        &argSize
        );
    if (!NT_SUCCESS(status) ) {

        timeSliceLength = 0;

    }

    argSize = sizeof(timeSliceInterval);
    status = OSReadRegValue(
        "AMLITimeSliceInterval",
        (HANDLE) NULL,
        &timeSliceInterval,
        &argSize
        );
    if (!NT_SUCCESS(status) ) {

        timeSliceInterval = 0;

    }

    argSize = sizeof(AMLIMaxCTObjs);
    status = OSReadRegValue(
        "AMLIMaxCTObjs",
        (HANDLE) NULL,
        &AMLIMaxCTObjs,
        &argSize
        );
    if (!NT_SUCCESS(status)) {

        AMLIMaxCTObjs = 0;

    }

    //
    // Allow the OSes to do some work once the interperter has been loaded
    //
    OSInitializeCallbacks();

    //
    // Initialize the interpreter
    //
    return AMLIInitialize(
        contextBlockSize,
        globalHeapBlockSize,
        amliInitFlags,
        timeSliceLength,
        timeSliceInterval,
        AMLIMaxCTObjs
        );
}

NTSTATUS
ACPIInitializeDDB(
    IN  ULONG   Index
    )
/*++

Routine Description:

    This routine is called to load the specificied Differentiated Data Block

Arguments:

    Index   - Index of information in the RsdtInformation

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN     success;
    HANDLE      diffDataBlock = NULL;
    NTSTATUS    status;
    PDSDT       table;

    PAGED_CODE();

    //
    // Convert the index into a table entry
    //
    table = (PDSDT) (RsdtInformation->Tables[Index].Address);

    //
    // Make sure that the checksum of the table is correct
    //
    success = ACPILoadTableCheckSum( table, table->Header.Length );
    if (success == FALSE) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            7,
            (ULONG_PTR) table,
            table->Header.CreatorRev
            );


    }

    //
    // Now call the Interpreter to read the Differentiated System
   